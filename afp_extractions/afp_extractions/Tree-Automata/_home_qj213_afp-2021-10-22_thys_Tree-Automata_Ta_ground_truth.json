{"file_name": "/home/qj213/afp-2021-10-22/thys/Tree-Automata/Ta.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tree-Automata", "problem_names": ["lemma accs_laz: \"accs = accs_laz\"", "lemma rule_states_simp: \n  \"rule_states x = (case x of (q \\<rightarrow> l qs) \\<Rightarrow> insert q (set qs))\"", "lemma rule_states_lhs[simp]: \"lhs r \\<in> rule_states r\"", "lemma rule_states_rhsq: \"set (rhsq r) \\<subseteq> rule_states r\"", "lemma rule_states_finite[simp, intro!]: \"finite (rule_states r)\"", "lemma \\<delta>_statesI: \n  assumes A: \"(q \\<rightarrow> l qs)\\<in>\\<delta>\"\n  shows \"q\\<in>\\<delta>_states \\<delta>\"\n        \"set qs \\<subseteq> \\<delta>_states \\<delta>\"", "lemma \\<delta>_statesI': \"\\<lbrakk>(q \\<rightarrow> l qs)\\<in>\\<delta>; qi\\<in>set qs\\<rbrakk> \\<Longrightarrow> qi\\<in>\\<delta>_states \\<delta>\"", "lemma \\<delta>_states_accsI: \"accs \\<delta> n q \\<Longrightarrow> q\\<in>\\<delta>_states \\<delta>\"", "lemma \\<delta>_states_union[simp]: \"\\<delta>_states (\\<delta>\\<union>\\<delta>') = \\<delta>_states \\<delta> \\<union> \\<delta>_states \\<delta>'\"", "lemma \\<delta>_states_insert[simp]: \n  \"\\<delta>_states (insert r \\<delta>) = (rule_states r \\<union> \\<delta>_states \\<delta>)\"", "lemma \\<delta>_states_mono: \"\\<lbrakk>\\<delta> \\<subseteq> \\<delta>'\\<rbrakk> \\<Longrightarrow> \\<delta>_states \\<delta> \\<subseteq> \\<delta>_states \\<delta>'\"", "lemma \\<delta>_states_finite[simp, intro]: \"finite \\<delta> \\<Longrightarrow> finite (\\<delta>_states \\<delta>)\"", "lemma \\<delta>_statesE: \"\\<lbrakk>q\\<in>\\<delta>_states \\<Delta>;\n    !!f qs. \\<lbrakk> (q \\<rightarrow> f qs)\\<in>\\<Delta> \\<rbrakk> \\<Longrightarrow> P;\n    !!ql f qs. \\<lbrakk> (ql \\<rightarrow> f qs)\\<in>\\<Delta>; q\\<in>set qs \\<rbrakk> \\<Longrightarrow> P\n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma \\<delta>_symbolsI: \"(q \\<rightarrow> f qs)\\<in>\\<delta> \\<Longrightarrow> f\\<in>\\<delta>_symbols \\<delta>\"", "lemma \\<delta>_symbolsE: \n  assumes A: \"f\\<in>\\<delta>_symbols \\<delta>\"\n  obtains q qs where \"(q \\<rightarrow> f qs) \\<in> \\<delta>\"", "lemma \\<delta>_symbols_simps[simp]:\n  \"\\<delta>_symbols {} = {}\"\n  \"\\<delta>_symbols (insert r \\<delta>) = insert (rhsl r) (\\<delta>_symbols \\<delta>)\"\n  \"\\<delta>_symbols (\\<delta>\\<union>\\<delta>') = \\<delta>_symbols \\<delta> \\<union> \\<delta>_symbols \\<delta>'\"", "lemma \\<delta>_symbols_finite[simp, intro!]:\n  \"finite \\<delta> \\<Longrightarrow> finite (\\<delta>_symbols \\<delta>)\"", "lemma accs_mono: \"\\<lbrakk>accs \\<delta> n q; \\<delta>\\<subseteq>\\<delta>'\\<rbrakk> \\<Longrightarrow> accs \\<delta>' n q\"", "lemma initial_subset: \"ta_initial TA \\<subseteq> ta_rstates TA\"", "lemma states_subset: \"\\<delta>_states (ta_rules TA) \\<subseteq> ta_rstates TA\"", "lemma finite_states[simp, intro!]: \"finite (ta_rstates TA)\"", "lemma finite_symbols[simp, intro!]: \"finite (\\<delta>_symbols (ta_rules TA))\"", "lemmas is_subset = rev_subsetD[OF _ initial_subset] \n                     rev_subsetD[OF _ states_subset]", "lemma legal_rulesI: \n    \"\\<lbrakk> \n      r\\<in>\\<delta>; \n      rule_states r \\<subseteq> Q; \n      A (rhsl r) = Some (length (rhsq r)) \n    \\<rbrakk> \\<Longrightarrow> r\\<in>legal_rules Q\"", "lemma legal_rules_finite[simp, intro!]:\n    fixes Q::\"'Q set\"\n    assumes [simp, intro!]: \"finite Q\"\n    shows \"finite (legal_rules Q)\"", "lemma rules_legal: \"r\\<in>\\<delta> \\<Longrightarrow> r\\<in>legal_rules Q\"", "lemma accs_is_ranked: \"accs \\<delta> t q \\<Longrightarrow> t\\<in>ranked_trees A\"", "theorem lang_is_ranked: \"ta_lang TA \\<subseteq> ranked_trees A\"", "theorem accs_unique: \"\\<lbrakk> accs \\<delta> t q; accs \\<delta> t q' \\<rbrakk> \\<Longrightarrow> q=q'\"", "theorem label_all: \"t\\<in>ranked_trees A \\<Longrightarrow> \\<exists>q\\<in>Q. accs \\<delta> t q\"", "theorem ta_empty_lang[simp]: \"ta_lang ta_empty = {}\"", "theorem ta_empty_ta[simp, intro!]: \"tree_automaton ta_empty\"", "theorem (in finite_alphabet) ta_empty_rta[simp, intro!]: \n  \"ranked_tree_automaton ta_empty A\"", "theorem (in finite_alphabet) ta_empty_dta[simp, intro!]: \n  \"det_tree_automaton ta_empty A\"", "lemma \\<delta>_states_remap[simp]: \"\\<delta>_states (remap_rule f ` \\<delta>) = f` \\<delta>_states \\<delta>\"", "lemma remap_accs1: \"accs \\<delta> n q \\<Longrightarrow> accs (remap_rule f ` \\<delta>) n (f q)\"", "lemma remap_lang1: \"t\\<in>ta_lang TA \\<Longrightarrow> t\\<in>ta_lang (ta_remap f TA)\"", "lemma remap_accs2: \"\\<lbrakk> \n    accs \\<delta>' n q'; \n    \\<delta>'=(remap_rule f ` \\<delta>); \n    q'=f q; \n    inj_on f Q; \n    q\\<in>Q; \n    \\<delta>_states \\<delta> \\<subseteq> Q \n  \\<rbrakk> \\<Longrightarrow> accs \\<delta> n q\"", "lemma (in tree_automaton) remap_lang2: \n  assumes I: \"inj_on f (ta_rstates TA)\" \n  shows \"t\\<in>ta_lang (ta_remap f TA) \\<Longrightarrow> t\\<in>ta_lang TA\"", "theorem (in tree_automaton) remap_lang: \n  \"inj_on f (ta_rstates TA) \\<Longrightarrow> ta_lang (ta_remap f TA) = ta_lang TA\"", "lemma (in tree_automaton) remap_ta[intro!, simp]: \n  \"tree_automaton (ta_remap f TA)\"", "lemma (in ranked_tree_automaton) remap_rta[intro!, simp]:\n  \"ranked_tree_automaton (ta_remap f TA) A\"", "lemma (in det_tree_automaton) remap_dta[intro, simp]:\n  assumes INJ: \"inj_on f Q\"\n  shows \"det_tree_automaton (ta_remap f TA) A\"", "lemma (in complete_tree_automaton) remap_cta[intro, simp]:\n  assumes INJ: \"inj_on f Q\"\n  shows \"complete_tree_automaton (ta_remap f TA) A\"", "lemma accs_exclusive_aux: \n  \"\\<lbrakk> accs \\<delta>n n q; \\<delta>n=\\<delta>\\<union>\\<delta>'; \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {}; q\\<in>\\<delta>_states \\<delta> \\<rbrakk> \n   \\<Longrightarrow> accs \\<delta> n q\"", "lemma ta_union_correct_aux1: \n  fixes TA TA'\n  assumes TA: \"tree_automaton TA\"\n  assumes TA': \"tree_automaton TA'\"\n  assumes DJ: \"ta_rstates TA \\<inter> ta_rstates TA' = {}\" \n  shows \"ta_lang (ta_union TA TA') = ta_lang TA \\<union> ta_lang TA'\"", "lemma ta_union_correct_aux2: \n  fixes TA TA'\n  assumes TA: \"tree_automaton TA\"\n  assumes TA': \"tree_automaton TA'\"\n  shows \"tree_automaton (ta_union TA TA')\"", "theorem ta_union_correct:\n  fixes TA TA'\n  assumes TA: \"tree_automaton TA\"\n  assumes TA': \"tree_automaton TA'\"\n  assumes DJ: \"ta_rstates TA \\<inter> ta_rstates TA' = {}\" \n  shows \"ta_lang (ta_union TA TA') = ta_lang TA \\<union> ta_lang TA'\"\n        \"tree_automaton (ta_union TA TA')\"", "lemma ta_union_rta: \n  fixes TA TA'\n  assumes TA: \"ranked_tree_automaton TA A\"\n  assumes TA': \"ranked_tree_automaton TA' A\"\n  shows \"ranked_tree_automaton (ta_union TA TA') A\"", "lemma usw_disjoint[simp]: \n  \"USW1 ` X \\<inter> USW2 ` Y = {}\"\n  \"remap_rule USW1 ` X \\<inter> remap_rule USW2 ` Y = {}\"", "lemma states_usw_disjoint[simp]: \n  \"ta_rstates (ta_remap USW1 X) \\<inter> ta_rstates (ta_remap USW2 Y) = {}\"", "lemma usw_inj_on[simp, intro!]:\n  \"inj_on USW1 X\" \n  \"inj_on USW2 X\"", "lemma ta_union_wrap_correct:\n  fixes TA :: \"('Q1,'L) tree_automaton_rec\"\n  fixes TA' :: \"('Q2,'L) tree_automaton_rec\"\n  assumes TA: \"tree_automaton TA\"\n  assumes TA': \"tree_automaton TA'\"\n  shows \"ta_lang (ta_union_wrap TA TA') = ta_lang TA \\<union> ta_lang TA'\" (is ?T1)\n        \"tree_automaton (ta_union_wrap TA TA')\" (is ?T2)", "lemma ta_union_wrap_rta:\n  fixes TA TA'\n  assumes TA: \"ranked_tree_automaton TA A\"\n  assumes TA': \"ranked_tree_automaton TA' A\"\n  shows \"ranked_tree_automaton (ta_union_wrap TA TA') A\"", "lemma reduce_rulesI: \"\\<lbrakk>r\\<in>\\<delta>; rule_states r \\<subseteq> P\\<rbrakk> \\<Longrightarrow> r\\<in>reduce_rules \\<delta> P\"", "lemma reduce_rulesD: \n  \"\\<lbrakk> r\\<in>reduce_rules \\<delta> P \\<rbrakk> \\<Longrightarrow> r\\<in>\\<delta>\"\n  \"\\<lbrakk> r\\<in>reduce_rules \\<delta> P; q\\<in>rule_states r\\<rbrakk> \\<Longrightarrow> q\\<in>P\"", "lemma reduce_rules_subset: \"reduce_rules \\<delta> P \\<subseteq> \\<delta>\"", "lemma reduce_rules_mono: \"P \\<subseteq> P' \\<Longrightarrow> reduce_rules \\<delta> P \\<subseteq> reduce_rules \\<delta> P'\"", "lemma \\<delta>_states_reduce_subset: \n  shows \"\\<delta>_states (reduce_rules \\<delta> Q) \\<subseteq> \\<delta>_states \\<delta> \\<inter> Q\"", "lemmas \\<delta>_states_reduce_subsetI = rev_subsetD[OF _ \\<delta>_states_reduce_subset]", "theorem ta_reduce_inv: assumes A: \"tree_automaton TA\" \n  shows \"tree_automaton (ta_reduce TA P)\"", "lemma reduce_\\<delta>_states_rules[simp]: \n  \"(ta_rules (ta_reduce TA (\\<delta>_states (ta_rules TA)))) = ta_rules TA\"", "lemma ta_reduce_\\<delta>_states: \n  \"ta_lang (ta_reduce TA (\\<delta>_states (ta_rules TA))) = ta_lang TA\"", "lemma f_succ_alt: \"f_succ \\<delta> = {(q,q'). \\<exists>l qs. (q \\<rightarrow> l qs)\\<in>\\<delta> \\<and> q'\\<in>set qs}\"", "lemma f_accessible_alt: \"f_accessible \\<delta> Q0 = f_accessible_alt \\<delta> Q0\"", "lemmas f_accessibleI = f_accessible_alt.intros[folded f_accessible_alt]", "lemmas f_accessibleE = f_accessible_alt.cases[folded f_accessible_alt]", "lemma f_succ_finite[simp, intro]: \"finite \\<delta> \\<Longrightarrow> finite (f_succ \\<delta>)\"", "lemma f_accessible_mono: \"Q\\<subseteq>Q' \\<Longrightarrow> x\\<in>f_accessible \\<delta> Q \\<Longrightarrow> x\\<in>f_accessible \\<delta> Q'\"", "lemma f_accessible_prepend: \n  \"\\<lbrakk> (q \\<rightarrow> l qs) \\<in> \\<delta>; q'\\<in>set qs; x\\<in>f_accessible \\<delta> {q'} \\<rbrakk> \n    \\<Longrightarrow> x\\<in>f_accessible \\<delta> {q}\"", "lemma f_accessible_subset: \"q\\<in>f_accessible \\<delta> Q \\<Longrightarrow> q\\<in>Q \\<union> \\<delta>_states \\<delta>\"", "lemma (in tree_automaton) f_accessible_in_states: \n  \"q\\<in>f_accessible (ta_rules TA) (ta_initial TA) \\<Longrightarrow> q\\<in>ta_rstates TA\"", "lemma f_accessible_refl_inter_simp[simp]: \"Q \\<inter> f_accessible r Q = Q\"", "lemma accs_reduce_f_acc: \n  \"accs \\<delta> t q \\<Longrightarrow> accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) t q\"", "theorem ta_reduce_f_acc[simp]: \"ta_lang (ta_fwd_reduce TA) = ta_lang TA\"", "lemma b_accessibleI: \n  \"\\<lbrakk>(q \\<rightarrow> l qs)\\<in>\\<delta>; set qs \\<subseteq> b_accessible \\<delta>\\<rbrakk> \\<Longrightarrow> q\\<in>b_accessible \\<delta>\"", "lemma accs_is_b_accessible: \"accs \\<delta> t q \\<Longrightarrow> q\\<in>b_accessible \\<delta>\"", "lemma b_acc_subset_\\<delta>_statesI: \"x\\<in>b_accessible \\<delta> \\<Longrightarrow> x\\<in>\\<delta>_states \\<delta>\"", "lemma b_acc_subset_\\<delta>_states: \"b_accessible \\<delta> \\<subseteq> \\<delta>_states \\<delta>\"", "lemma b_acc_finite[simp, intro!]: \"finite \\<delta> \\<Longrightarrow> finite (b_accessible \\<delta>)\"", "lemma b_accessible_is_accs: \n  \"\\<lbrakk> q\\<in>b_accessible (ta_rules TA); \n     !!t. accs (ta_rules TA) t q \\<Longrightarrow> P\n   \\<rbrakk> \\<Longrightarrow> P\"", "lemma accs_reduce_b_acc: \n  \"accs \\<delta> t q \\<Longrightarrow> accs (reduce_rules \\<delta> (b_accessible \\<delta>)) t q\"", "theorem ta_reduce_b_acc[simp]: \"ta_lang (ta_bwd_reduce TA) = ta_lang TA\"", "theorem empty_if_no_b_accessible: \n  \"ta_lang TA = {} \\<longleftrightarrow> ta_initial TA \\<inter> b_accessible (ta_rules TA) = {}\"", "lemma \\<delta>_prodI: \"\\<lbrakk> \n    length qs1 = length qs2;\n    (q1 \\<rightarrow> l qs1)\\<in>\\<delta>1;\n    (q2 \\<rightarrow> l qs2)\\<in>\\<delta>2 \\<rbrakk> \\<Longrightarrow> ((q1,q2) \\<rightarrow> l (zip qs1 qs2)) \\<in> \\<delta>_prod \\<delta>1 \\<delta>2\"", "lemma \\<delta>_prodE: \n  \"\\<lbrakk> \n    r\\<in>\\<delta>_prod \\<delta>1 \\<delta>2; \n    !!q1 q2 l qs1 qs2. \\<lbrakk> length qs1 = length qs2;\n                         (q1 \\<rightarrow> l qs1)\\<in>\\<delta>1;\n                         (q2 \\<rightarrow> l qs2)\\<in>\\<delta>2;\n                         r = ((q1,q2) \\<rightarrow> l (zip qs1 qs2)) \n                       \\<rbrakk> \\<Longrightarrow> P \n   \\<rbrakk> \\<Longrightarrow> P\"", "lemma \\<delta>_prod_sound: \n  assumes A: \"accs (\\<delta>_prod \\<delta>1 \\<delta>2) t (q1,q2)\" \n  shows \"accs \\<delta>1 t q1\" \"accs \\<delta>2 t q2\"", "lemma \\<delta>_prod_precise: \n  \"\\<lbrakk> accs \\<delta>1 t q1; accs \\<delta>2 t q2 \\<rbrakk> \\<Longrightarrow> accs (\\<delta>_prod \\<delta>1 \\<delta>2) t (q1,q2)\"", "lemma \\<delta>_prod_empty[simp]: \n  \"\\<delta>_prod {} \\<delta> = {}\"\n  \"\\<delta>_prod \\<delta> {} = {}\"", "lemma \\<delta>_prod_2sng[simp]: \n  \"\\<lbrakk> rhsl r1 \\<noteq> rhsl r2 \\<rbrakk> \\<Longrightarrow> \\<delta>_prod {r1} {r2} = {}\"\n  \"\\<lbrakk> length (rhsq r1) \\<noteq> length (rhsq r2) \\<rbrakk> \\<Longrightarrow> \\<delta>_prod {r1} {r2} = {}\"\n  \"\\<lbrakk> rhsl r1 = rhsl r2; length (rhsq r1) = length (rhsq r2) \\<rbrakk> \n    \\<Longrightarrow> \\<delta>_prod {r1} {r2} = {r_prod r1 r2}\"", "lemma \\<delta>_prod_Un[simp]: \n  \"\\<delta>_prod (\\<delta>1\\<union>\\<delta>1') \\<delta>2 = \\<delta>_prod \\<delta>1 \\<delta>2 \\<union> \\<delta>_prod \\<delta>1' \\<delta>2\"\n  \"\\<delta>_prod \\<delta>1 (\\<delta>2\\<union>\\<delta>2') = \\<delta>_prod \\<delta>1 \\<delta>2 \\<union> \\<delta>_prod \\<delta>1 \\<delta>2'\"", "lemma \\<delta>_prod_sng_alt:\n  \"\\<delta>_prod_sng1 r \\<delta>2 = \\<delta>_prod {r} \\<delta>2\"\n  \"\\<delta>_prod_sng2 \\<delta>1 r = \\<delta>_prod \\<delta>1 {r}\"", "lemmas \\<delta>_prod_insert = \n  \\<delta>_prod_Un(1)[where ?\\<delta>1.0=\"{x}\", simplified, folded \\<delta>_prod_sng_alt]\n  \\<delta>_prod_Un(2)[where ?\\<delta>2.0=\"{x}\", simplified, folded \\<delta>_prod_sng_alt]\n  for x\n\n  \\<comment> \\<open>Product automaton\\<close>", "lemma ta_prod_correct_aux1: \n  \"ta_lang (ta_prod TA1 TA2) = ta_lang TA1 \\<inter> ta_lang TA2\"", "lemma \\<delta>_states_cart: \n  \"q \\<in> \\<delta>_states (\\<delta>_prod \\<delta>1 \\<delta>2) \\<Longrightarrow> q \\<in> \\<delta>_states \\<delta>1 \\<times> \\<delta>_states \\<delta>2\"", "lemma \\<delta>_prod_finite [simp, intro]: \n  \"finite \\<delta>1 \\<Longrightarrow> finite \\<delta>2 \\<Longrightarrow> finite (\\<delta>_prod \\<delta>1 \\<delta>2)\"", "lemma ta_prod_correct_aux2: \n  assumes TA: \"tree_automaton TA1\" \"tree_automaton TA2\" \n  shows \"tree_automaton (ta_prod TA1 TA2)\"", "theorem ta_prod_correct:\n  assumes TA: \"tree_automaton TA1\" \"tree_automaton TA2\" \n  shows \n    \"ta_lang (ta_prod TA1 TA2) = ta_lang TA1 \\<inter> ta_lang TA2\"\n    \"tree_automaton (ta_prod TA1 TA2)\"", "lemma ta_prod_rta: \n  assumes TA: \"ranked_tree_automaton TA1 A\" \"ranked_tree_automaton TA2 A\" \n  shows \"ranked_tree_automaton (ta_prod TA1 TA2) A\"", "lemma \\<delta>ssI: \n    assumes A: \"A f = Some (length ss)\"\n               \"ss \\<in> lists {s. s \\<subseteq> ta_rstates TA}\"\n    shows \n      \"( (\\<delta>ss_lhs f ss) \\<rightarrow> f ss) \\<in> \\<delta>ss\"", "lemma \\<delta>ss_subset[simp, intro!]: \"\\<delta>ss_lhs f ss \\<subseteq> Q\"", "lemma \\<delta>ss_finite[simp, intro!]: \"finite \\<delta>ss\"", "lemma \\<delta>ss_det: \"\\<lbrakk> (q \\<rightarrow> f qs) \\<in> \\<delta>ss; (q' \\<rightarrow> f qs) \\<in>\\<delta>ss \\<rbrakk> \\<Longrightarrow> q=q'\"", "lemma \\<delta>ss_accs_sound: \n    assumes A: \"accs \\<delta> t q\"  \n    obtains s where\n    \"s\\<subseteq>Q\"\n    \"q\\<in>s\"\n    \"accs \\<delta>ss t s\"", "lemma \\<delta>ss_accs_precise:\n    assumes A: \"accs \\<delta>ss t s\" \"q\\<in>s\"  \n    shows \"accs \\<delta> t q\"", "theorem detTA_is_ta[simp, intro]:\n    \"det_tree_automaton detTA A\"", "theorem detTA_lang[simp]:\n    \"ta_lang (detTA) = ta_lang TA\"", "lemmas detTA_correct = detTA_is_ta detTA_lang", "lemma Qcomplete_finite[simp, intro!]: \"finite Qcomplete\"", "lemma \\<delta>_states_complete: \"q\\<in>\\<delta>_states \\<delta>complete \\<Longrightarrow> q\\<in>Qcomplete\"", "lemma \\<delta>complete_finite[simp, intro]: \"finite \\<delta>complete\"", "theorem completeTA_is_ta: \"complete_tree_automaton completeTA A\"", "theorem completeTA_lang: \"ta_lang completeTA = ta_lang TA\"", "lemmas completeTA_correct = completeTA_is_ta completeTA_lang", "lemma cta_rules[simp]: \"ta_rules complementTA = \\<delta>\"", "theorem complementTA_correct:\n    \"ta_lang complementTA = ranked_trees A - ta_lang TA\" (is ?T1)\n    \"complete_tree_automaton complementTA A\" (is ?T2)", "lemma rtlE:\n  fixes L :: \"'L tree set\"\n  assumes A: \"L\\<in>regular_languages A\"\n  obtains TA::\"(nat,'L) tree_automaton_rec\" where \n    \"L=ta_lang TA\"\n    \"ranked_tree_automaton TA A\"", "lemma (in ranked_tree_automaton) rtlI[simp]:\n    shows \"ta_lang TA \\<in> regular_languages A\"", "theorem obtain_complete:\n    obtains TAC::\"('Q set option,'L) tree_automaton_rec\" where\n    \"ta_lang TAC = ta_lang TA\"\n    \"complete_tree_automaton TAC A\"", "lemma rtlE_complete:\n  fixes L :: \"'L tree set\"\n  assumes A: \"L\\<in>regular_languages A\"\n  obtains TA::\"(nat,'L) tree_automaton_rec\" where \n    \"L=ta_lang TA\"\n    \"complete_tree_automaton TA A\"", "theorem (in finite_alphabet) rtl_empty[simp, intro!]: \"{} \\<in> regular_languages A\"", "theorem rtl_union_closed: \n  \"\\<lbrakk> L1\\<in>regular_languages A; L2\\<in>regular_languages A \\<rbrakk> \n    \\<Longrightarrow> L1\\<union>L2 \\<in> regular_languages A\"", "theorem rtl_inter_closed: \n  \"\\<lbrakk>L1\\<in>regular_languages A; L2\\<in>regular_languages A\\<rbrakk> \\<Longrightarrow> \n    L1\\<inter>L2 \\<in> regular_languages A\"", "theorem rtl_complement_closed:\n  \"L\\<in>regular_languages A \\<Longrightarrow> ranked_trees A - L \\<in> regular_languages A\"", "theorem (in finite_alphabet) rtl_univ: \n  \"ranked_trees A \\<in> regular_languages A\"", "theorem rtl_diff_closed:\n  fixes L1 :: \"'L tree set\"\n  assumes A[simp]: \"L1 \\<in> regular_languages A\" \"L2\\<in>regular_languages A\" \n  shows \"L1-L2 \\<in> regular_languages A\"", "lemmas rtl_closed = finite_alphabet.rtl_empty finite_alphabet.rtl_univ \n  rtl_complement_closed\n  rtl_inter_closed rtl_union_closed rtl_diff_closed"], "translations": [["", "lemma accs_laz: \"accs = accs_laz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs = accs_laz", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb. accs x xa xb = accs_laz x xa xb", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb. accs x xa xb \\<Longrightarrow> accs_laz x xa xb\n 2. \\<And>x xa xb. accs_laz x xa xb \\<Longrightarrow> accs x xa xb", "apply (erule accs.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs_laz \\<delta> (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) q\n 2. \\<And>x xa xb. accs_laz x xa xb \\<Longrightarrow> accs x xa xb", "apply (auto intro: accs_laz.intros[simplified list_all_zip_alt])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb. accs_laz x xa xb \\<Longrightarrow> accs x xa xb", "apply (erule accs_laz.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and> accs \\<delta> x1 x2)\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (NODE f ts) q", "apply (auto intro: accs.intros simp add: list_all_zip_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \"Language\""], ["", "text \\<open>\n  The language of a tree automaton is the set of all trees that are accepted\n  in an initial state.\n\\<close>"], ["", "definition \"ta_lang TA == { t . \\<exists>q\\<in>ta_initial TA. accs (ta_rules TA) t q }\""], ["", "subsection \"Basic Properties\""], ["", "lemma rule_states_simp: \n  \"rule_states x = (case x of (q \\<rightarrow> l qs) \\<Rightarrow> insert q (set qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rule_states x =\n    (case x of q \\<rightarrow> l qs \\<Rightarrow> insert q (set qs))", "by (case_tac x) auto"], ["", "lemma rule_states_lhs[simp]: \"lhs r \\<in> rule_states r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs r \\<in> rule_states r", "by (auto split: ta_rule.split simp add: rule_states_simp)"], ["", "lemma rule_states_rhsq: \"set (rhsq r) \\<subseteq> rule_states r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rhsq r) \\<subseteq> rule_states r", "by (auto split: ta_rule.split simp add: rule_states_simp)"], ["", "lemma rule_states_finite[simp, intro!]: \"finite (rule_states r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (rule_states r)", "by (simp add: rule_states_simp split: ta_rule.split)"], ["", "lemma \\<delta>_statesI: \n  assumes A: \"(q \\<rightarrow> l qs)\\<in>\\<delta>\"\n  shows \"q\\<in>\\<delta>_states \\<delta>\"\n        \"set qs \\<subseteq> \\<delta>_states \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states \\<delta> &&&\n    set qs \\<subseteq> \\<delta>_states \\<delta>", "using A"], ["proof (prove)\nusing this:\n  q \\<rightarrow> l qs \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states \\<delta> &&&\n    set qs \\<subseteq> \\<delta>_states \\<delta>", "apply (unfold \\<delta>_states_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q \\<rightarrow> l qs \\<in> \\<delta> \\<Longrightarrow>\n    q \\<in> \\<Union> (rule_states ` \\<delta>)\n 2. q \\<rightarrow> l qs \\<in> \\<delta> \\<Longrightarrow>\n    set qs \\<subseteq> \\<Union> (rule_states ` \\<delta>)", "by (auto split: ta_rule.split simp add: rule_states_simp)"], ["", "lemma \\<delta>_statesI': \"\\<lbrakk>(q \\<rightarrow> l qs)\\<in>\\<delta>; qi\\<in>set qs\\<rbrakk> \\<Longrightarrow> qi\\<in>\\<delta>_states \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<rightarrow> l qs \\<in> \\<delta>; qi \\<in> set qs\\<rbrakk>\n    \\<Longrightarrow> qi \\<in> \\<delta>_states \\<delta>", "using \\<delta>_statesI(2)"], ["proof (prove)\nusing this:\n  ?q \\<rightarrow> ?l ?qs \\<in> ?\\<delta> \\<Longrightarrow>\n  set ?qs \\<subseteq> \\<delta>_states ?\\<delta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<rightarrow> l qs \\<in> \\<delta>; qi \\<in> set qs\\<rbrakk>\n    \\<Longrightarrow> qi \\<in> \\<delta>_states \\<delta>", "by fast"], ["", "lemma \\<delta>_states_accsI: \"accs \\<delta> n q \\<Longrightarrow> q\\<in>\\<delta>_states \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> n q \\<Longrightarrow> q \\<in> \\<delta>_states \\<delta>", "by (auto elim: accs.cases intro: \\<delta>_statesI)"], ["", "lemma \\<delta>_states_union[simp]: \"\\<delta>_states (\\<delta>\\<union>\\<delta>') = \\<delta>_states \\<delta> \\<union> \\<delta>_states \\<delta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_states (\\<delta> \\<union> \\<delta>') =\n    \\<delta>_states \\<delta> \\<union> \\<delta>_states \\<delta>'", "by (auto simp add: \\<delta>_states_def)"], ["", "lemma \\<delta>_states_insert[simp]: \n  \"\\<delta>_states (insert r \\<delta>) = (rule_states r \\<union> \\<delta>_states \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_states (insert r \\<delta>) =\n    rule_states r \\<union> \\<delta>_states \\<delta>", "by (unfold \\<delta>_states_def) auto"], ["", "lemma \\<delta>_states_mono: \"\\<lbrakk>\\<delta> \\<subseteq> \\<delta>'\\<rbrakk> \\<Longrightarrow> \\<delta>_states \\<delta> \\<subseteq> \\<delta>_states \\<delta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<subseteq> \\<delta>' \\<Longrightarrow>\n    \\<delta>_states \\<delta> \\<subseteq> \\<delta>_states \\<delta>'", "by (unfold \\<delta>_states_def) auto"], ["", "lemma \\<delta>_states_finite[simp, intro]: \"finite \\<delta> \\<Longrightarrow> finite (\\<delta>_states \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow> finite (\\<delta>_states \\<delta>)", "by (unfold \\<delta>_states_def) auto"], ["", "lemma \\<delta>_statesE: \"\\<lbrakk>q\\<in>\\<delta>_states \\<Delta>;\n    !!f qs. \\<lbrakk> (q \\<rightarrow> f qs)\\<in>\\<Delta> \\<rbrakk> \\<Longrightarrow> P;\n    !!ql f qs. \\<lbrakk> (ql \\<rightarrow> f qs)\\<in>\\<Delta>; q\\<in>set qs \\<rbrakk> \\<Longrightarrow> P\n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> \\<delta>_states \\<Delta>;\n     \\<And>f qs. q \\<rightarrow> f qs \\<in> \\<Delta> \\<Longrightarrow> P;\n     \\<And>ql f qs.\n        \\<lbrakk>ql \\<rightarrow> f qs \\<in> \\<Delta>;\n         q \\<in> set qs\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (unfold \\<delta>_states_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> \\<Union> (rule_states ` \\<Delta>);\n     \\<And>f qs. q \\<rightarrow> f qs \\<in> \\<Delta> \\<Longrightarrow> P;\n     \\<And>ql f qs.\n        \\<lbrakk>ql \\<rightarrow> f qs \\<in> \\<Delta>;\n         q \\<in> set qs\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>f qs.\n                   q \\<rightarrow> f qs \\<in> \\<Delta> \\<Longrightarrow> P;\n        \\<And>ql f qs.\n           \\<lbrakk>ql \\<rightarrow> f qs \\<in> \\<Delta>;\n            q \\<in> set qs\\<rbrakk>\n           \\<Longrightarrow> P;\n        x \\<in> \\<Delta>; q \\<in> rule_states x\\<rbrakk>\n       \\<Longrightarrow> P", "apply (auto simp add: rule_states_simp split: ta_rule.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<delta>_symbolsI: \"(q \\<rightarrow> f qs)\\<in>\\<delta> \\<Longrightarrow> f\\<in>\\<delta>_symbols \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<rightarrow> f qs \\<in> \\<delta> \\<Longrightarrow>\n    f \\<in> \\<delta>_symbols \\<delta>", "by (force simp add: \\<delta>_symbols_def)"], ["", "lemma \\<delta>_symbolsE: \n  assumes A: \"f\\<in>\\<delta>_symbols \\<delta>\"\n  obtains q qs where \"(q \\<rightarrow> f qs) \\<in> \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q qs.\n        q \\<rightarrow> f qs \\<in> \\<delta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using A"], ["proof (prove)\nusing this:\n  f \\<in> \\<delta>_symbols \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<And>q qs.\n        q \\<rightarrow> f qs \\<in> \\<delta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (simp add: \\<delta>_symbols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q qs.\n                q \\<rightarrow> f qs \\<in> \\<delta> \\<Longrightarrow>\n                thesis;\n     f \\<in> rhsl ` \\<delta>\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule imageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>q qs.\n                   q \\<rightarrow> f qs \\<in> \\<delta> \\<Longrightarrow>\n                   thesis;\n        f = rhsl x; x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2 x3.\n       \\<lbrakk>\\<And>q qs.\n                   q \\<rightarrow> f qs \\<in> \\<delta> \\<Longrightarrow>\n                   thesis;\n        f = rhsl x; x \\<in> \\<delta>; x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<delta>_symbols_simps[simp]:\n  \"\\<delta>_symbols {} = {}\"\n  \"\\<delta>_symbols (insert r \\<delta>) = insert (rhsl r) (\\<delta>_symbols \\<delta>)\"\n  \"\\<delta>_symbols (\\<delta>\\<union>\\<delta>') = \\<delta>_symbols \\<delta> \\<union> \\<delta>_symbols \\<delta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_symbols {} = {} &&&\n    \\<delta>_symbols (insert r \\<delta>) =\n    insert (rhsl r) (\\<delta>_symbols \\<delta>) &&&\n    \\<delta>_symbols (\\<delta> \\<union> \\<delta>') =\n    \\<delta>_symbols \\<delta> \\<union> \\<delta>_symbols \\<delta>'", "by (auto simp add: \\<delta>_symbols_def)"], ["", "lemma \\<delta>_symbols_finite[simp, intro!]:\n  \"finite \\<delta> \\<Longrightarrow> finite (\\<delta>_symbols \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow> finite (\\<delta>_symbols \\<delta>)", "by (auto simp add: \\<delta>_symbols_def)"], ["", "lemma accs_mono: \"\\<lbrakk>accs \\<delta> n q; \\<delta>\\<subseteq>\\<delta>'\\<rbrakk> \\<Longrightarrow> accs \\<delta>' n q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>accs \\<delta> n q; \\<delta> \\<subseteq> \\<delta>'\\<rbrakk>\n    \\<Longrightarrow> accs \\<delta>' n q", "proof (induct rule: accs.induct[case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           \\<lbrakk>i < length qs; \\<delta> \\<subseteq> \\<delta>'\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) (qs ! i);\n        \\<delta> \\<subseteq> \\<delta>'\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE f ts) q", "case (step q l qs \\<delta> n)"], ["proof (state)\nthis:\n  q \\<rightarrow> l qs \\<in> \\<delta>\n  length n = length qs\n  ?i < length qs \\<Longrightarrow> accs \\<delta> (n ! ?i) (qs ! ?i)\n  \\<lbrakk>?i < length qs; \\<delta> \\<subseteq> \\<delta>'\\<rbrakk>\n  \\<Longrightarrow> accs \\<delta>' (n ! ?i) (qs ! ?i)\n  \\<delta> \\<subseteq> \\<delta>'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           \\<lbrakk>i < length qs; \\<delta> \\<subseteq> \\<delta>'\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) (qs ! i);\n        \\<delta> \\<subseteq> \\<delta>'\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE f ts) q", "hence R': \"(q \\<rightarrow> l qs) \\<in> \\<delta>'\""], ["proof (prove)\nusing this:\n  q \\<rightarrow> l qs \\<in> \\<delta>\n  length n = length qs\n  ?i < length qs \\<Longrightarrow> accs \\<delta> (n ! ?i) (qs ! ?i)\n  \\<lbrakk>?i < length qs; \\<delta> \\<subseteq> \\<delta>'\\<rbrakk>\n  \\<Longrightarrow> accs \\<delta>' (n ! ?i) (qs ! ?i)\n  \\<delta> \\<subseteq> \\<delta>'\n\ngoal (1 subgoal):\n 1. q \\<rightarrow> l qs \\<in> \\<delta>'", "by auto"], ["proof (state)\nthis:\n  q \\<rightarrow> l qs \\<in> \\<delta>'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           \\<lbrakk>i < length qs; \\<delta> \\<subseteq> \\<delta>'\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) (qs ! i);\n        \\<delta> \\<subseteq> \\<delta>'\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE f ts) q", "from accs.intros[OF R' step.hyps(2)] \n       step.hyps(4)[OF _ step.prems]"], ["proof (chain)\npicking this:\n  (\\<And>i.\n      i < length qs \\<Longrightarrow>\n      accs \\<delta>' (n ! i) (qs ! i)) \\<Longrightarrow>\n  accs \\<delta>' (NODE l n) q\n  ?i < length qs \\<Longrightarrow> accs \\<delta>' (n ! ?i) (qs ! ?i)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>i.\n      i < length qs \\<Longrightarrow>\n      accs \\<delta>' (n ! i) (qs ! i)) \\<Longrightarrow>\n  accs \\<delta>' (NODE l n) q\n  ?i < length qs \\<Longrightarrow> accs \\<delta>' (n ! ?i) (qs ! ?i)\n\ngoal (1 subgoal):\n 1. accs \\<delta>' (NODE l n) q", "."], ["proof (state)\nthis:\n  accs \\<delta>' (NODE l n) q\n\ngoal:\nNo subgoals!", "qed"], ["", "context tree_automaton\nbegin"], ["", "lemma initial_subset: \"ta_initial TA \\<subseteq> ta_rstates TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Qi \\<subseteq> Q", "by (unfold ta_rstates_def) auto"], ["", "lemma states_subset: \"\\<delta>_states (ta_rules TA) \\<subseteq> ta_rstates TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_states \\<delta> \\<subseteq> Q", "by (unfold ta_rstates_def) auto"], ["", "lemma finite_states[simp, intro!]: \"finite (ta_rstates TA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Q", "by (auto simp add: ta_rstates_def \\<delta>_states_def \n             intro: finite_rules finite_UN_I)"], ["", "lemma finite_symbols[simp, intro!]: \"finite (\\<delta>_symbols (ta_rules TA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<delta>_symbols \\<delta>)", "by simp"], ["", "lemmas is_subset = rev_subsetD[OF _ initial_subset] \n                     rev_subsetD[OF _ states_subset]"], ["", "end"], ["", "subsection \"Other Classes of Tree Automata\""], ["", "subsubsection \"Automata over Ranked Alphabets\"\n  \\<comment> \\<open>All trees over ranked alphabet\\<close>"], ["", "inductive_set ranked_trees :: \"('L \\<rightharpoonup> nat) \\<Rightarrow> 'L tree set\"\n  for A where\n  \"\\<lbrakk> \\<forall>t\\<in>set ts. t\\<in>ranked_trees A; A f = Some (length ts) \\<rbrakk> \n    \\<Longrightarrow> NODE f ts \\<in> ranked_trees A\""], ["", "locale finite_alphabet =\n  fixes A :: \"('L \\<rightharpoonup> nat)\"\n  assumes A_finite[simp, intro!]: \"finite (dom A)\"\nbegin"], ["", "abbreviation \"F == dom A\""], ["", "end"], ["", "context finite_alphabet\nbegin"], ["", "definition \"legal_rules Q == { (q \\<rightarrow> f qs) | q f qs.\n    q \\<in> Q\n    \\<and> qs \\<in> lists Q\n    \\<and> A f = Some (length qs)}\""], ["", "lemma legal_rulesI: \n    \"\\<lbrakk> \n      r\\<in>\\<delta>; \n      rule_states r \\<subseteq> Q; \n      A (rhsl r) = Some (length (rhsq r)) \n    \\<rbrakk> \\<Longrightarrow> r\\<in>legal_rules Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> \\<delta>; rule_states r \\<subseteq> Q;\n     A (rhsl r) = Some (length (rhsq r))\\<rbrakk>\n    \\<Longrightarrow> r \\<in> legal_rules Q", "apply (unfold legal_rules_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> \\<delta>; rule_states r \\<subseteq> Q;\n     A (rhsl r) = Some (length (rhsq r))\\<rbrakk>\n    \\<Longrightarrow> r \\<in> {q \\<rightarrow> f qs |q f qs.\n                               q \\<in> Q \\<and>\n                               qs \\<in> lists Q \\<and>\n                               A f = Some (length qs)}", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>r \\<in> \\<delta>; rule_states r \\<subseteq> Q;\n        A (rhsl r) = Some (length (rhsq r));\n        r = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> r \\<in> {q \\<rightarrow> f qs |q f qs.\n                                  q \\<in> Q \\<and>\n                                  qs \\<in> lists Q \\<and>\n                                  A f = Some (length qs)}", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma legal_rules_finite[simp, intro!]:\n    fixes Q::\"'Q set\"\n    assumes [simp, intro!]: \"finite Q\"\n    shows \"finite (legal_rules Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (legal_rules Q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (legal_rules Q)", "define possible_rules_f\n      where \"possible_rules_f = (\\<lambda>(Q::'Q set) f. \n      (\\<lambda>(q,qs). (q \\<rightarrow> f qs)) ` (Q \\<times> (lists Q \\<inter> {qs. A f = Some (length qs)})))\""], ["proof (state)\nthis:\n  possible_rules_f =\n  (\\<lambda>Q f.\n      (\\<lambda>(q, qs). q \\<rightarrow> f qs) `\n      (Q \\<times> (lists Q \\<inter> {qs. A f = Some (length qs)})))\n\ngoal (1 subgoal):\n 1. finite (legal_rules Q)", "have \"legal_rules Q = \\<Union>(possible_rules_f Q`F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_rules Q = \\<Union> (possible_rules_f Q ` F)", "by (auto simp add: legal_rules_def possible_rules_f_def)"], ["proof (state)\nthis:\n  legal_rules Q = \\<Union> (possible_rules_f Q ` F)\n\ngoal (1 subgoal):\n 1. finite (legal_rules Q)", "moreover"], ["proof (state)\nthis:\n  legal_rules Q = \\<Union> (possible_rules_f Q ` F)\n\ngoal (1 subgoal):\n 1. finite (legal_rules Q)", "have \"!!f. finite (possible_rules_f Q f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. finite (possible_rules_f Q f)", "apply (unfold possible_rules_f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       finite\n        ((\\<lambda>(q, y). q \\<rightarrow> f y) `\n         (Q \\<times> (lists Q \\<inter> {qs. A f = Some (length qs)})))", "apply (rule finite_imageI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       finite (Q \\<times> (lists Q \\<inter> {qs. A f = Some (length qs)}))", "apply (rule finite_SigmaI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f. finite Q\n 2. \\<And>f uu_.\n       uu_ \\<in> Q \\<Longrightarrow>\n       finite (lists Q \\<inter> {qs. A f = Some (length qs)})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f uu_.\n       uu_ \\<in> Q \\<Longrightarrow>\n       finite (lists Q \\<inter> {qs. A f = Some (length qs)})", "apply (case_tac \"A f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f uu_.\n       \\<lbrakk>uu_ \\<in> Q; A f = None\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (lists Q \\<inter> {qs. A f = Some (length qs)})\n 2. \\<And>f uu_ a.\n       \\<lbrakk>uu_ \\<in> Q; A f = Some a\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (lists Q \\<inter> {qs. A f = Some (length qs)})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f uu_ a.\n       \\<lbrakk>uu_ \\<in> Q; A f = Some a\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (lists Q \\<inter> {qs. A f = Some (length qs)})", "apply (simp add: lists_of_len_fin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite (possible_rules_f Q ?f1)\n\ngoal (1 subgoal):\n 1. finite (legal_rules Q)", "ultimately"], ["proof (chain)\npicking this:\n  legal_rules Q = \\<Union> (possible_rules_f Q ` F)\n  finite (possible_rules_f Q ?f1)", "show ?thesis"], ["proof (prove)\nusing this:\n  legal_rules Q = \\<Union> (possible_rules_f Q ` F)\n  finite (possible_rules_f Q ?f1)\n\ngoal (1 subgoal):\n 1. finite (legal_rules Q)", "by auto"], ["proof (state)\nthis:\n  finite (legal_rules Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "end\n\n  \\<comment> \\<open>Finite tree automata with ranked alphabet\\<close>"], ["", "locale ranked_tree_automaton = \n  tree_automaton TA +\n  finite_alphabet A\n  for TA :: \"('Q,'L) tree_automaton_rec\" \n  and A :: \"'L \\<rightharpoonup> nat\" +\n  assumes ranked: \"(q \\<rightarrow> f qs)\\<in>\\<delta> \\<Longrightarrow> A f = Some (length qs)\"\nbegin"], ["", "lemma rules_legal: \"r\\<in>\\<delta> \\<Longrightarrow> r\\<in>legal_rules Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> \\<delta> \\<Longrightarrow> r \\<in> legal_rules Q", "apply (rule legal_rulesI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. r \\<in> \\<delta> \\<Longrightarrow> r \\<in> ?\\<delta>\n 2. r \\<in> \\<delta> \\<Longrightarrow> rule_states r \\<subseteq> Q\n 3. r \\<in> \\<delta> \\<Longrightarrow> A (rhsl r) = Some (length (rhsq r))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. r \\<in> \\<delta> \\<Longrightarrow> rule_states r \\<subseteq> Q\n 2. r \\<in> \\<delta> \\<Longrightarrow> A (rhsl r) = Some (length (rhsq r))", "apply (auto simp add: ta_rstates_def \\<delta>_states_def) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> \\<delta> \\<Longrightarrow> A (rhsl r) = Some (length (rhsq r))", "apply (case_tac r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>r \\<in> \\<delta>; r = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> A (rhsl r) = Some (length (rhsq r))", "apply (auto intro: ranked)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n    \\<comment> \\<open>Only well-ranked trees are accepted\\<close>"], ["", "lemma accs_is_ranked: \"accs \\<delta> t q \\<Longrightarrow> t\\<in>ranked_trees A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> t q \\<Longrightarrow> t \\<in> ranked_trees A", "apply (induct \\<delta>\\<equiv>\\<delta> t q rule: accs.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           ts ! i \\<in> ranked_trees A\\<rbrakk>\n       \\<Longrightarrow> NODE f ts \\<in> ranked_trees A", "apply (rule ranked_trees.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           ts ! i \\<in> ranked_trees A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>t\\<in>set ts. t \\<in> ranked_trees A\n 2. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           ts ! i \\<in> ranked_trees A\\<rbrakk>\n       \\<Longrightarrow> A f = Some (length ts)", "apply (auto simp add: set_conv_nth ranked)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n    \\<comment> \\<open>The language consists of well-ranked trees\\<close>"], ["", "theorem lang_is_ranked: \"ta_lang TA \\<subseteq> ranked_trees A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang TA \\<subseteq> ranked_trees A", "using accs_is_ranked"], ["proof (prove)\nusing this:\n  accs \\<delta> ?t ?q \\<Longrightarrow> ?t \\<in> ranked_trees A\n\ngoal (1 subgoal):\n 1. ta_lang TA \\<subseteq> ranked_trees A", "by (auto simp add: ta_lang_def)"], ["", "end"], ["", "subsubsection \"Deterministic Tree Automata\"\n\n  \\<comment> \\<open>Deterministic, (bottom-up) finite tree automaton (DFTA)\\<close>"], ["", "locale det_tree_automaton = ranked_tree_automaton TA A\n  for TA :: \"('Q,'L) tree_automaton_rec\" and A +\n  assumes deterministic: \"\\<lbrakk> (q \\<rightarrow> f qs)\\<in>\\<delta>; (q' \\<rightarrow> f qs)\\<in>\\<delta> \\<rbrakk> \\<Longrightarrow> q=q'\"\nbegin"], ["", "theorem accs_unique: \"\\<lbrakk> accs \\<delta> t q; accs \\<delta> t q' \\<rbrakk> \\<Longrightarrow> q=q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>accs \\<delta> t q; accs \\<delta> t q'\\<rbrakk>\n    \\<Longrightarrow> q = q'", "unfolding accs_laz"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>accs_laz \\<delta> t q; accs_laz \\<delta> t q'\\<rbrakk>\n    \\<Longrightarrow> q = q'", "proof (induct \\<delta>\\<equiv>\\<delta> t q arbitrary: q' rule: accs_laz.induct[case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q f qs ts q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<forall>x. accs_laz \\<delta> x1 x \\<longrightarrow> x2 = x))\n         ts qs;\n        accs_laz \\<delta> (NODE f ts) q'\\<rbrakk>\n       \\<Longrightarrow> q = q'", "case (step q f qs ts q')"], ["proof (state)\nthis:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n  list_all_zip\n   (\\<lambda>x1 x2.\n       accs_laz \\<delta> x1 x2 \\<and>\n       (\\<forall>x. accs_laz \\<delta> x1 x \\<longrightarrow> x2 = x))\n   ts qs\n  accs_laz \\<delta> (NODE f ts) q'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<forall>x. accs_laz \\<delta> x1 x \\<longrightarrow> x2 = x))\n         ts qs;\n        accs_laz \\<delta> (NODE f ts) q'\\<rbrakk>\n       \\<Longrightarrow> q = q'", "hence I: \n      \"(q \\<rightarrow> f qs) \\<in> \\<delta>\"\n      \"list_all_zip (accs_laz \\<delta>) ts qs\"\n      \"list_all_zip (\\<lambda>t q. (\\<forall>q'. accs_laz \\<delta> t q' \\<longrightarrow> q=q')) ts qs\"\n      \"accs_laz \\<delta> (NODE f ts) q'\""], ["proof (prove)\nusing this:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n  list_all_zip\n   (\\<lambda>x1 x2.\n       accs_laz \\<delta> x1 x2 \\<and>\n       (\\<forall>x. accs_laz \\<delta> x1 x \\<longrightarrow> x2 = x))\n   ts qs\n  accs_laz \\<delta> (NODE f ts) q'\n\ngoal (1 subgoal):\n 1. (q \\<rightarrow> f qs \\<in> \\<delta> &&&\n     list_all_zip (accs_laz \\<delta>) ts qs) &&&\n    list_all_zip\n     (\\<lambda>t q.\n         \\<forall>q'. accs_laz \\<delta> t q' \\<longrightarrow> q = q')\n     ts qs &&&\n    accs_laz \\<delta> (NODE f ts) q'", "by auto"], ["proof (state)\nthis:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n  list_all_zip (accs_laz \\<delta>) ts qs\n  list_all_zip\n   (\\<lambda>t q.\n       \\<forall>q'. accs_laz \\<delta> t q' \\<longrightarrow> q = q')\n   ts qs\n  accs_laz \\<delta> (NODE f ts) q'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<forall>x. accs_laz \\<delta> x1 x \\<longrightarrow> x2 = x))\n         ts qs;\n        accs_laz \\<delta> (NODE f ts) q'\\<rbrakk>\n       \\<Longrightarrow> q = q'", "from I(4)"], ["proof (chain)\npicking this:\n  accs_laz \\<delta> (NODE f ts) q'", "obtain qs' where A':\n      \"(q' \\<rightarrow> f qs') \\<in> \\<delta>\"\n      \"list_all_zip (accs_laz \\<delta>) ts qs'\""], ["proof (prove)\nusing this:\n  accs_laz \\<delta> (NODE f ts) q'\n\ngoal (1 subgoal):\n 1. (\\<And>qs'.\n        \\<lbrakk>q' \\<rightarrow> f qs' \\<in> \\<delta>;\n         list_all_zip (accs_laz \\<delta>) ts qs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: accs_laz.cases)"], ["proof (state)\nthis:\n  q' \\<rightarrow> f qs' \\<in> \\<delta>\n  list_all_zip (accs_laz \\<delta>) ts qs'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<forall>x. accs_laz \\<delta> x1 x \\<longrightarrow> x2 = x))\n         ts qs;\n        accs_laz \\<delta> (NODE f ts) q'\\<rbrakk>\n       \\<Longrightarrow> q = q'", "from I(2,3) A'(2)"], ["proof (chain)\npicking this:\n  list_all_zip (accs_laz \\<delta>) ts qs\n  list_all_zip\n   (\\<lambda>t q.\n       \\<forall>q'. accs_laz \\<delta> t q' \\<longrightarrow> q = q')\n   ts qs\n  list_all_zip (accs_laz \\<delta>) ts qs'", "have \"list_all_zip (=) qs qs'\""], ["proof (prove)\nusing this:\n  list_all_zip (accs_laz \\<delta>) ts qs\n  list_all_zip\n   (\\<lambda>t q.\n       \\<forall>q'. accs_laz \\<delta> t q' \\<longrightarrow> q = q')\n   ts qs\n  list_all_zip (accs_laz \\<delta>) ts qs'\n\ngoal (1 subgoal):\n 1. list_all_zip (=) qs qs'", "by (auto simp add: list_all_zip_alt)"], ["proof (state)\nthis:\n  list_all_zip (=) qs qs'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<forall>x. accs_laz \\<delta> x1 x \\<longrightarrow> x2 = x))\n         ts qs;\n        accs_laz \\<delta> (NODE f ts) q'\\<rbrakk>\n       \\<Longrightarrow> q = q'", "hence \"qs=qs'\""], ["proof (prove)\nusing this:\n  list_all_zip (=) qs qs'\n\ngoal (1 subgoal):\n 1. qs = qs'", "by (auto simp add: laz_eq)"], ["proof (state)\nthis:\n  qs = qs'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<forall>x. accs_laz \\<delta> x1 x \\<longrightarrow> x2 = x))\n         ts qs;\n        accs_laz \\<delta> (NODE f ts) q'\\<rbrakk>\n       \\<Longrightarrow> q = q'", "with deterministic[OF I(1), of q'] A'(1)"], ["proof (chain)\npicking this:\n  q' \\<rightarrow> f qs \\<in> \\<delta> \\<Longrightarrow> q = q'\n  q' \\<rightarrow> f qs' \\<in> \\<delta>\n  qs = qs'", "show \"q=q'\""], ["proof (prove)\nusing this:\n  q' \\<rightarrow> f qs \\<in> \\<delta> \\<Longrightarrow> q = q'\n  q' \\<rightarrow> f qs' \\<in> \\<delta>\n  qs = qs'\n\ngoal (1 subgoal):\n 1. q = q'", "by simp"], ["proof (state)\nthis:\n  q = q'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \"Complete Tree Automata\""], ["", "locale complete_tree_automaton = det_tree_automaton TA A \n  for TA :: \"('Q,'L) tree_automaton_rec\" and A\n  +\n  assumes complete: \n  \"\\<lbrakk> qs\\<in>lists Q; A f = Some (length qs) \\<rbrakk> \\<Longrightarrow> \\<exists>q. (q \\<rightarrow> f qs)\\<in>\\<delta>\"\nbegin\n\n    \\<comment> \\<open>In a complete DFTA, all trees can be labeled by some state\\<close>"], ["", "theorem label_all: \"t\\<in>ranked_trees A \\<Longrightarrow> \\<exists>q\\<in>Q. accs \\<delta> t q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> ranked_trees A \\<Longrightarrow>\n    \\<exists>q\\<in>Q. accs \\<delta> t q", "proof (induct rule: ranked_trees.induct[case_names constr])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts f.\n       \\<lbrakk>\\<forall>t\\<in>set ts.\n                   t \\<in> ranked_trees A \\<and>\n                   (\\<exists>a\\<in>Q. accs \\<delta> t a);\n        A f = Some (length ts)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>Q. accs \\<delta> (NODE f ts) a", "case (constr ts f)"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set ts.\n     t \\<in> ranked_trees A \\<and> (\\<exists>a\\<in>Q. accs \\<delta> t a)\n  A f = Some (length ts)\n\ngoal (1 subgoal):\n 1. \\<And>ts f.\n       \\<lbrakk>\\<forall>t\\<in>set ts.\n                   t \\<in> ranked_trees A \\<and>\n                   (\\<exists>a\\<in>Q. accs \\<delta> t a);\n        A f = Some (length ts)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>Q. accs \\<delta> (NODE f ts) a", "obtain qs where QS:\n      \"qs\\<in>lists Q\"\n      \"list_all_zip (accs \\<delta>) ts qs\" \n      and [simp]: \"length qs = length ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> lists Q; list_all_zip (accs \\<delta>) ts qs;\n         length qs = length ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> lists Q; list_all_zip (accs \\<delta>) ts qs;\n         length qs = length ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from constr(1)"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>set ts.\n     t \\<in> ranked_trees A \\<and> (\\<exists>a\\<in>Q. accs \\<delta> t a)", "have \"\\<forall>i<length ts. \\<exists>q. q\\<in>Q \\<and> accs \\<delta> (ts!i) q\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set ts.\n     t \\<in> ranked_trees A \\<and> (\\<exists>a\\<in>Q. accs \\<delta> t a)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ts.\n       \\<exists>q. q \\<in> Q \\<and> accs \\<delta> (ts ! i) q", "by (auto)"], ["proof (state)\nthis:\n  \\<forall>i<length ts.\n     \\<exists>q. q \\<in> Q \\<and> accs \\<delta> (ts ! i) q\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> lists Q; list_all_zip (accs \\<delta>) ts qs;\n         length qs = length ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length ts.\n     \\<exists>q. q \\<in> Q \\<and> accs \\<delta> (ts ! i) q\n\ngoal (1 subgoal):\n 1. thesis", "apply (erule_tac obtain_list_from_elements)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>length l = length ts;\n        \\<forall>i<length ts.\n           l ! i \\<in> Q \\<and> accs \\<delta> (ts ! i) (l ! i)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule_tac that)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>length l = length ts;\n        \\<forall>i<length ts.\n           l ! i \\<in> Q \\<and> accs \\<delta> (ts ! i) (l ! i)\\<rbrakk>\n       \\<Longrightarrow> ?qs3 l \\<in> lists Q\n 2. \\<And>l.\n       \\<lbrakk>length l = length ts;\n        \\<forall>i<length ts.\n           l ! i \\<in> Q \\<and> accs \\<delta> (ts ! i) (l ! i)\\<rbrakk>\n       \\<Longrightarrow> list_all_zip (accs \\<delta>) ts (?qs3 l)\n 3. \\<And>l.\n       \\<lbrakk>length l = length ts;\n        \\<forall>i<length ts.\n           l ! i \\<in> Q \\<and> accs \\<delta> (ts ! i) (l ! i)\\<rbrakk>\n       \\<Longrightarrow> length (?qs3 l) = length ts", "apply (auto simp add: list_all_zip_alt set_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  qs \\<in> lists Q\n  list_all_zip (accs \\<delta>) ts qs\n  length qs = length ts\n\ngoal (1 subgoal):\n 1. \\<And>ts f.\n       \\<lbrakk>\\<forall>t\\<in>set ts.\n                   t \\<in> ranked_trees A \\<and>\n                   (\\<exists>a\\<in>Q. accs \\<delta> t a);\n        A f = Some (length ts)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>Q. accs \\<delta> (NODE f ts) a", "moreover"], ["proof (state)\nthis:\n  qs \\<in> lists Q\n  list_all_zip (accs \\<delta>) ts qs\n  length qs = length ts\n\ngoal (1 subgoal):\n 1. \\<And>ts f.\n       \\<lbrakk>\\<forall>t\\<in>set ts.\n                   t \\<in> ranked_trees A \\<and>\n                   (\\<exists>a\\<in>Q. accs \\<delta> t a);\n        A f = Some (length ts)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>Q. accs \\<delta> (NODE f ts) a", "from complete[OF QS(1), simplified, OF constr(2)]"], ["proof (chain)\npicking this:\n  \\<exists>q. q \\<rightarrow> f qs \\<in> \\<delta>", "obtain q \n      where \"(q \\<rightarrow> f qs) \\<in>\\<delta>\""], ["proof (prove)\nusing this:\n  \\<exists>q. q \\<rightarrow> f qs \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<rightarrow> f qs \\<in> \\<delta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>ts f.\n       \\<lbrakk>\\<forall>t\\<in>set ts.\n                   t \\<in> ranked_trees A \\<and>\n                   (\\<exists>a\\<in>Q. accs \\<delta> t a);\n        A f = Some (length ts)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>Q. accs \\<delta> (NODE f ts) a", "ultimately"], ["proof (chain)\npicking this:\n  qs \\<in> lists Q\n  list_all_zip (accs \\<delta>) ts qs\n  length qs = length ts\n  q \\<rightarrow> f qs \\<in> \\<delta>", "show ?case"], ["proof (prove)\nusing this:\n  qs \\<in> lists Q\n  list_all_zip (accs \\<delta>) ts qs\n  length qs = length ts\n  q \\<rightarrow> f qs \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>Q. accs \\<delta> (NODE f ts) a", "by (auto simp add: accs_laz ta_rstates_def \n               intro: accs_laz.intros \\<delta>_statesI)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>Q. accs \\<delta> (NODE f ts) a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \"Algorithms\""], ["", "text \\<open>\n  In this section, basic algorithms on tree-automata are specified.\n  The specification is a high-level, non-executable specification, intended\n  to be refined to more low-level specifications, as done in \n  Sections~\\ref{sec:absalgo} and \\ref{sec:taimpl}.\n\\<close>"], ["", "subsubsection \"Empty Automaton\""], ["", "definition \"ta_empty == \\<lparr> ta_initial = {}, ta_rules = {}\\<rparr>\""], ["", "theorem ta_empty_lang[simp]: \"ta_lang ta_empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang ta_empty = {}", "by (auto simp add: ta_empty_def ta_lang_def)"], ["", "theorem ta_empty_ta[simp, intro!]: \"tree_automaton ta_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton ta_empty", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (ta_rules ta_empty)\n 2. finite (ta_initial ta_empty)", "apply (unfold ta_empty_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (ta_rules \\<lparr>ta_initial = {}, ta_rules = {}\\<rparr>)\n 2. finite (ta_initial \\<lparr>ta_initial = {}, ta_rules = {}\\<rparr>)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem (in finite_alphabet) ta_empty_rta[simp, intro!]: \n  \"ranked_tree_automaton ta_empty A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton ta_empty A", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (ta_rules ta_empty)\n 2. finite (ta_initial ta_empty)\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules ta_empty \\<Longrightarrow>\n       A f = Some (length qs)", "apply (unfold ta_empty_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (ta_rules \\<lparr>ta_initial = {}, ta_rules = {}\\<rparr>)\n 2. finite (ta_initial \\<lparr>ta_initial = {}, ta_rules = {}\\<rparr>)\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs\n       \\<in> ta_rules\n              \\<lparr>ta_initial = {},\n                 ta_rules = {}\\<rparr> \\<Longrightarrow>\n       A f = Some (length qs)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem (in finite_alphabet) ta_empty_dta[simp, intro!]: \n  \"det_tree_automaton ta_empty A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_tree_automaton ta_empty A", "apply (unfold_locales)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (ta_rules ta_empty)\n 2. finite (ta_initial ta_empty)\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules ta_empty \\<Longrightarrow>\n       A f = Some (length qs)\n 4. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules ta_empty;\n        q' \\<rightarrow> f qs \\<in> ta_rules ta_empty\\<rbrakk>\n       \\<Longrightarrow> q = q'", "apply (unfold ta_empty_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (ta_rules \\<lparr>ta_initial = {}, ta_rules = {}\\<rparr>)\n 2. finite (ta_initial \\<lparr>ta_initial = {}, ta_rules = {}\\<rparr>)\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs\n       \\<in> ta_rules\n              \\<lparr>ta_initial = {},\n                 ta_rules = {}\\<rparr> \\<Longrightarrow>\n       A f = Some (length qs)\n 4. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs\n                \\<in> ta_rules\n                       \\<lparr>ta_initial = {}, ta_rules = {}\\<rparr>;\n        q' \\<rightarrow> f qs\n        \\<in> ta_rules\n               \\<lparr>ta_initial = {}, ta_rules = {}\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> q = q'", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \"Remapping of States\""], ["", "fun remap_rule where \"remap_rule f (q \\<rightarrow> l qs) = ((f q) \\<rightarrow> l (map f qs))\""], ["", "definition \n  \"ta_remap f TA == \\<lparr> ta_initial = f ` ta_initial TA, \n                      ta_rules = remap_rule f ` ta_rules TA \n                    \\<rparr>\""], ["", "lemma \\<delta>_states_remap[simp]: \"\\<delta>_states (remap_rule f ` \\<delta>) = f` \\<delta>_states \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_states (remap_rule f ` \\<delta>) = f ` \\<delta>_states \\<delta>", "apply (auto simp add: \\<delta>_states_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a.\n       \\<lbrakk>a \\<in> \\<delta>;\n        x \\<in> rule_states (remap_rule f a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f ` \\<Union> (rule_states ` \\<delta>)\n 2. \\<And>xa xb.\n       \\<lbrakk>xb \\<in> \\<delta>; xa \\<in> rule_states xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>\\<delta>.\n                            f xa \\<in> rule_states (remap_rule f x)", "apply (case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a x1 x2 x3.\n       \\<lbrakk>a \\<in> \\<delta>; x \\<in> rule_states (remap_rule f a);\n        a = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f ` \\<Union> (rule_states ` \\<delta>)\n 2. \\<And>xa xb.\n       \\<lbrakk>xb \\<in> \\<delta>; xa \\<in> rule_states xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>\\<delta>.\n                            f xa \\<in> rule_states (remap_rule f x)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>xb \\<in> \\<delta>; xa \\<in> rule_states xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>\\<delta>.\n                            f xa \\<in> rule_states (remap_rule f x)", "apply (case_tac xb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb x1 x2 x3.\n       \\<lbrakk>xb \\<in> \\<delta>; xa \\<in> rule_states xb;\n        xb = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>\\<delta>.\n                            f xa \\<in> rule_states (remap_rule f x)", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma remap_accs1: \"accs \\<delta> n q \\<Longrightarrow> accs (remap_rule f ` \\<delta>) n (f q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> n q \\<Longrightarrow>\n    accs (remap_rule f ` \\<delta>) n (f q)", "proof (induct rule: accs.induct[case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q fa qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> fa qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (remap_rule f ` \\<delta>) (ts ! i) (f (qs ! i))\\<rbrakk>\n       \\<Longrightarrow> accs (remap_rule f ` \\<delta>) (NODE fa ts) (f q)", "case (step q l qs \\<delta> ts)"], ["proof (state)\nthis:\n  q \\<rightarrow> l qs \\<in> \\<delta>\n  length ts = length qs\n  ?i < length qs \\<Longrightarrow> accs \\<delta> (ts ! ?i) (qs ! ?i)\n  ?i < length qs \\<Longrightarrow>\n  accs (remap_rule f ` \\<delta>) (ts ! ?i) (f (qs ! ?i))\n\ngoal (1 subgoal):\n 1. \\<And>q fa qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> fa qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (remap_rule f ` \\<delta>) (ts ! i) (f (qs ! i))\\<rbrakk>\n       \\<Longrightarrow> accs (remap_rule f ` \\<delta>) (NODE fa ts) (f q)", "from step.hyps(1)"], ["proof (chain)\npicking this:\n  q \\<rightarrow> l qs \\<in> \\<delta>", "have 1: \"((f q) \\<rightarrow> l (map f qs)) \\<in> remap_rule f ` \\<delta>\""], ["proof (prove)\nusing this:\n  q \\<rightarrow> l qs \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. f q \\<rightarrow> l map f qs \\<in> remap_rule f ` \\<delta>", "by (drule_tac f=\"remap_rule f\" in imageI) simp"], ["proof (state)\nthis:\n  f q \\<rightarrow> l map f qs \\<in> remap_rule f ` \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>q fa qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> fa qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (remap_rule f ` \\<delta>) (ts ! i) (f (qs ! i))\\<rbrakk>\n       \\<Longrightarrow> accs (remap_rule f ` \\<delta>) (NODE fa ts) (f q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. accs (remap_rule f ` \\<delta>) (NODE l ts) (f q)", "proof (rule accs.intros[OF 1])"], ["proof (state)\ngoal (2 subgoals):\n 1. length ts = length (map f qs)\n 2. \\<And>i.\n       i < length (map f qs) \\<Longrightarrow>\n       accs (remap_rule f ` \\<delta>) (ts ! i) (map f qs ! i)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length ts = length (map f qs)\n 2. \\<And>i.\n       i < length (map f qs) \\<Longrightarrow>\n       accs (remap_rule f ` \\<delta>) (ts ! i) (map f qs ! i)", "assume \"i<length (map f qs)\""], ["proof (state)\nthis:\n  i < length (map f qs)\n\ngoal (2 subgoals):\n 1. length ts = length (map f qs)\n 2. \\<And>i.\n       i < length (map f qs) \\<Longrightarrow>\n       accs (remap_rule f ` \\<delta>) (ts ! i) (map f qs ! i)", "with step.hyps(4)"], ["proof (chain)\npicking this:\n  ?i < length qs \\<Longrightarrow>\n  accs (remap_rule f ` \\<delta>) (ts ! ?i) (f (qs ! ?i))\n  i < length (map f qs)", "show \"accs (remap_rule f ` \\<delta>) (ts ! i) (map f qs ! i)\""], ["proof (prove)\nusing this:\n  ?i < length qs \\<Longrightarrow>\n  accs (remap_rule f ` \\<delta>) (ts ! ?i) (f (qs ! ?i))\n  i < length (map f qs)\n\ngoal (1 subgoal):\n 1. accs (remap_rule f ` \\<delta>) (ts ! i) (map f qs ! i)", "by auto"], ["proof (state)\nthis:\n  accs (remap_rule f ` \\<delta>) (ts ! i) (map f qs ! i)\n\ngoal (1 subgoal):\n 1. length ts = length (map f qs)", "qed (auto simp add: step.hyps(2))"], ["proof (state)\nthis:\n  accs (remap_rule f ` \\<delta>) (NODE l ts) (f q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remap_lang1: \"t\\<in>ta_lang TA \\<Longrightarrow> t\\<in>ta_lang (ta_remap f TA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> ta_lang TA \\<Longrightarrow> t \\<in> ta_lang (ta_remap f TA)", "by (unfold ta_lang_def ta_remap_def) (auto dest: remap_accs1)"], ["", "lemma remap_accs2: \"\\<lbrakk> \n    accs \\<delta>' n q'; \n    \\<delta>'=(remap_rule f ` \\<delta>); \n    q'=f q; \n    inj_on f Q; \n    q\\<in>Q; \n    \\<delta>_states \\<delta> \\<subseteq> Q \n  \\<rbrakk> \\<Longrightarrow> accs \\<delta> n q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>accs \\<delta>' n q'; \\<delta>' = remap_rule f ` \\<delta>;\n     q' = f q; inj_on f Q; q \\<in> Q;\n     \\<delta>_states \\<delta> \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> accs \\<delta> n q", "proof (induct arbitrary: \\<delta> q rule: accs.induct[case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q fa qs \\<delta> ts \\<delta>' qa.\n       \\<lbrakk>q \\<rightarrow> fa qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' q.\n           \\<lbrakk>i < length qs; \\<delta> = remap_rule f ` \\<delta>';\n            qs ! i = f q; inj_on f Q; q \\<in> Q;\n            \\<delta>_states \\<delta>' \\<subseteq> Q\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) q;\n        \\<delta> = remap_rule f ` \\<delta>'; q = f qa; inj_on f Q;\n        qa \\<in> Q; \\<delta>_states \\<delta>' \\<subseteq> Q\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE fa ts) qa", "case (step q' l qs \\<delta>' ts \\<delta> q)"], ["proof (state)\nthis:\n  q' \\<rightarrow> l qs \\<in> \\<delta>'\n  length ts = length qs\n  ?i < length qs \\<Longrightarrow> accs \\<delta>' (ts ! ?i) (qs ! ?i)\n  \\<lbrakk>?i < length qs; \\<delta>' = remap_rule f ` ?\\<delta>;\n   qs ! ?i = f ?q; inj_on f Q; ?q \\<in> Q;\n   \\<delta>_states ?\\<delta> \\<subseteq> Q\\<rbrakk>\n  \\<Longrightarrow> accs ?\\<delta> (ts ! ?i) ?q\n  \\<delta>' = remap_rule f ` \\<delta>\n  q' = f q\n  inj_on f Q\n  q \\<in> Q\n  \\<delta>_states \\<delta> \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. \\<And>q fa qs \\<delta> ts \\<delta>' qa.\n       \\<lbrakk>q \\<rightarrow> fa qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' q.\n           \\<lbrakk>i < length qs; \\<delta> = remap_rule f ` \\<delta>';\n            qs ! i = f q; inj_on f Q; q \\<in> Q;\n            \\<delta>_states \\<delta>' \\<subseteq> Q\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) q;\n        \\<delta> = remap_rule f ` \\<delta>'; q = f qa; inj_on f Q;\n        qa \\<in> Q; \\<delta>_states \\<delta>' \\<subseteq> Q\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE fa ts) qa", "note [simp] = step.prems(1,2)"], ["proof (state)\nthis:\n  \\<delta>' = remap_rule f ` \\<delta>\n  q' = f q\n\ngoal (1 subgoal):\n 1. \\<And>q fa qs \\<delta> ts \\<delta>' qa.\n       \\<lbrakk>q \\<rightarrow> fa qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' q.\n           \\<lbrakk>i < length qs; \\<delta> = remap_rule f ` \\<delta>';\n            qs ! i = f q; inj_on f Q; q \\<in> Q;\n            \\<delta>_states \\<delta>' \\<subseteq> Q\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) q;\n        \\<delta> = remap_rule f ` \\<delta>'; q = f qa; inj_on f Q;\n        qa \\<in> Q; \\<delta>_states \\<delta>' \\<subseteq> Q\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE fa ts) qa", "from step.hyps(1)[simplified] step.prems(3,4,5)"], ["proof (chain)\npicking this:\n  f q \\<rightarrow> l qs \\<in> remap_rule f ` \\<delta>\n  inj_on f Q\n  q \\<in> Q\n  \\<delta>_states \\<delta> \\<subseteq> Q", "have \n    R: \"(q \\<rightarrow> l (map (inv_on f Q) qs))\\<in>\\<delta>\""], ["proof (prove)\nusing this:\n  f q \\<rightarrow> l qs \\<in> remap_rule f ` \\<delta>\n  inj_on f Q\n  q \\<in> Q\n  \\<delta>_states \\<delta> \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. q \\<rightarrow> l map (inv_on f Q) qs \\<in> \\<delta>", "apply (erule_tac imageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        f q \\<rightarrow> l qs = remap_rule f x; x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> l map (inv_on f Q) qs\n                         \\<in> \\<delta>", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2 x3.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        f q \\<rightarrow> l qs = remap_rule f x; x \\<in> \\<delta>;\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> l map (inv_on f Q) qs\n                         \\<in> \\<delta>", "apply (auto simp del:map_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x3.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1;\n        qs = map f x3\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> l map (inv_on f Q) (map f x3)\n                         \\<in> \\<delta>", "apply (subst inj_on_map_inv_f)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x3.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1;\n        qs = map f x3\\<rbrakk>\n       \\<Longrightarrow> set x3 \\<subseteq> Q\n 2. \\<And>x1 x3.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1;\n        qs = map f x3\\<rbrakk>\n       \\<Longrightarrow> inj_on f Q\n 3. \\<And>x1 x3.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1;\n        qs = map f x3\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> l x3 \\<in> \\<delta>", "apply (auto dest: \\<delta>_statesI) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x3.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1;\n        qs = map f x3\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> l x3 \\<in> \\<delta>", "apply (subgoal_tac \"q\\<in>\\<delta>_states \\<delta>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x3.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1; qs = map f x3;\n        q \\<in> \\<delta>_states \\<delta>\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> l x3 \\<in> \\<delta>\n 2. \\<And>x1 x3.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1;\n        qs = map f x3\\<rbrakk>\n       \\<Longrightarrow> q \\<in> \\<delta>_states \\<delta>", "apply (unfold inj_on_def) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x3.\n       \\<lbrakk>\\<forall>x\\<in>Q.\n                   \\<forall>y\\<in>Q. f x = f y \\<longrightarrow> x = y;\n        q \\<in> Q; \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1; qs = map f x3;\n        q \\<in> \\<delta>_states \\<delta>\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> l x3 \\<in> \\<delta>\n 2. \\<And>x1 x3.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1;\n        qs = map f x3\\<rbrakk>\n       \\<Longrightarrow> q \\<in> \\<delta>_states \\<delta>", "apply (metis \\<delta>_statesI(1) contra_subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x3.\n       \\<lbrakk>inj_on f Q; q \\<in> Q;\n        \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1;\n        qs = map f x3\\<rbrakk>\n       \\<Longrightarrow> q \\<in> \\<delta>_states \\<delta>", "apply (fastforce intro: \\<delta>_statesI(1) dest: inj_onD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  q \\<rightarrow> l map (inv_on f Q) qs \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>q fa qs \\<delta> ts \\<delta>' qa.\n       \\<lbrakk>q \\<rightarrow> fa qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' q.\n           \\<lbrakk>i < length qs; \\<delta> = remap_rule f ` \\<delta>';\n            qs ! i = f q; inj_on f Q; q \\<in> Q;\n            \\<delta>_states \\<delta>' \\<subseteq> Q\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) q;\n        \\<delta> = remap_rule f ` \\<delta>'; q = f qa; inj_on f Q;\n        qa \\<in> Q; \\<delta>_states \\<delta>' \\<subseteq> Q\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE fa ts) qa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> (NODE l ts) q", "proof (rule accs.intros[OF R])"], ["proof (state)\ngoal (2 subgoals):\n 1. length ts = length (map (inv_on f Q) qs)\n 2. \\<And>i.\n       i < length (map (inv_on f Q) qs) \\<Longrightarrow>\n       accs \\<delta> (ts ! i) (map (inv_on f Q) qs ! i)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length ts = length (map (inv_on f Q) qs)\n 2. \\<And>i.\n       i < length (map (inv_on f Q) qs) \\<Longrightarrow>\n       accs \\<delta> (ts ! i) (map (inv_on f Q) qs ! i)", "assume \"i < length (map (inv_on f Q) qs)\""], ["proof (state)\nthis:\n  i < length (map (inv_on f Q) qs)\n\ngoal (2 subgoals):\n 1. length ts = length (map (inv_on f Q) qs)\n 2. \\<And>i.\n       i < length (map (inv_on f Q) qs) \\<Longrightarrow>\n       accs \\<delta> (ts ! i) (map (inv_on f Q) qs ! i)", "hence L: \"i<length qs\""], ["proof (prove)\nusing this:\n  i < length (map (inv_on f Q) qs)\n\ngoal (1 subgoal):\n 1. i < length qs", "by simp"], ["proof (state)\nthis:\n  i < length qs\n\ngoal (2 subgoals):\n 1. length ts = length (map (inv_on f Q) qs)\n 2. \\<And>i.\n       i < length (map (inv_on f Q) qs) \\<Longrightarrow>\n       accs \\<delta> (ts ! i) (map (inv_on f Q) qs ! i)", "from step.hyps(1)[simplified] step.prems(5)"], ["proof (chain)\npicking this:\n  f q \\<rightarrow> l qs \\<in> remap_rule f ` \\<delta>\n  \\<delta>_states \\<delta> \\<subseteq> Q", "have \n      IR: \"!!i. i<length qs \\<Longrightarrow> qs!i \\<in> f ` Q\""], ["proof (prove)\nusing this:\n  f q \\<rightarrow> l qs \\<in> remap_rule f ` \\<delta>\n  \\<delta>_states \\<delta> \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length qs \\<Longrightarrow> qs ! i \\<in> f ` Q", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i < length qs; \\<delta>_states \\<delta> \\<subseteq> Q;\n        f q \\<rightarrow> l qs = remap_rule f x; x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> qs ! i \\<in> f ` Q", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x x1 x2 x3.\n       \\<lbrakk>i < length qs; \\<delta>_states \\<delta> \\<subseteq> Q;\n        f q \\<rightarrow> l qs = remap_rule f x; x \\<in> \\<delta>;\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> qs ! i \\<in> f ` Q", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x1 x3.\n       \\<lbrakk>i < length x3; \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l x3 \\<in> \\<delta>; f q = f x1;\n        qs = map f x3\\<rbrakk>\n       \\<Longrightarrow> f (x3 ! i) \\<in> f ` Q", "apply (rename_tac list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x1 list.\n       \\<lbrakk>i < length list; \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l list \\<in> \\<delta>; f q = f x1;\n        qs = map f list\\<rbrakk>\n       \\<Longrightarrow> f (list ! i) \\<in> f ` Q", "apply (subgoal_tac \"list!i \\<in> \\<delta>_states \\<delta>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i x1 list.\n       \\<lbrakk>i < length list; \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l list \\<in> \\<delta>; f q = f x1; qs = map f list;\n        list ! i \\<in> \\<delta>_states \\<delta>\\<rbrakk>\n       \\<Longrightarrow> f (list ! i) \\<in> f ` Q\n 2. \\<And>i x1 list.\n       \\<lbrakk>i < length list; \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l list \\<in> \\<delta>; f q = f x1;\n        qs = map f list\\<rbrakk>\n       \\<Longrightarrow> list ! i \\<in> \\<delta>_states \\<delta>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x1 list.\n       \\<lbrakk>i < length list; \\<delta>_states \\<delta> \\<subseteq> Q;\n        x1 \\<rightarrow> l list \\<in> \\<delta>; f q = f x1;\n        qs = map f list\\<rbrakk>\n       \\<Longrightarrow> list ! i \\<in> \\<delta>_states \\<delta>", "apply (auto dest!: \\<delta>_statesI(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?i < length qs \\<Longrightarrow> qs ! ?i \\<in> f ` Q\n\ngoal (2 subgoals):\n 1. length ts = length (map (inv_on f Q) qs)\n 2. \\<And>i.\n       i < length (map (inv_on f Q) qs) \\<Longrightarrow>\n       accs \\<delta> (ts ! i) (map (inv_on f Q) qs ! i)", "show \"accs \\<delta> (ts ! i) (map (inv_on f Q) qs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> (ts ! i) (map (inv_on f Q) qs ! i)", "apply (rule step.hyps(4)[OF L, simplified])"], ["proof (prove)\ngoal (5 subgoals):\n 1. remap_rule f ` \\<delta> = remap_rule f ` \\<delta>\n 2. qs ! i = f (map (inv_on f Q) qs ! i)\n 3. inj_on f Q\n 4. map (inv_on f Q) qs ! i \\<in> Q\n 5. \\<delta>_states \\<delta> \\<subseteq> Q", "apply (simp_all add: f_inv_on_f[OF IR[OF L]] \n                      inv_on_f_range[OF IR[OF L]] \n                      L step.prems(3,5))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  accs \\<delta> (ts ! i) (map (inv_on f Q) qs ! i)\n\ngoal (1 subgoal):\n 1. length ts = length (map (inv_on f Q) qs)", "qed (auto simp add: step.hyps(2))"], ["proof (state)\nthis:\n  accs \\<delta> (NODE l ts) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in tree_automaton) remap_lang2: \n  assumes I: \"inj_on f (ta_rstates TA)\" \n  shows \"t\\<in>ta_lang (ta_remap f TA) \\<Longrightarrow> t\\<in>ta_lang TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> ta_lang (ta_remap f TA) \\<Longrightarrow> t \\<in> ta_lang TA", "apply (unfold ta_lang_def ta_remap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> {t. \\<exists>q\\<in>ta_initial\n                                \\<lparr>ta_initial = f ` Qi,\n                                   ta_rules =\n                                     remap_rule f ` \\<delta>\\<rparr>.\n                   accs\n                    (ta_rules\n                      \\<lparr>ta_initial = f ` Qi,\n                         ta_rules = remap_rule f ` \\<delta>\\<rparr>)\n                    t q} \\<Longrightarrow>\n    t \\<in> {t. \\<exists>q\\<in>Qi. accs \\<delta> t q}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> Qi; accs (remap_rule f ` \\<delta>) t (f x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Qi. accs \\<delta> t x", "apply (rule_tac x=x in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> Qi; accs (remap_rule f ` \\<delta>) t (f x)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> t x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> Qi; accs (remap_rule f ` \\<delta>) t (f x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Qi", "apply (drule remap_accs2[OF _ _ _ I])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       x \\<in> Qi \\<Longrightarrow>\n       remap_rule f ` \\<delta> = remap_rule f ` ?\\<delta>18 x\n 2. \\<And>x. x \\<in> Qi \\<Longrightarrow> f x = f (?q18 x)\n 3. \\<And>x. x \\<in> Qi \\<Longrightarrow> ?q18 x \\<in> Q\n 4. \\<And>x.\n       x \\<in> Qi \\<Longrightarrow>\n       \\<delta>_states (?\\<delta>18 x) \\<subseteq> Q\n 5. \\<And>x.\n       \\<lbrakk>x \\<in> Qi; accs (?\\<delta>18 x) t (?q18 x)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> t x\n 6. \\<And>x.\n       \\<lbrakk>x \\<in> Qi; accs (remap_rule f ` \\<delta>) t (f x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Qi", "apply (auto dest: is_subset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem (in tree_automaton) remap_lang: \n  \"inj_on f (ta_rstates TA) \\<Longrightarrow> ta_lang (ta_remap f TA) = ta_lang TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f Q \\<Longrightarrow> ta_lang (ta_remap f TA) = ta_lang TA", "by (auto intro: remap_lang1 remap_lang2)"], ["", "lemma (in tree_automaton) remap_ta[intro!, simp]: \n  \"tree_automaton (ta_remap f TA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton (ta_remap f TA)", "using initial_subset states_subset finite_states finite_rules"], ["proof (prove)\nusing this:\n  Qi \\<subseteq> Q\n  \\<delta>_states \\<delta> \\<subseteq> Q\n  finite Q\n  finite \\<delta>\n\ngoal (1 subgoal):\n 1. tree_automaton (ta_remap f TA)", "by (unfold_locales) (auto simp add: ta_remap_def ta_rstates_def)"], ["", "lemma (in ranked_tree_automaton) remap_rta[intro!, simp]:\n  \"ranked_tree_automaton (ta_remap f TA) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_remap f TA) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_remap f TA) A", "interpret ta: tree_automaton \"(ta_remap f TA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton (ta_remap f TA)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_remap f TA) A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_remap f TA) A", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta.\\<delta> \\<Longrightarrow>\n       A f = Some (length qs)", "apply (auto simp add: ta_remap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q fa qs x.\n       \\<lbrakk>q \\<rightarrow> fa qs = remap_rule f x;\n        x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> A fa = Some (length qs)", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q fa qs x x1 x2 x3.\n       \\<lbrakk>q \\<rightarrow> fa qs = remap_rule f x; x \\<in> \\<delta>;\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> A fa = Some (length qs)", "apply (auto simp add: ta_remap_def intro: ranked)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ranked_tree_automaton (ta_remap f TA) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in det_tree_automaton) remap_dta[intro, simp]:\n  assumes INJ: \"inj_on f Q\"\n  shows \"det_tree_automaton (ta_remap f TA) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_tree_automaton (ta_remap f TA) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det_tree_automaton (ta_remap f TA) A", "interpret ta: ranked_tree_automaton \"(ta_remap f TA)\" A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_remap f TA) A", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. det_tree_automaton (ta_remap f TA) A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det_tree_automaton (ta_remap f TA) A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta.\\<delta>;\n        q' \\<rightarrow> f qs \\<in> ta.\\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = q'", "fix q q' l qs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta.\\<delta>;\n        q' \\<rightarrow> f qs \\<in> ta.\\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = q'", "assume A: \n      \"(q \\<rightarrow> l qs) \\<in>ta_rules (ta_remap f TA)\"\n      \"(q' \\<rightarrow> l qs) \\<in>ta_rules (ta_remap f TA)\""], ["proof (state)\nthis:\n  q \\<rightarrow> l qs \\<in> ta.\\<delta>\n  q' \\<rightarrow> l qs \\<in> ta.\\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta.\\<delta>;\n        q' \\<rightarrow> f qs \\<in> ta.\\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = q'", "then"], ["proof (chain)\npicking this:\n  q \\<rightarrow> l qs \\<in> ta.\\<delta>\n  q' \\<rightarrow> l qs \\<in> ta.\\<delta>", "obtain qo qo' qso qso' where RO:\n      \"(qo \\<rightarrow> l qso) \\<in> \\<delta>\"\n      \"(qo' \\<rightarrow> l qso') \\<in> \\<delta>\"\n      and [simp]:\n      \"q=f qo\"\n      \"q'=f qo'\"\n      \"qs = map f qso\"\n      \"map f qso = map f qso'\""], ["proof (prove)\nusing this:\n  q \\<rightarrow> l qs \\<in> ta.\\<delta>\n  q' \\<rightarrow> l qs \\<in> ta.\\<delta>\n\ngoal (1 subgoal):\n 1. (\\<And>qo qso qo' qso'.\n        \\<lbrakk>qo \\<rightarrow> l qso \\<in> \\<delta>;\n         qo' \\<rightarrow> l qso' \\<in> \\<delta>; q = f qo; q' = f qo';\n         qs = map f qso; map f qso = map f qso'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (auto simp add: ta_remap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>qo qso qo' qso'.\n                   \\<lbrakk>qo \\<rightarrow> l qso \\<in> \\<delta>;\n                    qo' \\<rightarrow> l qso' \\<in> \\<delta>; q = f qo;\n                    q' = f qo'; qs = map f qso';\n                    map f qso = map f qso'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        q \\<rightarrow> l qs = remap_rule f x; x \\<in> \\<delta>;\n        q' \\<rightarrow> l qs = remap_rule f xa; xa \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (case_tac x, case_tac xa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>\\<And>qo qso qo' qso'.\n                   \\<lbrakk>qo \\<rightarrow> l qso \\<in> \\<delta>;\n                    qo' \\<rightarrow> l qso' \\<in> \\<delta>; q = f qo;\n                    q' = f qo'; qs = map f qso';\n                    map f qso = map f qso'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        q \\<rightarrow> l qs = remap_rule f x; x \\<in> \\<delta>;\n        q' \\<rightarrow> l qs = remap_rule f xa; xa \\<in> \\<delta>;\n        x = x1 \\<rightarrow> x2 x3; xa = x1a \\<rightarrow> x2a x3a\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  qo \\<rightarrow> l qso \\<in> \\<delta>\n  qo' \\<rightarrow> l qso' \\<in> \\<delta>\n  q = f qo\n  q' = f qo'\n  qs = map f qso\n  map f qso = map f qso'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta.\\<delta>;\n        q' \\<rightarrow> f qs \\<in> ta.\\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = q'", "from RO"], ["proof (chain)\npicking this:\n  qo \\<rightarrow> l qso \\<in> \\<delta>\n  qo' \\<rightarrow> l qso' \\<in> \\<delta>", "have OQ: \"qo\\<in>Q\" \"qo'\\<in>Q\" \"set qso \\<subseteq> Q\" \"set qso' \\<subseteq> Q\""], ["proof (prove)\nusing this:\n  qo \\<rightarrow> l qso \\<in> \\<delta>\n  qo' \\<rightarrow> l qso' \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. (qo \\<in> Q &&& qo' \\<in> Q) &&&\n    set qso \\<subseteq> Q &&& set qso' \\<subseteq> Q", "by (unfold ta_rstates_def)\n         (auto dest: \\<delta>_statesI)"], ["proof (state)\nthis:\n  qo \\<in> Q\n  qo' \\<in> Q\n  set qso \\<subseteq> Q\n  set qso' \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta.\\<delta>;\n        q' \\<rightarrow> f qs \\<in> ta.\\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = q'", "from OQ(3,4)"], ["proof (chain)\npicking this:\n  set qso \\<subseteq> Q\n  set qso' \\<subseteq> Q", "have INJQSO: \"inj_on f (set qso \\<union> set qso')\""], ["proof (prove)\nusing this:\n  set qso \\<subseteq> Q\n  set qso' \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. inj_on f (set qso \\<union> set qso')", "by (auto intro: subset_inj_on[OF INJ])"], ["proof (state)\nthis:\n  inj_on f (set qso \\<union> set qso')\n\ngoal (1 subgoal):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta.\\<delta>;\n        q' \\<rightarrow> f qs \\<in> ta.\\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = q'", "from inj_on_map_eq_map[OF INJQSO]"], ["proof (chain)\npicking this:\n  (map f qso = map f qso') = (qso = qso')", "have \"qso=qso'\""], ["proof (prove)\nusing this:\n  (map f qso = map f qso') = (qso = qso')\n\ngoal (1 subgoal):\n 1. qso = qso'", "by simp"], ["proof (state)\nthis:\n  qso = qso'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta.\\<delta>;\n        q' \\<rightarrow> f qs \\<in> ta.\\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = q'", "with deterministic[OF RO(1)] RO(2)"], ["proof (chain)\npicking this:\n  ?q' \\<rightarrow> l qso \\<in> \\<delta> \\<Longrightarrow> qo = ?q'\n  qo' \\<rightarrow> l qso' \\<in> \\<delta>\n  qso = qso'", "have \"qo=qo'\""], ["proof (prove)\nusing this:\n  ?q' \\<rightarrow> l qso \\<in> \\<delta> \\<Longrightarrow> qo = ?q'\n  qo' \\<rightarrow> l qso' \\<in> \\<delta>\n  qso = qso'\n\ngoal (1 subgoal):\n 1. qo = qo'", "by simp"], ["proof (state)\nthis:\n  qo = qo'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta.\\<delta>;\n        q' \\<rightarrow> f qs \\<in> ta.\\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = q'", "thus \"q=q'\""], ["proof (prove)\nusing this:\n  qo = qo'\n\ngoal (1 subgoal):\n 1. q = q'", "by simp"], ["proof (state)\nthis:\n  q = q'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det_tree_automaton (ta_remap f TA) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in complete_tree_automaton) remap_cta[intro, simp]:\n  assumes INJ: \"inj_on f Q\"\n  shows \"complete_tree_automaton (ta_remap f TA) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_tree_automaton (ta_remap f TA) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. complete_tree_automaton (ta_remap f TA) A", "interpret ta: det_tree_automaton \"(ta_remap f TA)\" A"], ["proof (prove)\ngoal (1 subgoal):\n 1. det_tree_automaton (ta_remap f TA) A", "by (simp add: INJ)"], ["proof (state)\ngoal (1 subgoal):\n 1. complete_tree_automaton (ta_remap f TA) A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_tree_automaton (ta_remap f TA) A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists ta.Q; A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q. q \\<rightarrow> f qs \\<in> ta.\\<delta>", "fix qs l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists ta.Q; A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q. q \\<rightarrow> f qs \\<in> ta.\\<delta>", "assume A:\n      \"qs \\<in> lists (ta_rstates (ta_remap f TA))\" \n      \"A l = Some (length qs)\""], ["proof (state)\nthis:\n  qs \\<in> lists ta.Q\n  A l = Some (length qs)\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists ta.Q; A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q. q \\<rightarrow> f qs \\<in> ta.\\<delta>", "from A(1)"], ["proof (chain)\npicking this:\n  qs \\<in> lists ta.Q", "have \"qs\\<in>lists (f`Q)\""], ["proof (prove)\nusing this:\n  qs \\<in> lists ta.Q\n\ngoal (1 subgoal):\n 1. qs \\<in> lists (f ` Q)", "by (auto simp add: ta_rstates_def ta_remap_def)"], ["proof (state)\nthis:\n  qs \\<in> lists (f ` Q)\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists ta.Q; A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q. q \\<rightarrow> f qs \\<in> ta.\\<delta>", "then"], ["proof (chain)\npicking this:\n  qs \\<in> lists (f ` Q)", "obtain qso where QSO:\n      \"qso\\<in>lists Q\"\n      \"qs = map f qso\""], ["proof (prove)\nusing this:\n  qs \\<in> lists (f ` Q)\n\ngoal (1 subgoal):\n 1. (\\<And>qso.\n        \\<lbrakk>qso \\<in> lists Q; qs = map f qso\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim!: lists_image_witness)"], ["proof (state)\nthis:\n  qso \\<in> lists Q\n  qs = map f qso\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists ta.Q; A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q. q \\<rightarrow> f qs \\<in> ta.\\<delta>", "hence [simp]: \"length qso = length qs\""], ["proof (prove)\nusing this:\n  qso \\<in> lists Q\n  qs = map f qso\n\ngoal (1 subgoal):\n 1. length qso = length qs", "by simp"], ["proof (state)\nthis:\n  length qso = length qs\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists ta.Q; A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q. q \\<rightarrow> f qs \\<in> ta.\\<delta>", "from complete[OF QSO(1)] A(2)"], ["proof (chain)\npicking this:\n  A ?f = Some (length qso) \\<Longrightarrow>\n  \\<exists>q. q \\<rightarrow> ?f qso \\<in> \\<delta>\n  A l = Some (length qs)", "obtain qo where \"(qo \\<rightarrow> l qso) \\<in> \\<delta>\""], ["proof (prove)\nusing this:\n  A ?f = Some (length qso) \\<Longrightarrow>\n  \\<exists>q. q \\<rightarrow> ?f qso \\<in> \\<delta>\n  A l = Some (length qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qo.\n        qo \\<rightarrow> l qso \\<in> \\<delta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qo \\<rightarrow> l qso \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists ta.Q; A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q. q \\<rightarrow> f qs \\<in> ta.\\<delta>", "with QSO(2)"], ["proof (chain)\npicking this:\n  qs = map f qso\n  qo \\<rightarrow> l qso \\<in> \\<delta>", "have \"((f qo) \\<rightarrow> l qs)\\<in>ta_rules (ta_remap f TA)\""], ["proof (prove)\nusing this:\n  qs = map f qso\n  qo \\<rightarrow> l qso \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. f qo \\<rightarrow> l qs \\<in> ta.\\<delta>", "by (force simp add: ta_remap_def)"], ["proof (state)\nthis:\n  f qo \\<rightarrow> l qs \\<in> ta.\\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists ta.Q; A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q. q \\<rightarrow> f qs \\<in> ta.\\<delta>", "thus \"\\<exists>q. q \\<rightarrow> l qs \\<in> ta_rules (ta_remap f TA)\""], ["proof (prove)\nusing this:\n  f qo \\<rightarrow> l qs \\<in> ta.\\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<rightarrow> l qs \\<in> ta.\\<delta>", ".."], ["proof (state)\nthis:\n  \\<exists>q. q \\<rightarrow> l qs \\<in> ta.\\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  complete_tree_automaton (ta_remap f TA) A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Union\""], ["", "definition \"ta_union TA TA' == \n  \\<lparr> ta_initial = ta_initial TA \\<union> ta_initial TA', \n    ta_rules = ta_rules TA \\<union> ta_rules TA' \n  \\<rparr>\"\n\n\\<comment> \\<open>Given two disjoint sets of states, where no rule contains states from\n  both sets, then any accepted tree is also accepted when only using one of the \n  subsets of states and rules. \n  This lemma and its corollaries capture the basic idea of \n  the union-algorithm.\\<close>"], ["", "lemma accs_exclusive_aux: \n  \"\\<lbrakk> accs \\<delta>n n q; \\<delta>n=\\<delta>\\<union>\\<delta>'; \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {}; q\\<in>\\<delta>_states \\<delta> \\<rbrakk> \n   \\<Longrightarrow> accs \\<delta> n q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>accs \\<delta>n n q; \\<delta>n = \\<delta> \\<union> \\<delta>';\n     \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {};\n     q \\<in> \\<delta>_states \\<delta>\\<rbrakk>\n    \\<Longrightarrow> accs \\<delta> n q", "proof (induct arbitrary: \\<delta> \\<delta>' rule: accs.induct[case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>' \\<delta>''.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' \\<delta>''.\n           \\<lbrakk>i < length qs; \\<delta> = \\<delta>' \\<union> \\<delta>'';\n            \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' =\n            {};\n            qs ! i \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) (qs ! i);\n        \\<delta> = \\<delta>' \\<union> \\<delta>'';\n        \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' = {};\n        q \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE f ts) q", "case (step q l qs \\<delta>n ts \\<delta> \\<delta>')"], ["proof (state)\nthis:\n  q \\<rightarrow> l qs \\<in> \\<delta>n\n  length ts = length qs\n  ?i < length qs \\<Longrightarrow> accs \\<delta>n (ts ! ?i) (qs ! ?i)\n  \\<lbrakk>?i < length qs; \\<delta>n = ?\\<delta> \\<union> ?\\<delta>';\n   \\<delta>_states ?\\<delta> \\<inter> \\<delta>_states ?\\<delta>' = {};\n   qs ! ?i \\<in> \\<delta>_states ?\\<delta>\\<rbrakk>\n  \\<Longrightarrow> accs ?\\<delta> (ts ! ?i) (qs ! ?i)\n  \\<delta>n = \\<delta> \\<union> \\<delta>'\n  \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {}\n  q \\<in> \\<delta>_states \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>' \\<delta>''.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' \\<delta>''.\n           \\<lbrakk>i < length qs; \\<delta> = \\<delta>' \\<union> \\<delta>'';\n            \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' =\n            {};\n            qs ! i \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) (qs ! i);\n        \\<delta> = \\<delta>' \\<union> \\<delta>'';\n        \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' = {};\n        q \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE f ts) q", "note [simp] = step.prems(1)"], ["proof (state)\nthis:\n  \\<delta>n = \\<delta> \\<union> \\<delta>'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>' \\<delta>''.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' \\<delta>''.\n           \\<lbrakk>i < length qs; \\<delta> = \\<delta>' \\<union> \\<delta>'';\n            \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' =\n            {};\n            qs ! i \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) (qs ! i);\n        \\<delta> = \\<delta>' \\<union> \\<delta>'';\n        \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' = {};\n        q \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE f ts) q", "note [simp] = step.hyps(2)[symmetric] step.hyps(3)"], ["proof (state)\nthis:\n  length qs = length ts\n  ?i < length qs \\<Longrightarrow> accs \\<delta>n (ts ! ?i) (qs ! ?i)\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>' \\<delta>''.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' \\<delta>''.\n           \\<lbrakk>i < length qs; \\<delta> = \\<delta>' \\<union> \\<delta>'';\n            \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' =\n            {};\n            qs ! i \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) (qs ! i);\n        \\<delta> = \\<delta>' \\<union> \\<delta>'';\n        \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' = {};\n        q \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE f ts) q", "from step.prems"], ["proof (chain)\npicking this:\n  \\<delta>n = \\<delta> \\<union> \\<delta>'\n  \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {}\n  q \\<in> \\<delta>_states \\<delta>", "have \"q\\<notin>\\<delta>_states \\<delta>'\""], ["proof (prove)\nusing this:\n  \\<delta>n = \\<delta> \\<union> \\<delta>'\n  \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {}\n  q \\<in> \\<delta>_states \\<delta>\n\ngoal (1 subgoal):\n 1. q \\<notin> \\<delta>_states \\<delta>'", "by blast"], ["proof (state)\nthis:\n  q \\<notin> \\<delta>_states \\<delta>'\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>' \\<delta>''.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' \\<delta>''.\n           \\<lbrakk>i < length qs; \\<delta> = \\<delta>' \\<union> \\<delta>'';\n            \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' =\n            {};\n            qs ! i \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) (qs ! i);\n        \\<delta> = \\<delta>' \\<union> \\<delta>'';\n        \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' = {};\n        q \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE f ts) q", "with step.hyps(1)"], ["proof (chain)\npicking this:\n  q \\<rightarrow> l qs \\<in> \\<delta>n\n  q \\<notin> \\<delta>_states \\<delta>'", "have \"set qs \\<subseteq> \\<delta>_states \\<delta>\" and R: \"(q \\<rightarrow> l qs)\\<in>\\<delta>\""], ["proof (prove)\nusing this:\n  q \\<rightarrow> l qs \\<in> \\<delta>n\n  q \\<notin> \\<delta>_states \\<delta>'\n\ngoal (1 subgoal):\n 1. set qs \\<subseteq> \\<delta>_states \\<delta> &&&\n    q \\<rightarrow> l qs \\<in> \\<delta>", "by (auto dest: \\<delta>_statesI)"], ["proof (state)\nthis:\n  set qs \\<subseteq> \\<delta>_states \\<delta>\n  q \\<rightarrow> l qs \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>' \\<delta>''.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' \\<delta>''.\n           \\<lbrakk>i < length qs; \\<delta> = \\<delta>' \\<union> \\<delta>'';\n            \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' =\n            {};\n            qs ! i \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) (qs ! i);\n        \\<delta> = \\<delta>' \\<union> \\<delta>'';\n        \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' = {};\n        q \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE f ts) q", "hence \"!!i. i<length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i)\""], ["proof (prove)\nusing this:\n  set qs \\<subseteq> \\<delta>_states \\<delta>\n  q \\<rightarrow> l qs \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i)", "by (force intro: step.hyps(4)[OF _ step.prems(1,2)])"], ["proof (state)\nthis:\n  ?i < length qs \\<Longrightarrow> accs \\<delta> (ts ! ?i) (qs ! ?i)\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>' \\<delta>''.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>' \\<delta>''.\n           \\<lbrakk>i < length qs; \\<delta> = \\<delta>' \\<union> \\<delta>'';\n            \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' =\n            {};\n            qs ! i \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n           \\<Longrightarrow> accs \\<delta>' (ts ! i) (qs ! i);\n        \\<delta> = \\<delta>' \\<union> \\<delta>'';\n        \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta>'' = {};\n        q \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>' (NODE f ts) q", "with accs.intros[OF R step.hyps(2)]"], ["proof (chain)\npicking this:\n  (\\<And>i.\n      i < length qs \\<Longrightarrow>\n      accs \\<delta> (ts ! i) (qs ! i)) \\<Longrightarrow>\n  accs \\<delta> (NODE l ts) q\n  ?i < length qs \\<Longrightarrow> accs \\<delta> (ts ! ?i) (qs ! ?i)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>i.\n      i < length qs \\<Longrightarrow>\n      accs \\<delta> (ts ! i) (qs ! i)) \\<Longrightarrow>\n  accs \\<delta> (NODE l ts) q\n  ?i < length qs \\<Longrightarrow> accs \\<delta> (ts ! ?i) (qs ! ?i)\n\ngoal (1 subgoal):\n 1. accs \\<delta> (NODE l ts) q", "."], ["proof (state)\nthis:\n  accs \\<delta> (NODE l ts) q\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary accs_exclusive1: \n  \"\\<lbrakk> accs (\\<delta>\\<union>\\<delta>') n q; \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {}; q\\<in>\\<delta>_states \\<delta> \\<rbrakk> \n   \\<Longrightarrow> accs \\<delta> n q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>accs (\\<delta> \\<union> \\<delta>') n q;\n     \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {};\n     q \\<in> \\<delta>_states \\<delta>\\<rbrakk>\n    \\<Longrightarrow> accs \\<delta> n q", "using accs_exclusive_aux[of _ n q \\<delta> \\<delta>']"], ["proof (prove)\nusing this:\n  \\<lbrakk>accs ?\\<delta>n n q; ?\\<delta>n = \\<delta> \\<union> \\<delta>';\n   \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {};\n   q \\<in> \\<delta>_states \\<delta>\\<rbrakk>\n  \\<Longrightarrow> accs \\<delta> n q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>accs (\\<delta> \\<union> \\<delta>') n q;\n     \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {};\n     q \\<in> \\<delta>_states \\<delta>\\<rbrakk>\n    \\<Longrightarrow> accs \\<delta> n q", "by blast"], ["", "corollary accs_exclusive2: \n  \"\\<lbrakk> accs (\\<delta>\\<union>\\<delta>') n q; \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {}; q\\<in>\\<delta>_states \\<delta>' \\<rbrakk> \n   \\<Longrightarrow> accs \\<delta>' n q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>accs (\\<delta> \\<union> \\<delta>') n q;\n     \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {};\n     q \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n    \\<Longrightarrow> accs \\<delta>' n q", "using accs_exclusive_aux[of _ n q \\<delta>' \\<delta>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>accs ?\\<delta>n n q; ?\\<delta>n = \\<delta>' \\<union> \\<delta>;\n   \\<delta>_states \\<delta>' \\<inter> \\<delta>_states \\<delta> = {};\n   q \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n  \\<Longrightarrow> accs \\<delta>' n q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>accs (\\<delta> \\<union> \\<delta>') n q;\n     \\<delta>_states \\<delta> \\<inter> \\<delta>_states \\<delta>' = {};\n     q \\<in> \\<delta>_states \\<delta>'\\<rbrakk>\n    \\<Longrightarrow> accs \\<delta>' n q", "by blast"], ["", "lemma ta_union_correct_aux1: \n  fixes TA TA'\n  assumes TA: \"tree_automaton TA\"\n  assumes TA': \"tree_automaton TA'\"\n  assumes DJ: \"ta_rstates TA \\<inter> ta_rstates TA' = {}\" \n  shows \"ta_lang (ta_union TA TA') = ta_lang TA \\<union> ta_lang TA'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (ta_union TA TA') = ta_lang TA \\<union> ta_lang TA'", "proof (safe)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ta_lang (ta_union TA TA');\n        x \\<notin> ta_lang TA'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x.\n       x \\<in> ta_lang TA \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')\n 3. \\<And>x.\n       x \\<in> ta_lang TA' \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')", "interpret ta: tree_automaton TA"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton TA", "using TA"], ["proof (prove)\nusing this:\n  tree_automaton TA\n\ngoal (1 subgoal):\n 1. tree_automaton TA", "."], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ta_lang (ta_union TA TA');\n        x \\<notin> ta_lang TA'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x.\n       x \\<in> ta_lang TA \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')\n 3. \\<And>x.\n       x \\<in> ta_lang TA' \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')", "interpret ta': tree_automaton TA'"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton TA'", "using TA'"], ["proof (prove)\nusing this:\n  tree_automaton TA'\n\ngoal (1 subgoal):\n 1. tree_automaton TA'", "."], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ta_lang (ta_union TA TA');\n        x \\<notin> ta_lang TA'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x.\n       x \\<in> ta_lang TA \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')\n 3. \\<And>x.\n       x \\<in> ta_lang TA' \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')", "from DJ ta.states_subset ta'.states_subset"], ["proof (chain)\npicking this:\n  ta.Q \\<inter> ta'.Q = {}\n  \\<delta>_states ta.\\<delta> \\<subseteq> ta.Q\n  \\<delta>_states ta'.\\<delta> \\<subseteq> ta'.Q", "have \n    DJ': \"\\<delta>_states (ta_rules TA) \\<inter> \\<delta>_states (ta_rules TA') = {}\""], ["proof (prove)\nusing this:\n  ta.Q \\<inter> ta'.Q = {}\n  \\<delta>_states ta.\\<delta> \\<subseteq> ta.Q\n  \\<delta>_states ta'.\\<delta> \\<subseteq> ta'.Q\n\ngoal (1 subgoal):\n 1. \\<delta>_states ta.\\<delta> \\<inter> \\<delta>_states ta'.\\<delta> = {}", "by blast"], ["proof (state)\nthis:\n  \\<delta>_states ta.\\<delta> \\<inter> \\<delta>_states ta'.\\<delta> = {}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ta_lang (ta_union TA TA');\n        x \\<notin> ta_lang TA'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x.\n       x \\<in> ta_lang TA \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')\n 3. \\<And>x.\n       x \\<in> ta_lang TA' \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')", "fix n"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ta_lang (ta_union TA TA');\n        x \\<notin> ta_lang TA'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x.\n       x \\<in> ta_lang TA \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')\n 3. \\<And>x.\n       x \\<in> ta_lang TA' \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')", "assume A: \"n \\<in> ta_lang (ta_union TA TA')\" \"n \\<notin> ta_lang TA'\""], ["proof (state)\nthis:\n  n \\<in> ta_lang (ta_union TA TA')\n  n \\<notin> ta_lang TA'\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ta_lang (ta_union TA TA');\n        x \\<notin> ta_lang TA'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x.\n       x \\<in> ta_lang TA \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')\n 3. \\<And>x.\n       x \\<in> ta_lang TA' \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')", "from A(1)"], ["proof (chain)\npicking this:\n  n \\<in> ta_lang (ta_union TA TA')", "obtain q where \n    B: \"q\\<in>ta_initial TA \\<union> ta_initial TA'\" \n       \"accs (ta_rules TA \\<union> ta_rules TA') n q\""], ["proof (prove)\nusing this:\n  n \\<in> ta_lang (ta_union TA TA')\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> ta.Qi \\<union> ta'.Qi;\n         accs (ta.\\<delta> \\<union> ta'.\\<delta>) n q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: ta_lang_def ta_union_def)"], ["proof (state)\nthis:\n  q \\<in> ta.Qi \\<union> ta'.Qi\n  accs (ta.\\<delta> \\<union> ta'.\\<delta>) n q\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ta_lang (ta_union TA TA');\n        x \\<notin> ta_lang TA'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x.\n       x \\<in> ta_lang TA \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')\n 3. \\<And>x.\n       x \\<in> ta_lang TA' \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')", "from \\<delta>_states_accsI[OF B(2), simplified]"], ["proof (chain)\npicking this:\n  q \\<in> \\<delta>_states ta.\\<delta> \\<or>\n  q \\<in> \\<delta>_states ta'.\\<delta>", "show \"n\\<in>ta_lang TA\""], ["proof (prove)\nusing this:\n  q \\<in> \\<delta>_states ta.\\<delta> \\<or>\n  q \\<in> \\<delta>_states ta'.\\<delta>\n\ngoal (1 subgoal):\n 1. n \\<in> ta_lang TA", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> \\<delta>_states ta.\\<delta> \\<Longrightarrow> n \\<in> ta_lang TA\n 2. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "assume C: \"q\\<in>\\<delta>_states (ta_rules TA)\""], ["proof (state)\nthis:\n  q \\<in> \\<delta>_states ta.\\<delta>\n\ngoal (2 subgoals):\n 1. q \\<in> \\<delta>_states ta.\\<delta> \\<Longrightarrow> n \\<in> ta_lang TA\n 2. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "with accs_exclusive1[OF B(2) DJ']"], ["proof (chain)\npicking this:\n  q \\<in> \\<delta>_states ta.\\<delta> \\<Longrightarrow> accs ta.\\<delta> n q\n  q \\<in> \\<delta>_states ta.\\<delta>", "have \"accs (ta_rules TA) n q\""], ["proof (prove)\nusing this:\n  q \\<in> \\<delta>_states ta.\\<delta> \\<Longrightarrow> accs ta.\\<delta> n q\n  q \\<in> \\<delta>_states ta.\\<delta>\n\ngoal (1 subgoal):\n 1. accs ta.\\<delta> n q", "."], ["proof (state)\nthis:\n  accs ta.\\<delta> n q\n\ngoal (2 subgoals):\n 1. q \\<in> \\<delta>_states ta.\\<delta> \\<Longrightarrow> n \\<in> ta_lang TA\n 2. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "moreover"], ["proof (state)\nthis:\n  accs ta.\\<delta> n q\n\ngoal (2 subgoals):\n 1. q \\<in> \\<delta>_states ta.\\<delta> \\<Longrightarrow> n \\<in> ta_lang TA\n 2. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "from DJ C ta'.initial_subset ta.states_subset B(1)"], ["proof (chain)\npicking this:\n  ta.Q \\<inter> ta'.Q = {}\n  q \\<in> \\<delta>_states ta.\\<delta>\n  ta'.Qi \\<subseteq> ta'.Q\n  \\<delta>_states ta.\\<delta> \\<subseteq> ta.Q\n  q \\<in> ta.Qi \\<union> ta'.Qi", "have \n      \"q\\<in>ta_initial TA\""], ["proof (prove)\nusing this:\n  ta.Q \\<inter> ta'.Q = {}\n  q \\<in> \\<delta>_states ta.\\<delta>\n  ta'.Qi \\<subseteq> ta'.Q\n  \\<delta>_states ta.\\<delta> \\<subseteq> ta.Q\n  q \\<in> ta.Qi \\<union> ta'.Qi\n\ngoal (1 subgoal):\n 1. q \\<in> ta.Qi", "by auto"], ["proof (state)\nthis:\n  q \\<in> ta.Qi\n\ngoal (2 subgoals):\n 1. q \\<in> \\<delta>_states ta.\\<delta> \\<Longrightarrow> n \\<in> ta_lang TA\n 2. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "ultimately"], ["proof (chain)\npicking this:\n  accs ta.\\<delta> n q\n  q \\<in> ta.Qi", "show ?thesis"], ["proof (prove)\nusing this:\n  accs ta.\\<delta> n q\n  q \\<in> ta.Qi\n\ngoal (1 subgoal):\n 1. n \\<in> ta_lang TA", "by (unfold ta_lang_def) auto"], ["proof (state)\nthis:\n  n \\<in> ta_lang TA\n\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "assume C: \"q\\<in>\\<delta>_states (ta_rules TA')\""], ["proof (state)\nthis:\n  q \\<in> \\<delta>_states ta'.\\<delta>\n\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "with accs_exclusive2[OF B(2) DJ']"], ["proof (chain)\npicking this:\n  q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n  accs ta'.\\<delta> n q\n  q \\<in> \\<delta>_states ta'.\\<delta>", "have \"accs (ta_rules TA') n q\""], ["proof (prove)\nusing this:\n  q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n  accs ta'.\\<delta> n q\n  q \\<in> \\<delta>_states ta'.\\<delta>\n\ngoal (1 subgoal):\n 1. accs ta'.\\<delta> n q", "."], ["proof (state)\nthis:\n  accs ta'.\\<delta> n q\n\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "moreover"], ["proof (state)\nthis:\n  accs ta'.\\<delta> n q\n\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "from DJ C ta.initial_subset B(1) ta'.states_subset"], ["proof (chain)\npicking this:\n  ta.Q \\<inter> ta'.Q = {}\n  q \\<in> \\<delta>_states ta'.\\<delta>\n  ta.Qi \\<subseteq> ta.Q\n  q \\<in> ta.Qi \\<union> ta'.Qi\n  \\<delta>_states ta'.\\<delta> \\<subseteq> ta'.Q", "have \n      \"q\\<in>ta_initial TA'\""], ["proof (prove)\nusing this:\n  ta.Q \\<inter> ta'.Q = {}\n  q \\<in> \\<delta>_states ta'.\\<delta>\n  ta.Qi \\<subseteq> ta.Q\n  q \\<in> ta.Qi \\<union> ta'.Qi\n  \\<delta>_states ta'.\\<delta> \\<subseteq> ta'.Q\n\ngoal (1 subgoal):\n 1. q \\<in> ta'.Qi", "by auto"], ["proof (state)\nthis:\n  q \\<in> ta'.Qi\n\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "ultimately"], ["proof (chain)\npicking this:\n  accs ta'.\\<delta> n q\n  q \\<in> ta'.Qi", "have False"], ["proof (prove)\nusing this:\n  accs ta'.\\<delta> n q\n  q \\<in> ta'.Qi\n\ngoal (1 subgoal):\n 1. False", "using A(2)"], ["proof (prove)\nusing this:\n  accs ta'.\\<delta> n q\n  q \\<in> ta'.Qi\n  n \\<notin> ta_lang TA'\n\ngoal (1 subgoal):\n 1. False", "by (unfold ta_lang_def) auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states ta'.\\<delta> \\<Longrightarrow>\n    n \\<in> ta_lang TA", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n \\<in> ta_lang TA", ".."], ["proof (state)\nthis:\n  n \\<in> ta_lang TA\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> ta_lang TA\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ta_lang TA \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')\n 2. \\<And>x.\n       x \\<in> ta_lang TA' \\<Longrightarrow>\n       x \\<in> ta_lang (ta_union TA TA')", "qed (unfold ta_lang_def ta_union_def, auto intro: accs_mono)"], ["", "lemma ta_union_correct_aux2: \n  fixes TA TA'\n  assumes TA: \"tree_automaton TA\"\n  assumes TA': \"tree_automaton TA'\"\n  shows \"tree_automaton (ta_union TA TA')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton (ta_union TA TA')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tree_automaton (ta_union TA TA')", "interpret ta: tree_automaton TA"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton TA", "using TA"], ["proof (prove)\nusing this:\n  tree_automaton TA\n\ngoal (1 subgoal):\n 1. tree_automaton TA", "."], ["proof (state)\ngoal (1 subgoal):\n 1. tree_automaton (ta_union TA TA')", "interpret ta': tree_automaton TA'"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton TA'", "using TA'"], ["proof (prove)\nusing this:\n  tree_automaton TA'\n\ngoal (1 subgoal):\n 1. tree_automaton TA'", "."], ["proof (state)\ngoal (1 subgoal):\n 1. tree_automaton (ta_union TA TA')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton (ta_union TA TA')", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (ta_rules (ta_union TA TA'))\n 2. finite (ta_initial (ta_union TA TA'))", "apply (unfold ta_union_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (ta_rules\n       \\<lparr>ta_initial = ta.Qi \\<union> ta'.Qi,\n          ta_rules = ta.\\<delta> \\<union> ta'.\\<delta>\\<rparr>)\n 2. finite\n     (ta_initial\n       \\<lparr>ta_initial = ta.Qi \\<union> ta'.Qi,\n          ta_rules = ta.\\<delta> \\<union> ta'.\\<delta>\\<rparr>)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  tree_automaton (ta_union TA TA')\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>If the sets of states are disjoint, the language of the union-automaton\n    is the union of the languages of the original automata.\\<close>"], ["", "theorem ta_union_correct:\n  fixes TA TA'\n  assumes TA: \"tree_automaton TA\"\n  assumes TA': \"tree_automaton TA'\"\n  assumes DJ: \"ta_rstates TA \\<inter> ta_rstates TA' = {}\" \n  shows \"ta_lang (ta_union TA TA') = ta_lang TA \\<union> ta_lang TA'\"\n        \"tree_automaton (ta_union TA TA')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (ta_union TA TA') = ta_lang TA \\<union> ta_lang TA' &&&\n    tree_automaton (ta_union TA TA')", "using ta_union_correct_aux1[OF TA TA' DJ]\n        ta_union_correct_aux2[OF TA TA']"], ["proof (prove)\nusing this:\n  ta_lang (ta_union TA TA') = ta_lang TA \\<union> ta_lang TA'\n  tree_automaton (ta_union TA TA')\n\ngoal (1 subgoal):\n 1. ta_lang (ta_union TA TA') = ta_lang TA \\<union> ta_lang TA' &&&\n    tree_automaton (ta_union TA TA')", "by auto"], ["", "lemma ta_union_rta: \n  fixes TA TA'\n  assumes TA: \"ranked_tree_automaton TA A\"\n  assumes TA': \"ranked_tree_automaton TA' A\"\n  shows \"ranked_tree_automaton (ta_union TA TA') A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_union TA TA') A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_union TA TA') A", "interpret ta: ranked_tree_automaton TA A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA A", "using TA"], ["proof (prove)\nusing this:\n  ranked_tree_automaton TA A\n\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA A", "."], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_union TA TA') A", "interpret ta': ranked_tree_automaton TA' A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA' A", "using TA'"], ["proof (prove)\nusing this:\n  ranked_tree_automaton TA' A\n\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA' A", "."], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_union TA TA') A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_union TA TA') A", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (ta_rules (ta_union TA TA'))\n 2. finite (ta_initial (ta_union TA TA'))\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs\n       \\<in> ta_rules (ta_union TA TA') \\<Longrightarrow>\n       A f = Some (length qs)", "apply (unfold ta_union_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     (ta_rules\n       \\<lparr>ta_initial = ta.Qi \\<union> ta'.Qi,\n          ta_rules = ta.\\<delta> \\<union> ta'.\\<delta>\\<rparr>)\n 2. finite\n     (ta_initial\n       \\<lparr>ta_initial = ta.Qi \\<union> ta'.Qi,\n          ta_rules = ta.\\<delta> \\<union> ta'.\\<delta>\\<rparr>)\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs\n       \\<in> ta_rules\n              \\<lparr>ta_initial = ta.Qi \\<union> ta'.Qi,\n                 ta_rules =\n                   ta.\\<delta> \\<union>\n                   ta'.\\<delta>\\<rparr> \\<Longrightarrow>\n       A f = Some (length qs)", "apply (auto intro: ta.ranked ta'.ranked)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ranked_tree_automaton (ta_union TA TA') A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \"The union-algorithm may wrap the states of the first and second automaton \n      in order to make them disjoint\""], ["", "datatype ('q1,'q2) ustate_wrapper = USW1 'q1 | USW2 'q2"], ["", "lemma usw_disjoint[simp]: \n  \"USW1 ` X \\<inter> USW2 ` Y = {}\"\n  \"remap_rule USW1 ` X \\<inter> remap_rule USW2 ` Y = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. USW1 ` X \\<inter> USW2 ` Y = {} &&&\n    remap_rule USW1 ` X \\<inter> remap_rule USW2 ` Y = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>xa \\<in> X; remap_rule USW1 xa = remap_rule USW2 xb;\n        xb \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac xa, case_tac xb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>xa \\<in> X; remap_rule USW1 xa = remap_rule USW2 xb;\n        xb \\<in> Y; xa = x1 \\<rightarrow> x2 x3;\n        xb = x1a \\<rightarrow> x2a x3a\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma states_usw_disjoint[simp]: \n  \"ta_rstates (ta_remap USW1 X) \\<inter> ta_rstates (ta_remap USW2 Y) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_rstates (ta_remap USW1 X) \\<inter> ta_rstates (ta_remap USW2 Y) = {}", "by (auto simp add: ta_remap_def ta_rstates_def)"], ["", "lemma usw_inj_on[simp, intro!]:\n  \"inj_on USW1 X\" \n  \"inj_on USW2 X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on USW1 X &&& inj_on USW2 X", "by (auto intro: inj_onI)"], ["", "definition \"ta_union_wrap TA TA' = \n  ta_union (ta_remap USW1 TA) (ta_remap USW2 TA')\""], ["", "lemma ta_union_wrap_correct:\n  fixes TA :: \"('Q1,'L) tree_automaton_rec\"\n  fixes TA' :: \"('Q2,'L) tree_automaton_rec\"\n  assumes TA: \"tree_automaton TA\"\n  assumes TA': \"tree_automaton TA'\"\n  shows \"ta_lang (ta_union_wrap TA TA') = ta_lang TA \\<union> ta_lang TA'\" (is ?T1)\n        \"tree_automaton (ta_union_wrap TA TA')\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (ta_union_wrap TA TA') = ta_lang TA \\<union> ta_lang TA' &&&\n    tree_automaton (ta_union_wrap TA TA')", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ta_lang (ta_union_wrap TA TA') = ta_lang TA \\<union> ta_lang TA'\n 2. tree_automaton (ta_union_wrap TA TA')", "interpret a1: tree_automaton TA"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton TA", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. ta_lang (ta_union_wrap TA TA') = ta_lang TA \\<union> ta_lang TA'\n 2. tree_automaton (ta_union_wrap TA TA')", "interpret a2: tree_automaton TA'"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton TA'", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. ta_lang (ta_union_wrap TA TA') = ta_lang TA \\<union> ta_lang TA'\n 2. tree_automaton (ta_union_wrap TA TA')", "show ?T1 ?T2"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (ta_union_wrap TA TA') = ta_lang TA \\<union> ta_lang TA' &&&\n    tree_automaton (ta_union_wrap TA TA')", "by (unfold ta_union_wrap_def)\n       (simp_all add: ta_union_correct a1.remap_lang a2.remap_lang)"], ["proof (state)\nthis:\n  ta_lang (ta_union_wrap TA TA') = ta_lang TA \\<union> ta_lang TA'\n  tree_automaton (ta_union_wrap TA TA')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ta_union_wrap_rta:\n  fixes TA TA'\n  assumes TA: \"ranked_tree_automaton TA A\"\n  assumes TA': \"ranked_tree_automaton TA' A\"\n  shows \"ranked_tree_automaton (ta_union_wrap TA TA') A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_union_wrap TA TA') A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_union_wrap TA TA') A", "interpret ta: ranked_tree_automaton TA A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA A", "using TA"], ["proof (prove)\nusing this:\n  ranked_tree_automaton TA A\n\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA A", "."], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_union_wrap TA TA') A", "interpret ta': ranked_tree_automaton TA' A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA' A", "using TA'"], ["proof (prove)\nusing this:\n  ranked_tree_automaton TA' A\n\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA' A", "."], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_union_wrap TA TA') A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_union_wrap TA TA') A", "by (unfold ta_union_wrap_def)\n       (simp add: ta_union_rta)"], ["proof (state)\nthis:\n  ranked_tree_automaton (ta_union_wrap TA TA') A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Reduction\""], ["", "definition \"reduce_rules \\<delta> P == \\<delta> \\<inter> { r. rule_states r \\<subseteq> P }\""], ["", "lemma reduce_rulesI: \"\\<lbrakk>r\\<in>\\<delta>; rule_states r \\<subseteq> P\\<rbrakk> \\<Longrightarrow> r\\<in>reduce_rules \\<delta> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> \\<delta>; rule_states r \\<subseteq> P\\<rbrakk>\n    \\<Longrightarrow> r \\<in> reduce_rules \\<delta> P", "by (unfold reduce_rules_def) auto"], ["", "lemma reduce_rulesD: \n  \"\\<lbrakk> r\\<in>reduce_rules \\<delta> P \\<rbrakk> \\<Longrightarrow> r\\<in>\\<delta>\"\n  \"\\<lbrakk> r\\<in>reduce_rules \\<delta> P; q\\<in>rule_states r\\<rbrakk> \\<Longrightarrow> q\\<in>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<in> reduce_rules \\<delta> P \\<Longrightarrow> r \\<in> \\<delta>) &&&\n    (\\<lbrakk>r \\<in> reduce_rules \\<delta> P;\n      q \\<in> rule_states r\\<rbrakk>\n     \\<Longrightarrow> q \\<in> P)", "by (unfold reduce_rules_def) auto"], ["", "lemma reduce_rules_subset: \"reduce_rules \\<delta> P \\<subseteq> \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_rules \\<delta> P \\<subseteq> \\<delta>", "by (unfold reduce_rules_def) auto"], ["", "lemma reduce_rules_mono: \"P \\<subseteq> P' \\<Longrightarrow> reduce_rules \\<delta> P \\<subseteq> reduce_rules \\<delta> P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> P' \\<Longrightarrow>\n    reduce_rules \\<delta> P \\<subseteq> reduce_rules \\<delta> P'", "by (unfold reduce_rules_def) auto"], ["", "lemma \\<delta>_states_reduce_subset: \n  shows \"\\<delta>_states (reduce_rules \\<delta> Q) \\<subseteq> \\<delta>_states \\<delta> \\<inter> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_states (reduce_rules \\<delta> Q)\n    \\<subseteq> \\<delta>_states \\<delta> \\<inter> Q", "by (unfold \\<delta>_states_def reduce_rules_def)\n    auto"], ["", "lemmas \\<delta>_states_reduce_subsetI = rev_subsetD[OF _ \\<delta>_states_reduce_subset]"], ["", "definition ta_reduce \n  :: \"('Q,'L) tree_automaton_rec \\<Rightarrow> ('Q set) \\<Rightarrow> ('Q,'L) tree_automaton_rec\"\n  where \"ta_reduce TA P ==\n    \\<lparr> ta_initial = ta_initial TA \\<inter> P,\n      ta_rules = reduce_rules (ta_rules TA) P \\<rparr>\"\n\n\\<comment> \\<open>Reducing a tree automaton preserves the tree automata invariants\\<close>"], ["", "theorem ta_reduce_inv: assumes A: \"tree_automaton TA\" \n  shows \"tree_automaton (ta_reduce TA P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton (ta_reduce TA P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tree_automaton (ta_reduce TA P)", "interpret tree_automaton TA"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton TA", "using A"], ["proof (prove)\nusing this:\n  tree_automaton TA\n\ngoal (1 subgoal):\n 1. tree_automaton TA", "."], ["proof (state)\ngoal (1 subgoal):\n 1. tree_automaton (ta_reduce TA P)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton (ta_reduce TA P)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (ta_rules (ta_reduce TA P))\n 2. finite (ta_initial (ta_reduce TA P))", "show \"finite (ta_rules (ta_reduce TA P))\" \n         \"finite (ta_initial (ta_reduce TA P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (ta_rules (ta_reduce TA P)) &&&\n    finite (ta_initial (ta_reduce TA P))", "using finite_states finite_rules finite_subset[OF reduce_rules_subset]"], ["proof (prove)\nusing this:\n  finite Q\n  finite \\<delta>\n  finite ?B \\<Longrightarrow> finite (reduce_rules ?B ?P1)\n\ngoal (1 subgoal):\n 1. finite (ta_rules (ta_reduce TA P)) &&&\n    finite (ta_initial (ta_reduce TA P))", "by (unfold ta_reduce_def) (auto simp add: Let_def)"], ["proof (state)\nthis:\n  finite (ta_rules (ta_reduce TA P))\n  finite (ta_initial (ta_reduce TA P))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tree_automaton (ta_reduce TA P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduce_\\<delta>_states_rules[simp]: \n  \"(ta_rules (ta_reduce TA (\\<delta>_states (ta_rules TA)))) = ta_rules TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_rules (ta_reduce TA (\\<delta>_states (ta_rules TA))) = ta_rules TA", "by (auto simp add: ta_reduce_def \\<delta>_states_def reduce_rules_def)\n\n\\<comment> \\<open>Reducing a tree automaton to the states that occur in its rules does \n      not change its language\\<close>"], ["", "lemma ta_reduce_\\<delta>_states: \n  \"ta_lang (ta_reduce TA (\\<delta>_states (ta_rules TA))) = ta_lang TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (ta_reduce TA (\\<delta>_states (ta_rules TA))) = ta_lang TA", "apply (auto simp add: ta_lang_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial\n                         (ta_reduce TA (\\<delta>_states (ta_rules TA)));\n        accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial\n   (ta_reduce TA (\\<delta>_states (ta_rules TA))).\n                            accs (ta_rules TA) x q", "apply (frule \\<delta>_states_accsI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial\n                         (ta_reduce TA (\\<delta>_states (ta_rules TA)));\n        accs (ta_rules TA) x q;\n        q \\<in> \\<delta>_states (ta_rules TA)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial\n   (ta_reduce TA (\\<delta>_states (ta_rules TA))).\n                            accs (ta_rules TA) x q", "apply (auto simp add: ta_reduce_def \\<delta>_states_def reduce_rules_def) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial\n   (ta_reduce TA (\\<delta>_states (ta_rules TA))).\n                            accs (ta_rules TA) x q", "apply (frule \\<delta>_states_accsI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q;\n        q \\<in> \\<delta>_states (ta_rules TA)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial\n   (ta_reduce TA (\\<delta>_states (ta_rules TA))).\n                            accs (ta_rules TA) x q", "apply (auto simp add: ta_reduce_def \\<delta>_states_def reduce_rules_def) [1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text_raw \\<open>\\paragraph{Forward Reduction}\\<close>"], ["", "text \\<open>\n  We characterize the set of forward accessible states by the reflexive,\n  transitive closure of a forward-successor (\\<open>f_succ \\<subseteq> Q\\<times>Q\\<close>) relation \n  applied to the initial states.\n  \n  The forward-successors of a state $q$ are those states $q'$ such that there is\n  a rule $q \\leftarrow f(\\ldots q' \\ldots)$.\n\\<close>\n\n  \\<comment> \\<open>Forward successors\\<close>"], ["", "inductive_set f_succ for \\<delta> where\n  \"\\<lbrakk>(q \\<rightarrow> l qs)\\<in>\\<delta>; q'\\<in>set qs\\<rbrakk> \\<Longrightarrow> (q,q') \\<in> f_succ \\<delta>\"\n\n  \\<comment> \\<open>Alternative characterization of forward successors\\<close>"], ["", "lemma f_succ_alt: \"f_succ \\<delta> = {(q,q'). \\<exists>l qs. (q \\<rightarrow> l qs)\\<in>\\<delta> \\<and> q'\\<in>set qs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_succ \\<delta> =\n    {(q, q').\n     \\<exists>l qs.\n        q \\<rightarrow> l qs \\<in> \\<delta> \\<and> q' \\<in> set qs}", "by (auto intro: f_succ.intros elim!: f_succ.cases)\n\n  \\<comment> \\<open>Forward accessible states\\<close>"], ["", "definition \"f_accessible \\<delta> Q0 == ((f_succ \\<delta>)\\<^sup>*) `` Q0\"\n\n  \\<comment> \\<open>Alternative characterization of forward accessible states.\n      The initial states are forward accessible, and if there is a rule\n      whose lhs-state is forward-accessible, all rhs-states of that rule\n      are forward-accessible, too.\\<close>"], ["", "inductive_set f_accessible_alt :: \"('Q,'L) ta_rule set \\<Rightarrow> 'Q set \\<Rightarrow> 'Q set\"\nfor \\<delta> Q0\nwhere\n  fa_refl: \"q0\\<in>Q0 \\<Longrightarrow> q0 \\<in> f_accessible_alt \\<delta> Q0\" |\n  fa_step: \"\\<lbrakk> q\\<in>f_accessible_alt \\<delta> Q0; (q \\<rightarrow> l qs)\\<in>\\<delta>; q'\\<in>set qs \\<rbrakk> \n            \\<Longrightarrow> q' \\<in> f_accessible_alt \\<delta> Q0\""], ["", "lemma f_accessible_alt: \"f_accessible \\<delta> Q0 = f_accessible_alt \\<delta> Q0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_accessible \\<delta> Q0 = f_accessible_alt \\<delta> Q0", "apply (unfold f_accessible_def f_succ_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(q, q').\n     \\<exists>l qs.\n        q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n        q' \\<in> set qs}\\<^sup>* ``\n    Q0 =\n    f_accessible_alt \\<delta> Q0", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x)\n                \\<in> {(q, q').\n                       \\<exists>l qs.\n                          q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                          q' \\<in> set qs}\\<^sup>*;\n        xa \\<in> Q0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f_accessible_alt \\<delta> Q0\n 2. \\<And>x.\n       x \\<in> f_accessible_alt \\<delta> Q0 \\<Longrightarrow>\n       x \\<in> {(q, q').\n                \\<exists>l qs.\n                   q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                   q' \\<in> set qs}\\<^sup>* ``\n               Q0", "proof goal_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x)\n                \\<in> {(q, q').\n                       \\<exists>l qs.\n                          q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                          q' \\<in> set qs}\\<^sup>*;\n        xa \\<in> Q0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f_accessible_alt \\<delta> Q0\n 2. \\<And>x.\n       x \\<in> f_accessible_alt \\<delta> Q0 \\<Longrightarrow>\n       x \\<in> {(q, q').\n                \\<exists>l qs.\n                   q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                   q' \\<in> set qs}\\<^sup>* ``\n               Q0", "case 1"], ["proof (state)\nthis:\n  (xa_, x_)\n  \\<in> {(q, q').\n         \\<exists>l qs.\n            q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n            q' \\<in> set qs}\\<^sup>*\n  xa_ \\<in> Q0\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x)\n                \\<in> {(q, q').\n                       \\<exists>l qs.\n                          q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                          q' \\<in> set qs}\\<^sup>*;\n        xa \\<in> Q0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f_accessible_alt \\<delta> Q0\n 2. \\<And>x.\n       x \\<in> f_accessible_alt \\<delta> Q0 \\<Longrightarrow>\n       x \\<in> {(q, q').\n                \\<exists>l qs.\n                   q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                   q' \\<in> set qs}\\<^sup>* ``\n               Q0", "thus ?case"], ["proof (prove)\nusing this:\n  (xa_, x_)\n  \\<in> {(q, q').\n         \\<exists>l qs.\n            q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n            q' \\<in> set qs}\\<^sup>*\n  xa_ \\<in> Q0\n\ngoal (1 subgoal):\n 1. x_ \\<in> f_accessible_alt \\<delta> Q0", "apply (induct rule: rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. xa_ \\<in> Q0 \\<Longrightarrow> xa_ \\<in> f_accessible_alt \\<delta> Q0\n 2. \\<And>y z.\n       \\<lbrakk>(xa_, y)\n                \\<in> {(q, q').\n                       \\<exists>l qs.\n                          q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                          q' \\<in> set qs}\\<^sup>*;\n        (y, z)\n        \\<in> {(q, q').\n               \\<exists>l qs.\n                  q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                  q' \\<in> set qs};\n        xa_ \\<in> Q0 \\<Longrightarrow> y \\<in> f_accessible_alt \\<delta> Q0;\n        xa_ \\<in> Q0\\<rbrakk>\n       \\<Longrightarrow> z \\<in> f_accessible_alt \\<delta> Q0", "apply (auto intro: f_accessible_alt.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x_ \\<in> f_accessible_alt \\<delta> Q0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f_accessible_alt \\<delta> Q0 \\<Longrightarrow>\n       x \\<in> {(q, q').\n                \\<exists>l qs.\n                   q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                   q' \\<in> set qs}\\<^sup>* ``\n               Q0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f_accessible_alt \\<delta> Q0 \\<Longrightarrow>\n       x \\<in> {(q, q').\n                \\<exists>l qs.\n                   q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                   q' \\<in> set qs}\\<^sup>* ``\n               Q0", "case 2"], ["proof (state)\nthis:\n  x_ \\<in> f_accessible_alt \\<delta> Q0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f_accessible_alt \\<delta> Q0 \\<Longrightarrow>\n       x \\<in> {(q, q').\n                \\<exists>l qs.\n                   q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                   q' \\<in> set qs}\\<^sup>* ``\n               Q0", "thus ?case"], ["proof (prove)\nusing this:\n  x_ \\<in> f_accessible_alt \\<delta> Q0\n\ngoal (1 subgoal):\n 1. x_ \\<in> {(q, q').\n              \\<exists>l qs.\n                 q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                 q' \\<in> set qs}\\<^sup>* ``\n             Q0", "apply (induct rule: f_accessible_alt.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q0.\n       q0 \\<in> Q0 \\<Longrightarrow>\n       q0 \\<in> {a. case a of\n                    (q, q') \\<Rightarrow>\n                      \\<exists>l qs.\n                         q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                         q' \\<in> set qs}\\<^sup>* ``\n                Q0\n 2. \\<And>q l qs q'.\n       \\<lbrakk>q \\<in> f_accessible_alt \\<delta> Q0;\n        q \\<in> {a. case a of\n                    (q, q') \\<Rightarrow>\n                      \\<exists>l qs.\n                         q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n                         q' \\<in> set qs}\\<^sup>* ``\n                Q0;\n        q \\<rightarrow> l qs \\<in> \\<delta>; q' \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> q' \\<in> {a. case a of\n(q, q') \\<Rightarrow>\n  \\<exists>l qs.\n     q \\<rightarrow> l qs \\<in> \\<delta> \\<and> q' \\<in> set qs}\\<^sup>* ``\n                                  Q0", "apply (auto simp add: Image_def intro: rtrancl.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x_ \\<in> {(q, q').\n            \\<exists>l qs.\n               q \\<rightarrow> l qs \\<in> \\<delta> \\<and>\n               q' \\<in> set qs}\\<^sup>* ``\n           Q0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas f_accessibleI = f_accessible_alt.intros[folded f_accessible_alt]"], ["", "lemmas f_accessibleE = f_accessible_alt.cases[folded f_accessible_alt]"], ["", "lemma f_succ_finite[simp, intro]: \"finite \\<delta> \\<Longrightarrow> finite (f_succ \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow> finite (f_succ \\<delta>)", "apply (unfold f_succ_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow>\n    finite\n     {(q, q').\n      \\<exists>l qs.\n         q \\<rightarrow> l qs \\<in> \\<delta> \\<and> q' \\<in> set qs}", "apply (rule_tac B=\"\\<delta>_states \\<delta> \\<times> \\<delta>_states \\<delta>\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite \\<delta> \\<Longrightarrow>\n    {(q, q').\n     \\<exists>l qs.\n        q \\<rightarrow> l qs \\<in> \\<delta> \\<and> q' \\<in> set qs}\n    \\<subseteq> \\<delta>_states \\<delta> \\<times> \\<delta>_states \\<delta>\n 2. finite \\<delta> \\<Longrightarrow>\n    finite (\\<delta>_states \\<delta> \\<times> \\<delta>_states \\<delta>)", "apply (auto dest: \\<delta>_statesI simp add: \\<delta>_states_finite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma f_accessible_mono: \"Q\\<subseteq>Q' \\<Longrightarrow> x\\<in>f_accessible \\<delta> Q \\<Longrightarrow> x\\<in>f_accessible \\<delta> Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<subseteq> Q'; x \\<in> f_accessible \\<delta> Q\\<rbrakk>\n    \\<Longrightarrow> x \\<in> f_accessible \\<delta> Q'", "by (auto simp add: f_accessible_def)"], ["", "lemma f_accessible_prepend: \n  \"\\<lbrakk> (q \\<rightarrow> l qs) \\<in> \\<delta>; q'\\<in>set qs; x\\<in>f_accessible \\<delta> {q'} \\<rbrakk> \n    \\<Longrightarrow> x\\<in>f_accessible \\<delta> {q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<rightarrow> l qs \\<in> \\<delta>; q' \\<in> set qs;\n     x \\<in> f_accessible \\<delta> {q'}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> f_accessible \\<delta> {q}", "by (auto dest: f_succ.intros simp add: f_accessible_def)"], ["", "lemma f_accessible_subset: \"q\\<in>f_accessible \\<delta> Q \\<Longrightarrow> q\\<in>Q \\<union> \\<delta>_states \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> f_accessible \\<delta> Q \\<Longrightarrow>\n    q \\<in> Q \\<union> \\<delta>_states \\<delta>", "apply (unfold f_accessible_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> f_accessible_alt \\<delta> Q \\<Longrightarrow>\n    q \\<in> Q \\<union> \\<delta>_states \\<delta>", "apply (induct rule: f_accessible_alt.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q0.\n       q0 \\<in> Q \\<Longrightarrow>\n       q0 \\<in> Q \\<union> \\<delta>_states \\<delta>\n 2. \\<And>q l qs q'.\n       \\<lbrakk>q \\<in> f_accessible_alt \\<delta> Q;\n        q \\<in> Q \\<union> \\<delta>_states \\<delta>;\n        q \\<rightarrow> l qs \\<in> \\<delta>; q' \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> q' \\<in> Q \\<union> \\<delta>_states \\<delta>", "apply (force simp add: \\<delta>_states_def split: ta_rule.split_asm)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in tree_automaton) f_accessible_in_states: \n  \"q\\<in>f_accessible (ta_rules TA) (ta_initial TA) \\<Longrightarrow> q\\<in>ta_rstates TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> f_accessible \\<delta> Qi \\<Longrightarrow> q \\<in> Q", "using initial_subset states_subset"], ["proof (prove)\nusing this:\n  Qi \\<subseteq> Q\n  \\<delta>_states \\<delta> \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. q \\<in> f_accessible \\<delta> Qi \\<Longrightarrow> q \\<in> Q", "by (drule_tac f_accessible_subset) (auto)"], ["", "lemma f_accessible_refl_inter_simp[simp]: \"Q \\<inter> f_accessible r Q = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<inter> f_accessible r Q = Q", "by (unfold f_accessible_alt) (auto intro: fa_refl)\n\n  \\<comment> \\<open>A tree remains accepted by a state @{text q} if the rules are reduced to \n        the states that are forward-accessible from @{text q}\\<close>"], ["", "lemma accs_reduce_f_acc: \n  \"accs \\<delta> t q \\<Longrightarrow> accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) t q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> t q \\<Longrightarrow>\n    accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) t q", "proof (induct rule: accs.induct[case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (f_accessible \\<delta> {qs ! i}))\n            (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> accs\n                          (reduce_rules \\<delta>\n                            (f_accessible \\<delta> {q}))\n                          (NODE f ts) q", "case (step q l qs \\<delta> n)"], ["proof (state)\nthis:\n  q \\<rightarrow> l qs \\<in> \\<delta>\n  length n = length qs\n  ?i < length qs \\<Longrightarrow> accs \\<delta> (n ! ?i) (qs ! ?i)\n  ?i < length qs \\<Longrightarrow>\n  accs (reduce_rules \\<delta> (f_accessible \\<delta> {qs ! ?i})) (n ! ?i)\n   (qs ! ?i)\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (f_accessible \\<delta> {qs ! i}))\n            (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> accs\n                          (reduce_rules \\<delta>\n                            (f_accessible \\<delta> {q}))\n                          (NODE f ts) q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (NODE l n) q", "proof (rule accs.intros[of q l qs])"], ["proof (state)\ngoal (3 subgoals):\n 1. q \\<rightarrow> l qs\n    \\<in> reduce_rules \\<delta> (f_accessible \\<delta> {q})\n 2. length n = length qs\n 3. \\<And>i.\n       i < length qs \\<Longrightarrow>\n       accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i)\n        (qs ! i)", "show \"(q \\<rightarrow> l qs) \\<in> reduce_rules \\<delta> (f_accessible \\<delta> {q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<rightarrow> l qs\n    \\<in> reduce_rules \\<delta> (f_accessible \\<delta> {q})", "using step(1)"], ["proof (prove)\nusing this:\n  q \\<rightarrow> l qs \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. q \\<rightarrow> l qs\n    \\<in> reduce_rules \\<delta> (f_accessible \\<delta> {q})", "by (fastforce \n        intro!: reduce_rulesI \n        intro: f_succ.intros \n        simp add: f_accessible_def)"], ["proof (state)\nthis:\n  q \\<rightarrow> l qs\n  \\<in> reduce_rules \\<delta> (f_accessible \\<delta> {q})\n\ngoal (2 subgoals):\n 1. length n = length qs\n 2. \\<And>i.\n       i < length qs \\<Longrightarrow>\n       accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i)\n        (qs ! i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. length n = length qs\n 2. \\<And>i.\n       i < length qs \\<Longrightarrow>\n       accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i)\n        (qs ! i)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length n = length qs\n 2. \\<And>i.\n       i < length qs \\<Longrightarrow>\n       accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i)\n        (qs ! i)", "assume A: \"i<length qs\""], ["proof (state)\nthis:\n  i < length qs\n\ngoal (2 subgoals):\n 1. length n = length qs\n 2. \\<And>i.\n       i < length qs \\<Longrightarrow>\n       accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i)\n        (qs ! i)", "have B: \"f_accessible \\<delta> {q} \\<supseteq> f_accessible \\<delta> {qs!i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_accessible \\<delta> {qs ! i} \\<subseteq> f_accessible \\<delta> {q}", "using step.hyps(1)"], ["proof (prove)\nusing this:\n  q \\<rightarrow> l qs \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. f_accessible \\<delta> {qs ! i} \\<subseteq> f_accessible \\<delta> {q}", "by (force \n        simp add: A f_accessible_def \n        intro: converse_rtrancl_into_rtrancl f_succ.intros[where q'=\"qs!i\"])"], ["proof (state)\nthis:\n  f_accessible \\<delta> {qs ! i} \\<subseteq> f_accessible \\<delta> {q}\n\ngoal (2 subgoals):\n 1. length n = length qs\n 2. \\<And>i.\n       i < length qs \\<Longrightarrow>\n       accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i)\n        (qs ! i)", "show \"accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i) (qs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i)\n     (qs ! i)", "using accs_mono[OF step.hyps(4)[OF A] reduce_rules_mono[OF B]]"], ["proof (prove)\nusing this:\n  accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i) (qs ! i)\n\ngoal (1 subgoal):\n 1. accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i)\n     (qs ! i)", "."], ["proof (state)\nthis:\n  accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (n ! i) (qs ! i)\n\ngoal (1 subgoal):\n 1. length n = length qs", "qed (simp_all add: step.hyps(2,3))"], ["proof (state)\nthis:\n  accs (reduce_rules \\<delta> (f_accessible \\<delta> {q})) (NODE l n) q\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Short-hand notation for forward-reducing a tree-automaton\\<close>"], ["", "abbreviation \"ta_fwd_reduce TA == \n  (ta_reduce TA (f_accessible (ta_rules TA) (ta_initial TA)))\"\n\n\\<comment> \\<open>Forward-reducing a tree automaton does not change its language\\<close>"], ["", "theorem ta_reduce_f_acc[simp]: \"ta_lang (ta_fwd_reduce TA) = ta_lang TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (ta_fwd_reduce TA) = ta_lang TA", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang TA = ta_lang (ta_fwd_reduce TA)", "apply (unfold ta_reduce_def ta_lang_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. \\<exists>q\\<in>ta_initial TA. accs (ta_rules TA) t q} =\n    {t. \\<exists>q\\<in>ta_initial\n                        \\<lparr>ta_initial =\n                                  ta_initial TA \\<inter>\n                                  f_accessible (ta_rules TA)\n                                   (ta_initial TA),\n                           ta_rules =\n                             reduce_rules (ta_rules TA)\n                              (f_accessible (ta_rules TA)\n                                (ta_initial TA))\\<rparr>.\n           accs\n            (ta_rules\n              \\<lparr>ta_initial =\n                        ta_initial TA \\<inter>\n                        f_accessible (ta_rules TA) (ta_initial TA),\n                 ta_rules =\n                   reduce_rules (ta_rules TA)\n                    (f_accessible (ta_rules TA) (ta_initial TA))\\<rparr>)\n            t q}", "apply (auto simp add: Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs\n                             (reduce_rules (ta_rules TA)\n                               (f_accessible (ta_rules TA) (ta_initial TA)))\n                             x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs\n         (reduce_rules (ta_rules TA)\n           (f_accessible (ta_rules TA) (ta_initial TA)))\n         x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q", "apply (rule_tac x=q in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> accs\n                          (reduce_rules (ta_rules TA)\n                            (f_accessible (ta_rules TA) (ta_initial TA)))\n                          x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ta_initial TA\n 3. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs\n         (reduce_rules (ta_rules TA)\n           (f_accessible (ta_rules TA) (ta_initial TA)))\n         x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q", "apply (drule accs_reduce_f_acc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs (reduce_rules (ta_rules TA) (f_accessible (ta_rules TA) {q})) x\n         q\\<rbrakk>\n       \\<Longrightarrow> accs\n                          (reduce_rules (ta_rules TA)\n                            (f_accessible (ta_rules TA) (ta_initial TA)))\n                          x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ta_initial TA\n 3. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs\n         (reduce_rules (ta_rules TA)\n           (f_accessible (ta_rules TA) (ta_initial TA)))\n         x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q", "apply (rule_tac \n    P1=\"(f_accessible (ta_rules TA) {q})\" \n    in accs_mono[OF _ reduce_rules_mono])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs (reduce_rules (ta_rules TA) (f_accessible (ta_rules TA) {q})) x\n         q\\<rbrakk>\n       \\<Longrightarrow> accs\n                          (reduce_rules (ta_rules TA)\n                            (f_accessible (ta_rules TA) {q}))\n                          x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs (reduce_rules (ta_rules TA) (f_accessible (ta_rules TA) {q})) x\n         q\\<rbrakk>\n       \\<Longrightarrow> f_accessible (ta_rules TA) {q}\n                         \\<subseteq> f_accessible (ta_rules TA)\n(ta_initial TA)\n 3. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ta_initial TA\n 4. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs\n         (reduce_rules (ta_rules TA)\n           (f_accessible (ta_rules TA) (ta_initial TA)))\n         x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q", "apply (auto simp add: f_accessible_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs\n         (reduce_rules (ta_rules TA)\n           ((f_succ (ta_rules TA))\\<^sup>* `` ta_initial TA))\n         x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q", "apply (rule_tac x=q in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs\n         (reduce_rules (ta_rules TA)\n           ((f_succ (ta_rules TA))\\<^sup>* `` ta_initial TA))\n         x q\\<rbrakk>\n       \\<Longrightarrow> accs (ta_rules TA) x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs\n         (reduce_rules (ta_rules TA)\n           ((f_succ (ta_rules TA))\\<^sup>* `` ta_initial TA))\n         x q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ta_initial TA", "apply (blast intro: accs_mono[OF _ reduce_rules_subset])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA;\n        accs\n         (reduce_rules (ta_rules TA)\n           ((f_succ (ta_rules TA))\\<^sup>* `` ta_initial TA))\n         x q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ta_initial TA", "."], ["", "text_raw \\<open>\\paragraph{Backward Reduction}\\<close>"], ["", "text \\<open>\n  A state is backward accessible, iff at least one tree is accepted in it.\n\n  Inductively, backward accessible states can be characterized as follows:\n  A state is backward accessible, if it occurs on the left hand side of a \n  rule, and all states on this rule's right hand side are backward accessible.\n\\<close>"], ["", "inductive_set b_accessible :: \"('Q,'L) ta_rule set \\<Rightarrow> 'Q set\" \n  for \\<delta>\n  where\n  \"\\<lbrakk> (q \\<rightarrow> l qs)\\<in>\\<delta>; !!x. x\\<in>set qs \\<Longrightarrow> x\\<in>b_accessible \\<delta> \\<rbrakk> \\<Longrightarrow> q\\<in>b_accessible \\<delta>\""], ["", "lemma b_accessibleI: \n  \"\\<lbrakk>(q \\<rightarrow> l qs)\\<in>\\<delta>; set qs \\<subseteq> b_accessible \\<delta>\\<rbrakk> \\<Longrightarrow> q\\<in>b_accessible \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<rightarrow> l qs \\<in> \\<delta>;\n     set qs \\<subseteq> b_accessible \\<delta>\\<rbrakk>\n    \\<Longrightarrow> q \\<in> b_accessible \\<delta>", "by (auto intro: b_accessible.intros)\n\n\\<comment> \\<open>States that accept a tree are backward accessible\\<close>"], ["", "lemma accs_is_b_accessible: \"accs \\<delta> t q \\<Longrightarrow> q\\<in>b_accessible \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> t q \\<Longrightarrow> q \\<in> b_accessible \\<delta>", "apply (induct rule: accs.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           qs ! i \\<in> b_accessible \\<delta>\\<rbrakk>\n       \\<Longrightarrow> q \\<in> b_accessible \\<delta>", "apply (rule b_accessible.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           qs ! i \\<in> b_accessible \\<delta>\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> ?l1 q f qs \\<delta>\n    ts ?qs1 q f qs \\<delta> ts\n                         \\<in> \\<delta>\n 2. \\<And>q f qs \\<delta> ts x.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           qs ! i \\<in> b_accessible \\<delta>;\n        x \\<in> set (?qs1 q f qs \\<delta> ts)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b_accessible \\<delta>", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts x.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           qs ! i \\<in> b_accessible \\<delta>;\n        x \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b_accessible \\<delta>", "apply (fastforce simp add: in_set_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma b_acc_subset_\\<delta>_statesI: \"x\\<in>b_accessible \\<delta> \\<Longrightarrow> x\\<in>\\<delta>_states \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> b_accessible \\<delta> \\<Longrightarrow>\n    x \\<in> \\<delta>_states \\<delta>", "apply (erule b_accessible.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q l qs.\n       \\<lbrakk>x = q; q \\<rightarrow> l qs \\<in> \\<delta>;\n        \\<And>x.\n           x \\<in> set qs \\<Longrightarrow>\n           x \\<in> b_accessible \\<delta>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<delta>_states \\<delta>", "apply (auto intro: \\<delta>_statesI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma b_acc_subset_\\<delta>_states: \"b_accessible \\<delta> \\<subseteq> \\<delta>_states \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_accessible \\<delta> \\<subseteq> \\<delta>_states \\<delta>", "by (auto simp add: b_acc_subset_\\<delta>_statesI)"], ["", "lemma b_acc_finite[simp, intro!]: \"finite \\<delta> \\<Longrightarrow> finite (b_accessible \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow> finite (b_accessible \\<delta>)", "apply (rule finite_subset[OF b_acc_subset_\\<delta>_states])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow> finite (\\<delta>_states \\<delta>)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>Backward accessible states accept at least one tree\\<close>"], ["", "lemma b_accessible_is_accs: \n  \"\\<lbrakk> q\\<in>b_accessible (ta_rules TA); \n     !!t. accs (ta_rules TA) t q \\<Longrightarrow> P\n   \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> b_accessible (ta_rules TA);\n     \\<And>t. accs (ta_rules TA) t q \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "proof (induct arbitrary: P rule: b_accessible.induct[case_names IH])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q l qs P.\n       \\<lbrakk>q \\<rightarrow> l qs \\<in> ta_rules TA;\n        \\<And>x.\n           x \\<in> set qs \\<Longrightarrow>\n           x \\<in> b_accessible (ta_rules TA);\n        \\<And>x P.\n           \\<lbrakk>x \\<in> set qs;\n            \\<And>t. accs (ta_rules TA) t x \\<Longrightarrow> P\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>t. accs (ta_rules TA) t q \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "case (IH q l qs)"], ["proof (state)\nthis:\n  q \\<rightarrow> l qs \\<in> ta_rules TA\n  ?x \\<in> set qs \\<Longrightarrow> ?x \\<in> b_accessible (ta_rules TA)\n  \\<lbrakk>?x \\<in> set qs;\n   \\<And>t. accs (ta_rules TA) t ?x \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  accs (ta_rules TA) ?t q \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>q l qs P.\n       \\<lbrakk>q \\<rightarrow> l qs \\<in> ta_rules TA;\n        \\<And>x.\n           x \\<in> set qs \\<Longrightarrow>\n           x \\<in> b_accessible (ta_rules TA);\n        \\<And>x P.\n           \\<lbrakk>x \\<in> set qs;\n            \\<And>t. accs (ta_rules TA) t x \\<Longrightarrow> P\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>t. accs (ta_rules TA) t q \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "obtain ts where \n    A: \"\\<forall>i<length qs. accs (ta_rules TA) (ts!i) (qs!i)\" \n       \"length ts = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i);\n         length ts = length qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i);\n         length ts = length qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from IH(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set qs;\n   \\<And>t. accs (ta_rules TA) t ?x \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P", "have \"\\<forall>x\\<in>set qs. \\<exists>t. accs (ta_rules TA) t x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set qs;\n   \\<And>t. accs (ta_rules TA) t ?x \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set qs. \\<exists>t. accs (ta_rules TA) t x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set qs. \\<exists>t. accs (ta_rules TA) t x\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i);\n         length ts = length qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"\\<exists>ts. (\\<forall>i<length qs. accs (ta_rules TA) (ts!i) (qs!i)) \n                \\<and> length ts = length qs\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set qs. \\<exists>t. accs (ta_rules TA) t x\n\ngoal (1 subgoal):\n 1. \\<exists>ts.\n       (\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n       length ts = length qs", "proof (induct qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n    \\<exists>ts.\n       (\\<forall>i<length []. accs (ta_rules TA) (ts ! i) ([] ! i)) \\<and>\n       length ts = length []\n 2. \\<And>a qs.\n       \\<lbrakk>\\<forall>x\\<in>set qs.\n                   \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n                \\<exists>ts.\n                   (\\<forall>i<length qs.\n                       accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n                   length ts = length qs;\n        \\<forall>x\\<in>set (a # qs).\n           \\<exists>t. accs (ta_rules TA) t x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            (\\<forall>i<length (a # qs).\n                                accs (ta_rules TA) (ts ! i)\n                                 ((a # qs) ! i)) \\<and>\n                            length ts = length (a # qs)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. \\<exists>t. accs (ta_rules TA) t x\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n    \\<exists>ts.\n       (\\<forall>i<length []. accs (ta_rules TA) (ts ! i) ([] ! i)) \\<and>\n       length ts = length []\n 2. \\<And>a qs.\n       \\<lbrakk>\\<forall>x\\<in>set qs.\n                   \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n                \\<exists>ts.\n                   (\\<forall>i<length qs.\n                       accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n                   length ts = length qs;\n        \\<forall>x\\<in>set (a # qs).\n           \\<exists>t. accs (ta_rules TA) t x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            (\\<forall>i<length (a # qs).\n                                accs (ta_rules TA) (ts ! i)\n                                 ((a # qs) ! i)) \\<and>\n                            length ts = length (a # qs)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set []. \\<exists>t. accs (ta_rules TA) t x\n\ngoal (1 subgoal):\n 1. \\<exists>ts.\n       (\\<forall>i<length []. accs (ta_rules TA) (ts ! i) ([] ! i)) \\<and>\n       length ts = length []", "by simp"], ["proof (state)\nthis:\n  \\<exists>ts.\n     (\\<forall>i<length []. accs (ta_rules TA) (ts ! i) ([] ! i)) \\<and>\n     length ts = length []\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<forall>x\\<in>set qs.\n                   \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n                \\<exists>ts.\n                   (\\<forall>i<length qs.\n                       accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n                   length ts = length qs;\n        \\<forall>x\\<in>set (a # qs).\n           \\<exists>t. accs (ta_rules TA) t x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            (\\<forall>i<length (a # qs).\n                                accs (ta_rules TA) (ts ! i)\n                                 ((a # qs) ! i)) \\<and>\n                            length ts = length (a # qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<forall>x\\<in>set qs.\n                   \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n                \\<exists>ts.\n                   (\\<forall>i<length qs.\n                       accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n                   length ts = length qs;\n        \\<forall>x\\<in>set (a # qs).\n           \\<exists>t. accs (ta_rules TA) t x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            (\\<forall>i<length (a # qs).\n                                accs (ta_rules TA) (ts ! i)\n                                 ((a # qs) ! i)) \\<and>\n                            length ts = length (a # qs)", "case (Cons q qs)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set qs.\n     \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n  \\<exists>ts.\n     (\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n     length ts = length qs\n  \\<forall>x\\<in>set (q # qs). \\<exists>t. accs (ta_rules TA) t x\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<forall>x\\<in>set qs.\n                   \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n                \\<exists>ts.\n                   (\\<forall>i<length qs.\n                       accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n                   length ts = length qs;\n        \\<forall>x\\<in>set (a # qs).\n           \\<exists>t. accs (ta_rules TA) t x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            (\\<forall>i<length (a # qs).\n                                accs (ta_rules TA) (ts ! i)\n                                 ((a # qs) ! i)) \\<and>\n                            length ts = length (a # qs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set qs.\n     \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n  \\<exists>ts.\n     (\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n     length ts = length qs\n  \\<forall>x\\<in>set (q # qs). \\<exists>t. accs (ta_rules TA) t x", "obtain ts where \n        IHAPP: \"\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)\" and \n        L: \"length ts = length qs\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set qs.\n     \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n  \\<exists>ts.\n     (\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n     length ts = length qs\n  \\<forall>x\\<in>set (q # qs). \\<exists>t. accs (ta_rules TA) t x\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i);\n         length ts = length qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)\n  length ts = length qs\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<forall>x\\<in>set qs.\n                   \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n                \\<exists>ts.\n                   (\\<forall>i<length qs.\n                       accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n                   length ts = length qs;\n        \\<forall>x\\<in>set (a # qs).\n           \\<exists>t. accs (ta_rules TA) t x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            (\\<forall>i<length (a # qs).\n                                accs (ta_rules TA) (ts ! i)\n                                 ((a # qs) ! i)) \\<and>\n                            length ts = length (a # qs)", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)\n  length ts = length qs\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<forall>x\\<in>set qs.\n                   \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n                \\<exists>ts.\n                   (\\<forall>i<length qs.\n                       accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n                   length ts = length qs;\n        \\<forall>x\\<in>set (a # qs).\n           \\<exists>t. accs (ta_rules TA) t x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            (\\<forall>i<length (a # qs).\n                                accs (ta_rules TA) (ts ! i)\n                                 ((a # qs) ! i)) \\<and>\n                            length ts = length (a # qs)", "from Cons"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set qs.\n     \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n  \\<exists>ts.\n     (\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n     length ts = length qs\n  \\<forall>x\\<in>set (q # qs). \\<exists>t. accs (ta_rules TA) t x", "obtain t where \"accs (ta_rules TA) t q\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set qs.\n     \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n  \\<exists>ts.\n     (\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n     length ts = length qs\n  \\<forall>x\\<in>set (q # qs). \\<exists>t. accs (ta_rules TA) t x\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        accs (ta_rules TA) t q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  accs (ta_rules TA) t q\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<forall>x\\<in>set qs.\n                   \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n                \\<exists>ts.\n                   (\\<forall>i<length qs.\n                       accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n                   length ts = length qs;\n        \\<forall>x\\<in>set (a # qs).\n           \\<exists>t. accs (ta_rules TA) t x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            (\\<forall>i<length (a # qs).\n                                accs (ta_rules TA) (ts ! i)\n                                 ((a # qs) ! i)) \\<and>\n                            length ts = length (a # qs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)\n  length ts = length qs\n  accs (ta_rules TA) t q", "have \n        \"\\<forall>i<length (q#qs). accs (ta_rules TA) ((t#ts) ! i) ((q#qs) ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)\n  length ts = length qs\n  accs (ta_rules TA) t q\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (q # qs).\n       accs (ta_rules TA) ((t # ts) ! i) ((q # qs) ! i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i);\n        length ts = length qs; accs (ta_rules TA) t q;\n        i < Suc (length qs)\\<rbrakk>\n       \\<Longrightarrow> accs (ta_rules TA) ((t # ts) ! i) ((q # qs) ! i)", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i);\n        length ts = length qs; accs (ta_rules TA) t q; i < Suc (length qs);\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> accs (ta_rules TA) ((t # ts) ! i) ((q # qs) ! i)\n 2. \\<And>i nat.\n       \\<lbrakk>\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i);\n        length ts = length qs; accs (ta_rules TA) t q; i < Suc (length qs);\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> accs (ta_rules TA) ((t # ts) ! i) ((q # qs) ! i)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i<length (q # qs).\n     accs (ta_rules TA) ((t # ts) ! i) ((q # qs) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<forall>x\\<in>set qs.\n                   \\<exists>t. accs (ta_rules TA) t x \\<Longrightarrow>\n                \\<exists>ts.\n                   (\\<forall>i<length qs.\n                       accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n                   length ts = length qs;\n        \\<forall>x\\<in>set (a # qs).\n           \\<exists>t. accs (ta_rules TA) t x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            (\\<forall>i<length (a # qs).\n                                accs (ta_rules TA) (ts ! i)\n                                 ((a # qs) ! i)) \\<and>\n                            length ts = length (a # qs)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>i<length (q # qs).\n     accs (ta_rules TA) ((t # ts) ! i) ((q # qs) ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>ts.\n       (\\<forall>i<length (q # qs).\n           accs (ta_rules TA) (ts ! i) ((q # qs) ! i)) \\<and>\n       length ts = length (q # qs)", "using L"], ["proof (prove)\nusing this:\n  \\<forall>i<length (q # qs).\n     accs (ta_rules TA) ((t # ts) ! i) ((q # qs) ! i)\n  length ts = length qs\n\ngoal (1 subgoal):\n 1. \\<exists>ts.\n       (\\<forall>i<length (q # qs).\n           accs (ta_rules TA) (ts ! i) ((q # qs) ! i)) \\<and>\n       length ts = length (q # qs)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ts.\n     (\\<forall>i<length (q # qs).\n         accs (ta_rules TA) (ts ! i) ((q # qs) ! i)) \\<and>\n     length ts = length (q # qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ts.\n     (\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n     length ts = length qs\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i);\n         length ts = length qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  \\<exists>ts.\n     (\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)) \\<and>\n     length ts = length qs\n\ngoal (1 subgoal):\n 1. thesis", "by (blast intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)\n  length ts = length qs\n\ngoal (1 subgoal):\n 1. \\<And>q l qs P.\n       \\<lbrakk>q \\<rightarrow> l qs \\<in> ta_rules TA;\n        \\<And>x.\n           x \\<in> set qs \\<Longrightarrow>\n           x \\<in> b_accessible (ta_rules TA);\n        \\<And>x P.\n           \\<lbrakk>x \\<in> set qs;\n            \\<And>t. accs (ta_rules TA) t x \\<Longrightarrow> P\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>t. accs (ta_rules TA) t q \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "from A"], ["proof (chain)\npicking this:\n  \\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)\n  length ts = length qs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i)\n  length ts = length qs\n\ngoal (1 subgoal):\n 1. P", "apply (rule_tac IH(4)[OF accs.intros[OF IH(1)]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i);\n     length ts = length qs\\<rbrakk>\n    \\<Longrightarrow> length ?ts3 = length qs\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i<length qs. accs (ta_rules TA) (ts ! i) (qs ! i);\n        length ts = length qs; i < length qs\\<rbrakk>\n       \\<Longrightarrow> accs (ta_rules TA) (?ts3 ! i) (qs ! i)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>All trees remain accepted when reducing the rules to \n      backward-accessible states\\<close>"], ["", "lemma accs_reduce_b_acc: \n  \"accs \\<delta> t q \\<Longrightarrow> accs (reduce_rules \\<delta> (b_accessible \\<delta>)) t q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> t q \\<Longrightarrow>\n    accs (reduce_rules \\<delta> (b_accessible \\<delta>)) t q", "apply (induct rule: accs.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> accs\n                          (reduce_rules \\<delta> (b_accessible \\<delta>))\n                          (NODE f ts) q", "apply (rule accs.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> f ?qs1 q f qs \\<delta> ts\n                         \\<in> reduce_rules \\<delta> (b_accessible \\<delta>)\n 2. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> length ts = length (?qs1 q f qs \\<delta> ts)\n 3. \\<And>q f qs \\<delta> ts i.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        i < length (?qs1 q f qs \\<delta> ts)\\<rbrakk>\n       \\<Longrightarrow> accs\n                          (reduce_rules \\<delta> (b_accessible \\<delta>))\n                          (ts ! i) (?qs1 q f qs \\<delta> ts ! i)", "apply (rule reduce_rulesI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> f ?qs1 q f qs \\<delta> ts\n                         \\<in> \\<delta>\n 2. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> rule_states\n                          q \\<rightarrow> f ?qs1 q f qs \\<delta> ts\n                         \\<subseteq> b_accessible \\<delta>\n 3. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> length ts = length (?qs1 q f qs \\<delta> ts)\n 4. \\<And>q f qs \\<delta> ts i.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        i < length (?qs1 q f qs \\<delta> ts)\\<rbrakk>\n       \\<Longrightarrow> accs\n                          (reduce_rules \\<delta> (b_accessible \\<delta>))\n                          (ts ! i) (?qs1 q f qs \\<delta> ts ! i)", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> rule_states q \\<rightarrow> f qs\n                         \\<subseteq> b_accessible \\<delta>\n 2. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> length ts = length qs\n 3. \\<And>q f qs \\<delta> ts i.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        i < length qs\\<rbrakk>\n       \\<Longrightarrow> accs\n                          (reduce_rules \\<delta> (b_accessible \\<delta>))\n                          (ts ! i) (qs ! i)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> q \\<in> b_accessible \\<delta>\n 2. \\<And>q f qs \\<delta> ts x.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        x \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b_accessible \\<delta>", "apply (rule_tac t=\"NODE f ts\" in accs_is_b_accessible)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (NODE f ts) q\n 2. \\<And>q f qs \\<delta> ts x.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        x \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b_accessible \\<delta>", "apply (rule_tac accs.intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> f ?qs11 q f qs \\<delta> ts\n                         \\<in> \\<delta>\n 2. \\<And>q f qs \\<delta> ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> length ts = length (?qs11 q f qs \\<delta> ts)\n 3. \\<And>q f qs \\<delta> ts i.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        i < length (?qs11 q f qs \\<delta> ts)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (ts ! i)\n                          (?qs11 q f qs \\<delta> ts ! i)\n 4. \\<And>q f qs \\<delta> ts x.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        x \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b_accessible \\<delta>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts x.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        x \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b_accessible \\<delta>", "apply (simp only: in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts x.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        \\<exists>i<length qs. qs ! i = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b_accessible \\<delta>", "apply (erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts x i.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        i < length qs \\<and> qs ! i = x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> b_accessible \\<delta>", "apply (rule_tac t=\"ts ! i\" in accs_is_b_accessible)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts x i.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs (reduce_rules \\<delta> (b_accessible \\<delta>)) (ts ! i)\n            (qs ! i);\n        i < length qs \\<and> qs ! i = x\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (ts ! i) x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>Shorthand notation for backward-reduction of a tree automaton\\<close>"], ["", "abbreviation \"ta_bwd_reduce TA == (ta_reduce TA (b_accessible (ta_rules TA)))\"\n\n\\<comment> \\<open>Backwards-reducing a tree automaton does not change its language\\<close>"], ["", "theorem ta_reduce_b_acc[simp]: \"ta_lang (ta_bwd_reduce TA) = ta_lang TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (ta_bwd_reduce TA) = ta_lang TA", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang TA = ta_lang (ta_bwd_reduce TA)", "apply (unfold ta_reduce_def ta_lang_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. \\<exists>q\\<in>ta_initial TA. accs (ta_rules TA) t q} =\n    {t. \\<exists>q\\<in>ta_initial\n                        \\<lparr>ta_initial =\n                                  ta_initial TA \\<inter>\n                                  b_accessible (ta_rules TA),\n                           ta_rules =\n                             reduce_rules (ta_rules TA)\n                              (b_accessible (ta_rules TA))\\<rparr>.\n           accs\n            (ta_rules\n              \\<lparr>ta_initial =\n                        ta_initial TA \\<inter> b_accessible (ta_rules TA),\n                 ta_rules =\n                   reduce_rules (ta_rules TA)\n                    (b_accessible (ta_rules TA))\\<rparr>)\n            t q}", "apply (auto simp add: Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA \\<inter>\n  b_accessible (ta_rules TA).\n                            accs\n                             (reduce_rules (ta_rules TA)\n                               (b_accessible (ta_rules TA)))\n                             x q\n 2. \\<And>x q.\n       \\<lbrakk>accs\n                 (reduce_rules (ta_rules TA) (b_accessible (ta_rules TA))) x\n                 q;\n        q \\<in> ta_initial TA; q \\<in> b_accessible (ta_rules TA)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q", "apply (rule_tac x=q in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> accs\n                          (reduce_rules (ta_rules TA)\n                            (b_accessible (ta_rules TA)))\n                          x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ta_initial TA \\<inter>\n                                 b_accessible (ta_rules TA)\n 3. \\<And>x q.\n       \\<lbrakk>accs\n                 (reduce_rules (ta_rules TA) (b_accessible (ta_rules TA))) x\n                 q;\n        q \\<in> ta_initial TA; q \\<in> b_accessible (ta_rules TA)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q", "apply (blast intro: accs_reduce_b_acc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial TA; accs (ta_rules TA) x q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ta_initial TA \\<inter>\n                                 b_accessible (ta_rules TA)\n 2. \\<And>x q.\n       \\<lbrakk>accs\n                 (reduce_rules (ta_rules TA) (b_accessible (ta_rules TA))) x\n                 q;\n        q \\<in> ta_initial TA; q \\<in> b_accessible (ta_rules TA)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q", "apply (blast dest: accs_is_b_accessible)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>accs\n                 (reduce_rules (ta_rules TA) (b_accessible (ta_rules TA))) x\n                 q;\n        q \\<in> ta_initial TA; q \\<in> b_accessible (ta_rules TA)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial TA.\n                            accs (ta_rules TA) x q", "apply (rule_tac x=q in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>accs\n                 (reduce_rules (ta_rules TA) (b_accessible (ta_rules TA))) x\n                 q;\n        q \\<in> ta_initial TA; q \\<in> b_accessible (ta_rules TA)\\<rbrakk>\n       \\<Longrightarrow> accs (ta_rules TA) x q\n 2. \\<And>x q.\n       \\<lbrakk>accs\n                 (reduce_rules (ta_rules TA) (b_accessible (ta_rules TA))) x\n                 q;\n        q \\<in> ta_initial TA; q \\<in> b_accessible (ta_rules TA)\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ta_initial TA", "apply (blast intro: accs_mono[OF _ reduce_rules_subset])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>accs\n                 (reduce_rules (ta_rules TA) (b_accessible (ta_rules TA))) x\n                 q;\n        q \\<in> ta_initial TA; q \\<in> b_accessible (ta_rules TA)\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ta_initial TA", ".\n\n  \\<comment> \\<open>Emptiness check by backward reduction. The language of a tree automaton \n    is empty, if and only if no initial state is backwards-accessible.\\<close>"], ["", "theorem empty_if_no_b_accessible: \n  \"ta_lang TA = {} \\<longleftrightarrow> ta_initial TA \\<inter> b_accessible (ta_rules TA) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ta_lang TA = {}) =\n    (ta_initial TA \\<inter> b_accessible (ta_rules TA) = {})", "by (auto \n    simp add: ta_lang_def \n    intro: accs_is_b_accessible b_accessible_is_accs)"], ["", "subsubsection \"Product Automaton\""], ["", "text \\<open>\n  The product automaton of two tree automata accepts the intersection \n  of the languages of the two automata.\n\\<close>\n\n  \\<comment> \\<open>Product rule\\<close>"], ["", "fun r_prod where\n  \"r_prod (q1 \\<rightarrow> l1 qs1) (q2 \\<rightarrow> l2 qs2) = ((q1,q2) \\<rightarrow> l1 (zip qs1 qs2))\"\n\n  \\<comment> \\<open>Product rules\\<close>"], ["", "definition \"\\<delta>_prod \\<delta>1 \\<delta>2 == {\n  r_prod (q1 \\<rightarrow> l qs1) (q2 \\<rightarrow> l qs2) | q1 q2 l qs1 qs2.\n    length qs1 = length qs2 \\<and> \n    (q1 \\<rightarrow> l qs1)\\<in>\\<delta>1 \\<and> \n    (q2 \\<rightarrow> l qs2)\\<in>\\<delta>2\n}\""], ["", "lemma \\<delta>_prodI: \"\\<lbrakk> \n    length qs1 = length qs2;\n    (q1 \\<rightarrow> l qs1)\\<in>\\<delta>1;\n    (q2 \\<rightarrow> l qs2)\\<in>\\<delta>2 \\<rbrakk> \\<Longrightarrow> ((q1,q2) \\<rightarrow> l (zip qs1 qs2)) \\<in> \\<delta>_prod \\<delta>1 \\<delta>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length qs1 = length qs2;\n     q1 \\<rightarrow> l qs1 \\<in> \\<delta>1;\n     q2 \\<rightarrow> l qs2 \\<in> \\<delta>2\\<rbrakk>\n    \\<Longrightarrow> (q1, q2) \\<rightarrow> l zip qs1 qs2\n                      \\<in> \\<delta>_prod \\<delta>1 \\<delta>2", "by (auto simp add: \\<delta>_prod_def)"], ["", "lemma \\<delta>_prodE: \n  \"\\<lbrakk> \n    r\\<in>\\<delta>_prod \\<delta>1 \\<delta>2; \n    !!q1 q2 l qs1 qs2. \\<lbrakk> length qs1 = length qs2;\n                         (q1 \\<rightarrow> l qs1)\\<in>\\<delta>1;\n                         (q2 \\<rightarrow> l qs2)\\<in>\\<delta>2;\n                         r = ((q1,q2) \\<rightarrow> l (zip qs1 qs2)) \n                       \\<rbrakk> \\<Longrightarrow> P \n   \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> \\<delta>_prod \\<delta>1 \\<delta>2;\n     \\<And>q1 q2 l qs1 qs2.\n        \\<lbrakk>length qs1 = length qs2;\n         q1 \\<rightarrow> l qs1 \\<in> \\<delta>1;\n         q2 \\<rightarrow> l qs2 \\<in> \\<delta>2;\n         r = (q1, q2) \\<rightarrow> l zip qs1 qs2\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto simp add: \\<delta>_prod_def)\n\n  \\<comment> \\<open>With the product rules, only trees can be constructed that can also be \n      constructed with the two original sets of rules\\<close>"], ["", "lemma \\<delta>_prod_sound: \n  assumes A: \"accs (\\<delta>_prod \\<delta>1 \\<delta>2) t (q1,q2)\" \n  shows \"accs \\<delta>1 t q1\" \"accs \\<delta>2 t q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta>1 t q1 &&& accs \\<delta>2 t q2", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. accs \\<delta>1 t q1\n 2. accs \\<delta>2 t q2", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. accs \\<delta>1 t q1\n 2. accs \\<delta>2 t q2", "fix \\<delta> q"], ["proof (state)\ngoal (2 subgoals):\n 1. accs \\<delta>1 t q1\n 2. accs \\<delta>2 t q2", "assume \"accs \\<delta> t q\" \"\\<delta> = (\\<delta>_prod \\<delta>1 \\<delta>2)\" \"q=(q1,q2)\""], ["proof (state)\nthis:\n  accs \\<delta> t q\n  \\<delta> = \\<delta>_prod \\<delta>1 \\<delta>2\n  q = (q1, q2)\n\ngoal (2 subgoals):\n 1. accs \\<delta>1 t q1\n 2. accs \\<delta>2 t q2", "hence \"accs \\<delta>1 t q1 \\<and> accs \\<delta>2 t q2\""], ["proof (prove)\nusing this:\n  accs \\<delta> t q\n  \\<delta> = \\<delta>_prod \\<delta>1 \\<delta>2\n  q = (q1, q2)\n\ngoal (1 subgoal):\n 1. accs \\<delta>1 t q1 \\<and> accs \\<delta>2 t q2", "by (induct arbitrary: \\<delta>1 \\<delta>2 q1 q2 rule: accs.induct)\n         (auto intro: accs.intros simp add: \\<delta>_prod_def)"], ["proof (state)\nthis:\n  accs \\<delta>1 t q1 \\<and> accs \\<delta>2 t q2\n\ngoal (2 subgoals):\n 1. accs \\<delta>1 t q1\n 2. accs \\<delta>2 t q2", "}"], ["proof (state)\nthis:\n  \\<lbrakk>accs ?\\<delta>2 t ?q2;\n   ?\\<delta>2 = \\<delta>_prod \\<delta>1 \\<delta>2; ?q2 = (q1, q2)\\<rbrakk>\n  \\<Longrightarrow> accs \\<delta>1 t q1 \\<and> accs \\<delta>2 t q2\n\ngoal (2 subgoals):\n 1. accs \\<delta>1 t q1\n 2. accs \\<delta>2 t q2", "with A"], ["proof (chain)\npicking this:\n  accs (\\<delta>_prod \\<delta>1 \\<delta>2) t (q1, q2)\n  \\<lbrakk>accs ?\\<delta>2 t ?q2;\n   ?\\<delta>2 = \\<delta>_prod \\<delta>1 \\<delta>2; ?q2 = (q1, q2)\\<rbrakk>\n  \\<Longrightarrow> accs \\<delta>1 t q1 \\<and> accs \\<delta>2 t q2", "show \"accs \\<delta>1 t q1\" \"accs \\<delta>2 t q2\""], ["proof (prove)\nusing this:\n  accs (\\<delta>_prod \\<delta>1 \\<delta>2) t (q1, q2)\n  \\<lbrakk>accs ?\\<delta>2 t ?q2;\n   ?\\<delta>2 = \\<delta>_prod \\<delta>1 \\<delta>2; ?q2 = (q1, q2)\\<rbrakk>\n  \\<Longrightarrow> accs \\<delta>1 t q1 \\<and> accs \\<delta>2 t q2\n\ngoal (1 subgoal):\n 1. accs \\<delta>1 t q1 &&& accs \\<delta>2 t q2", "by auto"], ["proof (state)\nthis:\n  accs \\<delta>1 t q1\n  accs \\<delta>2 t q2\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Any tree that can be constructed with both original sets of rules can also\n      be constructed with the product rules\\<close>"], ["", "lemma \\<delta>_prod_precise: \n  \"\\<lbrakk> accs \\<delta>1 t q1; accs \\<delta>2 t q2 \\<rbrakk> \\<Longrightarrow> accs (\\<delta>_prod \\<delta>1 \\<delta>2) t (q1,q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>accs \\<delta>1 t q1; accs \\<delta>2 t q2\\<rbrakk>\n    \\<Longrightarrow> accs (\\<delta>_prod \\<delta>1 \\<delta>2) t (q1, q2)", "proof (induct arbitrary: \\<delta>2 q2 rule: accs.induct[case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>2 q2.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>2 q2.\n           \\<lbrakk>i < length qs; accs \\<delta>2 (ts ! i) q2\\<rbrakk>\n           \\<Longrightarrow> accs (\\<delta>_prod \\<delta> \\<delta>2)\n                              (ts ! i) (qs ! i, q2);\n        accs \\<delta>2 (NODE f ts) q2\\<rbrakk>\n       \\<Longrightarrow> accs (\\<delta>_prod \\<delta> \\<delta>2) (NODE f ts)\n                          (q, q2)", "case (step q1 l qs1 \\<delta>1 ts \\<delta>2 q2)"], ["proof (state)\nthis:\n  q1 \\<rightarrow> l qs1 \\<in> \\<delta>1\n  length ts = length qs1\n  ?i < length qs1 \\<Longrightarrow> accs \\<delta>1 (ts ! ?i) (qs1 ! ?i)\n  \\<lbrakk>?i < length qs1; accs ?\\<delta>2.0 (ts ! ?i) ?q2.0\\<rbrakk>\n  \\<Longrightarrow> accs (\\<delta>_prod \\<delta>1 ?\\<delta>2.0) (ts ! ?i)\n                     (qs1 ! ?i, ?q2.0)\n  accs \\<delta>2 (NODE l ts) q2\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>2 q2.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>2 q2.\n           \\<lbrakk>i < length qs; accs \\<delta>2 (ts ! i) q2\\<rbrakk>\n           \\<Longrightarrow> accs (\\<delta>_prod \\<delta> \\<delta>2)\n                              (ts ! i) (qs ! i, q2);\n        accs \\<delta>2 (NODE f ts) q2\\<rbrakk>\n       \\<Longrightarrow> accs (\\<delta>_prod \\<delta> \\<delta>2) (NODE f ts)\n                          (q, q2)", "note [simp] = step.hyps(2,3)"], ["proof (state)\nthis:\n  length ts = length qs1\n  ?i < length qs1 \\<Longrightarrow> accs \\<delta>1 (ts ! ?i) (qs1 ! ?i)\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>2 q2.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>2 q2.\n           \\<lbrakk>i < length qs; accs \\<delta>2 (ts ! i) q2\\<rbrakk>\n           \\<Longrightarrow> accs (\\<delta>_prod \\<delta> \\<delta>2)\n                              (ts ! i) (qs ! i, q2);\n        accs \\<delta>2 (NODE f ts) q2\\<rbrakk>\n       \\<Longrightarrow> accs (\\<delta>_prod \\<delta> \\<delta>2) (NODE f ts)\n                          (q, q2)", "from step.hyps(2)"], ["proof (chain)\npicking this:\n  length ts = length qs1", "obtain qs2 where \n    I2: \"(q2 \\<rightarrow> l qs2)\\<in>\\<delta>2\" \n        \"!!i. i<length qs2 \\<Longrightarrow> accs \\<delta>2 (ts ! i) (qs2 ! i)\" and \n    [simp]: \"length qs2 = length ts\""], ["proof (prove)\nusing this:\n  length ts = length qs1\n\ngoal (1 subgoal):\n 1. (\\<And>qs2.\n        \\<lbrakk>q2 \\<rightarrow> l qs2 \\<in> \\<delta>2;\n         \\<And>i.\n            i < length qs2 \\<Longrightarrow>\n            accs \\<delta>2 (ts ! i) (qs2 ! i);\n         length qs2 = length ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule_tac accs.cases[OF step.prems]) fastforce"], ["proof (state)\nthis:\n  q2 \\<rightarrow> l qs2 \\<in> \\<delta>2\n  ?i < length qs2 \\<Longrightarrow> accs \\<delta>2 (ts ! ?i) (qs2 ! ?i)\n  length qs2 = length ts\n\ngoal (1 subgoal):\n 1. \\<And>q f qs \\<delta> ts \\<delta>2 q2.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow> accs \\<delta> (ts ! i) (qs ! i);\n        \\<And>i \\<delta>2 q2.\n           \\<lbrakk>i < length qs; accs \\<delta>2 (ts ! i) q2\\<rbrakk>\n           \\<Longrightarrow> accs (\\<delta>_prod \\<delta> \\<delta>2)\n                              (ts ! i) (qs ! i, q2);\n        accs \\<delta>2 (NODE f ts) q2\\<rbrakk>\n       \\<Longrightarrow> accs (\\<delta>_prod \\<delta> \\<delta>2) (NODE f ts)\n                          (q, q2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. accs (\\<delta>_prod \\<delta>1 \\<delta>2) (NODE l ts) (q1, q2)", "proof (rule accs.intros)"], ["proof (state)\ngoal (3 subgoals):\n 1. (q1, q2) \\<rightarrow> l ?qs \\<in> \\<delta>_prod \\<delta>1 \\<delta>2\n 2. length ts = length ?qs\n 3. \\<And>i.\n       i < length ?qs \\<Longrightarrow>\n       accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (?qs ! i)", "from step.hyps(1) I2(1)"], ["proof (chain)\npicking this:\n  q1 \\<rightarrow> l qs1 \\<in> \\<delta>1\n  q2 \\<rightarrow> l qs2 \\<in> \\<delta>2", "show \n      \"((q1,q2) \\<rightarrow> l (zip qs1 qs2))\\<in>\\<delta>_prod \\<delta>1 \\<delta>2\" and \n      [simp]: \"length ts = length (zip qs1 qs2)\""], ["proof (prove)\nusing this:\n  q1 \\<rightarrow> l qs1 \\<in> \\<delta>1\n  q2 \\<rightarrow> l qs2 \\<in> \\<delta>2\n\ngoal (1 subgoal):\n 1. (q1, q2) \\<rightarrow> l zip qs1 qs2\n    \\<in> \\<delta>_prod \\<delta>1 \\<delta>2 &&&\n    length ts = length (zip qs1 qs2)", "by (unfold \\<delta>_prod_def) force+"], ["proof (state)\nthis:\n  (q1, q2) \\<rightarrow> l zip qs1 qs2\n  \\<in> \\<delta>_prod \\<delta>1 \\<delta>2\n  length ts = length (zip qs1 qs2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (zip qs1 qs2) \\<Longrightarrow>\n       accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (zip qs1 qs2) \\<Longrightarrow>\n       accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (zip qs1 qs2) \\<Longrightarrow>\n       accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)", "assume L: \"i<length (zip qs1 qs2)\""], ["proof (state)\nthis:\n  i < length (zip qs1 qs2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (zip qs1 qs2) \\<Longrightarrow>\n       accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)", "with step.hyps(4)[OF _ I2(2), of i]"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < length qs1; i < length qs2\\<rbrakk>\n  \\<Longrightarrow> accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i)\n                     (qs1 ! i, qs2 ! i)\n  i < length (zip qs1 qs2)", "have \n      \"accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (qs1 ! i, qs2 ! i)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length qs1; i < length qs2\\<rbrakk>\n  \\<Longrightarrow> accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i)\n                     (qs1 ! i, qs2 ! i)\n  i < length (zip qs1 qs2)\n\ngoal (1 subgoal):\n 1. accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (qs1 ! i, qs2 ! i)", "by simp"], ["proof (state)\nthis:\n  accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (qs1 ! i, qs2 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (zip qs1 qs2) \\<Longrightarrow>\n       accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)", "also"], ["proof (state)\nthis:\n  accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (qs1 ! i, qs2 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (zip qs1 qs2) \\<Longrightarrow>\n       accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)", "have \"(qs1 ! i, qs2 ! i) = zip qs1 qs2 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qs1 ! i, qs2 ! i) = zip qs1 qs2 ! i", "using L"], ["proof (prove)\nusing this:\n  i < length (zip qs1 qs2)\n\ngoal (1 subgoal):\n 1. (qs1 ! i, qs2 ! i) = zip qs1 qs2 ! i", "by auto"], ["proof (state)\nthis:\n  (qs1 ! i, qs2 ! i) = zip qs1 qs2 ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (zip qs1 qs2) \\<Longrightarrow>\n       accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)", "finally"], ["proof (chain)\npicking this:\n  accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)", "show \"accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)\""], ["proof (prove)\nusing this:\n  accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)\n\ngoal (1 subgoal):\n 1. accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)", "."], ["proof (state)\nthis:\n  accs (\\<delta>_prod \\<delta>1 \\<delta>2) (ts ! i) (zip qs1 qs2 ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  accs (\\<delta>_prod \\<delta>1 \\<delta>2) (NODE l ts) (q1, q2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<delta>_prod_empty[simp]: \n  \"\\<delta>_prod {} \\<delta> = {}\"\n  \"\\<delta>_prod \\<delta> {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_prod {} \\<delta> = {} &&& \\<delta>_prod \\<delta> {} = {}", "by (unfold \\<delta>_prod_def) auto"], ["", "lemma \\<delta>_prod_2sng[simp]: \n  \"\\<lbrakk> rhsl r1 \\<noteq> rhsl r2 \\<rbrakk> \\<Longrightarrow> \\<delta>_prod {r1} {r2} = {}\"\n  \"\\<lbrakk> length (rhsq r1) \\<noteq> length (rhsq r2) \\<rbrakk> \\<Longrightarrow> \\<delta>_prod {r1} {r2} = {}\"\n  \"\\<lbrakk> rhsl r1 = rhsl r2; length (rhsq r1) = length (rhsq r2) \\<rbrakk> \n    \\<Longrightarrow> \\<delta>_prod {r1} {r2} = {r_prod r1 r2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rhsl r1 \\<noteq> rhsl r2 \\<Longrightarrow>\n     \\<delta>_prod {r1} {r2} = {}) &&&\n    (length (rhsq r1) \\<noteq> length (rhsq r2) \\<Longrightarrow>\n     \\<delta>_prod {r1} {r2} = {}) &&&\n    (\\<lbrakk>rhsl r1 = rhsl r2;\n      length (rhsq r1) = length (rhsq r2)\\<rbrakk>\n     \\<Longrightarrow> \\<delta>_prod {r1} {r2} = {r_prod r1 r2})", "apply (unfold \\<delta>_prod_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rhsl r1 \\<noteq> rhsl r2 \\<Longrightarrow>\n    {r_prod q1 \\<rightarrow> l qs1 q2 \\<rightarrow> l qs2 |q1 q2 l qs1 qs2.\n     length qs1 = length qs2 \\<and>\n     q1 \\<rightarrow> l qs1 \\<in> {r1} \\<and>\n     q2 \\<rightarrow> l qs2 \\<in> {r2}} =\n    {}\n 2. length (rhsq r1) \\<noteq> length (rhsq r2) \\<Longrightarrow>\n    {r_prod q1 \\<rightarrow> l qs1 q2 \\<rightarrow> l qs2 |q1 q2 l qs1 qs2.\n     length qs1 = length qs2 \\<and>\n     q1 \\<rightarrow> l qs1 \\<in> {r1} \\<and>\n     q2 \\<rightarrow> l qs2 \\<in> {r2}} =\n    {}\n 3. \\<lbrakk>rhsl r1 = rhsl r2; length (rhsq r1) = length (rhsq r2)\\<rbrakk>\n    \\<Longrightarrow> {r_prod q1 \\<rightarrow> l qs1\n                        q2 \\<rightarrow> l qs2 |\n                       q1 q2 l qs1 qs2.\n                       length qs1 = length qs2 \\<and>\n                       q1 \\<rightarrow> l qs1 \\<in> {r1} \\<and>\n                       q2 \\<rightarrow> l qs2 \\<in> {r2}} =\n                      {r_prod r1 r2}", "apply (cases r1, cases r2, auto)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<delta>_prod_Un[simp]: \n  \"\\<delta>_prod (\\<delta>1\\<union>\\<delta>1') \\<delta>2 = \\<delta>_prod \\<delta>1 \\<delta>2 \\<union> \\<delta>_prod \\<delta>1' \\<delta>2\"\n  \"\\<delta>_prod \\<delta>1 (\\<delta>2\\<union>\\<delta>2') = \\<delta>_prod \\<delta>1 \\<delta>2 \\<union> \\<delta>_prod \\<delta>1 \\<delta>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_prod (\\<delta>1 \\<union> \\<delta>1') \\<delta>2 =\n    \\<delta>_prod \\<delta>1 \\<delta>2 \\<union>\n    \\<delta>_prod \\<delta>1' \\<delta>2 &&&\n    \\<delta>_prod \\<delta>1 (\\<delta>2 \\<union> \\<delta>2') =\n    \\<delta>_prod \\<delta>1 \\<delta>2 \\<union>\n    \\<delta>_prod \\<delta>1 \\<delta>2'", "by (auto elim: \\<delta>_prodE intro: \\<delta>_prodI)"], ["", "text \\<open>The next two definitions are solely for technical reasons.\n  They are required to allow simplification of expressions of the form\n  @{term \"\\<delta>_prod (insert r \\<delta>1) \\<delta>2\"} or @{term \"\\<delta>_prod \\<delta>1 (insert r \\<delta>2)\"}, \n  without making the simplifier loop.\n\\<close>"], ["", "definition \"\\<delta>_prod_sng1 r \\<delta>2 == \n  case r of (q1 \\<rightarrow> l qs1) \\<Rightarrow> \n    { r_prod r (q2 \\<rightarrow> l qs2) | \n         q2 qs2. length qs1 = length qs2 \\<and> (q2 \\<rightarrow> l qs2)\\<in>\\<delta>2 \n    }\""], ["", "definition \"\\<delta>_prod_sng2 \\<delta>1 r == \n  case r of (q2 \\<rightarrow> l qs2) \\<Rightarrow> \n    { r_prod (q1 \\<rightarrow> l qs1) r | \n         q1 qs1. length qs1 = length qs2 \\<and> (q1 \\<rightarrow> l qs1)\\<in>\\<delta>1 \n    }\""], ["", "lemma \\<delta>_prod_sng_alt:\n  \"\\<delta>_prod_sng1 r \\<delta>2 = \\<delta>_prod {r} \\<delta>2\"\n  \"\\<delta>_prod_sng2 \\<delta>1 r = \\<delta>_prod \\<delta>1 {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_prod_sng1 r \\<delta>2 = \\<delta>_prod {r} \\<delta>2 &&&\n    \\<delta>_prod_sng2 \\<delta>1 r = \\<delta>_prod \\<delta>1 {r}", "apply (unfold \\<delta>_prod_def \\<delta>_prod_sng1_def \\<delta>_prod_sng2_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (case r of\n     q1 \\<rightarrow> l qs1 \\<Rightarrow>\n       {r_prod r q2 \\<rightarrow> l qs2 |q2 qs2.\n        length qs1 = length qs2 \\<and>\n        q2 \\<rightarrow> l qs2 \\<in> \\<delta>2}) =\n    {r_prod q1 \\<rightarrow> l qs1 q2 \\<rightarrow> l qs2 |q1 q2 l qs1 qs2.\n     length qs1 = length qs2 \\<and>\n     q1 \\<rightarrow> l qs1 \\<in> {r} \\<and>\n     q2 \\<rightarrow> l qs2 \\<in> \\<delta>2}\n 2. (case r of\n     q2 \\<rightarrow> l qs2 \\<Rightarrow>\n       {r_prod q1 \\<rightarrow> l qs1 r |q1 qs1.\n        length qs1 = length qs2 \\<and>\n        q1 \\<rightarrow> l qs1 \\<in> \\<delta>1}) =\n    {r_prod q1 \\<rightarrow> l qs1 q2 \\<rightarrow> l qs2 |q1 q2 l qs1 qs2.\n     length qs1 = length qs2 \\<and>\n     q1 \\<rightarrow> l qs1 \\<in> \\<delta>1 \\<and>\n     q2 \\<rightarrow> l qs2 \\<in> {r}}", "apply (auto split: ta_rule.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas \\<delta>_prod_insert = \n  \\<delta>_prod_Un(1)[where ?\\<delta>1.0=\"{x}\", simplified, folded \\<delta>_prod_sng_alt]\n  \\<delta>_prod_Un(2)[where ?\\<delta>2.0=\"{x}\", simplified, folded \\<delta>_prod_sng_alt]\n  for x\n\n  \\<comment> \\<open>Product automaton\\<close>"], ["", "definition \"ta_prod TA1 TA2 == \n  \\<lparr> ta_initial = ta_initial TA1 \\<times> ta_initial TA2, \n    ta_rules = \\<delta>_prod (ta_rules TA1) (ta_rules TA2) \n  \\<rparr>\""], ["", "lemma ta_prod_correct_aux1: \n  \"ta_lang (ta_prod TA1 TA2) = ta_lang TA1 \\<inter> ta_lang TA2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (ta_prod TA1 TA2) = ta_lang TA1 \\<inter> ta_lang TA2", "by (unfold ta_lang_def ta_prod_def) (auto dest: \\<delta>_prod_sound \\<delta>_prod_precise)"], ["", "lemma \\<delta>_states_cart: \n  \"q \\<in> \\<delta>_states (\\<delta>_prod \\<delta>1 \\<delta>2) \\<Longrightarrow> q \\<in> \\<delta>_states \\<delta>1 \\<times> \\<delta>_states \\<delta>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states\n             (\\<delta>_prod \\<delta>1 \\<delta>2) \\<Longrightarrow>\n    q \\<in> \\<delta>_states \\<delta>1 \\<times> \\<delta>_states \\<delta>2", "by (unfold \\<delta>_states_def \\<delta>_prod_def) \n     (force split: ta_rule.split simp add: set_zip)"], ["", "lemma \\<delta>_prod_finite [simp, intro]: \n  \"finite \\<delta>1 \\<Longrightarrow> finite \\<delta>2 \\<Longrightarrow> finite (\\<delta>_prod \\<delta>1 \\<delta>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite \\<delta>1; finite \\<delta>2\\<rbrakk>\n    \\<Longrightarrow> finite (\\<delta>_prod \\<delta>1 \\<delta>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite \\<delta>1; finite \\<delta>2\\<rbrakk>\n    \\<Longrightarrow> finite (\\<delta>_prod \\<delta>1 \\<delta>2)", "have \n    \"\\<delta>_prod \\<delta>1 \\<delta>2 \n    \\<subseteq> (\\<lambda>(r1,r2). case r1 of (q1 \\<rightarrow> l1 qs1) \\<Rightarrow> \n                  case r2 of (q2 \\<rightarrow> l2 qs2) \\<Rightarrow> \n                    ((q1,q2) \\<rightarrow> l1 (zip qs1 qs2))) \n       ` (\\<delta>1 \\<times> \\<delta>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>_prod \\<delta>1 \\<delta>2\n    \\<subseteq> (\\<lambda>(r1, r2).\n                    case r1 of\n                    q1 \\<rightarrow> l1 qs1 \\<Rightarrow>\n                      case r2 of\n                      q2 \\<rightarrow> l2 qs2 \\<Rightarrow>\n                        (q1, q2) \\<rightarrow> l1 zip qs1 qs2) `\n                (\\<delta>1 \\<times> \\<delta>2)", "by (unfold \\<delta>_prod_def) force"], ["proof (state)\nthis:\n  \\<delta>_prod \\<delta>1 \\<delta>2\n  \\<subseteq> (\\<lambda>(r1, r2).\n                  case r1 of\n                  q1 \\<rightarrow> l1 qs1 \\<Rightarrow>\n                    case r2 of\n                    q2 \\<rightarrow> l2 qs2 \\<Rightarrow>\n                      (q1, q2) \\<rightarrow> l1 zip qs1 qs2) `\n              (\\<delta>1 \\<times> \\<delta>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite \\<delta>1; finite \\<delta>2\\<rbrakk>\n    \\<Longrightarrow> finite (\\<delta>_prod \\<delta>1 \\<delta>2)", "moreover"], ["proof (state)\nthis:\n  \\<delta>_prod \\<delta>1 \\<delta>2\n  \\<subseteq> (\\<lambda>(r1, r2).\n                  case r1 of\n                  q1 \\<rightarrow> l1 qs1 \\<Rightarrow>\n                    case r2 of\n                    q2 \\<rightarrow> l2 qs2 \\<Rightarrow>\n                      (q1, q2) \\<rightarrow> l1 zip qs1 qs2) `\n              (\\<delta>1 \\<times> \\<delta>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite \\<delta>1; finite \\<delta>2\\<rbrakk>\n    \\<Longrightarrow> finite (\\<delta>_prod \\<delta>1 \\<delta>2)", "assume \"finite \\<delta>1\" \"finite \\<delta>2\""], ["proof (state)\nthis:\n  finite \\<delta>1\n  finite \\<delta>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite \\<delta>1; finite \\<delta>2\\<rbrakk>\n    \\<Longrightarrow> finite (\\<delta>_prod \\<delta>1 \\<delta>2)", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta>_prod \\<delta>1 \\<delta>2\n  \\<subseteq> (\\<lambda>(r1, r2).\n                  case r1 of\n                  q1 \\<rightarrow> l1 qs1 \\<Rightarrow>\n                    case r2 of\n                    q2 \\<rightarrow> l2 qs2 \\<Rightarrow>\n                      (q1, q2) \\<rightarrow> l1 zip qs1 qs2) `\n              (\\<delta>1 \\<times> \\<delta>2)\n  finite \\<delta>1\n  finite \\<delta>2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<delta>_prod \\<delta>1 \\<delta>2\n  \\<subseteq> (\\<lambda>(r1, r2).\n                  case r1 of\n                  q1 \\<rightarrow> l1 qs1 \\<Rightarrow>\n                    case r2 of\n                    q2 \\<rightarrow> l2 qs2 \\<Rightarrow>\n                      (q1, q2) \\<rightarrow> l1 zip qs1 qs2) `\n              (\\<delta>1 \\<times> \\<delta>2)\n  finite \\<delta>1\n  finite \\<delta>2\n\ngoal (1 subgoal):\n 1. finite (\\<delta>_prod \\<delta>1 \\<delta>2)", "by (metis finite_imageI finite_cartesian_product finite_subset)"], ["proof (state)\nthis:\n  finite (\\<delta>_prod \\<delta>1 \\<delta>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ta_prod_correct_aux2: \n  assumes TA: \"tree_automaton TA1\" \"tree_automaton TA2\" \n  shows \"tree_automaton (ta_prod TA1 TA2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton (ta_prod TA1 TA2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tree_automaton (ta_prod TA1 TA2)", "interpret ta1: tree_automaton TA1"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton TA1", "using TA"], ["proof (prove)\nusing this:\n  tree_automaton TA1\n  tree_automaton TA2\n\ngoal (1 subgoal):\n 1. tree_automaton TA1", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. tree_automaton (ta_prod TA1 TA2)", "interpret ta2: tree_automaton TA2"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton TA2", "using TA"], ["proof (prove)\nusing this:\n  tree_automaton TA1\n  tree_automaton TA2\n\ngoal (1 subgoal):\n 1. tree_automaton TA2", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. tree_automaton (ta_prod TA1 TA2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton (ta_prod TA1 TA2)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (ta_rules (ta_prod TA1 TA2))\n 2. finite (ta_initial (ta_prod TA1 TA2))", "apply (unfold ta_prod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (ta_rules\n       \\<lparr>ta_initial = ta1.Qi \\<times> ta2.Qi,\n          ta_rules = \\<delta>_prod ta1.\\<delta> ta2.\\<delta>\\<rparr>)\n 2. finite\n     (ta_initial\n       \\<lparr>ta_initial = ta1.Qi \\<times> ta2.Qi,\n          ta_rules = \\<delta>_prod ta1.\\<delta> ta2.\\<delta>\\<rparr>)", "apply (auto \n      intro: ta1.is_subset ta2.is_subset \\<delta>_prod_finite \n      dest: \\<delta>_states_cart \n      simp add: ta1.finite_states ta2.finite_states \n                ta1.finite_rules ta2.finite_rules)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  tree_automaton (ta_prod TA1 TA2)\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>The language of the product automaton is the intersection of the languages\n      of the two original automata\\<close>"], ["", "theorem ta_prod_correct:\n  assumes TA: \"tree_automaton TA1\" \"tree_automaton TA2\" \n  shows \n    \"ta_lang (ta_prod TA1 TA2) = ta_lang TA1 \\<inter> ta_lang TA2\"\n    \"tree_automaton (ta_prod TA1 TA2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (ta_prod TA1 TA2) = ta_lang TA1 \\<inter> ta_lang TA2 &&&\n    tree_automaton (ta_prod TA1 TA2)", "using ta_prod_correct_aux1 \n        ta_prod_correct_aux2[OF TA]"], ["proof (prove)\nusing this:\n  ta_lang (ta_prod ?TA1.0 ?TA2.0) = ta_lang ?TA1.0 \\<inter> ta_lang ?TA2.0\n  tree_automaton (ta_prod TA1 TA2)\n\ngoal (1 subgoal):\n 1. ta_lang (ta_prod TA1 TA2) = ta_lang TA1 \\<inter> ta_lang TA2 &&&\n    tree_automaton (ta_prod TA1 TA2)", "by auto"], ["", "lemma ta_prod_rta: \n  assumes TA: \"ranked_tree_automaton TA1 A\" \"ranked_tree_automaton TA2 A\" \n  shows \"ranked_tree_automaton (ta_prod TA1 TA2) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_prod TA1 TA2) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_prod TA1 TA2) A", "interpret ta1: ranked_tree_automaton TA1 A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA1 A", "using TA"], ["proof (prove)\nusing this:\n  ranked_tree_automaton TA1 A\n  ranked_tree_automaton TA2 A\n\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA1 A", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_prod TA1 TA2) A", "interpret ta2: ranked_tree_automaton TA2 A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA2 A", "using TA"], ["proof (prove)\nusing this:\n  ranked_tree_automaton TA1 A\n  ranked_tree_automaton TA2 A\n\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA2 A", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_prod TA1 TA2) A", "interpret tap: tree_automaton \"(ta_prod TA1 TA2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton (ta_prod TA1 TA2)", "apply (rule ta_prod_correct_aux2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. tree_automaton TA1\n 2. tree_automaton TA2", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_prod TA1 TA2) A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_prod TA1 TA2) A", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> tap.\\<delta> \\<Longrightarrow>\n       A f = Some (length qs)", "apply (unfold ta_prod_def \\<delta>_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q f qs.\n       q \\<rightarrow> f qs\n       \\<in> ta_rules\n              \\<lparr>ta_initial = ta1.Qi \\<times> ta2.Qi,\n                 ta_rules =\n                   {r_prod q1 \\<rightarrow> l qs1 q2 \\<rightarrow> l qs2 |q1\n                    q2 l qs1 qs2.\n                    length qs1 = length qs2 \\<and>\n                    q1 \\<rightarrow> l qs1 \\<in> ta1.\\<delta> \\<and>\n                    q2 \\<rightarrow> l qs2\n                    \\<in> ta2.\\<delta>}\\<rparr> \\<Longrightarrow>\n       A f = Some (length qs)", "apply (auto intro: ta1.ranked ta2.ranked)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ranked_tree_automaton (ta_prod TA1 TA2) A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Determinization\""], ["", "text \\<open>\n  We only formalize the brute-force subset construction without reduction. \n\n  The basic idea of this construction is to construct an automaton where the\n  states are sets of original states, and the lhs of a rule consists of all\n  states that a term with given rhs and function symbol may be labeled by.\n\\<close>"], ["", "context ranked_tree_automaton\nbegin\n  \\<comment> \\<open>Left-hand side of subset rule for given symbol and rhs\\<close>"], ["", "definition \"\\<delta>ss_lhs f ss == \n    { q | q qs. (q \\<rightarrow> f qs)\\<in>\\<delta> \\<and> list_all_zip (\\<in>) qs ss }\"\n\n  \\<comment> \\<open>Subset construction\\<close>"], ["", "inductive_set \\<delta>ss :: \"('Q set,'L) ta_rule set\" where\n    \"\\<lbrakk> A f = Some (length ss); \n       ss \\<in> lists {s. s \\<subseteq> ta_rstates TA}; \n       s = \\<delta>ss_lhs f ss\n     \\<rbrakk> \\<Longrightarrow> (s \\<rightarrow> f ss) \\<in> \\<delta>ss\""], ["", "lemma \\<delta>ssI: \n    assumes A: \"A f = Some (length ss)\"\n               \"ss \\<in> lists {s. s \\<subseteq> ta_rstates TA}\"\n    shows \n      \"( (\\<delta>ss_lhs f ss) \\<rightarrow> f ss) \\<in> \\<delta>ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>ss_lhs f ss \\<rightarrow> f ss \\<in> \\<delta>ss", "using \\<delta>ss.intros[where s=\"(\\<delta>ss_lhs f ss)\"] A"], ["proof (prove)\nusing this:\n  \\<lbrakk>A ?f = Some (length ?ss);\n   listsp (\\<lambda>s. s \\<subseteq> Q) ?ss;\n   \\<delta>ss_lhs f ss = \\<delta>ss_lhs ?f ?ss\\<rbrakk>\n  \\<Longrightarrow> \\<delta>ss_lhs f ss \\<rightarrow> ?f ?ss\n                    \\<in> \\<delta>ss\n  A f = Some (length ss)\n  ss \\<in> lists {s. s \\<subseteq> Q}\n\ngoal (1 subgoal):\n 1. \\<delta>ss_lhs f ss \\<rightarrow> f ss \\<in> \\<delta>ss", "by auto"], ["", "lemma \\<delta>ss_subset[simp, intro!]: \"\\<delta>ss_lhs f ss \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>ss_lhs f ss \\<subseteq> Q", "by (unfold ta_rstates_def \\<delta>ss_lhs_def) (auto intro: \\<delta>_statesI)"], ["", "lemma \\<delta>ss_finite[simp, intro!]: \"finite \\<delta>ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta>ss", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite \\<delta>ss", "have \"\\<delta>ss \\<subseteq> \\<Union>((\\<lambda>f. (\\<lambda>(s,ss). (s \\<rightarrow> f ss))\n                     `({s. s\\<subseteq>Q} \n                       \\<times> (lists {s. s\\<subseteq>Q} \\<inter> {l. length l = the (A f)}))\n                  ) ` F)\" \n      (is \"_\\<subseteq>\\<Union>((\\<lambda>f. ?tr f ` ?prod f)`F)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>ss\n    \\<subseteq> (\\<Union>f\\<in>F.\n                    (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                    ({s. s \\<subseteq> Q} \\<times>\n                     (lists {s. s \\<subseteq> Q} \\<inter>\n                      {l. length l = the (A f)})))", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "assume \"r\\<in>\\<delta>ss\""], ["proof (state)\nthis:\n  r \\<in> \\<delta>ss\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "then"], ["proof (chain)\npicking this:\n  r \\<in> \\<delta>ss", "obtain f s ss where \n        U: \"r=(s \\<rightarrow> f ss)\" \n           \"A f = Some (length ss)\" \n           \"ss\\<in>lists {s. s\\<subseteq>Q}\" \n           \"s=\\<delta>ss_lhs f ss\""], ["proof (prove)\nusing this:\n  r \\<in> \\<delta>ss\n\ngoal (1 subgoal):\n 1. (\\<And>s f ss.\n        \\<lbrakk>r = s \\<rightarrow> f ss; A f = Some (length ss);\n         ss \\<in> lists {s. s \\<subseteq> Q};\n         s = \\<delta>ss_lhs f ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force elim!: \\<delta>ss.cases)"], ["proof (state)\nthis:\n  r = s \\<rightarrow> f ss\n  A f = Some (length ss)\n  ss \\<in> lists {s. s \\<subseteq> Q}\n  s = \\<delta>ss_lhs f ss\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "from U(4)"], ["proof (chain)\npicking this:\n  s = \\<delta>ss_lhs f ss", "have \"s\\<subseteq>Q\""], ["proof (prove)\nusing this:\n  s = \\<delta>ss_lhs f ss\n\ngoal (1 subgoal):\n 1. s \\<subseteq> Q", "by simp"], ["proof (state)\nthis:\n  s \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "moreover"], ["proof (state)\nthis:\n  s \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "from U(2)"], ["proof (chain)\npicking this:\n  A f = Some (length ss)", "have \"length ss = the (A f)\""], ["proof (prove)\nusing this:\n  A f = Some (length ss)\n\ngoal (1 subgoal):\n 1. length ss = the (A f)", "by simp"], ["proof (state)\nthis:\n  length ss = the (A f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "ultimately"], ["proof (chain)\npicking this:\n  s \\<subseteq> Q\n  length ss = the (A f)", "have \"(s,ss)\\<in>?prod f\""], ["proof (prove)\nusing this:\n  s \\<subseteq> Q\n  length ss = the (A f)\n\ngoal (1 subgoal):\n 1. (s, ss)\n    \\<in> {s. s \\<subseteq> Q} \\<times>\n          (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)})", "using U(3)"], ["proof (prove)\nusing this:\n  s \\<subseteq> Q\n  length ss = the (A f)\n  ss \\<in> lists {s. s \\<subseteq> Q}\n\ngoal (1 subgoal):\n 1. (s, ss)\n    \\<in> {s. s \\<subseteq> Q} \\<times>\n          (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)})", "by auto"], ["proof (state)\nthis:\n  (s, ss)\n  \\<in> {s. s \\<subseteq> Q} \\<times>\n        (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "hence \"(s \\<rightarrow> f ss)\\<in>?tr f ` ?prod f\""], ["proof (prove)\nusing this:\n  (s, ss)\n  \\<in> {s. s \\<subseteq> Q} \\<times>\n        (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)})\n\ngoal (1 subgoal):\n 1. s \\<rightarrow> f ss\n    \\<in> (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n          ({s. s \\<subseteq> Q} \\<times>\n           (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)}))", "by auto"], ["proof (state)\nthis:\n  s \\<rightarrow> f ss\n  \\<in> (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n        ({s. s \\<subseteq> Q} \\<times>\n         (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "moreover"], ["proof (state)\nthis:\n  s \\<rightarrow> f ss\n  \\<in> (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n        ({s. s \\<subseteq> Q} \\<times>\n         (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "from U(2)"], ["proof (chain)\npicking this:\n  A f = Some (length ss)", "have \"f\\<in>F\""], ["proof (prove)\nusing this:\n  A f = Some (length ss)\n\ngoal (1 subgoal):\n 1. f \\<in> F", "by auto"], ["proof (state)\nthis:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>ss \\<Longrightarrow>\n       x \\<in> (\\<Union>f\\<in>F.\n                   (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                   ({s. s \\<subseteq> Q} \\<times>\n                    (lists {s. s \\<subseteq> Q} \\<inter>\n                     {l. length l = the (A f)})))", "ultimately"], ["proof (chain)\npicking this:\n  s \\<rightarrow> f ss\n  \\<in> (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n        ({s. s \\<subseteq> Q} \\<times>\n         (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)}))\n  f \\<in> F", "show \"r\\<in>\\<Union>((\\<lambda>f. ?tr f ` ?prod f)`F)\""], ["proof (prove)\nusing this:\n  s \\<rightarrow> f ss\n  \\<in> (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n        ({s. s \\<subseteq> Q} \\<times>\n         (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)}))\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. r \\<in> (\\<Union>f\\<in>F.\n                (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                ({s. s \\<subseteq> Q} \\<times>\n                 (lists {s. s \\<subseteq> Q} \\<inter>\n                  {l. length l = the (A f)})))", "using U(1)"], ["proof (prove)\nusing this:\n  s \\<rightarrow> f ss\n  \\<in> (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n        ({s. s \\<subseteq> Q} \\<times>\n         (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)}))\n  f \\<in> F\n  r = s \\<rightarrow> f ss\n\ngoal (1 subgoal):\n 1. r \\<in> (\\<Union>f\\<in>F.\n                (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                ({s. s \\<subseteq> Q} \\<times>\n                 (lists {s. s \\<subseteq> Q} \\<inter>\n                  {l. length l = the (A f)})))", "by auto"], ["proof (state)\nthis:\n  r \\<in> (\\<Union>f\\<in>F.\n              (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n              ({s. s \\<subseteq> Q} \\<times>\n               (lists {s. s \\<subseteq> Q} \\<inter>\n                {l. length l = the (A f)})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<delta>ss\n  \\<subseteq> (\\<Union>f\\<in>F.\n                  (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                  ({s. s \\<subseteq> Q} \\<times>\n                   (lists {s. s \\<subseteq> Q} \\<inter>\n                    {l. length l = the (A f)})))\n\ngoal (1 subgoal):\n 1. finite \\<delta>ss", "moreover"], ["proof (state)\nthis:\n  \\<delta>ss\n  \\<subseteq> (\\<Union>f\\<in>F.\n                  (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                  ({s. s \\<subseteq> Q} \\<times>\n                   (lists {s. s \\<subseteq> Q} \\<inter>\n                    {l. length l = the (A f)})))\n\ngoal (1 subgoal):\n 1. finite \\<delta>ss", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>f\\<in>F.\n         (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n         ({s. s \\<subseteq> Q} \\<times>\n          (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)})))", "by (auto intro!: finite_imageI finite_SigmaI lists_of_len_fin)"], ["proof (state)\nthis:\n  finite\n   (\\<Union>f\\<in>F.\n       (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n       ({s. s \\<subseteq> Q} \\<times>\n        (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)})))\n\ngoal (1 subgoal):\n 1. finite \\<delta>ss", "ultimately"], ["proof (chain)\npicking this:\n  \\<delta>ss\n  \\<subseteq> (\\<Union>f\\<in>F.\n                  (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                  ({s. s \\<subseteq> Q} \\<times>\n                   (lists {s. s \\<subseteq> Q} \\<inter>\n                    {l. length l = the (A f)})))\n  finite\n   (\\<Union>f\\<in>F.\n       (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n       ({s. s \\<subseteq> Q} \\<times>\n        (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)})))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<delta>ss\n  \\<subseteq> (\\<Union>f\\<in>F.\n                  (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n                  ({s. s \\<subseteq> Q} \\<times>\n                   (lists {s. s \\<subseteq> Q} \\<inter>\n                    {l. length l = the (A f)})))\n  finite\n   (\\<Union>f\\<in>F.\n       (\\<lambda>(s, ss). s \\<rightarrow> f ss) `\n       ({s. s \\<subseteq> Q} \\<times>\n        (lists {s. s \\<subseteq> Q} \\<inter> {l. length l = the (A f)})))\n\ngoal (1 subgoal):\n 1. finite \\<delta>ss", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite \\<delta>ss\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<delta>ss_det: \"\\<lbrakk> (q \\<rightarrow> f qs) \\<in> \\<delta>ss; (q' \\<rightarrow> f qs) \\<in>\\<delta>ss \\<rbrakk> \\<Longrightarrow> q=q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>ss;\n     q' \\<rightarrow> f qs \\<in> \\<delta>ss\\<rbrakk>\n    \\<Longrightarrow> q = q'", "by (auto elim!: \\<delta>ss.cases)"], ["", "lemma \\<delta>ss_accs_sound: \n    assumes A: \"accs \\<delta> t q\"  \n    obtains s where\n    \"s\\<subseteq>Q\"\n    \"q\\<in>s\"\n    \"accs \\<delta>ss t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<subseteq> Q; q \\<in> s; accs \\<delta>ss t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<subseteq> Q; q \\<in> s; accs \\<delta>ss t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>s\\<subseteq>Q. q\\<in>s \\<and> accs_laz \\<delta>ss t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<subseteq>Q. q \\<in> s \\<and> accs_laz \\<delta>ss t s", "using A[unfolded accs_laz]"], ["proof (prove)\nusing this:\n  accs_laz \\<delta> t q\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<subseteq>Q. q \\<in> s \\<and> accs_laz \\<delta>ss t s", "proof (induct \\<delta>\\<equiv>\\<delta> t q rule: accs_laz.induct[case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<exists>s\\<subseteq>Q.\n                 x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<subseteq>Q.\n                            q \\<in> s \\<and>\n                            accs_laz \\<delta>ss (NODE f ts) s", "case (step q f qs ts)"], ["proof (state)\nthis:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n  list_all_zip\n   (\\<lambda>x1 x2.\n       accs_laz \\<delta> x1 x2 \\<and>\n       (\\<exists>s\\<subseteq>Q. x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n   ts qs\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<exists>s\\<subseteq>Q.\n                 x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<subseteq>Q.\n                            q \\<in> s \\<and>\n                            accs_laz \\<delta>ss (NODE f ts) s", "hence I:\n        \"(q \\<rightarrow> f qs)\\<in>\\<delta>\"\n        \"list_all_zip (accs_laz \\<delta>) ts qs\"\n        \"list_all_zip (\\<lambda>t q. \\<exists>s. s\\<subseteq>Q \\<and> q\\<in>s \\<and> accs_laz \\<delta>ss t s) ts qs\""], ["proof (prove)\nusing this:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n  list_all_zip\n   (\\<lambda>x1 x2.\n       accs_laz \\<delta> x1 x2 \\<and>\n       (\\<exists>s\\<subseteq>Q. x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n   ts qs\n\ngoal (1 subgoal):\n 1. q \\<rightarrow> f qs \\<in> \\<delta> &&&\n    list_all_zip (accs_laz \\<delta>) ts qs &&&\n    list_all_zip\n     (\\<lambda>t q.\n         \\<exists>s\\<subseteq>Q. q \\<in> s \\<and> accs_laz \\<delta>ss t s)\n     ts qs", "by simp_all"], ["proof (state)\nthis:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n  list_all_zip (accs_laz \\<delta>) ts qs\n  list_all_zip\n   (\\<lambda>t q.\n       \\<exists>s\\<subseteq>Q. q \\<in> s \\<and> accs_laz \\<delta>ss t s)\n   ts qs\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<exists>s\\<subseteq>Q.\n                 x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<subseteq>Q.\n                            q \\<in> s \\<and>\n                            accs_laz \\<delta>ss (NODE f ts) s", "from I(3)"], ["proof (chain)\npicking this:\n  list_all_zip\n   (\\<lambda>t q.\n       \\<exists>s\\<subseteq>Q. q \\<in> s \\<and> accs_laz \\<delta>ss t s)\n   ts qs", "obtain ss where SS: \n        \"ss \\<in> lists {s. s\\<subseteq>Q}\"\n        \"list_all_zip (\\<in>) qs ss\"\n        \"list_all_zip (accs_laz \\<delta>ss) ts ss\""], ["proof (prove)\nusing this:\n  list_all_zip\n   (\\<lambda>t q.\n       \\<exists>s\\<subseteq>Q. q \\<in> s \\<and> accs_laz \\<delta>ss t s)\n   ts qs\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>ss \\<in> lists {s. s \\<subseteq> Q};\n         list_all_zip (\\<in>) qs ss;\n         list_all_zip (accs_laz \\<delta>ss) ts ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule_tac laz_swap_ex) auto"], ["proof (state)\nthis:\n  ss \\<in> lists {s. s \\<subseteq> Q}\n  list_all_zip (\\<in>) qs ss\n  list_all_zip (accs_laz \\<delta>ss) ts ss\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<exists>s\\<subseteq>Q.\n                 x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<subseteq>Q.\n                            q \\<in> s \\<and>\n                            accs_laz \\<delta>ss (NODE f ts) s", "from I(2) SS(2)"], ["proof (chain)\npicking this:\n  list_all_zip (accs_laz \\<delta>) ts qs\n  list_all_zip (\\<in>) qs ss", "have \n        LEN[simp]: \"length qs = length ts\" \"length ss = length ts\""], ["proof (prove)\nusing this:\n  list_all_zip (accs_laz \\<delta>) ts qs\n  list_all_zip (\\<in>) qs ss\n\ngoal (1 subgoal):\n 1. length qs = length ts &&& length ss = length ts", "by (auto simp add: list_all_zip_alt)"], ["proof (state)\nthis:\n  length qs = length ts\n  length ss = length ts\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<exists>s\\<subseteq>Q.\n                 x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<subseteq>Q.\n                            q \\<in> s \\<and>\n                            accs_laz \\<delta>ss (NODE f ts) s", "from ranked[OF I(1)]"], ["proof (chain)\npicking this:\n  A f = Some (length qs)", "have AF: \"A f = Some (length ts)\""], ["proof (prove)\nusing this:\n  A f = Some (length qs)\n\ngoal (1 subgoal):\n 1. A f = Some (length ts)", "by simp"], ["proof (state)\nthis:\n  A f = Some (length ts)\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<exists>s\\<subseteq>Q.\n                 x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<subseteq>Q.\n                            q \\<in> s \\<and>\n                            accs_laz \\<delta>ss (NODE f ts) s", "from \\<delta>ssI[of f ss, OF _ SS(1)] AF"], ["proof (chain)\npicking this:\n  A f = Some (length ss) \\<Longrightarrow>\n  \\<delta>ss_lhs f ss \\<rightarrow> f ss \\<in> \\<delta>ss\n  A f = Some (length ts)", "have \n        RULE_S: \"((\\<delta>ss_lhs f ss) \\<rightarrow> f ss) \\<in> \\<delta>ss\""], ["proof (prove)\nusing this:\n  A f = Some (length ss) \\<Longrightarrow>\n  \\<delta>ss_lhs f ss \\<rightarrow> f ss \\<in> \\<delta>ss\n  A f = Some (length ts)\n\ngoal (1 subgoal):\n 1. \\<delta>ss_lhs f ss \\<rightarrow> f ss \\<in> \\<delta>ss", "by simp"], ["proof (state)\nthis:\n  \\<delta>ss_lhs f ss \\<rightarrow> f ss \\<in> \\<delta>ss\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<exists>s\\<subseteq>Q.\n                 x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<subseteq>Q.\n                            q \\<in> s \\<and>\n                            accs_laz \\<delta>ss (NODE f ts) s", "from accs_laz.intros[OF RULE_S SS(3)]"], ["proof (chain)\npicking this:\n  accs_laz \\<delta>ss (NODE f ts) (\\<delta>ss_lhs f ss)", "have \n        G1: \"accs_laz \\<delta>ss (NODE f ts) (\\<delta>ss_lhs f ss)\""], ["proof (prove)\nusing this:\n  accs_laz \\<delta>ss (NODE f ts) (\\<delta>ss_lhs f ss)\n\ngoal (1 subgoal):\n 1. accs_laz \\<delta>ss (NODE f ts) (\\<delta>ss_lhs f ss)", "."], ["proof (state)\nthis:\n  accs_laz \\<delta>ss (NODE f ts) (\\<delta>ss_lhs f ss)\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<exists>s\\<subseteq>Q.\n                 x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<subseteq>Q.\n                            q \\<in> s \\<and>\n                            accs_laz \\<delta>ss (NODE f ts) s", "from I(1) SS(2)"], ["proof (chain)\npicking this:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n  list_all_zip (\\<in>) qs ss", "have \"q\\<in>(\\<delta>ss_lhs f ss)\""], ["proof (prove)\nusing this:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n  list_all_zip (\\<in>) qs ss\n\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>ss_lhs f ss", "by (auto simp add: \\<delta>ss_lhs_def)"], ["proof (state)\nthis:\n  q \\<in> \\<delta>ss_lhs f ss\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta> x1 x2 \\<and>\n             (\\<exists>s\\<subseteq>Q.\n                 x2 \\<in> s \\<and> accs_laz \\<delta>ss x1 s))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<subseteq>Q.\n                            q \\<in> s \\<and>\n                            accs_laz \\<delta>ss (NODE f ts) s", "thus ?case"], ["proof (prove)\nusing this:\n  q \\<in> \\<delta>ss_lhs f ss\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<subseteq>Q.\n       q \\<in> s \\<and> accs_laz \\<delta>ss (NODE f ts) s", "using G1"], ["proof (prove)\nusing this:\n  q \\<in> \\<delta>ss_lhs f ss\n  accs_laz \\<delta>ss (NODE f ts) (\\<delta>ss_lhs f ss)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<subseteq>Q.\n       q \\<in> s \\<and> accs_laz \\<delta>ss (NODE f ts) s", "by auto"], ["proof (state)\nthis:\n  \\<exists>s\\<subseteq>Q. q \\<in> s \\<and> accs_laz \\<delta>ss (NODE f ts) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s\\<subseteq>Q. q \\<in> s \\<and> accs_laz \\<delta>ss t s\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<subseteq> Q; q \\<in> s; accs \\<delta>ss t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s\\<subseteq>Q. q \\<in> s \\<and> accs_laz \\<delta>ss t s\n\ngoal (1 subgoal):\n 1. thesis", "apply (elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<subseteq> Q; q \\<in> s; accs_laz \\<delta>ss t s\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule_tac that)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<subseteq> Q; q \\<in> s; accs_laz \\<delta>ss t s\\<rbrakk>\n       \\<Longrightarrow> ?s5 s \\<subseteq> Q\n 2. \\<And>s.\n       \\<lbrakk>s \\<subseteq> Q; q \\<in> s; accs_laz \\<delta>ss t s\\<rbrakk>\n       \\<Longrightarrow> q \\<in> ?s5 s\n 3. \\<And>s.\n       \\<lbrakk>s \\<subseteq> Q; q \\<in> s; accs_laz \\<delta>ss t s\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>ss t (?s5 s)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<subseteq> Q; q \\<in> s; accs_laz \\<delta>ss t s\\<rbrakk>\n       \\<Longrightarrow> q \\<in> s\n 2. \\<And>s.\n       \\<lbrakk>s \\<subseteq> Q; q \\<in> s; accs_laz \\<delta>ss t s\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>ss t s", "apply (auto simp add: accs_laz)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<delta>ss_accs_precise:\n    assumes A: \"accs \\<delta>ss t s\" \"q\\<in>s\"  \n    shows \"accs \\<delta> t q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> t q", "using A"], ["proof (prove)\nusing this:\n  accs \\<delta>ss t s\n  q \\<in> s\n\ngoal (1 subgoal):\n 1. accs \\<delta> t q", "unfolding accs_laz"], ["proof (prove)\nusing this:\n  accs_laz \\<delta>ss t s\n  q \\<in> s\n\ngoal (1 subgoal):\n 1. accs_laz \\<delta> t q", "proof (induct \\<delta>\\<equiv>\\<delta>ss t s \n                arbitrary: q \n                rule: accs_laz.induct[case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q f qs ts qa.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>ss;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>ss x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<in> x2 \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs;\n        qa \\<in> q\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qa", "case (step s f ss ts)"], ["proof (state)\nthis:\n  s \\<rightarrow> f ss \\<in> \\<delta>ss\n  list_all_zip\n   (\\<lambda>x1 x2.\n       accs_laz \\<delta>ss x1 x2 \\<and>\n       (\\<forall>x. x \\<in> x2 \\<longrightarrow> accs_laz \\<delta> x1 x))\n   ts ss\n  q \\<in> s\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts qa.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>ss;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>ss x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<in> x2 \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs;\n        qa \\<in> q\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qa", "hence I:\n      \"(s \\<rightarrow> f ss) \\<in> \\<delta>ss\"\n      \"list_all_zip (accs_laz \\<delta>ss) ts ss\"\n      \"list_all_zip (\\<lambda>t s. \\<forall>q\\<in>s. accs_laz \\<delta> t q) ts ss\"\n      \"q\\<in>s\""], ["proof (prove)\nusing this:\n  s \\<rightarrow> f ss \\<in> \\<delta>ss\n  list_all_zip\n   (\\<lambda>x1 x2.\n       accs_laz \\<delta>ss x1 x2 \\<and>\n       (\\<forall>x. x \\<in> x2 \\<longrightarrow> accs_laz \\<delta> x1 x))\n   ts ss\n  q \\<in> s\n\ngoal (1 subgoal):\n 1. (s \\<rightarrow> f ss \\<in> \\<delta>ss &&&\n     list_all_zip (accs_laz \\<delta>ss) ts ss) &&&\n    list_all_zip (\\<lambda>t s. \\<forall>q\\<in>s. accs_laz \\<delta> t q) ts\n     ss &&&\n    q \\<in> s", "by (auto simp add: Ball_def)"], ["proof (state)\nthis:\n  s \\<rightarrow> f ss \\<in> \\<delta>ss\n  list_all_zip (accs_laz \\<delta>ss) ts ss\n  list_all_zip (\\<lambda>t s. \\<forall>q\\<in>s. accs_laz \\<delta> t q) ts ss\n  q \\<in> s\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts qa.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>ss;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>ss x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<in> x2 \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs;\n        qa \\<in> q\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qa", "from I(2)"], ["proof (chain)\npicking this:\n  list_all_zip (accs_laz \\<delta>ss) ts ss", "have [simp]: \"length ss = length ts\""], ["proof (prove)\nusing this:\n  list_all_zip (accs_laz \\<delta>ss) ts ss\n\ngoal (1 subgoal):\n 1. length ss = length ts", "by (simp add: list_all_zip_alt)"], ["proof (state)\nthis:\n  length ss = length ts\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts qa.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>ss;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>ss x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<in> x2 \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs;\n        qa \\<in> q\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qa", "from I(1)"], ["proof (chain)\npicking this:\n  s \\<rightarrow> f ss \\<in> \\<delta>ss", "have SS: \n      \"A f = Some (length ts)\"\n      \"ss \\<in> lists {s. s\\<subseteq>Q}\"\n      \"s=\\<delta>ss_lhs f ss\""], ["proof (prove)\nusing this:\n  s \\<rightarrow> f ss \\<in> \\<delta>ss\n\ngoal (1 subgoal):\n 1. A f = Some (length ts) &&&\n    ss \\<in> lists {s. s \\<subseteq> Q} &&& s = \\<delta>ss_lhs f ss", "by (force elim!: \\<delta>ss.cases)+"], ["proof (state)\nthis:\n  A f = Some (length ts)\n  ss \\<in> lists {s. s \\<subseteq> Q}\n  s = \\<delta>ss_lhs f ss\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts qa.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>ss;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>ss x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<in> x2 \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs;\n        qa \\<in> q\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qa", "from I(4) SS(3)"], ["proof (chain)\npicking this:\n  q \\<in> s\n  s = \\<delta>ss_lhs f ss", "obtain qs where\n      RULE: \"(q \\<rightarrow> f qs) \\<in> \\<delta>\" and\n      QSISS: \"list_all_zip (\\<in>) qs ss\""], ["proof (prove)\nusing this:\n  q \\<in> s\n  s = \\<delta>ss_lhs f ss\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>;\n         list_all_zip (\\<in>) qs ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: \\<delta>ss_lhs_def)"], ["proof (state)\nthis:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n  list_all_zip (\\<in>) qs ss\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts qa.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>ss;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>ss x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<in> x2 \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs;\n        qa \\<in> q\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qa", "from I(3) QSISS"], ["proof (chain)\npicking this:\n  list_all_zip (\\<lambda>t s. \\<forall>q\\<in>s. accs_laz \\<delta> t q) ts ss\n  list_all_zip (\\<in>) qs ss", "have CA: \"list_all_zip (accs_laz \\<delta>) ts qs\""], ["proof (prove)\nusing this:\n  list_all_zip (\\<lambda>t s. \\<forall>q\\<in>s. accs_laz \\<delta> t q) ts ss\n  list_all_zip (\\<in>) qs ss\n\ngoal (1 subgoal):\n 1. list_all_zip (accs_laz \\<delta>) ts qs", "by (auto simp add: list_all_zip_alt)"], ["proof (state)\nthis:\n  list_all_zip (accs_laz \\<delta>) ts qs\n\ngoal (1 subgoal):\n 1. \\<And>q f qs ts qa.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> \\<delta>ss;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>ss x1 x2 \\<and>\n             (\\<forall>x.\n                 x \\<in> x2 \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs;\n        qa \\<in> q\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qa", "from accs_laz.intros[OF RULE CA]"], ["proof (chain)\npicking this:\n  accs_laz \\<delta> (NODE f ts) q", "show ?case"], ["proof (prove)\nusing this:\n  accs_laz \\<delta> (NODE f ts) q\n\ngoal (1 subgoal):\n 1. accs_laz \\<delta> (NODE f ts) q", "."], ["proof (state)\nthis:\n  accs_laz \\<delta> (NODE f ts) q\n\ngoal:\nNo subgoals!", "qed\n    \n\n  \\<comment> \\<open>Determinization\\<close>"], ["", "definition \"detTA == \\<lparr> ta_initial = { s. s\\<subseteq>Q \\<and> s\\<inter>Qi \\<noteq> {} }, \n                         ta_rules = \\<delta>ss \\<rparr>\""], ["", "theorem detTA_is_ta[simp, intro]:\n    \"det_tree_automaton detTA A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_tree_automaton detTA A", "apply (unfold_locales)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (ta_rules detTA)\n 2. finite (ta_initial detTA)\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules detTA \\<Longrightarrow>\n       A f = Some (length qs)\n 4. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules detTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules detTA\\<rbrakk>\n       \\<Longrightarrow> q = q'", "apply (auto simp add: detTA_def elim: \\<delta>ss.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem detTA_lang[simp]:\n    \"ta_lang (detTA) = ta_lang TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang detTA = ta_lang TA", "apply (unfold ta_lang_def detTA_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. \\<exists>q\\<in>ta_initial\n                        \\<lparr>ta_initial =\n                                  {s. s \\<subseteq> Q \\<and>\ns \\<inter> Qi \\<noteq> {}},\n                           ta_rules = \\<delta>ss\\<rparr>.\n           accs\n            (ta_rules\n              \\<lparr>ta_initial =\n                        {s. s \\<subseteq> Q \\<and>\n                            s \\<inter> Qi \\<noteq> {}},\n                 ta_rules = \\<delta>ss\\<rparr>)\n            t q} =\n    {t. \\<exists>q\\<in>Qi. accs \\<delta> t q}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> ta_initial\n                         \\<lparr>ta_initial =\n                                   {s. s \\<subseteq> Q \\<and>\n s \\<inter> Qi \\<noteq> {}},\n                            ta_rules = \\<delta>ss\\<rparr>;\n        accs\n         (ta_rules\n           \\<lparr>ta_initial =\n                     {s. s \\<subseteq> Q \\<and> s \\<inter> Qi \\<noteq> {}},\n              ta_rules = \\<delta>ss\\<rparr>)\n         x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>Qi. accs \\<delta> x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>ta_initial\n   \\<lparr>ta_initial =\n             {s. s \\<subseteq> Q \\<and> s \\<inter> Qi \\<noteq> {}},\n      ta_rules = \\<delta>ss\\<rparr>.\n                            accs\n                             (ta_rules\n                               \\<lparr>ta_initial =\n   {s. s \\<subseteq> Q \\<and> s \\<inter> Qi \\<noteq> {}},\n                                  ta_rules = \\<delta>ss\\<rparr>)\n                             x q", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<subseteq> Q \\<and> q \\<inter> Qi \\<noteq> {};\n        accs \\<delta>ss x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>Qi. accs \\<delta> x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<subseteq> Q \\<and> q \\<inter> Qi \\<noteq> {};\n        accs \\<delta>ss x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>Qi. accs \\<delta> x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "fix t s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<subseteq> Q \\<and> q \\<inter> Qi \\<noteq> {};\n        accs \\<delta>ss x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>Qi. accs \\<delta> x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "assume A: \n      \"s\\<subseteq>Q \\<and> s\\<inter>Qi \\<noteq> {}\"\n      \"accs \\<delta>ss t s\""], ["proof (state)\nthis:\n  s \\<subseteq> Q \\<and> s \\<inter> Qi \\<noteq> {}\n  accs \\<delta>ss t s\n\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<subseteq> Q \\<and> q \\<inter> Qi \\<noteq> {};\n        accs \\<delta>ss x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>Qi. accs \\<delta> x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "from A(1)"], ["proof (chain)\npicking this:\n  s \\<subseteq> Q \\<and> s \\<inter> Qi \\<noteq> {}", "obtain qi where QI: \"qi\\<in>s\" \"qi\\<in>Qi\""], ["proof (prove)\nusing this:\n  s \\<subseteq> Q \\<and> s \\<inter> Qi \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>qi.\n        \\<lbrakk>qi \\<in> s; qi \\<in> Qi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qi \\<in> s\n  qi \\<in> Qi\n\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<subseteq> Q \\<and> q \\<inter> Qi \\<noteq> {};\n        accs \\<delta>ss x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>Qi. accs \\<delta> x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "from \\<delta>ss_accs_precise[OF A(2) QI(1)]"], ["proof (chain)\npicking this:\n  accs \\<delta> t qi", "have \"accs \\<delta> t qi\""], ["proof (prove)\nusing this:\n  accs \\<delta> t qi\n\ngoal (1 subgoal):\n 1. accs \\<delta> t qi", "."], ["proof (state)\nthis:\n  accs \\<delta> t qi\n\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<subseteq> Q \\<and> q \\<inter> Qi \\<noteq> {};\n        accs \\<delta>ss x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q\\<in>Qi. accs \\<delta> x q\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "with QI(2)"], ["proof (chain)\npicking this:\n  qi \\<in> Qi\n  accs \\<delta> t qi", "show \"\\<exists>qi\\<in>Qi. accs \\<delta> t qi\""], ["proof (prove)\nusing this:\n  qi \\<in> Qi\n  accs \\<delta> t qi\n\ngoal (1 subgoal):\n 1. \\<exists>qi\\<in>Qi. accs \\<delta> t qi", "by blast"], ["proof (state)\nthis:\n  \\<exists>qi\\<in>Qi. accs \\<delta> t qi\n\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "fix t qi"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "assume A: \n      \"qi\\<in>Qi\" \n      \"accs \\<delta> t qi\""], ["proof (state)\nthis:\n  qi \\<in> Qi\n  accs \\<delta> t qi\n\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "from \\<delta>ss_accs_sound[OF A(2)]"], ["proof (chain)\npicking this:\n  (\\<And>s.\n      \\<lbrakk>s \\<subseteq> Q; qi \\<in> s; accs \\<delta>ss t s\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain s where SS: \n      \"s\\<subseteq>Q\" \n      \"qi\\<in>s\" \n      \"accs \\<delta>ss t s\""], ["proof (prove)\nusing this:\n  (\\<And>s.\n      \\<lbrakk>s \\<subseteq> Q; qi \\<in> s; accs \\<delta>ss t s\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<subseteq> Q; qi \\<in> s; accs \\<delta>ss t s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  s \\<subseteq> Q\n  qi \\<in> s\n  accs \\<delta>ss t s\n\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> Qi; accs \\<delta> x q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<subseteq>Q.\n                            xa \\<inter> Qi \\<noteq> {} \\<and>\n                            accs \\<delta>ss x xa", "with A(1)"], ["proof (chain)\npicking this:\n  qi \\<in> Qi\n  s \\<subseteq> Q\n  qi \\<in> s\n  accs \\<delta>ss t s", "show \"\\<exists>s\\<subseteq>Q. s \\<inter> Qi \\<noteq> {} \\<and> accs \\<delta>ss t s\""], ["proof (prove)\nusing this:\n  qi \\<in> Qi\n  s \\<subseteq> Q\n  qi \\<in> s\n  accs \\<delta>ss t s\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<subseteq>Q.\n       s \\<inter> Qi \\<noteq> {} \\<and> accs \\<delta>ss t s", "by blast"], ["proof (state)\nthis:\n  \\<exists>s\\<subseteq>Q.\n     s \\<inter> Qi \\<noteq> {} \\<and> accs \\<delta>ss t s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas detTA_correct = detTA_is_ta detTA_lang"], ["", "end"], ["", "subsubsection \"Completion\""], ["", "text \\<open>\n  To each deterministic tree automaton, rules and states can be added to make\n  it complete, without changing its language.\n\\<close>"], ["", "context det_tree_automaton\nbegin\n  \\<comment> \\<open>States of the complete automaton\\<close>"], ["", "definition \"Qcomplete == insert None (Some`Q)\""], ["", "lemma Qcomplete_finite[simp, intro!]: \"finite Qcomplete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Qcomplete", "by (auto simp add: Qcomplete_def)\n\n  \\<comment> \\<open>Rules of the complete automaton\\<close>"], ["", "definition \\<delta>complete :: \"('Q option, 'L) ta_rule set\" where\n    \"\\<delta>complete == (remap_rule Some ` \\<delta>) \n                  \\<union> { (None \\<rightarrow> f qs) | f qs. \n                         A f = Some (length qs) \n                         \\<and> qs\\<in>lists Qcomplete \n                         \\<and> \\<not>(\\<exists>qo qso. (qo \\<rightarrow> f qso)\\<in>\\<delta> \\<and> qs=map Some qso ) }\""], ["", "lemma \\<delta>_states_complete: \"q\\<in>\\<delta>_states \\<delta>complete \\<Longrightarrow> q\\<in>Qcomplete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> \\<delta>_states \\<delta>complete \\<Longrightarrow>\n    q \\<in> Qcomplete", "apply (erule \\<delta>_statesE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f qs.\n       q \\<rightarrow> f qs \\<in> \\<delta>complete \\<Longrightarrow>\n       q \\<in> Qcomplete\n 2. \\<And>ql f qs.\n       \\<lbrakk>ql \\<rightarrow> f qs \\<in> \\<delta>complete;\n        q \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> q \\<in> Qcomplete", "apply (unfold \\<delta>complete_def Qcomplete_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f qs.\n       q \\<rightarrow> f qs\n       \\<in> remap_rule Some ` \\<delta> \\<union>\n             {None \\<rightarrow> f qs |f qs.\n              A f = Some (length qs) \\<and>\n              qs \\<in> lists (insert None (Some ` Q)) \\<and>\n              (\\<nexists>qo qso.\n                  qo \\<rightarrow> f qso \\<in> \\<delta> \\<and>\n                  qs = map Some qso)} \\<Longrightarrow>\n       q \\<in> insert None (Some ` Q)\n 2. \\<And>ql f qs.\n       \\<lbrakk>ql \\<rightarrow> f qs\n                \\<in> remap_rule Some ` \\<delta> \\<union>\n                      {None \\<rightarrow> f qs |f qs.\n                       A f = Some (length qs) \\<and>\n                       qs \\<in> lists (insert None (Some ` Q)) \\<and>\n                       (\\<nexists>qo qso.\n                           qo \\<rightarrow> f qso \\<in> \\<delta> \\<and>\n                           qs = map Some qso)};\n        q \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> q \\<in> insert None (Some ` Q)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f qs x.\n       \\<lbrakk>q \\<notin> Some ` Q;\n        q \\<rightarrow> f qs = remap_rule Some x; x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = None\n 2. \\<And>ql f qs x.\n       \\<lbrakk>q \\<in> set qs; q \\<notin> Some ` Q;\n        ql \\<rightarrow> f qs = remap_rule Some x; x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = None", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f qs x x1 x2 x3.\n       \\<lbrakk>q \\<notin> Some ` Q;\n        q \\<rightarrow> f qs = remap_rule Some x; x \\<in> \\<delta>;\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> q = None\n 2. \\<And>ql f qs x.\n       \\<lbrakk>q \\<in> set qs; q \\<notin> Some ` Q;\n        ql \\<rightarrow> f qs = remap_rule Some x; x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = None", "apply (auto simp add: ta_rstates_def intro: \\<delta>_statesI) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ql f qs x.\n       \\<lbrakk>q \\<in> set qs; q \\<notin> Some ` Q;\n        ql \\<rightarrow> f qs = remap_rule Some x; x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> q = None", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ql f qs x x1 x2 x3.\n       \\<lbrakk>q \\<in> set qs; q \\<notin> Some ` Q;\n        ql \\<rightarrow> f qs = remap_rule Some x; x \\<in> \\<delta>;\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> q = None", "apply (auto simp add: ta_rstates_def dest: \\<delta>_statesI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \n    \"completeTA == \\<lparr> ta_initial = Some`Qi, ta_rules = \\<delta>complete \\<rparr>\""], ["", "lemma \\<delta>complete_finite[simp, intro]: \"finite \\<delta>complete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta>complete", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite \\<delta>complete", "have \"\\<delta>complete \\<subseteq> legal_rules Qcomplete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>complete \\<subseteq> legal_rules Qcomplete", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       x \\<in> legal_rules Qcomplete", "apply (rule legal_rulesI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> \\<delta>complete \\<Longrightarrow> x \\<in> ?\\<delta>2 x\n 2. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       rule_states x \\<subseteq> Qcomplete\n 3. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       A (rhsl x) = Some (length (rhsq x))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       rule_states x \\<subseteq> Qcomplete\n 2. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       A (rhsl x) = Some (length (rhsq x))", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2 x3.\n       \\<lbrakk>x \\<in> \\<delta>complete;\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> rule_states x \\<subseteq> Qcomplete\n 2. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       A (rhsl x) = Some (length (rhsq x))", "apply (unfold \\<delta>complete_def Qcomplete_def ta_rstates_def) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2 x3.\n       \\<lbrakk>x \\<in> remap_rule Some ` \\<delta> \\<union>\n                        {None \\<rightarrow> f qs |f qs.\n                         A f = Some (length qs) \\<and>\n                         qs \\<in> lists\n                                   (insert None\n                                     (Some `\n(Qi \\<union> \\<delta>_states \\<delta>))) \\<and>\n                         (\\<nexists>qo qso.\n                             qo \\<rightarrow> f qso \\<in> \\<delta> \\<and>\n                             qs = map Some qso)};\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> rule_states x\n                         \\<subseteq> insert None\n(Some ` (Qi \\<union> \\<delta>_states \\<delta>))\n 2. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       A (rhsl x) = Some (length (rhsq x))", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 xa.\n       \\<lbrakk>x1 \\<rightarrow> x2 x3 = remap_rule Some xa;\n        xa \\<in> \\<delta>;\n        x1 \\<notin> Some ` (Qi \\<union> \\<delta>_states \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> x1 = None\n 2. \\<And>x1 x2 x3 xa xb.\n       \\<lbrakk>x1 \\<rightarrow> x2 x3 = remap_rule Some xa;\n        xa \\<in> \\<delta>; xb \\<in> set x3;\n        xb \\<notin> Some ` (Qi \\<union> \\<delta>_states \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> xb = None\n 3. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       A (rhsl x) = Some (length (rhsq x))", "apply (case_tac xa)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 xa x1a x2a x3a.\n       \\<lbrakk>x1 \\<rightarrow> x2 x3 = remap_rule Some xa;\n        xa \\<in> \\<delta>;\n        x1 \\<notin> Some ` (Qi \\<union> \\<delta>_states \\<delta>);\n        xa = x1a \\<rightarrow> x2a x3a\\<rbrakk>\n       \\<Longrightarrow> x1 = None\n 2. \\<And>x1 x2 x3 xa xb.\n       \\<lbrakk>x1 \\<rightarrow> x2 x3 = remap_rule Some xa;\n        xa \\<in> \\<delta>; xb \\<in> set x3;\n        xb \\<notin> Some ` (Qi \\<union> \\<delta>_states \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> xb = None\n 3. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       A (rhsl x) = Some (length (rhsq x))", "apply (auto dest: \\<delta>_statesI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 xa xb.\n       \\<lbrakk>x1 \\<rightarrow> x2 x3 = remap_rule Some xa;\n        xa \\<in> \\<delta>; xb \\<in> set x3;\n        xb \\<notin> Some ` (Qi \\<union> \\<delta>_states \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> xb = None\n 2. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       A (rhsl x) = Some (length (rhsq x))", "apply (case_tac xa)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 xa xb x1a x2a x3a.\n       \\<lbrakk>x1 \\<rightarrow> x2 x3 = remap_rule Some xa;\n        xa \\<in> \\<delta>; xb \\<in> set x3;\n        xb \\<notin> Some ` (Qi \\<union> \\<delta>_states \\<delta>);\n        xa = x1a \\<rightarrow> x2a x3a\\<rbrakk>\n       \\<Longrightarrow> xb = None\n 2. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       A (rhsl x) = Some (length (rhsq x))", "apply (auto dest: \\<delta>_statesI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<delta>complete \\<Longrightarrow>\n       A (rhsl x) = Some (length (rhsq x))", "apply (unfold \\<delta>complete_def Qcomplete_def ta_rstates_def) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> remap_rule Some ` \\<delta> \\<union>\n               {None \\<rightarrow> f qs |f qs.\n                A f = Some (length qs) \\<and>\n                qs \\<in> lists\n                          (insert None\n                            (Some `\n                             (Qi \\<union> \\<delta>_states \\<delta>))) \\<and>\n                (\\<nexists>qo qso.\n                    qo \\<rightarrow> f qso \\<in> \\<delta> \\<and>\n                    qs = map Some qso)} \\<Longrightarrow>\n       A (rhsl x) = Some (length (rhsq x))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<delta> \\<Longrightarrow>\n       A (rhsl (remap_rule Some xa)) =\n       Some (length (rhsq (remap_rule Some xa)))", "apply (case_tac xa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x1 x2 x3.\n       \\<lbrakk>xa \\<in> \\<delta>; xa = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> A (rhsl (remap_rule Some xa)) =\n                         Some (length (rhsq (remap_rule Some xa)))", "apply (auto intro: ranked)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<delta>complete \\<subseteq> legal_rules Qcomplete\n\ngoal (1 subgoal):\n 1. finite \\<delta>complete", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<delta>complete \\<subseteq> legal_rules Qcomplete\n\ngoal (1 subgoal):\n 1. finite \\<delta>complete", "by (auto intro: finite_subset)"], ["proof (state)\nthis:\n  finite \\<delta>complete\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem completeTA_is_ta: \"complete_tree_automaton completeTA A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_tree_automaton completeTA A", "proof (standard, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. finite (ta_rules completeTA)\n 2. finite (ta_initial completeTA)\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules completeTA \\<Longrightarrow>\n       A f = Some (length qs)\n 4. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 5. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. finite (ta_rules completeTA)\n 2. finite (ta_initial completeTA)\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules completeTA \\<Longrightarrow>\n       A f = Some (length qs)\n 4. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 5. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (ta_rules completeTA)", "by (simp add: completeTA_def)"], ["proof (state)\nthis:\n  finite (ta_rules completeTA)\n\ngoal (4 subgoals):\n 1. finite (ta_initial completeTA)\n 2. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules completeTA \\<Longrightarrow>\n       A f = Some (length qs)\n 3. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 4. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (ta_initial completeTA)\n 2. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules completeTA \\<Longrightarrow>\n       A f = Some (length qs)\n 3. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 4. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. finite (ta_initial completeTA)\n 2. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules completeTA \\<Longrightarrow>\n       A f = Some (length qs)\n 3. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 4. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (ta_initial completeTA)", "by (simp add: completeTA_def)"], ["proof (state)\nthis:\n  finite (ta_initial completeTA)\n\ngoal (3 subgoals):\n 1. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules completeTA \\<Longrightarrow>\n       A f = Some (length qs)\n 2. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 3. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules completeTA \\<Longrightarrow>\n       A f = Some (length qs)\n 2. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 3. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "case 3"], ["proof (state)\nthis:\n  q_ \\<rightarrow> f_ qs_ \\<in> ta_rules completeTA\n\ngoal (3 subgoals):\n 1. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules completeTA \\<Longrightarrow>\n       A f = Some (length qs)\n 2. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 3. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "thus ?case"], ["proof (prove)\nusing this:\n  q_ \\<rightarrow> f_ qs_ \\<in> ta_rules completeTA\n\ngoal (1 subgoal):\n 1. A f_ = Some (length qs_)", "apply (auto simp add: completeTA_def \\<delta>complete_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>q_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> A f_ = Some (length qs_)", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2 x3.\n       \\<lbrakk>q_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>; x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> A f_ = Some (length qs_)", "apply (auto intro: ranked)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  A f_ = Some (length qs_)\n\ngoal (2 subgoals):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 2. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 2. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "case 4"], ["proof (state)\nthis:\n  q_ \\<rightarrow> f_ qs_ \\<in> ta_rules completeTA\n  q'_ \\<rightarrow> f_ qs_ \\<in> ta_rules completeTA\n\ngoal (2 subgoals):\n 1. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules completeTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules completeTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 2. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "thus ?case"], ["proof (prove)\nusing this:\n  q_ \\<rightarrow> f_ qs_ \\<in> ta_rules completeTA\n  q'_ \\<rightarrow> f_ qs_ \\<in> ta_rules completeTA\n\ngoal (1 subgoal):\n 1. q_ = q'_", "apply (auto simp add: completeTA_def \\<delta>complete_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>q_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>; q'_ \\<rightarrow> f_ qs_ = remap_rule Some xa;\n        xa \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> q_ = q'_\n 2. \\<And>x.\n       \\<lbrakk>q_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>; q'_ = None; A f_ = Some (length qs_);\n        \\<forall>qo qso.\n           qo \\<rightarrow> f_ qso \\<in> \\<delta> \\<longrightarrow>\n           qs_ \\<noteq> map Some qso;\n        \\<forall>x\\<in>set qs_. x \\<in> Qcomplete\\<rbrakk>\n       \\<Longrightarrow> q_ = None\n 3. \\<And>x.\n       \\<lbrakk>q_ = None; A f_ = Some (length qs_);\n        \\<forall>qo qso.\n           qo \\<rightarrow> f_ qso \\<in> \\<delta> \\<longrightarrow>\n           qs_ \\<noteq> map Some qso;\n        \\<forall>x\\<in>set qs_. x \\<in> Qcomplete;\n        q'_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> None = q'_", "apply (case_tac x, case_tac xa)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>q_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>; q'_ \\<rightarrow> f_ qs_ = remap_rule Some xa;\n        xa \\<in> \\<delta>; x = x1 \\<rightarrow> x2 x3;\n        xa = x1a \\<rightarrow> x2a x3a\\<rbrakk>\n       \\<Longrightarrow> q_ = q'_\n 2. \\<And>x.\n       \\<lbrakk>q_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>; q'_ = None; A f_ = Some (length qs_);\n        \\<forall>qo qso.\n           qo \\<rightarrow> f_ qso \\<in> \\<delta> \\<longrightarrow>\n           qs_ \\<noteq> map Some qso;\n        \\<forall>x\\<in>set qs_. x \\<in> Qcomplete\\<rbrakk>\n       \\<Longrightarrow> q_ = None\n 3. \\<And>x.\n       \\<lbrakk>q_ = None; A f_ = Some (length qs_);\n        \\<forall>qo qso.\n           qo \\<rightarrow> f_ qso \\<in> \\<delta> \\<longrightarrow>\n           qs_ \\<noteq> map Some qso;\n        \\<forall>x\\<in>set qs_. x \\<in> Qcomplete;\n        q'_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> None = q'_", "apply (auto intro: deterministic) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>q_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>; q'_ = None; A f_ = Some (length qs_);\n        \\<forall>qo qso.\n           qo \\<rightarrow> f_ qso \\<in> \\<delta> \\<longrightarrow>\n           qs_ \\<noteq> map Some qso;\n        \\<forall>x\\<in>set qs_. x \\<in> Qcomplete\\<rbrakk>\n       \\<Longrightarrow> q_ = None\n 2. \\<And>x.\n       \\<lbrakk>q_ = None; A f_ = Some (length qs_);\n        \\<forall>qo qso.\n           qo \\<rightarrow> f_ qso \\<in> \\<delta> \\<longrightarrow>\n           qs_ \\<noteq> map Some qso;\n        \\<forall>x\\<in>set qs_. x \\<in> Qcomplete;\n        q'_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> None = q'_", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2 x3.\n       \\<lbrakk>q_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>; q'_ = None; A f_ = Some (length qs_);\n        \\<forall>qo qso.\n           qo \\<rightarrow> f_ qso \\<in> \\<delta> \\<longrightarrow>\n           qs_ \\<noteq> map Some qso;\n        \\<forall>x\\<in>set qs_. x \\<in> Qcomplete;\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> q_ = None\n 2. \\<And>x.\n       \\<lbrakk>q_ = None; A f_ = Some (length qs_);\n        \\<forall>qo qso.\n           qo \\<rightarrow> f_ qso \\<in> \\<delta> \\<longrightarrow>\n           qs_ \\<noteq> map Some qso;\n        \\<forall>x\\<in>set qs_. x \\<in> Qcomplete;\n        q'_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> None = q'_", "apply auto [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>q_ = None; A f_ = Some (length qs_);\n        \\<forall>qo qso.\n           qo \\<rightarrow> f_ qso \\<in> \\<delta> \\<longrightarrow>\n           qs_ \\<noteq> map Some qso;\n        \\<forall>x\\<in>set qs_. x \\<in> Qcomplete;\n        q'_ \\<rightarrow> f_ qs_ = remap_rule Some x;\n        x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> None = q'_", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2 x3.\n       \\<lbrakk>q_ = None; A f_ = Some (length qs_);\n        \\<forall>qo qso.\n           qo \\<rightarrow> f_ qso \\<in> \\<delta> \\<longrightarrow>\n           qs_ \\<noteq> map Some qso;\n        \\<forall>x\\<in>set qs_. x \\<in> Qcomplete;\n        q'_ \\<rightarrow> f_ qs_ = remap_rule Some x; x \\<in> \\<delta>;\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> None = q'_", "apply auto [1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  q_ = q'_\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "case prems: (5 qs f)"], ["proof (state)\nthis:\n  qs \\<in> lists (ta_rstates completeTA)\n  A f = Some (length qs)\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "{"], ["proof (state)\nthis:\n  qs \\<in> lists (ta_rstates completeTA)\n  A f = Some (length qs)\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "fix qo qso"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "assume R: \"(qo \\<rightarrow> f qso)\\<in>\\<delta>\" and [simp]: \"qs=map Some qso\""], ["proof (state)\nthis:\n  qo \\<rightarrow> f qso \\<in> \\<delta>\n  qs = map Some qso\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "hence \"((Some qo) \\<rightarrow> f qs) \\<in> remap_rule Some ` \\<delta>\""], ["proof (prove)\nusing this:\n  qo \\<rightarrow> f qso \\<in> \\<delta>\n  qs = map Some qso\n\ngoal (1 subgoal):\n 1. Some qo \\<rightarrow> f qs \\<in> remap_rule Some ` \\<delta>", "by force"], ["proof (state)\nthis:\n  Some qo \\<rightarrow> f qs \\<in> remap_rule Some ` \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "hence ?case"], ["proof (prove)\nusing this:\n  Some qo \\<rightarrow> f qs \\<in> remap_rule Some ` \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<rightarrow> f qs \\<in> ta_rules completeTA", "by (simp add: completeTA_def \\<delta>complete_def) blast"], ["proof (state)\nthis:\n  \\<exists>q. q \\<rightarrow> f qs \\<in> ta_rules completeTA\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?qo3 \\<rightarrow> f ?qso3 \\<in> \\<delta>;\n   qs = map Some ?qso3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       q \\<rightarrow> f qs \\<in> ta_rules completeTA\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?qo3 \\<rightarrow> f ?qso3 \\<in> \\<delta>;\n   qs = map Some ?qso3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       q \\<rightarrow> f qs \\<in> ta_rules completeTA\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?qo3 \\<rightarrow> f ?qso3 \\<in> \\<delta>;\n   qs = map Some ?qso3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       q \\<rightarrow> f qs \\<in> ta_rules completeTA\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "assume A: \"\\<not>(\\<exists>qo qso. (qo \\<rightarrow> f qso)\\<in>\\<delta> \\<and> qs=map Some qso)\""], ["proof (state)\nthis:\n  \\<nexists>qo qso.\n     qo \\<rightarrow> f qso \\<in> \\<delta> \\<and> qs = map Some qso\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "have \"(Some ` Qi \\<union> \\<delta>_states \\<delta>complete) \\<subseteq> Qcomplete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some ` Qi \\<union> \\<delta>_states \\<delta>complete\n    \\<subseteq> Qcomplete", "apply (auto intro: \\<delta>_states_complete)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> Qi \\<Longrightarrow> Some xa \\<in> Qcomplete", "apply (simp add: Qcomplete_def ta_rstates_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Some ` Qi \\<union> \\<delta>_states \\<delta>complete \\<subseteq> Qcomplete\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "with prems"], ["proof (chain)\npicking this:\n  qs \\<in> lists (ta_rstates completeTA)\n  A f = Some (length qs)\n  Some ` Qi \\<union> \\<delta>_states \\<delta>complete \\<subseteq> Qcomplete", "have B: \"qs\\<in>lists Qcomplete\""], ["proof (prove)\nusing this:\n  qs \\<in> lists (ta_rstates completeTA)\n  A f = Some (length qs)\n  Some ` Qi \\<union> \\<delta>_states \\<delta>complete \\<subseteq> Qcomplete\n\ngoal (1 subgoal):\n 1. qs \\<in> lists Qcomplete", "by (auto simp add: completeTA_def ta_rstates_def)"], ["proof (state)\nthis:\n  qs \\<in> lists Qcomplete\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "from A B prems(2)"], ["proof (chain)\npicking this:\n  \\<nexists>qo qso.\n     qo \\<rightarrow> f qso \\<in> \\<delta> \\<and> qs = map Some qso\n  qs \\<in> lists Qcomplete\n  A f = Some (length qs)", "have ?case"], ["proof (prove)\nusing this:\n  \\<nexists>qo qso.\n     qo \\<rightarrow> f qso \\<in> \\<delta> \\<and> qs = map Some qso\n  qs \\<in> lists Qcomplete\n  A f = Some (length qs)\n\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<rightarrow> f qs \\<in> ta_rules completeTA", "apply (rule_tac x=None in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nexists>qo qso.\n                qo \\<rightarrow> f qso \\<in> \\<delta> \\<and>\n                qs = map Some qso;\n     qs \\<in> lists Qcomplete; A f = Some (length qs)\\<rbrakk>\n    \\<Longrightarrow> None \\<rightarrow> f qs \\<in> ta_rules completeTA", "apply (simp add: completeTA_def \\<delta>complete_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>q. q \\<rightarrow> f qs \\<in> ta_rules completeTA\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "}"], ["proof (state)\nthis:\n  \\<nexists>qo qso.\n     qo \\<rightarrow> f qso \\<in> \\<delta> \\<and>\n     qs = map Some qso \\<Longrightarrow>\n  \\<exists>q. q \\<rightarrow> f qs \\<in> ta_rules completeTA\n\ngoal (1 subgoal):\n 1. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates completeTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules completeTA", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?qo3 \\<rightarrow> f ?qso3 \\<in> \\<delta>;\n   qs = map Some ?qso3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       q \\<rightarrow> f qs \\<in> ta_rules completeTA\n  \\<nexists>qo qso.\n     qo \\<rightarrow> f qso \\<in> \\<delta> \\<and>\n     qs = map Some qso \\<Longrightarrow>\n  \\<exists>q. q \\<rightarrow> f qs \\<in> ta_rules completeTA", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?qo3 \\<rightarrow> f ?qso3 \\<in> \\<delta>;\n   qs = map Some ?qso3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q.\n                       q \\<rightarrow> f qs \\<in> ta_rules completeTA\n  \\<nexists>qo qso.\n     qo \\<rightarrow> f qso \\<in> \\<delta> \\<and>\n     qs = map Some qso \\<Longrightarrow>\n  \\<exists>q. q \\<rightarrow> f qs \\<in> ta_rules completeTA\n\ngoal (1 subgoal):\n 1. \\<exists>q. q \\<rightarrow> f qs \\<in> ta_rules completeTA", "by blast"], ["proof (state)\nthis:\n  \\<exists>q. q \\<rightarrow> f qs \\<in> ta_rules completeTA\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem completeTA_lang: \"ta_lang completeTA = ta_lang TA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang completeTA = ta_lang TA", "proof (intro equalityI subsetI)\n    \\<comment> \\<open>This direction is done by a monotonicity argument\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x. x \\<in> ta_lang TA \\<Longrightarrow> x \\<in> ta_lang completeTA", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x. x \\<in> ta_lang TA \\<Longrightarrow> x \\<in> ta_lang completeTA", "assume \"t\\<in>ta_lang TA\""], ["proof (state)\nthis:\n  t \\<in> ta_lang TA\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x. x \\<in> ta_lang TA \\<Longrightarrow> x \\<in> ta_lang completeTA", "then"], ["proof (chain)\npicking this:\n  t \\<in> ta_lang TA", "obtain qi where \"qi\\<in>Qi\" \"accs \\<delta> t qi\""], ["proof (prove)\nusing this:\n  t \\<in> ta_lang TA\n\ngoal (1 subgoal):\n 1. (\\<And>qi.\n        \\<lbrakk>qi \\<in> Qi; accs \\<delta> t qi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: ta_lang_def)"], ["proof (state)\nthis:\n  qi \\<in> Qi\n  accs \\<delta> t qi\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x. x \\<in> ta_lang TA \\<Longrightarrow> x \\<in> ta_lang completeTA", "hence \n      QI: \"Some qi \\<in> Some`Qi\" and\n      ACCS: \"accs (remap_rule Some`\\<delta>) t (Some qi)\""], ["proof (prove)\nusing this:\n  qi \\<in> Qi\n  accs \\<delta> t qi\n\ngoal (1 subgoal):\n 1. Some qi \\<in> Some ` Qi &&&\n    accs (remap_rule Some ` \\<delta>) t (Some qi)", "by (auto intro: remap_accs1)"], ["proof (state)\nthis:\n  Some qi \\<in> Some ` Qi\n  accs (remap_rule Some ` \\<delta>) t (Some qi)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x. x \\<in> ta_lang TA \\<Longrightarrow> x \\<in> ta_lang completeTA", "have \"(remap_rule Some`\\<delta>) \\<subseteq> \\<delta>complete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remap_rule Some ` \\<delta> \\<subseteq> \\<delta>complete", "by (unfold \\<delta>complete_def) auto"], ["proof (state)\nthis:\n  remap_rule Some ` \\<delta> \\<subseteq> \\<delta>complete\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x. x \\<in> ta_lang TA \\<Longrightarrow> x \\<in> ta_lang completeTA", "with ACCS"], ["proof (chain)\npicking this:\n  accs (remap_rule Some ` \\<delta>) t (Some qi)\n  remap_rule Some ` \\<delta> \\<subseteq> \\<delta>complete", "have \"accs \\<delta>complete t (Some qi)\""], ["proof (prove)\nusing this:\n  accs (remap_rule Some ` \\<delta>) t (Some qi)\n  remap_rule Some ` \\<delta> \\<subseteq> \\<delta>complete\n\ngoal (1 subgoal):\n 1. accs \\<delta>complete t (Some qi)", "by (blast dest: accs_mono)"], ["proof (state)\nthis:\n  accs \\<delta>complete t (Some qi)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA\n 2. \\<And>x. x \\<in> ta_lang TA \\<Longrightarrow> x \\<in> ta_lang completeTA", "thus \"t\\<in>ta_lang completeTA\""], ["proof (prove)\nusing this:\n  accs \\<delta>complete t (Some qi)\n\ngoal (1 subgoal):\n 1. t \\<in> ta_lang completeTA", "using QI"], ["proof (prove)\nusing this:\n  accs \\<delta>complete t (Some qi)\n  Some qi \\<in> Some ` Qi\n\ngoal (1 subgoal):\n 1. t \\<in> ta_lang completeTA", "by (auto simp add: ta_lang_def completeTA_def)"], ["proof (state)\nthis:\n  t \\<in> ta_lang completeTA\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "assume A: \"t\\<in>ta_lang completeTA\""], ["proof (state)\nthis:\n  t \\<in> ta_lang completeTA\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "then"], ["proof (chain)\npicking this:\n  t \\<in> ta_lang completeTA", "obtain qi where \n      QI: \"qi\\<in>Qi\" and\n      ACCS: \"accs \\<delta>complete t (Some qi)\""], ["proof (prove)\nusing this:\n  t \\<in> ta_lang completeTA\n\ngoal (1 subgoal):\n 1. (\\<And>qi.\n        \\<lbrakk>qi \\<in> Qi; accs \\<delta>complete t (Some qi)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: ta_lang_def completeTA_def)"], ["proof (state)\nthis:\n  qi \\<in> Qi\n  accs \\<delta>complete t (Some qi)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "moreover"], ["proof (state)\nthis:\n  qi \\<in> Qi\n  accs \\<delta>complete t (Some qi)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "{"], ["proof (state)\nthis:\n  qi \\<in> Qi\n  accs \\<delta>complete t (Some qi)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "fix qi"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "have \"\\<lbrakk> accs \\<delta>complete t (Some qi) \\<rbrakk> \\<Longrightarrow> accs \\<delta> t qi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta>complete t (Some qi) \\<Longrightarrow> accs \\<delta> t qi", "unfolding accs_laz"], ["proof (prove)\ngoal (1 subgoal):\n 1. accs_laz \\<delta>complete t (Some qi) \\<Longrightarrow>\n    accs_laz \\<delta> t qi", "proof (induct \\<delta>\\<equiv>\\<delta>complete t q\\<equiv>\"Some qi\"\n                    arbitrary: qi\n                    rule: accs_laz.induct[case_names step])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f qs ts qi.\n       \\<lbrakk>Some qi \\<rightarrow> f qs \\<in> \\<delta>complete;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>complete x1 x2 \\<and>\n             (\\<forall>x.\n                 x2 = Some x \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qi", "case (step f qs ts qi)"], ["proof (state)\nthis:\n  Some qi \\<rightarrow> f qs \\<in> \\<delta>complete\n  list_all_zip\n   (\\<lambda>x1 x2.\n       accs_laz \\<delta>complete x1 x2 \\<and>\n       (\\<forall>x. x2 = Some x \\<longrightarrow> accs_laz \\<delta> x1 x))\n   ts qs\n\ngoal (1 subgoal):\n 1. \\<And>f qs ts qi.\n       \\<lbrakk>Some qi \\<rightarrow> f qs \\<in> \\<delta>complete;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>complete x1 x2 \\<and>\n             (\\<forall>x.\n                 x2 = Some x \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qi", "hence I:\n          \"((Some qi) \\<rightarrow> f qs) \\<in> \\<delta>complete\"\n          \"list_all_zip (accs_laz \\<delta>complete) ts qs\"\n          \"list_all_zip (\\<lambda>t q. (\\<forall>qo. q=Some qo \\<longrightarrow> accs_laz \\<delta> t qo)) ts qs\""], ["proof (prove)\nusing this:\n  Some qi \\<rightarrow> f qs \\<in> \\<delta>complete\n  list_all_zip\n   (\\<lambda>x1 x2.\n       accs_laz \\<delta>complete x1 x2 \\<and>\n       (\\<forall>x. x2 = Some x \\<longrightarrow> accs_laz \\<delta> x1 x))\n   ts qs\n\ngoal (1 subgoal):\n 1. Some qi \\<rightarrow> f qs \\<in> \\<delta>complete &&&\n    list_all_zip (accs_laz \\<delta>complete) ts qs &&&\n    list_all_zip\n     (\\<lambda>t q.\n         \\<forall>qo. q = Some qo \\<longrightarrow> accs_laz \\<delta> t qo)\n     ts qs", "by auto"], ["proof (state)\nthis:\n  Some qi \\<rightarrow> f qs \\<in> \\<delta>complete\n  list_all_zip (accs_laz \\<delta>complete) ts qs\n  list_all_zip\n   (\\<lambda>t q.\n       \\<forall>qo. q = Some qo \\<longrightarrow> accs_laz \\<delta> t qo)\n   ts qs\n\ngoal (1 subgoal):\n 1. \\<And>f qs ts qi.\n       \\<lbrakk>Some qi \\<rightarrow> f qs \\<in> \\<delta>complete;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>complete x1 x2 \\<and>\n             (\\<forall>x.\n                 x2 = Some x \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qi", "from I(1)"], ["proof (chain)\npicking this:\n  Some qi \\<rightarrow> f qs \\<in> \\<delta>complete", "have \"((Some qi) \\<rightarrow> f qs) \\<in> remap_rule Some`\\<delta>\""], ["proof (prove)\nusing this:\n  Some qi \\<rightarrow> f qs \\<in> \\<delta>complete\n\ngoal (1 subgoal):\n 1. Some qi \\<rightarrow> f qs \\<in> remap_rule Some ` \\<delta>", "by (unfold \\<delta>complete_def) auto"], ["proof (state)\nthis:\n  Some qi \\<rightarrow> f qs \\<in> remap_rule Some ` \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>f qs ts qi.\n       \\<lbrakk>Some qi \\<rightarrow> f qs \\<in> \\<delta>complete;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>complete x1 x2 \\<and>\n             (\\<forall>x.\n                 x2 = Some x \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qi", "then"], ["proof (chain)\npicking this:\n  Some qi \\<rightarrow> f qs \\<in> remap_rule Some ` \\<delta>", "obtain qso where \n          RULE: \"(qi \\<rightarrow> f qso)\\<in>\\<delta>\" and\n          QSF: \"qs=map Some qso\""], ["proof (prove)\nusing this:\n  Some qi \\<rightarrow> f qs \\<in> remap_rule Some ` \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<And>qso.\n        \\<lbrakk>qi \\<rightarrow> f qso \\<in> \\<delta>;\n         qs = map Some qso\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>qso.\n                   \\<lbrakk>qi \\<rightarrow> f qso \\<in> \\<delta>;\n                    qs = map Some qso\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Some qi \\<rightarrow> f qs = remap_rule Some x;\n        x \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2 x3.\n       \\<lbrakk>\\<And>qso.\n                   \\<lbrakk>qi \\<rightarrow> f qso \\<in> \\<delta>;\n                    qs = map Some qso\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Some qi \\<rightarrow> f qs = remap_rule Some x; x \\<in> \\<delta>;\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  qi \\<rightarrow> f qso \\<in> \\<delta>\n  qs = map Some qso\n\ngoal (1 subgoal):\n 1. \\<And>f qs ts qi.\n       \\<lbrakk>Some qi \\<rightarrow> f qs \\<in> \\<delta>complete;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>complete x1 x2 \\<and>\n             (\\<forall>x.\n                 x2 = Some x \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qi", "from I(3) QSF"], ["proof (chain)\npicking this:\n  list_all_zip\n   (\\<lambda>t q.\n       \\<forall>qo. q = Some qo \\<longrightarrow> accs_laz \\<delta> t qo)\n   ts qs\n  qs = map Some qso", "have ACCS: \"list_all_zip (accs_laz \\<delta>) ts qso\""], ["proof (prove)\nusing this:\n  list_all_zip\n   (\\<lambda>t q.\n       \\<forall>qo. q = Some qo \\<longrightarrow> accs_laz \\<delta> t qo)\n   ts qs\n  qs = map Some qso\n\ngoal (1 subgoal):\n 1. list_all_zip (accs_laz \\<delta>) ts qso", "by (auto simp add: list_all_zip_alt)"], ["proof (state)\nthis:\n  list_all_zip (accs_laz \\<delta>) ts qso\n\ngoal (1 subgoal):\n 1. \\<And>f qs ts qi.\n       \\<lbrakk>Some qi \\<rightarrow> f qs \\<in> \\<delta>complete;\n        list_all_zip\n         (\\<lambda>x1 x2.\n             accs_laz \\<delta>complete x1 x2 \\<and>\n             (\\<forall>x.\n                 x2 = Some x \\<longrightarrow> accs_laz \\<delta> x1 x))\n         ts qs\\<rbrakk>\n       \\<Longrightarrow> accs_laz \\<delta> (NODE f ts) qi", "from accs_laz.intros[OF RULE ACCS]"], ["proof (chain)\npicking this:\n  accs_laz \\<delta> (NODE f ts) qi", "show ?case"], ["proof (prove)\nusing this:\n  accs_laz \\<delta> (NODE f ts) qi\n\ngoal (1 subgoal):\n 1. accs_laz \\<delta> (NODE f ts) qi", "."], ["proof (state)\nthis:\n  accs_laz \\<delta> (NODE f ts) qi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  accs \\<delta>complete t (Some qi) \\<Longrightarrow> accs \\<delta> t qi\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "}"], ["proof (state)\nthis:\n  accs \\<delta>complete t (Some ?qia3) \\<Longrightarrow>\n  accs \\<delta> t ?qia3\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "ultimately"], ["proof (chain)\npicking this:\n  qi \\<in> Qi\n  accs \\<delta>complete t (Some qi)\n  accs \\<delta>complete t (Some ?qia3) \\<Longrightarrow>\n  accs \\<delta> t ?qia3", "have \"accs \\<delta> t qi\""], ["proof (prove)\nusing this:\n  qi \\<in> Qi\n  accs \\<delta>complete t (Some qi)\n  accs \\<delta>complete t (Some ?qia3) \\<Longrightarrow>\n  accs \\<delta> t ?qia3\n\ngoal (1 subgoal):\n 1. accs \\<delta> t qi", "by blast"], ["proof (state)\nthis:\n  accs \\<delta> t qi\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> ta_lang completeTA \\<Longrightarrow> x \\<in> ta_lang TA", "thus \"t\\<in>ta_lang TA\""], ["proof (prove)\nusing this:\n  accs \\<delta> t qi\n\ngoal (1 subgoal):\n 1. t \\<in> ta_lang TA", "using QI"], ["proof (prove)\nusing this:\n  accs \\<delta> t qi\n  qi \\<in> Qi\n\ngoal (1 subgoal):\n 1. t \\<in> ta_lang TA", "by (auto simp add: ta_lang_def)"], ["proof (state)\nthis:\n  t \\<in> ta_lang TA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas completeTA_correct = completeTA_is_ta completeTA_lang"], ["", "end"], ["", "subsubsection \"Complement\""], ["", "text \\<open>\n  A deterministic, complete tree automaton can be transformed into an automaton\n  accepting the complement language by complementing its initial states.\n\\<close>"], ["", "context complete_tree_automaton\nbegin\n\n    \\<comment> \\<open>Complement automaton, i.e. that accepts exactly the \n        trees not accepted by this automaton\\<close>"], ["", "definition \"complementTA == \\<lparr>\n    ta_initial = Q - Qi,\n    ta_rules = \\<delta> \\<rparr>\""], ["", "lemma cta_rules[simp]: \"ta_rules complementTA = \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_rules complementTA = \\<delta>", "by (auto simp add: complementTA_def)"], ["", "theorem complementTA_correct:\n    \"ta_lang complementTA = ranked_trees A - ta_lang TA\" (is ?T1)\n    \"complete_tree_automaton complementTA A\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang complementTA = ranked_trees A - ta_lang TA &&&\n    complete_tree_automaton complementTA A", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ta_lang complementTA = ranked_trees A - ta_lang TA\n 2. complete_tree_automaton complementTA A", "show ?T1"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang complementTA = ranked_trees A - ta_lang TA", "apply (unfold ta_lang_def complementTA_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. \\<exists>q\\<in>ta_initial\n                        \\<lparr>ta_initial = Q - Qi,\n                           ta_rules = \\<delta>\\<rparr>.\n           accs\n            (ta_rules\n              \\<lparr>ta_initial = Q - Qi, ta_rules = \\<delta>\\<rparr>)\n            t q} =\n    ranked_trees A - {t. \\<exists>q\\<in>Qi. accs \\<delta> t q}", "apply (force intro: accs_is_ranked dest: accs_unique label_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ta_lang complementTA = ranked_trees A - ta_lang TA\n\ngoal (1 subgoal):\n 1. complete_tree_automaton complementTA A", "have QSS: \"!!q. q\\<in>ta_rstates complementTA \\<Longrightarrow> q\\<in>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q. q \\<in> ta_rstates complementTA \\<Longrightarrow> q \\<in> Q", "by (auto simp add: complementTA_def ta_rstates_def)"], ["proof (state)\nthis:\n  ?q1 \\<in> ta_rstates complementTA \\<Longrightarrow> ?q1 \\<in> Q\n\ngoal (1 subgoal):\n 1. complete_tree_automaton complementTA A", "show ?T2"], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_tree_automaton complementTA A", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite (ta_rules complementTA)\n 2. finite (ta_initial complementTA)\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs \\<in> ta_rules complementTA \\<Longrightarrow>\n       A f = Some (length qs)\n 4. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs \\<in> ta_rules complementTA;\n        q' \\<rightarrow> f qs \\<in> ta_rules complementTA\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 5. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates complementTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules complementTA", "apply (unfold complementTA_def)[4]"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite\n     (ta_rules \\<lparr>ta_initial = Q - Qi, ta_rules = \\<delta>\\<rparr>)\n 2. finite\n     (ta_initial \\<lparr>ta_initial = Q - Qi, ta_rules = \\<delta>\\<rparr>)\n 3. \\<And>q f qs.\n       q \\<rightarrow> f qs\n       \\<in> ta_rules\n              \\<lparr>ta_initial = Q - Qi,\n                 ta_rules = \\<delta>\\<rparr> \\<Longrightarrow>\n       A f = Some (length qs)\n 4. \\<And>q f qs q'.\n       \\<lbrakk>q \\<rightarrow> f qs\n                \\<in> ta_rules\n                       \\<lparr>ta_initial = Q - Qi,\n                          ta_rules = \\<delta>\\<rparr>;\n        q' \\<rightarrow> f qs\n        \\<in> ta_rules\n               \\<lparr>ta_initial = Q - Qi,\n                  ta_rules = \\<delta>\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> q = q'\n 5. \\<And>qs f.\n       \\<lbrakk>qs \\<in> lists (ta_rstates complementTA);\n        A f = Some (length qs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            q \\<rightarrow> f qs \\<in> ta_rules complementTA", "apply (auto simp add: deterministic ranked \n                  intro: complete QSS)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  complete_tree_automaton complementTA A\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \"Regular Tree Languages\""], ["", "subsubsection \"Definitions\"\n\n  \\<comment> \\<open>Regular languages over alphabet @{text A}\\<close>"], ["", "definition regular_languages :: \"('L \\<rightharpoonup> nat) \\<Rightarrow> 'L tree set set\" \n  where \"regular_languages A == \n    { ta_lang TA | (TA::(nat,'L) tree_automaton_rec). \n                          ranked_tree_automaton TA A }\""], ["", "lemma rtlE:\n  fixes L :: \"'L tree set\"\n  assumes A: \"L\\<in>regular_languages A\"\n  obtains TA::\"(nat,'L) tree_automaton_rec\" where \n    \"L=ta_lang TA\"\n    \"ranked_tree_automaton TA A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; ranked_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using A that"], ["proof (prove)\nusing this:\n  L \\<in> regular_languages A\n  \\<lbrakk>L = ta_lang ?TA; ranked_tree_automaton ?TA A\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; ranked_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold regular_languages_def) blast"], ["", "context ranked_tree_automaton\nbegin"], ["", "lemma (in ranked_tree_automaton) rtlI[simp]:\n    shows \"ta_lang TA \\<in> regular_languages A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang TA \\<in> regular_languages A", "proof -\n    \\<comment> \\<open>Obtain injective mapping from the finite set of states to the \n        natural numbers\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. ta_lang TA \\<in> regular_languages A", "from finite_imp_inj_to_nat_seg[OF finite_states]"], ["proof (chain)\npicking this:\n  \\<exists>f n. f ` Q = {i. i < n} \\<and> inj_on f Q", "obtain f :: \"'Q \\<Rightarrow> nat\" \n      where INJMAP: \"inj_on f (ta_rstates TA)\""], ["proof (prove)\nusing this:\n  \\<exists>f n. f ` Q = {i. i < n} \\<and> inj_on f Q\n\ngoal (1 subgoal):\n 1. (\\<And>f. inj_on f Q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast\n    \\<comment> \\<open>Remap automaton. The language remains the same.\\<close>"], ["proof (state)\nthis:\n  inj_on f Q\n\ngoal (1 subgoal):\n 1. ta_lang TA \\<in> regular_languages A", "from remap_lang[OF INJMAP]"], ["proof (chain)\npicking this:\n  ta_lang (ta_remap f TA) = ta_lang TA", "have LE: \"ta_lang (ta_remap f TA) = ta_lang TA\""], ["proof (prove)\nusing this:\n  ta_lang (ta_remap f TA) = ta_lang TA\n\ngoal (1 subgoal):\n 1. ta_lang (ta_remap f TA) = ta_lang TA", "."], ["proof (state)\nthis:\n  ta_lang (ta_remap f TA) = ta_lang TA\n\ngoal (1 subgoal):\n 1. ta_lang TA \\<in> regular_languages A", "moreover"], ["proof (state)\nthis:\n  ta_lang (ta_remap f TA) = ta_lang TA\n\ngoal (1 subgoal):\n 1. ta_lang TA \\<in> regular_languages A", "have \"ranked_tree_automaton (ta_remap f TA) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton (ta_remap f TA) A", ".."], ["proof (state)\nthis:\n  ranked_tree_automaton (ta_remap f TA) A\n\ngoal (1 subgoal):\n 1. ta_lang TA \\<in> regular_languages A", "ultimately"], ["proof (chain)\npicking this:\n  ta_lang (ta_remap f TA) = ta_lang TA\n  ranked_tree_automaton (ta_remap f TA) A", "show ?thesis"], ["proof (prove)\nusing this:\n  ta_lang (ta_remap f TA) = ta_lang TA\n  ranked_tree_automaton (ta_remap f TA) A\n\ngoal (1 subgoal):\n 1. ta_lang TA \\<in> regular_languages A", "by (auto simp add: regular_languages_def)"], ["proof (state)\nthis:\n  ta_lang TA \\<in> regular_languages A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n    It is sometimes more handy to obtain a complete, deterministic tree automaton\n    accepting a given regular language.\n\\<close>"], ["", "theorem obtain_complete:\n    obtains TAC::\"('Q set option,'L) tree_automaton_rec\" where\n    \"ta_lang TAC = ta_lang TA\"\n    \"complete_tree_automaton TAC A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>TAC.\n        \\<lbrakk>ta_lang TAC = ta_lang TA;\n         complete_tree_automaton TAC A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>TAC.\n        \\<lbrakk>ta_lang TAC = ta_lang TA;\n         complete_tree_automaton TAC A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from detTA_correct"], ["proof (chain)\npicking this:\n  det_tree_automaton detTA A\n  ta_lang detTA = ta_lang TA", "have \n      DT: \"det_tree_automaton detTA A\" and\n      [simp]: \"ta_lang detTA = ta_lang TA\""], ["proof (prove)\nusing this:\n  det_tree_automaton detTA A\n  ta_lang detTA = ta_lang TA\n\ngoal (1 subgoal):\n 1. det_tree_automaton detTA A &&& ta_lang detTA = ta_lang TA", "by simp_all"], ["proof (state)\nthis:\n  det_tree_automaton detTA A\n  ta_lang detTA = ta_lang TA\n\ngoal (1 subgoal):\n 1. (\\<And>TAC.\n        \\<lbrakk>ta_lang TAC = ta_lang TA;\n         complete_tree_automaton TAC A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "interpret dt: det_tree_automaton detTA A"], ["proof (prove)\ngoal (1 subgoal):\n 1. det_tree_automaton detTA A", "using DT"], ["proof (prove)\nusing this:\n  det_tree_automaton detTA A\n\ngoal (1 subgoal):\n 1. det_tree_automaton detTA A", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>TAC.\n        \\<lbrakk>ta_lang TAC = ta_lang TA;\n         complete_tree_automaton TAC A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from dt.completeTA_correct"], ["proof (chain)\npicking this:\n  complete_tree_automaton dt.completeTA A\n  ta_lang dt.completeTA = ta_lang detTA", "have G: \n      \"ta_lang (det_tree_automaton.completeTA detTA A) = ta_lang TA\"\n      \"complete_tree_automaton (det_tree_automaton.completeTA detTA A) A\""], ["proof (prove)\nusing this:\n  complete_tree_automaton dt.completeTA A\n  ta_lang dt.completeTA = ta_lang detTA\n\ngoal (1 subgoal):\n 1. ta_lang dt.completeTA = ta_lang TA &&&\n    complete_tree_automaton dt.completeTA A", "by simp_all"], ["proof (state)\nthis:\n  ta_lang dt.completeTA = ta_lang TA\n  complete_tree_automaton dt.completeTA A\n\ngoal (1 subgoal):\n 1. (\\<And>TAC.\n        \\<lbrakk>ta_lang TAC = ta_lang TA;\n         complete_tree_automaton TAC A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  ta_lang dt.completeTA = ta_lang TA\n  complete_tree_automaton dt.completeTA A\n\ngoal (1 subgoal):\n 1. thesis", "by (blast intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma rtlE_complete:\n  fixes L :: \"'L tree set\"\n  assumes A: \"L\\<in>regular_languages A\"\n  obtains TA::\"(nat,'L) tree_automaton_rec\" where \n    \"L=ta_lang TA\"\n    \"complete_tree_automaton TA A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from rtlE[OF A]"], ["proof (chain)\npicking this:\n  (\\<And>TA.\n      \\<lbrakk>L = ta_lang TA; ranked_tree_automaton TA A\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain TA :: \"(nat,'L) tree_automaton_rec\" where\n    [simp, symmetric]: \"L = ta_lang TA\" and\n        RT: \"ranked_tree_automaton TA A\""], ["proof (prove)\nusing this:\n  (\\<And>TA.\n      \\<lbrakk>L = ta_lang TA; ranked_tree_automaton TA A\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; ranked_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  ta_lang TA = L\n  ranked_tree_automaton TA A\n\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "interpret ta: ranked_tree_automaton TA A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA A", "using RT"], ["proof (prove)\nusing this:\n  ranked_tree_automaton TA A\n\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA A", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain TAC :: \"(nat set option,'L) tree_automaton_rec\" \n    where [simp]: \"ta_lang TAC = L\" and CT: \"complete_tree_automaton TAC A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>TAC.\n        \\<lbrakk>ta_lang TAC = L; complete_tree_automaton TAC A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule_tac ta.obtain_complete) auto"], ["proof (state)\nthis:\n  ta_lang TAC = L\n  complete_tree_automaton TAC A\n\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "interpret tac: complete_tree_automaton TAC A"], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_tree_automaton TAC A", "using CT"], ["proof (prove)\nusing this:\n  complete_tree_automaton TAC A\n\ngoal (1 subgoal):\n 1. complete_tree_automaton TAC A", ".\n\n  \\<comment> \\<open>Obtain injective mapping from the finite set of states to the \n      natural numbers\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from finite_imp_inj_to_nat_seg[OF tac.finite_states]"], ["proof (chain)\npicking this:\n  \\<exists>f n. f ` tac.Q = {i. i < n} \\<and> inj_on f tac.Q", "obtain f :: \"nat set option \\<Rightarrow> nat\" where\n    INJMAP: \"inj_on f (ta_rstates TAC)\""], ["proof (prove)\nusing this:\n  \\<exists>f n. f ` tac.Q = {i. i < n} \\<and> inj_on f tac.Q\n\ngoal (1 subgoal):\n 1. (\\<And>f. inj_on f tac.Q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n  \\<comment> \\<open>Remap automaton. The language remains the same.\\<close>"], ["proof (state)\nthis:\n  inj_on f tac.Q\n\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from tac.remap_lang[OF INJMAP]"], ["proof (chain)\npicking this:\n  ta_lang (ta_remap f TAC) = ta_lang TAC", "have LE: \"ta_lang (ta_remap f TAC) = L\""], ["proof (prove)\nusing this:\n  ta_lang (ta_remap f TAC) = ta_lang TAC\n\ngoal (1 subgoal):\n 1. ta_lang (ta_remap f TAC) = L", "by simp"], ["proof (state)\nthis:\n  ta_lang (ta_remap f TAC) = L\n\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"complete_tree_automaton (ta_remap f TAC) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_tree_automaton (ta_remap f TAC) A", "using tac.remap_cta[OF INJMAP]"], ["proof (prove)\nusing this:\n  complete_tree_automaton (ta_remap f TAC) A\n\ngoal (1 subgoal):\n 1. complete_tree_automaton (ta_remap f TAC) A", "."], ["proof (state)\nthis:\n  complete_tree_automaton (ta_remap f TAC) A\n\ngoal (1 subgoal):\n 1. (\\<And>TA.\n        \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  complete_tree_automaton (ta_remap f TAC) A\n\ngoal (1 subgoal):\n 1. thesis", "by (rule_tac that[OF LE[symmetric]])"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Closure Properties\""], ["", "text \\<open>\n  In this section, we derive the standard closure properties of regular languages,\n  i.e. that regular languages are closed under union, intersection, complement, \n  and difference, as well as that the empty and the universal language are\n  regular.\n  \n  Note that we do not formalize homomorphisms or tree transducers here.\n\\<close>"], ["", "theorem (in finite_alphabet) rtl_empty[simp, intro!]: \"{} \\<in> regular_languages A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<in> regular_languages A", "by (rule ranked_tree_automaton.rtlI[OF ta_empty_rta, simplified])"], ["", "theorem rtl_union_closed: \n  \"\\<lbrakk> L1\\<in>regular_languages A; L2\\<in>regular_languages A \\<rbrakk> \n    \\<Longrightarrow> L1\\<union>L2 \\<in> regular_languages A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L1 \\<in> regular_languages A;\n     L2 \\<in> regular_languages A\\<rbrakk>\n    \\<Longrightarrow> L1 \\<union> L2 \\<in> regular_languages A", "proof (elim rtlE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>TA TAa.\n       \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A;\n        L2 = ta_lang TAa; ranked_tree_automaton TAa A\\<rbrakk>\n       \\<Longrightarrow> L1 \\<union> L2 \\<in> regular_languages A", "fix TA1 TA2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>TA TAa.\n       \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A;\n        L2 = ta_lang TAa; ranked_tree_automaton TAa A\\<rbrakk>\n       \\<Longrightarrow> L1 \\<union> L2 \\<in> regular_languages A", "assume TA[simp]: \"ranked_tree_automaton TA1 A\" \"ranked_tree_automaton TA2 A\"\n    and [simp]: \"L1=ta_lang TA1\" \"L2=ta_lang TA2\""], ["proof (state)\nthis:\n  ranked_tree_automaton TA1 A\n  ranked_tree_automaton TA2 A\n  L1 = ta_lang TA1\n  L2 = ta_lang TA2\n\ngoal (1 subgoal):\n 1. \\<And>TA TAa.\n       \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A;\n        L2 = ta_lang TAa; ranked_tree_automaton TAa A\\<rbrakk>\n       \\<Longrightarrow> L1 \\<union> L2 \\<in> regular_languages A", "interpret ta1: ranked_tree_automaton TA1 A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA1 A", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>TA TAa.\n       \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A;\n        L2 = ta_lang TAa; ranked_tree_automaton TAa A\\<rbrakk>\n       \\<Longrightarrow> L1 \\<union> L2 \\<in> regular_languages A", "interpret ta2: ranked_tree_automaton TA2 A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA2 A", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>TA TAa.\n       \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A;\n        L2 = ta_lang TAa; ranked_tree_automaton TAa A\\<rbrakk>\n       \\<Longrightarrow> L1 \\<union> L2 \\<in> regular_languages A", "have \"ta_lang (ta_union_wrap TA1 TA2) = ta_lang TA1 \\<union> ta_lang TA2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta_lang (ta_union_wrap TA1 TA2) = ta_lang TA1 \\<union> ta_lang TA2", "apply (rule ta_union_wrap_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. tree_automaton TA1\n 2. tree_automaton TA2", "by unfold_locales"], ["proof (state)\nthis:\n  ta_lang (ta_union_wrap TA1 TA2) = ta_lang TA1 \\<union> ta_lang TA2\n\ngoal (1 subgoal):\n 1. \\<And>TA TAa.\n       \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A;\n        L2 = ta_lang TAa; ranked_tree_automaton TAa A\\<rbrakk>\n       \\<Longrightarrow> L1 \\<union> L2 \\<in> regular_languages A", "with ranked_tree_automaton.rtlI[OF ta_union_wrap_rta[OF TA]]"], ["proof (chain)\npicking this:\n  ta_lang (ta_union_wrap TA1 TA2) \\<in> regular_languages A\n  ta_lang (ta_union_wrap TA1 TA2) = ta_lang TA1 \\<union> ta_lang TA2", "show ?thesis"], ["proof (prove)\nusing this:\n  ta_lang (ta_union_wrap TA1 TA2) \\<in> regular_languages A\n  ta_lang (ta_union_wrap TA1 TA2) = ta_lang TA1 \\<union> ta_lang TA2\n\ngoal (1 subgoal):\n 1. L1 \\<union> L2 \\<in> regular_languages A", "by (simp)"], ["proof (state)\nthis:\n  L1 \\<union> L2 \\<in> regular_languages A\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem rtl_inter_closed: \n  \"\\<lbrakk>L1\\<in>regular_languages A; L2\\<in>regular_languages A\\<rbrakk> \\<Longrightarrow> \n    L1\\<inter>L2 \\<in> regular_languages A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L1 \\<in> regular_languages A;\n     L2 \\<in> regular_languages A\\<rbrakk>\n    \\<Longrightarrow> L1 \\<inter> L2 \\<in> regular_languages A", "proof (elim rtlE, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>TA TAa.\n       \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A;\n        L2 = ta_lang TAa; ranked_tree_automaton TAa A\\<rbrakk>\n       \\<Longrightarrow> L1 \\<inter> L2 \\<in> regular_languages A", "case (1 TA1 TA2)"], ["proof (state)\nthis:\n  L1 = ta_lang TA1\n  ranked_tree_automaton TA1 A\n  L2 = ta_lang TA2\n  ranked_tree_automaton TA2 A\n\ngoal (1 subgoal):\n 1. \\<And>TA TAa.\n       \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A;\n        L2 = ta_lang TAa; ranked_tree_automaton TAa A\\<rbrakk>\n       \\<Longrightarrow> L1 \\<inter> L2 \\<in> regular_languages A", "with ta_prod_correct[of TA1 TA2] ta_prod_rta[of TA1 A TA2]"], ["proof (chain)\npicking this:\n  \\<lbrakk>tree_automaton TA1; tree_automaton TA2\\<rbrakk>\n  \\<Longrightarrow> ta_lang (ta_prod TA1 TA2) =\n                    ta_lang TA1 \\<inter> ta_lang TA2\n  \\<lbrakk>tree_automaton TA1; tree_automaton TA2\\<rbrakk>\n  \\<Longrightarrow> tree_automaton (ta_prod TA1 TA2)\n  \\<lbrakk>ranked_tree_automaton TA1 A; ranked_tree_automaton TA2 A\\<rbrakk>\n  \\<Longrightarrow> ranked_tree_automaton (ta_prod TA1 TA2) A\n  L1 = ta_lang TA1\n  ranked_tree_automaton TA1 A\n  L2 = ta_lang TA2\n  ranked_tree_automaton TA2 A", "have \n     L: \"ta_lang (ta_prod TA1 TA2) = L1\\<inter>L2\"  and\n     A: \"ranked_tree_automaton (ta_prod TA1 TA2) A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tree_automaton TA1; tree_automaton TA2\\<rbrakk>\n  \\<Longrightarrow> ta_lang (ta_prod TA1 TA2) =\n                    ta_lang TA1 \\<inter> ta_lang TA2\n  \\<lbrakk>tree_automaton TA1; tree_automaton TA2\\<rbrakk>\n  \\<Longrightarrow> tree_automaton (ta_prod TA1 TA2)\n  \\<lbrakk>ranked_tree_automaton TA1 A; ranked_tree_automaton TA2 A\\<rbrakk>\n  \\<Longrightarrow> ranked_tree_automaton (ta_prod TA1 TA2) A\n  L1 = ta_lang TA1\n  ranked_tree_automaton TA1 A\n  L2 = ta_lang TA2\n  ranked_tree_automaton TA2 A\n\ngoal (1 subgoal):\n 1. ta_lang (ta_prod TA1 TA2) = L1 \\<inter> L2 &&&\n    ranked_tree_automaton (ta_prod TA1 TA2) A", "by (simp_all add: ranked_tree_automaton.axioms)"], ["proof (state)\nthis:\n  ta_lang (ta_prod TA1 TA2) = L1 \\<inter> L2\n  ranked_tree_automaton (ta_prod TA1 TA2) A\n\ngoal (1 subgoal):\n 1. \\<And>TA TAa.\n       \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A;\n        L2 = ta_lang TAa; ranked_tree_automaton TAa A\\<rbrakk>\n       \\<Longrightarrow> L1 \\<inter> L2 \\<in> regular_languages A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<in> regular_languages A", "using ranked_tree_automaton.rtlI[OF A]"], ["proof (prove)\nusing this:\n  ta_lang (ta_prod TA1 TA2) \\<in> regular_languages A\n\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<in> regular_languages A", "by (simp add: L)"], ["proof (state)\nthis:\n  L1 \\<inter> L2 \\<in> regular_languages A\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem rtl_complement_closed:\n  \"L\\<in>regular_languages A \\<Longrightarrow> ranked_trees A - L \\<in> regular_languages A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<in> regular_languages A \\<Longrightarrow>\n    ranked_trees A - L \\<in> regular_languages A", "proof (elim rtlE_complete, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>TA.\n       \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n       \\<Longrightarrow> ranked_trees A - L \\<in> regular_languages A", "case prems: (1 TA)"], ["proof (state)\nthis:\n  L = ta_lang TA\n  complete_tree_automaton TA A\n\ngoal (1 subgoal):\n 1. \\<And>TA.\n       \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n       \\<Longrightarrow> ranked_trees A - L \\<in> regular_languages A", "then"], ["proof (chain)\npicking this:\n  L = ta_lang TA\n  complete_tree_automaton TA A", "interpret ta: complete_tree_automaton TA A"], ["proof (prove)\nusing this:\n  L = ta_lang TA\n  complete_tree_automaton TA A\n\ngoal (1 subgoal):\n 1. complete_tree_automaton TA A", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>TA.\n       \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n       \\<Longrightarrow> ranked_trees A - L \\<in> regular_languages A", "from ta.complementTA_correct"], ["proof (chain)\npicking this:\n  ta_lang ta.complementTA = ranked_trees A - ta_lang TA\n  complete_tree_automaton ta.complementTA A", "have\n    [simp]: \"ta_lang (ta.complementTA) = ranked_trees A - ta_lang TA\" and\n    CTA: \"complete_tree_automaton ta.complementTA A\""], ["proof (prove)\nusing this:\n  ta_lang ta.complementTA = ranked_trees A - ta_lang TA\n  complete_tree_automaton ta.complementTA A\n\ngoal (1 subgoal):\n 1. ta_lang ta.complementTA = ranked_trees A - ta_lang TA &&&\n    complete_tree_automaton ta.complementTA A", "by auto"], ["proof (state)\nthis:\n  ta_lang ta.complementTA = ranked_trees A - ta_lang TA\n  complete_tree_automaton ta.complementTA A\n\ngoal (1 subgoal):\n 1. \\<And>TA.\n       \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n       \\<Longrightarrow> ranked_trees A - L \\<in> regular_languages A", "interpret cta: complete_tree_automaton ta.complementTA A"], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_tree_automaton ta.complementTA A", "using CTA"], ["proof (prove)\nusing this:\n  complete_tree_automaton ta.complementTA A\n\ngoal (1 subgoal):\n 1. complete_tree_automaton ta.complementTA A", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>TA.\n       \\<lbrakk>L = ta_lang TA; complete_tree_automaton TA A\\<rbrakk>\n       \\<Longrightarrow> ranked_trees A - L \\<in> regular_languages A", "from cta.rtlI prems(1)"], ["proof (chain)\npicking this:\n  ta_lang ta.complementTA \\<in> regular_languages A\n  L = ta_lang TA", "show ?case"], ["proof (prove)\nusing this:\n  ta_lang ta.complementTA \\<in> regular_languages A\n  L = ta_lang TA\n\ngoal (1 subgoal):\n 1. ranked_trees A - L \\<in> regular_languages A", "by simp"], ["proof (state)\nthis:\n  ranked_trees A - L \\<in> regular_languages A\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in finite_alphabet) rtl_univ: \n  \"ranked_trees A \\<in> regular_languages A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_trees A \\<in> regular_languages A", "using rtl_complement_closed[OF rtl_empty]"], ["proof (prove)\nusing this:\n  ranked_trees A - {} \\<in> regular_languages A\n\ngoal (1 subgoal):\n 1. ranked_trees A \\<in> regular_languages A", "by simp"], ["", "theorem rtl_diff_closed:\n  fixes L1 :: \"'L tree set\"\n  assumes A[simp]: \"L1 \\<in> regular_languages A\" \"L2\\<in>regular_languages A\" \n  shows \"L1-L2 \\<in> regular_languages A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L1 - L2 \\<in> regular_languages A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. L1 - L2 \\<in> regular_languages A", "from rtlE[OF A(1)]"], ["proof (chain)\npicking this:\n  (\\<And>TA.\n      \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain TA1::\"(nat,'L) tree_automaton_rec\" where\n    L1: \"L1=ta_lang TA1\" and\n    RT1: \"ranked_tree_automaton TA1 A\""], ["proof (prove)\nusing this:\n  (\\<And>TA.\n      \\<lbrakk>L1 = ta_lang TA; ranked_tree_automaton TA A\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>TA1.\n        \\<lbrakk>L1 = ta_lang TA1; ranked_tree_automaton TA1 A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  L1 = ta_lang TA1\n  ranked_tree_automaton TA1 A\n\ngoal (1 subgoal):\n 1. L1 - L2 \\<in> regular_languages A", "from rtlE[OF A(2)]"], ["proof (chain)\npicking this:\n  (\\<And>TA.\n      \\<lbrakk>L2 = ta_lang TA; ranked_tree_automaton TA A\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain TA2::\"(nat,'L) tree_automaton_rec\" where\n    L2: \"L2=ta_lang TA2\" and\n    RT2: \"ranked_tree_automaton TA2 A\""], ["proof (prove)\nusing this:\n  (\\<And>TA.\n      \\<lbrakk>L2 = ta_lang TA; ranked_tree_automaton TA A\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>TA2.\n        \\<lbrakk>L2 = ta_lang TA2; ranked_tree_automaton TA2 A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  L2 = ta_lang TA2\n  ranked_tree_automaton TA2 A\n\ngoal (1 subgoal):\n 1. L1 - L2 \\<in> regular_languages A", "interpret ta1: ranked_tree_automaton TA1 A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA1 A", "using RT1"], ["proof (prove)\nusing this:\n  ranked_tree_automaton TA1 A\n\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA1 A", "."], ["proof (state)\ngoal (1 subgoal):\n 1. L1 - L2 \\<in> regular_languages A", "interpret ta2: ranked_tree_automaton TA2 A"], ["proof (prove)\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA2 A", "using RT2"], ["proof (prove)\nusing this:\n  ranked_tree_automaton TA2 A\n\ngoal (1 subgoal):\n 1. ranked_tree_automaton TA2 A", "."], ["proof (state)\ngoal (1 subgoal):\n 1. L1 - L2 \\<in> regular_languages A", "from ta1.lang_is_ranked"], ["proof (chain)\npicking this:\n  ta_lang TA1 \\<subseteq> ranked_trees A", "have ALT: \"L1-L2 = L1 \\<inter> (ranked_trees A - L2)\""], ["proof (prove)\nusing this:\n  ta_lang TA1 \\<subseteq> ranked_trees A\n\ngoal (1 subgoal):\n 1. L1 - L2 = L1 \\<inter> (ranked_trees A - L2)", "by (auto simp add: L1 L2)"], ["proof (state)\nthis:\n  L1 - L2 = L1 \\<inter> (ranked_trees A - L2)\n\ngoal (1 subgoal):\n 1. L1 - L2 \\<in> regular_languages A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. L1 - L2 \\<in> regular_languages A", "unfolding ALT"], ["proof (prove)\ngoal (1 subgoal):\n 1. L1 \\<inter> (ranked_trees A - L2) \\<in> regular_languages A", "by (simp add: rtl_complement_closed rtl_inter_closed)"], ["proof (state)\nthis:\n  L1 - L2 \\<in> regular_languages A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas rtl_closed = finite_alphabet.rtl_empty finite_alphabet.rtl_univ \n  rtl_complement_closed\n  rtl_inter_closed rtl_union_closed rtl_diff_closed"], ["", "end"]]}