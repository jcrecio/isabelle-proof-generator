{"file_name": "/home/qj213/afp-2021-10-22/thys/Tree-Automata/AbsAlgo.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tree-Automata", "problem_names": ["lemma r_match_alt: \n  \"r_match L l \\<longleftrightarrow> length L = length l \\<and> (\\<forall>i<length l. l!i \\<in> L!i)\"", "lemma faccs_correct_aux: \n  \"q\\<in>faccs \\<delta> n = accs \\<delta> n q\" (is ?T1)\n  \"(map (faccs \\<delta>) ts = map (\\<lambda>t. { q . accs \\<delta> t q}) ts)\" (is ?T2)", "theorem faccs_correct1: \"q\\<in>faccs \\<delta> n \\<Longrightarrow> accs \\<delta> n q\"", "theorem faccs_correct2: \"accs \\<delta> n q \\<Longrightarrow> q\\<in>faccs \\<delta> n\"", "lemmas faccs_correct = faccs_correct1 faccs_correct2", "lemma faccs_alt: \"faccs \\<delta> t = {q. accs \\<delta> t q}\"", "lemma b_accs_as_closed:\n  assumes A: \"bacc_step \\<delta> Q \\<subseteq> Q\"  \n  shows \"b_accessible \\<delta> \\<subseteq> Q\"", "lemma bre_cond_imp_br_cond[intro, simp]: \"bre_cond Qi \\<subseteq> br_cond\"", "lemma br_termrel_wf[simp, intro!]: \"finite \\<delta> \\<Longrightarrow> wf (br_termrel \\<delta>)\"", "lemma br_dsq_ss:\n  assumes A: \"(Q,W)\\<in>br_invar \\<delta>\" \"W \\<noteq> {}\" \"q\\<in>W\"\n  shows \"br_dsq \\<delta> q (Q,W) \\<subseteq> b_accessible \\<delta>\"", "lemma br_step_in_termrel: \n  assumes A: \"\\<Sigma>\\<in>br_cond\" \"\\<Sigma>\\<in>br_invar \\<delta>\" \"(\\<Sigma>,\\<Sigma>')\\<in>br_step \\<delta>\"\n  shows \"(\\<Sigma>', \\<Sigma>)\\<in>br_termrel \\<delta>\"", "lemma br_invar_initial[simp]: \"finite \\<delta> \\<Longrightarrow> (br_initial \\<delta>)\\<in>br_invar \\<delta>\"", "lemma br_invar_step: \n  assumes [simp]: \"finite \\<delta>\"\n  assumes A: \"\\<Sigma>\\<in>br_cond\" \"\\<Sigma>\\<in>br_invar \\<delta>\" \"(\\<Sigma>,\\<Sigma>')\\<in>br_step \\<delta>\"\n  shows \"\\<Sigma>'\\<in>br_invar \\<delta>\"", "lemma br_invar_final:\n  \"\\<forall>\\<Sigma>. \\<Sigma>\\<in>wa_invar (br_algo \\<delta>) \\<and> \\<Sigma>\\<notin>wa_cond (br_algo \\<delta>) \n   \\<longrightarrow> fst \\<Sigma> = b_accessible \\<delta>\"", "theorem br_while_algo: \n  assumes FIN[simp]: \"finite \\<delta>\"\n  shows \"while_algo (br_algo \\<delta>)\"", "lemma bre_invar_final:\n  \"\\<forall>\\<Sigma>. \\<Sigma>\\<in>wa_invar (bre_algo Qi \\<delta>) \\<and> \\<Sigma>\\<notin>wa_cond (bre_algo Qi \\<delta>) \n     \\<longrightarrow> ((Qi\\<inter>fst \\<Sigma>={}) \\<longleftrightarrow> (Qi \\<inter> b_accessible \\<delta> = {}))\"", "theorem bre_while_algo:\n  assumes FIN[simp]: \"finite \\<delta>\"\n  shows \"while_algo (bre_algo Qi \\<delta>)\"", "lemma br'_step_invar: \n  assumes finite[simp]: \"finite \\<delta>\"\n  assumes INV: \"\\<Sigma>\\<in>br'_invar_add \\<delta>\" \"br'_\\<alpha> \\<Sigma> \\<in> br_invar \\<delta>\"\n  assumes STEP: \"(\\<Sigma>,\\<Sigma>') \\<in> br'_step \\<delta>\"\n  shows \"\\<Sigma>'\\<in>br'_invar_add \\<delta>\"", "lemma br'_invar_initial: \n  \"br'_initial \\<delta> \\<subseteq> br'_invar_add \\<delta>\"", "lemma br'_rcm_aux': \n  \"\\<lbrakk> (Q,W,rcm)\\<in>br'_invar \\<delta>; q\\<in>W \\<rbrakk> \n    \\<Longrightarrow> {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} \n         = {r\\<in>\\<delta>. q\\<in>set (rhsq r) \\<and> set (rhsq r) \\<subseteq> (Q - (W-{q}))}\"", "lemma br'_rcm_aux: \n  assumes A: \"(Q,W,rcm)\\<in>br'_invar \\<delta>\" \"q\\<in>W\"  \n  shows \"{lhs r |r. r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} \n         = {lhs r | r. r\\<in>\\<delta> \\<and> q\\<in>set (rhsq r) \\<and> set (rhsq r) \\<subseteq> (Q - (W-{q}))}\"", "lemma br'_invar_QcD: \n  \"(Q,W,rcm) \\<in> br'_invar \\<delta> \\<Longrightarrow> {lhs r | r. r\\<in>\\<delta> \\<and> set (rhsq r) \\<subseteq> (Q-W)} \\<subseteq> Q\"", "lemma br'_rcm_aux2: \n  \"\\<lbrakk> (Q,W,rcm)\\<in>br'_invar \\<delta>; q\\<in>W \\<rbrakk> \n    \\<Longrightarrow> Q \\<union> br_dsq \\<delta> q (Q,W) \n        = Q \\<union> {lhs r |r. r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}\"", "lemma br'_rcm_aux3: \n  \"\\<lbrakk> (Q,W,rcm)\\<in>br'_invar \\<delta>; q\\<in>W \\<rbrakk> \n    \\<Longrightarrow> br_dsq \\<delta> q (Q,W) - Q \n        = {lhs r |r. r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} - Q\"", "lemma br'_step_abs: \n  \"\\<lbrakk> \n     \\<Sigma>\\<in>br'_invar \\<delta>; \n     (\\<Sigma>,\\<Sigma>') \\<in> br'_step \\<delta> \n   \\<rbrakk> \\<Longrightarrow> (br'_\\<alpha> \\<Sigma>, br'_\\<alpha> \\<Sigma>')\\<in>br_step \\<delta>\"", "lemma br'_initial_abs: \"br'_\\<alpha>`(br'_initial \\<delta>) = {br_initial \\<delta>}\"", "lemma br'_cond_abs: \"\\<Sigma>\\<in>br'_cond \\<longleftrightarrow> (br'_\\<alpha> \\<Sigma>) \\<in> br_cond\"", "lemma bre'_cond_abs: \"\\<Sigma>\\<in>bre'_cond Qi \\<longleftrightarrow> (br'_\\<alpha> \\<Sigma>)\\<in>bre_cond Qi\"", "lemma br'_invar_abs: \"br'_\\<alpha>`br'_invar \\<delta> \\<subseteq> br_invar \\<delta>\"", "theorem br'_pref_br: \"wa_precise_refine (br'_algo \\<delta>) (br_algo \\<delta>) br'_\\<alpha>\"", "theorem br'_while_algo: \n  \"finite \\<delta> \\<Longrightarrow> while_algo (br'_algo \\<delta>)\"", "lemma fst_br'_\\<alpha>: \"fst (br'_\\<alpha> s) = fst s\"", "lemmas br'_invar_final = \n  br'_pref.transfer_correctness[OF br_invar_final, unfolded fst_br'_\\<alpha>]", "theorem bre'_pref_br: \"wa_precise_refine (bre'_algo Qi \\<delta>) (bre_algo Qi \\<delta>) br'_\\<alpha>\"", "theorem bre'_while_algo: \n  \"finite \\<delta> \\<Longrightarrow> while_algo (bre'_algo Qi \\<delta>)\"", "lemmas bre'_invar_final = \n  bre'_pref.transfer_correctness[OF bre_invar_final, unfolded fst_br'_\\<alpha>]", "lemma br'_inner_invar_imp_final: \n  \"\\<lbrakk> q\\<in>W; br'_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) {} \\<Sigma>' \\<rbrakk> \n     \\<Longrightarrow> ((Q,W,rcm),\\<Sigma>') \\<in> br'_step \\<delta>\"", "lemma br'_inner_invar_step: \n  \"\\<lbrakk> q\\<in>W; br'_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) it \\<Sigma>'; \n     r\\<in>it; it\\<subseteq>{r\\<in>\\<delta>. q\\<in>set (rhsq r)} \n   \\<rbrakk> \\<Longrightarrow> br'_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) \n                         (it-{r}) (br'_inner_step r \\<Sigma>')\n  \"", "lemma br'_inner_invar_initial: \n  \"\\<lbrakk> q\\<in>W \\<rbrakk> \\<Longrightarrow> br'_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) \n                               {r\\<in>\\<delta>. q\\<in>set (rhsq r)} (Q,W-{q},rcm)\"", "lemma br'_inner_step_proof:\n  fixes \\<alpha>s :: \"'\\<Sigma> \\<Rightarrow> ('Q,'L) br'_state\"\n  fixes cstep :: \"('Q,'L) ta_rule \\<Rightarrow> '\\<Sigma> \\<Rightarrow> '\\<Sigma>\"\n  fixes \\<Sigma>h :: \"'\\<Sigma>\"\n  fixes cinvar :: \"('Q,'L) ta_rule set \\<Rightarrow> '\\<Sigma> \\<Rightarrow> bool\"\n\n  assumes iterable_set: \"set_iteratei \\<alpha> invar iteratei\"\n  assumes invar_initial: \"cinvar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} \\<Sigma>h\"\n  assumes invar_step: \n    \"!!it r \\<Sigma>. \\<lbrakk> r\\<in>it; it \\<subseteq> {r\\<in>\\<delta>. q\\<in>set (rhsq r)}; cinvar it \\<Sigma> \\<rbrakk> \n                 \\<Longrightarrow> cinvar (it-{r}) (cstep r \\<Sigma>)\"\n  assumes step_desc: \n    \"!!it r \\<Sigma>. \\<lbrakk> r\\<in>it; it\\<subseteq>{r\\<in>\\<delta>. q\\<in>set (rhsq r)}; cinvar it \\<Sigma> \\<rbrakk> \n                 \\<Longrightarrow> \\<alpha>s (cstep r \\<Sigma>) = br'_inner_step r (\\<alpha>s \\<Sigma>)\"\n  assumes it_set_desc: \"invar it_set\" \"\\<alpha> it_set = {r\\<in>\\<delta>. q\\<in>set (rhsq r)}\"\n\n  assumes QIW[simp]: \"q\\<in>W\"\n\n  assumes \\<Sigma>_desc[simp]: \"\\<alpha>s \\<Sigma> = (Q,W,rcm)\"\n  assumes \\<Sigma>h_desc[simp]: \"\\<alpha>s \\<Sigma>h = (Q,W-{q},rcm)\"\n\n  shows \"(\\<alpha>s \\<Sigma>, \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\\<in>br'_step \\<delta>\"", "lemma witness_propD: \"\\<lbrakk>witness_prop \\<delta> m; m q = Some t\\<rbrakk> \\<Longrightarrow> accs \\<delta> t q\"", "lemma construct_witness_correct: \n  \"\\<lbrakk> witness_prop \\<delta> Q; r\\<in>\\<delta>; set (rhsq r) \\<subseteq> dom Q \\<rbrakk> \n    \\<Longrightarrow> accs \\<delta> (construct_witness Q r) (lhs r)\"", "lemma construct_witness_eq: \n  \"\\<lbrakk> Q |` set (rhsq r) = Q' |` set (rhsq r) \\<rbrakk> \\<Longrightarrow> \n    construct_witness Q r = construct_witness Q' r\"", "lemma brw_cond_abs: \"\\<Sigma>\\<in>brw_cond Qi \\<longleftrightarrow> (brw_\\<alpha> \\<Sigma>)\\<in>bre'_cond Qi\"", "lemma brw_initial_abs: \"\\<Sigma>\\<in>brw_initial \\<delta> \\<Longrightarrow> brw_\\<alpha> \\<Sigma> \\<in> br'_initial \\<delta>\"", "lemma brw_invar_initial: \"brw_initial \\<delta> \\<subseteq> brw_invar_add \\<delta>\"", "lemma brw_step_abs:\n  \"\\<lbrakk> (\\<Sigma>,\\<Sigma>')\\<in>brw_step \\<delta> \\<rbrakk> \\<Longrightarrow> (brw_\\<alpha> \\<Sigma>, brw_\\<alpha> \\<Sigma>')\\<in>br'_step \\<delta>\"", "lemma brw_step_invar:\n  assumes FIN[simp]: \"finite \\<delta>\"\n  assumes INV: \"\\<Sigma>\\<in>brw_invar_add \\<delta>\" and BR'INV: \"brw_\\<alpha> \\<Sigma> \\<in> br'_invar \\<delta>\"\n  assumes STEP: \"(\\<Sigma>,\\<Sigma>') \\<in> brw_step \\<delta>\"\n  shows \"\\<Sigma>'\\<in>brw_invar_add \\<delta>\"", "theorem brw_pref_bre': \"wa_precise_refine (brw_algo Qi \\<delta>) (bre'_algo Qi \\<delta>) brw_\\<alpha>\"", "theorem brw_while_algo: \"finite \\<delta> \\<Longrightarrow> while_algo (brw_algo Qi \\<delta>)\"", "lemma fst_brw_\\<alpha>: \"fst (brw_\\<alpha> s) = dom (fst s)\"", "theorem brw_invar_final: \n  \"\\<forall>sc. sc \\<in> wa_invar (brw_algo Qi \\<delta>) \\<and> sc \\<notin> wa_cond (brw_algo Qi \\<delta>) \n    \\<longrightarrow> (Qi \\<inter> dom (fst sc) = {}) = (Qi \\<inter> b_accessible \\<delta> = {}) \n        \\<and> (witness_prop \\<delta> (fst sc))\"", "lemma brw_inner_step_abs: \n  \"(\\<Sigma>,\\<Sigma>')\\<in>brw_inner_step r \\<Longrightarrow> br'_inner_step r (brw_\\<alpha> \\<Sigma>) = brw_\\<alpha> \\<Sigma>'\"", "lemma brw_inner_invar_imp_final: \n  \"\\<lbrakk> q\\<in>W; brw_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) {} \\<Sigma>' \\<rbrakk> \n    \\<Longrightarrow> ((Q,W,rcm),\\<Sigma>') \\<in> brw_step \\<delta>\"", "lemma brw_inner_invar_step: \n  assumes INVI: \"(Q,W,rcm)\\<in>brw_invar \\<delta>\"\n  assumes A: \"q\\<in>W\" \"r\\<in>it\" \"it\\<subseteq>{r\\<in>\\<delta>. q\\<in>set (rhsq r)}\" \n  assumes INVH: \"brw_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) it \\<Sigma>h\"\n  assumes STEP: \"(\\<Sigma>h,\\<Sigma>')\\<in>brw_inner_step r\" \n  shows \"brw_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) (it-{r}) \\<Sigma>'\"", "lemma brw_inner_invar_initial: \n  \"\\<lbrakk>q\\<in>W\\<rbrakk> \\<Longrightarrow> brw_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) \n                             {r\\<in>\\<delta>. q\\<in>set (rhsq r)} (Q,W-{q},rcm)\"", "theorem brw_inner_step_proof:\n  fixes \\<alpha>s :: \"'\\<Sigma> \\<Rightarrow> ('Q,'L) brw_state\"\n  fixes cstep :: \"('Q,'L) ta_rule \\<Rightarrow> '\\<Sigma> \\<Rightarrow> '\\<Sigma>\"\n  fixes \\<Sigma>h :: \"'\\<Sigma>\"\n  fixes cinvar :: \"('Q,'L) ta_rule set \\<Rightarrow> '\\<Sigma> \\<Rightarrow> bool\"\n\n  assumes set_iterate: \"set_iteratei \\<alpha> invar iteratei\"\n  assumes invar_start: \"(\\<alpha>s \\<Sigma>)\\<in>brw_invar \\<delta>\"\n  assumes invar_initial: \"cinvar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} \\<Sigma>h\"\n  assumes invar_step: \n    \"!!it r \\<Sigma>. \\<lbrakk> r\\<in>it; it \\<subseteq> {r\\<in>\\<delta>. q\\<in>set (rhsq r)}; cinvar it \\<Sigma> \\<rbrakk> \n                \\<Longrightarrow> cinvar (it-{r}) (cstep r \\<Sigma>)\"\n  assumes step_desc: \n    \"!!it r \\<Sigma>. \\<lbrakk> r\\<in>it; it\\<subseteq>{r\\<in>\\<delta>. q\\<in>set (rhsq r)}; cinvar it \\<Sigma> \\<rbrakk> \n                \\<Longrightarrow> (\\<alpha>s \\<Sigma>, \\<alpha>s (cstep r \\<Sigma>)) \\<in> brw_inner_step r\"\n  assumes it_set_desc: \"invar it_set\" \"\\<alpha> it_set = {r\\<in>\\<delta>. q\\<in>set (rhsq r)}\"\n\n  assumes QIW[simp]: \"q\\<in>W\"\n\n  assumes \\<Sigma>_desc[simp]: \"\\<alpha>s \\<Sigma> = (Q,W,rcm)\"\n  assumes \\<Sigma>h_desc[simp]: \"\\<alpha>s \\<Sigma>h = (Q,W-{q},rcm)\"\n\n  shows \"(\\<alpha>s \\<Sigma>, \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\\<in>brw_step \\<delta>\"", "theorem frp_pref_dfs: \n  \"wa_precise_refine (frp_algo T1 T2) \n     (dfs_algo (ta_initial T1 \\<times> ta_initial T2) \n               (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2))))\n     frp_\\<alpha>\"", "theorem frp_while_algo:\n  assumes TA: \"tree_automaton T1\" \n              \"tree_automaton T2\"\n  shows \"while_algo (frp_algo T1 T2)\"", "theorem frp_inv_final:\n  \"\\<forall>s. s\\<in>wa_invar (frp_algo T1 T2) \\<and> s\\<notin>wa_cond (frp_algo T1 T2)\n       \\<longrightarrow> (case s of (Q,W,\\<delta>d) \\<Rightarrow> \n             \\<lparr> ta_initial = ta_initial T1 \\<times> ta_initial T2, \n               ta_rules = \\<delta>d \n             \\<rparr> = ta_fwd_reduce (ta_prod T1 T2))\""], "translations": [["", "lemma r_match_alt: \n  \"r_match L l \\<longleftrightarrow> length L = length l \\<and> (\\<forall>i<length l. l!i \\<in> L!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r_match L l =\n    (length L = length l \\<and> (\\<forall>i<length l. l ! i \\<in> L ! i))", "apply (induct L l rule: r_match.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. r_match [] [] =\n    (length [] = length [] \\<and>\n     (\\<forall>i<length []. [] ! i \\<in> [] ! i))\n 2. \\<And>A AS a as.\n       r_match AS as =\n       (length AS = length as \\<and>\n        (\\<forall>i<length as. as ! i \\<in> AS ! i)) \\<Longrightarrow>\n       r_match (A # AS) (a # as) =\n       (length (A # AS) = length (a # as) \\<and>\n        (\\<forall>i<length (a # as). (a # as) ! i \\<in> (A # AS) ! i))\n 3. \\<And>v va.\n       r_match (v # va) [] =\n       (length (v # va) = length [] \\<and>\n        (\\<forall>i<length []. [] ! i \\<in> (v # va) ! i))\n 4. \\<And>v va.\n       r_match [] (v # va) =\n       (length [] = length (v # va) \\<and>\n        (\\<forall>i<length (v # va). (v # va) ! i \\<in> [] ! i))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A AS a as i.\n       \\<lbrakk>r_match AS as; a \\<in> A; length AS = length as;\n        \\<forall>i<length as. as ! i \\<in> AS ! i;\n        i < Suc (length as)\\<rbrakk>\n       \\<Longrightarrow> (a # as) ! i \\<in> (A # AS) ! i", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A AS a as i.\n       \\<lbrakk>r_match AS as; a \\<in> A; length AS = length as;\n        \\<forall>i<length as. as ! i \\<in> AS ! i; i < Suc (length as);\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> (a # as) ! i \\<in> (A # AS) ! i\n 2. \\<And>A AS a as i nat.\n       \\<lbrakk>r_match AS as; a \\<in> A; length AS = length as;\n        \\<forall>i<length as. as ! i \\<in> AS ! i; i < Suc (length as);\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (a # as) ! i \\<in> (A # AS) ! i", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open>Whether a rule matches the given state, label and list of sets of states\\<close>"], ["", "fun r_matchc where\n  \"r_matchc q l Qs (qr \\<rightarrow> lr qsr) \\<longleftrightarrow> q=qr \\<and> l=lr \\<and> r_match Qs qsr\"\n\n\\<comment> \\<open>recursive version of @{const accs}-predicate\\<close>"], ["", "fun faccs :: \"('Q,'L) ta_rule set \\<Rightarrow> 'L tree \\<Rightarrow> 'Q set\" where\n  \"faccs \\<delta> (NODE f ts) = (\n    let Qs = map (faccs \\<delta>) (ts) in\n      {q. \\<exists>r\\<in>\\<delta>. r_matchc q f Qs r }\n  )\""], ["", "lemma faccs_correct_aux: \n  \"q\\<in>faccs \\<delta> n = accs \\<delta> n q\" (is ?T1)\n  \"(map (faccs \\<delta>) ts = map (\\<lambda>t. { q . accs \\<delta> t q}) ts)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (q \\<in> faccs \\<delta> n) = accs \\<delta> n q &&&\n    map (faccs \\<delta>) ts = map (\\<lambda>t. {q. accs \\<delta> t q}) ts", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (q \\<in> faccs \\<delta> n) = accs \\<delta> n q\n 2. map (faccs \\<delta>) ts = map (\\<lambda>t. {q. accs \\<delta> t q}) ts", "have \"(\\<forall>q. q\\<in>faccs \\<delta> n = accs \\<delta> n q) \n        \\<and> (map (faccs \\<delta>) ts = map (\\<lambda>t. { q . accs \\<delta> t q}) ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>q. (q \\<in> faccs \\<delta> n) = accs \\<delta> n q) \\<and>\n    map (faccs \\<delta>) ts = map (\\<lambda>t. {q. accs \\<delta> t q}) ts", "proof (induct rule: compat_tree_tree_list.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map (faccs \\<delta>) x2 =\n       map (\\<lambda>t. {q. accs \\<delta> t q}) x2 \\<Longrightarrow>\n       \\<forall>q.\n          (q \\<in> faccs \\<delta> (NODE x1 x2)) =\n          accs \\<delta> (NODE x1 x2) q\n 2. map (faccs \\<delta>) [] = map (\\<lambda>t. {q. accs \\<delta> t q}) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<forall>q.\n                   (q \\<in> faccs \\<delta> x1) = accs \\<delta> x1 q;\n        map (faccs \\<delta>) x2 =\n        map (\\<lambda>t. {q. accs \\<delta> t q}) x2\\<rbrakk>\n       \\<Longrightarrow> map (faccs \\<delta>) (x1 # x2) =\n                         map (\\<lambda>t. {q. accs \\<delta> t q}) (x1 # x2)", "case (NODE f ts)"], ["proof (state)\nthis:\n  map (faccs \\<delta>) ts = map (\\<lambda>t. {q. accs \\<delta> t q}) ts\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       map (faccs \\<delta>) x2 =\n       map (\\<lambda>t. {q. accs \\<delta> t q}) x2 \\<Longrightarrow>\n       \\<forall>q.\n          (q \\<in> faccs \\<delta> (NODE x1 x2)) =\n          accs \\<delta> (NODE x1 x2) q\n 2. map (faccs \\<delta>) [] = map (\\<lambda>t. {q. accs \\<delta> t q}) []\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<forall>q.\n                   (q \\<in> faccs \\<delta> x1) = accs \\<delta> x1 q;\n        map (faccs \\<delta>) x2 =\n        map (\\<lambda>t. {q. accs \\<delta> t q}) x2\\<rbrakk>\n       \\<Longrightarrow> map (faccs \\<delta>) (x1 # x2) =\n                         map (\\<lambda>t. {q. accs \\<delta> t q}) (x1 # x2)", "thus ?case"], ["proof (prove)\nusing this:\n  map (faccs \\<delta>) ts = map (\\<lambda>t. {q. accs \\<delta> t q}) ts\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       (q \\<in> faccs \\<delta> (NODE f ts)) = accs \\<delta> (NODE f ts) q", "apply (intro allI iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        q \\<in> faccs \\<delta> (NODE f ts)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (NODE f ts) q\n 2. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> faccs \\<delta> (NODE f ts)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        \\<exists>x\\<in>\\<delta>.\n           r_matchc q f (map (faccs \\<delta>) ts) x\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (NODE f ts) q\n 2. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> faccs \\<delta> (NODE f ts)", "apply (erule bexE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        x \\<in> \\<delta>; r_matchc q f (map (faccs \\<delta>) ts) x\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (NODE f ts) q\n 2. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> faccs \\<delta> (NODE f ts)", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q x x1 x2 x3.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        x \\<in> \\<delta>; r_matchc q f (map (faccs \\<delta>) ts) x;\n        x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (NODE f ts) q\n 2. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> faccs \\<delta> (NODE f ts)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q x x3.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        q \\<rightarrow> f x3 \\<in> \\<delta>;\n        r_match (map (faccs \\<delta>) ts) x3;\n        x = q \\<rightarrow> f x3\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (NODE f ts) q\n 2. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> faccs \\<delta> (NODE f ts)", "apply (rule accs.intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q x x3.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        q \\<rightarrow> f x3 \\<in> \\<delta>;\n        r_match (map (faccs \\<delta>) ts) x3;\n        x = q \\<rightarrow> f x3\\<rbrakk>\n       \\<Longrightarrow> q \\<rightarrow> f ?qs13 q x x3 \\<in> \\<delta>\n 2. \\<And>q x x3.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        q \\<rightarrow> f x3 \\<in> \\<delta>;\n        r_match (map (faccs \\<delta>) ts) x3;\n        x = q \\<rightarrow> f x3\\<rbrakk>\n       \\<Longrightarrow> length ts = length (?qs13 q x x3)\n 3. \\<And>q x x3 i.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        q \\<rightarrow> f x3 \\<in> \\<delta>;\n        r_match (map (faccs \\<delta>) ts) x3; x = q \\<rightarrow> f x3;\n        i < length (?qs13 q x x3)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (ts ! i) (?qs13 q x x3 ! i)\n 4. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> faccs \\<delta> (NODE f ts)", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q x x3.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        q \\<rightarrow> f x3 \\<in> \\<delta>;\n        r_match (map (faccs \\<delta>) ts) x3;\n        x = q \\<rightarrow> f x3\\<rbrakk>\n       \\<Longrightarrow> length ts = length x3\n 2. \\<And>q x x3 i.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        q \\<rightarrow> f x3 \\<in> \\<delta>;\n        r_match (map (faccs \\<delta>) ts) x3; x = q \\<rightarrow> f x3;\n        i < length x3\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (ts ! i) (x3 ! i)\n 3. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> faccs \\<delta> (NODE f ts)", "apply (unfold r_match_alt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q x x3.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        q \\<rightarrow> f x3 \\<in> \\<delta>;\n        length (map (faccs \\<delta>) ts) = length x3 \\<and>\n        (\\<forall>i<length x3. x3 ! i \\<in> map (faccs \\<delta>) ts ! i);\n        x = q \\<rightarrow> f x3\\<rbrakk>\n       \\<Longrightarrow> length ts = length x3\n 2. \\<And>q x x3 i.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        q \\<rightarrow> f x3 \\<in> \\<delta>;\n        length (map (faccs \\<delta>) ts) = length x3 \\<and>\n        (\\<forall>i<length x3. x3 ! i \\<in> map (faccs \\<delta>) ts ! i);\n        x = q \\<rightarrow> f x3; i < length x3\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (ts ! i) (x3 ! i)\n 3. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> faccs \\<delta> (NODE f ts)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q x x3 i.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        q \\<rightarrow> f x3 \\<in> \\<delta>;\n        length (map (faccs \\<delta>) ts) = length x3 \\<and>\n        (\\<forall>i<length x3. x3 ! i \\<in> map (faccs \\<delta>) ts ! i);\n        x = q \\<rightarrow> f x3; i < length x3\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (ts ! i) (x3 ! i)\n 2. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> faccs \\<delta> (NODE f ts)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>map (faccs \\<delta>) ts =\n                map (\\<lambda>t. {q. accs \\<delta> t q}) ts;\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> faccs \\<delta> (NODE f ts)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        accs \\<delta> (NODE f ts) q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>\\<delta>.\n                            r_matchc q f (map (faccs \\<delta>) ts) x", "apply (erule accs.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q qa fa qs \\<delta>' ts.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        \\<delta> = \\<delta>'; NODE f ts = NODE fa ts; q = qa;\n        qa \\<rightarrow> fa qs \\<in> \\<delta>'; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs \\<delta>' (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>\\<delta>.\n                            r_matchc q f (map (faccs \\<delta>) ts) x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>qa qs.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        qa \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs \\<delta> (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>\\<delta>.\n                            r_matchc qa f (map (faccs \\<delta>) ts) x", "apply (rule_tac x=\"qa \\<rightarrow> f qs\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>qa qs.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        qa \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs \\<delta> (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> r_matchc qa f (map (faccs \\<delta>) ts)\n                          qa \\<rightarrow> f qs\n 2. \\<And>qa qs.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        qa \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs \\<delta> (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> qa \\<rightarrow> f qs \\<in> \\<delta>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>qa qs.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        qa \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs \\<delta> (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> r_match (map (faccs \\<delta>) ts) qs\n 2. \\<And>qa qs.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        qa \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs \\<delta> (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> qa \\<rightarrow> f qs \\<in> \\<delta>", "apply (unfold r_match_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>qa qs.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        qa \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs \\<delta> (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> length (map (faccs \\<delta>) ts) = length qs \\<and>\n                         (\\<forall>i<length qs.\n                             qs ! i \\<in> map (faccs \\<delta>) ts ! i)\n 2. \\<And>qa qs.\n       \\<lbrakk>\\<forall>x\\<in>set ts.\n                   faccs \\<delta> x = Collect (accs \\<delta> x);\n        qa \\<rightarrow> f qs \\<in> \\<delta>; length ts = length qs;\n        \\<And>i.\n           i < length qs \\<Longrightarrow>\n           accs \\<delta> (ts ! i) (qs ! i)\\<rbrakk>\n       \\<Longrightarrow> qa \\<rightarrow> f qs \\<in> \\<delta>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>q.\n     (q \\<in> faccs \\<delta> (NODE f ts)) = accs \\<delta> (NODE f ts) q\n\ngoal (2 subgoals):\n 1. map (faccs \\<delta>) [] = map (\\<lambda>t. {q. accs \\<delta> t q}) []\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<forall>q.\n                   (q \\<in> faccs \\<delta> x1) = accs \\<delta> x1 q;\n        map (faccs \\<delta>) x2 =\n        map (\\<lambda>t. {q. accs \\<delta> t q}) x2\\<rbrakk>\n       \\<Longrightarrow> map (faccs \\<delta>) (x1 # x2) =\n                         map (\\<lambda>t. {q. accs \\<delta> t q}) (x1 # x2)", "qed auto"], ["proof (state)\nthis:\n  (\\<forall>q. (q \\<in> faccs \\<delta> n) = accs \\<delta> n q) \\<and>\n  map (faccs \\<delta>) ts = map (\\<lambda>t. {q. accs \\<delta> t q}) ts\n\ngoal (2 subgoals):\n 1. (q \\<in> faccs \\<delta> n) = accs \\<delta> n q\n 2. map (faccs \\<delta>) ts = map (\\<lambda>t. {q. accs \\<delta> t q}) ts", "thus ?T1 ?T2"], ["proof (prove)\nusing this:\n  (\\<forall>q. (q \\<in> faccs \\<delta> n) = accs \\<delta> n q) \\<and>\n  map (faccs \\<delta>) ts = map (\\<lambda>t. {q. accs \\<delta> t q}) ts\n\ngoal (1 subgoal):\n 1. (q \\<in> faccs \\<delta> n) = accs \\<delta> n q &&&\n    map (faccs \\<delta>) ts = map (\\<lambda>t. {q. accs \\<delta> t q}) ts", "by auto"], ["proof (state)\nthis:\n  (q \\<in> faccs \\<delta> n) = accs \\<delta> n q\n  map (faccs \\<delta>) ts = map (\\<lambda>t. {q. accs \\<delta> t q}) ts\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem faccs_correct1: \"q\\<in>faccs \\<delta> n \\<Longrightarrow> accs \\<delta> n q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> faccs \\<delta> n \\<Longrightarrow> accs \\<delta> n q", "by (simp add: faccs_correct_aux)"], ["", "theorem faccs_correct2: \"accs \\<delta> n q \\<Longrightarrow> q\\<in>faccs \\<delta> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> n q \\<Longrightarrow> q \\<in> faccs \\<delta> n", "by (simp add: faccs_correct_aux)"], ["", "lemmas faccs_correct = faccs_correct1 faccs_correct2"], ["", "lemma faccs_alt: \"faccs \\<delta> t = {q. accs \\<delta> t q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. faccs \\<delta> t = {q. accs \\<delta> t q}", "by (auto intro: faccs_correct)"], ["", "subsection \\<open>Backward Reduction and Emptiness Check\\<close>"], ["", "subsubsection \"Auxiliary Definitions\"\n\n\\<comment> \\<open>Step function, that maps a set of states to those states \n  that are reachable via one backward step.\\<close>"], ["", "inductive_set bacc_step :: \"('Q,'L) ta_rule set \\<Rightarrow> 'Q set \\<Rightarrow> 'Q set\" \n  for \\<delta> Q \n  where\n  \"\\<lbrakk> r\\<in>\\<delta>; set (rhsq r) \\<subseteq> Q \\<rbrakk> \\<Longrightarrow> lhs r \\<in> bacc_step \\<delta> Q\"\n\n\\<comment> \\<open>If a set is closed under adding all states that are reachable from the set \n  by one backward step, then this set contains all backward accessible states.\\<close>"], ["", "lemma b_accs_as_closed:\n  assumes A: \"bacc_step \\<delta> Q \\<subseteq> Q\"  \n  shows \"b_accessible \\<delta> \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_accessible \\<delta> \\<subseteq> Q", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> b_accessible \\<delta> \\<Longrightarrow> x \\<in> Q", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> b_accessible \\<delta> \\<Longrightarrow> x \\<in> Q", "assume \"q\\<in>b_accessible \\<delta>\""], ["proof (state)\nthis:\n  q \\<in> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> b_accessible \\<delta> \\<Longrightarrow> x \\<in> Q", "thus \"q\\<in>Q\""], ["proof (prove)\nusing this:\n  q \\<in> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. q \\<in> Q", "proof (induct rule: b_accessible.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q l qs.\n       \\<lbrakk>q \\<rightarrow> l qs \\<in> \\<delta>;\n        \\<And>x.\n           x \\<in> set qs \\<Longrightarrow> x \\<in> b_accessible \\<delta>;\n        \\<And>x. x \\<in> set qs \\<Longrightarrow> x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> Q", "fix q f qs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q l qs.\n       \\<lbrakk>q \\<rightarrow> l qs \\<in> \\<delta>;\n        \\<And>x.\n           x \\<in> set qs \\<Longrightarrow> x \\<in> b_accessible \\<delta>;\n        \\<And>x. x \\<in> set qs \\<Longrightarrow> x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> Q", "assume BC: \"(q\\<rightarrow>f qs)\\<in>\\<delta>\" \n               \"!!x. x\\<in>set qs \\<Longrightarrow> x\\<in>b_accessible \\<delta>\" \n               \"!!x. x\\<in>set qs \\<Longrightarrow> x\\<in>Q\""], ["proof (state)\nthis:\n  q \\<rightarrow> f qs \\<in> \\<delta>\n  ?x \\<in> set qs \\<Longrightarrow> ?x \\<in> b_accessible \\<delta>\n  ?x \\<in> set qs \\<Longrightarrow> ?x \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>q l qs.\n       \\<lbrakk>q \\<rightarrow> l qs \\<in> \\<delta>;\n        \\<And>x.\n           x \\<in> set qs \\<Longrightarrow> x \\<in> b_accessible \\<delta>;\n        \\<And>x. x \\<in> set qs \\<Longrightarrow> x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> Q", "from bacc_step.intros[OF BC(1)] BC(3)"], ["proof (chain)\npicking this:\n  set (rhsq q \\<rightarrow> f qs) \\<subseteq> ?Q \\<Longrightarrow>\n  lhs q \\<rightarrow> f qs \\<in> bacc_step \\<delta> ?Q\n  ?x \\<in> set qs \\<Longrightarrow> ?x \\<in> Q", "have \"q\\<in>bacc_step \\<delta> Q\""], ["proof (prove)\nusing this:\n  set (rhsq q \\<rightarrow> f qs) \\<subseteq> ?Q \\<Longrightarrow>\n  lhs q \\<rightarrow> f qs \\<in> bacc_step \\<delta> ?Q\n  ?x \\<in> set qs \\<Longrightarrow> ?x \\<in> Q\n\ngoal (1 subgoal):\n 1. q \\<in> bacc_step \\<delta> Q", "by auto"], ["proof (state)\nthis:\n  q \\<in> bacc_step \\<delta> Q\n\ngoal (1 subgoal):\n 1. \\<And>q l qs.\n       \\<lbrakk>q \\<rightarrow> l qs \\<in> \\<delta>;\n        \\<And>x.\n           x \\<in> set qs \\<Longrightarrow> x \\<in> b_accessible \\<delta>;\n        \\<And>x. x \\<in> set qs \\<Longrightarrow> x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> Q", "with A"], ["proof (chain)\npicking this:\n  bacc_step \\<delta> Q \\<subseteq> Q\n  q \\<in> bacc_step \\<delta> Q", "show \"q\\<in>Q\""], ["proof (prove)\nusing this:\n  bacc_step \\<delta> Q \\<subseteq> Q\n  q \\<in> bacc_step \\<delta> Q\n\ngoal (1 subgoal):\n 1. q \\<in> Q", "by blast"], ["proof (state)\nthis:\n  q \\<in> Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> Q\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Algorithms\""], ["", "text \\<open>\n  First, the basic workset algorithm is specified. \n  Then, it is refined to contain a counter for each rule, \n  that counts the number of undiscovered states on the RHS. \n  For both levels of abstraction, a version that computes the \n  backwards reduction, and a version that checks for emptiness is specified.\n\n  Additionally, a version of the algorithm that computes a witness\n  for non-emptiness is provided.\n  \n  Levels of abstraction:\n  \\begin{itemize} \n    \\item[\\<open>\\<alpha>\\<close>] On this level, the state consists of a set of \n      discovered states and a workset.\n    \\item[\\<open>\\<alpha>'\\<close>] On this level, the state consists of a set of \n      discovered states, a workset and a map from rules to number of \n      undiscovered rhs states. This map can be used to make the discovery of\n      rules that have to be considered more efficient.\n  \\end{itemize}\n\\<close>"], ["", "text_raw \\<open>\\paragraph {\\<open>\\<alpha>\\<close> - Level:}\\<close>\n\n  \\<comment> \\<open>A state contains the set of discovered states and a workset\\<close>"], ["", "type_synonym ('Q,'L) br_state = \"'Q set \\<times> 'Q set\"\n\n  \\<comment> \\<open>Set of states that are non-empty (accept a tree) after adding the \n  state $q$ to the set of discovered states\\<close>"], ["", "definition br_dsq \n  :: \"('Q,'L) ta_rule set \\<Rightarrow> 'Q \\<Rightarrow> ('Q,'L) br_state \\<Rightarrow> 'Q set\" \n  where  \n  \"br_dsq \\<delta> q == \\<lambda>(Q,W). { lhs r | r. r\\<in>\\<delta> \\<and> set (rhsq r) \\<subseteq> (Q-(W-{q})) }\"\n\n  \\<comment> \\<open>Description of a step: One state is removed from the workset, and all \n  new states that become non-empty due to this state are added to, both, \n  the workset and the set of discovered states\\<close>"], ["", "inductive_set br_step \n  :: \"('Q,'L) ta_rule set \\<Rightarrow> (('Q,'L) br_state \\<times> ('Q,'L) br_state) set\" \n  for \\<delta> where\n  \"\\<lbrakk>\n     q\\<in>W;\n     Q' = Q \\<union> br_dsq \\<delta> q (Q,W);\n     W' = W - {q} \\<union> (br_dsq \\<delta> q (Q,W) - Q)\n   \\<rbrakk> \\<Longrightarrow> ((Q,W),(Q',W'))\\<in>br_step \\<delta>\"\n\n  \\<comment> \\<open>Termination condition for backwards reduction: The workset is empty\\<close>"], ["", "definition br_cond :: \"('Q,'L) br_state set\" \n  where \"br_cond == {(Q,W). W\\<noteq>{}}\"\n\n  \\<comment> \\<open>Termination condition for emptiness check: \n      The workset is empty or a non-empty initial state has been discovered\\<close>"], ["", "definition bre_cond :: \"'Q set \\<Rightarrow> ('Q,'L) br_state set\" \n  where \"bre_cond Qi == {(Q,W). W\\<noteq>{} \\<and> (Qi\\<inter>Q={})}\"\n\n  \\<comment> \\<open>Set of all states that occur on the lhs of a constant-rule\\<close>"], ["", "definition br_iq :: \"('Q,'L) ta_rule set \\<Rightarrow> 'Q set\" \n  where \"br_iq \\<delta> == { lhs r | r. r\\<in>\\<delta> \\<and> rhsq r = [] }\"\n\n  \\<comment> \\<open>Initial state for the iteration\\<close>"], ["", "definition br_initial :: \"('Q,'L) ta_rule set \\<Rightarrow> ('Q,'L) br_state\" \n  where \"br_initial \\<delta> == (br_iq \\<delta>, br_iq \\<delta>)\"\n\n  \\<comment> \\<open>Invariant for the iteration: \n    \\begin{itemize}\n      \\item States on the workset have been discovered\n      \\item Only accessible states have been discovered\n      \\item If a state is non-empty due to a rule whose \n            rhs-states have been discovered and processed \n            (i.e. are in $Q-W$), then the lhs state of the \n            rule has also been discovered.\n      \\item The set of discovered states is finite\n    \\end{itemize}\\<close>"], ["", "definition br_invar :: \"('Q,'L) ta_rule set \\<Rightarrow> ('Q,'L) br_state set\" \n  where \"br_invar \\<delta> == {(Q,W). \n    W\\<subseteq>Q \\<and> \n    Q \\<subseteq> b_accessible \\<delta> \\<and> \n    bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> \n    finite Q}\""], ["", "definition \"br_algo \\<delta> == \\<lparr>\n  wa_cond = br_cond,\n  wa_step = br_step \\<delta>,\n  wa_initial = {br_initial \\<delta>},\n  wa_invar = br_invar \\<delta>\n\\<rparr>\""], ["", "definition \"bre_algo Qi \\<delta> == \\<lparr>\n  wa_cond = bre_cond Qi,\n  wa_step = br_step \\<delta>,\n  wa_initial = {br_initial \\<delta>},\n  wa_invar = br_invar \\<delta>\n\\<rparr>\"\n\n\n  \\<comment> \\<open>Termination: Either a new state is added, or the workset decreases.\\<close>"], ["", "definition \"br_termrel \\<delta> == \n  ({(Q',Q). Q \\<subset> Q' \\<and> Q' \\<subseteq> b_accessible \\<delta>}) <*lex*> finite_psubset\""], ["", "lemma bre_cond_imp_br_cond[intro, simp]: \"bre_cond Qi \\<subseteq> br_cond\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bre_cond Qi \\<subseteq> br_cond", "by (auto simp add: br_cond_def bre_cond_def)"], ["", "lemma br_termrel_wf[simp, intro!]: \"finite \\<delta> \\<Longrightarrow> wf (br_termrel \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow> wf (br_termrel \\<delta>)", "apply (unfold br_termrel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow>\n    wf ({(Q', Q).\n         Q \\<subset> Q' \\<and> Q' \\<subseteq> b_accessible \\<delta>} <*lex*>\n        finite_psubset)", "apply (auto simp add: wf_bounded_supset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>Only accessible states are discovered\\<close>"], ["", "lemma br_dsq_ss:\n  assumes A: \"(Q,W)\\<in>br_invar \\<delta>\" \"W \\<noteq> {}\" \"q\\<in>W\"\n  shows \"br_dsq \\<delta> q (Q,W) \\<subseteq> b_accessible \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> br_dsq \\<delta> q (Q, W) \\<Longrightarrow>\n       x \\<in> b_accessible \\<delta>", "fix q'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> br_dsq \\<delta> q (Q, W) \\<Longrightarrow>\n       x \\<in> b_accessible \\<delta>", "assume B: \"q'\\<in>br_dsq \\<delta> q (Q,W)\""], ["proof (state)\nthis:\n  q' \\<in> br_dsq \\<delta> q (Q, W)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> br_dsq \\<delta> q (Q, W) \\<Longrightarrow>\n       x \\<in> b_accessible \\<delta>", "then"], ["proof (chain)\npicking this:\n  q' \\<in> br_dsq \\<delta> q (Q, W)", "obtain r where \n    R: \"q' = lhs r\" \"r\\<in>\\<delta>\" and \n    S: \"set (rhsq r) \\<subseteq> (Q-(W-{q}))\""], ["proof (prove)\nusing this:\n  q' \\<in> br_dsq \\<delta> q (Q, W)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>q' = lhs r; r \\<in> \\<delta>;\n         set (rhsq r) \\<subseteq> Q - (W - {q})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold br_dsq_def) auto"], ["proof (state)\nthis:\n  q' = lhs r\n  r \\<in> \\<delta>\n  set (rhsq r) \\<subseteq> Q - (W - {q})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> br_dsq \\<delta> q (Q, W) \\<Longrightarrow>\n       x \\<in> b_accessible \\<delta>", "note S"], ["proof (state)\nthis:\n  set (rhsq r) \\<subseteq> Q - (W - {q})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> br_dsq \\<delta> q (Q, W) \\<Longrightarrow>\n       x \\<in> b_accessible \\<delta>", "also"], ["proof (state)\nthis:\n  set (rhsq r) \\<subseteq> Q - (W - {q})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> br_dsq \\<delta> q (Q, W) \\<Longrightarrow>\n       x \\<in> b_accessible \\<delta>", "have \"(Q-(W-{q})) \\<subseteq> b_accessible \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q - (W - {q}) \\<subseteq> b_accessible \\<delta>", "using A(1,3)"], ["proof (prove)\nusing this:\n  (Q, W) \\<in> br_invar \\<delta>\n  q \\<in> W\n\ngoal (1 subgoal):\n 1. Q - (W - {q}) \\<subseteq> b_accessible \\<delta>", "by (auto simp add: br_invar_def)"], ["proof (state)\nthis:\n  Q - (W - {q}) \\<subseteq> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> br_dsq \\<delta> q (Q, W) \\<Longrightarrow>\n       x \\<in> b_accessible \\<delta>", "finally"], ["proof (chain)\npicking this:\n  set (rhsq r) \\<subseteq> b_accessible \\<delta>", "show \"q'\\<in>b_accessible \\<delta>\""], ["proof (prove)\nusing this:\n  set (rhsq r) \\<subseteq> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. q' \\<in> b_accessible \\<delta>", "using R"], ["proof (prove)\nusing this:\n  set (rhsq r) \\<subseteq> b_accessible \\<delta>\n  q' = lhs r\n  r \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. q' \\<in> b_accessible \\<delta>", "by (cases r)\n  (auto intro: b_accessible.intros)"], ["proof (state)\nthis:\n  q' \\<in> b_accessible \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma br_step_in_termrel: \n  assumes A: \"\\<Sigma>\\<in>br_cond\" \"\\<Sigma>\\<in>br_invar \\<delta>\" \"(\\<Sigma>,\\<Sigma>')\\<in>br_step \\<delta>\"\n  shows \"(\\<Sigma>', \\<Sigma>)\\<in>br_termrel \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "obtain Q W Q' W' where \n    [simp]: \"\\<Sigma>=(Q,W)\" \"\\<Sigma>'=(Q',W')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q W Q' W'.\n        \\<lbrakk>\\<Sigma> = (Q, W); \\<Sigma>' = (Q', W')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \\<Sigma>, cases \\<Sigma>', auto)"], ["proof (state)\nthis:\n  \\<Sigma> = (Q, W)\n  \\<Sigma>' = (Q', W')\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "obtain q where \n    QIW: \"q\\<in>W\" and \n    ASSFMT[simp]: \"Q' = Q \\<union> br_dsq \\<delta> q (Q, W)\"\n                  \"W' = W - {q} \\<union> (br_dsq \\<delta> q (Q, W) - Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> W; Q' = Q \\<union> br_dsq \\<delta> q (Q, W);\n         W' = W - {q} \\<union> (br_dsq \\<delta> q (Q, W) - Q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: br_step.cases[OF A(3)[simplified]])"], ["proof (state)\nthis:\n  q \\<in> W\n  Q' = Q \\<union> br_dsq \\<delta> q (Q, W)\n  W' = W - {q} \\<union> (br_dsq \\<delta> q (Q, W) - Q)\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "from A(2)"], ["proof (chain)\npicking this:\n  \\<Sigma> \\<in> br_invar \\<delta>", "have [simp]: \"finite Q\""], ["proof (prove)\nusing this:\n  \\<Sigma> \\<in> br_invar \\<delta>\n\ngoal (1 subgoal):\n 1. finite Q", "by (auto simp add: br_invar_def)"], ["proof (state)\nthis:\n  finite Q\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "from A(2)[unfolded br_invar_def]"], ["proof (chain)\npicking this:\n  \\<Sigma>\n  \\<in> {(Q, W).\n         W \\<subseteq> Q \\<and>\n         Q \\<subseteq> b_accessible \\<delta> \\<and>\n         bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q}", "have [simp]: \"finite W\""], ["proof (prove)\nusing this:\n  \\<Sigma>\n  \\<in> {(Q, W).\n         W \\<subseteq> Q \\<and>\n         Q \\<subseteq> b_accessible \\<delta> \\<and>\n         bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q}\n\ngoal (1 subgoal):\n 1. finite W", "by (auto simp add: finite_subset)"], ["proof (state)\nthis:\n  finite W\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "from A(1)"], ["proof (chain)\npicking this:\n  \\<Sigma> \\<in> br_cond", "have WNE: \"W\\<noteq>{}\""], ["proof (prove)\nusing this:\n  \\<Sigma> \\<in> br_cond\n\ngoal (1 subgoal):\n 1. W \\<noteq> {}", "by (unfold br_cond_def) auto"], ["proof (state)\nthis:\n  W \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "note DSQSS = br_dsq_ss[OF A(2)[simplified] WNE QIW]"], ["proof (state)\nthis:\n  br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "{"], ["proof (state)\nthis:\n  br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "assume \"br_dsq \\<delta> q (Q,W) - Q = {}\""], ["proof (state)\nthis:\n  br_dsq \\<delta> q (Q, W) - Q = {}\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "hence ?thesis"], ["proof (prove)\nusing this:\n  br_dsq \\<delta> q (Q, W) - Q = {}\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "using QIW"], ["proof (prove)\nusing this:\n  br_dsq \\<delta> q (Q, W) - Q = {}\n  q \\<in> W\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "by (simp add: br_termrel_def set_simps)"], ["proof (state)\nthis:\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "}"], ["proof (state)\nthis:\n  br_dsq \\<delta> q (Q, W) - Q = {} \\<Longrightarrow>\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "moreover"], ["proof (state)\nthis:\n  br_dsq \\<delta> q (Q, W) - Q = {} \\<Longrightarrow>\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "{"], ["proof (state)\nthis:\n  br_dsq \\<delta> q (Q, W) - Q = {} \\<Longrightarrow>\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "assume \"br_dsq \\<delta> q (Q,W) - Q \\<noteq> {}\""], ["proof (state)\nthis:\n  br_dsq \\<delta> q (Q, W) - Q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "hence \"Q \\<subset> Q'\""], ["proof (prove)\nusing this:\n  br_dsq \\<delta> q (Q, W) - Q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q \\<subset> Q'", "by auto"], ["proof (state)\nthis:\n  Q \\<subset> Q'\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "moreover"], ["proof (state)\nthis:\n  Q \\<subset> Q'\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "from DSQSS A(2)[unfolded br_invar_def]"], ["proof (chain)\npicking this:\n  br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>\n  \\<Sigma>\n  \\<in> {(Q, W).\n         W \\<subseteq> Q \\<and>\n         Q \\<subseteq> b_accessible \\<delta> \\<and>\n         bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q}", "have \n      \"Q' \\<subseteq> b_accessible \\<delta>\""], ["proof (prove)\nusing this:\n  br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>\n  \\<Sigma>\n  \\<in> {(Q, W).\n         W \\<subseteq> Q \\<and>\n         Q \\<subseteq> b_accessible \\<delta> \\<and>\n         bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q}\n\ngoal (1 subgoal):\n 1. Q' \\<subseteq> b_accessible \\<delta>", "by auto"], ["proof (state)\nthis:\n  Q' \\<subseteq> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "ultimately"], ["proof (chain)\npicking this:\n  Q \\<subset> Q'\n  Q' \\<subseteq> b_accessible \\<delta>", "have ?thesis"], ["proof (prove)\nusing this:\n  Q \\<subset> Q'\n  Q' \\<subseteq> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "by (auto simp add: br_termrel_def)"], ["proof (state)\nthis:\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "}"], ["proof (state)\nthis:\n  br_dsq \\<delta> q (Q, W) - Q \\<noteq> {} \\<Longrightarrow>\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "ultimately"], ["proof (chain)\npicking this:\n  br_dsq \\<delta> q (Q, W) - Q = {} \\<Longrightarrow>\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>\n  br_dsq \\<delta> q (Q, W) - Q \\<noteq> {} \\<Longrightarrow>\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  br_dsq \\<delta> q (Q, W) - Q = {} \\<Longrightarrow>\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>\n  br_dsq \\<delta> q (Q, W) - Q \\<noteq> {} \\<Longrightarrow>\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>", "by blast"], ["proof (state)\nthis:\n  (\\<Sigma>', \\<Sigma>) \\<in> br_termrel \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma br_invar_initial[simp]: \"finite \\<delta> \\<Longrightarrow> (br_initial \\<delta>)\\<in>br_invar \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow>\n    br_initial \\<delta> \\<in> br_invar \\<delta>", "apply (auto simp add: br_initial_def br_invar_def br_iq_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>finite \\<delta>; r \\<in> \\<delta>; rhsq r = []\\<rbrakk>\n       \\<Longrightarrow> lhs r \\<in> b_accessible \\<delta>\n 2. \\<And>x.\n       \\<lbrakk>finite \\<delta>; x \\<in> bacc_step \\<delta> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            x = lhs r \\<and>\n                            r \\<in> \\<delta> \\<and> rhsq r = []", "apply (case_tac r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r x1 x2 x3.\n       \\<lbrakk>finite \\<delta>; r \\<in> \\<delta>; rhsq r = [];\n        r = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> lhs r \\<in> b_accessible \\<delta>\n 2. \\<And>x.\n       \\<lbrakk>finite \\<delta>; x \\<in> bacc_step \\<delta> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            x = lhs r \\<and>\n                            r \\<in> \\<delta> \\<and> rhsq r = []", "apply (fastforce intro: b_accessible.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite \\<delta>; x \\<in> bacc_step \\<delta> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            x = lhs r \\<and>\n                            r \\<in> \\<delta> \\<and> rhsq r = []", "apply (fastforce elim!: bacc_step.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma br_invar_step: \n  assumes [simp]: \"finite \\<delta>\"\n  assumes A: \"\\<Sigma>\\<in>br_cond\" \"\\<Sigma>\\<in>br_invar \\<delta>\" \"(\\<Sigma>,\\<Sigma>')\\<in>br_step \\<delta>\"\n  shows \"\\<Sigma>'\\<in>br_invar \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br_invar \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br_invar \\<delta>", "obtain Q W Q' W' where SF[simp]: \"\\<Sigma>=(Q,W)\" \"\\<Sigma>'=(Q',W')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q W Q' W'.\n        \\<lbrakk>\\<Sigma> = (Q, W); \\<Sigma>' = (Q', W')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \\<Sigma>, cases \\<Sigma>', auto)"], ["proof (state)\nthis:\n  \\<Sigma> = (Q, W)\n  \\<Sigma>' = (Q', W')\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br_invar \\<delta>", "obtain q where \n    QIW: \"q\\<in>W\" and \n    ASSFMT[simp]: \"Q' = Q \\<union> br_dsq \\<delta> q (Q, W)\"\n                  \"W' = W - {q} \\<union> (br_dsq \\<delta> q (Q, W) - Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> W; Q' = Q \\<union> br_dsq \\<delta> q (Q, W);\n         W' = W - {q} \\<union> (br_dsq \\<delta> q (Q, W) - Q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: br_step.cases[OF A(3)[simplified]])"], ["proof (state)\nthis:\n  q \\<in> W\n  Q' = Q \\<union> br_dsq \\<delta> q (Q, W)\n  W' = W - {q} \\<union> (br_dsq \\<delta> q (Q, W) - Q)\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br_invar \\<delta>", "from A(1)"], ["proof (chain)\npicking this:\n  \\<Sigma> \\<in> br_cond", "have WNE: \"W\\<noteq>{}\""], ["proof (prove)\nusing this:\n  \\<Sigma> \\<in> br_cond\n\ngoal (1 subgoal):\n 1. W \\<noteq> {}", "by (unfold br_cond_def) auto"], ["proof (state)\nthis:\n  W \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br_invar \\<delta>", "have DSQSS: \"br_dsq \\<delta> q (Q,W) \\<subseteq> b_accessible \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>", "using br_dsq_ss[OF A(2)[simplified] WNE QIW]"], ["proof (prove)\nusing this:\n  br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>", "."], ["proof (state)\nthis:\n  br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br_invar \\<delta>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br_invar \\<delta>", "apply (simp add: br_invar_def del: ASSFMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. W' \\<subseteq> Q' \\<and>\n    Q' \\<subseteq> b_accessible \\<delta> \\<and>\n    bacc_step \\<delta> (Q' - W') \\<subseteq> Q' \\<and> finite Q'", "proof (intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. W' \\<subseteq> Q'\n 2. Q' \\<subseteq> b_accessible \\<delta>\n 3. bacc_step \\<delta> (Q' - W') \\<subseteq> Q'\n 4. finite Q'", "from A(2)"], ["proof (chain)\npicking this:\n  \\<Sigma> \\<in> br_invar \\<delta>", "have \"W \\<subseteq> Q\""], ["proof (prove)\nusing this:\n  \\<Sigma> \\<in> br_invar \\<delta>\n\ngoal (1 subgoal):\n 1. W \\<subseteq> Q", "by (simp add: br_invar_def)"], ["proof (state)\nthis:\n  W \\<subseteq> Q\n\ngoal (4 subgoals):\n 1. W' \\<subseteq> Q'\n 2. Q' \\<subseteq> b_accessible \\<delta>\n 3. bacc_step \\<delta> (Q' - W') \\<subseteq> Q'\n 4. finite Q'", "thus \"W' \\<subseteq> Q'\""], ["proof (prove)\nusing this:\n  W \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. W' \\<subseteq> Q'", "by auto"], ["proof (state)\nthis:\n  W' \\<subseteq> Q'\n\ngoal (3 subgoals):\n 1. Q' \\<subseteq> b_accessible \\<delta>\n 2. bacc_step \\<delta> (Q' - W') \\<subseteq> Q'\n 3. finite Q'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Q' \\<subseteq> b_accessible \\<delta>\n 2. bacc_step \\<delta> (Q' - W') \\<subseteq> Q'\n 3. finite Q'", "from A(2)"], ["proof (chain)\npicking this:\n  \\<Sigma> \\<in> br_invar \\<delta>", "have \"Q \\<subseteq> b_accessible \\<delta>\""], ["proof (prove)\nusing this:\n  \\<Sigma> \\<in> br_invar \\<delta>\n\ngoal (1 subgoal):\n 1. Q \\<subseteq> b_accessible \\<delta>", "by (simp add: br_invar_def)"], ["proof (state)\nthis:\n  Q \\<subseteq> b_accessible \\<delta>\n\ngoal (3 subgoals):\n 1. Q' \\<subseteq> b_accessible \\<delta>\n 2. bacc_step \\<delta> (Q' - W') \\<subseteq> Q'\n 3. finite Q'", "with DSQSS"], ["proof (chain)\npicking this:\n  br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>\n  Q \\<subseteq> b_accessible \\<delta>", "show \"Q' \\<subseteq> b_accessible \\<delta>\""], ["proof (prove)\nusing this:\n  br_dsq \\<delta> q (Q, W) \\<subseteq> b_accessible \\<delta>\n  Q \\<subseteq> b_accessible \\<delta>\n\ngoal (1 subgoal):\n 1. Q' \\<subseteq> b_accessible \\<delta>", "by auto"], ["proof (state)\nthis:\n  Q' \\<subseteq> b_accessible \\<delta>\n\ngoal (2 subgoals):\n 1. bacc_step \\<delta> (Q' - W') \\<subseteq> Q'\n 2. finite Q'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. bacc_step \\<delta> (Q' - W') \\<subseteq> Q'\n 2. finite Q'", "show \"bacc_step \\<delta> (Q' - W') \\<subseteq> Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bacc_step \\<delta> (Q' - W') \\<subseteq> Q'", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> bacc_step \\<delta> (Q' - W') \\<Longrightarrow> x \\<in> Q'", "apply (erule bacc_step.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>x = lhs r; r \\<in> \\<delta>;\n        set (rhsq r) \\<subseteq> Q' - W'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Q'", "apply (auto simp add: br_dsq_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bacc_step \\<delta> (Q' - W') \\<subseteq> Q'\n\ngoal (1 subgoal):\n 1. finite Q'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite Q'", "show \"finite Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Q'", "using A(2)"], ["proof (prove)\nusing this:\n  \\<Sigma> \\<in> br_invar \\<delta>\n\ngoal (1 subgoal):\n 1. finite Q'", "by (simp add: br_invar_def br_dsq_def)"], ["proof (state)\nthis:\n  finite Q'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Sigma>' \\<in> br_invar \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma br_invar_final:\n  \"\\<forall>\\<Sigma>. \\<Sigma>\\<in>wa_invar (br_algo \\<delta>) \\<and> \\<Sigma>\\<notin>wa_cond (br_algo \\<delta>) \n   \\<longrightarrow> fst \\<Sigma> = b_accessible \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Sigma>.\n       \\<Sigma> \\<in> wa_invar (br_algo \\<delta>) \\<and>\n       \\<Sigma> \\<notin> wa_cond (br_algo \\<delta>) \\<longrightarrow>\n       fst \\<Sigma> = b_accessible \\<delta>", "apply (simp add: br_invar_def br_cond_def br_algo_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       a \\<subseteq> b_accessible \\<delta> \\<and>\n       bacc_step \\<delta> a \\<subseteq> a \\<and> finite a \\<longrightarrow>\n       a = b_accessible \\<delta>", "apply (auto intro: rev_subsetD[OF _ b_accs_as_closed])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*  shows \"\\<lbrakk>(Q,W)\\<in>br_invar \\<delta>; (Q,W)\\<notin>br_cond\\<rbrakk> \\<Longrightarrow> Q = b_accessible \\<delta>\"\n  apply (simp add: br_invar_def br_cond_def)\n  apply (auto intro: rev_subsetD[OF _ b_accs_as_closed])\n  done*)"], ["", "theorem br_while_algo: \n  assumes FIN[simp]: \"finite \\<delta>\"\n  shows \"while_algo (br_algo \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (br_algo \\<delta>)", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (br_algo \\<delta>);\n        s \\<in> wa_cond (br_algo \\<delta>);\n        (s, s') \\<in> wa_step (br_algo \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> wa_invar (br_algo \\<delta>)\n 2. wa_initial (br_algo \\<delta>) \\<subseteq> wa_invar (br_algo \\<delta>)\n 3. wf {(s', s).\n        s \\<in> wa_invar (br_algo \\<delta>) \\<and>\n        s \\<in> wa_cond (br_algo \\<delta>) \\<and>\n        (s, s') \\<in> wa_step (br_algo \\<delta>)}", "apply (simp_all add: br_algo_def br_invar_step br_invar_initial \n                       br_step_in_termrel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(s', s).\n        s \\<in> br_invar \\<delta> \\<and>\n        s \\<in> br_cond \\<and> (s, s') \\<in> br_step \\<delta>}", "apply (rule_tac r=\"br_termrel \\<delta>\" in wf_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (br_termrel \\<delta>)\n 2. {(s', s).\n     s \\<in> br_invar \\<delta> \\<and>\n     s \\<in> br_cond \\<and> (s, s') \\<in> br_step \\<delta>}\n    \\<subseteq> br_termrel \\<delta>", "apply (auto intro: br_step_in_termrel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bre_invar_final:\n  \"\\<forall>\\<Sigma>. \\<Sigma>\\<in>wa_invar (bre_algo Qi \\<delta>) \\<and> \\<Sigma>\\<notin>wa_cond (bre_algo Qi \\<delta>) \n     \\<longrightarrow> ((Qi\\<inter>fst \\<Sigma>={}) \\<longleftrightarrow> (Qi \\<inter> b_accessible \\<delta> = {}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Sigma>.\n       \\<Sigma> \\<in> wa_invar (bre_algo Qi \\<delta>) \\<and>\n       \\<Sigma> \\<notin> wa_cond (bre_algo Qi \\<delta>) \\<longrightarrow>\n       (Qi \\<inter> fst \\<Sigma> = {}) =\n       (Qi \\<inter> b_accessible \\<delta> = {})", "apply (simp add: br_invar_def bre_cond_def bre_algo_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       (\\<exists>b\\<subseteq>a.\n           a \\<subseteq> b_accessible \\<delta> \\<and>\n           bacc_step \\<delta> (a - b) \\<subseteq> a \\<and>\n           finite a \\<and>\n           (b = {} \\<or> Qi \\<inter> a \\<noteq> {})) \\<longrightarrow>\n       (Qi \\<inter> a = {}) = (Qi \\<inter> b_accessible \\<delta> = {})", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>{} \\<subseteq> a; a \\<subseteq> b_accessible \\<delta>;\n        bacc_step \\<delta> (a - {}) \\<subseteq> a; finite a;\n        Qi \\<inter> a = {}; x \\<in> Qi;\n        x \\<in> b_accessible \\<delta>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}\n 2. \\<And>a b x.\n       \\<lbrakk>{} \\<subseteq> a; a \\<subseteq> b_accessible \\<delta>;\n        bacc_step \\<delta> (a - {}) \\<subseteq> a; finite a;\n        Qi \\<inter> b_accessible \\<delta> = {}; x \\<in> Qi;\n        x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {}\n 3. \\<And>a b x xa.\n       \\<lbrakk>b \\<subseteq> a; a \\<subseteq> b_accessible \\<delta>;\n        bacc_step \\<delta> (a - b) \\<subseteq> a; finite a; x \\<in> Qi;\n        x \\<in> a; x \\<notin> {}; Qi \\<inter> a = {}; xa \\<in> Qi;\n        xa \\<in> b_accessible \\<delta>\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}\n 4. \\<And>a b x xa.\n       \\<lbrakk>b \\<subseteq> a; a \\<subseteq> b_accessible \\<delta>;\n        bacc_step \\<delta> (a - b) \\<subseteq> a; finite a; x \\<in> Qi;\n        x \\<in> a; x \\<notin> {}; Qi \\<inter> b_accessible \\<delta> = {};\n        xa \\<in> Qi; xa \\<in> a\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "apply (auto dest!: b_accs_as_closed)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem bre_while_algo:\n  assumes FIN[simp]: \"finite \\<delta>\"\n  shows \"while_algo (bre_algo Qi \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (bre_algo Qi \\<delta>)", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (bre_algo Qi \\<delta>);\n        s \\<in> wa_cond (bre_algo Qi \\<delta>);\n        (s, s') \\<in> wa_step (bre_algo Qi \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> wa_invar (bre_algo Qi \\<delta>)\n 2. wa_initial (bre_algo Qi \\<delta>)\n    \\<subseteq> wa_invar (bre_algo Qi \\<delta>)\n 3. wf {(s', s).\n        s \\<in> wa_invar (bre_algo Qi \\<delta>) \\<and>\n        s \\<in> wa_cond (bre_algo Qi \\<delta>) \\<and>\n        (s, s') \\<in> wa_step (bre_algo Qi \\<delta>)}", "apply (unfold bre_algo_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar\n                         \\<lparr>wa_cond = bre_cond Qi,\n                            wa_step = br_step \\<delta>,\n                            wa_initial = {br_initial \\<delta>},\n                            wa_invar = br_invar \\<delta>\\<rparr>;\n        s \\<in> wa_cond\n                 \\<lparr>wa_cond = bre_cond Qi, wa_step = br_step \\<delta>,\n                    wa_initial = {br_initial \\<delta>},\n                    wa_invar = br_invar \\<delta>\\<rparr>;\n        (s, s')\n        \\<in> wa_step\n               \\<lparr>wa_cond = bre_cond Qi, wa_step = br_step \\<delta>,\n                  wa_initial = {br_initial \\<delta>},\n                  wa_invar = br_invar \\<delta>\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> wa_invar\n                                   \\<lparr>wa_cond = bre_cond Qi,\nwa_step = br_step \\<delta>, wa_initial = {br_initial \\<delta>},\nwa_invar = br_invar \\<delta>\\<rparr>\n 2. wa_initial\n     \\<lparr>wa_cond = bre_cond Qi, wa_step = br_step \\<delta>,\n        wa_initial = {br_initial \\<delta>},\n        wa_invar = br_invar \\<delta>\\<rparr>\n    \\<subseteq> wa_invar\n                 \\<lparr>wa_cond = bre_cond Qi, wa_step = br_step \\<delta>,\n                    wa_initial = {br_initial \\<delta>},\n                    wa_invar = br_invar \\<delta>\\<rparr>\n 3. wf {(s', s).\n        s \\<in> wa_invar\n                 \\<lparr>wa_cond = bre_cond Qi, wa_step = br_step \\<delta>,\n                    wa_initial = {br_initial \\<delta>},\n                    wa_invar = br_invar \\<delta>\\<rparr> \\<and>\n        s \\<in> wa_cond\n                 \\<lparr>wa_cond = bre_cond Qi, wa_step = br_step \\<delta>,\n                    wa_initial = {br_initial \\<delta>},\n                    wa_invar = br_invar \\<delta>\\<rparr> \\<and>\n        (s, s')\n        \\<in> wa_step\n               \\<lparr>wa_cond = bre_cond Qi, wa_step = br_step \\<delta>,\n                  wa_initial = {br_initial \\<delta>},\n                  wa_invar = br_invar \\<delta>\\<rparr>}", "apply (auto simp add: br_invar_initial br_step_in_termrel\n    intro: br_invar_step \n    dest: rev_subsetD[OF _ bre_cond_imp_br_cond])"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(s', s).\n        s \\<in> br_invar \\<delta> \\<and>\n        s \\<in> bre_cond Qi \\<and> (s, s') \\<in> br_step \\<delta>}", "apply (rule_tac r=\"br_termrel \\<delta>\" in wf_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (br_termrel \\<delta>)\n 2. {(s', s).\n     s \\<in> br_invar \\<delta> \\<and>\n     s \\<in> bre_cond Qi \\<and> (s, s') \\<in> br_step \\<delta>}\n    \\<subseteq> br_termrel \\<delta>", "apply (auto intro: br_step_in_termrel\n              dest: rev_subsetD[OF _ bre_cond_imp_br_cond])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text_raw \\<open>\\paragraph{\\<open>\\<alpha>'\\<close> - Level}\\<close>"], ["", "text \\<open>\n  Here, an optimization is added:\n    For each rule, the algorithm now maintains a counter that counts the number\n    of undiscovered states on the rules RHS. Whenever a new state is discovered,\n    this counter is decremented for all rules where the state occurs on the RHS.\n    The LHS states of rules where the counter falls to 0 are added to the \n    worklist. The idea is that decrementing the counter is more efficient than \n    checking whether all states on the rule's RHS have been discovered.\n\n  A similar algorithm is sketched in \\cite{tata2007}(Exercise~1.18).\n\\<close>"], ["", "type_synonym ('Q,'L) br'_state = \"'Q set \\<times> 'Q set \\<times> (('Q,'L) ta_rule \\<rightharpoonup> nat)\"\n\n  \\<comment> \\<open>Abstraction to @{text \\<alpha>}-level\\<close>"], ["", "definition br'_\\<alpha> :: \"('Q,'L) br'_state \\<Rightarrow> ('Q,'L) br_state\" \n  where \"br'_\\<alpha> = (\\<lambda>(Q,W,rcm). (Q,W))\""], ["", "definition br'_invar_add :: \"('Q,'L) ta_rule set \\<Rightarrow> ('Q,'L) br'_state set\"\n  where \"br'_invar_add \\<delta> == {(Q,W,rcm). \n    (\\<forall>r\\<in>\\<delta>. rcm r = Some (card (set (rhsq r) - (Q - W)))) \\<and> \n    {lhs r | r. r\\<in>\\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\n  }\""], ["", "definition br'_invar :: \"('Q,'L) ta_rule set \\<Rightarrow> ('Q,'L) br'_state set\"\n  where \"br'_invar \\<delta> == br'_invar_add \\<delta> \\<inter> {\\<Sigma>. br'_\\<alpha> \\<Sigma> \\<in> br_invar \\<delta>}\""], ["", "inductive_set br'_step \n  :: \"('Q,'L) ta_rule set \\<Rightarrow> (('Q,'L) br'_state \\<times> ('Q,'L) br'_state) set\" \n  for \\<delta> where\n  \"\\<lbrakk> q\\<in>W;\n     Q' = Q \\<union> { lhs r | r. r\\<in>\\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1 };\n     W' = (W-{q}) \n          \\<union> ({ lhs r | r. r\\<in>\\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1 } \n              - Q);\n     !!r. r\\<in>\\<delta> \\<Longrightarrow> rcm' r = ( if q \\<in> set (rhsq r) then \n                               Some (the (rcm r) - 1) \n                             else rcm r\n                           )\n   \\<rbrakk> \\<Longrightarrow> ((Q,W,rcm),(Q',W',rcm')) \\<in> br'_step \\<delta>\""], ["", "definition br'_cond :: \"('Q,'L) br'_state set\" \n  where \"br'_cond == {(Q,W,rcm). W\\<noteq>{}}\""], ["", "definition bre'_cond :: \"'Q set \\<Rightarrow> ('Q,'L) br'_state set\" \n  where \"bre'_cond Qi == {(Q,W,rcm). W\\<noteq>{} \\<and> (Qi\\<inter>Q={})}\""], ["", "inductive_set br'_initial :: \"('Q,'L) ta_rule set \\<Rightarrow> ('Q,'L) br'_state set\" \n  for \\<delta> where\n  \"\\<lbrakk> !!r. r\\<in>\\<delta> \\<Longrightarrow> rcm r = Some (card (set (rhsq r))) \\<rbrakk> \n     \\<Longrightarrow> (br_iq \\<delta>, br_iq \\<delta>, rcm)\\<in>br'_initial \\<delta>\""], ["", "definition \"br'_algo \\<delta> == \\<lparr>\n  wa_cond=br'_cond,\n  wa_step = br'_step \\<delta>,\n  wa_initial = br'_initial \\<delta>,\n  wa_invar = br'_invar \\<delta>\n\\<rparr>\""], ["", "definition \"bre'_algo Qi \\<delta> == \\<lparr>\n  wa_cond=bre'_cond Qi,\n  wa_step = br'_step \\<delta>,\n  wa_initial = br'_initial \\<delta>,\n  wa_invar = br'_invar \\<delta>\n\\<rparr>\""], ["", "lemma br'_step_invar: \n  assumes finite[simp]: \"finite \\<delta>\"\n  assumes INV: \"\\<Sigma>\\<in>br'_invar_add \\<delta>\" \"br'_\\<alpha> \\<Sigma> \\<in> br_invar \\<delta>\"\n  assumes STEP: \"(\\<Sigma>,\\<Sigma>') \\<in> br'_step \\<delta>\"\n  shows \"\\<Sigma>'\\<in>br'_invar_add \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "obtain Q W rcm where [simp]: \"\\<Sigma>=(Q,W,rcm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q W rcm.\n        \\<Sigma> = (Q, W, rcm) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \\<Sigma>) auto"], ["proof (state)\nthis:\n  \\<Sigma> = (Q, W, rcm)\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "obtain Q' W' rcm' where [simp]: \"\\<Sigma>'=(Q',W',rcm')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q' W' rcm'.\n        \\<Sigma>' = (Q', W', rcm') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \\<Sigma>') auto"], ["proof (state)\nthis:\n  \\<Sigma>' = (Q', W', rcm')\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "from STEP"], ["proof (chain)\npicking this:\n  (\\<Sigma>, \\<Sigma>') \\<in> br'_step \\<delta>", "obtain q where\n    STEPF:\n    \"q\\<in>W\"\n    \"Q' = Q \\<union> { lhs r | r. r\\<in>\\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1 }\"\n    \"W' = (W-{q}) \n          \\<union> ({ lhs r | r. r\\<in>\\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1 } \n              - Q)\"\n    \"!!r. r\\<in>\\<delta> \\<Longrightarrow> rcm' r = ( if q \\<in> set (rhsq r) then \n                               Some (the (rcm r) - 1) \n                             else rcm r\n                           )\""], ["proof (prove)\nusing this:\n  (\\<Sigma>, \\<Sigma>') \\<in> br'_step \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> W;\n         Q' =\n         Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1};\n         W' =\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1} -\n          Q);\n         \\<And>r.\n            r \\<in> \\<delta> \\<Longrightarrow>\n            rcm' r =\n            (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n             else rcm r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: br'_step.cases)"], ["proof (state)\nthis:\n  q \\<in> W\n  Q' =\n  Q \\<union>\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n  W' =\n  W - {q} \\<union>\n  ({lhs r |r.\n    r \\<in> \\<delta> \\<and>\n    q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1} -\n   Q)\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "from INV[unfolded br'_invar_def br_invar_def br'_invar_add_def br'_\\<alpha>_def, \n           simplified]"], ["proof (chain)\npicking this:\n  (\\<forall>r\\<in>\\<delta>.\n      rcm r = Some (card (set (rhsq r) - (Q - W)))) \\<and>\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\n  W \\<subseteq> Q \\<and>\n  Q \\<subseteq> b_accessible \\<delta> \\<and>\n  bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q", "have INV:\n    \"(\\<forall>r\\<in>\\<delta>. rcm r = Some (card (set (rhsq r) - (Q - W))))\" \n    \"{lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\" \n    \"W \\<subseteq> Q\" \n    \"Q \\<subseteq> b_accessible \\<delta>\" \n    \"bacc_step \\<delta> (Q - W) \\<subseteq> Q\" \n    \"finite Q\""], ["proof (prove)\nusing this:\n  (\\<forall>r\\<in>\\<delta>.\n      rcm r = Some (card (set (rhsq r) - (Q - W)))) \\<and>\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\n  W \\<subseteq> Q \\<and>\n  Q \\<subseteq> b_accessible \\<delta> \\<and>\n  bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q\n\ngoal (1 subgoal):\n 1. (\\<forall>r\\<in>\\<delta>.\n        rcm r = Some (card (set (rhsq r) - (Q - W))) &&&\n     {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q &&&\n     W \\<subseteq> Q) &&&\n    Q \\<subseteq> b_accessible \\<delta> &&&\n    bacc_step \\<delta> (Q - W) \\<subseteq> Q &&& finite Q", "by auto"], ["proof (state)\nthis:\n  \\<forall>r\\<in>\\<delta>. rcm r = Some (card (set (rhsq r) - (Q - W)))\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\n  W \\<subseteq> Q\n  Q \\<subseteq> b_accessible \\<delta>\n  bacc_step \\<delta> (Q - W) \\<subseteq> Q\n  finite Q\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "{"], ["proof (state)\nthis:\n  \\<forall>r\\<in>\\<delta>. rcm r = Some (card (set (rhsq r) - (Q - W)))\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\n  W \\<subseteq> Q\n  Q \\<subseteq> b_accessible \\<delta>\n  bacc_step \\<delta> (Q - W) \\<subseteq> Q\n  finite Q\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "assume A: \"r\\<in>\\<delta>\""], ["proof (state)\nthis:\n  r \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "with INV(1)"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>\\<delta>. rcm r = Some (card (set (rhsq r) - (Q - W)))\n  r \\<in> \\<delta>", "have RCMR: \"rcm r = Some (card (set (rhsq r) - (Q - W)))\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>\\<delta>. rcm r = Some (card (set (rhsq r) - (Q - W)))\n  r \\<in> \\<delta>\n\ngoal (1 subgoal):\n 1. rcm r = Some (card (set (rhsq r) - (Q - W)))", "by auto"], ["proof (state)\nthis:\n  rcm r = Some (card (set (rhsq r) - (Q - W)))\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "have \"rcm' r = Some (card (set (rhsq r) - (Q' - W')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "proof (cases \"q\\<in>set (rhsq r)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))\n 2. q \\<notin> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "case False"], ["proof (state)\nthis:\n  q \\<notin> set (rhsq r)\n\ngoal (2 subgoals):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))\n 2. q \\<notin> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "with A STEPF(4)"], ["proof (chain)\npicking this:\n  r \\<in> \\<delta>\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  q \\<notin> set (rhsq r)", "have \"rcm' r = rcm r\""], ["proof (prove)\nusing this:\n  r \\<in> \\<delta>\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  q \\<notin> set (rhsq r)\n\ngoal (1 subgoal):\n 1. rcm' r = rcm r", "by auto"], ["proof (state)\nthis:\n  rcm' r = rcm r\n\ngoal (2 subgoals):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))\n 2. q \\<notin> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "moreover"], ["proof (state)\nthis:\n  rcm' r = rcm r\n\ngoal (2 subgoals):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))\n 2. q \\<notin> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "from STEPF INV(3) False"], ["proof (chain)\npicking this:\n  q \\<in> W\n  Q' =\n  Q \\<union>\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n  W' =\n  W - {q} \\<union>\n  ({lhs r |r.\n    r \\<in> \\<delta> \\<and>\n    q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1} -\n   Q)\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  W \\<subseteq> Q\n  q \\<notin> set (rhsq r)", "have \n        \"set (rhsq r) - (Q-W) = set (rhsq r) - (Q'-W')\""], ["proof (prove)\nusing this:\n  q \\<in> W\n  Q' =\n  Q \\<union>\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n  W' =\n  W - {q} \\<union>\n  ({lhs r |r.\n    r \\<in> \\<delta> \\<and>\n    q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1} -\n   Q)\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  W \\<subseteq> Q\n  q \\<notin> set (rhsq r)\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = set (rhsq r) - (Q' - W')", "by auto"], ["proof (state)\nthis:\n  set (rhsq r) - (Q - W) = set (rhsq r) - (Q' - W')\n\ngoal (2 subgoals):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))\n 2. q \\<notin> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "ultimately"], ["proof (chain)\npicking this:\n  rcm' r = rcm r\n  set (rhsq r) - (Q - W) = set (rhsq r) - (Q' - W')", "show ?thesis"], ["proof (prove)\nusing this:\n  rcm' r = rcm r\n  set (rhsq r) - (Q - W) = set (rhsq r) - (Q' - W')\n\ngoal (1 subgoal):\n 1. rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "by (simp add: RCMR)"], ["proof (state)\nthis:\n  rcm' r = Some (card (set (rhsq r) - (Q' - W')))\n\ngoal (1 subgoal):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "case True"], ["proof (state)\nthis:\n  q \\<in> set (rhsq r)\n\ngoal (1 subgoal):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "with A STEPF(4) RCMR"], ["proof (chain)\npicking this:\n  r \\<in> \\<delta>\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  rcm r = Some (card (set (rhsq r) - (Q - W)))\n  q \\<in> set (rhsq r)", "have \n        \"rcm' r = Some ((card (set (rhsq r) - (Q - W))) - 1)\""], ["proof (prove)\nusing this:\n  r \\<in> \\<delta>\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  rcm r = Some (card (set (rhsq r) - (Q - W)))\n  q \\<in> set (rhsq r)\n\ngoal (1 subgoal):\n 1. rcm' r = Some (card (set (rhsq r) - (Q - W)) - 1)", "by simp"], ["proof (state)\nthis:\n  rcm' r = Some (card (set (rhsq r) - (Q - W)) - 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "moreover"], ["proof (state)\nthis:\n  rcm' r = Some (card (set (rhsq r) - (Q - W)) - 1)\n\ngoal (1 subgoal):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "from STEPF INV(3) True"], ["proof (chain)\npicking this:\n  q \\<in> W\n  Q' =\n  Q \\<union>\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n  W' =\n  W - {q} \\<union>\n  ({lhs r |r.\n    r \\<in> \\<delta> \\<and>\n    q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1} -\n   Q)\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  W \\<subseteq> Q\n  q \\<in> set (rhsq r)", "have \n        \"set (rhsq r) - (Q-W) = insert q (set (rhsq r) - (Q'-W'))\"\n        \"q\\<notin>(set (rhsq r) - (Q'-W'))\""], ["proof (prove)\nusing this:\n  q \\<in> W\n  Q' =\n  Q \\<union>\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n  W' =\n  W - {q} \\<union>\n  ({lhs r |r.\n    r \\<in> \\<delta> \\<and>\n    q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1} -\n   Q)\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  W \\<subseteq> Q\n  q \\<in> set (rhsq r)\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = insert q (set (rhsq r) - (Q' - W')) &&&\n    q \\<notin> set (rhsq r) - (Q' - W')", "by auto"], ["proof (state)\nthis:\n  set (rhsq r) - (Q - W) = insert q (set (rhsq r) - (Q' - W'))\n  q \\<notin> set (rhsq r) - (Q' - W')\n\ngoal (1 subgoal):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow>\n    rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "ultimately"], ["proof (chain)\npicking this:\n  rcm' r = Some (card (set (rhsq r) - (Q - W)) - 1)\n  set (rhsq r) - (Q - W) = insert q (set (rhsq r) - (Q' - W'))\n  q \\<notin> set (rhsq r) - (Q' - W')", "show ?thesis"], ["proof (prove)\nusing this:\n  rcm' r = Some (card (set (rhsq r) - (Q - W)) - 1)\n  set (rhsq r) - (Q - W) = insert q (set (rhsq r) - (Q' - W'))\n  q \\<notin> set (rhsq r) - (Q' - W')\n\ngoal (1 subgoal):\n 1. rcm' r = Some (card (set (rhsq r) - (Q' - W')))", "by (simp add: RCMR card_insert_disjoint')"], ["proof (state)\nthis:\n  rcm' r = Some (card (set (rhsq r) - (Q' - W')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rcm' r = Some (card (set (rhsq r) - (Q' - W')))\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "}"], ["proof (state)\nthis:\n  ?r2 \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r2 = Some (card (set (rhsq ?r2) - (Q' - W')))\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "moreover"], ["proof (state)\nthis:\n  ?r2 \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r2 = Some (card (set (rhsq ?r2) - (Q' - W')))\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "{"], ["proof (state)\nthis:\n  ?r2 \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r2 = Some (card (set (rhsq ?r2) - (Q' - W')))\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "assume A: \"r\\<in>\\<delta>\" \"the (rcm' r) = 0\""], ["proof (state)\nthis:\n  r \\<in> \\<delta>\n  the (rcm' r) = 0\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "have \"lhs r \\<in> Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs r \\<in> Q'", "proof (cases \"q\\<in>set (rhsq r)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'\n 2. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "case True"], ["proof (state)\nthis:\n  q \\<in> set (rhsq r)\n\ngoal (2 subgoals):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'\n 2. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "with A(1) STEPF(4)"], ["proof (chain)\npicking this:\n  r \\<in> \\<delta>\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  q \\<in> set (rhsq r)", "have \"rcm' r = Some (the (rcm r) - 1)\""], ["proof (prove)\nusing this:\n  r \\<in> \\<delta>\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  q \\<in> set (rhsq r)\n\ngoal (1 subgoal):\n 1. rcm' r = Some (the (rcm r) - 1)", "by auto"], ["proof (state)\nthis:\n  rcm' r = Some (the (rcm r) - 1)\n\ngoal (2 subgoals):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'\n 2. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "with A(2)"], ["proof (chain)\npicking this:\n  the (rcm' r) = 0\n  rcm' r = Some (the (rcm r) - 1)", "have \"the (rcm r) - 1 = 0\""], ["proof (prove)\nusing this:\n  the (rcm' r) = 0\n  rcm' r = Some (the (rcm r) - 1)\n\ngoal (1 subgoal):\n 1. the (rcm r) - 1 = 0", "by auto"], ["proof (state)\nthis:\n  the (rcm r) - 1 = 0\n\ngoal (2 subgoals):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'\n 2. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "hence \"the (rcm r) \\<le> 1\""], ["proof (prove)\nusing this:\n  the (rcm r) - 1 = 0\n\ngoal (1 subgoal):\n 1. the (rcm r) \\<le> 1", "by auto"], ["proof (state)\nthis:\n  the (rcm r) \\<le> 1\n\ngoal (2 subgoals):\n 1. q \\<in> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'\n 2. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "with STEPF(2) A(1) True"], ["proof (chain)\npicking this:\n  Q' =\n  Q \\<union>\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n  r \\<in> \\<delta>\n  q \\<in> set (rhsq r)\n  the (rcm r) \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  Q' =\n  Q \\<union>\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n  r \\<in> \\<delta>\n  q \\<in> set (rhsq r)\n  the (rcm r) \\<le> 1\n\ngoal (1 subgoal):\n 1. lhs r \\<in> Q'", "by auto"], ["proof (state)\nthis:\n  lhs r \\<in> Q'\n\ngoal (1 subgoal):\n 1. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "case False"], ["proof (state)\nthis:\n  q \\<notin> set (rhsq r)\n\ngoal (1 subgoal):\n 1. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "with A(1) STEPF(4)"], ["proof (chain)\npicking this:\n  r \\<in> \\<delta>\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  q \\<notin> set (rhsq r)", "have \"rcm' r = rcm r\""], ["proof (prove)\nusing this:\n  r \\<in> \\<delta>\n  ?r \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r =\n  (if q \\<in> set (rhsq ?r) then Some (the (rcm ?r) - 1) else rcm ?r)\n  q \\<notin> set (rhsq r)\n\ngoal (1 subgoal):\n 1. rcm' r = rcm r", "by auto"], ["proof (state)\nthis:\n  rcm' r = rcm r\n\ngoal (1 subgoal):\n 1. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "with A(2)"], ["proof (chain)\npicking this:\n  the (rcm' r) = 0\n  rcm' r = rcm r", "have \"the (rcm r) = 0\""], ["proof (prove)\nusing this:\n  the (rcm' r) = 0\n  rcm' r = rcm r\n\ngoal (1 subgoal):\n 1. the (rcm r) = 0", "by auto"], ["proof (state)\nthis:\n  the (rcm r) = 0\n\ngoal (1 subgoal):\n 1. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "with A(1) INV(2)"], ["proof (chain)\npicking this:\n  r \\<in> \\<delta>\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\n  the (rcm r) = 0", "have \"lhs r \\<in> Q\""], ["proof (prove)\nusing this:\n  r \\<in> \\<delta>\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\n  the (rcm r) = 0\n\ngoal (1 subgoal):\n 1. lhs r \\<in> Q", "by auto"], ["proof (state)\nthis:\n  lhs r \\<in> Q\n\ngoal (1 subgoal):\n 1. q \\<notin> set (rhsq r) \\<Longrightarrow> lhs r \\<in> Q'", "with STEPF(2)"], ["proof (chain)\npicking this:\n  Q' =\n  Q \\<union>\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n  lhs r \\<in> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  Q' =\n  Q \\<union>\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n  lhs r \\<in> Q\n\ngoal (1 subgoal):\n 1. lhs r \\<in> Q'", "by auto"], ["proof (state)\nthis:\n  lhs r \\<in> Q'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lhs r \\<in> Q'\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?r2 \\<in> \\<delta>; the (rcm' ?r2) = 0\\<rbrakk>\n  \\<Longrightarrow> lhs ?r2 \\<in> Q'\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "ultimately"], ["proof (chain)\npicking this:\n  ?r2 \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r2 = Some (card (set (rhsq ?r2) - (Q' - W')))\n  \\<lbrakk>?r2 \\<in> \\<delta>; the (rcm' ?r2) = 0\\<rbrakk>\n  \\<Longrightarrow> lhs ?r2 \\<in> Q'", "show ?thesis"], ["proof (prove)\nusing this:\n  ?r2 \\<in> \\<delta> \\<Longrightarrow>\n  rcm' ?r2 = Some (card (set (rhsq ?r2) - (Q' - W')))\n  \\<lbrakk>?r2 \\<in> \\<delta>; the (rcm' ?r2) = 0\\<rbrakk>\n  \\<Longrightarrow> lhs ?r2 \\<in> Q'\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> br'_invar_add \\<delta>", "by (auto simp add: br'_invar_add_def)"], ["proof (state)\nthis:\n  \\<Sigma>' \\<in> br'_invar_add \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma br'_invar_initial: \n  \"br'_initial \\<delta> \\<subseteq> br'_invar_add \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. br'_initial \\<delta> \\<subseteq> br'_invar_add \\<delta>", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       (a, aa, b) \\<in> br'_initial \\<delta> \\<Longrightarrow>\n       (a, aa, b) \\<in> br'_invar_add \\<delta>", "apply (erule br'_initial.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b rcm.\n       \\<lbrakk>a = br_iq \\<delta>; aa = br_iq \\<delta>; b = rcm;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)))\\<rbrakk>\n       \\<Longrightarrow> (a, aa, b) \\<in> br'_invar_add \\<delta>", "apply (unfold br'_invar_add_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b rcm.\n       \\<lbrakk>a = br_iq \\<delta>; aa = br_iq \\<delta>; b = rcm;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)))\\<rbrakk>\n       \\<Longrightarrow> (a, aa, b)\n                         \\<in> {(Q, W, rcm).\n                                (\\<forall>r\\<in>\\<delta>.\n                                    rcm r =\n                                    Some\n                                     (card (set (rhsq r) - (Q - W)))) \\<and>\n                                {lhs r |r.\n                                 r \\<in> \\<delta> \\<and> the (rcm r) = 0}\n                                \\<subseteq> Q}", "apply (auto simp add: br_iq_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma br'_rcm_aux': \n  \"\\<lbrakk> (Q,W,rcm)\\<in>br'_invar \\<delta>; q\\<in>W \\<rbrakk> \n    \\<Longrightarrow> {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} \n         = {r\\<in>\\<delta>. q\\<in>set (rhsq r) \\<and> set (rhsq r) \\<subseteq> (Q - (W-{q}))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W\\<rbrakk>\n    \\<Longrightarrow> {r \\<in> \\<delta>.\n                       q \\<in> set (rhsq r) \\<and>\n                       the (rcm r) \\<le> Suc 0} =\n                      {r \\<in> \\<delta>.\n                       q \\<in> set (rhsq r) \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})}", "proof (intro subsetI equalityI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 the (rcm r) \\<le> Suc 0}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  set (rhsq r) \\<subseteq> Q - (W - {q})}\n 2. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "case prems: (1 r)"], ["proof (state)\nthis:\n  (Q, W, rcm) \\<in> br'_invar \\<delta>\n  q \\<in> W\n  r \\<in> {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 the (rcm r) \\<le> Suc 0}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  set (rhsq r) \\<subseteq> Q - (W - {q})}\n 2. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "hence  B: \"r\\<in>\\<delta>\" \"q\\<in>set (rhsq r)\" \"the (rcm r) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  (Q, W, rcm) \\<in> br'_invar \\<delta>\n  q \\<in> W\n  r \\<in> {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}\n\ngoal (1 subgoal):\n 1. r \\<in> \\<delta> &&& q \\<in> set (rhsq r) &&& the (rcm r) \\<le> Suc 0", "by auto"], ["proof (state)\nthis:\n  r \\<in> \\<delta>\n  q \\<in> set (rhsq r)\n  the (rcm r) \\<le> Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 the (rcm r) \\<le> Suc 0}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  set (rhsq r) \\<subseteq> Q - (W - {q})}\n 2. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "from B(1,3) prems(1)[unfolded br'_invar_def br'_invar_add_def]"], ["proof (chain)\npicking this:\n  r \\<in> \\<delta>\n  the (rcm r) \\<le> Suc 0\n  (Q, W, rcm)\n  \\<in> {(Q, W, rcm).\n         (\\<forall>r\\<in>\\<delta>.\n             rcm r = Some (card (set (rhsq r) - (Q - W)))) \\<and>\n         {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0}\n         \\<subseteq> Q} \\<inter>\n        {\\<Sigma>. br'_\\<alpha> \\<Sigma> \\<in> br_invar \\<delta>}", "have \n    CARD: \"card (set (rhsq r) - (Q - W)) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  r \\<in> \\<delta>\n  the (rcm r) \\<le> Suc 0\n  (Q, W, rcm)\n  \\<in> {(Q, W, rcm).\n         (\\<forall>r\\<in>\\<delta>.\n             rcm r = Some (card (set (rhsq r) - (Q - W)))) \\<and>\n         {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0}\n         \\<subseteq> Q} \\<inter>\n        {\\<Sigma>. br'_\\<alpha> \\<Sigma> \\<in> br_invar \\<delta>}\n\ngoal (1 subgoal):\n 1. card (set (rhsq r) - (Q - W)) \\<le> Suc 0", "by auto"], ["proof (state)\nthis:\n  card (set (rhsq r) - (Q - W)) \\<le> Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 the (rcm r) \\<le> Suc 0}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  set (rhsq r) \\<subseteq> Q - (W - {q})}\n 2. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "from prems(1)[unfolded br'_invar_def br_invar_def br'_\\<alpha>_def]"], ["proof (chain)\npicking this:\n  (Q, W, rcm)\n  \\<in> br'_invar_add \\<delta> \\<inter>\n        {\\<Sigma>.\n         (case \\<Sigma> of (Q, W, rcm) \\<Rightarrow> (Q, W))\n         \\<in> {(Q, W).\n                W \\<subseteq> Q \\<and>\n                Q \\<subseteq> b_accessible \\<delta> \\<and>\n                bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q}}", "have WSQ: \"W\\<subseteq>Q\""], ["proof (prove)\nusing this:\n  (Q, W, rcm)\n  \\<in> br'_invar_add \\<delta> \\<inter>\n        {\\<Sigma>.\n         (case \\<Sigma> of (Q, W, rcm) \\<Rightarrow> (Q, W))\n         \\<in> {(Q, W).\n                W \\<subseteq> Q \\<and>\n                Q \\<subseteq> b_accessible \\<delta> \\<and>\n                bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q}}\n\ngoal (1 subgoal):\n 1. W \\<subseteq> Q", "by auto"], ["proof (state)\nthis:\n  W \\<subseteq> Q\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 the (rcm r) \\<le> Suc 0}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  set (rhsq r) \\<subseteq> Q - (W - {q})}\n 2. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "have \"set (rhsq r) - (Q - W) = {q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "from B(2) prems(2)"], ["proof (chain)\npicking this:\n  q \\<in> set (rhsq r)\n  q \\<in> W", "have R1: \"q\\<in>set (rhsq r) - (Q - W)\""], ["proof (prove)\nusing this:\n  q \\<in> set (rhsq r)\n  q \\<in> W\n\ngoal (1 subgoal):\n 1. q \\<in> set (rhsq r) - (Q - W)", "by auto"], ["proof (state)\nthis:\n  q \\<in> set (rhsq r) - (Q - W)\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "moreover"], ["proof (state)\nthis:\n  q \\<in> set (rhsq r) - (Q - W)\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "{"], ["proof (state)\nthis:\n  q \\<in> set (rhsq r) - (Q - W)\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "assume A: \"x\\<noteq>q\" \"x\\<in>set (rhsq r) - (Q - W)\""], ["proof (state)\nthis:\n  x \\<noteq> q\n  x \\<in> set (rhsq r) - (Q - W)\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "with R1"], ["proof (chain)\npicking this:\n  q \\<in> set (rhsq r) - (Q - W)\n  x \\<noteq> q\n  x \\<in> set (rhsq r) - (Q - W)", "have \"{x,q} \\<subseteq> set (rhsq r) - (Q - W)\""], ["proof (prove)\nusing this:\n  q \\<in> set (rhsq r) - (Q - W)\n  x \\<noteq> q\n  x \\<in> set (rhsq r) - (Q - W)\n\ngoal (1 subgoal):\n 1. {x, q} \\<subseteq> set (rhsq r) - (Q - W)", "by auto"], ["proof (state)\nthis:\n  {x, q} \\<subseteq> set (rhsq r) - (Q - W)\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "hence \"card {x,q} \\<le> card (set (rhsq r) - (Q - W))\""], ["proof (prove)\nusing this:\n  {x, q} \\<subseteq> set (rhsq r) - (Q - W)\n\ngoal (1 subgoal):\n 1. card {x, q} \\<le> card (set (rhsq r) - (Q - W))", "by (auto simp add: card_mono)"], ["proof (state)\nthis:\n  card {x, q} \\<le> card (set (rhsq r) - (Q - W))\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "with CARD A(1)"], ["proof (chain)\npicking this:\n  card (set (rhsq r) - (Q - W)) \\<le> Suc 0\n  x \\<noteq> q\n  card {x, q} \\<le> card (set (rhsq r) - (Q - W))", "have False"], ["proof (prove)\nusing this:\n  card (set (rhsq r) - (Q - W)) \\<le> Suc 0\n  x \\<noteq> q\n  card {x, q} \\<le> card (set (rhsq r) - (Q - W))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<noteq> q; ?x2 \\<in> set (rhsq r) - (Q - W)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "ultimately"], ["proof (chain)\npicking this:\n  q \\<in> set (rhsq r) - (Q - W)\n  \\<lbrakk>?x2 \\<noteq> q; ?x2 \\<in> set (rhsq r) - (Q - W)\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> set (rhsq r) - (Q - W)\n  \\<lbrakk>?x2 \\<noteq> q; ?x2 \\<in> set (rhsq r) - (Q - W)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) = {q}", "by auto"], ["proof (state)\nthis:\n  set (rhsq r) - (Q - W) = {q}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (rhsq r) - (Q - W) = {q}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 the (rcm r) \\<le> Suc 0}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  set (rhsq r) \\<subseteq> Q - (W - {q})}\n 2. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "with prems(2) WSQ"], ["proof (chain)\npicking this:\n  q \\<in> W\n  W \\<subseteq> Q\n  set (rhsq r) - (Q - W) = {q}", "have \"set (rhsq r) \\<subseteq> Q - (W - {q})\""], ["proof (prove)\nusing this:\n  q \\<in> W\n  W \\<subseteq> Q\n  set (rhsq r) - (Q - W) = {q}\n\ngoal (1 subgoal):\n 1. set (rhsq r) \\<subseteq> Q - (W - {q})", "by auto"], ["proof (state)\nthis:\n  set (rhsq r) \\<subseteq> Q - (W - {q})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 the (rcm r) \\<le> Suc 0}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  set (rhsq r) \\<subseteq> Q - (W - {q})}\n 2. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "thus ?case"], ["proof (prove)\nusing this:\n  set (rhsq r) \\<subseteq> Q - (W - {q})\n\ngoal (1 subgoal):\n 1. r \\<in> {r \\<in> \\<delta>.\n             q \\<in> set (rhsq r) \\<and>\n             set (rhsq r) \\<subseteq> Q - (W - {q})}", "using B(1,2)"], ["proof (prove)\nusing this:\n  set (rhsq r) \\<subseteq> Q - (W - {q})\n  r \\<in> \\<delta>\n  q \\<in> set (rhsq r)\n\ngoal (1 subgoal):\n 1. r \\<in> {r \\<in> \\<delta>.\n             q \\<in> set (rhsq r) \\<and>\n             set (rhsq r) \\<subseteq> Q - (W - {q})}", "by auto"], ["proof (state)\nthis:\n  r \\<in> {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and>\n           set (rhsq r) \\<subseteq> Q - (W - {q})}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "case prems: (2 r)"], ["proof (state)\nthis:\n  (Q, W, rcm) \\<in> br'_invar \\<delta>\n  q \\<in> W\n  r \\<in> {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and>\n           set (rhsq r) \\<subseteq> Q - (W - {q})}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "hence B: \"r\\<in>\\<delta>\" \"q\\<in>set (rhsq r)\" \"set (rhsq r) \\<subseteq> Q - (W - {q})\""], ["proof (prove)\nusing this:\n  (Q, W, rcm) \\<in> br'_invar \\<delta>\n  q \\<in> W\n  r \\<in> {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and>\n           set (rhsq r) \\<subseteq> Q - (W - {q})}\n\ngoal (1 subgoal):\n 1. r \\<in> \\<delta> &&&\n    q \\<in> set (rhsq r) &&& set (rhsq r) \\<subseteq> Q - (W - {q})", "by auto"], ["proof (state)\nthis:\n  r \\<in> \\<delta>\n  q \\<in> set (rhsq r)\n  set (rhsq r) \\<subseteq> Q - (W - {q})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "with prems(1)[unfolded br'_invar_def br'_invar_add_def \n                         br'_\\<alpha>_def br_invar_def]"], ["proof (chain)\npicking this:\n  (Q, W, rcm)\n  \\<in> {(Q, W, rcm).\n         (\\<forall>r\\<in>\\<delta>.\n             rcm r = Some (card (set (rhsq r) - (Q - W)))) \\<and>\n         {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0}\n         \\<subseteq> Q} \\<inter>\n        {\\<Sigma>.\n         (case \\<Sigma> of (Q, W, rcm) \\<Rightarrow> (Q, W))\n         \\<in> {(Q, W).\n                W \\<subseteq> Q \\<and>\n                Q \\<subseteq> b_accessible \\<delta> \\<and>\n                bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q}}\n  r \\<in> \\<delta>\n  q \\<in> set (rhsq r)\n  set (rhsq r) \\<subseteq> Q - (W - {q})", "have \n    IC: \"W\\<subseteq>Q\" \"the (rcm r) = card (set (rhsq r) - (Q - W))\""], ["proof (prove)\nusing this:\n  (Q, W, rcm)\n  \\<in> {(Q, W, rcm).\n         (\\<forall>r\\<in>\\<delta>.\n             rcm r = Some (card (set (rhsq r) - (Q - W)))) \\<and>\n         {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0}\n         \\<subseteq> Q} \\<inter>\n        {\\<Sigma>.\n         (case \\<Sigma> of (Q, W, rcm) \\<Rightarrow> (Q, W))\n         \\<in> {(Q, W).\n                W \\<subseteq> Q \\<and>\n                Q \\<subseteq> b_accessible \\<delta> \\<and>\n                bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q}}\n  r \\<in> \\<delta>\n  q \\<in> set (rhsq r)\n  set (rhsq r) \\<subseteq> Q - (W - {q})\n\ngoal (1 subgoal):\n 1. W \\<subseteq> Q &&& the (rcm r) = card (set (rhsq r) - (Q - W))", "by auto"], ["proof (state)\nthis:\n  W \\<subseteq> Q\n  the (rcm r) = card (set (rhsq r) - (Q - W))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "have \"set (rhsq r) - (Q - W) \\<subseteq> {q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) \\<subseteq> {q}", "using B(2,3) IC(1)"], ["proof (prove)\nusing this:\n  q \\<in> set (rhsq r)\n  set (rhsq r) \\<subseteq> Q - (W - {q})\n  W \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. set (rhsq r) - (Q - W) \\<subseteq> {q}", "by auto"], ["proof (state)\nthis:\n  set (rhsq r) - (Q - W) \\<subseteq> {q}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "from card_mono[OF _ this]"], ["proof (chain)\npicking this:\n  finite {q} \\<Longrightarrow> card (set (rhsq r) - (Q - W)) \\<le> card {q}", "have \"the (rcm r) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  finite {q} \\<Longrightarrow> card (set (rhsq r) - (Q - W)) \\<le> card {q}\n\ngoal (1 subgoal):\n 1. the (rcm r) \\<le> Suc 0", "by (simp add: IC(2))"], ["proof (state)\nthis:\n  the (rcm r) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n        x \\<in> {r \\<in> \\<delta>.\n                 q \\<in> set (rhsq r) \\<and>\n                 set (rhsq r) \\<subseteq> Q - (W - {q})}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {r \\<in> \\<delta>.\n                                  q \\<in> set (rhsq r) \\<and>\n                                  the (rcm r) \\<le> Suc 0}", "with B(1,2)"], ["proof (chain)\npicking this:\n  r \\<in> \\<delta>\n  q \\<in> set (rhsq r)\n  the (rcm r) \\<le> Suc 0", "show ?case"], ["proof (prove)\nusing this:\n  r \\<in> \\<delta>\n  q \\<in> set (rhsq r)\n  the (rcm r) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. r \\<in> {r \\<in> \\<delta>.\n             q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}", "by auto"], ["proof (state)\nthis:\n  r \\<in> {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma br'_rcm_aux: \n  assumes A: \"(Q,W,rcm)\\<in>br'_invar \\<delta>\" \"q\\<in>W\"  \n  shows \"{lhs r |r. r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} \n         = {lhs r | r. r\\<in>\\<delta> \\<and> q\\<in>set (rhsq r) \\<and> set (rhsq r) \\<subseteq> (Q - (W-{q}))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n    {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n    {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "have \"{lhs r |r. r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} \n        = lhs ` {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n    lhs `\n    {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}", "by auto"], ["proof (state)\nthis:\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and>\n   q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  lhs `\n  {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}\n\ngoal (1 subgoal):\n 1. {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n    {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "also"], ["proof (state)\nthis:\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and>\n   q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  lhs `\n  {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}\n\ngoal (1 subgoal):\n 1. {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n    {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "from br'_rcm_aux'[OF A]"], ["proof (chain)\npicking this:\n  {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  {r \\<in> \\<delta>.\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "have \n    \"\\<dots> = lhs ` {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}\""], ["proof (prove)\nusing this:\n  {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  {r \\<in> \\<delta>.\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}\n\ngoal (1 subgoal):\n 1. lhs `\n    {r \\<in> \\<delta>.\n     q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n    lhs `\n    {r \\<in> \\<delta>.\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "by simp"], ["proof (state)\nthis:\n  lhs `\n  {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  lhs `\n  {r \\<in> \\<delta>.\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}\n\ngoal (1 subgoal):\n 1. {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n    {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "also"], ["proof (state)\nthis:\n  lhs `\n  {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  lhs `\n  {r \\<in> \\<delta>.\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}\n\ngoal (1 subgoal):\n 1. {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n    {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "have \n    \"\\<dots> = {lhs r | r. r\\<in>\\<delta> \\<and> q\\<in>set (rhsq r) \\<and> set (rhsq r) \\<subseteq> (Q - (W-{q}))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs `\n    {r \\<in> \\<delta>.\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})} =\n    {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "by auto"], ["proof (state)\nthis:\n  lhs `\n  {r \\<in> \\<delta>.\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})} =\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and>\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}\n\ngoal (1 subgoal):\n 1. {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n    {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "finally"], ["proof (chain)\npicking this:\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and>\n   q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and>\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "show ?thesis"], ["proof (prove)\nusing this:\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and>\n   q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and>\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}\n\ngoal (1 subgoal):\n 1. {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n    {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}", "."], ["proof (state)\nthis:\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and>\n   q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  {lhs r |r.\n   r \\<in> \\<delta> \\<and>\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> Q - (W - {q})}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma br'_invar_QcD: \n  \"(Q,W,rcm) \\<in> br'_invar \\<delta> \\<Longrightarrow> {lhs r | r. r\\<in>\\<delta> \\<and> set (rhsq r) \\<subseteq> (Q-W)} \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q, W, rcm) \\<in> br'_invar \\<delta> \\<Longrightarrow>\n    {lhs r |r. r \\<in> \\<delta> \\<and> set (rhsq r) \\<subseteq> Q - W}\n    \\<subseteq> Q", "proof (safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; r \\<in> \\<delta>;\n        set (rhsq r) \\<subseteq> Q - W\\<rbrakk>\n       \\<Longrightarrow> lhs r \\<in> Q", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; r \\<in> \\<delta>;\n        set (rhsq r) \\<subseteq> Q - W\\<rbrakk>\n       \\<Longrightarrow> lhs r \\<in> Q", "assume A: \"(Q,W,rcm)\\<in>br'_invar \\<delta>\" \"r\\<in>\\<delta>\" \"set (rhsq r) \\<subseteq> Q - W\""], ["proof (state)\nthis:\n  (Q, W, rcm) \\<in> br'_invar \\<delta>\n  r \\<in> \\<delta>\n  set (rhsq r) \\<subseteq> Q - W\n\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; r \\<in> \\<delta>;\n        set (rhsq r) \\<subseteq> Q - W\\<rbrakk>\n       \\<Longrightarrow> lhs r \\<in> Q", "from A(1)[unfolded br'_invar_def br'_invar_add_def br'_\\<alpha>_def br_invar_def, \n            simplified]"], ["proof (chain)\npicking this:\n  (\\<forall>r\\<in>\\<delta>.\n      rcm r = Some (card (set (rhsq r) - (Q - W)))) \\<and>\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q \\<and>\n  W \\<subseteq> Q \\<and>\n  Q \\<subseteq> b_accessible \\<delta> \\<and>\n  bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q", "have \n    IC: \"W \\<subseteq> Q\" \n        \"finite Q\" \n        \"(\\<forall>r\\<in>\\<delta>. rcm r = Some (card (set (rhsq r) - (Q - W))))\" \n        \"{lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\""], ["proof (prove)\nusing this:\n  (\\<forall>r\\<in>\\<delta>.\n      rcm r = Some (card (set (rhsq r) - (Q - W)))) \\<and>\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q \\<and>\n  W \\<subseteq> Q \\<and>\n  Q \\<subseteq> b_accessible \\<delta> \\<and>\n  bacc_step \\<delta> (Q - W) \\<subseteq> Q \\<and> finite Q\n\ngoal (1 subgoal):\n 1. (W \\<subseteq> Q &&& finite Q) &&&\n    \\<forall>r\\<in>\\<delta>.\n       rcm r = Some (card (set (rhsq r) - (Q - W))) &&&\n    {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q", "by auto"], ["proof (state)\nthis:\n  W \\<subseteq> Q\n  finite Q\n  \\<forall>r\\<in>\\<delta>. rcm r = Some (card (set (rhsq r) - (Q - W)))\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; r \\<in> \\<delta>;\n        set (rhsq r) \\<subseteq> Q - W\\<rbrakk>\n       \\<Longrightarrow> lhs r \\<in> Q", "from IC(3) A(2,3)"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>\\<delta>. rcm r = Some (card (set (rhsq r) - (Q - W)))\n  r \\<in> \\<delta>\n  set (rhsq r) \\<subseteq> Q - W", "have \"the (rcm r) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>\\<delta>. rcm r = Some (card (set (rhsq r) - (Q - W)))\n  r \\<in> \\<delta>\n  set (rhsq r) \\<subseteq> Q - W\n\ngoal (1 subgoal):\n 1. the (rcm r) = 0", "by auto"], ["proof (state)\nthis:\n  the (rcm r) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; r \\<in> \\<delta>;\n        set (rhsq r) \\<subseteq> Q - W\\<rbrakk>\n       \\<Longrightarrow> lhs r \\<in> Q", "with IC(4) A(2)"], ["proof (chain)\npicking this:\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\n  r \\<in> \\<delta>\n  the (rcm r) = 0", "show \"lhs r \\<in> Q\""], ["proof (prove)\nusing this:\n  {lhs r |r. r \\<in> \\<delta> \\<and> the (rcm r) = 0} \\<subseteq> Q\n  r \\<in> \\<delta>\n  the (rcm r) = 0\n\ngoal (1 subgoal):\n 1. lhs r \\<in> Q", "by auto"], ["proof (state)\nthis:\n  lhs r \\<in> Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma br'_rcm_aux2: \n  \"\\<lbrakk> (Q,W,rcm)\\<in>br'_invar \\<delta>; q\\<in>W \\<rbrakk> \n    \\<Longrightarrow> Q \\<union> br_dsq \\<delta> q (Q,W) \n        = Q \\<union> {lhs r |r. r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W\\<rbrakk>\n    \\<Longrightarrow> Q \\<union> br_dsq \\<delta> q (Q, W) =\n                      Q \\<union>\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0}", "apply (simp only: br'_rcm_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W\\<rbrakk>\n    \\<Longrightarrow> Q \\<union> br_dsq \\<delta> q (Q, W) =\n                      Q \\<union>\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       q \\<in> set (rhsq r) \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})}", "apply (unfold br_dsq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W\\<rbrakk>\n    \\<Longrightarrow> Q \\<union>\n                      (case (Q, W) of\n                       (Q, W) \\<Rightarrow>\n                         {lhs r |r.\n                          r \\<in> \\<delta> \\<and>\n                          set (rhsq r) \\<subseteq> Q - (W - {q})}) =\n                      Q \\<union>\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       q \\<in> set (rhsq r) \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W\\<rbrakk>\n    \\<Longrightarrow> Q \\<union>\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})} =\n                      Q \\<union>\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       q \\<in> set (rhsq r) \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})}", "apply (frule br'_invar_QcD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n     {lhs r |r. r \\<in> \\<delta> \\<and> set (rhsq r) \\<subseteq> Q - W}\n     \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> Q \\<union>\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})} =\n                      Q \\<union>\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       q \\<in> set (rhsq r) \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma br'_rcm_aux3: \n  \"\\<lbrakk> (Q,W,rcm)\\<in>br'_invar \\<delta>; q\\<in>W \\<rbrakk> \n    \\<Longrightarrow> br_dsq \\<delta> q (Q,W) - Q \n        = {lhs r |r. r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} - Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W\\<rbrakk>\n    \\<Longrightarrow> br_dsq \\<delta> q (Q, W) - Q =\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       q \\<in> set (rhsq r) \\<and>\n                       the (rcm r) \\<le> Suc 0} -\n                      Q", "apply (simp only: br'_rcm_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W\\<rbrakk>\n    \\<Longrightarrow> br_dsq \\<delta> q (Q, W) - Q =\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       q \\<in> set (rhsq r) \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})} -\n                      Q", "apply (unfold br_dsq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W\\<rbrakk>\n    \\<Longrightarrow> (case (Q, W) of\n                       (Q, W) \\<Rightarrow>\n                         {lhs r |r.\n                          r \\<in> \\<delta> \\<and>\n                          set (rhsq r) \\<subseteq> Q - (W - {q})}) -\n                      Q =\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       q \\<in> set (rhsq r) \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})} -\n                      Q", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W\\<rbrakk>\n    \\<Longrightarrow> {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})} -\n                      Q =\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       q \\<in> set (rhsq r) \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})} -\n                      Q", "apply (frule br'_invar_QcD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>; q \\<in> W;\n     {lhs r |r. r \\<in> \\<delta> \\<and> set (rhsq r) \\<subseteq> Q - W}\n     \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})} -\n                      Q =\n                      {lhs r |r.\n                       r \\<in> \\<delta> \\<and>\n                       q \\<in> set (rhsq r) \\<and>\n                       set (rhsq r) \\<subseteq> Q - (W - {q})} -\n                      Q", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma br'_step_abs: \n  \"\\<lbrakk> \n     \\<Sigma>\\<in>br'_invar \\<delta>; \n     (\\<Sigma>,\\<Sigma>') \\<in> br'_step \\<delta> \n   \\<rbrakk> \\<Longrightarrow> (br'_\\<alpha> \\<Sigma>, br'_\\<alpha> \\<Sigma>')\\<in>br_step \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Sigma> \\<in> br'_invar \\<delta>;\n     (\\<Sigma>, \\<Sigma>') \\<in> br'_step \\<delta>\\<rbrakk>\n    \\<Longrightarrow> (br'_\\<alpha> \\<Sigma>, br'_\\<alpha> \\<Sigma>')\n                      \\<in> br_step \\<delta>", "apply (cases \\<Sigma>, cases \\<Sigma>', simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>(a, b, c) \\<in> br'_invar \\<delta>;\n        ((a, b, c), aa, ba, ca) \\<in> br'_step \\<delta>;\n        \\<Sigma> = (a, b, c); \\<Sigma>' = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> (br'_\\<alpha> (a, b, c), br'_\\<alpha> (aa, ba, ca))\n                         \\<in> br_step \\<delta>", "apply (erule br'_step.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca q W Q' Q rcm W' rcm'.\n       \\<lbrakk>(a, b, c) \\<in> br'_invar \\<delta>; \\<Sigma> = (a, b, c);\n        \\<Sigma>' = (aa, ba, ca); a = Q; b = W; c = rcm; aa = Q'; ba = W';\n        ca = rcm'; q \\<in> W;\n        Q' =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1};\n        W' =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1} -\n         Q);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> (br'_\\<alpha> (a, b, c), br'_\\<alpha> (aa, ba, ca))\n                         \\<in> br_step \\<delta>", "apply (simp add: br'_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca q W Q' Q rcm W' rcm'.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>;\n        \\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         rcm');\n        a = Q; b = W; c = rcm;\n        aa =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        ba =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        ca = rcm'; q \\<in> W;\n        Q' =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        W' =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> ((Q, W),\n                          Q \\<union>\n                          {lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0},\n                          W - {q} \\<union>\n                          ({lhs r |r.\n                            r \\<in> \\<delta> \\<and>\n                            q \\<in> set (rhsq r) \\<and>\n                            the (rcm r) \\<le> Suc 0} -\n                           Q))\n                         \\<in> br_step \\<delta>", "apply (rule_tac q=q in br_step.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c aa ba ca q W Q' Q rcm W' rcm'.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>;\n        \\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         rcm');\n        a = Q; b = W; c = rcm;\n        aa =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        ba =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        ca = rcm'; q \\<in> W;\n        Q' =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        W' =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> q \\<in> W\n 2. \\<And>a b c aa ba ca q W Q' Q rcm W' rcm'.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>;\n        \\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         rcm');\n        a = Q; b = W; c = rcm;\n        aa =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        ba =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        ca = rcm'; q \\<in> W;\n        Q' =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        W' =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> Q \\<union>\n                         {lhs r |r.\n                          r \\<in> \\<delta> \\<and>\n                          q \\<in> set (rhsq r) \\<and>\n                          the (rcm r) \\<le> Suc 0} =\n                         Q \\<union> br_dsq \\<delta> q (Q, W)\n 3. \\<And>a b c aa ba ca q W Q' Q rcm W' rcm'.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>;\n        \\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         rcm');\n        a = Q; b = W; c = rcm;\n        aa =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        ba =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        ca = rcm'; q \\<in> W;\n        Q' =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        W' =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> W - {q} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0} -\n                          Q) =\n                         W - {q} \\<union> (br_dsq \\<delta> q (Q, W) - Q)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c aa ba ca q W Q' Q rcm W' rcm'.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>;\n        \\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         rcm');\n        a = Q; b = W; c = rcm;\n        aa =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        ba =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        ca = rcm'; q \\<in> W;\n        Q' =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        W' =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> Q \\<union>\n                         {lhs r |r.\n                          r \\<in> \\<delta> \\<and>\n                          q \\<in> set (rhsq r) \\<and>\n                          the (rcm r) \\<le> Suc 0} =\n                         Q \\<union> br_dsq \\<delta> q (Q, W)\n 2. \\<And>a b c aa ba ca q W Q' Q rcm W' rcm'.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>;\n        \\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         rcm');\n        a = Q; b = W; c = rcm;\n        aa =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        ba =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        ca = rcm'; q \\<in> W;\n        Q' =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        W' =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> W - {q} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0} -\n                          Q) =\n                         W - {q} \\<union> (br_dsq \\<delta> q (Q, W) - Q)", "apply (simp only: br'_rcm_aux2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca q W Q' Q rcm W' rcm'.\n       \\<lbrakk>(Q, W, rcm) \\<in> br'_invar \\<delta>;\n        \\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         rcm');\n        a = Q; b = W; c = rcm;\n        aa =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        ba =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        ca = rcm'; q \\<in> W;\n        Q' =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        W' =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         Q);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> W - {q} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0} -\n                          Q) =\n                         W - {q} \\<union> (br_dsq \\<delta> q (Q, W) - Q)", "apply (simp only: br'_rcm_aux3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma br'_initial_abs: \"br'_\\<alpha>`(br'_initial \\<delta>) = {br_initial \\<delta>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. br'_\\<alpha> ` br'_initial \\<delta> = {br_initial \\<delta>}", "apply (force simp add: br_initial_def br'_\\<alpha>_def\n               elim: br'_initial.cases \n               intro: br'_initial.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma br'_cond_abs: \"\\<Sigma>\\<in>br'_cond \\<longleftrightarrow> (br'_\\<alpha> \\<Sigma>) \\<in> br_cond\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sigma> \\<in> br'_cond) = (br'_\\<alpha> \\<Sigma> \\<in> br_cond)", "by (cases \\<Sigma>) \n     (simp add: br'_cond_def br_cond_def br'_\\<alpha>_def image_Collect \n                br'_algo_def br_algo_def)"], ["", "lemma bre'_cond_abs: \"\\<Sigma>\\<in>bre'_cond Qi \\<longleftrightarrow> (br'_\\<alpha> \\<Sigma>)\\<in>bre_cond Qi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sigma> \\<in> bre'_cond Qi) =\n    (br'_\\<alpha> \\<Sigma> \\<in> bre_cond Qi)", "by (cases \\<Sigma>) (simp add: bre'_cond_def bre_cond_def br'_\\<alpha>_def image_Collect \n                          bre'_algo_def bre_algo_def)"], ["", "lemma br'_invar_abs: \"br'_\\<alpha>`br'_invar \\<delta> \\<subseteq> br_invar \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. br'_\\<alpha> ` br'_invar \\<delta> \\<subseteq> br_invar \\<delta>", "by (auto simp add: br'_invar_def)"], ["", "theorem br'_pref_br: \"wa_precise_refine (br'_algo \\<delta>) (br_algo \\<delta>) br'_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (br'_algo \\<delta>) (br_algo \\<delta>) br'_\\<alpha>", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> wa_invar (br'_algo \\<delta>);\n        s \\<in> wa_cond (br'_algo \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> br'_\\<alpha> s \\<in> wa_cond (br_algo \\<delta>)\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (br'_algo \\<delta>);\n        s \\<in> wa_cond (br'_algo \\<delta>);\n        (s, s') \\<in> wa_step (br'_algo \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> (br'_\\<alpha> s, br'_\\<alpha> s')\n                         \\<in> wa_step (br_algo \\<delta>)\n 3. br'_\\<alpha> ` wa_initial (br'_algo \\<delta>)\n    \\<subseteq> wa_initial (br_algo \\<delta>)\n 4. br'_\\<alpha> ` wa_invar (br'_algo \\<delta>)\n    \\<subseteq> wa_invar (br_algo \\<delta>)\n 5. \\<forall>s.\n       s \\<in> wa_invar (br'_algo \\<delta>) \\<and>\n       br'_\\<alpha> s \\<in> wa_cond (br_algo \\<delta>) \\<longrightarrow>\n       s \\<in> wa_cond (br'_algo \\<delta>)", "apply (simp_all add: br'_algo_def br_algo_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> br'_invar \\<delta>; s \\<in> br'_cond\\<rbrakk>\n       \\<Longrightarrow> br'_\\<alpha> s \\<in> br_cond\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> br'_invar \\<delta>; s \\<in> br'_cond;\n        (s, s') \\<in> br'_step \\<delta>\\<rbrakk>\n       \\<Longrightarrow> (br'_\\<alpha> s, br'_\\<alpha> s')\n                         \\<in> br_step \\<delta>\n 3. br'_\\<alpha> ` br'_initial \\<delta> \\<subseteq> {br_initial \\<delta>}\n 4. br'_\\<alpha> ` br'_invar \\<delta> \\<subseteq> br_invar \\<delta>\n 5. \\<forall>a aa b.\n       (a, aa, b) \\<in> br'_invar \\<delta> \\<and>\n       br'_\\<alpha> (a, aa, b) \\<in> br_cond \\<longrightarrow>\n       (a, aa, b) \\<in> br'_cond", "apply (simp_all add: br'_cond_abs br'_step_abs br'_invar_abs br'_initial_abs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation br'_pref: wa_precise_refine \"br'_algo \\<delta>\" \"br_algo \\<delta>\" \"br'_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (br'_algo \\<delta>) (br_algo \\<delta>) br'_\\<alpha>", "using br'_pref_br"], ["proof (prove)\nusing this:\n  wa_precise_refine (br'_algo ?\\<delta>) (br_algo ?\\<delta>) br'_\\<alpha>\n\ngoal (1 subgoal):\n 1. wa_precise_refine (br'_algo \\<delta>) (br_algo \\<delta>) br'_\\<alpha>", "."], ["", "theorem br'_while_algo: \n  \"finite \\<delta> \\<Longrightarrow> while_algo (br'_algo \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow> while_algo (br'_algo \\<delta>)", "apply (rule br'_pref.wa_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite \\<delta> \\<Longrightarrow> while_algo (br_algo \\<delta>)\n 2. finite \\<delta> \\<Longrightarrow>\n    wa_invar (br'_algo \\<delta>) =\n    ?addi \\<inter> {s. br'_\\<alpha> s \\<in> wa_invar (br_algo \\<delta>)}\n 3. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> ?addi;\n        s \\<in> wa_cond (br'_algo \\<delta>);\n        br'_\\<alpha> s \\<in> wa_invar (br_algo \\<delta>);\n        (s, s') \\<in> wa_step (br'_algo \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 4. finite \\<delta> \\<Longrightarrow>\n    wa_initial (br'_algo \\<delta>) \\<subseteq> ?addi", "apply (simp add: br_while_algo)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite \\<delta> \\<Longrightarrow>\n    wa_invar (br'_algo \\<delta>) =\n    ?addi \\<inter> {s. br'_\\<alpha> s \\<in> wa_invar (br_algo \\<delta>)}\n 2. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> ?addi;\n        s \\<in> wa_cond (br'_algo \\<delta>);\n        br'_\\<alpha> s \\<in> wa_invar (br_algo \\<delta>);\n        (s, s') \\<in> wa_step (br'_algo \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. finite \\<delta> \\<Longrightarrow>\n    wa_initial (br'_algo \\<delta>) \\<subseteq> ?addi", "apply (simp_all add: br'_algo_def br_algo_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite \\<delta> \\<Longrightarrow>\n    br'_invar \\<delta> =\n    ?addi \\<inter> {s. br'_\\<alpha> s \\<in> br_invar \\<delta>}\n 2. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> ?addi; s \\<in> br'_cond;\n        br'_\\<alpha> s \\<in> br_invar \\<delta>;\n        (s, s') \\<in> br'_step \\<delta>\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. finite \\<delta> \\<Longrightarrow> br'_initial \\<delta> \\<subseteq> ?addi", "apply (simp add: br'_invar_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> br'_invar_add \\<delta>;\n        s \\<in> br'_cond; br'_\\<alpha> s \\<in> br_invar \\<delta>;\n        (s, s') \\<in> br'_step \\<delta>\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> br'_invar_add \\<delta>\n 2. finite \\<delta> \\<Longrightarrow>\n    br'_initial \\<delta> \\<subseteq> br'_invar_add \\<delta>", "apply (erule (3) br'_step_invar)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow>\n    br'_initial \\<delta> \\<subseteq> br'_invar_add \\<delta>", "apply (simp add: br'_invar_initial)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fst_br'_\\<alpha>: \"fst (br'_\\<alpha> s) = fst s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (br'_\\<alpha> s) = fst s", "by (cases s) (simp add: br'_\\<alpha>_def)"], ["", "lemmas br'_invar_final = \n  br'_pref.transfer_correctness[OF br_invar_final, unfolded fst_br'_\\<alpha>]"], ["", "theorem bre'_pref_br: \"wa_precise_refine (bre'_algo Qi \\<delta>) (bre_algo Qi \\<delta>) br'_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (bre'_algo Qi \\<delta>) (bre_algo Qi \\<delta>)\n     br'_\\<alpha>", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> wa_invar (bre'_algo Qi \\<delta>);\n        s \\<in> wa_cond (bre'_algo Qi \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> br'_\\<alpha> s \\<in> wa_cond (bre_algo Qi \\<delta>)\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (bre'_algo Qi \\<delta>);\n        s \\<in> wa_cond (bre'_algo Qi \\<delta>);\n        (s, s') \\<in> wa_step (bre'_algo Qi \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> (br'_\\<alpha> s, br'_\\<alpha> s')\n                         \\<in> wa_step (bre_algo Qi \\<delta>)\n 3. br'_\\<alpha> ` wa_initial (bre'_algo Qi \\<delta>)\n    \\<subseteq> wa_initial (bre_algo Qi \\<delta>)\n 4. br'_\\<alpha> ` wa_invar (bre'_algo Qi \\<delta>)\n    \\<subseteq> wa_invar (bre_algo Qi \\<delta>)\n 5. \\<forall>s.\n       s \\<in> wa_invar (bre'_algo Qi \\<delta>) \\<and>\n       br'_\\<alpha> s \\<in> wa_cond (bre_algo Qi \\<delta>) \\<longrightarrow>\n       s \\<in> wa_cond (bre'_algo Qi \\<delta>)", "apply (simp_all add: bre'_algo_def bre_algo_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> br'_invar \\<delta>; s \\<in> bre'_cond Qi\\<rbrakk>\n       \\<Longrightarrow> br'_\\<alpha> s \\<in> bre_cond Qi\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> br'_invar \\<delta>; s \\<in> bre'_cond Qi;\n        (s, s') \\<in> br'_step \\<delta>\\<rbrakk>\n       \\<Longrightarrow> (br'_\\<alpha> s, br'_\\<alpha> s')\n                         \\<in> br_step \\<delta>\n 3. br'_\\<alpha> ` br'_initial \\<delta> \\<subseteq> {br_initial \\<delta>}\n 4. br'_\\<alpha> ` br'_invar \\<delta> \\<subseteq> br_invar \\<delta>\n 5. \\<forall>a aa b.\n       (a, aa, b) \\<in> br'_invar \\<delta> \\<and>\n       br'_\\<alpha> (a, aa, b) \\<in> bre_cond Qi \\<longrightarrow>\n       (a, aa, b) \\<in> bre'_cond Qi", "apply (simp_all add: bre'_cond_abs br'_step_abs br'_invar_abs br'_initial_abs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation bre'_pref: \n  wa_precise_refine \"bre'_algo Qi \\<delta>\" \"bre_algo Qi \\<delta>\" \"br'_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (bre'_algo Qi \\<delta>) (bre_algo Qi \\<delta>)\n     br'_\\<alpha>", "using bre'_pref_br"], ["proof (prove)\nusing this:\n  wa_precise_refine (bre'_algo ?Qi ?\\<delta>) (bre_algo ?Qi ?\\<delta>)\n   br'_\\<alpha>\n\ngoal (1 subgoal):\n 1. wa_precise_refine (bre'_algo Qi \\<delta>) (bre_algo Qi \\<delta>)\n     br'_\\<alpha>", "."], ["", "theorem bre'_while_algo: \n  \"finite \\<delta> \\<Longrightarrow> while_algo (bre'_algo Qi \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow> while_algo (bre'_algo Qi \\<delta>)", "apply (rule bre'_pref.wa_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite \\<delta> \\<Longrightarrow> while_algo (bre_algo Qi \\<delta>)\n 2. finite \\<delta> \\<Longrightarrow>\n    wa_invar (bre'_algo Qi \\<delta>) =\n    ?addi \\<inter> {s. br'_\\<alpha> s \\<in> wa_invar (bre_algo Qi \\<delta>)}\n 3. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> ?addi;\n        s \\<in> wa_cond (bre'_algo Qi \\<delta>);\n        br'_\\<alpha> s \\<in> wa_invar (bre_algo Qi \\<delta>);\n        (s, s') \\<in> wa_step (bre'_algo Qi \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 4. finite \\<delta> \\<Longrightarrow>\n    wa_initial (bre'_algo Qi \\<delta>) \\<subseteq> ?addi", "apply (simp add: bre_while_algo)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite \\<delta> \\<Longrightarrow>\n    wa_invar (bre'_algo Qi \\<delta>) =\n    ?addi \\<inter> {s. br'_\\<alpha> s \\<in> wa_invar (bre_algo Qi \\<delta>)}\n 2. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> ?addi;\n        s \\<in> wa_cond (bre'_algo Qi \\<delta>);\n        br'_\\<alpha> s \\<in> wa_invar (bre_algo Qi \\<delta>);\n        (s, s') \\<in> wa_step (bre'_algo Qi \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. finite \\<delta> \\<Longrightarrow>\n    wa_initial (bre'_algo Qi \\<delta>) \\<subseteq> ?addi", "apply (simp_all add: bre'_algo_def bre_algo_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite \\<delta> \\<Longrightarrow>\n    br'_invar \\<delta> =\n    ?addi \\<inter> {s. br'_\\<alpha> s \\<in> br_invar \\<delta>}\n 2. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> ?addi; s \\<in> bre'_cond Qi;\n        br'_\\<alpha> s \\<in> br_invar \\<delta>;\n        (s, s') \\<in> br'_step \\<delta>\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. finite \\<delta> \\<Longrightarrow> br'_initial \\<delta> \\<subseteq> ?addi", "apply (simp add: br'_invar_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> br'_invar_add \\<delta>;\n        s \\<in> bre'_cond Qi; br'_\\<alpha> s \\<in> br_invar \\<delta>;\n        (s, s') \\<in> br'_step \\<delta>\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> br'_invar_add \\<delta>\n 2. finite \\<delta> \\<Longrightarrow>\n    br'_initial \\<delta> \\<subseteq> br'_invar_add \\<delta>", "apply (erule (3) br'_step_invar)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow>\n    br'_initial \\<delta> \\<subseteq> br'_invar_add \\<delta>", "apply (simp add: br'_invar_initial)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas bre'_invar_final = \n  bre'_pref.transfer_correctness[OF bre_invar_final, unfolded fst_br'_\\<alpha>]"], ["", "text_raw \\<open>\\paragraph{Implementing a Step}\\<close>"], ["", "text \\<open>\n  In this paragraph, it is shown how to implement a step of the br'-algorithm \n  by iteration over the rules that have the discovered state on their RHS.\n\\<close>"], ["", "definition br'_inner_step \n  :: \"('Q,'L) ta_rule \\<Rightarrow> ('Q,'L) br'_state \\<Rightarrow> ('Q,'L) br'_state\" \n  where\n  \"br'_inner_step == \\<lambda>r (Q,W,rcm). let c=the (rcm r) in (\n    if c\\<le>1 then insert (lhs r) Q else Q,\n    if c\\<le>1 \\<and> (lhs r) \\<notin> Q then insert (lhs r) W else W,\n    rcm ( r \\<mapsto> (c-(1::nat)))\n  )\n\""], ["", "definition br'_inner_invar \n  :: \"('Q,'L) ta_rule set \\<Rightarrow> 'Q \\<Rightarrow> ('Q,'L) br'_state \n      \\<Rightarrow> ('Q,'L) ta_rule set \\<Rightarrow> ('Q,'L) br'_state \\<Rightarrow> bool\" \n  where\n  \"br'_inner_invar rules q == \\<lambda>(Q,W,rcm) it (Q',W',rcm'). \n    Q' = Q \\<union> { lhs r | r. r\\<in>rules-it \\<and> the (rcm r) \\<le> 1 } \\<and> \n    W' = (W-{q}) \\<union> ({ lhs r | r. r\\<in>rules-it \\<and> the (rcm r) \\<le> 1 } - Q) \\<and> \n    (\\<forall>r. rcm' r = (if r\\<in>rules-it then Some (the (rcm r) - 1) else rcm r))\n  \""], ["", "lemma br'_inner_invar_imp_final: \n  \"\\<lbrakk> q\\<in>W; br'_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) {} \\<Sigma>' \\<rbrakk> \n     \\<Longrightarrow> ((Q,W,rcm),\\<Sigma>') \\<in> br'_step \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> W;\n     br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n      (Q, W - {q}, rcm) {} \\<Sigma>'\\<rbrakk>\n    \\<Longrightarrow> ((Q, W, rcm), \\<Sigma>') \\<in> br'_step \\<delta>", "apply (unfold br'_inner_invar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> W;\n     (case (Q, W - {q}, rcm) of\n      (Q, W, rcm) \\<Rightarrow>\n        \\<lambda>it (Q', W', rcm').\n           Q' =\n           Q \\<union>\n           {lhs r |r.\n            r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it \\<and>\n            the (rcm r) \\<le> 1} \\<and>\n           W' =\n           W - {q} \\<union>\n           ({lhs r |r.\n             r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it \\<and>\n             the (rcm r) \\<le> 1} -\n            Q) \\<and>\n           (\\<forall>r.\n               rcm' r =\n               (if r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it\n                then Some (the (rcm r) - 1) else rcm r)))\n      {} \\<Sigma>'\\<rbrakk>\n    \\<Longrightarrow> ((Q, W, rcm), \\<Sigma>') \\<in> br'_step \\<delta>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         b);\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r)\\<rbrakk>\n       \\<Longrightarrow> ((Q, W, rcm),\n                          Q \\<union>\n                          {lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0},\n                          W - {q} \\<union>\n                          ({lhs r |r.\n                            r \\<in> \\<delta> \\<and>\n                            q \\<in> set (rhsq r) \\<and>\n                            the (rcm r) \\<le> Suc 0} -\n                           Q),\n                          b)\n                         \\<in> br'_step \\<delta>", "apply (rule br'_step.intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         b);\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r)\\<rbrakk>\n       \\<Longrightarrow> ?q10 b \\<in> W\n 2. \\<And>b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         b);\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r)\\<rbrakk>\n       \\<Longrightarrow> Q \\<union>\n                         {lhs r |r.\n                          r \\<in> \\<delta> \\<and>\n                          q \\<in> set (rhsq r) \\<and>\n                          the (rcm r) \\<le> Suc 0} =\n                         Q \\<union>\n                         {lhs r |r.\n                          r \\<in> \\<delta> \\<and>\n                          ?q10 b \\<in> set (rhsq r) \\<and>\n                          the (rcm r) \\<le> 1}\n 3. \\<And>b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         b);\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r)\\<rbrakk>\n       \\<Longrightarrow> W - {q} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0} -\n                          Q) =\n                         W - {?q10 b} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           ?q10 b \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> 1} -\n                          Q)\n 4. \\<And>b r.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         b);\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        r \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> b r =\n                         (if ?q10 b \\<in> set (rhsq r)\n                          then Some (the (rcm r) - 1) else rcm r)", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         b);\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r)\\<rbrakk>\n       \\<Longrightarrow> Q \\<union>\n                         {lhs r |r.\n                          r \\<in> \\<delta> \\<and>\n                          q \\<in> set (rhsq r) \\<and>\n                          the (rcm r) \\<le> Suc 0} =\n                         Q \\<union>\n                         {lhs r |r.\n                          r \\<in> \\<delta> \\<and>\n                          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n 2. \\<And>b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         b);\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r)\\<rbrakk>\n       \\<Longrightarrow> W - {q} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0} -\n                          Q) =\n                         W - {q} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> 1} -\n                          Q)\n 3. \\<And>b r.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (Q \\<union>\n         {lhs r |r.\n          r \\<in> \\<delta> \\<and>\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0},\n         W - {q} \\<union>\n         ({lhs r |r.\n           r \\<in> \\<delta> \\<and>\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          Q),\n         b);\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        r \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> b r =\n                         (if q \\<in> set (rhsq r)\n                          then Some (the (rcm r) - 1) else rcm r)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma br'_inner_invar_step: \n  \"\\<lbrakk> q\\<in>W; br'_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) it \\<Sigma>'; \n     r\\<in>it; it\\<subseteq>{r\\<in>\\<delta>. q\\<in>set (rhsq r)} \n   \\<rbrakk> \\<Longrightarrow> br'_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) \n                         (it-{r}) (br'_inner_step r \\<Sigma>')\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> W;\n     br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n      (Q, W - {q}, rcm) it \\<Sigma>';\n     r \\<in> it;\n     it \\<subseteq> {r \\<in> \\<delta>. q \\<in> set (rhsq r)}\\<rbrakk>\n    \\<Longrightarrow> br'_inner_invar\n                       {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n                       (Q, W - {q}, rcm) (it - {r})\n                       (br'_inner_step r \\<Sigma>')", "apply (cases \\<Sigma>', simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>q \\<in> W;\n        br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n         (Q, W - {q}, rcm) it (a, b, c);\n        r \\<in> it; it \\<subseteq> {r \\<in> \\<delta>. q \\<in> set (rhsq r)};\n        \\<Sigma>' = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> br'_inner_invar\n                          {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n                          (Q, W - {q}, rcm) (it - {r})\n                          (br'_inner_step r (a, b, c))", "apply (unfold br'_inner_invar_def br'_inner_step_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>q \\<in> W;\n        (case (Q, W - {q}, rcm) of\n         (Q, W, rcm) \\<Rightarrow>\n           \\<lambda>it (Q', W', rcm').\n              Q' =\n              Q \\<union>\n              {lhs r |r.\n               r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it \\<and>\n               the (rcm r) \\<le> 1} \\<and>\n              W' =\n              W - {q} \\<union>\n              ({lhs r |r.\n                r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it \\<and>\n                the (rcm r) \\<le> 1} -\n               Q) \\<and>\n              (\\<forall>r.\n                  rcm' r =\n                  (if r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it\n                   then Some (the (rcm r) - 1) else rcm r)))\n         it (a, b, c);\n        r \\<in> it; it \\<subseteq> {r \\<in> \\<delta>. q \\<in> set (rhsq r)};\n        \\<Sigma>' = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (case (Q, W - {q}, rcm) of\n                          (Q, W, rcm) \\<Rightarrow>\n                            \\<lambda>it (Q', W', rcm').\n                               Q' =\n                               Q \\<union>\n                               {lhs r |r.\n                                r \\<in> {r \\<in> \\<delta>.\n   q \\<in> set (rhsq r)} -\n  it \\<and>\n                                the (rcm r) \\<le> 1} \\<and>\n                               W' =\n                               W - {q} \\<union>\n                               ({lhs r |r.\n                                 r \\<in> {r \\<in> \\<delta>.\n    q \\<in> set (rhsq r)} -\n   it \\<and>\n                                 the (rcm r) \\<le> 1} -\n                                Q) \\<and>\n                               (\\<forall>r.\n                                   rcm' r =\n                                   (if r\n \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it\n                                    then Some (the (rcm r) - 1)\n                                    else rcm r)))\n                          (it - {r})\n                          (case (a, b, c) of\n                           (Q, W, rcm) \\<Rightarrow>\n                             (if the (rcm r) \\<le> 1 then insert (lhs r) Q\n                              else Q,\n                              if the (rcm r) \\<le> 1 \\<and> lhs r \\<notin> Q\n                              then insert (lhs r) W else W,\n                              rcm(r \\<mapsto> the (rcm r) - 1)))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma br'_inner_invar_initial: \n  \"\\<lbrakk> q\\<in>W \\<rbrakk> \\<Longrightarrow> br'_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) \n                               {r\\<in>\\<delta>. q\\<in>set (rhsq r)} (Q,W-{q},rcm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> W \\<Longrightarrow>\n    br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) {r \\<in> \\<delta>. q \\<in> set (rhsq r)}\n     (Q, W - {q}, rcm)", "apply (simp add: br'_inner_invar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> W \\<Longrightarrow>\n    Q =\n    Q \\<union>\n    {lhs r |r.\n     r \\<in> \\<delta> \\<and>\n     q \\<in> set (rhsq r) \\<and>\n     (r \\<in> \\<delta> \\<longrightarrow> q \\<notin> set (rhsq r)) \\<and>\n     the (rcm r) \\<le> Suc 0} \\<and>\n    W - {q} =\n    W - {q} \\<union>\n    ({lhs r |r.\n      r \\<in> \\<delta> \\<and>\n      q \\<in> set (rhsq r) \\<and>\n      (r \\<in> \\<delta> \\<longrightarrow> q \\<notin> set (rhsq r)) \\<and>\n      the (rcm r) \\<le> Suc 0} -\n     Q) \\<and>\n    (\\<forall>r.\n        r \\<in> \\<delta> \\<and>\n        q \\<in> set (rhsq r) \\<and>\n        (r \\<in> \\<delta> \\<longrightarrow>\n         q \\<notin> set (rhsq r)) \\<longrightarrow>\n        rcm r = Some (the (rcm r) - Suc 0))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma br'_inner_step_proof:\n  fixes \\<alpha>s :: \"'\\<Sigma> \\<Rightarrow> ('Q,'L) br'_state\"\n  fixes cstep :: \"('Q,'L) ta_rule \\<Rightarrow> '\\<Sigma> \\<Rightarrow> '\\<Sigma>\"\n  fixes \\<Sigma>h :: \"'\\<Sigma>\"\n  fixes cinvar :: \"('Q,'L) ta_rule set \\<Rightarrow> '\\<Sigma> \\<Rightarrow> bool\"\n\n  assumes iterable_set: \"set_iteratei \\<alpha> invar iteratei\"\n  assumes invar_initial: \"cinvar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} \\<Sigma>h\"\n  assumes invar_step: \n    \"!!it r \\<Sigma>. \\<lbrakk> r\\<in>it; it \\<subseteq> {r\\<in>\\<delta>. q\\<in>set (rhsq r)}; cinvar it \\<Sigma> \\<rbrakk> \n                 \\<Longrightarrow> cinvar (it-{r}) (cstep r \\<Sigma>)\"\n  assumes step_desc: \n    \"!!it r \\<Sigma>. \\<lbrakk> r\\<in>it; it\\<subseteq>{r\\<in>\\<delta>. q\\<in>set (rhsq r)}; cinvar it \\<Sigma> \\<rbrakk> \n                 \\<Longrightarrow> \\<alpha>s (cstep r \\<Sigma>) = br'_inner_step r (\\<alpha>s \\<Sigma>)\"\n  assumes it_set_desc: \"invar it_set\" \"\\<alpha> it_set = {r\\<in>\\<delta>. q\\<in>set (rhsq r)}\"\n\n  assumes QIW[simp]: \"q\\<in>W\"\n\n  assumes \\<Sigma>_desc[simp]: \"\\<alpha>s \\<Sigma> = (Q,W,rcm)\"\n  assumes \\<Sigma>h_desc[simp]: \"\\<alpha>s \\<Sigma>h = (Q,W-{q},rcm)\"\n\n  shows \"(\\<alpha>s \\<Sigma>, \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\\<in>br'_step \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha>s \\<Sigma>,\n     \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\n    \\<in> br'_step \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<alpha>s \\<Sigma>,\n     \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\n    \\<in> br'_step \\<delta>", "interpret set_iteratei \\<alpha> invar iteratei"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iteratei \\<alpha> invar iteratei", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<alpha>s \\<Sigma>,\n     \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\n    \\<in> br'_step \\<delta>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha>s \\<Sigma>,\n     \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\n    \\<in> br'_step \\<delta>", "apply (rule_tac \n      I=\"\\<lambda>it \\<Sigma>. cinvar it \\<Sigma> \n                \\<and> br'_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) \n                                  it (\\<alpha>s \\<Sigma>)\" \n      in iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. invar it_set\n 2. cinvar (\\<alpha> it_set) \\<Sigma>h \\<and>\n    br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (\\<alpha> it_set) (\\<alpha>s \\<Sigma>h)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> it_set;\n        cinvar it \\<sigma> \\<and>\n        br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n         (Q, W - {q}, rcm) it (\\<alpha>s \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> cinvar (it - {x}) (cstep x \\<sigma>) \\<and>\n                         br'_inner_invar\n                          {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n                          (Q, W - {q}, rcm) (it - {x})\n                          (\\<alpha>s (cstep x \\<sigma>))\n 4. \\<And>\\<sigma>.\n       cinvar {} \\<sigma> \\<and>\n       br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n        (Q, W - {q}, rcm) {} (\\<alpha>s \\<sigma>) \\<Longrightarrow>\n       (\\<alpha>s \\<Sigma>, \\<alpha>s \\<sigma>) \\<in> br'_step \\<delta>", "apply (simp_all \n      add: it_set_desc invar_initial br'_inner_invar_initial invar_step \n           step_desc br'_inner_invar_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       cinvar {} \\<sigma> \\<and>\n       br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n        (Q, W - {q}, rcm) {} (\\<alpha>s \\<sigma>) \\<Longrightarrow>\n       ((Q, W, rcm), \\<alpha>s \\<sigma>) \\<in> br'_step \\<delta>", "apply (rule br'_inner_invar_imp_final)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       cinvar {} \\<sigma> \\<and>\n       br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n        (Q, W - {q}, rcm) {} (\\<alpha>s \\<sigma>) \\<Longrightarrow>\n       ?q3 \\<sigma> \\<in> W\n 2. \\<And>\\<sigma>.\n       cinvar {} \\<sigma> \\<and>\n       br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n        (Q, W - {q}, rcm) {} (\\<alpha>s \\<sigma>) \\<Longrightarrow>\n       br'_inner_invar {r \\<in> \\<delta>. ?q3 \\<sigma> \\<in> set (rhsq r)}\n        (?q3 \\<sigma>) (Q, W - {?q3 \\<sigma>}, rcm) {} (\\<alpha>s \\<sigma>)", "apply (rule QIW)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       cinvar {} \\<sigma> \\<and>\n       br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n        (Q, W - {q}, rcm) {} (\\<alpha>s \\<sigma>) \\<Longrightarrow>\n       br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n        (Q, W - {q}, rcm) {} (\\<alpha>s \\<sigma>)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<alpha>s \\<Sigma>,\n   \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\n  \\<in> br'_step \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "text_raw \\<open>\\paragraph{Computing Witnesses}\\<close>"], ["", "text \\<open>\n  The algorithm is now refined further, such that it stores, for each discovered\n  state, a witness for non-emptiness, i.e. a tree that is accepted with the\n  discovered state.\n\\<close>\n\n\\<comment> \\<open>A map from states to trees has the witness-property, if it maps states to \n    trees that are accepted with that state:\\<close>"], ["", "definition \"witness_prop \\<delta> m == \\<forall>q t. m q = Some t \\<longrightarrow> accs \\<delta> t q\"\n\n\\<comment> \\<open>Construct a witness for the LHS of a rule, provided that the map contains \n    witnesses for all states on the RHS:\\<close>"], ["", "definition construct_witness \n  :: \"('Q \\<rightharpoonup> 'L tree) \\<Rightarrow> ('Q,'L) ta_rule \\<Rightarrow> 'L tree\"\n  where \n  \"construct_witness Q r == NODE (rhsl r) (List.map (\\<lambda>q. the (Q q)) (rhsq r))\""], ["", "lemma witness_propD: \"\\<lbrakk>witness_prop \\<delta> m; m q = Some t\\<rbrakk> \\<Longrightarrow> accs \\<delta> t q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>witness_prop \\<delta> m; m q = Some t\\<rbrakk>\n    \\<Longrightarrow> accs \\<delta> t q", "by (auto simp add: witness_prop_def)"], ["", "lemma construct_witness_correct: \n  \"\\<lbrakk> witness_prop \\<delta> Q; r\\<in>\\<delta>; set (rhsq r) \\<subseteq> dom Q \\<rbrakk> \n    \\<Longrightarrow> accs \\<delta> (construct_witness Q r) (lhs r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>witness_prop \\<delta> Q; r \\<in> \\<delta>;\n     set (rhsq r) \\<subseteq> dom Q\\<rbrakk>\n    \\<Longrightarrow> accs \\<delta> (construct_witness Q r) (lhs r)", "apply (unfold construct_witness_def witness_prop_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q t. Q q = Some t \\<longrightarrow> accs \\<delta> t q;\n     r \\<in> \\<delta>; set (rhsq r) \\<subseteq> dom Q\\<rbrakk>\n    \\<Longrightarrow> accs \\<delta>\n                       (NODE (rhsl r)\n                         (map (\\<lambda>q. the (Q q)) (rhsq r)))\n                       (lhs r)", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<forall>q t.\n                   Q q = Some t \\<longrightarrow> accs \\<delta> t q;\n        r \\<in> \\<delta>; set (rhsq r) \\<subseteq> dom Q;\n        r = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>\n                          (NODE (rhsl r)\n                            (map (\\<lambda>q. the (Q q)) (rhsq r)))\n                          (lhs r)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<forall>q t.\n                   Q q = Some t \\<longrightarrow> accs \\<delta> t q;\n        x1 \\<rightarrow> x2 x3 \\<in> \\<delta>; set x3 \\<subseteq> dom Q;\n        r = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta>\n                          (NODE x2 (map (\\<lambda>q. the (Q q)) x3)) x1", "apply (erule accs.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<forall>q t.\n                   Q q = Some t \\<longrightarrow> accs \\<delta> t q;\n        set x3 \\<subseteq> dom Q; r = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> length (map (\\<lambda>q. the (Q q)) x3) = length x3\n 2. \\<And>x1 x2 x3 i.\n       \\<lbrakk>\\<forall>q t.\n                   Q q = Some t \\<longrightarrow> accs \\<delta> t q;\n        set x3 \\<subseteq> dom Q; r = x1 \\<rightarrow> x2 x3;\n        i < length x3\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> (map (\\<lambda>q. the (Q q)) x3 ! i)\n                          (x3 ! i)", "apply (auto dest: nth_mem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma construct_witness_eq: \n  \"\\<lbrakk> Q |` set (rhsq r) = Q' |` set (rhsq r) \\<rbrakk> \\<Longrightarrow> \n    construct_witness Q r = construct_witness Q' r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q |` set (rhsq r) = Q' |` set (rhsq r) \\<Longrightarrow>\n    construct_witness Q r = construct_witness Q' r", "apply (unfold construct_witness_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q |` set (rhsq r) = Q' |` set (rhsq r) \\<Longrightarrow>\n    NODE (rhsl r) (map (\\<lambda>q. the (Q q)) (rhsq r)) =\n    NODE (rhsl r) (map (\\<lambda>q. the (Q' q)) (rhsq r))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Q |` set (rhsq r) = Q' |` set (rhsq r);\n        x \\<in> set (rhsq r)\\<rbrakk>\n       \\<Longrightarrow> the (Q x) = the (Q' x)", "apply (subgoal_tac \"Q x = Q' x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Q |` set (rhsq r) = Q' |` set (rhsq r);\n        x \\<in> set (rhsq r); Q x = Q' x\\<rbrakk>\n       \\<Longrightarrow> the (Q x) = the (Q' x)\n 2. \\<And>x.\n       \\<lbrakk>Q |` set (rhsq r) = Q' |` set (rhsq r);\n        x \\<in> set (rhsq r)\\<rbrakk>\n       \\<Longrightarrow> Q x = Q' x", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Q |` set (rhsq r) = Q' |` set (rhsq r);\n        x \\<in> set (rhsq r)\\<rbrakk>\n       \\<Longrightarrow> Q x = Q' x", "apply (drule_tac x=x in fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (rhsq r);\n        (Q |` set (rhsq r)) x = (Q' |` set (rhsq r)) x\\<rbrakk>\n       \\<Longrightarrow> Q x = Q' x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The set of discovered states is refined by a map from discovered states to \n  their witnesses:\n\\<close>"], ["", "type_synonym ('Q,'L) brw_state = \"('Q\\<rightharpoonup>'L tree) \\<times> 'Q set \\<times> (('Q,'L) ta_rule \\<rightharpoonup> nat)\""], ["", "definition brw_\\<alpha> :: \"('Q,'L) brw_state \\<Rightarrow> ('Q,'L) br'_state\" \n  where \"brw_\\<alpha> = (\\<lambda>(Q,W,rcm). (dom Q,W,rcm))\""], ["", "definition brw_invar_add :: \"('Q,'L) ta_rule set \\<Rightarrow> ('Q,'L) brw_state set\"\n  where \"brw_invar_add \\<delta> == {(Q,W,rcm). witness_prop \\<delta> Q}\""], ["", "definition \"brw_invar \\<delta> == brw_invar_add \\<delta> \\<inter> {s. brw_\\<alpha> s \\<in> br'_invar \\<delta>}\""], ["", "(* TODO:\n    This step description does not allow full flexibility, because\n    we may want to construct new witnesses from other witnesses constructed \n    in the same step!\n    \n    However, if we say t = construct_witness Q' r, may we run into cyclicity \n    problems, where a cycle of witnesses\n    may witness itself?. Hmm? As these cyclic witnesses would have to\n    be infinite, they cannot exist?\n\n    But, if we use a BFS search strategy, the current step description will \n    compute minimal depth witnesses.\n    The argumentation is, that:\n      Initially, all witnesses of depth 1 (definitely minimal) are discovered\n      A witness of depth n has children of length < n\n      The states that are initially on the workset are all those with \n      witnesses of depth 1. Thus,\n      after they have been processed, all states with witnesses of depth 2 have\n      been discovered. This argument can be iterated inductively.\n*)"], ["", "inductive_set brw_step \n  :: \"('Q,'L) ta_rule set \\<Rightarrow> (('Q,'L) brw_state \\<times> ('Q,'L) brw_state) set\" \n  for \\<delta> where\n  \"\\<lbrakk> \n     q\\<in>W;\n     dsqr = { r\\<in>\\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1 };\n     dom Q' = dom Q \\<union> lhs`dsqr;\n     !!q t. Q' q = Some t \\<Longrightarrow> Q q = Some t \n                              \\<or> (\\<exists>r\\<in>dsqr. q=lhs r \\<and> t=construct_witness Q r);\n     W' = (W-{q}) \\<union> (lhs`dsqr - dom Q);\n     !!r. r\\<in>\\<delta> \\<Longrightarrow> rcm' r = ( if q \\<in> set (rhsq r) then \n                               Some (the (rcm r) - 1) \n                             else rcm r\n                           )\n   \\<rbrakk> \\<Longrightarrow> ((Q,W,rcm),(Q',W',rcm')) \\<in> brw_step \\<delta>\""], ["", "definition brw_cond :: \"'Q set \\<Rightarrow> ('Q,'L) brw_state set\" \n  where \"brw_cond Qi == {(Q,W,rcm). W\\<noteq>{} \\<and> (Qi\\<inter>dom Q={})}\""], ["", "inductive_set brw_iq :: \"('Q,'L) ta_rule set \\<Rightarrow> ('Q \\<rightharpoonup> 'L tree) set\" \n  for \\<delta> where \n  \"\\<lbrakk> \n    \\<forall>q t. Q q = Some t \\<longrightarrow> (\\<exists>r\\<in>\\<delta>. rhsq r = [] \\<and> q = lhs r \n                                  \\<and> t = NODE (rhsl r) []);\n    \\<forall>r\\<in>\\<delta>. rhsq r = [] \\<longrightarrow> Q (lhs r) \\<noteq> None\n   \\<rbrakk> \\<Longrightarrow> Q \\<in> brw_iq \\<delta>\""], ["", "inductive_set brw_initial :: \"('Q,'L) ta_rule set \\<Rightarrow> ('Q,'L) brw_state set\" \n  for \\<delta> where\n  \"\\<lbrakk> !!r. r\\<in>\\<delta> \\<Longrightarrow> rcm r = Some (card (set (rhsq r))); Q\\<in>brw_iq \\<delta> \\<rbrakk> \n     \\<Longrightarrow> (Q, br_iq \\<delta>, rcm)\\<in>brw_initial \\<delta>\""], ["", "definition \"brw_algo Qi \\<delta> == \\<lparr>\n  wa_cond=brw_cond Qi,\n  wa_step = brw_step \\<delta>,\n  wa_initial = brw_initial \\<delta>,\n  wa_invar = brw_invar \\<delta>\n\\<rparr>\""], ["", "lemma brw_cond_abs: \"\\<Sigma>\\<in>brw_cond Qi \\<longleftrightarrow> (brw_\\<alpha> \\<Sigma>)\\<in>bre'_cond Qi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sigma> \\<in> brw_cond Qi) =\n    (brw_\\<alpha> \\<Sigma> \\<in> bre'_cond Qi)", "apply (cases \\<Sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<Sigma> = (a, b, c) \\<Longrightarrow>\n       (\\<Sigma> \\<in> brw_cond Qi) =\n       (brw_\\<alpha> \\<Sigma> \\<in> bre'_cond Qi)", "apply (simp add: brw_cond_def bre'_cond_def brw_\\<alpha>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brw_initial_abs: \"\\<Sigma>\\<in>brw_initial \\<delta> \\<Longrightarrow> brw_\\<alpha> \\<Sigma> \\<in> br'_initial \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> \\<in> brw_initial \\<delta> \\<Longrightarrow>\n    brw_\\<alpha> \\<Sigma> \\<in> br'_initial \\<delta>", "apply (cases \\<Sigma>, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b, c) \\<in> brw_initial \\<delta>;\n        \\<Sigma> = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> brw_\\<alpha> (a, b, c) \\<in> br'_initial \\<delta>", "apply (erule brw_initial.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c rcm Q.\n       \\<lbrakk>\\<Sigma> = (a, b, c); a = Q; b = br_iq \\<delta>; c = rcm;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        Q \\<in> brw_iq \\<delta>\\<rbrakk>\n       \\<Longrightarrow> brw_\\<alpha> (a, b, c) \\<in> br'_initial \\<delta>", "apply (erule brw_iq.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c rcm Q Qa.\n       \\<lbrakk>\\<Sigma> = (a, b, c); a = Q; b = br_iq \\<delta>; c = rcm;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        Q = Qa;\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow> Qa (lhs r) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> brw_\\<alpha> (a, b, c) \\<in> br'_initial \\<delta>", "apply (auto simp add: brw_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rcm Qa.\n       \\<lbrakk>\\<Sigma> = (Qa, br_iq \\<delta>, rcm);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           (\\<exists>y. Qa (lhs r) = Some y)\\<rbrakk>\n       \\<Longrightarrow> (dom Qa, br_iq \\<delta>, rcm)\n                         \\<in> br'_initial \\<delta>", "apply (subgoal_tac \"dom Qa = br_iq \\<delta>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rcm Qa.\n       \\<lbrakk>\\<Sigma> = (Qa, br_iq \\<delta>, rcm);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow> (\\<exists>y. Qa (lhs r) = Some y);\n        dom Qa = br_iq \\<delta>\\<rbrakk>\n       \\<Longrightarrow> (dom Qa, br_iq \\<delta>, rcm)\n                         \\<in> br'_initial \\<delta>\n 2. \\<And>rcm Qa.\n       \\<lbrakk>\\<Sigma> = (Qa, br_iq \\<delta>, rcm);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           (\\<exists>y. Qa (lhs r) = Some y)\\<rbrakk>\n       \\<Longrightarrow> dom Qa = br_iq \\<delta>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rcm Qa.\n       \\<lbrakk>\\<Sigma> = (Qa, br_iq \\<delta>, rcm);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow> (\\<exists>y. Qa (lhs r) = Some y);\n        dom Qa = br_iq \\<delta>\\<rbrakk>\n       \\<Longrightarrow> (br_iq \\<delta>, br_iq \\<delta>, rcm)\n                         \\<in> br'_initial \\<delta>\n 2. \\<And>rcm Qa.\n       \\<lbrakk>\\<Sigma> = (Qa, br_iq \\<delta>, rcm);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           (\\<exists>y. Qa (lhs r) = Some y)\\<rbrakk>\n       \\<Longrightarrow> dom Qa = br_iq \\<delta>", "apply (rule br'_initial.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rcm Qa r.\n       \\<lbrakk>\\<Sigma> = (Qa, br_iq \\<delta>, rcm);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow> (\\<exists>y. Qa (lhs r) = Some y);\n        dom Qa = br_iq \\<delta>; r \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> rcm r = Some (card (set (rhsq r)))\n 2. \\<And>rcm Qa.\n       \\<lbrakk>\\<Sigma> = (Qa, br_iq \\<delta>, rcm);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           (\\<exists>y. Qa (lhs r) = Some y)\\<rbrakk>\n       \\<Longrightarrow> dom Qa = br_iq \\<delta>", "apply auto [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rcm Qa.\n       \\<lbrakk>\\<Sigma> = (Qa, br_iq \\<delta>, rcm);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           (\\<exists>y. Qa (lhs r) = Some y)\\<rbrakk>\n       \\<Longrightarrow> dom Qa = br_iq \\<delta>", "apply (force simp add: br_iq_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brw_invar_initial: \"brw_initial \\<delta> \\<subseteq> brw_invar_add \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brw_initial \\<delta> \\<subseteq> brw_invar_add \\<delta>", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       (a, aa, b) \\<in> brw_initial \\<delta> \\<Longrightarrow>\n       (a, aa, b) \\<in> brw_invar_add \\<delta>", "apply (unfold brw_invar_add_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       (a, aa, b) \\<in> brw_initial \\<delta> \\<Longrightarrow>\n       (a, aa, b) \\<in> {(Q, W, rcm). witness_prop \\<delta> Q}", "apply (auto simp add: witness_prop_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b q t.\n       \\<lbrakk>(a, aa, b) \\<in> brw_initial \\<delta>; a q = Some t\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> t q", "apply (erule brw_initial.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b q t rcm Q.\n       \\<lbrakk>a q = Some t; a = Q; aa = br_iq \\<delta>; b = rcm;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        Q \\<in> brw_iq \\<delta>\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> t q", "apply (erule brw_iq.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b q t rcm Q Qa.\n       \\<lbrakk>a q = Some t; a = Q; aa = br_iq \\<delta>; b = rcm;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        Q = Qa;\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow> Qa (lhs r) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> t q", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q t rcm Qa.\n       \\<lbrakk>Qa q = Some t;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           (\\<exists>y. Qa (lhs r) = Some y)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> t q", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q t rcm Qa.\n       \\<lbrakk>Qa q = Some t;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           (\\<exists>y. Qa (lhs r) = Some y)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> t q", "case prems: (1 q t rcm Q)"], ["proof (state)\nthis:\n  Q q = Some t\n  ?r \\<in> \\<delta> \\<Longrightarrow> rcm ?r = Some (card (set (rhsq ?r)))\n  \\<forall>q t.\n     Q q = Some t \\<longrightarrow>\n     (\\<exists>r\\<in>\\<delta>.\n         rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) [])\n  \\<forall>r\\<in>\\<delta>.\n     rhsq r = [] \\<longrightarrow> (\\<exists>y. Q (lhs r) = Some y)\n\ngoal (1 subgoal):\n 1. \\<And>q t rcm Qa.\n       \\<lbrakk>Qa q = Some t;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           (\\<exists>y. Qa (lhs r) = Some y)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> t q", "from prems(3)[rule_format, OF prems(1)]"], ["proof (chain)\npicking this:\n  \\<exists>r\\<in>\\<delta>.\n     rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []", "obtain r where \n    [simp]: \"r\\<in>\\<delta>\" \"rhsq r = []\" \"q=lhs r\" \"t=NODE (rhsl r) []\""], ["proof (prove)\nusing this:\n  \\<exists>r\\<in>\\<delta>.\n     rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r \\<in> \\<delta>; rhsq r = []; q = lhs r;\n         t = NODE (rhsl r) []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r \\<in> \\<delta>\n  rhsq r = []\n  q = lhs r\n  t = NODE (rhsl r) []\n\ngoal (1 subgoal):\n 1. \\<And>q t rcm Qa.\n       \\<lbrakk>Qa q = Some t;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           (\\<exists>y. Qa (lhs r) = Some y)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> t q", "have RF[simplified]: \"r=((lhs r) \\<rightarrow> (rhsl r) (rhsq r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = lhs r \\<rightarrow> rhsl r rhsq r", "by (cases r) simp"], ["proof (state)\nthis:\n  r = lhs r \\<rightarrow> rhsl r []\n\ngoal (1 subgoal):\n 1. \\<And>q t rcm Qa.\n       \\<lbrakk>Qa q = Some t;\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm r = Some (card (set (rhsq r)));\n        \\<forall>q t.\n           Qa q = Some t \\<longrightarrow>\n           (\\<exists>r\\<in>\\<delta>.\n               rhsq r = [] \\<and> q = lhs r \\<and> t = NODE (rhsl r) []);\n        \\<forall>r\\<in>\\<delta>.\n           rhsq r = [] \\<longrightarrow>\n           (\\<exists>y. Qa (lhs r) = Some y)\\<rbrakk>\n       \\<Longrightarrow> accs \\<delta> t q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> t q", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. accs \\<delta> (NODE (rhsl r) []) (lhs r)", "apply (rule accs.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. lhs r \\<rightarrow> rhsl r ?qs1 \\<in> \\<delta>\n 2. length [] = length ?qs1\n 3. \\<And>i.\n       i < length ?qs1 \\<Longrightarrow> accs \\<delta> ([] ! i) (?qs1 ! i)", "apply (subst RF[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. r \\<in> \\<delta>\n 2. length [] = length []\n 3. \\<And>i. i < length [] \\<Longrightarrow> accs \\<delta> ([] ! i) ([] ! i)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  accs \\<delta> t q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma brw_step_abs:\n  \"\\<lbrakk> (\\<Sigma>,\\<Sigma>')\\<in>brw_step \\<delta> \\<rbrakk> \\<Longrightarrow> (brw_\\<alpha> \\<Sigma>, brw_\\<alpha> \\<Sigma>')\\<in>br'_step \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sigma>, \\<Sigma>') \\<in> brw_step \\<delta> \\<Longrightarrow>\n    (brw_\\<alpha> \\<Sigma>, brw_\\<alpha> \\<Sigma>') \\<in> br'_step \\<delta>", "apply (cases \\<Sigma>, cases \\<Sigma>', simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>((a, b, c), aa, ba, ca) \\<in> brw_step \\<delta>;\n        \\<Sigma> = (a, b, c); \\<Sigma>' = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> (brw_\\<alpha> (a, b, c), brw_\\<alpha> (aa, ba, ca))\n                         \\<in> br'_step \\<delta>", "apply (erule brw_step.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca q W dsqr rcm Q' Q W' rcm'.\n       \\<lbrakk>\\<Sigma> = (a, b, c); \\<Sigma>' = (aa, ba, ca); a = Q;\n        b = W; c = rcm; aa = Q'; ba = W'; ca = rcm'; q \\<in> W;\n        dsqr =\n        {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1};\n        dom Q' = dom Q \\<union> lhs ` dsqr;\n        \\<And>q t.\n           Q' q = Some t \\<Longrightarrow>\n           Q q = Some t \\<or>\n           (\\<exists>r\\<in>dsqr.\n               q = lhs r \\<and> t = construct_witness Q r);\n        W' = W - {q} \\<union> (lhs ` dsqr - dom Q);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> (brw_\\<alpha> (a, b, c), brw_\\<alpha> (aa, ba, ca))\n                         \\<in> br'_step \\<delta>", "apply (simp add: brw_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca q W dsqr rcm Q' Q W' rcm'.\n       \\<lbrakk>\\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q',\n         W - {q} \\<union>\n         (lhs `\n          {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          dom Q),\n         rcm');\n        a = Q; b = W; c = rcm; aa = Q';\n        ba =\n        W - {q} \\<union>\n        (lhs `\n         {r \\<in> \\<delta>.\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         dom Q);\n        ca = rcm'; q \\<in> W;\n        dsqr =\n        {r \\<in> \\<delta>.\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        dom Q' =\n        dom Q \\<union>\n        lhs `\n        {r \\<in> \\<delta>.\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<And>qa t.\n           Q' qa = Some t \\<Longrightarrow>\n           Q qa = Some t \\<or>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        W' =\n        W - {q} \\<union>\n        (lhs `\n         {r \\<in> \\<delta>.\n          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n         dom Q);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> ((dom Q, W, rcm),\n                          dom Q \\<union>\n                          lhs `\n                          {r \\<in> \\<delta>.\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0},\n                          W - {q} \\<union>\n                          (lhs `\n                           {r \\<in> \\<delta>.\n                            q \\<in> set (rhsq r) \\<and>\n                            the (rcm r) \\<le> Suc 0} -\n                           dom Q),\n                          rcm')\n                         \\<in> br'_step \\<delta>", "apply hypsubst"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca q W dsqr rcm Q' Q W' rcm'.\n       \\<lbrakk>\\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q',\n         W - {q} \\<union>\n         (lhs `\n          {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          dom Q),\n         rcm');\n        q \\<in> W;\n        dom Q' =\n        dom Q \\<union>\n        lhs `\n        {r \\<in> \\<delta>.\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<And>qa t.\n           Q' qa = Some t \\<Longrightarrow>\n           Q qa = Some t \\<or>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> ((dom Q, W, rcm),\n                          dom Q \\<union>\n                          lhs `\n                          {r \\<in> \\<delta>.\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0},\n                          W - {q} \\<union>\n                          (lhs `\n                           {r \\<in> \\<delta>.\n                            q \\<in> set (rhsq r) \\<and>\n                            the (rcm r) \\<le> Suc 0} -\n                           dom Q),\n                          rcm')\n                         \\<in> br'_step \\<delta>", "apply (rule br'_step.intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c aa ba ca q W dsqr rcm Q' Q W' rcm'.\n       \\<lbrakk>\\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q',\n         W - {q} \\<union>\n         (lhs `\n          {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          dom Q),\n         rcm');\n        q \\<in> W;\n        dom Q' =\n        dom Q \\<union>\n        lhs `\n        {r \\<in> \\<delta>.\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<And>qa t.\n           Q' qa = Some t \\<Longrightarrow>\n           Q qa = Some t \\<or>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> ?q14 a b c aa ba ca q W dsqr rcm Q' Q W' rcm'\n                         \\<in> W\n 2. \\<And>a b c aa ba ca q W dsqr rcm Q' Q W' rcm'.\n       \\<lbrakk>\\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q',\n         W - {q} \\<union>\n         (lhs `\n          {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          dom Q),\n         rcm');\n        q \\<in> W;\n        dom Q' =\n        dom Q \\<union>\n        lhs `\n        {r \\<in> \\<delta>.\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<And>qa t.\n           Q' qa = Some t \\<Longrightarrow>\n           Q qa = Some t \\<or>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> dom Q \\<union>\n                         lhs `\n                         {r \\<in> \\<delta>.\n                          q \\<in> set (rhsq r) \\<and>\n                          the (rcm r) \\<le> Suc 0} =\n                         dom Q \\<union>\n                         {lhs r |r.\n                          r \\<in> \\<delta> \\<and>\n                          ?q14 a b c aa ba ca q W dsqr rcm Q' Q W' rcm'\n                          \\<in> set (rhsq r) \\<and>\n                          the (rcm r) \\<le> 1}\n 3. \\<And>a b c aa ba ca q W dsqr rcm Q' Q W' rcm'.\n       \\<lbrakk>\\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q',\n         W - {q} \\<union>\n         (lhs `\n          {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          dom Q),\n         rcm');\n        q \\<in> W;\n        dom Q' =\n        dom Q \\<union>\n        lhs `\n        {r \\<in> \\<delta>.\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<And>qa t.\n           Q' qa = Some t \\<Longrightarrow>\n           Q qa = Some t \\<or>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> W - {q} \\<union>\n                         (lhs `\n                          {r \\<in> \\<delta>.\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0} -\n                          dom Q) =\n                         W -\n                         {?q14 a b c aa ba ca q W dsqr rcm Q' Q W'\n                           rcm'} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           ?q14 a b c aa ba ca q W dsqr rcm Q' Q W' rcm'\n                           \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> 1} -\n                          dom Q)\n 4. \\<And>a b c aa ba ca q W dsqr rcm Q' Q W' rcm' r.\n       \\<lbrakk>\\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q',\n         W - {q} \\<union>\n         (lhs `\n          {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          dom Q),\n         rcm');\n        q \\<in> W;\n        dom Q' =\n        dom Q \\<union>\n        lhs `\n        {r \\<in> \\<delta>.\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<And>qa t.\n           Q' qa = Some t \\<Longrightarrow>\n           Q qa = Some t \\<or>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1) else rcm r);\n        r \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> rcm' r =\n                         (if ?q14 a b c aa ba ca q W dsqr rcm Q' Q W' rcm'\n                             \\<in> set (rhsq r)\n                          then Some (the (rcm r) - 1) else rcm r)", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c aa ba ca q W dsqr rcm Q' Q W' rcm'.\n       \\<lbrakk>\\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q',\n         W - {q} \\<union>\n         (lhs `\n          {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          dom Q),\n         rcm');\n        q \\<in> W;\n        dom Q' =\n        dom Q \\<union>\n        lhs `\n        {r \\<in> \\<delta>.\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<And>qa t.\n           Q' qa = Some t \\<Longrightarrow>\n           Q qa = Some t \\<or>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> dom Q \\<union>\n                         lhs `\n                         {r \\<in> \\<delta>.\n                          q \\<in> set (rhsq r) \\<and>\n                          the (rcm r) \\<le> Suc 0} =\n                         dom Q \\<union>\n                         {lhs r |r.\n                          r \\<in> \\<delta> \\<and>\n                          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n 2. \\<And>a b c aa ba ca q W dsqr rcm Q' Q W' rcm'.\n       \\<lbrakk>\\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q',\n         W - {q} \\<union>\n         (lhs `\n          {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          dom Q),\n         rcm');\n        q \\<in> W;\n        dom Q' =\n        dom Q \\<union>\n        lhs `\n        {r \\<in> \\<delta>.\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<And>qa t.\n           Q' qa = Some t \\<Longrightarrow>\n           Q qa = Some t \\<or>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1)\n            else rcm r)\\<rbrakk>\n       \\<Longrightarrow> W - {q} \\<union>\n                         (lhs `\n                          {r \\<in> \\<delta>.\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0} -\n                          dom Q) =\n                         W - {q} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> 1} -\n                          dom Q)\n 3. \\<And>a b c aa ba ca q W dsqr rcm Q' Q W' rcm' r.\n       \\<lbrakk>\\<Sigma> = (Q, W, rcm);\n        \\<Sigma>' =\n        (Q',\n         W - {q} \\<union>\n         (lhs `\n          {r \\<in> \\<delta>.\n           q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n          dom Q),\n         rcm');\n        q \\<in> W;\n        dom Q' =\n        dom Q \\<union>\n        lhs `\n        {r \\<in> \\<delta>.\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<And>qa t.\n           Q' qa = Some t \\<Longrightarrow>\n           Q qa = Some t \\<or>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        \\<And>r.\n           r \\<in> \\<delta> \\<Longrightarrow>\n           rcm' r =\n           (if q \\<in> set (rhsq r) then Some (the (rcm r) - 1) else rcm r);\n        r \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> rcm' r =\n                         (if q \\<in> set (rhsq r)\n                          then Some (the (rcm r) - 1) else rcm r)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brw_step_invar:\n  assumes FIN[simp]: \"finite \\<delta>\"\n  assumes INV: \"\\<Sigma>\\<in>brw_invar_add \\<delta>\" and BR'INV: \"brw_\\<alpha> \\<Sigma> \\<in> br'_invar \\<delta>\"\n  assumes STEP: \"(\\<Sigma>,\\<Sigma>') \\<in> brw_step \\<delta>\"\n  shows \"\\<Sigma>'\\<in>brw_invar_add \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> brw_invar_add \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> brw_invar_add \\<delta>", "obtain Q W rcm Q' W' rcm' where \n    [simp]: \"\\<Sigma>=(Q,W,rcm)\" \"\\<Sigma>'=(Q',W',rcm')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q W rcm Q' W' rcm'.\n        \\<lbrakk>\\<Sigma> = (Q, W, rcm); \\<Sigma>' = (Q', W', rcm')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \\<Sigma>, cases \\<Sigma>') force"], ["proof (state)\nthis:\n  \\<Sigma> = (Q, W, rcm)\n  \\<Sigma>' = (Q', W', rcm')\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> brw_invar_add \\<delta>", "from INV"], ["proof (chain)\npicking this:\n  \\<Sigma> \\<in> brw_invar_add \\<delta>", "have WP: \"witness_prop \\<delta> Q\""], ["proof (prove)\nusing this:\n  \\<Sigma> \\<in> brw_invar_add \\<delta>\n\ngoal (1 subgoal):\n 1. witness_prop \\<delta> Q", "by (simp_all add: brw_invar_add_def)"], ["proof (state)\nthis:\n  witness_prop \\<delta> Q\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> brw_invar_add \\<delta>", "obtain qw dsqr where SPROPS:\n    \"dsqr = {r \\<in> \\<delta>. qw \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\"\n    \"qw\\<in>W\"\n    \"dom Q' = dom Q \\<union> lhs ` dsqr\"\n    \"!!q t. Q' q = Some t \\<Longrightarrow> Q q = Some t \n                              \\<or> (\\<exists>r\\<in>dsqr. q=lhs r \\<and> t=construct_witness Q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>dsqr qw.\n        \\<lbrakk>dsqr =\n                 {r \\<in> \\<delta>.\n                  qw \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1};\n         qw \\<in> W; dom Q' = dom Q \\<union> lhs ` dsqr;\n         \\<And>q t.\n            Q' q = Some t \\<Longrightarrow>\n            Q q = Some t \\<or>\n            (\\<exists>r\\<in>dsqr.\n                q = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: brw_step.cases[OF STEP[simplified]])"], ["proof (state)\nthis:\n  dsqr =\n  {r \\<in> \\<delta>. qw \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n  qw \\<in> W\n  dom Q' = dom Q \\<union> lhs ` dsqr\n  Q' ?q = Some ?t \\<Longrightarrow>\n  Q ?q = Some ?t \\<or>\n  (\\<exists>r\\<in>dsqr. ?q = lhs r \\<and> ?t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> brw_invar_add \\<delta>", "from br'_rcm_aux'[OF BR'INV[unfolded brw_\\<alpha>_def, simplified] SPROPS(2)]"], ["proof (chain)\npicking this:\n  {r \\<in> \\<delta>. qw \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  {r \\<in> \\<delta>.\n   qw \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> dom Q - (W - {qw})}", "have \n    DSQR_ALT: \"dsqr = {r \\<in> \\<delta>. qw \\<in> set (rhsq r) \n                              \\<and> set (rhsq r) \\<subseteq> dom Q - (W - {qw})}\""], ["proof (prove)\nusing this:\n  {r \\<in> \\<delta>. qw \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  {r \\<in> \\<delta>.\n   qw \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> dom Q - (W - {qw})}\n\ngoal (1 subgoal):\n 1. dsqr =\n    {r \\<in> \\<delta>.\n     qw \\<in> set (rhsq r) \\<and>\n     set (rhsq r) \\<subseteq> dom Q - (W - {qw})}", "by (simp add: SPROPS(1))"], ["proof (state)\nthis:\n  dsqr =\n  {r \\<in> \\<delta>.\n   qw \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> dom Q - (W - {qw})}\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> brw_invar_add \\<delta>", "have \"witness_prop \\<delta> Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. witness_prop \\<delta> Q'", "proof (unfold witness_prop_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "fix q t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "assume A: \"Q' q = Some t\""], ["proof (state)\nthis:\n  Q' q = Some t\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "from SPROPS(4)[OF A]"], ["proof (chain)\npicking this:\n  Q q = Some t \\<or>\n  (\\<exists>r\\<in>dsqr. q = lhs r \\<and> t = construct_witness Q r)", "have \n      \"Q q = Some t \\<or> (\\<exists>r\\<in>dsqr. q = lhs r \\<and> t = construct_witness Q r)\""], ["proof (prove)\nusing this:\n  Q q = Some t \\<or>\n  (\\<exists>r\\<in>dsqr. q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. Q q = Some t \\<or>\n    (\\<exists>r\\<in>dsqr. q = lhs r \\<and> t = construct_witness Q r)", "."], ["proof (state)\nthis:\n  Q q = Some t \\<or>\n  (\\<exists>r\\<in>dsqr. q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "moreover"], ["proof (state)\nthis:\n  Q q = Some t \\<or>\n  (\\<exists>r\\<in>dsqr. q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "{"], ["proof (state)\nthis:\n  Q q = Some t \\<or>\n  (\\<exists>r\\<in>dsqr. q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "assume C: \"Q q = Some t\""], ["proof (state)\nthis:\n  Q q = Some t\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "from witness_propD[OF WP, OF C]"], ["proof (chain)\npicking this:\n  accs \\<delta> t q", "have \"accs \\<delta> t q\""], ["proof (prove)\nusing this:\n  accs \\<delta> t q\n\ngoal (1 subgoal):\n 1. accs \\<delta> t q", "."], ["proof (state)\nthis:\n  accs \\<delta> t q\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "}"], ["proof (state)\nthis:\n  Q q = Some t \\<Longrightarrow> accs \\<delta> t q\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "moreover"], ["proof (state)\nthis:\n  Q q = Some t \\<Longrightarrow> accs \\<delta> t q\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "{"], ["proof (state)\nthis:\n  Q q = Some t \\<Longrightarrow> accs \\<delta> t q\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "assume \"r\\<in>dsqr\" and [simp]: \"q=lhs r\" \"t=construct_witness Q r\""], ["proof (state)\nthis:\n  r \\<in> dsqr\n  q = lhs r\n  t = construct_witness Q r\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "from \\<open>r\\<in>dsqr\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> dsqr", "have 1: \"r\\<in>\\<delta>\" \"set (rhsq r) \\<subseteq> dom Q\""], ["proof (prove)\nusing this:\n  r \\<in> dsqr\n\ngoal (1 subgoal):\n 1. r \\<in> \\<delta> &&& set (rhsq r) \\<subseteq> dom Q", "by (auto simp add: DSQR_ALT)"], ["proof (state)\nthis:\n  r \\<in> \\<delta>\n  set (rhsq r) \\<subseteq> dom Q\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "from construct_witness_correct[OF WP 1]"], ["proof (chain)\npicking this:\n  accs \\<delta> (construct_witness Q r) (lhs r)", "have \"accs \\<delta> t q\""], ["proof (prove)\nusing this:\n  accs \\<delta> (construct_witness Q r) (lhs r)\n\ngoal (1 subgoal):\n 1. accs \\<delta> t q", "by simp"], ["proof (state)\nthis:\n  accs \\<delta> t q\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?r2 \\<in> dsqr; q = lhs ?r2; t = construct_witness Q ?r2\\<rbrakk>\n  \\<Longrightarrow> accs \\<delta> t q\n\ngoal (1 subgoal):\n 1. \\<And>q t. Q' q = Some t \\<Longrightarrow> accs \\<delta> t q", "ultimately"], ["proof (chain)\npicking this:\n  Q q = Some t \\<or>\n  (\\<exists>r\\<in>dsqr. q = lhs r \\<and> t = construct_witness Q r)\n  Q q = Some t \\<Longrightarrow> accs \\<delta> t q\n  \\<lbrakk>?r2 \\<in> dsqr; q = lhs ?r2; t = construct_witness Q ?r2\\<rbrakk>\n  \\<Longrightarrow> accs \\<delta> t q", "show \"accs \\<delta> t q\""], ["proof (prove)\nusing this:\n  Q q = Some t \\<or>\n  (\\<exists>r\\<in>dsqr. q = lhs r \\<and> t = construct_witness Q r)\n  Q q = Some t \\<Longrightarrow> accs \\<delta> t q\n  \\<lbrakk>?r2 \\<in> dsqr; q = lhs ?r2; t = construct_witness Q ?r2\\<rbrakk>\n  \\<Longrightarrow> accs \\<delta> t q\n\ngoal (1 subgoal):\n 1. accs \\<delta> t q", "by blast"], ["proof (state)\nthis:\n  accs \\<delta> t q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  witness_prop \\<delta> Q'\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> brw_invar_add \\<delta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  witness_prop \\<delta> Q'\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<in> brw_invar_add \\<delta>", "by (simp add: brw_invar_add_def)"], ["proof (state)\nthis:\n  \\<Sigma>' \\<in> brw_invar_add \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem brw_pref_bre': \"wa_precise_refine (brw_algo Qi \\<delta>) (bre'_algo Qi \\<delta>) brw_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (brw_algo Qi \\<delta>) (bre'_algo Qi \\<delta>)\n     brw_\\<alpha>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> wa_invar (brw_algo Qi \\<delta>);\n        s \\<in> wa_cond (brw_algo Qi \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> brw_\\<alpha> s\n                         \\<in> wa_cond (bre'_algo Qi \\<delta>)\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (brw_algo Qi \\<delta>);\n        s \\<in> wa_cond (brw_algo Qi \\<delta>);\n        (s, s') \\<in> wa_step (brw_algo Qi \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> (brw_\\<alpha> s, brw_\\<alpha> s')\n                         \\<in> wa_step (bre'_algo Qi \\<delta>)\n 3. brw_\\<alpha> ` wa_initial (brw_algo Qi \\<delta>)\n    \\<subseteq> wa_initial (bre'_algo Qi \\<delta>)\n 4. brw_\\<alpha> ` wa_invar (brw_algo Qi \\<delta>)\n    \\<subseteq> wa_invar (bre'_algo Qi \\<delta>)\n 5. \\<forall>s.\n       s \\<in> wa_invar (brw_algo Qi \\<delta>) \\<and>\n       brw_\\<alpha> s\n       \\<in> wa_cond (bre'_algo Qi \\<delta>) \\<longrightarrow>\n       s \\<in> wa_cond (brw_algo Qi \\<delta>)", "apply (simp_all add: brw_algo_def bre'_algo_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> brw_invar \\<delta>; s \\<in> brw_cond Qi\\<rbrakk>\n       \\<Longrightarrow> brw_\\<alpha> s \\<in> bre'_cond Qi\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> brw_invar \\<delta>; s \\<in> brw_cond Qi;\n        (s, s') \\<in> brw_step \\<delta>\\<rbrakk>\n       \\<Longrightarrow> (brw_\\<alpha> s, brw_\\<alpha> s')\n                         \\<in> br'_step \\<delta>\n 3. brw_\\<alpha> ` brw_initial \\<delta> \\<subseteq> br'_initial \\<delta>\n 4. brw_\\<alpha> ` brw_invar \\<delta> \\<subseteq> br'_invar \\<delta>\n 5. \\<forall>a aa b.\n       (a, aa, b) \\<in> brw_invar \\<delta> \\<and>\n       brw_\\<alpha> (a, aa, b) \\<in> bre'_cond Qi \\<longrightarrow>\n       (a, aa, b) \\<in> brw_cond Qi", "apply (auto simp add: brw_cond_abs brw_step_abs brw_initial_abs brw_invar_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation brw_pref: \n  wa_precise_refine \"brw_algo Qi \\<delta>\" \"bre'_algo Qi \\<delta>\" \"brw_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (brw_algo Qi \\<delta>) (bre'_algo Qi \\<delta>)\n     brw_\\<alpha>", "using brw_pref_bre'"], ["proof (prove)\nusing this:\n  wa_precise_refine (brw_algo ?Qi ?\\<delta>) (bre'_algo ?Qi ?\\<delta>)\n   brw_\\<alpha>\n\ngoal (1 subgoal):\n 1. wa_precise_refine (brw_algo Qi \\<delta>) (bre'_algo Qi \\<delta>)\n     brw_\\<alpha>", "."], ["", "theorem brw_while_algo: \"finite \\<delta> \\<Longrightarrow> while_algo (brw_algo Qi \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<delta> \\<Longrightarrow> while_algo (brw_algo Qi \\<delta>)", "apply (rule brw_pref.wa_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite \\<delta> \\<Longrightarrow> while_algo (bre'_algo Qi \\<delta>)\n 2. finite \\<delta> \\<Longrightarrow>\n    wa_invar (brw_algo Qi \\<delta>) =\n    ?addi \\<inter>\n    {s. brw_\\<alpha> s \\<in> wa_invar (bre'_algo Qi \\<delta>)}\n 3. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> ?addi;\n        s \\<in> wa_cond (brw_algo Qi \\<delta>);\n        brw_\\<alpha> s \\<in> wa_invar (bre'_algo Qi \\<delta>);\n        (s, s') \\<in> wa_step (brw_algo Qi \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 4. finite \\<delta> \\<Longrightarrow>\n    wa_initial (brw_algo Qi \\<delta>) \\<subseteq> ?addi", "apply (simp add: bre'_while_algo)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite \\<delta> \\<Longrightarrow>\n    wa_invar (brw_algo Qi \\<delta>) =\n    ?addi \\<inter>\n    {s. brw_\\<alpha> s \\<in> wa_invar (bre'_algo Qi \\<delta>)}\n 2. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> ?addi;\n        s \\<in> wa_cond (brw_algo Qi \\<delta>);\n        brw_\\<alpha> s \\<in> wa_invar (bre'_algo Qi \\<delta>);\n        (s, s') \\<in> wa_step (brw_algo Qi \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. finite \\<delta> \\<Longrightarrow>\n    wa_initial (brw_algo Qi \\<delta>) \\<subseteq> ?addi", "apply (simp_all add: brw_algo_def bre'_algo_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite \\<delta> \\<Longrightarrow>\n    brw_invar \\<delta> =\n    ?addi \\<inter> {s. brw_\\<alpha> s \\<in> br'_invar \\<delta>}\n 2. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> ?addi; s \\<in> brw_cond Qi;\n        brw_\\<alpha> s \\<in> br'_invar \\<delta>;\n        (s, s') \\<in> brw_step \\<delta>\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. finite \\<delta> \\<Longrightarrow> brw_initial \\<delta> \\<subseteq> ?addi", "apply (simp add: brw_invar_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>finite \\<delta>; s \\<in> brw_invar_add \\<delta>;\n        s \\<in> brw_cond Qi; brw_\\<alpha> s \\<in> br'_invar \\<delta>;\n        (s, s') \\<in> brw_step \\<delta>\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> brw_invar_add \\<delta>\n 2. finite \\<delta> \\<Longrightarrow>\n    brw_initial \\<delta> \\<subseteq> brw_invar_add \\<delta>", "apply (auto intro: brw_step_invar simp add: brw_invar_initial)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fst_brw_\\<alpha>: \"fst (brw_\\<alpha> s) = dom (fst s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (brw_\\<alpha> s) = dom (fst s)", "by (cases s) (simp add: brw_\\<alpha>_def)"], ["", "theorem brw_invar_final: \n  \"\\<forall>sc. sc \\<in> wa_invar (brw_algo Qi \\<delta>) \\<and> sc \\<notin> wa_cond (brw_algo Qi \\<delta>) \n    \\<longrightarrow> (Qi \\<inter> dom (fst sc) = {}) = (Qi \\<inter> b_accessible \\<delta> = {}) \n        \\<and> (witness_prop \\<delta> (fst sc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sc.\n       sc \\<in> wa_invar (brw_algo Qi \\<delta>) \\<and>\n       sc \\<notin> wa_cond (brw_algo Qi \\<delta>) \\<longrightarrow>\n       (Qi \\<inter> dom (fst sc) = {}) =\n       (Qi \\<inter> b_accessible \\<delta> = {}) \\<and>\n       witness_prop \\<delta> (fst sc)", "apply (intro conjI allI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sc.\n       sc \\<in> wa_invar (brw_algo Qi \\<delta>) \\<and>\n       sc \\<notin> wa_cond (brw_algo Qi \\<delta>) \\<Longrightarrow>\n       (Qi \\<inter> dom (fst sc) = {}) =\n       (Qi \\<inter> b_accessible \\<delta> = {})\n 2. \\<And>sc.\n       sc \\<in> wa_invar (brw_algo Qi \\<delta>) \\<and>\n       sc \\<notin> wa_cond (brw_algo Qi \\<delta>) \\<Longrightarrow>\n       witness_prop \\<delta> (fst sc)", "using brw_pref.transfer_correctness[OF bre'_invar_final, unfolded fst_brw_\\<alpha>]"], ["proof (prove)\nusing this:\n  \\<forall>sc.\n     sc \\<in> wa_invar (brw_algo ?Qi ?\\<delta>) \\<and>\n     sc \\<notin> wa_cond (brw_algo ?Qi ?\\<delta>) \\<longrightarrow>\n     (?Qi \\<inter> dom (fst sc) = {}) =\n     (?Qi \\<inter> b_accessible ?\\<delta> = {})\n\ngoal (2 subgoals):\n 1. \\<And>sc.\n       sc \\<in> wa_invar (brw_algo Qi \\<delta>) \\<and>\n       sc \\<notin> wa_cond (brw_algo Qi \\<delta>) \\<Longrightarrow>\n       (Qi \\<inter> dom (fst sc) = {}) =\n       (Qi \\<inter> b_accessible \\<delta> = {})\n 2. \\<And>sc.\n       sc \\<in> wa_invar (brw_algo Qi \\<delta>) \\<and>\n       sc \\<notin> wa_cond (brw_algo Qi \\<delta>) \\<Longrightarrow>\n       witness_prop \\<delta> (fst sc)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sc.\n       sc \\<in> wa_invar (brw_algo Qi \\<delta>) \\<and>\n       sc \\<notin> wa_cond (brw_algo Qi \\<delta>) \\<Longrightarrow>\n       witness_prop \\<delta> (fst sc)", "apply (auto simp add: brw_algo_def brw_invar_def brw_invar_add_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text_raw \\<open>\\paragraph{Implementing a Step}\\<close>"], ["", "inductive_set brw_inner_step \n  :: \"('Q,'L) ta_rule \\<Rightarrow> (('Q,'L) brw_state \\<times> ('Q,'L) brw_state) set\" \n  for r where\n  \"\\<lbrakk>  c = the (rcm r); \\<Sigma> = (Q,W,rcm); \\<Sigma>'=(Q',W',rcm');\n     if c\\<le>1 \\<and> (lhs r) \\<notin> dom Q then \n       Q' = Q(lhs r \\<mapsto> construct_witness Q r) \n     else Q' = Q;\n     if c\\<le>1 \\<and> (lhs r) \\<notin> dom Q then \n       W' = insert (lhs r) W \n     else W' = W;\n     rcm' = rcm ( r \\<mapsto> (c-(1::nat)))\n   \\<rbrakk> \\<Longrightarrow> (\\<Sigma>,\\<Sigma>')\\<in>brw_inner_step r\""], ["", "definition brw_inner_invar \n  :: \"('Q,'L) ta_rule set \\<Rightarrow> 'Q \\<Rightarrow> ('Q,'L) brw_state \\<Rightarrow> ('Q,'L) ta_rule set \n      \\<Rightarrow> ('Q,'L) brw_state \\<Rightarrow> bool\" \n  where\n  \"brw_inner_invar rules q == \\<lambda>(Q,W,rcm) it (Q',W',rcm').\n    (br'_inner_invar rules q (brw_\\<alpha> (Q,W,rcm)) it (brw_\\<alpha> (Q',W',rcm')) \\<and>  \n    (Q'|`dom Q = Q) \\<and> \n    (let dsqr = { r\\<in>rules - it. the (rcm r) \\<le> 1 } in\n      (\\<forall>q t. Q' q = Some t \\<longrightarrow> (Q q = Some t \n           \\<or> (Q q = None \\<and> (\\<exists>r\\<in>dsqr. q=lhs r \\<and> t=construct_witness Q r))\n                                )\n      )))\n  \""], ["", "lemma brw_inner_step_abs: \n  \"(\\<Sigma>,\\<Sigma>')\\<in>brw_inner_step r \\<Longrightarrow> br'_inner_step r (brw_\\<alpha> \\<Sigma>) = brw_\\<alpha> \\<Sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sigma>, \\<Sigma>') \\<in> brw_inner_step r \\<Longrightarrow>\n    br'_inner_step r (brw_\\<alpha> \\<Sigma>) = brw_\\<alpha> \\<Sigma>'", "apply (erule brw_inner_step.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c rcm \\<Sigma>'' Q W \\<Sigma>''' Q' W' rcm'.\n       \\<lbrakk>\\<Sigma> = \\<Sigma>''; \\<Sigma>' = \\<Sigma>''';\n        c = the (rcm r); \\<Sigma>'' = (Q, W, rcm);\n        \\<Sigma>''' = (Q', W', rcm');\n        if c \\<le> 1 \\<and> lhs r \\<notin> dom Q\n        then Q' = Q(lhs r \\<mapsto> construct_witness Q r) else Q' = Q;\n        if c \\<le> 1 \\<and> lhs r \\<notin> dom Q then W' = insert (lhs r) W\n        else W' = W;\n        rcm' = rcm(r \\<mapsto> c - 1)\\<rbrakk>\n       \\<Longrightarrow> br'_inner_step r (brw_\\<alpha> \\<Sigma>) =\n                         brw_\\<alpha> \\<Sigma>'", "apply (unfold br'_inner_step_def brw_\\<alpha>_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c rcm \\<Sigma>'' Q W \\<Sigma>''' Q' W' rcm'.\n       \\<lbrakk>\\<Sigma> = \\<Sigma>''; \\<Sigma>' = \\<Sigma>''';\n        c = the (rcm r); \\<Sigma>'' = (Q, W, rcm);\n        \\<Sigma>''' = (Q', W', rcm');\n        if c \\<le> 1 \\<and> lhs r \\<notin> dom Q\n        then Q' = Q(lhs r \\<mapsto> construct_witness Q r) else Q' = Q;\n        if c \\<le> 1 \\<and> lhs r \\<notin> dom Q then W' = insert (lhs r) W\n        else W' = W;\n        rcm' = rcm(r \\<mapsto> c - 1)\\<rbrakk>\n       \\<Longrightarrow> (case case \\<Sigma> of\n                               (Q, W, rcm) \\<Rightarrow> (dom Q, W, rcm) of\n                          (Q, W, rcm) \\<Rightarrow>\n                            (if the (rcm r) \\<le> 1 then insert (lhs r) Q\n                             else Q,\n                             if the (rcm r) \\<le> 1 \\<and> lhs r \\<notin> Q\n                             then insert (lhs r) W else W,\n                             rcm(r \\<mapsto> the (rcm r) - 1))) =\n                         (case \\<Sigma>' of\n                          (Q, W, rcm) \\<Rightarrow> (dom Q, W, rcm))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brw_inner_invar_imp_final: \n  \"\\<lbrakk> q\\<in>W; brw_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) {} \\<Sigma>' \\<rbrakk> \n    \\<Longrightarrow> ((Q,W,rcm),\\<Sigma>') \\<in> brw_step \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> W;\n     brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n      (Q, W - {q}, rcm) {} \\<Sigma>'\\<rbrakk>\n    \\<Longrightarrow> ((Q, W, rcm), \\<Sigma>') \\<in> brw_step \\<delta>", "apply (unfold brw_inner_invar_def br'_inner_invar_def brw_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> W;\n     (case (Q, W - {q}, rcm) of\n      (Q, W, rcm) \\<Rightarrow>\n        \\<lambda>it (Q', W', rcm').\n           (case case (Q, W, rcm) of\n                 (Q, W, rcm) \\<Rightarrow> (dom Q, W, rcm) of\n            (Q, W, rcm) \\<Rightarrow>\n              \\<lambda>it (Q', W', rcm').\n                 Q' =\n                 Q \\<union>\n                 {lhs r |r.\n                  r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                          it \\<and>\n                  the (rcm r) \\<le> 1} \\<and>\n                 W' =\n                 W - {q} \\<union>\n                 ({lhs r |r.\n                   r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                           it \\<and>\n                   the (rcm r) \\<le> 1} -\n                  Q) \\<and>\n                 (\\<forall>r.\n                     rcm' r =\n                     (if r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 it\n                      then Some (the (rcm r) - 1) else rcm r)))\n            it (case (Q', W', rcm') of\n                (Q, W, rcm) \\<Rightarrow> (dom Q, W, rcm)) \\<and>\n           Q' |` dom Q = Q \\<and>\n           (let dsqr =\n                  {r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n                   the (rcm r) \\<le> 1}\n            in \\<forall>q t.\n                  Q' q = Some t \\<longrightarrow>\n                  Q q = Some t \\<or>\n                  Q q = None \\<and>\n                  (\\<exists>r\\<in>dsqr.\n                      q = lhs r \\<and> t = construct_witness Q r)))\n      {} \\<Sigma>'\\<rbrakk>\n    \\<Longrightarrow> ((Q, W, rcm), \\<Sigma>') \\<in> brw_step \\<delta>", "apply (auto simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n       \\<Longrightarrow> ((Q, W, rcm), x,\n                          W - {q} \\<union>\n                          ({lhs r |r.\n                            r \\<in> \\<delta> \\<and>\n                            q \\<in> set (rhsq r) \\<and>\n                            the (rcm r) \\<le> Suc 0} -\n                           dom Q),\n                          b)\n                         \\<in> brw_step \\<delta>", "apply (rule brw_step.intros)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n       \\<Longrightarrow> ?q13 x b \\<in> W\n 2. \\<And>x b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n       \\<Longrightarrow> ?dsqr13 x b =\n                         {r \\<in> \\<delta>.\n                          ?q13 x b \\<in> set (rhsq r) \\<and>\n                          the (rcm r) \\<le> 1}\n 3. \\<And>x b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n       \\<Longrightarrow> dom x = dom Q \\<union> lhs ` ?dsqr13 x b\n 4. \\<And>x b qa t.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        x qa = Some t\\<rbrakk>\n       \\<Longrightarrow> Q qa = Some t \\<or>\n                         (\\<exists>r\\<in>?dsqr13 x b.\n                             qa = lhs r \\<and> t = construct_witness Q r)\n 5. \\<And>x b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n       \\<Longrightarrow> W - {q} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0} -\n                          dom Q) =\n                         W - {?q13 x b} \\<union> (lhs ` ?dsqr13 x b - dom Q)\n 6. \\<And>x b r.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        r \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> b r =\n                         (if ?q13 x b \\<in> set (rhsq r)\n                          then Some (the (rcm r) - 1) else rcm r)", "apply assumption"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n       \\<Longrightarrow> ?dsqr13 x b =\n                         {r \\<in> \\<delta>.\n                          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n 2. \\<And>x b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n       \\<Longrightarrow> dom x = dom Q \\<union> lhs ` ?dsqr13 x b\n 3. \\<And>x b qa t.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        x qa = Some t\\<rbrakk>\n       \\<Longrightarrow> Q qa = Some t \\<or>\n                         (\\<exists>r\\<in>?dsqr13 x b.\n                             qa = lhs r \\<and> t = construct_witness Q r)\n 4. \\<And>x b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n       \\<Longrightarrow> W - {q} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0} -\n                          dom Q) =\n                         W - {q} \\<union> (lhs ` ?dsqr13 x b - dom Q)\n 5. \\<And>x b r.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        r \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> b r =\n                         (if q \\<in> set (rhsq r)\n                          then Some (the (rcm r) - 1) else rcm r)", "apply (rule refl)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n       \\<Longrightarrow> dom x =\n                         dom Q \\<union>\n                         lhs `\n                         {r \\<in> \\<delta>.\n                          q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}\n 2. \\<And>x b qa t.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        x qa = Some t\\<rbrakk>\n       \\<Longrightarrow> Q qa = Some t \\<or>\n                         (\\<exists>r\\<in>{r \\<in> \\<delta>.\n    q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> 1}.\n                             qa = lhs r \\<and> t = construct_witness Q r)\n 3. \\<And>x b.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r)\\<rbrakk>\n       \\<Longrightarrow> W - {q} \\<union>\n                         ({lhs r |r.\n                           r \\<in> \\<delta> \\<and>\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> Suc 0} -\n                          dom Q) =\n                         W - {q} \\<union>\n                         (lhs `\n                          {r \\<in> \\<delta>.\n                           q \\<in> set (rhsq r) \\<and>\n                           the (rcm r) \\<le> 1} -\n                          dom Q)\n 4. \\<And>x b r.\n       \\<lbrakk>q \\<in> W;\n        \\<Sigma>' =\n        (x, W - {q} \\<union>\n            ({lhs r |r.\n              r \\<in> \\<delta> \\<and>\n              q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} -\n             dom Q),\n         b);\n        dom x =\n        dom Q \\<union>\n        {lhs r |r.\n         r \\<in> \\<delta> \\<and>\n         q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0};\n        \\<forall>r.\n           b r =\n           (if r \\<in> \\<delta> \\<and> q \\<in> set (rhsq r)\n            then Some (the (rcm r) - 1) else rcm r);\n        x |` dom Q = Q;\n        \\<forall>qa t.\n           x qa = Some t \\<longrightarrow>\n           Q qa = Some t \\<or>\n           Q qa = None \\<and>\n           (\\<exists>r.\n               r \\<in> \\<delta> \\<and>\n               q \\<in> set (rhsq r) \\<and>\n               the (rcm r) \\<le> Suc 0 \\<and>\n               qa = lhs r \\<and> t = construct_witness Q r);\n        r \\<in> \\<delta>\\<rbrakk>\n       \\<Longrightarrow> b r =\n                         (if q \\<in> set (rhsq r)\n                          then Some (the (rcm r) - 1) else rcm r)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma brw_inner_invar_step: \n  assumes INVI: \"(Q,W,rcm)\\<in>brw_invar \\<delta>\"\n  assumes A: \"q\\<in>W\" \"r\\<in>it\" \"it\\<subseteq>{r\\<in>\\<delta>. q\\<in>set (rhsq r)}\" \n  assumes INVH: \"brw_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) it \\<Sigma>h\"\n  assumes STEP: \"(\\<Sigma>h,\\<Sigma>')\\<in>brw_inner_step r\" \n  shows \"brw_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) (it-{r}) \\<Sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "from INVI"], ["proof (chain)\npicking this:\n  (Q, W, rcm) \\<in> brw_invar \\<delta>", "have BR'_INV: \"(dom Q,W,rcm)\\<in>br'_invar \\<delta>\""], ["proof (prove)\nusing this:\n  (Q, W, rcm) \\<in> brw_invar \\<delta>\n\ngoal (1 subgoal):\n 1. (dom Q, W, rcm) \\<in> br'_invar \\<delta>", "by (simp add: brw_invar_def brw_\\<alpha>_def)"], ["proof (state)\nthis:\n  (dom Q, W, rcm) \\<in> br'_invar \\<delta>\n\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "obtain c Qh Wh rcmh Q' W' rcm' where\n    SIGMAF[simp]: \"\\<Sigma>h=(Qh,Wh,rcmh)\" \"\\<Sigma>'=(Q',W',rcm')\" and\n    CF[simp]: \"c = the (rcmh r)\" and\n    SF: \"if c\\<le>1 \\<and> (lhs r) \\<notin> dom Qh then \n           Q' = Qh(lhs r \\<mapsto> (construct_witness Qh r)) \n         else Q' = Qh\"\n\n        \"if c\\<le>1 \\<and> (lhs r) \\<notin> dom Qh then \n           W' = insert (lhs r) Wh \n         else W' = Wh\"\n\n        \"rcm' = rcmh ( r \\<mapsto> (c-(1::nat)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Qh Wh rcmh Q' W' rcm' c.\n        \\<lbrakk>\\<Sigma>h = (Qh, Wh, rcmh); \\<Sigma>' = (Q', W', rcm');\n         c = the (rcmh r);\n         if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh\n         then Q' = Qh(lhs r \\<mapsto> construct_witness Qh r) else Q' = Qh;\n         if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh\n         then W' = insert (lhs r) Wh else W' = Wh;\n         rcm' = rcmh(r \\<mapsto> c - 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast intro: brw_inner_step.cases[OF STEP])"], ["proof (state)\nthis:\n  \\<Sigma>h = (Qh, Wh, rcmh)\n  \\<Sigma>' = (Q', W', rcm')\n  c = the (rcmh r)\n  if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh\n  then Q' = Qh(lhs r \\<mapsto> construct_witness Qh r) else Q' = Qh\n  if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh then W' = insert (lhs r) Wh\n  else W' = Wh\n  rcm' = rcmh(r \\<mapsto> c - 1)\n\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "let ?rules = \"{r\\<in>\\<delta>. q\\<in>set (rhsq r)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "let ?dsqr = \"\\<lambda>it. { r\\<in>?rules - it. the (rcm r) \\<le> 1 }\""], ["proof (state)\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "from INVH"], ["proof (chain)\npicking this:\n  brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n   (Q, W - {q}, rcm) it \\<Sigma>h", "have INVHF:\n    \"br'_inner_invar ?rules q (dom Q, W-{q}, rcm) (it) (dom Qh,Wh,rcmh)\"\n    \"Qh|`dom Q = Q\"\n    \"(\\<forall>q t. Qh q = Some t \\<longrightarrow> (Q q = Some t \n         \\<or> (Q q = None \\<and> (\\<exists>r\\<in>?dsqr it. q=lhs r \\<and> t=construct_witness Q r))\n                               )\n     )\""], ["proof (prove)\nusing this:\n  brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n   (Q, W - {q}, rcm) it \\<Sigma>h\n\ngoal (1 subgoal):\n 1. br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (dom Q, W - {q}, rcm) it (dom Qh, Wh, rcmh) &&&\n    Qh |` dom Q = Q &&&\n    \\<forall>qa t.\n       Qh qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                it.\n                        the (rcm r) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "by (auto simp add: brw_inner_invar_def Let_def brw_\\<alpha>_def)"], ["proof (state)\nthis:\n  br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n   (dom Q, W - {q}, rcm) it (dom Qh, Wh, rcmh)\n  Qh |` dom Q = Q\n  \\<forall>qa t.\n     Qh qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n                      the (rcm r) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "from INVHF(1)[unfolded br'_inner_invar_def]"], ["proof (chain)\npicking this:\n  (case (dom Q, W - {q}, rcm) of\n   (Q, W, rcm) \\<Rightarrow>\n     \\<lambda>it (Q', W', rcm').\n        Q' =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it \\<and>\n         the (rcm r) \\<le> 1} \\<and>\n        W' =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it \\<and>\n          the (rcm r) \\<le> 1} -\n         Q) \\<and>\n        (\\<forall>r.\n            rcm' r =\n            (if r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it\n             then Some (the (rcm r) - 1) else rcm r)))\n   it (dom Qh, Wh, rcmh)", "have INV'HF:\n    \"dom Qh = dom Q \\<union> lhs`?dsqr it\"\n    \"(\\<forall>r. rcmh r = (if r \\<in> ?rules - it then \n                      Some (the (rcm r) - 1) \n                    else rcm r))\""], ["proof (prove)\nusing this:\n  (case (dom Q, W - {q}, rcm) of\n   (Q, W, rcm) \\<Rightarrow>\n     \\<lambda>it (Q', W', rcm').\n        Q' =\n        Q \\<union>\n        {lhs r |r.\n         r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it \\<and>\n         the (rcm r) \\<le> 1} \\<and>\n        W' =\n        W - {q} \\<union>\n        ({lhs r |r.\n          r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it \\<and>\n          the (rcm r) \\<le> 1} -\n         Q) \\<and>\n        (\\<forall>r.\n            rcm' r =\n            (if r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it\n             then Some (the (rcm r) - 1) else rcm r)))\n   it (dom Qh, Wh, rcmh)\n\ngoal (1 subgoal):\n 1. dom Qh =\n    dom Q \\<union>\n    lhs `\n    {r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n     the (rcm r) \\<le> 1} &&&\n    \\<forall>r.\n       rcmh r =\n       (if r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it\n        then Some (the (rcm r) - 1) else rcm r)", "by auto"], ["proof (state)\nthis:\n  dom Qh =\n  dom Q \\<union>\n  lhs `\n  {r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n   the (rcm r) \\<le> 1}\n  \\<forall>r.\n     rcmh r =\n     (if r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it\n      then Some (the (rcm r) - 1) else rcm r)\n\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "from brw_inner_step_abs[OF STEP] \n       br'_inner_invar_step[OF A(1) INVHF(1) A(2,3)]"], ["proof (chain)\npicking this:\n  br'_inner_step r (brw_\\<alpha> \\<Sigma>h) = brw_\\<alpha> \\<Sigma>'\n  br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n   (dom Q, W - {q}, rcm) (it - {r}) (br'_inner_step r (dom Qh, Wh, rcmh))", "have \n    G1: \"br'_inner_invar ?rules q (dom Q, W-{q}, rcm) (it-{r}) (dom Q',W',rcm')\""], ["proof (prove)\nusing this:\n  br'_inner_step r (brw_\\<alpha> \\<Sigma>h) = brw_\\<alpha> \\<Sigma>'\n  br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n   (dom Q, W - {q}, rcm) (it - {r}) (br'_inner_step r (dom Qh, Wh, rcmh))\n\ngoal (1 subgoal):\n 1. br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (dom Q, W - {q}, rcm) (it - {r}) (dom Q', W', rcm')", "by (simp add: brw_\\<alpha>_def)"], ["proof (state)\nthis:\n  br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n   (dom Q, W - {q}, rcm) (it - {r}) (dom Q', W', rcm')\n\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "moreover"], ["proof (state)\nthis:\n  br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n   (dom Q, W - {q}, rcm) (it - {r}) (dom Q', W', rcm')\n\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "have\n    \"(\\<forall>q t. Q' q = Some t \\<longrightarrow> (Q q = Some t \n        \\<or> ( Q q = None \n            \\<and> (\\<exists>r\\<in>?dsqr (it-{r}). q=lhs r \\<and> t=construct_witness Q r)\n           ) \n                              ) \n     )\" (is ?G1)\n\n    \"Q'|`dom Q = Q\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r) &&&\n    Q' |` dom Q = Q", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "assume C: \"\\<not> c\\<le>1 \\<or> lhs r \\<in> dom Qh\""], ["proof (state)\nthis:\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "with SF"], ["proof (chain)\npicking this:\n  if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh\n  then Q' = Qh(lhs r \\<mapsto> construct_witness Qh r) else Q' = Qh\n  if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh then W' = insert (lhs r) Wh\n  else W' = Wh\n  rcm' = rcmh(r \\<mapsto> c - 1)\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh", "have \"Q'=Qh\""], ["proof (prove)\nusing this:\n  if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh\n  then Q' = Qh(lhs r \\<mapsto> construct_witness Qh r) else Q' = Qh\n  if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh then W' = insert (lhs r) Wh\n  else W' = Wh\n  rcm' = rcmh(r \\<mapsto> c - 1)\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh\n\ngoal (1 subgoal):\n 1. Q' = Qh", "by auto"], ["proof (state)\nthis:\n  Q' = Qh\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "with INVHF(2,3)"], ["proof (chain)\npicking this:\n  Qh |` dom Q = Q\n  \\<forall>qa t.\n     Qh qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n                      the (rcm r) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  Q' = Qh", "have ?G1 ?G2"], ["proof (prove)\nusing this:\n  Qh |` dom Q = Q\n  \\<forall>qa t.\n     Qh qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n                      the (rcm r) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  Q' = Qh\n\ngoal (1 subgoal):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r) &&&\n    Q' |` dom Q = Q", "by auto"], ["proof (state)\nthis:\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  Q' |` dom Q = Q\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "}"], ["proof (state)\nthis:\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh \\<Longrightarrow>\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh \\<Longrightarrow>\n  Q' |` dom Q = Q\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "moreover"], ["proof (state)\nthis:\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh \\<Longrightarrow>\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh \\<Longrightarrow>\n  Q' |` dom Q = Q\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "{"], ["proof (state)\nthis:\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh \\<Longrightarrow>\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh \\<Longrightarrow>\n  Q' |` dom Q = Q\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "assume C: \"c\\<le>1\" \"lhs r\\<notin> dom Qh\""], ["proof (state)\nthis:\n  c \\<le> 1\n  lhs r \\<notin> dom Qh\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "with SF"], ["proof (chain)\npicking this:\n  if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh\n  then Q' = Qh(lhs r \\<mapsto> construct_witness Qh r) else Q' = Qh\n  if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh then W' = insert (lhs r) Wh\n  else W' = Wh\n  rcm' = rcmh(r \\<mapsto> c - 1)\n  c \\<le> 1\n  lhs r \\<notin> dom Qh", "have Q'F: \"Q'=Qh(lhs r \\<mapsto> (construct_witness Qh r))\""], ["proof (prove)\nusing this:\n  if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh\n  then Q' = Qh(lhs r \\<mapsto> construct_witness Qh r) else Q' = Qh\n  if c \\<le> 1 \\<and> lhs r \\<notin> dom Qh then W' = insert (lhs r) Wh\n  else W' = Wh\n  rcm' = rcmh(r \\<mapsto> c - 1)\n  c \\<le> 1\n  lhs r \\<notin> dom Qh\n\ngoal (1 subgoal):\n 1. Q' = Qh(lhs r \\<mapsto> construct_witness Qh r)", "by auto"], ["proof (state)\nthis:\n  Q' = Qh(lhs r \\<mapsto> construct_witness Qh r)\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "from C(2) INVHF(2) INV'HF(1)"], ["proof (chain)\npicking this:\n  lhs r \\<notin> dom Qh\n  Qh |` dom Q = Q\n  dom Qh =\n  dom Q \\<union>\n  lhs `\n  {r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n   the (rcm r) \\<le> 1}", "have G2: ?G2"], ["proof (prove)\nusing this:\n  lhs r \\<notin> dom Qh\n  Qh |` dom Q = Q\n  dom Qh =\n  dom Q \\<union>\n  lhs `\n  {r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n   the (rcm r) \\<le> 1}\n\ngoal (1 subgoal):\n 1. Q' |` dom Q = Q", "by (auto simp add: Q'F)"], ["proof (state)\nthis:\n  Q' |` dom Q = Q\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "from C(1) INV'HF A"], ["proof (chain)\npicking this:\n  c \\<le> 1\n  dom Qh =\n  dom Q \\<union>\n  lhs `\n  {r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n   the (rcm r) \\<le> 1}\n  \\<forall>r.\n     rcmh r =\n     (if r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it\n      then Some (the (rcm r) - 1) else rcm r)\n  q \\<in> W\n  r \\<in> it\n  it \\<subseteq> {r \\<in> \\<delta>. q \\<in> set (rhsq r)}", "have \n        RI: \"r\\<in>?dsqr (it-{r})\" and \n        DSS: \"dom Q \\<subseteq> dom Qh\""], ["proof (prove)\nusing this:\n  c \\<le> 1\n  dom Qh =\n  dom Q \\<union>\n  lhs `\n  {r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n   the (rcm r) \\<le> 1}\n  \\<forall>r.\n     rcmh r =\n     (if r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it\n      then Some (the (rcm r) - 1) else rcm r)\n  q \\<in> W\n  r \\<in> it\n  it \\<subseteq> {r \\<in> \\<delta>. q \\<in> set (rhsq r)}\n\ngoal (1 subgoal):\n 1. r \\<in> {ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - (it - {r}).\n             the (rcm ra) \\<le> 1} &&&\n    dom Q \\<subseteq> dom Qh", "by (auto)"], ["proof (state)\nthis:\n  r \\<in> {ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - (it - {r}).\n           the (rcm ra) \\<le> 1}\n  dom Q \\<subseteq> dom Qh\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "from br'_rcm_aux'[OF BR'_INV A(1)] RI"], ["proof (chain)\npicking this:\n  {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  {r \\<in> \\<delta>.\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> dom Q - (W - {q})}\n  r \\<in> {ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - (it - {r}).\n           the (rcm ra) \\<le> 1}", "have \n        RDQ: \"set (rhsq r) \\<subseteq> dom Q\""], ["proof (prove)\nusing this:\n  {r \\<in> \\<delta>. q \\<in> set (rhsq r) \\<and> the (rcm r) \\<le> Suc 0} =\n  {r \\<in> \\<delta>.\n   q \\<in> set (rhsq r) \\<and> set (rhsq r) \\<subseteq> dom Q - (W - {q})}\n  r \\<in> {ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - (it - {r}).\n           the (rcm ra) \\<le> 1}\n\ngoal (1 subgoal):\n 1. set (rhsq r) \\<subseteq> dom Q", "by auto"], ["proof (state)\nthis:\n  set (rhsq r) \\<subseteq> dom Q\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "with INVHF(2)"], ["proof (chain)\npicking this:\n  Qh |` dom Q = Q\n  set (rhsq r) \\<subseteq> dom Q", "have \"Qh |` set (rhsq r) = Q |` set (rhsq r)\""], ["proof (prove)\nusing this:\n  Qh |` dom Q = Q\n  set (rhsq r) \\<subseteq> dom Q\n\ngoal (1 subgoal):\n 1. Qh |` set (rhsq r) = Q |` set (rhsq r)", "by (blast intro: restrict_map_subset_eq)"], ["proof (state)\nthis:\n  Qh |` set (rhsq r) = Q |` set (rhsq r)\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "hence [simp]: \"construct_witness Qh r = construct_witness Q r\""], ["proof (prove)\nusing this:\n  Qh |` set (rhsq r) = Q |` set (rhsq r)\n\ngoal (1 subgoal):\n 1. construct_witness Qh r = construct_witness Q r", "by (blast dest: construct_witness_eq)"], ["proof (state)\nthis:\n  construct_witness Qh r = construct_witness Q r\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "from DSS C(2)"], ["proof (chain)\npicking this:\n  dom Q \\<subseteq> dom Qh\n  lhs r \\<notin> dom Qh", "have [simp]: \"Q (lhs r) = None\" \"Qh (lhs r) = None\""], ["proof (prove)\nusing this:\n  dom Q \\<subseteq> dom Qh\n  lhs r \\<notin> dom Qh\n\ngoal (1 subgoal):\n 1. Q (lhs r) = None &&& Qh (lhs r) = None", "by auto"], ["proof (state)\nthis:\n  Q (lhs r) = None\n  Qh (lhs r) = None\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "have G1: ?G1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "case prems: (1 q t)"], ["proof (state)\nthis:\n  Q' q = Some t\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "{"], ["proof (state)\nthis:\n  Q' q = Some t\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "assume [simp]: \"q=lhs r\""], ["proof (state)\nthis:\n  q = lhs r\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "from prems Q'F"], ["proof (chain)\npicking this:\n  Q' q = Some t\n  Q' = Qh(lhs r \\<mapsto> construct_witness Qh r)", "have [simp]: \"t = (construct_witness Qh r)\""], ["proof (prove)\nusing this:\n  Q' q = Some t\n  Q' = Qh(lhs r \\<mapsto> construct_witness Qh r)\n\ngoal (1 subgoal):\n 1. t = construct_witness Qh r", "by simp"], ["proof (state)\nthis:\n  t = construct_witness Qh r\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "from RI"], ["proof (chain)\npicking this:\n  r \\<in> {ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - (it - {r}).\n           the (rcm ra) \\<le> 1}", "have ?case"], ["proof (prove)\nusing this:\n  r \\<in> {ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - (it - {r}).\n           the (rcm ra) \\<le> 1}\n\ngoal (1 subgoal):\n 1. Q q = Some t \\<or>\n    Q q = None \\<and>\n    (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                              (it - {r}).\n                     the (rcm ra) \\<le> 1}.\n        q = lhs r \\<and> t = construct_witness Q r)", "by auto"], ["proof (state)\nthis:\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "}"], ["proof (state)\nthis:\n  q = lhs r \\<Longrightarrow>\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "moreover"], ["proof (state)\nthis:\n  q = lhs r \\<Longrightarrow>\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "{"], ["proof (state)\nthis:\n  q = lhs r \\<Longrightarrow>\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "assume \"q\\<noteq>lhs r\""], ["proof (state)\nthis:\n  q \\<noteq> lhs r\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "with Q'F prems"], ["proof (chain)\npicking this:\n  Q' = Qh(lhs r \\<mapsto> construct_witness Qh r)\n  Q' q = Some t\n  q \\<noteq> lhs r", "have \"Qh q = Some t\""], ["proof (prove)\nusing this:\n  Q' = Qh(lhs r \\<mapsto> construct_witness Qh r)\n  Q' q = Some t\n  q \\<noteq> lhs r\n\ngoal (1 subgoal):\n 1. Qh q = Some t", "by auto"], ["proof (state)\nthis:\n  Qh q = Some t\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "with INVHF(3)"], ["proof (chain)\npicking this:\n  \\<forall>qa t.\n     Qh qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n                      the (rcm r) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  Qh q = Some t", "have ?case"], ["proof (prove)\nusing this:\n  \\<forall>qa t.\n     Qh qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{r \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - it.\n                      the (rcm r) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  Qh q = Some t\n\ngoal (1 subgoal):\n 1. Q q = Some t \\<or>\n    Q q = None \\<and>\n    (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                              (it - {r}).\n                     the (rcm ra) \\<le> 1}.\n        q = lhs r \\<and> t = construct_witness Q r)", "by auto"], ["proof (state)\nthis:\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "}"], ["proof (state)\nthis:\n  q \\<noteq> lhs r \\<Longrightarrow>\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. \\<And>qa t.\n       Q' qa = Some t \\<Longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)", "ultimately"], ["proof (chain)\npicking this:\n  q = lhs r \\<Longrightarrow>\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)\n  q \\<noteq> lhs r \\<Longrightarrow>\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)", "show ?case"], ["proof (prove)\nusing this:\n  q = lhs r \\<Longrightarrow>\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)\n  q \\<noteq> lhs r \\<Longrightarrow>\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)\n\ngoal (1 subgoal):\n 1. Q q = Some t \\<or>\n    Q q = None \\<and>\n    (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                              (it - {r}).\n                     the (rcm ra) \\<le> 1}.\n        q = lhs r \\<and> t = construct_witness Q r)", "by blast"], ["proof (state)\nthis:\n  Q q = Some t \\<or>\n  Q q = None \\<and>\n  (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                            (it - {r}).\n                   the (rcm ra) \\<le> 1}.\n      q = lhs r \\<and> t = construct_witness Q r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "note G1 G2"], ["proof (state)\nthis:\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  Q' |` dom Q = Q\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "}"], ["proof (state)\nthis:\n  \\<lbrakk>c \\<le> 1; lhs r \\<notin> dom Qh\\<rbrakk>\n  \\<Longrightarrow> \\<forall>qa t.\n                       Q' qa = Some t \\<longrightarrow>\n                       Q qa = Some t \\<or>\n                       Q qa = None \\<and>\n                       (\\<exists>r\\<in>{ra\n  \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - (it - {r}).\n  the (rcm ra) \\<le> 1}.\n                           qa = lhs r \\<and> t = construct_witness Q r)\n  \\<lbrakk>c \\<le> 1; lhs r \\<notin> dom Qh\\<rbrakk>\n  \\<Longrightarrow> Q' |` dom Q = Q\n\ngoal (2 subgoals):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r)\n 2. Q' |` dom Q = Q", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh \\<Longrightarrow>\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh \\<Longrightarrow>\n  Q' |` dom Q = Q\n  \\<lbrakk>c \\<le> 1; lhs r \\<notin> dom Qh\\<rbrakk>\n  \\<Longrightarrow> \\<forall>qa t.\n                       Q' qa = Some t \\<longrightarrow>\n                       Q qa = Some t \\<or>\n                       Q qa = None \\<and>\n                       (\\<exists>r\\<in>{ra\n  \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - (it - {r}).\n  the (rcm ra) \\<le> 1}.\n                           qa = lhs r \\<and> t = construct_witness Q r)\n  \\<lbrakk>c \\<le> 1; lhs r \\<notin> dom Qh\\<rbrakk>\n  \\<Longrightarrow> Q' |` dom Q = Q", "show ?G1 ?G2"], ["proof (prove)\nusing this:\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh \\<Longrightarrow>\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  \\<not> c \\<le> 1 \\<or> lhs r \\<in> dom Qh \\<Longrightarrow>\n  Q' |` dom Q = Q\n  \\<lbrakk>c \\<le> 1; lhs r \\<notin> dom Qh\\<rbrakk>\n  \\<Longrightarrow> \\<forall>qa t.\n                       Q' qa = Some t \\<longrightarrow>\n                       Q qa = Some t \\<or>\n                       Q qa = None \\<and>\n                       (\\<exists>r\\<in>{ra\n  \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} - (it - {r}).\n  the (rcm ra) \\<le> 1}.\n                           qa = lhs r \\<and> t = construct_witness Q r)\n  \\<lbrakk>c \\<le> 1; lhs r \\<notin> dom Qh\\<rbrakk>\n  \\<Longrightarrow> Q' |` dom Q = Q\n\ngoal (1 subgoal):\n 1. \\<forall>qa t.\n       Q' qa = Some t \\<longrightarrow>\n       Q qa = Some t \\<or>\n       Q qa = None \\<and>\n       (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                                 (it - {r}).\n                        the (rcm ra) \\<le> 1}.\n           qa = lhs r \\<and> t = construct_witness Q r) &&&\n    Q' |` dom Q = Q", "by blast+"], ["proof (state)\nthis:\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  Q' |` dom Q = Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  Q' |` dom Q = Q\n\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "ultimately"], ["proof (chain)\npicking this:\n  br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n   (dom Q, W - {q}, rcm) (it - {r}) (dom Q', W', rcm')\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  Q' |` dom Q = Q", "show ?thesis"], ["proof (prove)\nusing this:\n  br'_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n   (dom Q, W - {q}, rcm) (it - {r}) (dom Q', W', rcm')\n  \\<forall>qa t.\n     Q' qa = Some t \\<longrightarrow>\n     Q qa = Some t \\<or>\n     Q qa = None \\<and>\n     (\\<exists>r\\<in>{ra \\<in> {r \\<in> \\<delta>. q \\<in> set (rhsq r)} -\n                               (it - {r}).\n                      the (rcm ra) \\<le> 1}.\n         qa = lhs r \\<and> t = construct_witness Q r)\n  Q' |` dom Q = Q\n\ngoal (1 subgoal):\n 1. brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'", "by (unfold brw_inner_invar_def Let_def brw_\\<alpha>_def) auto"], ["proof (state)\nthis:\n  brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n   (Q, W - {q}, rcm) (it - {r}) \\<Sigma>'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma brw_inner_invar_initial: \n  \"\\<lbrakk>q\\<in>W\\<rbrakk> \\<Longrightarrow> brw_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q (Q,W-{q},rcm) \n                             {r\\<in>\\<delta>. q\\<in>set (rhsq r)} (Q,W-{q},rcm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> W \\<Longrightarrow>\n    brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) {r \\<in> \\<delta>. q \\<in> set (rhsq r)}\n     (Q, W - {q}, rcm)", "by (simp add: brw_inner_invar_def br'_inner_invar_initial brw_\\<alpha>_def)"], ["", "theorem brw_inner_step_proof:\n  fixes \\<alpha>s :: \"'\\<Sigma> \\<Rightarrow> ('Q,'L) brw_state\"\n  fixes cstep :: \"('Q,'L) ta_rule \\<Rightarrow> '\\<Sigma> \\<Rightarrow> '\\<Sigma>\"\n  fixes \\<Sigma>h :: \"'\\<Sigma>\"\n  fixes cinvar :: \"('Q,'L) ta_rule set \\<Rightarrow> '\\<Sigma> \\<Rightarrow> bool\"\n\n  assumes set_iterate: \"set_iteratei \\<alpha> invar iteratei\"\n  assumes invar_start: \"(\\<alpha>s \\<Sigma>)\\<in>brw_invar \\<delta>\"\n  assumes invar_initial: \"cinvar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} \\<Sigma>h\"\n  assumes invar_step: \n    \"!!it r \\<Sigma>. \\<lbrakk> r\\<in>it; it \\<subseteq> {r\\<in>\\<delta>. q\\<in>set (rhsq r)}; cinvar it \\<Sigma> \\<rbrakk> \n                \\<Longrightarrow> cinvar (it-{r}) (cstep r \\<Sigma>)\"\n  assumes step_desc: \n    \"!!it r \\<Sigma>. \\<lbrakk> r\\<in>it; it\\<subseteq>{r\\<in>\\<delta>. q\\<in>set (rhsq r)}; cinvar it \\<Sigma> \\<rbrakk> \n                \\<Longrightarrow> (\\<alpha>s \\<Sigma>, \\<alpha>s (cstep r \\<Sigma>)) \\<in> brw_inner_step r\"\n  assumes it_set_desc: \"invar it_set\" \"\\<alpha> it_set = {r\\<in>\\<delta>. q\\<in>set (rhsq r)}\"\n\n  assumes QIW[simp]: \"q\\<in>W\"\n\n  assumes \\<Sigma>_desc[simp]: \"\\<alpha>s \\<Sigma> = (Q,W,rcm)\"\n  assumes \\<Sigma>h_desc[simp]: \"\\<alpha>s \\<Sigma>h = (Q,W-{q},rcm)\"\n\n  shows \"(\\<alpha>s \\<Sigma>, \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\\<in>brw_step \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha>s \\<Sigma>,\n     \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\n    \\<in> brw_step \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<alpha>s \\<Sigma>,\n     \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\n    \\<in> brw_step \\<delta>", "interpret set_iteratei \\<alpha> invar iteratei"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iteratei \\<alpha> invar iteratei", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<alpha>s \\<Sigma>,\n     \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\n    \\<in> brw_step \\<delta>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha>s \\<Sigma>,\n     \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\n    \\<in> brw_step \\<delta>", "apply (rule_tac \n      I=\"\\<lambda>it \\<Sigma>. cinvar it \\<Sigma> \\<and> brw_inner_invar {r\\<in>\\<delta>. q\\<in>set (rhsq r)} q \n                                                (Q,W-{q},rcm) it (\\<alpha>s \\<Sigma>)\" \n      in iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. invar it_set\n 2. cinvar (\\<alpha> it_set) \\<Sigma>h \\<and>\n    brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n     (Q, W - {q}, rcm) (\\<alpha> it_set) (\\<alpha>s \\<Sigma>h)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> it_set;\n        cinvar it \\<sigma> \\<and>\n        brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n         (Q, W - {q}, rcm) it (\\<alpha>s \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> cinvar (it - {x}) (cstep x \\<sigma>) \\<and>\n                         brw_inner_invar\n                          {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n                          (Q, W - {q}, rcm) (it - {x})\n                          (\\<alpha>s (cstep x \\<sigma>))\n 4. \\<And>\\<sigma>.\n       cinvar {} \\<sigma> \\<and>\n       brw_inner_invar {r \\<in> \\<delta>. q \\<in> set (rhsq r)} q\n        (Q, W - {q}, rcm) {} (\\<alpha>s \\<sigma>) \\<Longrightarrow>\n       (\\<alpha>s \\<Sigma>, \\<alpha>s \\<sigma>) \\<in> brw_step \\<delta>", "apply (auto \n      simp add: it_set_desc invar_initial brw_inner_invar_initial invar_step \n                step_desc brw_inner_invar_step[OF invar_start[simplified]] \n                brw_inner_invar_imp_final[OF QIW])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<alpha>s \\<Sigma>,\n   \\<alpha>s (iteratei it_set (\\<lambda>_. True) cstep \\<Sigma>h))\n  \\<in> brw_step \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Product Automaton\\<close>"], ["", "text \\<open>\n  The forward-reduced product automaton can be described as a state-space\n  exploration problem. \n\n  In this section, the DFS-algorithm for state-space exploration \n  (cf. Theory~@{theory Collections_Examples.Exploration} in the Isabelle Collections Framework) is refined to compute the product automaton.\n\\<close>"], ["", "type_synonym ('Q1,'Q2,'L) frp_state = \n  \"('Q1\\<times>'Q2) set \\<times> ('Q1\\<times>'Q2) list \\<times> (('Q1\\<times>'Q2),'L) ta_rule set\""], ["", "definition frp_\\<alpha> :: \"('Q1,'Q2,'L) frp_state \\<Rightarrow> ('Q1\\<times>'Q2) dfs_state\"\n  where \"frp_\\<alpha> S == let (Q,W,\\<delta>)=S in (Q, W)\""], ["", "definition \"frp_invar_add \\<delta>1 \\<delta>2 == \n  { (Q,W,\\<delta>d). \\<delta>d = { r. r\\<in>\\<delta>_prod \\<delta>1 \\<delta>2 \\<and> lhs r \\<in> Q - set W} }\""], ["", "definition frp_invar \n  :: \"('Q1, 'L) tree_automaton_rec \\<Rightarrow> ('Q2, 'L) tree_automaton_rec \n      \\<Rightarrow> ('Q1,'Q2,'L) frp_state set\"\n  where \"frp_invar T1 T2 == \n  frp_invar_add (ta_rules T1) (ta_rules T2) \n  \\<inter> { s. frp_\\<alpha> s \\<in> dfs_invar (ta_initial T1 \\<times> ta_initial T2) \n                              (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2))) }\""], ["", "inductive_set frp_step \n  :: \"('Q1,'L) ta_rule set \\<Rightarrow> ('Q2,'L) ta_rule set \n      \\<Rightarrow> (('Q1,'Q2,'L) frp_state \\<times> ('Q1,'Q2,'L) frp_state) set\" \n  for \\<delta>1 \\<delta>2 where\n  \"\\<lbrakk> W=(q1,q2)#Wtl;\n     distinct Wn;\n     set Wn = f_succ (\\<delta>_prod \\<delta>1 \\<delta>2) `` {(q1,q2)} - Q;\n     W'=Wn@Wtl;\n     Q'=Q \\<union> f_succ (\\<delta>_prod \\<delta>1 \\<delta>2) `` {(q1,q2)};\n     \\<delta>d'=\\<delta>d \\<union> {r\\<in>\\<delta>_prod \\<delta>1 \\<delta>2. lhs r = (q1,q2) }\n  \\<rbrakk> \\<Longrightarrow> ((Q,W,\\<delta>d),(Q',W',\\<delta>d'))\\<in>frp_step \\<delta>1 \\<delta>2\""], ["", "inductive_set frp_initial :: \"'Q1 set \\<Rightarrow> 'Q2 set \\<Rightarrow> ('Q1,'Q2,'L) frp_state set\"\n  for Q10 Q20 where \n  \"\\<lbrakk> distinct W; set W = Q10\\<times>Q20 \\<rbrakk> \\<Longrightarrow> (Q10\\<times>Q20,W,{}) \\<in> frp_initial Q10 Q20\""], ["", "definition frp_cond :: \"('Q1,'Q2,'L) frp_state set\" where\n  \"frp_cond == {(Q,W,\\<delta>d). W\\<noteq>[]}\""], ["", "definition \"frp_algo T1 T2 == \\<lparr>\n  wa_cond = frp_cond,\n  wa_step = frp_step (ta_rules T1) (ta_rules T2),\n  wa_initial = frp_initial (ta_initial T1) (ta_initial T2),\n  wa_invar = frp_invar T1 T2\n\\<rparr>\"\n\n  \\<comment> \\<open>The algorithm refines the DFS-algorithm\\<close>"], ["", "theorem frp_pref_dfs: \n  \"wa_precise_refine (frp_algo T1 T2) \n     (dfs_algo (ta_initial T1 \\<times> ta_initial T2) \n               (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2))))\n     frp_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (frp_algo T1 T2)\n     (dfs_algo (ta_initial T1 \\<times> ta_initial T2)\n       (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2))))\n     frp_\\<alpha>", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> wa_invar (frp_algo T1 T2);\n        s \\<in> wa_cond (frp_algo T1 T2)\\<rbrakk>\n       \\<Longrightarrow> frp_\\<alpha> s\n                         \\<in> wa_cond\n                                (dfs_algo\n                                  (ta_initial T1 \\<times> ta_initial T2)\n                                  (f_succ\n                                    (\\<delta>_prod (ta_rules T1)\n(ta_rules T2))))\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (frp_algo T1 T2);\n        s \\<in> wa_cond (frp_algo T1 T2);\n        (s, s') \\<in> wa_step (frp_algo T1 T2)\\<rbrakk>\n       \\<Longrightarrow> (frp_\\<alpha> s, frp_\\<alpha> s')\n                         \\<in> wa_step\n                                (dfs_algo\n                                  (ta_initial T1 \\<times> ta_initial T2)\n                                  (f_succ\n                                    (\\<delta>_prod (ta_rules T1)\n(ta_rules T2))))\n 3. frp_\\<alpha> ` wa_initial (frp_algo T1 T2)\n    \\<subseteq> wa_initial\n                 (dfs_algo (ta_initial T1 \\<times> ta_initial T2)\n                   (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2))))\n 4. frp_\\<alpha> ` wa_invar (frp_algo T1 T2)\n    \\<subseteq> wa_invar\n                 (dfs_algo (ta_initial T1 \\<times> ta_initial T2)\n                   (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2))))\n 5. \\<forall>s.\n       s \\<in> wa_invar (frp_algo T1 T2) \\<and>\n       frp_\\<alpha> s\n       \\<in> wa_cond\n              (dfs_algo (ta_initial T1 \\<times> ta_initial T2)\n                (f_succ\n                  (\\<delta>_prod (ta_rules T1)\n                    (ta_rules T2)))) \\<longrightarrow>\n       s \\<in> wa_cond (frp_algo T1 T2)", "apply (auto simp add: frp_algo_def frp_\\<alpha>_def frp_cond_def dfs_algo_def \n                        dfs_cond_def frp_invar_def\n    elim!: frp_step.cases frp_initial.cases\n    intro: dfs_step.intros dfs_initial.intros\n  )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation frp_ref: wa_precise_refine \"(frp_algo T1 T2)\"\n                  \"(dfs_algo (ta_initial T1 \\<times> ta_initial T2) \n                             (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2))))\"\n                  \"frp_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (frp_algo T1 T2)\n     (dfs_algo (ta_initial T1 \\<times> ta_initial T2)\n       (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2))))\n     frp_\\<alpha>", "using frp_pref_dfs"], ["proof (prove)\nusing this:\n  wa_precise_refine (frp_algo ?T1.0 ?T2.0)\n   (dfs_algo (ta_initial ?T1.0 \\<times> ta_initial ?T2.0)\n     (f_succ (\\<delta>_prod (ta_rules ?T1.0) (ta_rules ?T2.0))))\n   frp_\\<alpha>\n\ngoal (1 subgoal):\n 1. wa_precise_refine (frp_algo T1 T2)\n     (dfs_algo (ta_initial T1 \\<times> ta_initial T2)\n       (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2))))\n     frp_\\<alpha>", ".\n\n\\<comment> \\<open>The algorithm is a well-defined while-algorithm\\<close>"], ["", "theorem frp_while_algo:\n  assumes TA: \"tree_automaton T1\" \n              \"tree_automaton T2\"\n  shows \"while_algo (frp_algo T1 T2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (frp_algo T1 T2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (frp_algo T1 T2)", "interpret t1: tree_automaton T1"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton T1", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (frp_algo T1 T2)", "interpret t2: tree_automaton T2"], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_automaton T2", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (frp_algo T1 T2)", "have finite: \"finite ((f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2)))\\<^sup>* \n               `` (ta_initial T1 \\<times> ta_initial T2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n      (t1.Qi \\<times> t2.Qi))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     ((f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n      (t1.Qi \\<times> t2.Qi))", "have \"((f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2)))\\<^sup>* \n               `` (ta_initial T1 \\<times> ta_initial T2)) \n          \\<subseteq> ((ta_initial T1 \\<times> ta_initial T2) \n             \\<union> \\<delta>_states (\\<delta>_prod (ta_rules T1) (ta_rules T2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n    (t1.Qi \\<times> t2.Qi)\n    \\<subseteq> t1.Qi \\<times> t2.Qi \\<union>\n                \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n               (t1.Qi \\<times> t2.Qi) \\<Longrightarrow>\n       x \\<in> t1.Qi \\<times> t2.Qi \\<union>\n               \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>)", "apply (drule f_accessible_subset[unfolded f_accessible_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> t1.Qi \\<times> t2.Qi \\<union>\n               \\<delta>_states\n                (\\<delta>_prod t1.\\<delta> t2.\\<delta>) \\<Longrightarrow>\n       x \\<in> t1.Qi \\<times> t2.Qi \\<union>\n               \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n  (t1.Qi \\<times> t2.Qi)\n  \\<subseteq> t1.Qi \\<times> t2.Qi \\<union>\n              \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>)\n\ngoal (1 subgoal):\n 1. finite\n     ((f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n      (t1.Qi \\<times> t2.Qi))", "moreover"], ["proof (state)\nthis:\n  (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n  (t1.Qi \\<times> t2.Qi)\n  \\<subseteq> t1.Qi \\<times> t2.Qi \\<union>\n              \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>)\n\ngoal (1 subgoal):\n 1. finite\n     ((f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n      (t1.Qi \\<times> t2.Qi))", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (t1.Qi \\<times> t2.Qi \\<union>\n      \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>))", "by auto"], ["proof (state)\nthis:\n  finite\n   (t1.Qi \\<times> t2.Qi \\<union>\n    \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\n\ngoal (1 subgoal):\n 1. finite\n     ((f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n      (t1.Qi \\<times> t2.Qi))", "ultimately"], ["proof (chain)\npicking this:\n  (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n  (t1.Qi \\<times> t2.Qi)\n  \\<subseteq> t1.Qi \\<times> t2.Qi \\<union>\n              \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>)\n  finite\n   (t1.Qi \\<times> t2.Qi \\<union>\n    \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>))", "show ?thesis"], ["proof (prove)\nusing this:\n  (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n  (t1.Qi \\<times> t2.Qi)\n  \\<subseteq> t1.Qi \\<times> t2.Qi \\<union>\n              \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>)\n  finite\n   (t1.Qi \\<times> t2.Qi \\<union>\n    \\<delta>_states (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\n\ngoal (1 subgoal):\n 1. finite\n     ((f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n      (t1.Qi \\<times> t2.Qi))", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  finite\n   ((f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n    (t1.Qi \\<times> t2.Qi))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   ((f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>))\\<^sup>* ``\n    (t1.Qi \\<times> t2.Qi))\n\ngoal (1 subgoal):\n 1. while_algo (frp_algo T1 T2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (frp_algo T1 T2)", "apply (rule frp_ref.wa_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. while_algo\n     (dfs_algo (t1.Qi \\<times> t2.Qi)\n       (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>)))\n 2. wa_invar (frp_algo T1 T2) =\n    ?addi \\<inter>\n    {s. frp_\\<alpha> s\n        \\<in> wa_invar\n               (dfs_algo (t1.Qi \\<times> t2.Qi)\n                 (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>)))}\n 3. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi; s \\<in> wa_cond (frp_algo T1 T2);\n        frp_\\<alpha> s\n        \\<in> wa_invar\n               (dfs_algo (t1.Qi \\<times> t2.Qi)\n                 (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>)));\n        (s, s') \\<in> wa_step (frp_algo T1 T2)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 4. wa_initial (frp_algo T1 T2) \\<subseteq> ?addi", "apply (rule dfs_while_algo[OF finite])"], ["proof (prove)\ngoal (3 subgoals):\n 1. wa_invar (frp_algo T1 T2) =\n    ?addi \\<inter>\n    {s. frp_\\<alpha> s\n        \\<in> wa_invar\n               (dfs_algo (t1.Qi \\<times> t2.Qi)\n                 (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>)))}\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi; s \\<in> wa_cond (frp_algo T1 T2);\n        frp_\\<alpha> s\n        \\<in> wa_invar\n               (dfs_algo (t1.Qi \\<times> t2.Qi)\n                 (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>)));\n        (s, s') \\<in> wa_step (frp_algo T1 T2)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. wa_initial (frp_algo T1 T2) \\<subseteq> ?addi", "apply (simp add: frp_algo_def dfs_algo_def frp_invar_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> frp_invar_add t1.\\<delta> t2.\\<delta>;\n        s \\<in> wa_cond (frp_algo T1 T2);\n        frp_\\<alpha> s\n        \\<in> wa_invar\n               (dfs_algo (t1.Qi \\<times> t2.Qi)\n                 (f_succ (\\<delta>_prod t1.\\<delta> t2.\\<delta>)));\n        (s, s') \\<in> wa_step (frp_algo T1 T2)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> frp_invar_add t1.\\<delta> t2.\\<delta>\n 2. wa_initial (frp_algo T1 T2)\n    \\<subseteq> frp_invar_add t1.\\<delta> t2.\\<delta>", "apply (auto simp add: dfs_algo_def frp_algo_def frp_\\<alpha>_def \n                          dfs_\\<alpha>_def frp_invar_add_def dfs_invar_def \n                          dfs_invar_add_def sse_invar_def \n                elim!: frp_step.cases) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_initial (frp_algo T1 T2)\n    \\<subseteq> frp_invar_add t1.\\<delta> t2.\\<delta>", "apply (force simp add: frp_algo_def frp_invar_add_def \n                 elim!: frp_initial.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  while_algo (frp_algo T1 T2)\n\ngoal:\nNo subgoals!", "qed\n\n(* unused\nlemma f_succ_adv: \n  \"\\<lbrakk>lhs r \\<in> (f_succ \\<delta>)\\<^sup>* `` Q0; r\\<in>\\<delta>\\<rbrakk> \\<Longrightarrow> set (rhsq r) \\<subseteq> (f_succ \\<delta>)\\<^sup>* `` Q0\"\n  by (case_tac r) (auto dest: rtrancl_into_rtrancl intro: f_succ.intros)\n*)\n\n\\<comment> \\<open>If the algorithm terminates, the forward reduced product automaton \n    can be constructed from the result\\<close>"], ["", "theorem frp_inv_final:\n  \"\\<forall>s. s\\<in>wa_invar (frp_algo T1 T2) \\<and> s\\<notin>wa_cond (frp_algo T1 T2)\n       \\<longrightarrow> (case s of (Q,W,\\<delta>d) \\<Rightarrow> \n             \\<lparr> ta_initial = ta_initial T1 \\<times> ta_initial T2, \n               ta_rules = \\<delta>d \n             \\<rparr> = ta_fwd_reduce (ta_prod T1 T2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> wa_invar (frp_algo T1 T2) \\<and>\n       s \\<notin> wa_cond (frp_algo T1 T2) \\<longrightarrow>\n       (case s of\n        (Q, W, \\<delta>d) \\<Rightarrow>\n          \\<lparr>ta_initial = ta_initial T1 \\<times> ta_initial T2,\n             ta_rules = \\<delta>d\\<rparr> =\n          ta_fwd_reduce (ta_prod T1 T2))", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> wa_invar (frp_algo T1 T2) \\<and>\n       s \\<notin> wa_cond (frp_algo T1 T2) \\<Longrightarrow>\n       case s of\n       (Q, W, \\<delta>d) \\<Rightarrow>\n         \\<lparr>ta_initial = ta_initial T1 \\<times> ta_initial T2,\n            ta_rules = \\<delta>d\\<rparr> =\n         ta_fwd_reduce (ta_prod T1 T2)", "apply (case_tac s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b c.\n       \\<lbrakk>s \\<in> wa_invar (frp_algo T1 T2) \\<and>\n                s \\<notin> wa_cond (frp_algo T1 T2);\n        s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> case s of\n                         (Q, W, \\<delta>d) \\<Rightarrow>\n                           \\<lparr>ta_initial =\n                                     ta_initial T1 \\<times> ta_initial T2,\n                              ta_rules = \\<delta>d\\<rparr> =\n                           ta_fwd_reduce (ta_prod T1 T2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b c.\n       \\<lbrakk>(a, b, c) \\<in> wa_invar (frp_algo T1 T2) \\<and>\n                (a, b, c) \\<notin> wa_cond (frp_algo T1 T2);\n        s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>ta_initial =\n                                   ta_initial T1 \\<times> ta_initial T2,\n                            ta_rules = c\\<rparr> =\n                         ta_fwd_reduce (ta_prod T1 T2)", "apply (simp add: ta_reduce_def ta_prod_def frp_algo_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b c.\n       \\<lbrakk>(a, b, c) \\<in> frp_invar T1 T2 \\<and>\n                (a, b, c) \\<notin> frp_cond;\n        s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> c =\n                         reduce_rules\n                          (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n                          (f_accessible\n                            (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n                            (ta_initial T1 \\<times> ta_initial T2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a b c.\n       \\<lbrakk>(a, b, c) \\<in> frp_invar T1 T2 \\<and>\n                (a, b, c) \\<notin> frp_cond;\n        s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> c =\n                         reduce_rules\n                          (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n                          (f_accessible\n                            (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n                            (ta_initial T1 \\<times> ta_initial T2))", "fix Q W \\<delta>d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a b c.\n       \\<lbrakk>(a, b, c) \\<in> frp_invar T1 T2 \\<and>\n                (a, b, c) \\<notin> frp_cond;\n        s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> c =\n                         reduce_rules\n                          (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n                          (f_accessible\n                            (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n                            (ta_initial T1 \\<times> ta_initial T2))", "assume A: \"(Q,W,\\<delta>d)\\<in>frp_invar T1 T2 \\<and> (Q,W,\\<delta>d)\\<notin>frp_cond\""], ["proof (state)\nthis:\n  (Q, W, \\<delta>d) \\<in> frp_invar T1 T2 \\<and>\n  (Q, W, \\<delta>d) \\<notin> frp_cond\n\ngoal (1 subgoal):\n 1. \\<And>s a b c.\n       \\<lbrakk>(a, b, c) \\<in> frp_invar T1 T2 \\<and>\n                (a, b, c) \\<notin> frp_cond;\n        s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> c =\n                         reduce_rules\n                          (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n                          (f_accessible\n                            (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n                            (ta_initial T1 \\<times> ta_initial T2))", "from frp_ref.transfer_correctness[OF dfs_invar_final, \n                                    unfolded frp_algo_def, simplified, \n                                    rule_format, OF A]"], ["proof (chain)\npicking this:\n  fst (dfs_\\<alpha> (frp_\\<alpha> (Q, W, \\<delta>d))) =\n  (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2)))\\<^sup>* ``\n  (ta_initial T1 \\<times> ta_initial T2)", "have [simp]: \"Q = f_accessible (\\<delta>_prod (ta_rules T1) (ta_rules T2)) \n                                 (ta_initial T1 \\<times> ta_initial T2)\""], ["proof (prove)\nusing this:\n  fst (dfs_\\<alpha> (frp_\\<alpha> (Q, W, \\<delta>d))) =\n  (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2)))\\<^sup>* ``\n  (ta_initial T1 \\<times> ta_initial T2)\n\ngoal (1 subgoal):\n 1. Q =\n    f_accessible (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n     (ta_initial T1 \\<times> ta_initial T2)", "by (simp add: f_accessible_def dfs_\\<alpha>_def frp_\\<alpha>_def)"], ["proof (state)\nthis:\n  Q =\n  f_accessible (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n   (ta_initial T1 \\<times> ta_initial T2)\n\ngoal (1 subgoal):\n 1. \\<And>s a b c.\n       \\<lbrakk>(a, b, c) \\<in> frp_invar T1 T2 \\<and>\n                (a, b, c) \\<notin> frp_cond;\n        s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> c =\n                         reduce_rules\n                          (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n                          (f_accessible\n                            (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n                            (ta_initial T1 \\<times> ta_initial T2))", "from A"], ["proof (chain)\npicking this:\n  (Q, W, \\<delta>d) \\<in> frp_invar T1 T2 \\<and>\n  (Q, W, \\<delta>d) \\<notin> frp_cond", "show \"\\<delta>d = reduce_rules \n    (\\<delta>_prod (ta_rules T1) (ta_rules T2)) \n    (f_accessible (\\<delta>_prod (ta_rules T1) (ta_rules T2)) \n                  (ta_initial T1 \\<times> ta_initial T2))\""], ["proof (prove)\nusing this:\n  (Q, W, \\<delta>d) \\<in> frp_invar T1 T2 \\<and>\n  (Q, W, \\<delta>d) \\<notin> frp_cond\n\ngoal (1 subgoal):\n 1. \\<delta>d =\n    reduce_rules (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n     (f_accessible (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n       (ta_initial T1 \\<times> ta_initial T2))", "apply (auto simp add: reduce_rules_def f_accessible_def frp_invar_def \n                          frp_invar_add_def frp_\\<alpha>_def frp_cond_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b aa ba.\n       \\<lbrakk>\\<delta>d =\n                {r \\<in> \\<delta>_prod (ta_rules T1) (ta_rules T2).\n                 lhs r\n                 \\<in> (f_succ\n                         (\\<delta>_prod (ta_rules T1)\n                           (ta_rules T2)))\\<^sup>* ``\n                       (ta_initial T1 \\<times> ta_initial T2)};\n        ((f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2)))\\<^sup>* ``\n         (ta_initial T1 \\<times> ta_initial T2),\n         [])\n        \\<in> dfs_invar (ta_initial T1 \\<times> ta_initial T2)\n               (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2)));\n        W = []; x \\<in> \\<delta>_prod (ta_rules T1) (ta_rules T2);\n        ((a, b), lhs x)\n        \\<in> (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2)))\\<^sup>*;\n        a \\<in> ta_initial T1; b \\<in> ta_initial T2;\n        (aa, ba) \\<in> rule_states x\\<rbrakk>\n       \\<Longrightarrow> (aa, ba)\n                         \\<in> (f_succ\n                                 (\\<delta>_prod (ta_rules T1)\n                                   (ta_rules T2)))\\<^sup>* ``\n                               (ta_initial T1 \\<times> ta_initial T2)", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b aa ba x1 x2 x3.\n       \\<lbrakk>\\<delta>d =\n                {r \\<in> \\<delta>_prod (ta_rules T1) (ta_rules T2).\n                 lhs r\n                 \\<in> (f_succ\n                         (\\<delta>_prod (ta_rules T1)\n                           (ta_rules T2)))\\<^sup>* ``\n                       (ta_initial T1 \\<times> ta_initial T2)};\n        ((f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2)))\\<^sup>* ``\n         (ta_initial T1 \\<times> ta_initial T2),\n         [])\n        \\<in> dfs_invar (ta_initial T1 \\<times> ta_initial T2)\n               (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2)));\n        W = []; x \\<in> \\<delta>_prod (ta_rules T1) (ta_rules T2);\n        ((a, b), lhs x)\n        \\<in> (f_succ (\\<delta>_prod (ta_rules T1) (ta_rules T2)))\\<^sup>*;\n        a \\<in> ta_initial T1; b \\<in> ta_initial T2;\n        (aa, ba) \\<in> rule_states x; x = x1 \\<rightarrow> x2 x3\\<rbrakk>\n       \\<Longrightarrow> (aa, ba)\n                         \\<in> (f_succ\n                                 (\\<delta>_prod (ta_rules T1)\n                                   (ta_rules T2)))\\<^sup>* ``\n                               (ta_initial T1 \\<times> ta_initial T2)", "apply (auto dest: rtrancl_into_rtrancl intro: f_succ.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<delta>d =\n  reduce_rules (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n   (f_accessible (\\<delta>_prod (ta_rules T1) (ta_rules T2))\n     (ta_initial T1 \\<times> ta_initial T2))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}