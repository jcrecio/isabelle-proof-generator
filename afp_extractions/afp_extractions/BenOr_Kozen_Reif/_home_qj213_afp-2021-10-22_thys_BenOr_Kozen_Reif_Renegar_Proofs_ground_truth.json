{"file_name": "/home/qj213/afp-2021-10-22/thys/BenOr_Kozen_Reif/Renegar_Proofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BenOr_Kozen_Reif", "problem_names": ["lemma construct_NofI_R_relation:\n  fixes p:: \"real poly\"\n  fixes I1:: \"real poly list\"\n  fixes I2:: \"real poly list\"\n  shows \"construct_NofI_R p I1 I2 =\n    construct_NofI (sum_list (map power2 (p # I1))) I2\"", "lemma sum_list_map_power2:\n  shows \"sum_list (map power2 ls) \\<ge> (0::real poly)\"", "lemma sum_list_map_power2_poly:\n  shows \"poly (sum_list (map power2 (ls::real poly list))) x \\<ge> (0::real)\"", "lemma construct_NofI_R_prop_helper:\n  fixes p:: \"real poly\"\n  fixes I1:: \"real poly list\"\n  fixes I2:: \"real poly list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  shows \"construct_NofI_R p I1 I2 =\n    rat_of_int (int (card {x. poly (sum_list (map (\\<lambda>x. x^2) (p # I1))) x = 0 \\<and> poly (prod_list I2) x > 0}) - \n    int (card {x. poly (sum_list (map (\\<lambda>x. x^2) (p # I1))) x = 0  \\<and> poly (prod_list I2) x < 0}))\"", "lemma zer_iff:\n  fixes p:: \"real poly\"\n  fixes ls:: \"real poly list\"\n  shows \"poly (sum_list (map (\\<lambda>x. x^2) ls)) x = 0 \\<longleftrightarrow> (\\<forall>i \\<in> set ls. poly i x = 0)\"", "lemma construct_NofI_prop_R:\n  fixes p:: \"real poly\"\n  fixes I1:: \"real poly list\"\n  fixes I2:: \"real poly list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  shows \"construct_NofI_R p I1 I2 =\n    rat_of_int (int (card {x. poly p x = 0 \\<and> (\\<forall>q \\<in> set I1. poly q x = 0) \\<and> poly (prod_list I2) x > 0}) - \n    int (card {x. poly p x = 0  \\<and> (\\<forall>q \\<in> set I1. poly q x = 0) \\<and> poly (prod_list I2) x < 0}))\"", "lemma alt_matrix_char_R: \"alt_matrix_A_R signs subsets = matrix_A_R signs subsets\"", "lemma subsets_are_rows_R: \"\\<forall>i < (length subsets). row (alt_matrix_A_R signs subsets) i  = vec (length signs) (\\<lambda>j. z_R (subsets ! i) (signs ! j))\"", "lemma signs_are_cols_R: \"\\<forall>i < (length signs). col (alt_matrix_A_R signs subsets) i  = vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! i))\"", "lemma construct_lhs_vector_clean_R:\n  assumes \"p \\<noteq> 0\"\n  assumes \"i < length signs\"\n  shows \"(construct_lhs_vector_R p qs signs) $ i =\n    card {x. poly p x = 0 \\<and> ((consistent_sign_vec qs x) = (nth signs i))}\"", "lemma construct_lhs_vector_cleaner_R:\n  assumes \"p \\<noteq> 0\"\n  shows \"(construct_lhs_vector_R p qs signs) =\n   vec_of_list (map (\\<lambda>s. rat_of_int (card {x. poly p x = 0 \\<and> ((consistent_sign_vec qs x) = s)})) signs)\"", "lemma z_signs_R2:\n  fixes I:: \"nat list\"\n  fixes signs:: \"rat list\"\n  assumes lf: \"list_all (\\<lambda>i. i < length signs) I\"\n  assumes la:  \"list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = -1) signs\"\n  shows \"(prod_list (map (nth signs) I)) = 1 \\<or>\n  (prod_list (map (nth signs) I)) = 0 \\<or>\n  (prod_list (map (nth signs) I)) = -1\"", "lemma z_signs_R1:\n  fixes I:: \"nat list\"\n  fixes signs:: \"rat list\"\n  assumes lf: \"list_all (\\<lambda>i. i < length signs) I\"\n  assumes la:  \"list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = -1) signs\"\n  shows \"(prod_list (map (nth (map_sgas signs)) I)) = 1 \\<or>\n(prod_list (map (nth (map_sgas signs)) I)) = 0\"", "lemma z_signs_R:\n  fixes I:: \"(nat list * nat list)\"\n  fixes signs:: \"rat list\"\n  assumes lf: \"list_all (\\<lambda>i. i < length signs) (fst(I))\"\n  assumes ls: \"list_all (\\<lambda>i. i < length signs) (snd(I))\"\n  assumes la:  \"list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = -1) signs\"\n  shows \"(z_R I signs = 1) \\<or> (z_R I signs = 0) \\<or> (z_R I signs = -1)\"", "lemma z_lemma_R:\n  fixes I:: \"nat list * nat list\" \n  fixes sign:: \"rat list\"\n  assumes consistent: \"sign \\<in> set (characterize_consistent_signs_at_roots p qs)\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows \"(z_R I sign = 1) \\<or> (z_R I sign = 0) \\<or> (z_R I sign = -1)\"", "lemma in_set_R: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  shows \"sign \\<in> set (characterize_consistent_signs_at_roots p qs)\"", "lemma consistent_signs_prop_R:\n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  shows  \"list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = -1) sign\"", "lemma horiz_vector_helper_pos_ind_R1: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes asm: \"list_constr I (length qs)\"\n  shows \"(prod_list (map (nth (map_sgas sign)) I)) = 1 \\<longleftrightarrow> \n    (\\<forall>p \\<in> set (retrieve_polys qs I). poly p x = 0)\"", "lemma csv_length_same_as_qlist: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  shows \"length sign = length qs\"", "lemma horiz_vector_helper_zer_ind_R2: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes asm: \"list_constr I (length qs)\"\n  shows \"(prod_list (map (nth sign) I)) = 0 \\<longleftrightarrow> \n    (poly (prod_list (retrieve_polys qs I)) x = 0)\"", "lemma horiz_vector_helper_pos_ind_R2: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes asm: \"list_constr I (length qs)\"\n  shows \"(prod_list (map (nth sign) I)) = 1 \\<longleftrightarrow> \n    (poly (prod_list (retrieve_polys qs I)) x > 0)\"", "lemma horiz_vector_helper_pos_ind_R: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list * nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes asm1: \"list_constr (fst I) (length qs)\"\n  assumes asm2: \"list_constr (snd I) (length qs)\"\n  shows \"((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x > 0)) \\<longleftrightarrow> (z_R I sign = 1)\"", "lemma horiz_vector_helper_pos_R: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows \"((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x > 0)) \\<longleftrightarrow> (z_R I sign = 1)\"", "lemma horiz_vector_helper_neg_R: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows \"((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x < 0)) \\<longleftrightarrow> (z_R I sign = -1)\"", "lemma lhs_dot_rewrite:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  shows\n    \"(vec_of_list (mtx_row_R signs I) \\<bullet> (construct_lhs_vector_R p qs signs)) =\n   sum_list (map (\\<lambda>s. (z_R I s)  *  rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) signs)\"", "lemma construct_lhs_vector_drop_consistent_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows\n    \"(vec_of_list (mtx_row_R signs I) \\<bullet> (construct_lhs_vector_R p qs signs)) =\n     (vec_of_list (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n      (construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs)))\"", "lemma matrix_equation_helper_step_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows \"(vec_of_list (mtx_row_R signs I) \\<bullet> (construct_lhs_vector_R p qs signs)) =\n   rat_of_int (card {x. poly p x = 0 \\<and> (\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> poly (prod_list (retrieve_polys qs (snd I))) x > 0}) -\n   rat_of_int (card {x. poly p x = 0 \\<and> (\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> poly (prod_list (retrieve_polys qs (snd I))) x < 0})\"", "lemma matrix_equation_main_step_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows \"(vec_of_list (mtx_row_R signs I) \\<bullet>\n          (construct_lhs_vector_R p qs signs)) =  \n    construct_NofI_R p (retrieve_polys qs (fst I)) (retrieve_polys qs (snd I))\"", "lemma mtx_row_length_R:\n  \"list_all (\\<lambda>r. length r = length signs) (map (mtx_row_R signs) ls)\"", "theorem matrix_equation_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes subsets:: \"(nat list*nat list) list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes welldefined: \"all_list_constr_R (subsets) (length qs)\"\n  shows \"satisfy_equation_R p qs subsets signs\"", "lemma consistent_signs_at_roots_eq:\n  assumes \"p \\<noteq> 0\"\n  shows \"consistent_signs_at_roots p qs =\n         set (characterize_consistent_signs_at_roots p qs)\"", "theorem matrix_equation_pretty:\n  fixes subsets:: \"(nat list*nat list) list\"\n  assumes \"p\\<noteq>0\"\n  assumes \"distinct signs\"\n  assumes \"consistent_signs_at_roots p qs \\<subseteq> set signs\"\n  assumes \"\\<And>a b i. (a, b) \\<in> set ( subsets) \\<Longrightarrow> (i \\<in> set a \\<or> i \\<in> set b) \\<Longrightarrow> i < length qs\"\n  shows \"M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs = v_vec_R p qs subsets\"", "lemma mat_base_case_R:\n  shows \"matrix_A_R [[1],[0],[-1]] [([], []),([0], []),([], [0])] = (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]])\"", "lemma base_case_sgas_R:\n  fixes q p:: \"real poly\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"set (characterize_consistent_signs_at_roots p [q]) \\<subseteq> {[1],[0], [- 1]}\"", "lemma base_case_sgas_alt_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  assumes len1: \"length qs = 1\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> {[1], [0], [- 1]}\"", "lemma base_case_satisfy_equation_R:\n  fixes q p:: \"real poly\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"satisfy_equation_R p [q] [([], []),([0], []),([], [0])] [[1],[0],[-1]] \"", "lemma base_case_satisfy_equation_alt_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  assumes len1: \"length qs = 1\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"satisfy_equation_R p qs [([], []),([0], []),([], [0])] [[1],[0],[-1]]\"", "lemma base_case_matrix_eq:\n  fixes q p:: \"real poly\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"(mult_mat_vec (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]]) (construct_lhs_vector_R p [q] [[1],[0],[-1]]) = \n    (construct_rhs_vector_R p [q] [([], []),([0], []),([], [0])]))\"", "lemma less_three: \"(n::nat) < Suc (Suc (Suc 0)) \\<longleftrightarrow> n = 0 \\<or> n = 1 \\<or> n = 2\"", "lemma inverse_mat_base_case_R:\n  shows \"inverts_mat (mat_of_rows_list 3  [[1/2, -1/2, 1/2], [0, 1, 0], [1/2, -1/2, -1/2]]::rat mat) (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]]::rat mat)\"", "lemma inverse_mat_base_case_2_R: \n  shows \"inverts_mat (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]]::rat mat) (mat_of_rows_list 3  [[1/2, -1/2, 1/2], [0, 1, 0], [1/2, -1/2, -1/2]]:: rat mat)\"", "lemma base_case_invertible_mat_R: \n  shows \"invertible_mat (matrix_A_R [[1],[0], [- 1]] [([], []),([0], []),([], [0])])\"", "lemma smash_list_list_property_set:\n  fixes l1 l2 :: \"('a list*'a list) list\"\n  fixes a b:: \"nat\"\n  shows \"\\<forall> (elem :: ('a list*'a list)). (elem \\<in> (set (smash_list_list l1 l2)) \\<longrightarrow> \n    (\\<exists> (elem1:: ('a list*'a list)). \\<exists> (elem2:: ('a list*'a list)). \n      (elem1 \\<in> set(l1) \\<and> elem2 \\<in> set(l2) \\<and> elem = (fst elem1@ fst elem2, snd elem1 @ snd elem2))))\"", "lemma subsets_smash_property_R:\n  fixes subsets1 subsets2 :: \"(nat list*nat list) list\"\n  fixes n:: \"nat\"\n  shows \"\\<forall> (elem :: nat list*nat list). (List.member (subsets_smash_R n subsets1 subsets2) elem) \\<longrightarrow> \n    (\\<exists> (elem1::nat list*nat list). \\<exists> (elem2::nat list*nat list).\n      (elem1 \\<in> set(subsets1) \\<and> elem2 \\<in> set(subsets2) \\<and> elem = ((fst elem1) @ (map ((+) n) (fst elem2)), (snd elem1) @ (map ((+) n) (snd elem2)))))\"", "lemma well_def_step_R: \n  fixes qs1 qs2 :: \"real poly list\"\n  fixes subsets1 subsets2 :: \"(nat list*nat list) list\"\n  assumes well_def_subsets1: \"all_list_constr_R (subsets1) (length qs1)\"\n  assumes well_def_subsets2: \"all_list_constr_R (subsets2) (length qs2)\"\n  shows \"all_list_constr_R ((subsets_smash_R (length qs1) subsets1 subsets2))\n     (length (qs1 @ qs2))\"", "lemma subset_helper_R:\n  fixes p:: \"real poly\"\n  fixes qs1 qs2 :: \"real poly list\"\n  fixes signs1 signs2 :: \"rat list list\"\n  shows \"\\<forall> x \\<in> set (characterize_consistent_signs_at_roots p (qs1 @ qs2)). \n        \\<exists> x1 \\<in> set (characterize_consistent_signs_at_roots p qs1). \n        \\<exists> x2 \\<in> set (characterize_consistent_signs_at_roots p qs2).\n        x = x1@x2\"", "lemma subset_step_R:  \n  fixes p:: \"real poly\"\n  fixes qs1 qs2 :: \"real poly list\"\n  fixes signs1 signs2 :: \"rat list list\"\n  assumes csa1: \"set (characterize_consistent_signs_at_roots p qs1) \\<subseteq> set (signs1)\"\n  assumes csa2: \"set (characterize_consistent_signs_at_roots p qs2) \\<subseteq> set (signs2)\"  \n  shows \"set (characterize_consistent_signs_at_roots p\n          (qs1 @ qs2))\n    \\<subseteq> set (signs_smash signs1 signs2)\"", "lemma dim_row_matrix_A_R[simp]:\n  shows \"dim_row (matrix_A_R signs subsets) = length subsets\"", "lemma dim_col_matrix_A_R[simp]:\n  shows \"dim_col (matrix_A_R signs subsets) = length signs\"", "lemma length_subsets_smash_R:\n  shows\n    \"length (subsets_smash_R n subs1 subs2) = length subs1 * length subs2\"", "lemma z_append_R:\n  fixes xs:: \"(nat list * nat list)\"\n  assumes \"\\<And>i. i \\<in> set (fst xs) \\<Longrightarrow> i  < length as\"\n  assumes \"\\<And>i. i \\<in> set (snd xs) \\<Longrightarrow> i  < length as\"\n  shows \"z_R ((fst xs) @ (map ((+) (length as)) (fst ys)), (snd xs) @ (map ((+) (length as)) (snd ys))) (as @ bs) = z_R xs as * z_R ys bs\"", "lemma matrix_construction_is_kronecker_product_R: \n  fixes qs1 :: \"real poly list\"\n  fixes subs1 subs2 :: \"(nat list*nat list) list\"\n  fixes signs1 signs2 :: \"rat list list\"\n    (* n1 is the number of polynomials in the \"1\" sets *)\n  assumes \"\\<And>l i. l \\<in> set subs1 \\<Longrightarrow> (i \\<in> set (fst l) \\<or> i \\<in> set (snd l)) \\<Longrightarrow> i < n1\"\n  assumes \"\\<And>j. j \\<in> set signs1 \\<Longrightarrow> length j = n1\"\n  shows \"(matrix_A_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2)) =\n    kronecker_product (matrix_A_R signs1 subs1) (matrix_A_R signs2 subs2)\"", "lemma inductive_step_R:\n  fixes p:: \"real poly\"\n  fixes qs1 qs2 :: \"real poly list\"\n  fixes subsets1 subsets2 :: \"(nat list*nat list) list\"\n  fixes signs1 signs2 :: \"rat list list\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes nontriv1: \"length qs1 > 0\"\n  assumes nontriv2: \"length qs2 > 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs1) signs1\"\n  assumes welldefined_signs2: \"well_def_signs (length qs2) signs2\"\n  assumes distinct_signs1: \"distinct signs1\"\n  assumes distinct_signs2: \"distinct signs2\"\n  assumes all_info1: \"set (characterize_consistent_signs_at_roots p qs1) \\<subseteq> set(signs1)\"\n  assumes all_info2: \"set (characterize_consistent_signs_at_roots p qs2) \\<subseteq> set(signs2)\"\n  assumes welldefined_subsets1: \"all_list_constr_R (subsets1) (length qs1)\"\n  assumes welldefined_subsets2: \"all_list_constr_R (subsets2) (length qs2)\"\n  assumes invertibleMtx1: \"invertible_mat (matrix_A_R signs1 subsets1)\"\n  assumes invertibleMtx2: \"invertible_mat (matrix_A_R signs2 subsets2)\"\n  shows \"satisfy_equation_R p (qs1@qs2) (subsets_smash_R (length qs1) subsets1 subsets2) (signs_smash signs1 signs2) \n        \\<and> invertible_mat (matrix_A_R (signs_smash signs1 signs2) (subsets_smash_R (length qs1) subsets1 subsets2))\"", "lemma reduction_signs_is_get_signs_R: \"reduction_signs_R p qs signs subsets m =  get_signs_R (reduce_system_R p (qs, (m, (subsets, signs))))\"", "lemma reduction_subsets_is_get_subsets_R: \"reduction_subsets_R p qs signs subsets m =  get_subsets_R (reduce_system_R p (qs, (m, (subsets, signs))))\"", "lemma take_indices_lem_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes arb_list :: \"('a list*'a list) list\"\n  fixes index_list :: \"nat list\" \n  fixes n:: \"nat\"\n  assumes lest: \"n < length (take_indices arb_list index_list)\"\n  assumes well_def: \"\\<forall>q.(List.member index_list q \\<longrightarrow> q < length arb_list)\"\n  shows \"\\<exists>k<length arb_list.\n            (take_indices arb_list index_list) ! n =  arb_list ! k\"", "lemma size_of_mat_R:\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  shows \"(matrix_A_R signs subsets) \\<in> carrier_mat (length subsets) (length signs)\"", "lemma size_of_lhs_R: \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes signs :: \"rat list list\" \n  shows \"dim_vec (construct_lhs_vector_R p qs signs) = length signs\"", "lemma size_of_rhs_R: \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\" \n  shows \"dim_vec (construct_rhs_vector_R p qs subsets) = length subsets\"", "lemma same_size_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"length subsets = length signs\"", "lemma construct_lhs_matches_solve_for_lhs_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"(construct_lhs_vector_R p qs signs) = solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)\"", "lemma reduction_doesnt_break_things_signs_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(reduction_signs_R p qs signs subsets (matrix_A_R signs subsets))\"", "lemma reduction_deletes_bad_sign_conds_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"set (characterize_consistent_signs_at_roots p qs) = set(reduction_signs_R p qs signs subsets (matrix_A_R signs subsets))\"", "theorem reduce_system_sign_conditions_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"set (get_signs_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs))))) = set (characterize_consistent_signs_at_roots p qs)\"", "lemma reduce_system_matrix_equation_preserved_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs: \"well_def_signs (length qs) signs\"\n  assumes welldefined_subsets: \"all_list_constr_R (subsets) (length qs)\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"satisfy_equation_R p qs (get_subsets_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\n  (get_signs_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\"", "lemma reduce_system_matrix_signs_helper_aux_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  fixes S:: \"nat list\"\n  assumes well_def_h: \"\\<forall>x. List.member S x \\<longrightarrow> x < length signs\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"alt_matrix_A_R (take_indices signs S) subsets = take_cols_from_matrix (alt_matrix_A_R signs subsets) S\"", "lemma reduce_system_matrix_signs_helper_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  fixes S:: \"nat list\"\n  assumes well_def_h: \"\\<forall>x. List.member S x \\<longrightarrow> x < length signs\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"matrix_A_R (take_indices signs S) subsets = take_cols_from_matrix (matrix_A_R signs subsets) S\"", "lemma reduce_system_matrix_subsets_helper_aux_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list* nat list) list\"\n  fixes signs :: \"rat list list\" \n  fixes S:: \"nat list\"\n  assumes inv: \"length subsets \\<ge> length signs\"\n  assumes well_def_h: \"\\<forall>x. List.member S x \\<longrightarrow> x < length subsets\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"alt_matrix_A_R signs (take_indices subsets S) = take_rows_from_matrix (alt_matrix_A_R signs subsets) S\"", "lemma reduce_system_matrix_subsets_helper_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  fixes S:: \"nat list\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes inv: \"length subsets \\<ge> length signs\"\n  assumes well_def_h: \"\\<forall>x. List.member S x \\<longrightarrow> x < length subsets\"\n  shows \"matrix_A_R signs (take_indices subsets S) = take_rows_from_matrix (matrix_A_R signs subsets) S\"", "lemma reduce_system_matrix_match_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes inv: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"matrix_A_R (get_signs_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\n  (get_subsets_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs))))) = \n  (get_matrix_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\"", "lemma well_def_find_zeros_from_lhs_vec_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes len_eq: \"length subsets = length signs\"\n  assumes inv: \"invertible_mat (matrix_A_R signs subsets)\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  shows \"(\\<And>j. j \\<in> set (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) \\<Longrightarrow>\n          j < length (cols (matrix_A_R signs subsets)))\"", "lemma take_cols_subsets_og_cols_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes len_eq: \"length subsets = length signs\"\n  assumes inv: \"invertible_mat (matrix_A_R signs subsets)\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  shows \"set (take_indices (cols (matrix_A_R signs subsets))\n          (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))\n    \\<subseteq> set (cols (matrix_A_R signs subsets))\"", "lemma reduction_doesnt_break_things_invertibility_step1_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes len_eq: \"length subsets = length signs\"\n  assumes inv: \"invertible_mat (matrix_A_R signs subsets)\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  shows \"vec_space.rank (length signs) (reduce_mat_cols (matrix_A_R signs subsets) (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) =\n    (length (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))\"", "lemma reduction_doesnt_break_things_invertibility_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes len_eq: \"length subsets = length signs\"\n  assumes inv: \"invertible_mat (matrix_A_R signs subsets)\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  shows \"invertible_mat (get_matrix_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\"", "lemma reduction_doesnt_break_length_signs_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes length_init : \"\\<forall> x\\<in> set(signs). length x = length qs\"\n  assumes sat_eq: \"satisfy_equation_R p qs subsets signs\"\n  assumes inv_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"\\<forall>x \\<in> set(reduction_signs_R p qs signs subsets (matrix_A_R signs subsets)). \n    length x = length qs\"", "lemma reduction_signs_are_distinct_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes sat_eq: \"satisfy_equation_R p qs subsets signs\"\n  assumes inv_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  assumes distinct_init: \"distinct signs\"\n  shows \"distinct (reduction_signs_R p qs signs subsets (matrix_A_R signs subsets))\"", "lemma reduction_doesnt_break_subsets_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list* nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes length_init : \"all_list_constr_R subsets (length qs)\"\n  assumes sat_eq: \"satisfy_equation_R p qs subsets signs\"\n  assumes inv_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"all_list_constr_R (reduction_subsets_R p qs signs subsets (matrix_A_R signs subsets)) (length qs)\"", "lemma combining_to_smash_R:  \"combine_systems_R p (qs1, m1, (sub1, sgn1)) (qs2, m2, (sub2, sgn2))\n =  smash_systems_R p qs1 qs2 sub1 sub2 sgn1 sgn2 m1 m2\"", "lemma getter_functions_R: \"calculate_data_R p qs = (get_matrix_R (calculate_data_R p qs), (get_subsets_R (calculate_data_R p qs), get_signs_R (calculate_data_R p qs))) \"", "lemma combining_sys_satisfies_properties_helper_R:\n  fixes p:: \"real poly\"\n  fixes qs1 :: \"real poly list\"\n  fixes qs2 :: \"real poly list\"\n  fixes subsets1 subsets2 :: \"(nat list * nat list) list\"\n  fixes signs1 signs2 :: \"rat list list\" \n  fixes matrix1 matrix2:: \"rat mat\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes nontriv1: \"length qs1 > 0\"\n  assumes nontriv2: \"length qs2 > 0\"\n  assumes satisfies_properties_sys1: \"satisfies_properties_R p qs1 subsets1 signs1 matrix1\"\n  assumes satisfies_properties_sys2: \"satisfies_properties_R p qs2 subsets2 signs2 matrix2\"\n  shows  \"satisfies_properties_R p (qs1@qs2) (get_subsets_R (snd ((combine_systems_R p (qs1,(matrix1, (subsets1, signs1))) (qs2,(matrix2, (subsets2, signs2))))))) \n  (get_signs_R (snd ((combine_systems_R p (qs1,(matrix1, (subsets1, signs1))) (qs2,(matrix2, (subsets2, signs2))))))) \n  (get_matrix_R (snd ((combine_systems_R p (qs1,(matrix1, (subsets1, signs1))) (qs2,(matrix2, (subsets2, signs2)))))))\"", "lemma combining_sys_satisfies_properties_R:\n  fixes p:: \"real poly\"\n  fixes qs1 :: \"real poly list\"\n  fixes qs2 :: \"real poly list\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes nontriv1: \"length qs1 > 0\"\n  assumes nontriv2: \"length qs2 > 0\"\n  assumes satisfies_properties_sys1: \"satisfies_properties_R p qs1 (get_subsets_R (calculate_data_R p qs1)) (get_signs_R (calculate_data_R p qs1)) (get_matrix_R (calculate_data_R p qs1))\"\n  assumes satisfies_properties_sys2: \"satisfies_properties_R p qs2 (get_subsets_R (calculate_data_R p qs2)) (get_signs_R (calculate_data_R p qs2)) (get_matrix_R (calculate_data_R p qs2))\"\n  shows  \"satisfies_properties_R p (qs1@qs2) (get_subsets_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2))))) \n  (get_signs_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2))))) \n  (get_matrix_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2)))))\"", "lemma reducing_sys_satisfies_properties_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  fixes matrix:: \"rat mat\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes nontriv: \"length qs > 0\"\n  assumes satisfies_properties_sys: \"satisfies_properties_R p qs subsets signs matrix\"\n  shows  \"satisfies_properties_R p qs (get_subsets_R (reduce_system_R p (qs,matrix,subsets,signs)))\n  (get_signs_R (reduce_system_R p (qs,matrix,subsets,signs)))\n  (get_matrix_R (reduce_system_R p (qs,matrix,subsets,signs)))\"", "lemma  length_1_calculate_data_satisfies_properties_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes len1: \"length qs = 1\"\n  shows \"satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs)) (get_signs_R (calculate_data_R p qs)) (get_matrix_R (calculate_data_R p qs))\"", "lemma  calculate_data_satisfies_properties_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  shows \"(p \\<noteq> 0 \\<and> (length qs > 0))\n    \\<longrightarrow> satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs)) (get_signs_R (calculate_data_R p qs)) (get_matrix_R (calculate_data_R p qs))\"", "lemma find_consistent_signs_at_roots_len1_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes len1: \"length qs = 1\"\n  shows \"set (find_consistent_signs_at_roots_R p qs) = set (characterize_consistent_signs_at_roots p qs)\"", "lemma smaller_sys_are_good_R:\n  fixes p:: \"real poly\"\n  fixes qs1 :: \"real poly list\"\n  fixes qs2 :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes nontriv1: \"length qs1 > 0\"\n  assumes nontriv2: \"length qs2 > 0\"\n  assumes \"set(find_consistent_signs_at_roots_R p qs1) = set(characterize_consistent_signs_at_roots p qs1)\"\n  assumes \"set(find_consistent_signs_at_roots_R p qs2) = set(characterize_consistent_signs_at_roots p qs2)\"\n  shows \"set(snd(snd(reduce_system_R p (combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2)))))\n    = set(characterize_consistent_signs_at_roots p (qs1@qs2))\"", "lemma find_consistent_signs_at_roots_1_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  shows \"(p \\<noteq> 0 \\<and> length qs > 0) \\<longrightarrow> \n    set(find_consistent_signs_at_roots_R p qs) = set(characterize_consistent_signs_at_roots p qs)\"", "lemma find_consistent_signs_at_roots_0_R:\n  fixes p:: \"real poly\"\n  assumes \"p \\<noteq> 0\"\n  shows \"set(find_consistent_signs_at_roots_R p []) =\n         set(characterize_consistent_signs_at_roots p [])\"", "lemma find_consistent_signs_at_roots_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  assumes \"p \\<noteq> 0\"\n  shows \"set(find_consistent_signs_at_roots_R p qs) = set(characterize_consistent_signs_at_roots p qs)\""], "translations": [["", "lemma construct_NofI_R_relation:\n  fixes p:: \"real poly\"\n  fixes I1:: \"real poly list\"\n  fixes I2:: \"real poly list\"\n  shows \"construct_NofI_R p I1 I2 =\n    construct_NofI (sum_list (map power2 (p # I1))) I2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_NofI_R p I1 I2 =\n    construct_NofI (sum_list (map power2 (p # I1))) I2", "unfolding construct_NofI_R_def construct_NofI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let new_p = sum_list (map power2 (p # I1))\n     in rat_of_int (changes_R_smods new_p (pderiv new_p * prod_list I2))) =\n    rat_of_int\n     (changes_R_smods (sum_list (map power2 (p # I1)))\n       (pderiv (sum_list (map power2 (p # I1))) * prod_list I2))", "by metis"], ["", "lemma sum_list_map_power2:\n  shows \"sum_list (map power2 ls) \\<ge> (0::real poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sum_list (map power2 ls)", "apply (induct ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> sum_list (map power2 [])\n 2. \\<And>a ls.\n       0 \\<le> sum_list (map power2 ls) \\<Longrightarrow>\n       0 \\<le> sum_list (map power2 (a # ls))", "by auto"], ["", "lemma sum_list_map_power2_poly:\n  shows \"poly (sum_list (map power2 (ls::real poly list))) x \\<ge> (0::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> poly (sum_list (map power2 ls)) x", "apply (induct ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> poly (sum_list (map power2 [])) x\n 2. \\<And>a ls.\n       0 \\<le> poly (sum_list (map power2 ls)) x \\<Longrightarrow>\n       0 \\<le> poly (sum_list (map power2 (a # ls))) x", "by auto"], ["", "lemma construct_NofI_R_prop_helper:\n  fixes p:: \"real poly\"\n  fixes I1:: \"real poly list\"\n  fixes I2:: \"real poly list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  shows \"construct_NofI_R p I1 I2 =\n    rat_of_int (int (card {x. poly (sum_list (map (\\<lambda>x. x^2) (p # I1))) x = 0 \\<and> poly (prod_list I2) x > 0}) - \n    int (card {x. poly (sum_list (map (\\<lambda>x. x^2) (p # I1))) x = 0  \\<and> poly (prod_list I2) x < 0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_NofI_R p I1 I2 =\n    rat_of_int\n     (int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                poly (prod_list I2) x < 0}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. construct_NofI_R p I1 I2 =\n    rat_of_int\n     (int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                poly (prod_list I2) x < 0}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_NofI_R p I1 I2 =\n    rat_of_int\n     (int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                poly (prod_list I2) x < 0}))", "unfolding construct_NofI_R_relation[of p I1 I2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_NofI (sum_list (map power2 (p # I1))) I2 =\n    rat_of_int\n     (int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                poly (prod_list I2) x < 0}))", "apply (subst construct_NofI_prop[of _ I2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. sum_list (map power2 (p # I1)) \\<noteq> 0\n 2. rat_of_int\n     (int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                poly (prod_list I2) x < 0})) =\n    rat_of_int\n     (int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                poly (prod_list I2) x < 0}))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sup>2 + sum_list (map power2 I1) = 0 \\<Longrightarrow> False", "using assms sum_list_map_power2"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 \\<le> sum_list (map power2 ?ls)\n\ngoal (1 subgoal):\n 1. p\\<^sup>2 + sum_list (map power2 I1) = 0 \\<Longrightarrow> False", "by (metis le_add_same_cancel1 power2_less_eq_zero_iff)"], ["proof (state)\nthis:\n  construct_NofI_R p I1 I2 =\n  rat_of_int\n   (int (card\n          {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n              0 < poly (prod_list I2) x}) -\n    int (card\n          {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n              poly (prod_list I2) x < 0}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zer_iff:\n  fixes p:: \"real poly\"\n  fixes ls:: \"real poly list\"\n  shows \"poly (sum_list (map (\\<lambda>x. x^2) ls)) x = 0 \\<longleftrightarrow> (\\<forall>i \\<in> set ls. poly i x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (sum_list (map power2 ls)) x = 0) =\n    (\\<forall>i\\<in>set ls. poly i x = 0)", "proof (induct ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. (poly (sum_list (map power2 [])) x = 0) =\n    (\\<forall>i\\<in>set []. poly i x = 0)\n 2. \\<And>a ls.\n       (poly (sum_list (map power2 ls)) x = 0) =\n       (\\<forall>i\\<in>set ls. poly i x = 0) \\<Longrightarrow>\n       (poly (sum_list (map power2 (a # ls))) x = 0) =\n       (\\<forall>i\\<in>set (a # ls). poly i x = 0)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (poly (sum_list (map power2 [])) x = 0) =\n    (\\<forall>i\\<in>set []. poly i x = 0)\n 2. \\<And>a ls.\n       (poly (sum_list (map power2 ls)) x = 0) =\n       (\\<forall>i\\<in>set ls. poly i x = 0) \\<Longrightarrow>\n       (poly (sum_list (map power2 (a # ls))) x = 0) =\n       (\\<forall>i\\<in>set (a # ls). poly i x = 0)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (sum_list (map power2 [])) x = 0) =\n    (\\<forall>i\\<in>set []. poly i x = 0)", "by auto"], ["proof (state)\nthis:\n  (poly (sum_list (map power2 [])) x = 0) =\n  (\\<forall>i\\<in>set []. poly i x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       (poly (sum_list (map power2 ls)) x = 0) =\n       (\\<forall>i\\<in>set ls. poly i x = 0) \\<Longrightarrow>\n       (poly (sum_list (map power2 (a # ls))) x = 0) =\n       (\\<forall>i\\<in>set (a # ls). poly i x = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       (poly (sum_list (map power2 ls)) x = 0) =\n       (\\<forall>i\\<in>set ls. poly i x = 0) \\<Longrightarrow>\n       (poly (sum_list (map power2 (a # ls))) x = 0) =\n       (\\<forall>i\\<in>set (a # ls). poly i x = 0)", "case (Cons a I1)"], ["proof (state)\nthis:\n  (poly (sum_list (map power2 I1)) x = 0) =\n  (\\<forall>i\\<in>set I1. poly i x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       (poly (sum_list (map power2 ls)) x = 0) =\n       (\\<forall>i\\<in>set ls. poly i x = 0) \\<Longrightarrow>\n       (poly (sum_list (map power2 (a # ls))) x = 0) =\n       (\\<forall>i\\<in>set (a # ls). poly i x = 0)", "then"], ["proof (chain)\npicking this:\n  (poly (sum_list (map power2 I1)) x = 0) =\n  (\\<forall>i\\<in>set I1. poly i x = 0)", "show ?case"], ["proof (prove)\nusing this:\n  (poly (sum_list (map power2 I1)) x = 0) =\n  (\\<forall>i\\<in>set I1. poly i x = 0)\n\ngoal (1 subgoal):\n 1. (poly (sum_list (map power2 (a # I1))) x = 0) =\n    (\\<forall>i\\<in>set (a # I1). poly i x = 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    ((poly a x)\\<^sup>2 + poly (sum_list (map power2 I1)) x = 0) =\n    (poly a x = 0 \\<and> (\\<forall>i\\<in>set I1. poly i x = 0))", "apply (subst add_nonneg_eq_0_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    0 \\<le> (poly a x)\\<^sup>2\n 2. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    0 \\<le> poly (sum_list (map power2 I1)) x\n 3. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    ((poly a x)\\<^sup>2 = 0 \\<and> poly (sum_list (map power2 I1)) x = 0) =\n    (poly a x = 0 \\<and> (\\<forall>i\\<in>set I1. poly i x = 0))", "using zero_le_power2"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?a\\<^sup>2\n\ngoal (3 subgoals):\n 1. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    0 \\<le> (poly a x)\\<^sup>2\n 2. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    0 \\<le> poly (sum_list (map power2 I1)) x\n 3. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    ((poly a x)\\<^sup>2 = 0 \\<and> poly (sum_list (map power2 I1)) x = 0) =\n    (poly a x = 0 \\<and> (\\<forall>i\\<in>set I1. poly i x = 0))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    0 \\<le> poly (sum_list (map power2 I1)) x\n 2. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    ((poly a x)\\<^sup>2 = 0 \\<and> poly (sum_list (map power2 I1)) x = 0) =\n    (poly a x = 0 \\<and> (\\<forall>i\\<in>set I1. poly i x = 0))", "using sum_list_map_power2_poly"], ["proof (prove)\nusing this:\n  0 \\<le> poly (sum_list (map power2 ?ls)) ?x\n\ngoal (2 subgoals):\n 1. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    0 \\<le> poly (sum_list (map power2 I1)) x\n 2. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    ((poly a x)\\<^sup>2 = 0 \\<and> poly (sum_list (map power2 I1)) x = 0) =\n    (poly a x = 0 \\<and> (\\<forall>i\\<in>set I1. poly i x = 0))", "apply presburger"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (sum_list (map power2 I1)) x = 0) =\n    (\\<forall>i\\<in>set I1. poly i x = 0) \\<Longrightarrow>\n    ((poly a x)\\<^sup>2 = 0 \\<and> poly (sum_list (map power2 I1)) x = 0) =\n    (poly a x = 0 \\<and> (\\<forall>i\\<in>set I1. poly i x = 0))", "by simp"], ["proof (state)\nthis:\n  (poly (sum_list (map power2 (a # I1))) x = 0) =\n  (\\<forall>i\\<in>set (a # I1). poly i x = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma construct_NofI_prop_R:\n  fixes p:: \"real poly\"\n  fixes I1:: \"real poly list\"\n  fixes I2:: \"real poly list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  shows \"construct_NofI_R p I1 I2 =\n    rat_of_int (int (card {x. poly p x = 0 \\<and> (\\<forall>q \\<in> set I1. poly q x = 0) \\<and> poly (prod_list I2) x > 0}) - \n    int (card {x. poly p x = 0  \\<and> (\\<forall>q \\<in> set I1. poly q x = 0) \\<and> poly (prod_list I2) x < 0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_NofI_R p I1 I2 =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>q\\<in>set I1. poly q x = 0) \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>q\\<in>set I1. poly q x = 0) \\<and>\n                poly (prod_list I2) x < 0}))", "unfolding construct_NofI_R_prop_helper[OF nonzero]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int\n     (int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                poly (prod_list I2) x < 0})) =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>q\\<in>set I1. poly q x = 0) \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>q\\<in>set I1. poly q x = 0) \\<and>\n                poly (prod_list I2) x < 0}))", "using zer_iff"], ["proof (prove)\nusing this:\n  (poly (sum_list (map power2 ?ls)) ?x = 0) =\n  (\\<forall>i\\<in>set ?ls. poly i ?x = 0)\n\ngoal (1 subgoal):\n 1. rat_of_int\n     (int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly (sum_list (map power2 (p # I1))) x = 0 \\<and>\n                poly (prod_list I2) x < 0})) =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>q\\<in>set I1. poly q x = 0) \\<and>\n                0 < poly (prod_list I2) x}) -\n      int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>q\\<in>set I1. poly q x = 0) \\<and>\n                poly (prod_list I2) x < 0}))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ls x.\n        (poly (sum_list (map power2 ls)) x = 0) =\n        (\\<forall>i\\<in>set ls. poly i x = 0)) \\<Longrightarrow>\n    rat_of_nat\n     (card\n       {x. (poly p x)\\<^sup>2 + poly (sum_list (map power2 I1)) x = 0 \\<and>\n           0 < poly (prod_list I2) x}) -\n    rat_of_nat\n     (card\n       {x. (poly p x)\\<^sup>2 + poly (sum_list (map power2 I1)) x = 0 \\<and>\n           poly (prod_list I2) x < 0}) =\n    rat_of_nat\n     (card\n       {x. poly p x = 0 \\<and>\n           (\\<forall>q\\<in>set I1. poly q x = 0) \\<and>\n           0 < poly (prod_list I2) x}) -\n    rat_of_nat\n     (card\n       {x. poly p x = 0 \\<and>\n           (\\<forall>q\\<in>set I1. poly q x = 0) \\<and>\n           poly (prod_list I2) x < 0})", "by (smt (verit, del_insts) Collect_cong sum_list_map_power2_poly zero_le_power2 zero_less_power2)"], ["", "section \"Matrix Equation\""], ["", "definition map_sgas:: \"rat list \\<Rightarrow> rat list\"\n  where \"map_sgas l = map (\\<lambda>r. (1 - r^2)) l\""], ["", "definition z_R:: \"(nat list*nat list) \\<Rightarrow> rat list \\<Rightarrow> rat\"\n  where \"z_R index_list sign_asg \\<equiv> (prod_list (map (nth (map_sgas sign_asg)) (fst(index_list))))*(prod_list (map (nth sign_asg) (snd(index_list))))\""], ["", "definition mtx_row_R:: \"rat list list \\<Rightarrow> (nat list * nat list) \\<Rightarrow> rat list\"\n  where \"mtx_row_R sign_list index_list \\<equiv> (map ((z_R index_list)) sign_list)\""], ["", "definition matrix_A_R:: \"rat list list \\<Rightarrow>  (nat list * nat list) list \\<Rightarrow> rat mat\" \n  where \"matrix_A_R sign_list subset_list = \n    (mat_of_rows_list (length sign_list) (map (\\<lambda>i .(mtx_row_R sign_list i)) subset_list))\""], ["", "definition all_list_constr_R:: \"(nat list*nat list) list \\<Rightarrow> nat \\<Rightarrow> bool\"\n  where \"all_list_constr_R L n \\<equiv> (\\<forall>x. List.member L x \\<longrightarrow> (list_constr (fst x) n \\<and> list_constr (snd x) n))\""], ["", "definition alt_matrix_A_R:: \"rat list list \\<Rightarrow> (nat list*nat list) list \\<Rightarrow> rat mat\"\n  where \"alt_matrix_A_R signs subsets = (mat (length subsets) (length signs) \n    (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)))\""], ["", "lemma alt_matrix_char_R: \"alt_matrix_A_R signs subsets = matrix_A_R signs subsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_matrix_A_R signs subsets = matrix_A_R signs subsets", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alt_matrix_A_R signs subsets = matrix_A_R signs subsets", "have h0: \"(\\<And>i j. i < length subsets \\<Longrightarrow>\n            j < length signs \\<Longrightarrow>\n            map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i ! j = z_R (subsets ! i) (signs ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list.\n                                 map (z_R index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z_R (subsets ! i) (signs ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list.\n                                 map (z_R index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z_R (subsets ! i) (signs ! j)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list.\n                                 map (z_R index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z_R (subsets ! i) (signs ! j)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list.\n                                 map (z_R index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z_R (subsets ! i) (signs ! j)", "assume i_lt: \"i < length subsets\""], ["proof (state)\nthis:\n  i < length subsets\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list.\n                                 map (z_R index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z_R (subsets ! i) (signs ! j)", "assume j_lt: \"j < length signs\""], ["proof (state)\nthis:\n  j < length signs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list.\n                                 map (z_R index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z_R (subsets ! i) (signs ! j)", "show \"((map (\\<lambda>index_list. map (z_R index_list) signs) subsets) ! i) ! j = z_R (subsets ! i) (signs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i ! j =\n    z_R (subsets ! i) (signs ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i ! j =\n    z_R (subsets ! i) (signs ! j)", "have h0: \"(map (\\<lambda>index_list. map (z_R index_list) signs) subsets) ! i =  map (z_R (subsets ! i)) signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i =\n    map (z_R (subsets ! i)) signs", "using nth_map i_lt"], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n  i < length subsets\n\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i =\n    map (z_R (subsets ! i)) signs", "by blast"], ["proof (state)\nthis:\n  map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i =\n  map (z_R (subsets ! i)) signs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i ! j =\n    z_R (subsets ! i) (signs ! j)", "then"], ["proof (chain)\npicking this:\n  map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i =\n  map (z_R (subsets ! i)) signs", "show ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i =\n  map (z_R (subsets ! i)) signs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i ! j =\n    z_R (subsets ! i) (signs ! j)", "using nth_map j_lt"], ["proof (prove)\nusing this:\n  map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i =\n  map (z_R (subsets ! i)) signs\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n  j < length signs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i ! j =\n    z_R (subsets ! i) (signs ! j)", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i ! j =\n  z_R (subsets ! i) (signs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i ! j =\n  z_R (subsets ! i) (signs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length subsets; ?j < length signs\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>index_list. map (z_R index_list) signs)\n                     subsets !\n                    ?i !\n                    ?j =\n                    z_R (subsets ! ?i) (signs ! ?j)\n\ngoal (1 subgoal):\n 1. alt_matrix_A_R signs subsets = matrix_A_R signs subsets", "have h: \" mat (length subsets) (length signs) (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs) (\\<lambda>(i, y). map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i ! y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs)\n     (\\<lambda>(i, y).\n         map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i !\n         y)", "using h0 eq_matI[where A = \"mat (length subsets) (length signs) (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))\",\n        where B = \"mat (length subsets) (length signs) (\\<lambda>(i, y). map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i ! y)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length subsets; ?j < length signs\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>index_list. map (z_R index_list) signs)\n                     subsets !\n                    ?i !\n                    ?j =\n                    z_R (subsets ! ?i) (signs ! ?j)\n  \\<lbrakk>\\<And>i j.\n              \\<lbrakk>i < dim_row\n                            (mat (length subsets) (length signs)\n                              (\\<lambda>(i, y).\n                                  map (\\<lambda>index_list.\n    map (z_R index_list) signs)\n                                   subsets !\n                                  i !\n                                  y));\n               j < dim_col\n                    (mat (length subsets) (length signs)\n                      (\\<lambda>(i, y).\n                          map (\\<lambda>index_list.\n                                  map (z_R index_list) signs)\n                           subsets !\n                          i !\n                          y))\\<rbrakk>\n              \\<Longrightarrow> mat (length subsets) (length signs)\n                                 (\\<lambda>(i, j).\n                                     z_R (subsets ! i) (signs ! j)) $$\n                                (i, j) =\n                                mat (length subsets) (length signs)\n                                 (\\<lambda>(i, y).\n                                     map\n(\\<lambda>index_list. map (z_R index_list) signs) subsets !\n                                     i !\n                                     y) $$\n                                (i, j);\n   dim_row\n    (mat (length subsets) (length signs)\n      (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))) =\n   dim_row\n    (mat (length subsets) (length signs)\n      (\\<lambda>(i, y).\n          map (\\<lambda>index_list. map (z_R index_list) signs) subsets !\n          i !\n          y));\n   dim_col\n    (mat (length subsets) (length signs)\n      (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))) =\n   dim_col\n    (mat (length subsets) (length signs)\n      (\\<lambda>(i, y).\n          map (\\<lambda>index_list. map (z_R index_list) signs) subsets !\n          i !\n          y))\\<rbrakk>\n  \\<Longrightarrow> mat (length subsets) (length signs)\n                     (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) =\n                    mat (length subsets) (length signs)\n                     (\\<lambda>(i, y).\n                         map (\\<lambda>index_list.\n                                 map (z_R index_list) signs)\n                          subsets !\n                         i !\n                         y)\n\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs)\n     (\\<lambda>(i, y).\n         map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i !\n         y)", "by auto"], ["proof (state)\nthis:\n  mat (length subsets) (length signs)\n   (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) =\n  mat (length subsets) (length signs)\n   (\\<lambda>(i, y).\n       map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i !\n       y)\n\ngoal (1 subgoal):\n 1. alt_matrix_A_R signs subsets = matrix_A_R signs subsets", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_matrix_A_R signs subsets = matrix_A_R signs subsets", "unfolding alt_matrix_A_R_def matrix_A_R_def mat_of_rows_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) =\n    mat (length (map (mtx_row_R signs) subsets)) (length signs)\n     (\\<lambda>(i, y). map (mtx_row_R signs) subsets ! i ! y)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs)\n     (\\<lambda>(i, y). map (mtx_row_R signs) subsets ! i ! y)", "unfolding mtx_row_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs)\n     (\\<lambda>(i, y).\n         map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i !\n         y)", "using h"], ["proof (prove)\nusing this:\n  mat (length subsets) (length signs)\n   (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) =\n  mat (length subsets) (length signs)\n   (\\<lambda>(i, y).\n       map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i !\n       y)\n\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs)\n     (\\<lambda>(i, y).\n         map (\\<lambda>index_list. map (z_R index_list) signs) subsets ! i !\n         y)", "by blast"], ["proof (state)\nthis:\n  alt_matrix_A_R signs subsets = matrix_A_R signs subsets\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subsets_are_rows_R: \"\\<forall>i < (length subsets). row (alt_matrix_A_R signs subsets) i  = vec (length signs) (\\<lambda>j. z_R (subsets ! i) (signs ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length subsets.\n       row (alt_matrix_A_R signs subsets) i =\n       vec (length signs) (\\<lambda>j. z_R (subsets ! i) (signs ! j))", "unfolding row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length subsets.\n       vec (dim_col (alt_matrix_A_R signs subsets))\n        (\\<lambda>j. alt_matrix_A_R signs subsets $$ (i, j)) =\n       vec (length signs) (\\<lambda>j. z_R (subsets ! i) (signs ! j))", "unfolding alt_matrix_A_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length subsets.\n       vec (dim_col\n             (mat (length subsets) (length signs)\n               (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n        (\\<lambda>j.\n            mat (length subsets) (length signs)\n             (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) $$\n            (i, j)) =\n       vec (length signs) (\\<lambda>j. z_R (subsets ! i) (signs ! j))", "by auto"], ["", "lemma signs_are_cols_R: \"\\<forall>i < (length signs). col (alt_matrix_A_R signs subsets) i  = vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length signs.\n       col (alt_matrix_A_R signs subsets) i =\n       vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! i))", "unfolding col_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length signs.\n       vec (dim_row (alt_matrix_A_R signs subsets))\n        (\\<lambda>ia. alt_matrix_A_R signs subsets $$ (ia, i)) =\n       vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! i))", "unfolding alt_matrix_A_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length signs.\n       vec (dim_row\n             (mat (length subsets) (length signs)\n               (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n        (\\<lambda>ia.\n            mat (length subsets) (length signs)\n             (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)) $$\n            (ia, i)) =\n       vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! i))", "by auto"], ["", "definition consistent_sign_vec::\"real poly list \\<Rightarrow> real \\<Rightarrow> rat list\"\n  where \"consistent_sign_vec qs x \\<equiv>\n    map (\\<lambda> q. if (poly q x > 0) then (1::rat) else (if (poly q x = 0) then (0::rat) else (-1::rat))) qs\""], ["", "definition construct_lhs_vector_R:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> rat list list  \\<Rightarrow> rat vec\"\n  where \"construct_lhs_vector_R p qs signs \\<equiv>                                                           \n vec_of_list (map (\\<lambda>w.  rat_of_int (int (length (filter (\\<lambda>v. v = w) (map (consistent_sign_vec qs) (characterize_root_list_p p)))))) signs)\""], ["", "(* The ith entry of LHS vector is the number of (distinct) real zeros of p where the sign vector of \n   the qs is the ith entry of signs.*)\n\n(* Putting all of the pieces of the construction together *)"], ["", "definition satisfy_equation_R:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> (nat list*nat list) list \\<Rightarrow> rat list list \\<Rightarrow> bool\"\n  where \"satisfy_equation_R p qs subset_list sign_list =\n        (mult_mat_vec (matrix_A_R sign_list subset_list) (construct_lhs_vector_R p qs sign_list) = (construct_rhs_vector_R p qs subset_list))\""], ["", "(* Recharacterize the LHS vector *)"], ["", "lemma construct_lhs_vector_clean_R:\n  assumes \"p \\<noteq> 0\"\n  assumes \"i < length signs\"\n  shows \"(construct_lhs_vector_R p qs signs) $ i =\n    card {x. poly p x = 0 \\<and> ((consistent_sign_vec qs x) = (nth signs i))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat (construct_lhs_vector_R p qs signs $ i) =\n    of_nat\n     (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_rat (construct_lhs_vector_R p qs signs $ i) =\n    of_nat\n     (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})", "from poly_roots_finite[OF assms(1)]"], ["proof (chain)\npicking this:\n  finite {x. poly p x = 0}", "have \"finite {x. poly p x = 0}\""], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0}", "."], ["proof (state)\nthis:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. of_rat (construct_lhs_vector_R p qs signs $ i) =\n    of_nat\n     (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})", "then"], ["proof (chain)\npicking this:\n  finite {x. poly p x = 0}", "have eq: \"(Collect\n       ((\\<lambda>v. v = signs ! i) \\<circ>\n        consistent_sign_vec qs) \\<inter>\n      set (sorted_list_of_set\n            {x. poly p x = 0})) =\n    {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i}\""], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. Collect\n     ((\\<lambda>v. v = signs ! i) \\<circ> consistent_sign_vec qs) \\<inter>\n    set (sorted_list_of_set {x. poly p x = 0}) =\n    {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i}", "by auto"], ["proof (state)\nthis:\n  Collect\n   ((\\<lambda>v. v = signs ! i) \\<circ> consistent_sign_vec qs) \\<inter>\n  set (sorted_list_of_set {x. poly p x = 0}) =\n  {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i}\n\ngoal (1 subgoal):\n 1. of_rat (construct_lhs_vector_R p qs signs $ i) =\n    of_nat\n     (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat (construct_lhs_vector_R p qs signs $ i) =\n    of_nat\n     (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})", "unfolding construct_lhs_vector_R_def vec_of_list_index characterize_root_list_p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat\n     (map (\\<lambda>w.\n              rat_of_int\n               (int (length\n                      (filter (\\<lambda>v. v = w)\n                        (map (consistent_sign_vec qs)\n                          (sorted_list_of_set {x. poly p x = 0}))))))\n       signs !\n      i) =\n    of_nat\n     (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat\n     (map (\\<lambda>w.\n              rat_of_nat\n               (length\n                 (filter\n                   ((\\<lambda>v. v = w) \\<circ> consistent_sign_vec qs)\n                   (sorted_list_of_set {x. poly p x = 0}))))\n       signs !\n      i) =\n    of_nat\n     (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})", "apply (subst nth_map[OF assms(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat\n     (rat_of_nat\n       (length\n         (filter\n           ((\\<lambda>v. v = signs ! i) \\<circ> consistent_sign_vec qs)\n           (sorted_list_of_set {x. poly p x = 0})))) =\n    of_nat\n     (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter ((\\<lambda>v. v = signs ! i) \\<circ> consistent_sign_vec qs)\n       (sorted_list_of_set {x. poly p x = 0})) =\n    card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i}", "apply (subst distinct_length_filter)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (sorted_list_of_set {x. poly p x = 0})\n 2. card\n     (Collect\n       ((\\<lambda>v. v = signs ! i) \\<circ> consistent_sign_vec qs) \\<inter>\n      set (sorted_list_of_set {x. poly p x = 0})) =\n    card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i}", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (Collect\n       ((\\<lambda>v. v = signs ! i) \\<circ> consistent_sign_vec qs) \\<inter>\n      set (sorted_list_of_set {x. poly p x = 0})) =\n    card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i}", "using eq"], ["proof (prove)\nusing this:\n  Collect\n   ((\\<lambda>v. v = signs ! i) \\<circ> consistent_sign_vec qs) \\<inter>\n  set (sorted_list_of_set {x. poly p x = 0}) =\n  {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i}\n\ngoal (1 subgoal):\n 1. card\n     (Collect\n       ((\\<lambda>v. v = signs ! i) \\<circ> consistent_sign_vec qs) \\<inter>\n      set (sorted_list_of_set {x. poly p x = 0})) =\n    card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i}", "by auto"], ["proof (state)\nthis:\n  of_rat (construct_lhs_vector_R p qs signs $ i) =\n  of_nat\n   (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma construct_lhs_vector_cleaner_R:\n  assumes \"p \\<noteq> 0\"\n  shows \"(construct_lhs_vector_R p qs signs) =\n   vec_of_list (map (\\<lambda>s. rat_of_int (card {x. poly p x = 0 \\<and> ((consistent_sign_vec qs x) = s)})) signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec qs x = s})))\n       signs)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_list\n              (map (\\<lambda>s.\n                       rat_of_int\n                        (int (card\n                               {x. poly p x = 0 \\<and>\n                                   consistent_sign_vec qs x = s})))\n                signs)) \\<Longrightarrow>\n       construct_lhs_vector_R p qs signs $ i =\n       vec_of_list\n        (map (\\<lambda>s.\n                 rat_of_int\n                  (int (card\n                         {x. poly p x = 0 \\<and>\n                             consistent_sign_vec qs x = s})))\n          signs) $\n       i\n 2. dim_vec (construct_lhs_vector_R p qs signs) =\n    dim_vec\n     (vec_of_list\n       (map (\\<lambda>s.\n                rat_of_int\n                 (int (card\n                        {x. poly p x = 0 \\<and>\n                            consistent_sign_vec qs x = s})))\n         signs))", "apply (auto simp add:  construct_lhs_vector_clean_R[OF assms] )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length signs \\<Longrightarrow>\n       construct_lhs_vector_R p qs signs $ i =\n       rat_of_nat\n        (card\n          {x. poly p x = 0 \\<and>\n              consistent_sign_vec qs x = vec_of_list signs $ i})\n 2. dim_vec (construct_lhs_vector_R p qs signs) = length signs", "apply (simp add: vec_of_list_index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length signs \\<Longrightarrow>\n       construct_lhs_vector_R p qs signs $ i =\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})\n 2. dim_vec (construct_lhs_vector_R p qs signs) = length signs", "unfolding construct_lhs_vector_R_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length signs \\<Longrightarrow>\n       vec_of_list\n        (map (\\<lambda>w.\n                 rat_of_int\n                  (int (length\n                         (filter (\\<lambda>v. v = w)\n                           (map (consistent_sign_vec qs)\n                             (characterize_root_list_p p))))))\n          signs) $\n       i =\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})\n 2. dim_vec\n     (vec_of_list\n       (map (\\<lambda>w.\n                rat_of_int\n                 (int (length\n                        (filter (\\<lambda>v. v = w)\n                          (map (consistent_sign_vec qs)\n                            (characterize_root_list_p p))))))\n         signs)) =\n    length signs", "using assms construct_lhs_vector_clean_R construct_lhs_vector_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<lbrakk>?p \\<noteq> 0; ?i < length ?signs\\<rbrakk>\n  \\<Longrightarrow> of_rat (construct_lhs_vector_R ?p ?qs ?signs $ ?i) =\n                    of_nat\n                     (card\n                       {x. poly ?p x = 0 \\<and>\n                           consistent_sign_vec ?qs x = ?signs ! ?i})\n  w_vec ?p ?qs ?signs \\<equiv>\n  vec_of_list\n   (map (\\<lambda>w.\n            rat_of_int\n             (int (length\n                    (filter (\\<lambda>v. v = w)\n                      (map (consistent_sign_vec_copr ?qs)\n                        (characterize_root_list_p ?p))))))\n     ?signs)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length signs \\<Longrightarrow>\n       vec_of_list\n        (map (\\<lambda>w.\n                 rat_of_int\n                  (int (length\n                         (filter (\\<lambda>v. v = w)\n                           (map (consistent_sign_vec qs)\n                             (characterize_root_list_p p))))))\n          signs) $\n       i =\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! i})\n 2. dim_vec\n     (vec_of_list\n       (map (\\<lambda>w.\n                rat_of_int\n                 (int (length\n                        (filter (\\<lambda>v. v = w)\n                          (map (consistent_sign_vec qs)\n                            (characterize_root_list_p p))))))\n         signs)) =\n    length signs", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length signs; p \\<noteq> 0;\n        \\<And>p i signs qs.\n           \\<lbrakk>p \\<noteq> 0; i < length signs\\<rbrakk>\n           \\<Longrightarrow> of_rat\n                              (construct_lhs_vector_R p qs signs $ i) =\n                             of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec qs x = signs ! i});\n        \\<And>p qs signs.\n           w_vec p qs signs \\<equiv>\n           map_vec\n            (\\<lambda>w.\n                rat_of_nat\n                 (length\n                   (filter\n                     ((\\<lambda>v. v = w) \\<circ>\n                      consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p))))\n            (vec_of_list signs)\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            ((\\<lambda>v. v = vec_of_list signs $ i) \\<circ>\n                             consistent_sign_vec qs)\n                            (characterize_root_list_p p)) =\n                         card\n                          {x. poly p x = 0 \\<and>\n                              consistent_sign_vec qs x = signs ! i}\n 2. dim_vec\n     (vec_of_list\n       (map (\\<lambda>w.\n                rat_of_int\n                 (int (length\n                        (filter (\\<lambda>v. v = w)\n                          (map (consistent_sign_vec qs)\n                            (characterize_root_list_p p))))))\n         signs)) =\n    length signs", "apply (simp add: construct_lhs_vector_R_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (map (\\<lambda>w.\n                rat_of_int\n                 (int (length\n                        (filter (\\<lambda>v. v = w)\n                          (map (consistent_sign_vec qs)\n                            (characterize_root_list_p p))))))\n         signs)) =\n    length signs", "by auto"], ["", "(* Show that because our consistent sign vectors consist of 1, 0's, and -1's, z returns 1, 0, or -1 \n  when applied to a consistent sign vector *)"], ["", "lemma z_signs_R2:\n  fixes I:: \"nat list\"\n  fixes signs:: \"rat list\"\n  assumes lf: \"list_all (\\<lambda>i. i < length signs) I\"\n  assumes la:  \"list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = -1) signs\"\n  shows \"(prod_list (map (nth signs) I)) = 1 \\<or>\n  (prod_list (map (nth signs) I)) = 0 \\<or>\n  (prod_list (map (nth signs) I)) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) signs) I) = 1 \\<or>\n    prod_list (map ((!) signs) I) = 0 \\<or>\n    prod_list (map ((!) signs) I) = - 1", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) I\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) signs) I) = 1 \\<or>\n    prod_list (map ((!) signs) I) = 0 \\<or>\n    prod_list (map ((!) signs) I) = - 1", "proof (induct I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>i. i < length signs) [];\n     list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\\<rbrakk>\n    \\<Longrightarrow> prod_list (map ((!) signs) []) = 1 \\<or>\n                      prod_list (map ((!) signs) []) = 0 \\<or>\n                      prod_list (map ((!) signs) []) = - 1\n 2. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                                  prod_list (map ((!) signs) I) = 0 \\<or>\n                                  prod_list (map ((!) signs) I) = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = - 1", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>i. i < length signs) []\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>i. i < length signs) [];\n     list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\\<rbrakk>\n    \\<Longrightarrow> prod_list (map ((!) signs) []) = 1 \\<or>\n                      prod_list (map ((!) signs) []) = 0 \\<or>\n                      prod_list (map ((!) signs) []) = - 1\n 2. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                                  prod_list (map ((!) signs) I) = 0 \\<or>\n                                  prod_list (map ((!) signs) I) = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = - 1", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>i. i < length signs) []\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs", "show ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) []\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) signs) []) = 1 \\<or>\n    prod_list (map ((!) signs) []) = 0 \\<or>\n    prod_list (map ((!) signs) []) = - 1", "by auto"], ["proof (state)\nthis:\n  prod_list (map ((!) signs) []) = 1 \\<or>\n  prod_list (map ((!) signs) []) = 0 \\<or>\n  prod_list (map ((!) signs) []) = - 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                                  prod_list (map ((!) signs) I) = 0 \\<or>\n                                  prod_list (map ((!) signs) I) = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = - 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                                  prod_list (map ((!) signs) I) = 0 \\<or>\n                                  prod_list (map ((!) signs) I) = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = - 1", "case (Cons a I)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                    prod_list (map ((!) signs) I) = 0 \\<or>\n                    prod_list (map ((!) signs) I) = - 1\n  list_all (\\<lambda>i. i < length signs) (a # I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                                  prod_list (map ((!) signs) I) = 0 \\<or>\n                                  prod_list (map ((!) signs) I) = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = - 1", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                    prod_list (map ((!) signs) I) = 0 \\<or>\n                    prod_list (map ((!) signs) I) = - 1\n  list_all (\\<lambda>i. i < length signs) (a # I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                                  prod_list (map ((!) signs) I) = 0 \\<or>\n                                  prod_list (map ((!) signs) I) = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = - 1", "have eo: \"signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) I\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1", "by (smt (verit, del_insts) calculation(2) list_all_length list_all_simps(1))"], ["proof (state)\nthis:\n  signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                                  prod_list (map ((!) signs) I) = 0 \\<or>\n                                  prod_list (map ((!) signs) I) = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = - 1", "have \"prod_list (map ((!) (map_sgas signs)) (a # I)) = (1 - (signs ! a)^2)*prod_list (map ((!) (map_sgas signs)) (I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas signs)) (a # I)) =\n    (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)", "unfolding map_sgas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map (\\<lambda>r. 1 - r\\<^sup>2) signs)) (a # I)) =\n    (1 - (signs ! a)\\<^sup>2) *\n    prod_list (map ((!) (map (\\<lambda>r. 1 - r\\<^sup>2) signs)) I)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>r. 1 - r\\<^sup>2) signs ! a \\<noteq>\n    1 - (signs ! a)\\<^sup>2 \\<Longrightarrow>\n    0 \\<in> (!) (map (\\<lambda>r. 1 - r\\<^sup>2) signs) ` set I", "using calculation(2)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) (a # I)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>r. 1 - r\\<^sup>2) signs ! a \\<noteq>\n    1 - (signs ! a)\\<^sup>2 \\<Longrightarrow>\n    0 \\<in> (!) (map (\\<lambda>r. 1 - r\\<^sup>2) signs) ` set I", "by auto"], ["proof (state)\nthis:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) =\n  (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                                  prod_list (map ((!) signs) I) = 0 \\<or>\n                                  prod_list (map ((!) signs) I) = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n                         prod_list (map ((!) signs) (a # I)) = - 1", "then"], ["proof (chain)\npicking this:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) =\n  (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)", "show ?case"], ["proof (prove)\nusing this:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) =\n  (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n    prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n    prod_list (map ((!) signs) (a # I)) = - 1", "using eo"], ["proof (prove)\nusing this:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) =\n  (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)\n  signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n    prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n    prod_list (map ((!) signs) (a # I)) = - 1", "using Cons.hyps calculation(2) la"], ["proof (prove)\nusing this:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) =\n  (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)\n  signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1\n  \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                    prod_list (map ((!) signs) I) = 0 \\<or>\n                    prod_list (map ((!) signs) I) = - 1\n  list_all (\\<lambda>i. i < length signs) (a # I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n    prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n    prod_list (map ((!) signs) (a # I)) = - 1", "by auto"], ["proof (state)\nthis:\n  prod_list (map ((!) signs) (a # I)) = 1 \\<or>\n  prod_list (map ((!) signs) (a # I)) = 0 \\<or>\n  prod_list (map ((!) signs) (a # I)) = - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma z_signs_R1:\n  fixes I:: \"nat list\"\n  fixes signs:: \"rat list\"\n  assumes lf: \"list_all (\\<lambda>i. i < length signs) I\"\n  assumes la:  \"list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = -1) signs\"\n  shows \"(prod_list (map (nth (map_sgas signs)) I)) = 1 \\<or>\n(prod_list (map (nth (map_sgas signs)) I)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas signs)) I) = 1 \\<or>\n    prod_list (map ((!) (map_sgas signs)) I) = 0", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) I\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas signs)) I) = 1 \\<or>\n    prod_list (map ((!) (map_sgas signs)) I) = 0", "proof (induct I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>i. i < length signs) [];\n     list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\\<rbrakk>\n    \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) []) = 1 \\<or>\n                      prod_list (map ((!) (map_sgas signs)) []) = 0\n 2. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) =\n                                  1 \\<or>\n                                  prod_list (map ((!) (map_sgas signs)) I) =\n                                  0;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) (a # I)) =\n                         1 \\<or>\n                         prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>i. i < length signs) []\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>i. i < length signs) [];\n     list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\\<rbrakk>\n    \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) []) = 1 \\<or>\n                      prod_list (map ((!) (map_sgas signs)) []) = 0\n 2. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) =\n                                  1 \\<or>\n                                  prod_list (map ((!) (map_sgas signs)) I) =\n                                  0;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) (a # I)) =\n                         1 \\<or>\n                         prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>i. i < length signs) []\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs", "show ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) []\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas signs)) []) = 1 \\<or>\n    prod_list (map ((!) (map_sgas signs)) []) = 0", "by auto"], ["proof (state)\nthis:\n  prod_list (map ((!) (map_sgas signs)) []) = 1 \\<or>\n  prod_list (map ((!) (map_sgas signs)) []) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) =\n                                  1 \\<or>\n                                  prod_list (map ((!) (map_sgas signs)) I) =\n                                  0;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) (a # I)) =\n                         1 \\<or>\n                         prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) =\n                                  1 \\<or>\n                                  prod_list (map ((!) (map_sgas signs)) I) =\n                                  0;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) (a # I)) =\n                         1 \\<or>\n                         prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "case (Cons a I)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) = 1 \\<or>\n                    prod_list (map ((!) (map_sgas signs)) I) = 0\n  list_all (\\<lambda>i. i < length signs) (a # I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) =\n                                  1 \\<or>\n                                  prod_list (map ((!) (map_sgas signs)) I) =\n                                  0;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) (a # I)) =\n                         1 \\<or>\n                         prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) = 1 \\<or>\n                    prod_list (map ((!) (map_sgas signs)) I) = 0\n  list_all (\\<lambda>i. i < length signs) (a # I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) =\n                                  1 \\<or>\n                                  prod_list (map ((!) (map_sgas signs)) I) =\n                                  0;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) (a # I)) =\n                         1 \\<or>\n                         prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "have \"signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) I\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1", "by (smt (verit, best) calculation(2) list_all_length list_all_simps(1))"], ["proof (state)\nthis:\n  signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) =\n                                  1 \\<or>\n                                  prod_list (map ((!) (map_sgas signs)) I) =\n                                  0;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) (a # I)) =\n                         1 \\<or>\n                         prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "then"], ["proof (chain)\npicking this:\n  signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1", "have eo: \"1 - (signs ! a)^2 = 1 \\<or> 1 - (signs !a)^2 = 0\""], ["proof (prove)\nusing this:\n  signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1\n\ngoal (1 subgoal):\n 1. 1 - (signs ! a)\\<^sup>2 = 1 \\<or> 1 - (signs ! a)\\<^sup>2 = 0", "using cancel_comm_monoid_add_class.diff_cancel diff_zero"], ["proof (prove)\nusing this:\n  signs ! a = 1 \\<or> signs ! a = 0 \\<or> signs ! a = - 1\n  ?a - ?a = (0::?'a)\n  ?a - (0::?'a) = ?a\n\ngoal (1 subgoal):\n 1. 1 - (signs ! a)\\<^sup>2 = 1 \\<or> 1 - (signs ! a)\\<^sup>2 = 0", "by fastforce"], ["proof (state)\nthis:\n  1 - (signs ! a)\\<^sup>2 = 1 \\<or> 1 - (signs ! a)\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) =\n                                  1 \\<or>\n                                  prod_list (map ((!) (map_sgas signs)) I) =\n                                  0;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) (a # I)) =\n                         1 \\<or>\n                         prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "have \"prod_list (map ((!) (map_sgas signs)) (a # I)) = (1 - (signs ! a)^2)*prod_list (map ((!) (map_sgas signs)) (I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas signs)) (a # I)) =\n    (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)", "unfolding map_sgas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map (\\<lambda>r. 1 - r\\<^sup>2) signs)) (a # I)) =\n    (1 - (signs ! a)\\<^sup>2) *\n    prod_list (map ((!) (map (\\<lambda>r. 1 - r\\<^sup>2) signs)) I)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>r. 1 - r\\<^sup>2) signs ! a \\<noteq>\n    1 - (signs ! a)\\<^sup>2 \\<Longrightarrow>\n    0 \\<in> (!) (map (\\<lambda>r. 1 - r\\<^sup>2) signs) ` set I", "using calculation(2)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) (a # I)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>r. 1 - r\\<^sup>2) signs ! a \\<noteq>\n    1 - (signs ! a)\\<^sup>2 \\<Longrightarrow>\n    0 \\<in> (!) (map (\\<lambda>r. 1 - r\\<^sup>2) signs) ` set I", "by auto"], ["proof (state)\nthis:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) =\n  (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                  signs\\<rbrakk>\n                \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) =\n                                  1 \\<or>\n                                  prod_list (map ((!) (map_sgas signs)) I) =\n                                  0;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n         signs\\<rbrakk>\n       \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) (a # I)) =\n                         1 \\<or>\n                         prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "then"], ["proof (chain)\npicking this:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) =\n  (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)", "show ?case"], ["proof (prove)\nusing this:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) =\n  (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas signs)) (a # I)) = 1 \\<or>\n    prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "using eo"], ["proof (prove)\nusing this:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) =\n  (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)\n  1 - (signs ! a)\\<^sup>2 = 1 \\<or> 1 - (signs ! a)\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas signs)) (a # I)) = 1 \\<or>\n    prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "using Cons.hyps calculation(2) la"], ["proof (prove)\nusing this:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) =\n  (1 - (signs ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas signs)) I)\n  1 - (signs ! a)\\<^sup>2 = 1 \\<or> 1 - (signs ! a)\\<^sup>2 = 0\n  \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) = 1 \\<or>\n                    prod_list (map ((!) (map_sgas signs)) I) = 0\n  list_all (\\<lambda>i. i < length signs) (a # I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas signs)) (a # I)) = 1 \\<or>\n    prod_list (map ((!) (map_sgas signs)) (a # I)) = 0", "by auto"], ["proof (state)\nthis:\n  prod_list (map ((!) (map_sgas signs)) (a # I)) = 1 \\<or>\n  prod_list (map ((!) (map_sgas signs)) (a # I)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma z_signs_R:\n  fixes I:: \"(nat list * nat list)\"\n  fixes signs:: \"rat list\"\n  assumes lf: \"list_all (\\<lambda>i. i < length signs) (fst(I))\"\n  assumes ls: \"list_all (\\<lambda>i. i < length signs) (snd(I))\"\n  assumes la:  \"list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = -1) signs\"\n  shows \"(z_R I signs = 1) \\<or> (z_R I signs = 0) \\<or> (z_R I signs = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R I signs = 1 \\<or> z_R I signs = 0 \\<or> z_R I signs = - 1", "using assms z_signs_R2 z_signs_R1"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) (fst I)\n  list_all (\\<lambda>i. i < length signs) (snd I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n  \\<lbrakk>list_all (\\<lambda>i. i < length ?signs) ?I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) ?signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) ?signs) ?I) = 1 \\<or>\n                    prod_list (map ((!) ?signs) ?I) = 0 \\<or>\n                    prod_list (map ((!) ?signs) ?I) = - 1\n  \\<lbrakk>list_all (\\<lambda>i. i < length ?signs) ?I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) ?signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) (map_sgas ?signs)) ?I) = 1 \\<or>\n                    prod_list (map ((!) (map_sgas ?signs)) ?I) = 0\n\ngoal (1 subgoal):\n 1. z_R I signs = 1 \\<or> z_R I signs = 0 \\<or> z_R I signs = - 1", "unfolding z_R_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) (fst I)\n  list_all (\\<lambda>i. i < length signs) (snd I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs\n  \\<lbrakk>list_all (\\<lambda>i. i < length ?signs) ?I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) ?signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) ?signs) ?I) = 1 \\<or>\n                    prod_list (map ((!) ?signs) ?I) = 0 \\<or>\n                    prod_list (map ((!) ?signs) ?I) = - 1\n  \\<lbrakk>list_all (\\<lambda>i. i < length ?signs) ?I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) ?signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) (map_sgas ?signs)) ?I) = 1 \\<or>\n                    prod_list (map ((!) (map_sgas ?signs)) ?I) = 0\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas signs)) (fst I)) *\n    prod_list (map ((!) signs) (snd I)) =\n    1 \\<or>\n    prod_list (map ((!) (map_sgas signs)) (fst I)) *\n    prod_list (map ((!) signs) (snd I)) =\n    0 \\<or>\n    prod_list (map ((!) (map_sgas signs)) (fst I)) *\n    prod_list (map ((!) signs) (snd I)) =\n    - 1", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all (\\<lambda>i. i < length signs) (fst I);\n     list_all (\\<lambda>i. i < length signs) (snd I);\n     list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) signs;\n     \\<And>signs I.\n        \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n         list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n          signs\\<rbrakk>\n        \\<Longrightarrow> prod_list (map ((!) signs) I) = 1 \\<or>\n                          0 \\<in> (!) signs ` set I \\<or>\n                          prod_list (map ((!) signs) I) = - 1;\n     \\<And>signs I.\n        \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n         list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n          signs\\<rbrakk>\n        \\<Longrightarrow> prod_list (map ((!) (map_sgas signs)) I) = 1 \\<or>\n                          0 \\<in> (!) (map_sgas signs) ` set I;\n     prod_list (map ((!) (map_sgas signs)) (fst I)) *\n     prod_list (map ((!) signs) (snd I)) \\<noteq>\n     1;\n     0 \\<notin> (!) (map_sgas signs) ` set (fst I);\n     prod_list (map ((!) (map_sgas signs)) (fst I)) *\n     prod_list (map ((!) signs) (snd I)) \\<noteq>\n     - 1\\<rbrakk>\n    \\<Longrightarrow> 0 \\<in> (!) signs ` set (snd I)", "by (metis (no_types, lifting) mult_cancel_left1 mult_minus1_right)"], ["", "lemma z_lemma_R:\n  fixes I:: \"nat list * nat list\" \n  fixes sign:: \"rat list\"\n  assumes consistent: \"sign \\<in> set (characterize_consistent_signs_at_roots p qs)\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows \"(z_R I sign = 1) \\<or> (z_R I sign = 0) \\<or> (z_R I sign = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<or> z_R I sign = 0 \\<or> z_R I sign = - 1", "proof (rule z_signs_R)"], ["proof (state)\ngoal (3 subgoals):\n 1. list_all (\\<lambda>i. i < length sign) (fst I)\n 2. list_all (\\<lambda>i. i < length sign) (snd I)\n 3. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "have same: \"length sign = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length sign = length qs", "using consistent"], ["proof (prove)\nusing this:\n  sign \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. length sign = length qs", "using characterize_consistent_signs_at_roots_def signs_at_def"], ["proof (prove)\nusing this:\n  sign \\<in> set (characterize_consistent_signs_at_roots p qs)\n  characterize_consistent_signs_at_roots ?p ?qs =\n  remdups (map (signs_at ?qs) (characterize_root_list_p ?p))\n  signs_at ?qs ?x \\<equiv> map (squash \\<circ> (\\<lambda>q. poly q ?x)) ?qs\n\ngoal (1 subgoal):\n 1. length sign = length qs", "by fastforce"], ["proof (state)\nthis:\n  length sign = length qs\n\ngoal (3 subgoals):\n 1. list_all (\\<lambda>i. i < length sign) (fst I)\n 2. list_all (\\<lambda>i. i < length sign) (snd I)\n 3. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "thus \"(list_all (\\<lambda>i. i < length sign) (fst I))\""], ["proof (prove)\nusing this:\n  length sign = length qs\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>i. i < length sign) (fst I)", "using welldefined1"], ["proof (prove)\nusing this:\n  length sign = length qs\n  list_constr (fst I) (length qs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>i. i < length sign) (fst I)", "by (auto simp add: list_constr_def characterize_consistent_signs_at_roots_def consistent_sign_vec_copr_def)"], ["proof (state)\nthis:\n  list_all (\\<lambda>i. i < length sign) (fst I)\n\ngoal (2 subgoals):\n 1. list_all (\\<lambda>i. i < length sign) (snd I)\n 2. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "thus \"(list_all (\\<lambda>i. i < length sign) (snd I))\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length sign) (fst I)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>i. i < length sign) (snd I)", "using same welldefined2"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length sign) (fst I)\n  length sign = length qs\n  list_constr (snd I) (length qs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>i. i < length sign) (snd I)", "by (auto simp add: list_constr_def characterize_consistent_signs_at_roots_def consistent_sign_vec_copr_def)"], ["proof (state)\nthis:\n  list_all (\\<lambda>i. i < length sign) (snd I)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "show \"list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "using consistent"], ["proof (prove)\nusing this:\n  sign \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "apply (auto simp add: list.pred_map  characterize_consistent_signs_at_roots_def  consistent_sign_vec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (characterize_root_list_p p);\n        sign = signs_at qs x\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                          (signs_at qs x)", "using Ball_set"], ["proof (prove)\nusing this:\n  Ball (set ?xs) ?P = list_all ?P ?xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (characterize_root_list_p p);\n        sign = signs_at qs x\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                          (signs_at qs x)", "by (simp add: list_all_length signs_at_def squash_def)"], ["proof (state)\nthis:\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Show that all consistent sign vectors on roots of polynomials are in characterize_consistent_signs_at_roots  *)"], ["", "lemma in_set_R: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  shows \"sign \\<in> set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign \\<in> set (characterize_consistent_signs_at_roots p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign \\<in> set (characterize_consistent_signs_at_roots p qs)", "have h1: \"consistent_sign_vec qs x \\<in>\n      set (remdups (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_sign_vec qs x\n    \\<in> set (remdups\n                (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))", "unfolding consistent_sign_vec_def signs_at_def squash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>q.\n            if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n     qs\n    \\<in> set (remdups\n                (map (\\<lambda>x.\n                         map ((\\<lambda>x.\n                                  if 0 < x then 1\n                                  else if x < 0 then - 1 else 0) \\<circ>\n                              (\\<lambda>q. poly q x))\n                          qs)\n                  (sorted_list_of_set {x. poly p x = 0})))", "using root_p nonzero poly_roots_finite set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  x \\<in> {x. poly p x = 0}\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n\ngoal (1 subgoal):\n 1. map (\\<lambda>q.\n            if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n     qs\n    \\<in> set (remdups\n                (map (\\<lambda>x.\n                         map ((\\<lambda>x.\n                                  if 0 < x then 1\n                                  else if x < 0 then - 1 else 0) \\<circ>\n                              (\\<lambda>q. poly q x))\n                          qs)\n                  (sorted_list_of_set {x. poly p x = 0})))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly p x = 0; p \\<noteq> 0;\n     \\<And>p.\n        p \\<noteq> 0 \\<Longrightarrow> finite {x. poly p x = (0::?'a3)};\n     \\<And>A.\n        finite A \\<Longrightarrow> set (sorted_list_of_set A) = A\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>q.\n                              if 0 < poly q x then 1\n                              else if poly q x = 0 then 0 else - 1)\n                       qs\n                      \\<in> (\\<lambda>x.\n                                map ((\\<lambda>x.\n   if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n                                     (\\<lambda>q. poly q x))\n                                 qs) `\n                            set (sorted_list_of_set {x. poly p x = 0})", "by (smt (verit, ccfv_SIG) Collect_cong comp_def image_eqI map_eq_conv mem_Collect_eq poly_roots_finite set_sorted_list_of_set)"], ["proof (state)\nthis:\n  consistent_sign_vec qs x\n  \\<in> set (remdups\n              (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))\n\ngoal (1 subgoal):\n 1. sign \\<in> set (characterize_consistent_signs_at_roots p qs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  consistent_sign_vec qs x\n  \\<in> set (remdups\n              (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))\n\ngoal (1 subgoal):\n 1. sign \\<in> set (characterize_consistent_signs_at_roots p qs)", "unfolding characterize_consistent_signs_at_roots_def characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  consistent_sign_vec qs x\n  \\<in> set (remdups\n              (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))\n\ngoal (1 subgoal):\n 1. sign\n    \\<in> set (remdups\n                (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))", "using sign_fix"], ["proof (prove)\nusing this:\n  consistent_sign_vec qs x\n  \\<in> set (remdups\n              (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))\n  sign = consistent_sign_vec qs x\n\ngoal (1 subgoal):\n 1. sign\n    \\<in> set (remdups\n                (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))", "by blast"], ["proof (state)\nthis:\n  sign \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consistent_signs_prop_R:\n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  shows  \"list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = -1) sign\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "unfolding consistent_sign_vec_def squash_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign =\n  map (\\<lambda>q.\n          if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n   qs\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = 0;\n     sign =\n     map (\\<lambda>q.\n             if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n      qs\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                       (map (\\<lambda>q.\n                                if 0 < poly q x then 1\n                                else if poly q x = 0 then 0 else - 1)\n                         qs)", "by (smt (z3) length_map list_all_length nth_map)"], ["", "(* The next few lemmas relate z_R to the signs of the product of subsets of polynomials of qs *)"], ["", "lemma horiz_vector_helper_pos_ind_R1: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes asm: \"list_constr I (length qs)\"\n  shows \"(prod_list (map (nth (map_sgas sign)) I)) = 1 \\<longleftrightarrow> \n    (\\<forall>p \\<in> set (retrieve_polys qs I). poly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n    (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0)", "using asm"], ["proof (prove)\nusing this:\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n    (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0)", "proof (induction \"I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. list_constr [] (length qs) \\<Longrightarrow>\n    (prod_list (map ((!) (map_sgas sign)) []) = 1) =\n    (\\<forall>p\\<in>set (retrieve_polys qs []). poly p x = 0)\n 2. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "case Nil"], ["proof (state)\nthis:\n  list_constr [] (length qs)\n\ngoal (2 subgoals):\n 1. list_constr [] (length qs) \\<Longrightarrow>\n    (prod_list (map ((!) (map_sgas sign)) []) = 1) =\n    (\\<forall>p\\<in>set (retrieve_polys qs []). poly p x = 0)\n 2. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "then"], ["proof (chain)\npicking this:\n  list_constr [] (length qs)", "show ?case"], ["proof (prove)\nusing this:\n  list_constr [] (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) []) = 1) =\n    (\\<forall>p\\<in>set (retrieve_polys qs []). poly p x = 0)", "unfolding map_sgas_def"], ["proof (prove)\nusing this:\n  list_constr [] (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map (\\<lambda>r. 1 - r\\<^sup>2) sign)) []) = 1) =\n    (\\<forall>p\\<in>set (retrieve_polys qs []). poly p x = 0)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>list_constr [] (length qs);\n        p \\<in> set (retrieve_polys qs [])\\<rbrakk>\n       \\<Longrightarrow> poly p x = 0", "by (simp add: retrieve_polys_def)"], ["proof (state)\nthis:\n  (prod_list (map ((!) (map_sgas sign)) []) = 1) =\n  (\\<forall>p\\<in>set (retrieve_polys qs []). poly p x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "case (Cons a xa)"], ["proof (state)\nthis:\n  list_constr xa (length qs) \\<Longrightarrow>\n  (prod_list (map ((!) (map_sgas sign)) xa) = 1) =\n  (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0)\n  list_constr (a # xa) (length qs)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "then"], ["proof (chain)\npicking this:\n  list_constr xa (length qs) \\<Longrightarrow>\n  (prod_list (map ((!) (map_sgas sign)) xa) = 1) =\n  (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0)\n  list_constr (a # xa) (length qs)", "have same0: \"(prod_list (map (nth (map_sgas sign)) xa)) = 1 \\<longleftrightarrow> \n    (\\<forall>p \\<in> set (retrieve_polys qs xa). poly p x = 0)\""], ["proof (prove)\nusing this:\n  list_constr xa (length qs) \\<Longrightarrow>\n  (prod_list (map ((!) (map_sgas sign)) xa) = 1) =\n  (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0)\n  list_constr (a # xa) (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) xa) = 1) =\n    (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0)", "unfolding list_constr_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x < length qs) xa \\<Longrightarrow>\n  (prod_list (map ((!) (map_sgas sign)) xa) = 1) =\n  (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0)\n  list_all (\\<lambda>x. x < length qs) (a # xa)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) xa) = 1) =\n    (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0)", "by auto"], ["proof (state)\nthis:\n  (prod_list (map ((!) (map_sgas sign)) xa) = 1) =\n  (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "have welldef: \"a < length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < length qs", "using Cons.prems assms"], ["proof (prove)\nusing this:\n  list_constr (a # xa) (length qs)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. a < length qs", "unfolding list_constr_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x < length qs) (a # xa)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_all (\\<lambda>x. x < length qs) I\n\ngoal (1 subgoal):\n 1. a < length qs", "by auto"], ["proof (state)\nthis:\n  a < length qs\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "then"], ["proof (chain)\npicking this:\n  a < length qs", "have h: \"prod_list (map ((!) (map_sgas sign)) (a#xa)) = (1 - (sign ! a)^2)*(prod_list (map ((!) (map_sgas sign)) (xa)))\""], ["proof (prove)\nusing this:\n  a < length qs\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas sign)) (a # xa)) =\n    (1 - (sign ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas sign)) xa)", "unfolding map_sgas_def"], ["proof (prove)\nusing this:\n  a < length qs\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map (\\<lambda>r. 1 - r\\<^sup>2) sign)) (a # xa)) =\n    (1 - (sign ! a)\\<^sup>2) *\n    prod_list (map ((!) (map (\\<lambda>r. 1 - r\\<^sup>2) sign)) xa)", "using assms"], ["proof (prove)\nusing this:\n  a < length qs\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map (\\<lambda>r. 1 - r\\<^sup>2) sign)) (a # xa)) =\n    (1 - (sign ! a)\\<^sup>2) *\n    prod_list (map ((!) (map (\\<lambda>r. 1 - r\\<^sup>2) sign)) xa)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < length qs; p \\<noteq> 0; poly p x = 0;\n     sign = consistent_sign_vec qs x; list_constr I (length qs);\n     map (\\<lambda>r. 1 - r\\<^sup>2) (consistent_sign_vec qs x) ! a \\<noteq>\n     1 - (consistent_sign_vec qs x ! a)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> 0 \\<in> (!) (map (\\<lambda>r. 1 - r\\<^sup>2)\n                                    (consistent_sign_vec qs x)) `\n                              set xa", "by (metis (no_types, lifting) consistent_sign_vec_def length_map nth_map)"], ["proof (state)\nthis:\n  prod_list (map ((!) (map_sgas sign)) (a # xa)) =\n  (1 - (sign ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas sign)) xa)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "have \"list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = -1) sign\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "using sign_fix"], ["proof (prove)\nusing this:\n  sign = consistent_sign_vec qs x\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "unfolding consistent_sign_vec_def squash_def"], ["proof (prove)\nusing this:\n  sign =\n  map (\\<lambda>q.\n          if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n   qs\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign =\n    map (\\<lambda>q.\n            if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n     qs \\<Longrightarrow>\n    list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n     (map (\\<lambda>q.\n              if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n       qs)", "by (smt (z3) length_map list_all_length nth_map)"], ["proof (state)\nthis:\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign", "have eo: \"(prod_list (map ((!) (map_sgas sign)) (xa))) = 0 \\<or> (prod_list (map ((!) (map_sgas sign)) (xa))) = 1\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas sign)) xa) = 0 \\<or>\n    prod_list (map ((!) (map_sgas sign)) xa) = 1", "using z_signs_R1 assms Cons.prems consistent_sign_vec_def length_map list_all_simps(1) length_map list_all_length list_constr_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign\n  \\<lbrakk>list_all (\\<lambda>i. i < length ?signs) ?I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) ?signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) (map_sgas ?signs)) ?I) = 1 \\<or>\n                    prod_list (map ((!) (map_sgas ?signs)) ?I) = 0\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr I (length qs)\n  list_constr (a # xa) (length qs)\n  consistent_sign_vec ?qs ?x \\<equiv>\n  map (\\<lambda>q.\n          if 0 < poly q ?x then 1 else if poly q ?x = 0 then 0 else - 1)\n   ?qs\n  length (map ?f ?xs) = length ?xs\n  list_all ?P (?x # ?xs) = (?P ?x \\<and> list_all ?P ?xs)\n  length (map ?f ?xs) = length ?xs\n  list_all ?P ?xs = (\\<forall>n<length ?xs. ?P (?xs ! n))\n  list_constr ?L ?n \\<equiv> list_all (\\<lambda>x. x < ?n) ?L\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas sign)) xa) = 0 \\<or>\n    prod_list (map ((!) (map_sgas sign)) xa) = 1", "by (smt (verit, best))"], ["proof (state)\nthis:\n  prod_list (map ((!) (map_sgas sign)) xa) = 0 \\<or>\n  prod_list (map ((!) (map_sgas sign)) xa) = 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "have \"(sign ! a)^2 = 1 \\<or> (sign ! a)^2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sign ! a)\\<^sup>2 = 1 \\<or> (sign ! a)\\<^sup>2 = 0", "using sign_fix welldef"], ["proof (prove)\nusing this:\n  sign = consistent_sign_vec qs x\n  a < length qs\n\ngoal (1 subgoal):\n 1. (sign ! a)\\<^sup>2 = 1 \\<or> (sign ! a)\\<^sup>2 = 0", "unfolding consistent_sign_vec_def"], ["proof (prove)\nusing this:\n  sign =\n  map (\\<lambda>q.\n          if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n   qs\n  a < length qs\n\ngoal (1 subgoal):\n 1. (sign ! a)\\<^sup>2 = 1 \\<or> (sign ! a)\\<^sup>2 = 0", "by auto"], ["proof (state)\nthis:\n  (sign ! a)\\<^sup>2 = 1 \\<or> (sign ! a)\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "then"], ["proof (chain)\npicking this:\n  (sign ! a)\\<^sup>2 = 1 \\<or> (sign ! a)\\<^sup>2 = 0", "have s1: \"(prod_list (map (nth (map_sgas sign)) (a#xa))) = 1 \\<longleftrightarrow> \n    ((sign ! a)^2 = 0 \\<and> (prod_list (map ((!) (map_sgas sign)) (xa))) = 1)\""], ["proof (prove)\nusing this:\n  (sign ! a)\\<^sup>2 = 1 \\<or> (sign ! a)\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n    ((sign ! a)\\<^sup>2 = 0 \\<and>\n     prod_list (map ((!) (map_sgas sign)) xa) = 1)", "using eo h"], ["proof (prove)\nusing this:\n  (sign ! a)\\<^sup>2 = 1 \\<or> (sign ! a)\\<^sup>2 = 0\n  prod_list (map ((!) (map_sgas sign)) xa) = 0 \\<or>\n  prod_list (map ((!) (map_sgas sign)) xa) = 1\n  prod_list (map ((!) (map_sgas sign)) (a # xa)) =\n  (1 - (sign ! a)\\<^sup>2) * prod_list (map ((!) (map_sgas sign)) xa)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n    ((sign ! a)\\<^sup>2 = 0 \\<and>\n     prod_list (map ((!) (map_sgas sign)) xa) = 1)", "by (metis (mono_tags, hide_lams) cancel_comm_monoid_add_class.diff_cancel diff_zero mult.left_neutral mult_zero_left)"], ["proof (state)\nthis:\n  (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n  ((sign ! a)\\<^sup>2 = 0 \\<and>\n   prod_list (map ((!) (map_sgas sign)) xa) = 1)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "have \"(sign ! a)^2 = 0 \\<longleftrightarrow> (poly (qs ! a) x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sign ! a)\\<^sup>2 = 0) = (poly (qs ! a) x = 0)", "using sign_fix"], ["proof (prove)\nusing this:\n  sign = consistent_sign_vec qs x\n\ngoal (1 subgoal):\n 1. ((sign ! a)\\<^sup>2 = 0) = (poly (qs ! a) x = 0)", "unfolding consistent_sign_vec_def welldef"], ["proof (prove)\nusing this:\n  sign =\n  map (\\<lambda>q.\n          if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n   qs\n\ngoal (1 subgoal):\n 1. ((sign ! a)\\<^sup>2 = 0) = (poly (qs ! a) x = 0)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sign =\n             map (\\<lambda>q.\n                     if 0 < poly q x then 1\n                     else if poly q x = 0 then 0 else - 1)\n              qs;\n     map (\\<lambda>q.\n             if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n      qs !\n     a =\n     0\\<rbrakk>\n    \\<Longrightarrow> poly (qs ! a) x = 0\n 2. \\<lbrakk>sign =\n             map (\\<lambda>q.\n                     if 0 < poly q x then 1\n                     else if poly q x = 0 then 0 else - 1)\n              qs;\n     poly (qs ! a) x = 0\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>q.\n                              if 0 < poly q x then 1\n                              else if poly q x = 0 then 0 else - 1)\n                       qs !\n                      a =\n                      0", "apply (smt (z3) class_field.neg_1_not_0 class_field.zero_not_one nth_map welldef)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sign =\n             map (\\<lambda>q.\n                     if 0 < poly q x then 1\n                     else if poly q x = 0 then 0 else - 1)\n              qs;\n     poly (qs ! a) x = 0\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>q.\n                              if 0 < poly q x then 1\n                              else if poly q x = 0 then 0 else - 1)\n                       qs !\n                      a =\n                      0", "by (smt (z3) nth_map welldef)"], ["proof (state)\nthis:\n  ((sign ! a)\\<^sup>2 = 0) = (poly (qs ! a) x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "then"], ["proof (chain)\npicking this:\n  ((sign ! a)\\<^sup>2 = 0) = (poly (qs ! a) x = 0)", "have same1:\"(prod_list (map (nth (map_sgas sign)) (a#xa))) = 1 \\<longleftrightarrow> \n    ((poly (qs ! a) x = 0) \\<and> (prod_list (map ((!) (map_sgas sign)) (xa))) = 1)\""], ["proof (prove)\nusing this:\n  ((sign ! a)\\<^sup>2 = 0) = (poly (qs ! a) x = 0)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n    (poly (qs ! a) x = 0 \\<and>\n     prod_list (map ((!) (map_sgas sign)) xa) = 1)", "using s1"], ["proof (prove)\nusing this:\n  ((sign ! a)\\<^sup>2 = 0) = (poly (qs ! a) x = 0)\n  (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n  ((sign ! a)\\<^sup>2 = 0 \\<and>\n   prod_list (map ((!) (map_sgas sign)) xa) = 1)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n    (poly (qs ! a) x = 0 \\<and>\n     prod_list (map ((!) (map_sgas sign)) xa) = 1)", "by auto"], ["proof (state)\nthis:\n  (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n  (poly (qs ! a) x = 0 \\<and> prod_list (map ((!) (map_sgas sign)) xa) = 1)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "have \"set (retrieve_polys qs (a#xa)) = {(qs ! a)} \\<union> set (retrieve_polys qs xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (retrieve_polys qs (a # xa)) =\n    {qs ! a} \\<union> set (retrieve_polys qs xa)", "by (metis (no_types, lifting) insert_is_Un list.simps(15) list.simps(9) retrieve_polys_def)"], ["proof (state)\nthis:\n  set (retrieve_polys qs (a # xa)) =\n  {qs ! a} \\<union> set (retrieve_polys qs xa)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "then"], ["proof (chain)\npicking this:\n  set (retrieve_polys qs (a # xa)) =\n  {qs ! a} \\<union> set (retrieve_polys qs xa)", "have same2:\"(\\<forall>p \\<in> set (retrieve_polys qs (a#xa)). poly p x = 0) = ((poly (qs ! a) x = 0)\n      \\<and> (\\<forall>p \\<in> set (retrieve_polys qs (xa)). poly p x = 0))\""], ["proof (prove)\nusing this:\n  set (retrieve_polys qs (a # xa)) =\n  {qs ! a} \\<union> set (retrieve_polys qs xa)\n\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set (retrieve_polys qs (a # xa)). poly p x = 0) =\n    (poly (qs ! a) x = 0 \\<and>\n     (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>p\\<in>set (retrieve_polys qs (a # xa)). poly p x = 0) =\n  (poly (qs ! a) x = 0 \\<and>\n   (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0))\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) (map_sgas sign)) I) = 1) =\n                (\\<forall>p\\<in>set (retrieve_polys qs I). poly p x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (a # I)) =\n                          1) =\n                         (\\<forall>p\\<in>set (retrieve_polys qs (a # I)).\n                             poly p x = 0)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>p\\<in>set (retrieve_polys qs (a # xa)). poly p x = 0) =\n  (poly (qs ! a) x = 0 \\<and>\n   (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>p\\<in>set (retrieve_polys qs (a # xa)). poly p x = 0) =\n  (poly (qs ! a) x = 0 \\<and>\n   (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0))\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n    (\\<forall>p\\<in>set (retrieve_polys qs (a # xa)). poly p x = 0)", "using same0 same1 same2 \n      assms"], ["proof (prove)\nusing this:\n  (\\<forall>p\\<in>set (retrieve_polys qs (a # xa)). poly p x = 0) =\n  (poly (qs ! a) x = 0 \\<and>\n   (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0))\n  (prod_list (map ((!) (map_sgas sign)) xa) = 1) =\n  (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0)\n  (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n  (poly (qs ! a) x = 0 \\<and> prod_list (map ((!) (map_sgas sign)) xa) = 1)\n  (\\<forall>p\\<in>set (retrieve_polys qs (a # xa)). poly p x = 0) =\n  (poly (qs ! a) x = 0 \\<and>\n   (\\<forall>p\\<in>set (retrieve_polys qs xa). poly p x = 0))\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n    (\\<forall>p\\<in>set (retrieve_polys qs (a # xa)). poly p x = 0)", "by auto"], ["proof (state)\nthis:\n  (prod_list (map ((!) (map_sgas sign)) (a # xa)) = 1) =\n  (\\<forall>p\\<in>set (retrieve_polys qs (a # xa)). poly p x = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma csv_length_same_as_qlist: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  shows \"length sign = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length sign = length qs", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n\ngoal (1 subgoal):\n 1. length sign = length qs", "unfolding consistent_sign_vec_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign =\n  map (\\<lambda>q.\n          if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n   qs\n\ngoal (1 subgoal):\n 1. length sign = length qs", "by auto"], ["", "lemma horiz_vector_helper_zer_ind_R2: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes asm: \"list_constr I (length qs)\"\n  shows \"(prod_list (map (nth sign) I)) = 0 \\<longleftrightarrow> \n    (poly (prod_list (retrieve_polys qs I)) x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) I) = 0) =\n    (poly (prod_list (retrieve_polys qs I)) x = 0)", "using asm"], ["proof (prove)\nusing this:\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) I) = 0) =\n    (poly (prod_list (retrieve_polys qs I)) x = 0)", "proof (induction \"I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. list_constr [] (length qs) \\<Longrightarrow>\n    (prod_list (map ((!) sign) []) = 0) =\n    (poly (prod_list (retrieve_polys qs [])) x = 0)\n 2. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 0) =\n                (poly (prod_list (retrieve_polys qs I)) x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 0) =\n                         (poly (prod_list (retrieve_polys qs (a # I))) x =\n                          0)", "case Nil"], ["proof (state)\nthis:\n  list_constr [] (length qs)\n\ngoal (2 subgoals):\n 1. list_constr [] (length qs) \\<Longrightarrow>\n    (prod_list (map ((!) sign) []) = 0) =\n    (poly (prod_list (retrieve_polys qs [])) x = 0)\n 2. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 0) =\n                (poly (prod_list (retrieve_polys qs I)) x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 0) =\n                         (poly (prod_list (retrieve_polys qs (a # I))) x =\n                          0)", "then"], ["proof (chain)\npicking this:\n  list_constr [] (length qs)", "show ?case"], ["proof (prove)\nusing this:\n  list_constr [] (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) []) = 0) =\n    (poly (prod_list (retrieve_polys qs [])) x = 0)", "unfolding map_sgas_def"], ["proof (prove)\nusing this:\n  list_constr [] (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) []) = 0) =\n    (poly (prod_list (retrieve_polys qs [])) x = 0)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_constr [] (length qs);\n     poly (prod_list (retrieve_polys qs [])) x = 0\\<rbrakk>\n    \\<Longrightarrow> False", "unfolding retrieve_polys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_constr [] (length qs);\n     poly (prod_list (map ((!) qs) [])) x = 0\\<rbrakk>\n    \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  (prod_list (map ((!) sign) []) = 0) =\n  (poly (prod_list (retrieve_polys qs [])) x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 0) =\n                (poly (prod_list (retrieve_polys qs I)) x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 0) =\n                         (poly (prod_list (retrieve_polys qs (a # I))) x =\n                          0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 0) =\n                (poly (prod_list (retrieve_polys qs I)) x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 0) =\n                         (poly (prod_list (retrieve_polys qs (a # I))) x =\n                          0)", "case (Cons a xa)"], ["proof (state)\nthis:\n  list_constr xa (length qs) \\<Longrightarrow>\n  (prod_list (map ((!) sign) xa) = 0) =\n  (poly (prod_list (retrieve_polys qs xa)) x = 0)\n  list_constr (a # xa) (length qs)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 0) =\n                (poly (prod_list (retrieve_polys qs I)) x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 0) =\n                         (poly (prod_list (retrieve_polys qs (a # I))) x =\n                          0)", "have \"poly (prod_list (retrieve_polys qs (a # xa))) x = (poly (qs ! a) x)*poly (prod_list (retrieve_polys qs (xa))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list (retrieve_polys qs (a # xa))) x =\n    poly (qs ! a) x * poly (prod_list (retrieve_polys qs xa)) x", "by (simp add: retrieve_polys_def)"], ["proof (state)\nthis:\n  poly (prod_list (retrieve_polys qs (a # xa))) x =\n  poly (qs ! a) x * poly (prod_list (retrieve_polys qs xa)) x\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 0) =\n                (poly (prod_list (retrieve_polys qs I)) x = 0);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 0) =\n                         (poly (prod_list (retrieve_polys qs (a # I))) x =\n                          0)", "then"], ["proof (chain)\npicking this:\n  poly (prod_list (retrieve_polys qs (a # xa))) x =\n  poly (qs ! a) x * poly (prod_list (retrieve_polys qs xa)) x", "show ?case"], ["proof (prove)\nusing this:\n  poly (prod_list (retrieve_polys qs (a # xa))) x =\n  poly (qs ! a) x * poly (prod_list (retrieve_polys qs xa)) x\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) (a # xa)) = 0) =\n    (poly (prod_list (retrieve_polys qs (a # xa))) x = 0)", "using Cons.prems"], ["proof (prove)\nusing this:\n  poly (prod_list (retrieve_polys qs (a # xa))) x =\n  poly (qs ! a) x * poly (prod_list (retrieve_polys qs xa)) x\n  list_constr (a # xa) (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) (a # xa)) = 0) =\n    (poly (prod_list (retrieve_polys qs (a # xa))) x = 0)", "by (smt (z3) Cons.IH class_field.neg_1_not_0 class_field.zero_not_one consistent_sign_vec_def list.simps(9) list_all_simps(1) list_constr_def mult_eq_0_iff nth_map prod_list.Cons sign_fix)"], ["proof (state)\nthis:\n  (prod_list (map ((!) sign) (a # xa)) = 0) =\n  (poly (prod_list (retrieve_polys qs (a # xa))) x = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma horiz_vector_helper_pos_ind_R2: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes asm: \"list_constr I (length qs)\"\n  shows \"(prod_list (map (nth sign) I)) = 1 \\<longleftrightarrow> \n    (poly (prod_list (retrieve_polys qs I)) x > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) I) = 1) =\n    (0 < poly (prod_list (retrieve_polys qs I)) x)", "using asm"], ["proof (prove)\nusing this:\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) I) = 1) =\n    (0 < poly (prod_list (retrieve_polys qs I)) x)", "proof (induction \"I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. list_constr [] (length qs) \\<Longrightarrow>\n    (prod_list (map ((!) sign) []) = 1) =\n    (0 < poly (prod_list (retrieve_polys qs [])) x)\n 2. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "case Nil"], ["proof (state)\nthis:\n  list_constr [] (length qs)\n\ngoal (2 subgoals):\n 1. list_constr [] (length qs) \\<Longrightarrow>\n    (prod_list (map ((!) sign) []) = 1) =\n    (0 < poly (prod_list (retrieve_polys qs [])) x)\n 2. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "then"], ["proof (chain)\npicking this:\n  list_constr [] (length qs)", "show ?case"], ["proof (prove)\nusing this:\n  list_constr [] (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) []) = 1) =\n    (0 < poly (prod_list (retrieve_polys qs [])) x)", "unfolding map_sgas_def"], ["proof (prove)\nusing this:\n  list_constr [] (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) []) = 1) =\n    (0 < poly (prod_list (retrieve_polys qs [])) x)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr [] (length qs) \\<Longrightarrow>\n    0 < poly (prod_list (retrieve_polys qs [])) x", "unfolding retrieve_polys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr [] (length qs) \\<Longrightarrow>\n    0 < poly (prod_list (map ((!) qs) [])) x", "by auto"], ["proof (state)\nthis:\n  (prod_list (map ((!) sign) []) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs [])) x)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "case (Cons a xa)"], ["proof (state)\nthis:\n  list_constr xa (length qs) \\<Longrightarrow>\n  (prod_list (map ((!) sign) xa) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs xa)) x)\n  list_constr (a # xa) (length qs)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "then"], ["proof (chain)\npicking this:\n  list_constr xa (length qs) \\<Longrightarrow>\n  (prod_list (map ((!) sign) xa) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs xa)) x)\n  list_constr (a # xa) (length qs)", "have ih: \"(prod_list (map ((!) sign) xa) = 1) = (0 < poly (prod_list (retrieve_polys qs xa)) x)\""], ["proof (prove)\nusing this:\n  list_constr xa (length qs) \\<Longrightarrow>\n  (prod_list (map ((!) sign) xa) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs xa)) x)\n  list_constr (a # xa) (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) xa) = 1) =\n    (0 < poly (prod_list (retrieve_polys qs xa)) x)", "unfolding list_constr_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x < length qs) xa \\<Longrightarrow>\n  (prod_list (map ((!) sign) xa) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs xa)) x)\n  list_all (\\<lambda>x. x < length qs) (a # xa)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) xa) = 1) =\n    (0 < poly (prod_list (retrieve_polys qs xa)) x)", "by auto"], ["proof (state)\nthis:\n  (prod_list (map ((!) sign) xa) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs xa)) x)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have lensame: \"length sign = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length sign = length qs", "using sign_fix csv_length_same_as_qlist[of p x sign qs]\n      nonzero root_p"], ["proof (prove)\nusing this:\n  sign = consistent_sign_vec qs x\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec qs x\\<rbrakk>\n  \\<Longrightarrow> length sign = length qs\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. length sign = length qs", "by auto"], ["proof (state)\nthis:\n  length sign = length qs\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have \"poly (prod_list (retrieve_polys qs (a # xa))) x = (poly (qs ! a) x)*poly (prod_list (retrieve_polys qs (xa))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list (retrieve_polys qs (a # xa))) x =\n    poly (qs ! a) x * poly (prod_list (retrieve_polys qs xa)) x", "by (simp add: retrieve_polys_def)"], ["proof (state)\nthis:\n  poly (prod_list (retrieve_polys qs (a # xa))) x =\n  poly (qs ! a) x * poly (prod_list (retrieve_polys qs xa)) x\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "then"], ["proof (chain)\npicking this:\n  poly (prod_list (retrieve_polys qs (a # xa))) x =\n  poly (qs ! a) x * poly (prod_list (retrieve_polys qs xa)) x", "have iff1: \"(poly (prod_list (retrieve_polys qs (a#xa))) x > 0) \\<longleftrightarrow> \n      (((poly (qs ! a) x) > 0 \\<and> poly (prod_list (retrieve_polys qs (xa))) x > 0) \\<or> \n       ((poly (qs ! a) x) < 0 \\<and> poly (prod_list (retrieve_polys qs (xa))) x < 0))\""], ["proof (prove)\nusing this:\n  poly (prod_list (retrieve_polys qs (a # xa))) x =\n  poly (qs ! a) x * poly (prod_list (retrieve_polys qs xa)) x\n\ngoal (1 subgoal):\n 1. (0 < poly (prod_list (retrieve_polys qs (a # xa))) x) =\n    (0 < poly (qs ! a) x \\<and>\n     0 < poly (prod_list (retrieve_polys qs xa)) x \\<or>\n     poly (qs ! a) x < 0 \\<and>\n     poly (prod_list (retrieve_polys qs xa)) x < 0)", "by (metis zero_less_mult_iff)"], ["proof (state)\nthis:\n  (0 < poly (prod_list (retrieve_polys qs (a # xa))) x) =\n  (0 < poly (qs ! a) x \\<and>\n   0 < poly (prod_list (retrieve_polys qs xa)) x \\<or>\n   poly (qs ! a) x < 0 \\<and> poly (prod_list (retrieve_polys qs xa)) x < 0)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have prodsame: \"(prod_list (map (nth sign) (a#xa))) = (sign ! a)* (prod_list (map (nth sign) (xa)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) sign) (a # xa)) =\n    sign ! a * prod_list (map ((!) sign) xa)", "using lensame Cons.prems"], ["proof (prove)\nusing this:\n  length sign = length qs\n  list_constr (a # xa) (length qs)\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) sign) (a # xa)) =\n    sign ! a * prod_list (map ((!) sign) xa)", "unfolding list_constr_def"], ["proof (prove)\nusing this:\n  length sign = length qs\n  list_all (\\<lambda>x. x < length qs) (a # xa)\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) sign) (a # xa)) =\n    sign ! a * prod_list (map ((!) sign) xa)", "by auto"], ["proof (state)\nthis:\n  prod_list (map ((!) sign) (a # xa)) =\n  sign ! a * prod_list (map ((!) sign) xa)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have sagt: \"sign ! a = 1 \\<longleftrightarrow> (poly (qs ! a) x) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sign ! a = 1) = (0 < poly (qs ! a) x)", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. (sign ! a = 1) = (0 < poly (qs ! a) x)", "unfolding consistent_sign_vec_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign =\n  map (\\<lambda>q.\n          if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n   qs\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. (sign ! a = 1) = (0 < poly (qs ! a) x)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = 0;\n     sign =\n     map (\\<lambda>q.\n             if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n      qs;\n     list_constr I (length qs);\n     map (\\<lambda>q.\n             if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n      qs !\n     a =\n     1\\<rbrakk>\n    \\<Longrightarrow> 0 < poly (qs ! a) x\n 2. \\<lbrakk>p \\<noteq> 0; poly p x = 0;\n     sign =\n     map (\\<lambda>q.\n             if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n      qs;\n     list_constr I (length qs); 0 < poly (qs ! a) x\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>q.\n                              if 0 < poly q x then 1\n                              else if poly q x = 0 then 0 else - 1)\n                       qs !\n                      a =\n                      1", "apply (smt (verit, best) Cons.prems list_all_simps(1) list_constr_def neg_equal_zero nth_map zero_neq_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = 0;\n     sign =\n     map (\\<lambda>q.\n             if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n      qs;\n     list_constr I (length qs); 0 < poly (qs ! a) x\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>q.\n                              if 0 < poly q x then 1\n                              else if poly q x = 0 then 0 else - 1)\n                       qs !\n                      a =\n                      1", "by (smt (verit, ccfv_threshold) Cons.prems list_all_simps(1) list_constr_def nth_map)"], ["proof (state)\nthis:\n  (sign ! a = 1) = (0 < poly (qs ! a) x)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have salt: \"sign ! a = -1 \\<longleftrightarrow> (poly (qs ! a) x) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sign ! a = - 1) = (poly (qs ! a) x < 0)", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. (sign ! a = - 1) = (poly (qs ! a) x < 0)", "unfolding consistent_sign_vec_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign =\n  map (\\<lambda>q.\n          if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n   qs\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. (sign ! a = - 1) = (poly (qs ! a) x < 0)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = 0;\n     sign =\n     map (\\<lambda>q.\n             if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n      qs;\n     list_constr I (length qs);\n     map (\\<lambda>q.\n             if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n      qs !\n     a =\n     - 1\\<rbrakk>\n    \\<Longrightarrow> poly (qs ! a) x < 0\n 2. \\<lbrakk>p \\<noteq> 0; poly p x = 0;\n     sign =\n     map (\\<lambda>q.\n             if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n      qs;\n     list_constr I (length qs); poly (qs ! a) x < 0\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>q.\n                              if 0 < poly q x then 1\n                              else if poly q x = 0 then 0 else - 1)\n                       qs !\n                      a =\n                      - 1", "apply (smt (verit, ccfv_SIG) Cons.prems less_minus_one_simps(1) less_minus_one_simps(3) list_all_simps(1) list_constr_def neg_0_less_iff_less nth_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = 0;\n     sign =\n     map (\\<lambda>q.\n             if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n      qs;\n     list_constr I (length qs); poly (qs ! a) x < 0\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>q.\n                              if 0 < poly q x then 1\n                              else if poly q x = 0 then 0 else - 1)\n                       qs !\n                      a =\n                      - 1", "by (smt (verit, best) Cons.prems list_all_simps(1) list_constr_def nth_map)"], ["proof (state)\nthis:\n  (sign ! a = - 1) = (poly (qs ! a) x < 0)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have h1: \"((poly (qs ! a) x) > 0 \\<and> poly (prod_list (retrieve_polys qs (xa))) x > 0) \\<longrightarrow>\n       (prod_list (map (nth sign) (a#xa))) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly (qs ! a) x \\<and>\n    0 < poly (prod_list (retrieve_polys qs xa)) x \\<longrightarrow>\n    prod_list (map ((!) sign) (a # xa)) = 1", "using prodsame sagt ih"], ["proof (prove)\nusing this:\n  prod_list (map ((!) sign) (a # xa)) =\n  sign ! a * prod_list (map ((!) sign) xa)\n  (sign ! a = 1) = (0 < poly (qs ! a) x)\n  (prod_list (map ((!) sign) xa) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs xa)) x)\n\ngoal (1 subgoal):\n 1. 0 < poly (qs ! a) x \\<and>\n    0 < poly (prod_list (retrieve_polys qs xa)) x \\<longrightarrow>\n    prod_list (map ((!) sign) (a # xa)) = 1", "by auto"], ["proof (state)\nthis:\n  0 < poly (qs ! a) x \\<and>\n  0 < poly (prod_list (retrieve_polys qs xa)) x \\<longrightarrow>\n  prod_list (map ((!) sign) (a # xa)) = 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have eo: \"(prod_list (map ((!) sign) xa) = 1)  \\<or> (prod_list (map ((!) sign) xa) = 0) \\<or> \n      (prod_list (map ((!) sign) xa) = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) sign) xa) = 1 \\<or>\n    prod_list (map ((!) sign) xa) = 0 \\<or>\n    prod_list (map ((!) sign) xa) = - 1", "using Cons.prems consistent_signs_prop_R lensame list_constr_def nonzero root_p sign_fix z_signs_R2"], ["proof (prove)\nusing this:\n  list_constr (a # xa) (length qs)\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec ?qs ?x\\<rbrakk>\n  \\<Longrightarrow> list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                     ?sign\n  length sign = length qs\n  list_constr ?L ?n \\<equiv> list_all (\\<lambda>x. x < ?n) ?L\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  \\<lbrakk>list_all (\\<lambda>i. i < length ?signs) ?I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) ?signs\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) ?signs) ?I) = 1 \\<or>\n                    prod_list (map ((!) ?signs) ?I) = 0 \\<or>\n                    prod_list (map ((!) ?signs) ?I) = - 1\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) sign) xa) = 1 \\<or>\n    prod_list (map ((!) sign) xa) = 0 \\<or>\n    prod_list (map ((!) sign) xa) = - 1", "by auto"], ["proof (state)\nthis:\n  prod_list (map ((!) sign) xa) = 1 \\<or>\n  prod_list (map ((!) sign) xa) = 0 \\<or>\n  prod_list (map ((!) sign) xa) = - 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have d1:\"(prod_list (map ((!) sign) xa) = -1) \\<Longrightarrow> (0 > poly (prod_list (retrieve_polys qs xa)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) sign) xa) = - 1 \\<Longrightarrow>\n    poly (prod_list (retrieve_polys qs xa)) x < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_list (map ((!) sign) xa) = - 1 \\<Longrightarrow>\n    poly (prod_list (retrieve_polys qs xa)) x < 0", "assume \"(prod_list (map ((!) sign) xa) = -1) \""], ["proof (state)\nthis:\n  prod_list (map ((!) sign) xa) = - 1\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) sign) xa) = - 1 \\<Longrightarrow>\n    poly (prod_list (retrieve_polys qs xa)) x < 0", "then"], ["proof (chain)\npicking this:\n  prod_list (map ((!) sign) xa) = - 1", "show \"(0 > poly (prod_list (retrieve_polys qs xa)) x)\""], ["proof (prove)\nusing this:\n  prod_list (map ((!) sign) xa) = - 1\n\ngoal (1 subgoal):\n 1. poly (prod_list (retrieve_polys qs xa)) x < 0", "using prodsame salt ih assms Cons.prems class_field.neg_1_not_0 equal_neg_zero horiz_vector_helper_zer_ind_R2 linorder_neqE_linordered_idom list_all_simps(1) list_constr_def"], ["proof (prove)\nusing this:\n  prod_list (map ((!) sign) xa) = - 1\n  prod_list (map ((!) sign) (a # xa)) =\n  sign ! a * prod_list (map ((!) sign) xa)\n  (sign ! a = - 1) = (poly (qs ! a) x < 0)\n  (prod_list (map ((!) sign) xa) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs xa)) x)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr I (length qs)\n  list_constr (a # xa) (length qs)\n  - (1::?'a) \\<noteq> (0::?'a)\n  (?a = - ?a) = (?a = (0::?'a))\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec ?qs ?x; list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) ?sign) ?I) = 0) =\n                    (poly (prod_list (retrieve_polys ?qs ?I)) ?x = 0)\n  \\<lbrakk>?x \\<noteq> ?y; ?x < ?y \\<Longrightarrow> ?thesis;\n   ?y < ?x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  list_all ?P (?x # ?xs) = (?P ?x \\<and> list_all ?P ?xs)\n  list_constr ?L ?n \\<equiv> list_all (\\<lambda>x. x < ?n) ?L\n\ngoal (1 subgoal):\n 1. poly (prod_list (retrieve_polys qs xa)) x < 0", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prod_list (map ((!) (consistent_sign_vec qs x)) xa) = - 1;\n     \\<not> 0 < poly (prod_list (retrieve_polys qs xa)) x; p \\<noteq> 0;\n     poly p x = 0; sign = consistent_sign_vec qs x;\n     list_all (\\<lambda>x. x < length qs) I;\n     \\<And>p x sign qs I.\n        \\<lbrakk>p \\<noteq> 0; poly p x = 0;\n         sign = consistent_sign_vec qs x;\n         list_all (\\<lambda>x. x < length qs) I\\<rbrakk>\n        \\<Longrightarrow> (0 \\<in> (!) (consistent_sign_vec qs x) ` set I) =\n                          (poly (prod_list (retrieve_polys qs I)) x = 0);\n     \\<And>x y thesis.\n        \\<lbrakk>x \\<noteq> y; x < y \\<Longrightarrow> thesis;\n         y < x \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>L n. list_constr L n \\<equiv> list_all (\\<lambda>x. x < n) L;\n     a < length qs; list_all (\\<lambda>x. x < length qs) xa;\n     consistent_sign_vec qs x ! a = - 1; poly (qs ! a) x < 0\\<rbrakk>\n    \\<Longrightarrow> poly (prod_list (retrieve_polys qs xa)) x < 0\n 2. \\<lbrakk>prod_list (map ((!) (consistent_sign_vec qs x)) xa) = - 1;\n     \\<not> 0 < poly (prod_list (retrieve_polys qs xa)) x; p \\<noteq> 0;\n     poly p x = 0; sign = consistent_sign_vec qs x;\n     list_all (\\<lambda>x. x < length qs) I;\n     \\<And>p x sign qs I.\n        \\<lbrakk>p \\<noteq> 0; poly p x = 0;\n         sign = consistent_sign_vec qs x;\n         list_all (\\<lambda>x. x < length qs) I\\<rbrakk>\n        \\<Longrightarrow> (0 \\<in> (!) (consistent_sign_vec qs x) ` set I) =\n                          (poly (prod_list (retrieve_polys qs I)) x = 0);\n     \\<And>x y thesis.\n        \\<lbrakk>x \\<noteq> y; x < y \\<Longrightarrow> thesis;\n         y < x \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>L n. list_constr L n \\<equiv> list_all (\\<lambda>x. x < n) L;\n     a < length qs; list_all (\\<lambda>x. x < length qs) xa;\n     consistent_sign_vec qs x ! a \\<noteq> - 1;\n     \\<not> poly (qs ! a) x < 0\\<rbrakk>\n    \\<Longrightarrow> poly (prod_list (retrieve_polys qs xa)) x < 0", "apply (smt (verit, ccfv_threshold) class_field.neg_1_not_0 list.set_map list_all_length semidom_class.prod_list_zero_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prod_list (map ((!) (consistent_sign_vec qs x)) xa) = - 1;\n     \\<not> 0 < poly (prod_list (retrieve_polys qs xa)) x; p \\<noteq> 0;\n     poly p x = 0; sign = consistent_sign_vec qs x;\n     list_all (\\<lambda>x. x < length qs) I;\n     \\<And>p x sign qs I.\n        \\<lbrakk>p \\<noteq> 0; poly p x = 0;\n         sign = consistent_sign_vec qs x;\n         list_all (\\<lambda>x. x < length qs) I\\<rbrakk>\n        \\<Longrightarrow> (0 \\<in> (!) (consistent_sign_vec qs x) ` set I) =\n                          (poly (prod_list (retrieve_polys qs I)) x = 0);\n     \\<And>x y thesis.\n        \\<lbrakk>x \\<noteq> y; x < y \\<Longrightarrow> thesis;\n         y < x \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>L n. list_constr L n \\<equiv> list_all (\\<lambda>x. x < n) L;\n     a < length qs; list_all (\\<lambda>x. x < length qs) xa;\n     consistent_sign_vec qs x ! a \\<noteq> - 1;\n     \\<not> poly (qs ! a) x < 0\\<rbrakk>\n    \\<Longrightarrow> poly (prod_list (retrieve_polys qs xa)) x < 0", "by (smt (verit, ccfv_threshold) class_field.neg_1_not_0 list.set_map list_all_length semidom_class.prod_list_zero_iff)"], ["proof (state)\nthis:\n  poly (prod_list (retrieve_polys qs xa)) x < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod_list (map ((!) sign) xa) = - 1 \\<Longrightarrow>\n  poly (prod_list (retrieve_polys qs xa)) x < 0\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have d2: \"(0 > poly (prod_list (retrieve_polys qs xa)) x) \\<longrightarrow> (prod_list (map ((!) sign) xa) = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list (retrieve_polys qs xa)) x < 0 \\<longrightarrow>\n    prod_list (map ((!) sign) xa) = - 1", "using eo assms horiz_vector_helper_zer_ind_R2[where p = \"p\", where x = \"x\", where sign = \"sign\", where I =\"I\"]"], ["proof (prove)\nusing this:\n  prod_list (map ((!) sign) xa) = 1 \\<or>\n  prod_list (map ((!) sign) xa) = 0 \\<or>\n  prod_list (map ((!) sign) xa) = - 1\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr I (length qs)\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec ?qs x; list_constr I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) sign) I) = 0) =\n                    (poly (prod_list (retrieve_polys ?qs I)) x = 0)\n\ngoal (1 subgoal):\n 1. poly (prod_list (retrieve_polys qs xa)) x < 0 \\<longrightarrow>\n    prod_list (map ((!) sign) xa) = - 1", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = 0; sign = consistent_sign_vec qs x;\n     list_constr I (length qs);\n     \\<And>qsa.\n        \\<lbrakk>consistent_sign_vec qs x = consistent_sign_vec qsa x;\n         list_constr I (length qsa)\\<rbrakk>\n        \\<Longrightarrow> (0 \\<in> (!) (consistent_sign_vec qsa x) `\n                                   set I) =\n                          (poly (prod_list (retrieve_polys qsa I)) x = 0);\n     poly (prod_list (retrieve_polys qs xa)) x < 0;\n     prod_list (map ((!) (consistent_sign_vec qs x)) xa) = 1\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xb.\n       \\<lbrakk>p \\<noteq> 0; poly p x = 0; sign = consistent_sign_vec qs x;\n        list_constr I (length qs);\n        \\<And>qsa.\n           \\<lbrakk>consistent_sign_vec qs x = consistent_sign_vec qsa x;\n            list_constr I (length qsa)\\<rbrakk>\n           \\<Longrightarrow> (0 \\<in> (!) (consistent_sign_vec qsa x) `\nset I) =\n                             (poly (prod_list (retrieve_polys qsa I)) x =\n                              0);\n        poly (prod_list (retrieve_polys qs xa)) x < 0;\n        consistent_sign_vec qs x ! xb = 0; xb \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> prod_list\n                          (map ((!) (consistent_sign_vec qs x)) xa) =\n                         - 1", "using ih"], ["proof (prove)\nusing this:\n  (prod_list (map ((!) sign) xa) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs xa)) x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = 0; sign = consistent_sign_vec qs x;\n     list_constr I (length qs);\n     \\<And>qsa.\n        \\<lbrakk>consistent_sign_vec qs x = consistent_sign_vec qsa x;\n         list_constr I (length qsa)\\<rbrakk>\n        \\<Longrightarrow> (0 \\<in> (!) (consistent_sign_vec qsa x) `\n                                   set I) =\n                          (poly (prod_list (retrieve_polys qsa I)) x = 0);\n     poly (prod_list (retrieve_polys qs xa)) x < 0;\n     prod_list (map ((!) (consistent_sign_vec qs x)) xa) = 1\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>xb.\n       \\<lbrakk>p \\<noteq> 0; poly p x = 0; sign = consistent_sign_vec qs x;\n        list_constr I (length qs);\n        \\<And>qsa.\n           \\<lbrakk>consistent_sign_vec qs x = consistent_sign_vec qsa x;\n            list_constr I (length qsa)\\<rbrakk>\n           \\<Longrightarrow> (0 \\<in> (!) (consistent_sign_vec qsa x) `\nset I) =\n                             (poly (prod_list (retrieve_polys qsa I)) x =\n                              0);\n        poly (prod_list (retrieve_polys qs xa)) x < 0;\n        consistent_sign_vec qs x ! xb = 0; xb \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> prod_list\n                          (map ((!) (consistent_sign_vec qs x)) xa) =\n                         - 1", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>p \\<noteq> 0; poly p x = 0; sign = consistent_sign_vec qs x;\n        list_constr I (length qs);\n        \\<And>qsa.\n           \\<lbrakk>consistent_sign_vec qs x = consistent_sign_vec qsa x;\n            list_constr I (length qsa)\\<rbrakk>\n           \\<Longrightarrow> (0 \\<in> (!) (consistent_sign_vec qsa x) `\nset I) =\n                             (poly (prod_list (retrieve_polys qsa I)) x =\n                              0);\n        poly (prod_list (retrieve_polys qs xa)) x < 0;\n        consistent_sign_vec qs x ! xb = 0; xb \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> prod_list\n                          (map ((!) (consistent_sign_vec qs x)) xa) =\n                         - 1", "by (metis (full_types, lifting) Cons.prems class_field.neg_1_not_0 horiz_vector_helper_zer_ind_R2 ih imageI list.set_map list_all_simps(1) list_constr_def mem_Collect_eq neg_equal_0_iff_equal semidom_class.prod_list_zero_iff)"], ["proof (state)\nthis:\n  poly (prod_list (retrieve_polys qs xa)) x < 0 \\<longrightarrow>\n  prod_list (map ((!) sign) xa) = - 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have \"(prod_list (map ((!) sign) xa) = -1) = (0 > poly (prod_list (retrieve_polys qs xa)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) xa) = - 1) =\n    (poly (prod_list (retrieve_polys qs xa)) x < 0)", "using d1 d2"], ["proof (prove)\nusing this:\n  prod_list (map ((!) sign) xa) = - 1 \\<Longrightarrow>\n  poly (prod_list (retrieve_polys qs xa)) x < 0\n  poly (prod_list (retrieve_polys qs xa)) x < 0 \\<longrightarrow>\n  prod_list (map ((!) sign) xa) = - 1\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) xa) = - 1) =\n    (poly (prod_list (retrieve_polys qs xa)) x < 0)", "by blast"], ["proof (state)\nthis:\n  (prod_list (map ((!) sign) xa) = - 1) =\n  (poly (prod_list (retrieve_polys qs xa)) x < 0)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "then"], ["proof (chain)\npicking this:\n  (prod_list (map ((!) sign) xa) = - 1) =\n  (poly (prod_list (retrieve_polys qs xa)) x < 0)", "have h2: \"((poly (qs ! a) x) < 0 \\<and> poly (prod_list (retrieve_polys qs (xa))) x < 0) \\<longrightarrow>\n      (prod_list (map (nth sign) (a#xa))) = 1\""], ["proof (prove)\nusing this:\n  (prod_list (map ((!) sign) xa) = - 1) =\n  (poly (prod_list (retrieve_polys qs xa)) x < 0)\n\ngoal (1 subgoal):\n 1. poly (qs ! a) x < 0 \\<and>\n    poly (prod_list (retrieve_polys qs xa)) x < 0 \\<longrightarrow>\n    prod_list (map ((!) sign) (a # xa)) = 1", "using prodsame salt ih"], ["proof (prove)\nusing this:\n  (prod_list (map ((!) sign) xa) = - 1) =\n  (poly (prod_list (retrieve_polys qs xa)) x < 0)\n  prod_list (map ((!) sign) (a # xa)) =\n  sign ! a * prod_list (map ((!) sign) xa)\n  (sign ! a = - 1) = (poly (qs ! a) x < 0)\n  (prod_list (map ((!) sign) xa) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs xa)) x)\n\ngoal (1 subgoal):\n 1. poly (qs ! a) x < 0 \\<and>\n    poly (prod_list (retrieve_polys qs xa)) x < 0 \\<longrightarrow>\n    prod_list (map ((!) sign) (a # xa)) = 1", "by auto"], ["proof (state)\nthis:\n  poly (qs ! a) x < 0 \\<and>\n  poly (prod_list (retrieve_polys qs xa)) x < 0 \\<longrightarrow>\n  prod_list (map ((!) sign) (a # xa)) = 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "have h3: \"(prod_list (map (nth sign) (a#xa))) = 1 \\<longrightarrow> (((poly (qs ! a) x) > 0 \\<and> poly (prod_list (retrieve_polys qs (xa))) x > 0) \\<or> \n       ((poly (qs ! a) x) < 0 \\<and> poly (prod_list (retrieve_polys qs (xa))) x < 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) sign) (a # xa)) = 1 \\<longrightarrow>\n    0 < poly (qs ! a) x \\<and>\n    0 < poly (prod_list (retrieve_polys qs xa)) x \\<or>\n    poly (qs ! a) x < 0 \\<and> poly (prod_list (retrieve_polys qs xa)) x < 0", "using prodsame salt ih assms horiz_vector_helper_zer_ind_R2[where p = \"p\", where x = \"x\", where sign = \"sign\", where I =\"I\"]"], ["proof (prove)\nusing this:\n  prod_list (map ((!) sign) (a # xa)) =\n  sign ! a * prod_list (map ((!) sign) xa)\n  (sign ! a = - 1) = (poly (qs ! a) x < 0)\n  (prod_list (map ((!) sign) xa) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs xa)) x)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr I (length qs)\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec ?qs x; list_constr I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) sign) I) = 0) =\n                    (poly (prod_list (retrieve_polys ?qs I)) x = 0)\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) sign) (a # xa)) = 1 \\<longrightarrow>\n    0 < poly (qs ! a) x \\<and>\n    0 < poly (prod_list (retrieve_polys qs xa)) x \\<or>\n    poly (qs ! a) x < 0 \\<and> poly (prod_list (retrieve_polys qs xa)) x < 0", "by (smt (verit, ccfv_threshold) Cons.prems \\<open>poly (prod_list (retrieve_polys qs (a # xa))) x = poly (qs ! a) x * poly (prod_list (retrieve_polys qs xa)) x\\<close> horiz_vector_helper_zer_ind_R2 mem_Collect_eq mult_cancel_left1 mult_not_zero sagt)"], ["proof (state)\nthis:\n  prod_list (map ((!) sign) (a # xa)) = 1 \\<longrightarrow>\n  0 < poly (qs ! a) x \\<and>\n  0 < poly (prod_list (retrieve_polys qs xa)) x \\<or>\n  poly (qs ! a) x < 0 \\<and> poly (prod_list (retrieve_polys qs xa)) x < 0\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>list_constr I (length qs) \\<Longrightarrow>\n                (prod_list (map ((!) sign) I) = 1) =\n                (0 < poly (prod_list (retrieve_polys qs I)) x);\n        list_constr (a # I) (length qs)\\<rbrakk>\n       \\<Longrightarrow> (prod_list (map ((!) sign) (a # I)) = 1) =\n                         (0 < poly (prod_list (retrieve_polys qs (a # I)))\n                               x)", "then"], ["proof (chain)\npicking this:\n  prod_list (map ((!) sign) (a # xa)) = 1 \\<longrightarrow>\n  0 < poly (qs ! a) x \\<and>\n  0 < poly (prod_list (retrieve_polys qs xa)) x \\<or>\n  poly (qs ! a) x < 0 \\<and> poly (prod_list (retrieve_polys qs xa)) x < 0", "show ?case"], ["proof (prove)\nusing this:\n  prod_list (map ((!) sign) (a # xa)) = 1 \\<longrightarrow>\n  0 < poly (qs ! a) x \\<and>\n  0 < poly (prod_list (retrieve_polys qs xa)) x \\<or>\n  poly (qs ! a) x < 0 \\<and> poly (prod_list (retrieve_polys qs xa)) x < 0\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) (a # xa)) = 1) =\n    (0 < poly (prod_list (retrieve_polys qs (a # xa))) x)", "using h1 h2 h3 iff1 Cons.prems"], ["proof (prove)\nusing this:\n  prod_list (map ((!) sign) (a # xa)) = 1 \\<longrightarrow>\n  0 < poly (qs ! a) x \\<and>\n  0 < poly (prod_list (retrieve_polys qs xa)) x \\<or>\n  poly (qs ! a) x < 0 \\<and> poly (prod_list (retrieve_polys qs xa)) x < 0\n  0 < poly (qs ! a) x \\<and>\n  0 < poly (prod_list (retrieve_polys qs xa)) x \\<longrightarrow>\n  prod_list (map ((!) sign) (a # xa)) = 1\n  poly (qs ! a) x < 0 \\<and>\n  poly (prod_list (retrieve_polys qs xa)) x < 0 \\<longrightarrow>\n  prod_list (map ((!) sign) (a # xa)) = 1\n  prod_list (map ((!) sign) (a # xa)) = 1 \\<longrightarrow>\n  0 < poly (qs ! a) x \\<and>\n  0 < poly (prod_list (retrieve_polys qs xa)) x \\<or>\n  poly (qs ! a) x < 0 \\<and> poly (prod_list (retrieve_polys qs xa)) x < 0\n  (0 < poly (prod_list (retrieve_polys qs (a # xa))) x) =\n  (0 < poly (qs ! a) x \\<and>\n   0 < poly (prod_list (retrieve_polys qs xa)) x \\<or>\n   poly (qs ! a) x < 0 \\<and> poly (prod_list (retrieve_polys qs xa)) x < 0)\n  list_constr (a # xa) (length qs)\n\ngoal (1 subgoal):\n 1. (prod_list (map ((!) sign) (a # xa)) = 1) =\n    (0 < poly (prod_list (retrieve_polys qs (a # xa))) x)", "by auto"], ["proof (state)\nthis:\n  (prod_list (map ((!) sign) (a # xa)) = 1) =\n  (0 < poly (prod_list (retrieve_polys qs (a # xa))) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma horiz_vector_helper_pos_ind_R: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list * nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes asm1: \"list_constr (fst I) (length qs)\"\n  assumes asm2: \"list_constr (snd I) (length qs)\"\n  shows \"((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x > 0)) \\<longleftrightarrow> (z_R I sign = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n    (z_R I sign = 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n    (z_R I sign = 1)", "have len: \"length sign = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length sign = length qs", "using sign_fix csv_length_same_as_qlist[of p x sign qs]\n      nonzero root_p"], ["proof (prove)\nusing this:\n  sign = consistent_sign_vec qs x\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec qs x\\<rbrakk>\n  \\<Longrightarrow> length sign = length qs\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. length sign = length qs", "by auto"], ["proof (state)\nthis:\n  length sign = length qs\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n    (z_R I sign = 1)", "have d1: \"((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x > 0)) \\<longrightarrow> (z_R I sign = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<longrightarrow>\n    z_R I sign = 1", "using assms horiz_vector_helper_pos_ind_R1[where p = \"p\", where qs = \"qs\", where sign = \"sign\", where x = \"x\", where I = \"fst I\"]\n      horiz_vector_helper_pos_ind_R2[where p = \"p\", where qs = \"qs\", where sign = \"sign\", where x = \"x\", where I = \"snd I\"]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec qs x; list_constr (fst I) (length qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (fst I)) = 1) =\n                    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                        poly p x = 0)\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec qs x; list_constr (snd I) (length qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) sign) (snd I)) = 1) =\n                    (0 < poly (prod_list (retrieve_polys qs (snd I))) x)\n\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<longrightarrow>\n    z_R I sign = 1", "unfolding z_R_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec qs x; list_constr (fst I) (length qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (fst I)) = 1) =\n                    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                        poly p x = 0)\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec qs x; list_constr (snd I) (length qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) sign) (snd I)) = 1) =\n                    (0 < poly (prod_list (retrieve_polys qs (snd I))) x)\n\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<longrightarrow>\n    prod_list (map ((!) (map_sgas sign)) (fst I)) *\n    prod_list (map ((!) sign) (snd I)) =\n    1", "by auto"], ["proof (state)\nthis:\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<longrightarrow>\n  z_R I sign = 1\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n    (z_R I sign = 1)", "have d2: \"(z_R I sign = 1) \\<longrightarrow> ((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x > 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x", "have h1: \"(z_R I sign = 1) \\<longrightarrow> (\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)", "have \"(prod_list (map (nth (map_sgas sign)) (fst I))) = 1 \\<or> (prod_list (map (nth (map_sgas sign)) (fst I))) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or>\n    prod_list (map ((!) (map_sgas sign)) (fst I)) = 0", "using len consistent_signs_prop_R[where p = \"p\", where qs = \"qs\", where x = \"x\", where sign = \"sign\"] z_signs_R1[where signs = \"sign\", where I = \"fst I\"] assms"], ["proof (prove)\nusing this:\n  length sign = length qs\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec qs x\\<rbrakk>\n  \\<Longrightarrow> list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                     sign\n  \\<lbrakk>list_all (\\<lambda>i. i < length sign) (fst I);\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or>\n                    prod_list (map ((!) (map_sgas sign)) (fst I)) = 0\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or>\n    prod_list (map ((!) (map_sgas sign)) (fst I)) = 0", "unfolding list_constr_def"], ["proof (prove)\nusing this:\n  length sign = length qs\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec qs x\\<rbrakk>\n  \\<Longrightarrow> list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1)\n                     sign\n  \\<lbrakk>list_all (\\<lambda>i. i < length sign) (fst I);\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or>\n                    prod_list (map ((!) (map_sgas sign)) (fst I)) = 0\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_all (\\<lambda>x. x < length qs) (fst I)\n  list_all (\\<lambda>x. x < length qs) (snd I)\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or>\n    prod_list (map ((!) (map_sgas sign)) (fst I)) = 0", "by auto"], ["proof (state)\nthis:\n  prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or>\n  prod_list (map ((!) (map_sgas sign)) (fst I)) = 0\n\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)", "then"], ["proof (chain)\npicking this:\n  prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or>\n  prod_list (map ((!) (map_sgas sign)) (fst I)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or>\n  prod_list (map ((!) (map_sgas sign)) (fst I)) = 0\n\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)", "using z_signs_R1[where signs = \"sign\", where I = \"fst I\"] horiz_vector_helper_pos_ind_R1[where sign = \"sign\", where I = \"fst I\", where p = \"p\", where x = \"x\"] assms"], ["proof (prove)\nusing this:\n  prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or>\n  prod_list (map ((!) (map_sgas sign)) (fst I)) = 0\n  \\<lbrakk>list_all (\\<lambda>i. i < length sign) (fst I);\n   list_all (\\<lambda>s. s = 1 \\<or> s = 0 \\<or> s = - 1) sign\\<rbrakk>\n  \\<Longrightarrow> prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or>\n                    prod_list (map ((!) (map_sgas sign)) (fst I)) = 0\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec ?qs x;\n   list_constr (fst I) (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) (map_sgas sign)) (fst I)) = 1) =\n                    (\\<forall>p\\<in>set (retrieve_polys ?qs (fst I)).\n                        poly p x = 0)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pa xa.\n       \\<lbrakk>\\<And>qsa.\n                   \\<lbrakk>consistent_sign_vec qs x =\n                            consistent_sign_vec qsa x;\n                    list_constr (fst I) (length qsa)\\<rbrakk>\n                   \\<Longrightarrow> (prod_list\n (map ((!) (map_sgas (consistent_sign_vec qsa x))) (fst I)) =\n1) =\n                                     (\\<forall>p\n         \\<in>set (retrieve_polys qsa (fst I)).\n   poly p x = 0);\n        p \\<noteq> 0; poly p x = 0; sign = consistent_sign_vec qs x;\n        list_constr (fst I) (length qs); list_constr (snd I) (length qs);\n        z_R I (consistent_sign_vec qs x) = 1;\n        pa \\<in> set (retrieve_polys qs (fst I));\n        map_sgas (consistent_sign_vec qs x) ! xa = 0;\n        xa \\<in> set (fst I)\\<rbrakk>\n       \\<Longrightarrow> poly pa x = 0", "by (metis (mono_tags, hide_lams) \\<open>prod_list (map ((!) (map_sgas sign)) (fst I)) = 1 \\<or> prod_list (map ((!) (map_sgas sign)) (fst I)) = 0\\<close> mult_zero_left z_R_def)"], ["proof (state)\nthis:\n  z_R I sign = 1 \\<longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z_R I sign = 1 \\<longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)\n\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x", "then"], ["proof (chain)\npicking this:\n  z_R I sign = 1 \\<longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)", "have h2: \"(z_R I sign = 1) \\<longrightarrow> (poly (prod_list (retrieve_polys qs (snd I))) x > 0)\""], ["proof (prove)\nusing this:\n  z_R I sign = 1 \\<longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)\n\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x", "unfolding z_R_def"], ["proof (prove)\nusing this:\n  prod_list (map ((!) (map_sgas sign)) (fst I)) *\n  prod_list (map ((!) sign) (snd I)) =\n  1 \\<longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas sign)) (fst I)) *\n    prod_list (map ((!) sign) (snd I)) =\n    1 \\<longrightarrow>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x", "using assms horiz_vector_helper_pos_ind_R2[where p = \"p\", where x = \"x\", where sign = \"sign\", where qs = \"qs\", where I =\"snd I\"]"], ["proof (prove)\nusing this:\n  prod_list (map ((!) (map_sgas sign)) (fst I)) *\n  prod_list (map ((!) sign) (snd I)) =\n  1 \\<longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec qs x; list_constr (snd I) (length qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) sign) (snd I)) = 1) =\n                    (0 < poly (prod_list (retrieve_polys qs (snd I))) x)\n\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas sign)) (fst I)) *\n    prod_list (map ((!) sign) (snd I)) =\n    1 \\<longrightarrow>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x", "by (metis horiz_vector_helper_pos_ind_R1 mult.left_neutral)"], ["proof (state)\nthis:\n  z_R I sign = 1 \\<longrightarrow>\n  0 < poly (prod_list (retrieve_polys qs (snd I))) x\n\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x", "using h1 h2"], ["proof (prove)\nusing this:\n  z_R I sign = 1 \\<longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0)\n  z_R I sign = 1 \\<longrightarrow>\n  0 < poly (prod_list (retrieve_polys qs (snd I))) x\n\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    0 < poly (prod_list (retrieve_polys qs (snd I))) x", "by auto"], ["proof (state)\nthis:\n  z_R I sign = 1 \\<longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  0 < poly (prod_list (retrieve_polys qs (snd I))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z_R I sign = 1 \\<longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  0 < poly (prod_list (retrieve_polys qs (snd I))) x\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n    (z_R I sign = 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n    (z_R I sign = 1)", "using d1 d2"], ["proof (prove)\nusing this:\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<longrightarrow>\n  z_R I sign = 1\n  z_R I sign = 1 \\<longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  0 < poly (prod_list (retrieve_polys qs (snd I))) x\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n    (z_R I sign = 1)", "by blast"], ["proof (state)\nthis:\n  ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n   0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n  (z_R I sign = 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma horiz_vector_helper_pos_R: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows \"((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x > 0)) \\<longleftrightarrow> (z_R I sign = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n    (z_R I sign = 1)", "using horiz_vector_helper_pos_ind_R"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec ?qs ?x; list_constr (fst ?I) (length ?qs);\n   list_constr (snd ?I) (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<forall>p\\<in>set (retrieve_polys ?qs (fst ?I)).\n                         poly p ?x = 0) \\<and>\n                     0 < poly (prod_list (retrieve_polys ?qs (snd ?I)))\n                          ?x) =\n                    (z_R ?I ?sign = 1)\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n    (z_R I sign = 1)", "using  nonzero  root_p sign_fix welldefined1 welldefined2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec ?qs ?x; list_constr (fst ?I) (length ?qs);\n   list_constr (snd ?I) (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<forall>p\\<in>set (retrieve_polys ?qs (fst ?I)).\n                         poly p ?x = 0) \\<and>\n                     0 < poly (prod_list (retrieve_polys ?qs (snd ?I)))\n                          ?x) =\n                    (z_R ?I ?sign = 1)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     0 < poly (prod_list (retrieve_polys qs (snd I))) x) =\n    (z_R I sign = 1)", "by blast"], ["", "lemma horiz_vector_helper_neg_R: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec qs x\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows \"((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x < 0)) \\<longleftrightarrow> (z_R I sign = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     poly (prod_list (retrieve_polys qs (snd I))) x < 0) =\n    (z_R I sign = - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     poly (prod_list (retrieve_polys qs (snd I))) x < 0) =\n    (z_R I sign = - 1)", "have set_hyp: \"sign \\<in> set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign \\<in> set (characterize_consistent_signs_at_roots p qs)", "using in_set_R[of p x sign qs] nonzero root_p sign_fix"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; x \\<in> {x. poly p x = 0};\n   sign = consistent_sign_vec qs x\\<rbrakk>\n  \\<Longrightarrow> sign\n                    \\<in> set (characterize_consistent_signs_at_roots p qs)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n\ngoal (1 subgoal):\n 1. sign \\<in> set (characterize_consistent_signs_at_roots p qs)", "by blast"], ["proof (state)\nthis:\n  sign \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     poly (prod_list (retrieve_polys qs (snd I))) x < 0) =\n    (z_R I sign = - 1)", "have z_hyp: \"((z_R I sign = 1) \\<or> (z_R I sign = 0) \\<or> (z_R I sign = -1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<or> z_R I sign = 0 \\<or> z_R I sign = - 1", "using welldefined1 welldefined2 set_hyp  z_lemma_R[where sign=\"sign\", where I = \"I\", where p=\"p\", where qs=\"qs\"]"], ["proof (prove)\nusing this:\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n  sign \\<in> set (characterize_consistent_signs_at_roots p qs)\n  \\<lbrakk>sign \\<in> set (characterize_consistent_signs_at_roots p qs);\n   list_constr (fst I) (length qs); list_constr (snd I) (length qs)\\<rbrakk>\n  \\<Longrightarrow> z_R I sign = 1 \\<or>\n                    z_R I sign = 0 \\<or> z_R I sign = - 1\n\ngoal (1 subgoal):\n 1. z_R I sign = 1 \\<or> z_R I sign = 0 \\<or> z_R I sign = - 1", "by blast"], ["proof (state)\nthis:\n  z_R I sign = 1 \\<or> z_R I sign = 0 \\<or> z_R I sign = - 1\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     poly (prod_list (retrieve_polys qs (snd I))) x < 0) =\n    (z_R I sign = - 1)", "have d1: \"((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x < 0)) \\<Longrightarrow> (z_R I sign = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    poly (prod_list (retrieve_polys qs (snd I))) x < 0 \\<Longrightarrow>\n    z_R I sign = - 1", "using horiz_vector_helper_pos_R"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec ?qs ?x; list_constr (fst ?I) (length ?qs);\n   list_constr (snd ?I) (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<forall>p\\<in>set (retrieve_polys ?qs (fst ?I)).\n                         poly p ?x = 0) \\<and>\n                     0 < poly (prod_list (retrieve_polys ?qs (snd ?I)))\n                          ?x) =\n                    (z_R ?I ?sign = 1)\n\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    poly (prod_list (retrieve_polys qs (snd I))) x < 0 \\<Longrightarrow>\n    z_R I sign = - 1", "using nonzero root_p sign_fix welldefined1 welldefined2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec ?qs ?x; list_constr (fst ?I) (length ?qs);\n   list_constr (snd ?I) (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<forall>p\\<in>set (retrieve_polys ?qs (fst ?I)).\n                         poly p ?x = 0) \\<and>\n                     0 < poly (prod_list (retrieve_polys ?qs (snd ?I)))\n                          ?x) =\n                    (z_R ?I ?sign = 1)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    poly (prod_list (retrieve_polys qs (snd I))) x < 0 \\<Longrightarrow>\n    z_R I sign = - 1", "by (smt (verit, ccfv_threshold) horiz_vector_helper_pos_ind_R1 horiz_vector_helper_zer_ind_R2 mem_Collect_eq mult_eq_0_iff z_R_def z_hyp)"], ["proof (state)\nthis:\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  poly (prod_list (retrieve_polys qs (snd I))) x < 0 \\<Longrightarrow>\n  z_R I sign = - 1\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     poly (prod_list (retrieve_polys qs (snd I))) x < 0) =\n    (z_R I sign = - 1)", "have d2: \"(z_R I sign = -1) \\<Longrightarrow> ((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x < 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R I sign = - 1 \\<Longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    poly (prod_list (retrieve_polys qs (snd I))) x < 0", "using horiz_vector_helper_pos_ind_R1 horiz_vector_helper_zer_ind_R2 nonzero root_p sign_fix welldefined1 welldefined2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec ?qs ?x; list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) (map_sgas ?sign)) ?I) = 1) =\n                    (\\<forall>p\\<in>set (retrieve_polys ?qs ?I).\n                        poly p ?x = 0)\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec ?qs ?x; list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> (prod_list (map ((!) ?sign) ?I) = 0) =\n                    (poly (prod_list (retrieve_polys ?qs ?I)) ?x = 0)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec qs x\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n\ngoal (1 subgoal):\n 1. z_R I sign = - 1 \\<Longrightarrow>\n    (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n    poly (prod_list (retrieve_polys qs (snd I))) x < 0", "by (smt (verit, ccfv_threshold) class_field.neg_1_not_0 consistent_sign_vec_def consistent_signs_prop_R equal_neg_zero horiz_vector_helper_pos_ind_R2 length_map list_all_length list_constr_def mem_Collect_eq mem_Collect_eq mult_cancel_left1 mult_not_zero retrieve_polys_def z_R_def z_signs_R1 zero_neq_one)"], ["proof (state)\nthis:\n  z_R I sign = - 1 \\<Longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  poly (prod_list (retrieve_polys qs (snd I))) x < 0\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     poly (prod_list (retrieve_polys qs (snd I))) x < 0) =\n    (z_R I sign = - 1)", "then"], ["proof (chain)\npicking this:\n  z_R I sign = - 1 \\<Longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  poly (prod_list (retrieve_polys qs (snd I))) x < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  z_R I sign = - 1 \\<Longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  poly (prod_list (retrieve_polys qs (snd I))) x < 0\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     poly (prod_list (retrieve_polys qs (snd I))) x < 0) =\n    (z_R I sign = - 1)", "using d1 d2"], ["proof (prove)\nusing this:\n  z_R I sign = - 1 \\<Longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  poly (prod_list (retrieve_polys qs (snd I))) x < 0\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  poly (prod_list (retrieve_polys qs (snd I))) x < 0 \\<Longrightarrow>\n  z_R I sign = - 1\n  z_R I sign = - 1 \\<Longrightarrow>\n  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n  poly (prod_list (retrieve_polys qs (snd I))) x < 0\n\ngoal (1 subgoal):\n 1. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n     poly (prod_list (retrieve_polys qs (snd I))) x < 0) =\n    (z_R I sign = - 1)", "by linarith"], ["proof (state)\nthis:\n  ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n   poly (prod_list (retrieve_polys qs (snd I))) x < 0) =\n  (z_R I sign = - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lhs_dot_rewrite:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  shows\n    \"(vec_of_list (mtx_row_R signs I) \\<bullet> (construct_lhs_vector_R p qs signs)) =\n   sum_list (map (\\<lambda>s. (z_R I s)  *  rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "have \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using nonzero"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "from construct_lhs_vector_cleaner[OF this]"], ["proof (chain)\npicking this:\n  w_vec p ?qs ?signs =\n  vec_of_list\n   (map (\\<lambda>s.\n            rat_of_int\n             (int (card\n                    {x. poly p x = 0 \\<and>\n                        consistent_sign_vec_copr ?qs x = s})))\n     ?signs)", "have rhseq: \"construct_lhs_vector_R p qs signs =\n    vec_of_list\n    (map (\\<lambda>s. rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) signs)\""], ["proof (prove)\nusing this:\n  w_vec p ?qs ?signs =\n  vec_of_list\n   (map (\\<lambda>s.\n            rat_of_int\n             (int (card\n                    {x. poly p x = 0 \\<and>\n                        consistent_sign_vec_copr ?qs x = s})))\n     ?signs)\n\ngoal (1 subgoal):\n 1. construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec qs x = s})))\n       signs)", "using construct_lhs_vector_cleaner_R nonzero"], ["proof (prove)\nusing this:\n  w_vec p ?qs ?signs =\n  vec_of_list\n   (map (\\<lambda>s.\n            rat_of_int\n             (int (card\n                    {x. poly p x = 0 \\<and>\n                        consistent_sign_vec_copr ?qs x = s})))\n     ?signs)\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  construct_lhs_vector_R ?p ?qs ?signs =\n  vec_of_list\n   (map (\\<lambda>s.\n            rat_of_int\n             (int (card\n                    {x. poly ?p x = 0 \\<and>\n                        consistent_sign_vec ?qs x = s})))\n     ?signs)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec qs x = s})))\n       signs)", "by presburger"], ["proof (state)\nthis:\n  construct_lhs_vector_R p qs signs =\n  vec_of_list\n   (map (\\<lambda>s.\n            rat_of_int\n             (int (card\n                    {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n     signs)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "have \"(vec_of_list (mtx_row_R signs I) \\<bullet> (construct_lhs_vector_R p qs signs)) =    \n    sum_list (map2 (*) (mtx_row_R signs I) (map (\\<lambda>s. rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) signs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    sum_list\n     (map2 (*) (mtx_row_R signs I)\n       (map (\\<lambda>s.\n                rat_of_int\n                 (int (card\n                        {x. poly p x = 0 \\<and>\n                            consistent_sign_vec qs x = s})))\n         signs))", "unfolding rhseq"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    vec_of_list\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec qs x = s})))\n       signs) =\n    sum_list\n     (map2 (*) (mtx_row_R signs I)\n       (map (\\<lambda>s.\n                rat_of_int\n                 (int (card\n                        {x. poly p x = 0 \\<and>\n                            consistent_sign_vec qs x = s})))\n         signs))", "apply (intro vec_of_list_dot_rewrite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mtx_row_R signs I) =\n    length\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec qs x = s})))\n       signs)", "by (auto simp add: mtx_row_R_def)"], ["proof (state)\nthis:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  sum_list\n   (map2 (*) (mtx_row_R signs I)\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec qs x = s})))\n       signs))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "thus ?thesis"], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  sum_list\n   (map2 (*) (mtx_row_R signs I)\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec qs x = s})))\n       signs))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "unfolding mtx_row_R_def"], ["proof (prove)\nusing this:\n  vec_of_list (map (z_R I) signs) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  sum_list\n   (map2 (*) (map (z_R I) signs)\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec qs x = s})))\n       signs))\n\ngoal (1 subgoal):\n 1. vec_of_list (map (z_R I) signs) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "using map2_map_map"], ["proof (prove)\nusing this:\n  vec_of_list (map (z_R I) signs) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  sum_list\n   (map2 (*) (map (z_R I) signs)\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec qs x = s})))\n       signs))\n  map2 ?h (map ?f ?xs) (map ?g ?xs) = map (\\<lambda>x. ?h (?f x) (?g x)) ?xs\n\ngoal (1 subgoal):\n 1. vec_of_list (map (z_R I) signs) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "by (auto simp add: map2_map_map)"], ["proof (state)\nthis:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                             rat_of_int\n                              (int (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* If we have a superset of the signs, we can drop to just the consistent ones *)"], ["", "lemma construct_lhs_vector_drop_consistent_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows\n    \"(vec_of_list (mtx_row_R signs I) \\<bullet> (construct_lhs_vector_R p qs signs)) =\n     (vec_of_list (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n      (construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "have h0: \"\\<forall> sgn. sgn \\<in> set signs \\<and> sgn \\<notin> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<and> \n    0 < rat_of_nat (card  {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn}) \\<longrightarrow> z_R I sgn = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "have \"\\<forall> sgn. sgn \\<in> set signs \\<and> sgn \\<notin> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<and> 0 < rat_of_int (card\n                  {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn}) \\<longrightarrow> {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {}", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_int\n          (int (card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n     {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_int\n          (int (card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n     {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_int\n          (int (card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n     {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "fix iis :: \"rat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "have ff1: \"0 \\<noteq> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> p", "using nonzero rsquarefree_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  rsquarefree ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>a. Polynomial.order a ?p = 0 \\<or> Polynomial.order a ?p = 1))\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> p", "by blast"], ["proof (state)\nthis:\n  0 \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "obtain rr :: \"(real \\<Rightarrow> bool) \\<Rightarrow> real\" where\n          ff2: \"\\<And>p. p (rr p) \\<or> Collect p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rr.\n        (\\<And>p. p (rr p) \\<or> Collect p = {}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  ?p (rr ?p) \\<or> Collect ?p = {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "{"], ["proof (state)\nthis:\n  ?p (rr ?p) \\<or> Collect ?p = {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "assume \"\\<exists>is. is = iis \\<and> {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}", "have \"\\<exists>is. consistent_sign_vec qs (rr (\\<lambda>r. poly p r = 0 \\<and> consistent_sign_vec qs r = is)) = iis \\<and> {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>is.\n       consistent_sign_vec qs\n        (rr (\\<lambda>r.\n                poly p r = 0 \\<and> consistent_sign_vec qs r = is)) =\n       iis \\<and>\n       {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}", "using ff2"], ["proof (prove)\nusing this:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}\n  ?p (rr ?p) \\<or> Collect ?p = {}\n\ngoal (1 subgoal):\n 1. \\<exists>is.\n       consistent_sign_vec qs\n        (rr (\\<lambda>r.\n                poly p r = 0 \\<and> consistent_sign_vec qs r = is)) =\n       iis \\<and>\n       {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  \\<exists>is.\n     consistent_sign_vec qs\n      (rr (\\<lambda>r. poly p r = 0 \\<and> consistent_sign_vec qs r = is)) =\n     iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>is.\n     consistent_sign_vec qs\n      (rr (\\<lambda>r. poly p r = 0 \\<and> consistent_sign_vec qs r = is)) =\n     iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}", "have \"\\<exists>r. poly p r = 0 \\<and> consistent_sign_vec qs r = iis\""], ["proof (prove)\nusing this:\n  \\<exists>is.\n     consistent_sign_vec qs\n      (rr (\\<lambda>r. poly p r = 0 \\<and> consistent_sign_vec qs r = is)) =\n     iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec qs r = iis", "using ff2"], ["proof (prove)\nusing this:\n  \\<exists>is.\n     consistent_sign_vec qs\n      (rr (\\<lambda>r. poly p r = 0 \\<and> consistent_sign_vec qs r = is)) =\n     iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq> {}\n  ?p (rr ?p) \\<or> Collect ?p = {}\n\ngoal (1 subgoal):\n 1. \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec qs r = iis", "by smt"], ["proof (state)\nthis:\n  \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec qs r = iis\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec qs r = iis", "have \"iis \\<in> consistent_sign_vec qs ` set (sorted_list_of_set {r. poly p r = 0})\""], ["proof (prove)\nusing this:\n  \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec qs r = iis\n\ngoal (1 subgoal):\n 1. iis\n    \\<in> consistent_sign_vec qs `\n          set (sorted_list_of_set {r. poly p r = 0})", "using ff1 poly_roots_finite"], ["proof (prove)\nusing this:\n  \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec qs r = iis\n  0 \\<noteq> p\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. iis\n    \\<in> consistent_sign_vec qs `\n          set (sorted_list_of_set {r. poly p r = 0})", "by (metis (mono_tags) imageI mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  iis\n  \\<in> consistent_sign_vec qs ` set (sorted_list_of_set {r. poly p r = 0})\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "}"], ["proof (state)\nthis:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq>\n     {} \\<Longrightarrow>\n  iis\n  \\<in> consistent_sign_vec qs ` set (sorted_list_of_set {r. poly p r = 0})\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq>\n     {} \\<Longrightarrow>\n  iis\n  \\<in> consistent_sign_vec qs ` set (sorted_list_of_set {r. poly p r = 0})", "have \"iis \\<notin> set signs \\<or> iis \\<in> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<or> \\<not> 0 < rat_of_int (int (card {r. poly p r = 0 \\<and> consistent_sign_vec qs r = iis}))\""], ["proof (prove)\nusing this:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec qs r = is} \\<noteq>\n     {} \\<Longrightarrow>\n  iis\n  \\<in> consistent_sign_vec qs ` set (sorted_list_of_set {r. poly p r = 0})\n\ngoal (1 subgoal):\n 1. iis \\<notin> set signs \\<or>\n    iis\n    \\<in> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<or>\n    \\<not> 0 < rat_of_int\n                (int (card\n                       {r. poly p r = 0 \\<and>\n                           consistent_sign_vec qs r = iis}))", "by (metis (no_types) \\<open>\\<forall>sgn. sgn \\<in> set signs \\<and> sgn \\<notin> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<and> 0 < rat_of_int (int (card {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn})) \\<longrightarrow> {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq> {}\\<close> characterize_root_list_p_def)"], ["proof (state)\nthis:\n  iis \\<notin> set signs \\<or>\n  iis \\<in> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<or>\n  \\<not> 0 < rat_of_int\n              (int (card\n                     {r. poly p r = 0 \\<and>\n                         consistent_sign_vec qs r = iis}))\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "}"], ["proof (state)\nthis:\n  ?iis2 \\<notin> set signs \\<or>\n  ?iis2\n  \\<in> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<or>\n  \\<not> 0 < rat_of_int\n              (int (card\n                     {r. poly p r = 0 \\<and>\n                         consistent_sign_vec qs r = ?iis2}))\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec qs xa = sgn})) \\<longrightarrow>\n       {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "then"], ["proof (chain)\npicking this:\n  ?iis2 \\<notin> set signs \\<or>\n  ?iis2\n  \\<in> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<or>\n  \\<not> 0 < rat_of_int\n              (int (card\n                     {r. poly p r = 0 \\<and>\n                         consistent_sign_vec qs r = ?iis2}))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?iis2 \\<notin> set signs \\<or>\n  ?iis2\n  \\<in> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<or>\n  \\<not> 0 < rat_of_int\n              (int (card\n                     {r. poly p r = 0 \\<and>\n                         consistent_sign_vec qs r = ?iis2}))\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n       z_R I sgn = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_nat\n          (card\n            {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n     z_R I sgn = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_nat\n          (card\n            {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n     z_R I sgn = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_nat\n          (card\n            {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n     z_R I sgn = 0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_nat\n          (card\n            {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n     z_R I sgn = 0", "have \"\\<forall> sgn. sgn \\<in> set signs \\<and> sgn \\<notin> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<longrightarrow> ((0 = rat_of_nat (card\n                  {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn}) \\<or> z_R I sgn = 0))\""], ["proof (prove)\nusing this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_nat\n          (card\n            {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec qs xa = sgn}) \\<longrightarrow>\n     z_R I sgn = 0\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<longrightarrow>\n       0 =\n       rat_of_nat\n        (card\n          {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn}) \\<or>\n       z_R I sgn = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<longrightarrow>\n     0 =\n     rat_of_nat\n      (card\n        {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn}) \\<or>\n     z_R I sgn = 0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<longrightarrow>\n     0 =\n     rat_of_nat\n      (card\n        {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn}) \\<or>\n     z_R I sgn = 0", "have hyp: \"\\<forall> s. s \\<in> set signs \\<and> s \\<notin> consistent_sign_vec qs ` set (characterize_root_list_p p) \\<longrightarrow> (z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) = 0)\""], ["proof (prove)\nusing this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec qs `\n              set (characterize_root_list_p p) \\<longrightarrow>\n     0 =\n     rat_of_nat\n      (card\n        {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = sgn}) \\<or>\n     z_R I sgn = 0\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n       0", "by auto"], ["proof (state)\nthis:\n  \\<forall>s.\n     s \\<in> set signs \\<and>\n     s \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<longrightarrow>\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n     0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>s.\n     s \\<in> set signs \\<and>\n     s \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<longrightarrow>\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n     0", "have \"(\\<Sum>s\\<in> set(signs). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) = \n        (\\<Sum>s\\<in>(set (signs) \\<inter> (consistent_sign_vec qs ` set (characterize_root_list_p p))). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\nusing this:\n  \\<forall>s.\n     s \\<in> set signs \\<and>\n     s \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<longrightarrow>\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n     0\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n       0 \\<Longrightarrow>\n    (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "have \"set(signs) =(set (signs) \\<inter> (consistent_sign_vec qs ` set (characterize_root_list_p p))) \\<union>\n              (set(signs)-(consistent_sign_vec qs ` set (characterize_root_list_p p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set signs =\n    set signs \\<inter>\n    consistent_sign_vec qs ` set (characterize_root_list_p p) \\<union>\n    (set signs - consistent_sign_vec qs ` set (characterize_root_list_p p))", "by blast"], ["proof (state)\nthis:\n  set signs =\n  set signs \\<inter>\n  consistent_sign_vec qs ` set (characterize_root_list_p p) \\<union>\n  (set signs - consistent_sign_vec qs ` set (characterize_root_list_p p))\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n       0 \\<Longrightarrow>\n    (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "then"], ["proof (chain)\npicking this:\n  set signs =\n  set signs \\<inter>\n  consistent_sign_vec qs ` set (characterize_root_list_p p) \\<union>\n  (set signs - consistent_sign_vec qs ` set (characterize_root_list_p p))", "have sum_rewrite: \"(\\<Sum>s\\<in> set(signs). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =  \n          (\\<Sum>s\\<in> (set (signs) \\<inter> (consistent_sign_vec qs ` set (characterize_root_list_p p))) \\<union>\n              (set(signs)-(consistent_sign_vec qs ` set (characterize_root_list_p p))). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\nusing this:\n  set signs =\n  set signs \\<inter>\n  consistent_sign_vec qs ` set (characterize_root_list_p p) \\<union>\n  (set signs - consistent_sign_vec qs ` set (characterize_root_list_p p))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs `\n                 set (characterize_root_list_p p) \\<union>\n                 (set signs -\n                  consistent_sign_vec qs `\n                  set (characterize_root_list_p p)).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec qs ` set (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n       0 \\<Longrightarrow>\n    (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec qs ` set (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "have sum_split: \"(\\<Sum>s\\<in> (set (signs) \\<inter> (consistent_sign_vec qs ` set (characterize_root_list_p p))) \\<union>\n              (set(signs)-(consistent_sign_vec qs ` set (characterize_root_list_p p))). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n          = \n(\\<Sum>s\\<in> (set (signs) \\<inter> (consistent_sign_vec qs ` set (characterize_root_list_p p))). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n+ (\\<Sum>s\\<in> (set(signs)-(consistent_sign_vec qs ` set (characterize_root_list_p p))). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec qs ` set (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs `\n                 set (characterize_root_list_p p) \\<union>\n                 (set signs -\n                  consistent_sign_vec qs `\n                  set (characterize_root_list_p p)).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) +\n    (\\<Sum>s\\<in>set signs -\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "by (metis (no_types, lifting) List.finite_set sum.Int_Diff)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec qs ` set (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) +\n  (\\<Sum>s\\<in>set signs -\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n       0 \\<Longrightarrow>\n    (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "have sum_zero: \"(\\<Sum>s\\<in> (set(signs)-(consistent_sign_vec qs ` set (characterize_root_list_p p))). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs -\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    0", "using hyp"], ["proof (prove)\nusing this:\n  \\<forall>s.\n     s \\<in> set signs \\<and>\n     s \\<notin> consistent_sign_vec qs `\n                set (characterize_root_list_p p) \\<longrightarrow>\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n     0\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs -\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    0", "by (simp add: hyp)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs -\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  0\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n       0 \\<Longrightarrow>\n    (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "using sum_rewrite sum_split sum_zero"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec qs ` set (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec qs ` set (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) +\n  (\\<Sum>s\\<in>set signs -\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  (\\<Sum>s\\<in>set signs -\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "have set_eq: \"set (remdups\n           (map (consistent_sign_vec qs)\n             (characterize_root_list_p p))) = set (signs) \\<inter> (consistent_sign_vec qs ` set (characterize_root_list_p p))\""], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. set (remdups\n          (map (consistent_sign_vec qs) (characterize_root_list_p p))) =\n    set signs \\<inter>\n    consistent_sign_vec qs ` set (characterize_root_list_p p)", "using all_info"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n\ngoal (1 subgoal):\n 1. set (remdups\n          (map (consistent_sign_vec qs) (characterize_root_list_p p))) =\n    set signs \\<inter>\n    consistent_sign_vec qs ` set (characterize_root_list_p p)", "apply (simp add: characterize_consistent_signs_at_roots_def subset_antisym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>s\\<in>set signs.\n                z_R I s *\n                rat_of_nat\n                 (card\n                   {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n             (\\<Sum>s\\<in>set signs \\<inter>\n                          consistent_sign_vec qs `\n                          set (characterize_root_list_p p).\n                z_R I s *\n                rat_of_nat\n                 (card\n                   {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}));\n     signs_at qs ` set (characterize_root_list_p p)\n     \\<subseteq> set signs\\<rbrakk>\n    \\<Longrightarrow> consistent_sign_vec qs `\n                      set (characterize_root_list_p p) =\n                      set signs \\<inter>\n                      consistent_sign_vec qs `\n                      set (characterize_root_list_p p)", "by (smt (z3) Int_subset_iff consistent_sign_vec_def list.set_map map_eq_conv o_apply signs_at_def squash_def subsetI subset_antisym)"], ["proof (state)\nthis:\n  set (remdups\n        (map (consistent_sign_vec qs) (characterize_root_list_p p))) =\n  set signs \\<inter>\n  consistent_sign_vec qs ` set (characterize_root_list_p p)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "have hyp1: \"(\\<Sum>s\\<leftarrow>signs. z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) = \n        (\\<Sum>s\\<in>set (signs). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "using distinct_signs sum_list_distinct_conv_sum_set"], ["proof (prove)\nusing this:\n  distinct signs\n  distinct ?xs \\<Longrightarrow> sum_list (map ?f ?xs) = sum ?f (set ?xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set signs.\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "have hyp2: \"(\\<Sum>s\\<leftarrow>remdups\n           (map (consistent_sign_vec qs)\n             (characterize_root_list_p p)). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  = (\\<Sum>s\\<in> set (remdups\n           (map (consistent_sign_vec qs)\n             (characterize_root_list_p p))). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec qs)\n                           (characterize_root_list_p\n                             p)). z_R I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set (remdups\n                       (map (consistent_sign_vec qs)\n                         (characterize_root_list_p p))).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "using sum_list_distinct_conv_sum_set"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow> sum_list (map ?f ?xs) = sum ?f (set ?xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec qs)\n                           (characterize_root_list_p\n                             p)). z_R I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set (remdups\n                       (map (consistent_sign_vec qs)\n                         (characterize_root_list_p p))).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec qs)\n                         (characterize_root_list_p\n                           p)). z_R I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p))).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "have set_sum_eq: \"(\\<Sum>s\\<in>(set (signs) \\<inter> (consistent_sign_vec qs ` set (characterize_root_list_p p))). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in> set (remdups\n           (map (consistent_sign_vec qs)\n             (characterize_root_list_p p))). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set (remdups\n                       (map (consistent_sign_vec qs)\n                         (characterize_root_list_p p))).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "using set_eq"], ["proof (prove)\nusing this:\n  set (remdups\n        (map (consistent_sign_vec qs) (characterize_root_list_p p))) =\n  set signs \\<inter>\n  consistent_sign_vec qs ` set (characterize_root_list_p p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>set (remdups\n                       (map (consistent_sign_vec qs)\n                         (characterize_root_list_p p))).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p))).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p))).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "have \"(\\<Sum>s\\<leftarrow>signs. z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n           (map (consistent_sign_vec qs)\n             (characterize_root_list_p p)). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p))).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec qs)\n                           (characterize_root_list_p\n                             p)). z_R I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "using set_sum_eq hyp1 hyp2"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p))).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p))).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec qs)\n                         (characterize_root_list_p\n                           p)). z_R I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p))).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec qs)\n                           (characterize_root_list_p\n                             p)). z_R I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "using \\<open>(\\<Sum>s\\<in>set signs. z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) = (\\<Sum>s\\<in>set signs \\<inter> consistent_sign_vec qs ` set (characterize_root_list_p p). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p))).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p))).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec qs)\n                         (characterize_root_list_p\n                           p)). z_R I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p))).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  (\\<Sum>s\\<in>set signs.\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec qs ` set (characterize_root_list_p p).\n     z_R I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec qs)\n                           (characterize_root_list_p\n                             p)). z_R I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec qs)\n                         (characterize_root_list_p\n                           p)). z_R I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec qs)\n                         (characterize_root_list_p\n                           p)). z_R I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s}))", "have \"consistent_sign_vec qs ` set (characterize_root_list_p p) \\<subseteq> set signs \\<Longrightarrow>\n    (\\<And>p qss.\n        characterize_consistent_signs_at_roots p qss =\n        remdups (map (consistent_sign_vec qss) (characterize_root_list_p p))) \\<Longrightarrow>\n    (\\<Sum>s\\<leftarrow>signs. z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n           (map (consistent_sign_vec qs)\n             (characterize_root_list_p p)). z_R I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec qs x = s})) =\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec qs)\n                         (characterize_root_list_p\n                           p)). z_R I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent_sign_vec qs ` set (characterize_root_list_p p)\n             \\<subseteq> set signs;\n     \\<And>p qss.\n        characterize_consistent_signs_at_roots p qss =\n        remdups\n         (map (consistent_sign_vec qss)\n           (characterize_root_list_p p))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z_R I s *\n           rat_of_nat\n            (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n                      (\\<Sum>s\\<leftarrow>remdups\n     (map (consistent_sign_vec qs)\n       (characterize_root_list_p\n         p)). z_R I s *\n              rat_of_nat\n               (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>consistent_sign_vec qs ` set (characterize_root_list_p p)\n           \\<subseteq> set signs;\n   \\<And>p qss.\n      characterize_consistent_signs_at_roots p qss =\n      remdups\n       (map (consistent_sign_vec qss) (characterize_root_list_p p))\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z_R I s *\n         rat_of_nat\n          (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n                    (\\<Sum>s\\<leftarrow>remdups\n   (map (consistent_sign_vec qs)\n     (characterize_root_list_p\n       p)). z_R I s *\n            rat_of_nat\n             (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>consistent_sign_vec qs ` set (characterize_root_list_p p)\n           \\<subseteq> set signs;\n   \\<And>p qss.\n      characterize_consistent_signs_at_roots p qss =\n      remdups\n       (map (consistent_sign_vec qss) (characterize_root_list_p p))\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z_R I s *\n         rat_of_nat\n          (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n                    (\\<Sum>s\\<leftarrow>remdups\n   (map (consistent_sign_vec qs)\n     (characterize_root_list_p\n       p)). z_R I s *\n            rat_of_nat\n             (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>consistent_sign_vec qs ` set (characterize_root_list_p p)\n           \\<subseteq> set signs;\n   \\<And>p qss.\n      characterize_consistent_signs_at_roots p qss =\n      remdups\n       (map (consistent_sign_vec qss) (characterize_root_list_p p))\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z_R I s *\n         rat_of_nat\n          (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n                    (\\<Sum>s\\<leftarrow>remdups\n   (map (consistent_sign_vec qs)\n     (characterize_root_list_p\n       p)). z_R I s *\n            rat_of_nat\n             (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "unfolding lhs_dot_rewrite[OF nonzero]"], ["proof (prove)\nusing this:\n  \\<lbrakk>consistent_sign_vec qs ` set (characterize_root_list_p p)\n           \\<subseteq> set signs;\n   \\<And>p qss.\n      characterize_consistent_signs_at_roots p qss =\n      remdups\n       (map (consistent_sign_vec qss) (characterize_root_list_p p))\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z_R I s *\n         rat_of_nat\n          (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n                    (\\<Sum>s\\<leftarrow>remdups\n   (map (consistent_sign_vec qs)\n     (characterize_root_list_p\n       p)). z_R I s *\n            rat_of_nat\n             (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                         qs. z_R I s *\n                             rat_of_int\n                              (int (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "apply (auto intro!: sum_list_distinct_filter simp add: distinct_signs  consistent_sign_vec_def characterize_consistent_signs_at_roots_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>(\\<lambda>x.\n                  map (\\<lambda>q.\n                          if 0 < poly q x then 1\n                          else if poly q x = 0 then 0 else - 1)\n                   qs) `\n              set (characterize_root_list_p p)\n              \\<subseteq> set signs;\n      \\<And>p qss.\n         remdups (map (signs_at qss) (characterize_root_list_p p)) =\n         remdups\n          (map (consistent_sign_vec qss)\n            (characterize_root_list_p p))\\<rbrakk>\n     \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z_R I s *\n            rat_of_nat\n             (card\n               {x. poly p x = 0 \\<and>\n                   map (\\<lambda>q.\n                           if 0 < poly q x then 1\n                           else if poly q x = 0 then 0 else - 1)\n                    qs =\n                   s})) =\n                       (\\<Sum>s\\<leftarrow>remdups\n      (map (consistent_sign_vec qs)\n        (characterize_root_list_p\n          p)). z_R I s *\n               rat_of_nat\n                (card\n                  {x. poly p x = 0 \\<and>\n                      map (\\<lambda>q.\n                              if 0 < poly q x then 1\n                              else if poly q x = 0 then 0 else - 1)\n                       qs =\n                      s}))) \\<Longrightarrow>\n    (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nmap (\\<lambda>q.\n        if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n qs =\ns})) =\n    (\\<Sum>s\\<leftarrow>remdups\n                         (map (signs_at qs)\n                           (characterize_root_list_p\n                             p)). z_R I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and>\nmap (\\<lambda>q.\n        if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n qs =\ns}))", "using all_info consistent_sign_vec_def characterize_consistent_signs_at_roots_def"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  consistent_sign_vec ?qs ?x \\<equiv>\n  map (\\<lambda>q.\n          if 0 < poly q ?x then 1 else if poly q ?x = 0 then 0 else - 1)\n   ?qs\n  characterize_consistent_signs_at_roots ?p ?qs =\n  remdups (map (signs_at ?qs) (characterize_root_list_p ?p))\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>(\\<lambda>x.\n                  map (\\<lambda>q.\n                          if 0 < poly q x then 1\n                          else if poly q x = 0 then 0 else - 1)\n                   qs) `\n              set (characterize_root_list_p p)\n              \\<subseteq> set signs;\n      \\<And>p qss.\n         remdups (map (signs_at qss) (characterize_root_list_p p)) =\n         remdups\n          (map (consistent_sign_vec qss)\n            (characterize_root_list_p p))\\<rbrakk>\n     \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z_R I s *\n            rat_of_nat\n             (card\n               {x. poly p x = 0 \\<and>\n                   map (\\<lambda>q.\n                           if 0 < poly q x then 1\n                           else if poly q x = 0 then 0 else - 1)\n                    qs =\n                   s})) =\n                       (\\<Sum>s\\<leftarrow>remdups\n      (map (consistent_sign_vec qs)\n        (characterize_root_list_p\n          p)). z_R I s *\n               rat_of_nat\n                (card\n                  {x. poly p x = 0 \\<and>\n                      map (\\<lambda>q.\n                              if 0 < poly q x then 1\n                              else if poly q x = 0 then 0 else - 1)\n                       qs =\n                      s}))) \\<Longrightarrow>\n    (\\<Sum>s\\<leftarrow>signs. z_R I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nmap (\\<lambda>q.\n        if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n qs =\ns})) =\n    (\\<Sum>s\\<leftarrow>remdups\n                         (map (signs_at qs)\n                           (characterize_root_list_p\n                             p)). z_R I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and>\nmap (\\<lambda>q.\n        if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n qs =\ns}))", "by (smt (z3) list.set_map map_eq_conv o_apply set_remdups signs_at_def squash_def)"], ["proof (state)\nthis:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_equation_helper_step_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows \"(vec_of_list (mtx_row_R signs I) \\<bullet> (construct_lhs_vector_R p qs signs)) =\n   rat_of_int (card {x. poly p x = 0 \\<and> (\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> poly (prod_list (retrieve_polys qs (snd I))) x > 0}) -\n   rat_of_int (card {x. poly p x = 0 \\<and> (\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> poly (prod_list (retrieve_polys qs (snd I))) x < 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have finset: \"finite (set (map (consistent_sign_vec qs)  (characterize_root_list_p p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (map (consistent_sign_vec qs) (characterize_root_list_p p)))", "by auto"], ["proof (state)\nthis:\n  finite (set (map (consistent_sign_vec qs) (characterize_root_list_p p)))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "let ?gt = \"(set (map (consistent_sign_vec qs)  (characterize_root_list_p p)) \\<inter> {s. z_R I s = 1})\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "let ?lt = \"  (set (map (consistent_sign_vec qs)  (characterize_root_list_p p)) \\<inter> {s. z_R I s = -1})\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "let ?zer = \"(set (map (consistent_sign_vec qs)  (characterize_root_list_p p)) \\<inter> {s. z_R I s = 0})\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have eq: \"set (map (consistent_sign_vec qs)  (characterize_root_list_p p)) = (?gt \\<union> ?lt) \\<union> ?zer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (consistent_sign_vec qs) (characterize_root_list_p p)) =\n    set (map (consistent_sign_vec qs) (characterize_root_list_p p)) \\<inter>\n    {s. z_R I s = 1} \\<union>\n    set (map (consistent_sign_vec qs) (characterize_root_list_p p)) \\<inter>\n    {s. z_R I s = - 1} \\<union>\n    set (map (consistent_sign_vec qs) (characterize_root_list_p p)) \\<inter>\n    {s. z_R I s = 0}", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (map (consistent_sign_vec qs)\n                              (characterize_root_list_p p));\n        z_R I x \\<noteq> 0; z_R I x \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> z_R I x = 1", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (map (consistent_sign_vec qs)\n                              (characterize_root_list_p p));\n        z_R I x \\<noteq> 0; z_R I x \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> z_R I x = 1", "assume h:\"x \\<in> set (map (consistent_sign_vec qs) (characterize_root_list_p p))\"\n        \"z_R I x \\<noteq> 0\" \"z_R I x \\<noteq> - 1\""], ["proof (state)\nthis:\n  x \\<in> set (map (consistent_sign_vec qs) (characterize_root_list_p p))\n  z_R I x \\<noteq> 0\n  z_R I x \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (map (consistent_sign_vec qs)\n                              (characterize_root_list_p p));\n        z_R I x \\<noteq> 0; z_R I x \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> z_R I x = 1", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (map (consistent_sign_vec qs) (characterize_root_list_p p))\n  z_R I x \\<noteq> 0\n  z_R I x \\<noteq> - 1", "have \"x \\<in> set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\nusing this:\n  x \\<in> set (map (consistent_sign_vec qs) (characterize_root_list_p p))\n  z_R I x \\<noteq> 0\n  z_R I x \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. x \\<in> set (characterize_consistent_signs_at_roots p qs)", "unfolding characterize_consistent_signs_at_roots_def"], ["proof (prove)\nusing this:\n  x \\<in> set (map (consistent_sign_vec qs) (characterize_root_list_p p))\n  z_R I x \\<noteq> 0\n  z_R I x \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. x \\<in> set (remdups (map (signs_at qs) (characterize_root_list_p p)))", "by (smt (verit, del_insts) characterize_consistent_signs_at_roots_def characterize_root_list_p_def imageE in_set_R nonzero poly_roots_finite set_map sorted_list_of_set(1))"], ["proof (state)\nthis:\n  x \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (map (consistent_sign_vec qs)\n                              (characterize_root_list_p p));\n        z_R I x \\<noteq> 0; z_R I x \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> z_R I x = 1", "thus \"z_R I x = 1\""], ["proof (prove)\nusing this:\n  x \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. z_R I x = 1", "using h welldefined1 welldefined2 z_lemma_R"], ["proof (prove)\nusing this:\n  x \\<in> set (characterize_consistent_signs_at_roots p qs)\n  x \\<in> set (map (consistent_sign_vec qs) (characterize_root_list_p p))\n  z_R I x \\<noteq> 0\n  z_R I x \\<noteq> - 1\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n  \\<lbrakk>?sign \\<in> set (characterize_consistent_signs_at_roots ?p ?qs);\n   list_constr (fst ?I) (length ?qs);\n   list_constr (snd ?I) (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> z_R ?I ?sign = 1 \\<or>\n                    z_R ?I ?sign = 0 \\<or> z_R ?I ?sign = - 1\n\ngoal (1 subgoal):\n 1. z_R I x = 1", "by blast"], ["proof (state)\nthis:\n  z_R I x = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (map (consistent_sign_vec qs) (characterize_root_list_p p)) =\n  set (map (consistent_sign_vec qs) (characterize_root_list_p p)) \\<inter>\n  {s. z_R I s = 1} \\<union>\n  set (map (consistent_sign_vec qs) (characterize_root_list_p p)) \\<inter>\n  {s. z_R I s = - 1} \\<union>\n  set (map (consistent_sign_vec qs) (characterize_root_list_p p)) \\<inter>\n  {s. z_R I s = 0}\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have sumeq: \"(\\<Sum>s\\<in>(?gt\\<union>?lt). z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\n  = (\\<Sum>s\\<in>?gt. z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) +\n  (\\<Sum>s\\<in>?lt. z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 1} \\<union>\n                 set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = - 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = - 1}.\n       z_R I s *\n       rat_of_int\n        (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "apply (rule sum.union_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     (set (map (consistent_sign_vec qs)\n            (characterize_root_list_p p)) \\<inter>\n      {s. z_R I s = 1})\n 2. finite\n     (set (map (consistent_sign_vec qs)\n            (characterize_root_list_p p)) \\<inter>\n      {s. z_R I s = - 1})\n 3. set (map (consistent_sign_vec qs) (characterize_root_list_p p)) \\<inter>\n    {s. z_R I s = 1} \\<inter>\n    (set (map (consistent_sign_vec qs)\n           (characterize_root_list_p p)) \\<inter>\n     {s. z_R I s = - 1}) =\n    {}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "(* First, drop the signs that are irrelevant *)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "from construct_lhs_vector_drop_consistent_R[OF assms(1-5)]"], ["proof (chain)\npicking this:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs)", "have\n    \"vec_of_list (mtx_row_R signs I) \\<bullet> construct_lhs_vector_R p qs signs =\n  vec_of_list (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs)", "."], ["proof (state)\nthis:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "(* Now we split the sum *)"], ["proof (state)\nthis:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "from lhs_dot_rewrite[OF assms(1)]"], ["proof (chain)\npicking this:\n  vec_of_list (mtx_row_R ?signs ?I) \\<bullet>\n  construct_lhs_vector_R p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z_R ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec ?qs x = s})))", "moreover"], ["proof (chain)\npicking this:\n  vec_of_list (mtx_row_R ?signs ?I) \\<bullet>\n  construct_lhs_vector_R p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z_R ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec ?qs x = s})))", "have \"... =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p qs.\n    z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row_R ?signs ?I) \\<bullet>\n  construct_lhs_vector_R p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z_R ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec ?qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n    construct_lhs_vector_R p qs\n     (characterize_consistent_signs_at_roots p qs) =\n    (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                         qs. z_R I s *\n                             rat_of_int\n                              (int (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "."], ["proof (state)\nthis:\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs\n   (characterize_consistent_signs_at_roots p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "moreover"], ["proof (state)\nthis:\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs\n   (characterize_consistent_signs_at_roots p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have \"... =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)  (characterize_root_list_p p)).\n    z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                         qs. z_R I s *\n                             rat_of_int\n                              (int (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)).\n       z_R I s *\n       rat_of_int\n        (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "unfolding characterize_consistent_signs_at_roots_def sum_code[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (signs_at qs) (characterize_root_list_p p)).\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)).\n       z_R I s *\n       rat_of_int\n        (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>signs_at qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    (\\<Sum>s\\<in>consistent_sign_vec qs ` set (characterize_root_list_p p).\n       z_R I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))", "by (smt (verit, best) consistent_sign_vec_def list.set_map map_eq_conv o_apply signs_at_def squash_def sum.set_conv_list)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have setc1:\"... = \n  (\\<Sum>s\\<in>(?gt\\<union>?lt). z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) +\n    (\\<Sum>s\\<in>?zer. z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)).\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 1} \\<union>\n                 set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = - 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n       z_R I s *\n       rat_of_int\n        (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "apply (subst eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 1} \\<union>\n                 set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = - 1} \\<union>\n                 set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 1} \\<union>\n                 set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = - 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n       z_R I s *\n       rat_of_int\n        (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "apply (rule  sum.union_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     (set (map (consistent_sign_vec qs)\n            (characterize_root_list_p p)) \\<inter>\n      {s. z_R I s = 1} \\<union>\n      set (map (consistent_sign_vec qs)\n            (characterize_root_list_p p)) \\<inter>\n      {s. z_R I s = - 1})\n 2. finite\n     (set (map (consistent_sign_vec qs)\n            (characterize_root_list_p p)) \\<inter>\n      {s. z_R I s = 0})\n 3. (set (map (consistent_sign_vec qs)\n           (characterize_root_list_p p)) \\<inter>\n     {s. z_R I s = 1} \\<union>\n     set (map (consistent_sign_vec qs)\n           (characterize_root_list_p p)) \\<inter>\n     {s. z_R I s = - 1}) \\<inter>\n    (set (map (consistent_sign_vec qs)\n           (characterize_root_list_p p)) \\<inter>\n     {s. z_R I s = 0}) =\n    {}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "ultimately"], ["proof (chain)\npicking this:\n  vec_of_list (mtx_row_R ?signs ?I) \\<bullet>\n  construct_lhs_vector_R p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z_R ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec ?qs x = s})))\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs\n   (characterize_consistent_signs_at_roots p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s})))\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "have setc: \"... =\n  (\\<Sum>s\\<in>?gt. z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) +\n  (\\<Sum>s\\<in>?lt. z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) +\n  (\\<Sum>s\\<in>?zer. z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))\""], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row_R ?signs ?I) \\<bullet>\n  construct_lhs_vector_R p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z_R ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec ?qs x = s})))\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs\n   (characterize_consistent_signs_at_roots p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s})))\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 1} \\<union>\n                 set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = - 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = - 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n       z_R I s *\n       rat_of_int\n        (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "using sumeq"], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row_R ?signs ?I) \\<bullet>\n  construct_lhs_vector_R p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z_R ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec ?qs x = s})))\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs\n   (characterize_consistent_signs_at_roots p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s})))\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 1} \\<union>\n                 set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = - 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = - 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n       z_R I s *\n       rat_of_int\n        (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have \"\\<forall>s \\<in> ?zer. (z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>set (map (consistent_sign_vec qs)\n                         (characterize_root_list_p p)) \\<inter>\n                   {s. z_R I s = 0}.\n       z_R I s *\n       rat_of_int\n        (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n       0", "by auto"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n     0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "then"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n     0", "have obvzer: \"(\\<Sum>s\\<in>?zer. z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n     0\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 0}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "(* Now recharacterize lt, gt*)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have setroots: \"set (characterize_root_list_p p) = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_root_list_p p) = {x. poly p x = 0}", "unfolding characterize_root_list_p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sorted_list_of_set {x. poly p x = 0}) = {x. poly p x = 0}", "using poly_roots_finite nonzero rsquarefree_def set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n  p \\<noteq> 0\n  rsquarefree ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>a. Polynomial.order a ?p = 0 \\<or> Polynomial.order a ?p = 1))\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n\ngoal (1 subgoal):\n 1. set (sorted_list_of_set {x. poly p x = 0}) = {x. poly p x = 0}", "by blast"], ["proof (state)\nthis:\n  set (characterize_root_list_p p) = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have *: \"\\<And>s. {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s} =\n        {x \\<in>{x. poly p x = 0}. consistent_sign_vec qs x = s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s} =\n       {x \\<in> {x. poly p x = 0}. consistent_sign_vec qs x = s}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0 \\<and> consistent_sign_vec qs x = ?s} =\n  {x \\<in> {x. poly p x = 0}. consistent_sign_vec qs x = ?s}\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have e1: \"(\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter> {s. z_R I s = 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n     (sum (\\<lambda>x. if (\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x) > 0 then 1 else 0) {x. poly p x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n    (\\<Sum>x | poly p x = 0.\n       if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n              poly p x = 0) \\<and>\n          0 < poly (prod_list (retrieve_polys qs (snd I))) x\n       then 1 else 0)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n       card {x \\<in> {x. poly p x = 0}. consistent_sign_vec qs x = s}) =\n    (\\<Sum>x | poly p x = 0.\n       if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n              poly p x = 0) \\<and>\n          0 < poly (prod_list (retrieve_polys qs (snd I))) x\n       then 1 else 0)", "apply (rule sum_multicount_gen)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     (consistent_sign_vec qs ` {x. poly p x = 0} \\<inter> {s. z_R I s = 1})\n 2. finite {x. poly p x = 0}\n 3. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "using \\<open>finite (set (map (consistent_sign_vec qs) (characterize_root_list_p p)))\\<close> setroots"], ["proof (prove)\nusing this:\n  finite (set (map (consistent_sign_vec qs) (characterize_root_list_p p)))\n  set (characterize_root_list_p p) = {x. poly p x = 0}\n\ngoal (3 subgoals):\n 1. finite\n     (consistent_sign_vec qs ` {x. poly p x = 0} \\<inter> {s. z_R I s = 1})\n 2. finite {x. poly p x = 0}\n 3. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {x. poly p x = 0}\n 2. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "apply (metis List.finite_set setroots)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "assume rt: \"poly p x = 0\""], ["proof (state)\nthis:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  poly p x = 0", "have 1: \"{s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter> {s. z_R I s = 1}. consistent_sign_vec qs x = s} =\n      {s. z_R I s = 1 \\<and> consistent_sign_vec qs x = s}\""], ["proof (prove)\nusing this:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n             {s. z_R I s = 1}.\n     consistent_sign_vec qs x = s} =\n    {s. z_R I s = 1 \\<and> consistent_sign_vec qs x = s}", "by auto"], ["proof (state)\nthis:\n  {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n           {s. z_R I s = 1}.\n   consistent_sign_vec qs x = s} =\n  {s. z_R I s = 1 \\<and> consistent_sign_vec qs x = s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "have 2: \"... = {s. (\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (0 < poly (prod_list (retrieve_polys qs (snd I))) x)  \\<and> consistent_sign_vec qs x = s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. z_R I s = 1 \\<and> consistent_sign_vec qs x = s} =\n    {s. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<and>\n        consistent_sign_vec qs x = s}", "using horiz_vector_helper_pos_R assms welldefined1 welldefined2 rt"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec ?qs ?x; list_constr (fst ?I) (length ?qs);\n   list_constr (snd ?I) (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<forall>p\\<in>set (retrieve_polys ?qs (fst ?I)).\n                         poly p ?x = 0) \\<and>\n                     0 < poly (prod_list (retrieve_polys ?qs (snd ?I)))\n                          ?x) =\n                    (z_R ?I ?sign = 1)\n  p \\<noteq> 0\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. {s. z_R I s = 1 \\<and> consistent_sign_vec qs x = s} =\n    {s. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<and>\n        consistent_sign_vec qs x = s}", "by blast"], ["proof (state)\nthis:\n  {s. z_R I s = 1 \\<and> consistent_sign_vec qs x = s} =\n  {s. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<and>\n      consistent_sign_vec qs x = s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "have 3: \"... = (if (\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (0 < poly (prod_list (retrieve_polys qs (snd I))) x)  then {consistent_sign_vec qs x} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<and>\n        consistent_sign_vec qs x = s} =\n    (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        0 < poly (prod_list (retrieve_polys qs (snd I))) x\n     then {consistent_sign_vec qs x} else {})", "by auto"], ["proof (state)\nthis:\n  {s. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<and>\n      consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x\n   then {consistent_sign_vec qs x} else {})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  {s. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<and>\n      consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x\n   then {consistent_sign_vec qs x} else {})", "have \"card {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter> {s. z_R I s = 1}. consistent_sign_vec qs x = s} =\n         (if ((\\<forall>p \\<in> set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> 0 < poly (prod_list  (retrieve_polys qs (snd I))) x)\n          then 1 else 0)\""], ["proof (prove)\nusing this:\n  {s. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<and>\n      consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x\n   then {consistent_sign_vec qs x} else {})\n\ngoal (1 subgoal):\n 1. card\n     {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n              {s. z_R I s = 1}.\n      consistent_sign_vec qs x = s} =\n    (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        0 < poly (prod_list (retrieve_polys qs (snd I))) x\n     then 1 else 0)", "using 1 2 3"], ["proof (prove)\nusing this:\n  {s. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<and>\n      consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x\n   then {consistent_sign_vec qs x} else {})\n  {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n           {s. z_R I s = 1}.\n   consistent_sign_vec qs x = s} =\n  {s. z_R I s = 1 \\<and> consistent_sign_vec qs x = s}\n  {s. z_R I s = 1 \\<and> consistent_sign_vec qs x = s} =\n  {s. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<and>\n      consistent_sign_vec qs x = s}\n  {s. (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x \\<and>\n      consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x\n   then {consistent_sign_vec qs x} else {})\n\ngoal (1 subgoal):\n 1. card\n     {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n              {s. z_R I s = 1}.\n      consistent_sign_vec qs x = s} =\n    (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        0 < poly (prod_list (retrieve_polys qs (snd I))) x\n     then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  card\n   {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n            {s. z_R I s = 1}.\n    consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x\n   then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0)", "thus \" card\n          {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter> {s. z_R I s = 1}.\n           consistent_sign_vec qs x = s} =\n         (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n             0 < poly (prod_list (retrieve_polys qs (snd I))) x\n          then 1 else 0)\""], ["proof (prove)\nusing this:\n  card\n   {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n            {s. z_R I s = 1}.\n    consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x\n   then 1 else 0)\n\ngoal (1 subgoal):\n 1. card\n     {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n              {s. z_R I s = 1}.\n      consistent_sign_vec qs x = s} =\n    (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        0 < poly (prod_list (retrieve_polys qs (snd I))) x\n     then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  card\n   {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n            {s. z_R I s = 1}.\n    consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      0 < poly (prod_list (retrieve_polys qs (snd I))) x\n   then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n               {s. z_R I s = 1}.\n     card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n  (\\<Sum>x | poly p x = 0.\n     if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        0 < poly (prod_list (retrieve_polys qs (snd I))) x\n     then 1 else 0)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have gtchr: \"(\\<Sum>s\\<in>?gt. z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    rat_of_int (card {x. poly p x = 0 \\<and> (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> 0 < poly (prod_list (retrieve_polys qs (snd I))) x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x}))", "apply (auto simp add: setroots)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    rat_of_nat\n     (card\n       {x. poly p x = 0 \\<and>\n           (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x})", "apply (subst of_nat_sum[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat\n     (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                  {s. z_R I s = 1}.\n        card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n    rat_of_nat\n     (card\n       {x. poly p x = 0 \\<and>\n           (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x})", "apply (subst of_nat_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n    card\n     {x. poly p x = 0 \\<and>\n         (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n             poly p x = 0) \\<and>\n         0 < poly (prod_list (retrieve_polys qs (snd I))) x}", "apply (subst e1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0.\n       if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n              poly p x = 0) \\<and>\n          0 < poly (prod_list (retrieve_polys qs (snd I))) x\n       then 1 else 0) =\n    card\n     {x. poly p x = 0 \\<and>\n         (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n             poly p x = 0) \\<and>\n         0 < poly (prod_list (retrieve_polys qs (snd I))) x}", "apply (subst card_eq_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0.\n       if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n              poly p x = 0) \\<and>\n          0 < poly (prod_list (retrieve_polys qs (snd I))) x\n       then 1 else 0) =\n    (\\<Sum>x | poly p x = 0 \\<and>\n               (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                   poly p x = 0) \\<and>\n               0 < poly (prod_list (retrieve_polys qs (snd I))) x.\n       1)", "apply (rule sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {x. poly p x = 0}\n 2. {x. poly p x = 0 \\<and>\n        (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        0 < poly (prod_list (retrieve_polys qs (snd I))) x}\n    \\<subseteq> {x. poly p x = 0}\n 3. \\<forall>i\\<in>{x. poly p x = 0} -\n                   {x. poly p x = 0 \\<and>\n                       (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                           poly p x = 0) \\<and>\n                       0 < poly (prod_list (retrieve_polys qs (snd I))) x}.\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p i = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) i\n        then 1 else 0) =\n       0\n 4. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and>\n                   (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                       poly p x = 0) \\<and>\n                   0 < poly (prod_list (retrieve_polys qs (snd I)))\n                        x} \\<Longrightarrow>\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0) =\n       1", "apply (metis List.finite_set setroots)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {x. poly p x = 0 \\<and>\n        (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        0 < poly (prod_list (retrieve_polys qs (snd I))) x}\n    \\<subseteq> {x. poly p x = 0}\n 2. \\<forall>i\\<in>{x. poly p x = 0} -\n                   {x. poly p x = 0 \\<and>\n                       (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                           poly p x = 0) \\<and>\n                       0 < poly (prod_list (retrieve_polys qs (snd I))) x}.\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p i = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) i\n        then 1 else 0) =\n       0\n 3. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and>\n                   (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                       poly p x = 0) \\<and>\n                   0 < poly (prod_list (retrieve_polys qs (snd I)))\n                        x} \\<Longrightarrow>\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           0 < poly (prod_list (retrieve_polys qs (snd I))) x\n        then 1 else 0) =\n       1", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                  poly p x = 0) \\<and>\n              0 < poly (prod_list (retrieve_polys qs (snd I))) x}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have e2: \" (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter> {s. z_R I s = - 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n     (sum (\\<lambda>x. if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (poly (prod_list (retrieve_polys qs (snd I))) x) < 0 then 1 else 0) {x. poly p x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n    (\\<Sum>x | poly p x = 0.\n       if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n              poly p x = 0) \\<and>\n          poly (prod_list (retrieve_polys qs (snd I))) x < 0\n       then 1 else 0)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n       card {x \\<in> {x. poly p x = 0}. consistent_sign_vec qs x = s}) =\n    (\\<Sum>x | poly p x = 0.\n       if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n              poly p x = 0) \\<and>\n          poly (prod_list (retrieve_polys qs (snd I))) x < 0\n       then 1 else 0)", "apply (rule sum_multicount_gen)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     (consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n      {s. z_R I s = - 1})\n 2. finite {x. poly p x = 0}\n 3. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0)", "using \\<open>finite (set (map (consistent_sign_vec qs) (characterize_root_list_p p)))\\<close> setroots"], ["proof (prove)\nusing this:\n  finite (set (map (consistent_sign_vec qs) (characterize_root_list_p p)))\n  set (characterize_root_list_p p) = {x. poly p x = 0}\n\ngoal (3 subgoals):\n 1. finite\n     (consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n      {s. z_R I s = - 1})\n 2. finite {x. poly p x = 0}\n 3. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0)", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {x. poly p x = 0}\n 2. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0)", "apply (metis List.finite_set setroots)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0)", "assume rt: \"poly p x = 0\""], ["proof (state)\nthis:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  poly p x = 0", "have 1: \"{s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter> {s. z_R I s = -1}. consistent_sign_vec qs x = s} =\n      {s. z_R I s = -1 \\<and> consistent_sign_vec qs x = s}\""], ["proof (prove)\nusing this:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n             {s. z_R I s = - 1}.\n     consistent_sign_vec qs x = s} =\n    {s. z_R I s = - 1 \\<and> consistent_sign_vec qs x = s}", "by auto"], ["proof (state)\nthis:\n  {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n           {s. z_R I s = - 1}.\n   consistent_sign_vec qs x = s} =\n  {s. z_R I s = - 1 \\<and> consistent_sign_vec qs x = s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0)", "have 2: \"... = {s. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> 0 > poly (prod_list (retrieve_polys qs (snd I))) x)  \\<and> consistent_sign_vec qs x = s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. z_R I s = - 1 \\<and> consistent_sign_vec qs x = s} =\n    {s. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n             poly p x = 0) \\<and>\n         poly (prod_list (retrieve_polys qs (snd I))) x < 0) \\<and>\n        consistent_sign_vec qs x = s}", "using horiz_vector_helper_neg_R assms rt welldefined1 welldefined2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec ?qs ?x; list_constr (fst ?I) (length ?qs);\n   list_constr (snd ?I) (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> ((\\<forall>p\\<in>set (retrieve_polys ?qs (fst ?I)).\n                         poly p ?x = 0) \\<and>\n                     poly (prod_list (retrieve_polys ?qs (snd ?I))) ?x\n                     < 0) =\n                    (z_R ?I ?sign = - 1)\n  p \\<noteq> 0\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n  poly p x = 0\n  list_constr (fst I) (length qs)\n  list_constr (snd I) (length qs)\n\ngoal (1 subgoal):\n 1. {s. z_R I s = - 1 \\<and> consistent_sign_vec qs x = s} =\n    {s. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n             poly p x = 0) \\<and>\n         poly (prod_list (retrieve_polys qs (snd I))) x < 0) \\<and>\n        consistent_sign_vec qs x = s}", "by blast"], ["proof (state)\nthis:\n  {s. z_R I s = - 1 \\<and> consistent_sign_vec qs x = s} =\n  {s. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n       poly (prod_list (retrieve_polys qs (snd I))) x < 0) \\<and>\n      consistent_sign_vec qs x = s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0)", "have 3: \"... = (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> (0 > poly (prod_list (retrieve_polys qs (snd I))) x)  then {consistent_sign_vec qs x} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n             poly p x = 0) \\<and>\n         poly (prod_list (retrieve_polys qs (snd I))) x < 0) \\<and>\n        consistent_sign_vec qs x = s} =\n    (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        poly (prod_list (retrieve_polys qs (snd I))) x < 0\n     then {consistent_sign_vec qs x} else {})", "by auto"], ["proof (state)\nthis:\n  {s. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n       poly (prod_list (retrieve_polys qs (snd I))) x < 0) \\<and>\n      consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      poly (prod_list (retrieve_polys qs (snd I))) x < 0\n   then {consistent_sign_vec qs x} else {})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x = 0 \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n         consistent_sign_vec qs x = s} =\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0)", "thus \"card {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter> {s. z_R I s = -1}. consistent_sign_vec qs x = s} =\n         (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> 0 > poly\n                  (prod_list\n                    (retrieve_polys qs (snd I)))\n                  x\n          then 1 else 0)\""], ["proof (prove)\nusing this:\n  {s. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n       poly (prod_list (retrieve_polys qs (snd I))) x < 0) \\<and>\n      consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      poly (prod_list (retrieve_polys qs (snd I))) x < 0\n   then {consistent_sign_vec qs x} else {})\n\ngoal (1 subgoal):\n 1. card\n     {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n              {s. z_R I s = - 1}.\n      consistent_sign_vec qs x = s} =\n    (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        poly (prod_list (retrieve_polys qs (snd I))) x < 0\n     then 1 else 0)", "using 1 2 3"], ["proof (prove)\nusing this:\n  {s. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n       poly (prod_list (retrieve_polys qs (snd I))) x < 0) \\<and>\n      consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      poly (prod_list (retrieve_polys qs (snd I))) x < 0\n   then {consistent_sign_vec qs x} else {})\n  {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n           {s. z_R I s = - 1}.\n   consistent_sign_vec qs x = s} =\n  {s. z_R I s = - 1 \\<and> consistent_sign_vec qs x = s}\n  {s. z_R I s = - 1 \\<and> consistent_sign_vec qs x = s} =\n  {s. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n       poly (prod_list (retrieve_polys qs (snd I))) x < 0) \\<and>\n      consistent_sign_vec qs x = s}\n  {s. ((\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n       poly (prod_list (retrieve_polys qs (snd I))) x < 0) \\<and>\n      consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      poly (prod_list (retrieve_polys qs (snd I))) x < 0\n   then {consistent_sign_vec qs x} else {})\n\ngoal (1 subgoal):\n 1. card\n     {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n              {s. z_R I s = - 1}.\n      consistent_sign_vec qs x = s} =\n    (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        poly (prod_list (retrieve_polys qs (snd I))) x < 0\n     then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  card\n   {s \\<in> consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n            {s. z_R I s = - 1}.\n    consistent_sign_vec qs x = s} =\n  (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and>\n      poly (prod_list (retrieve_polys qs (snd I))) x < 0\n   then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n               {s. z_R I s = - 1}.\n     card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n  (\\<Sum>x | poly p x = 0.\n     if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        poly (prod_list (retrieve_polys qs (snd I))) x < 0\n     then 1 else 0)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "have ltchr: \"(\\<Sum>s\\<in>?lt. z_R I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    - rat_of_int (card {x. poly p x = 0 \\<and> (\\<forall>p\\<in>set (retrieve_polys qs (fst I)). poly p x = 0) \\<and> 0 > poly (prod_list (retrieve_polys qs (snd I))) x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z_R I s = - 1}.\n       z_R I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n    - rat_of_int\n       (int (card\n              {x. poly p x = 0 \\<and>\n                  (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                      poly p x = 0) \\<and>\n                  poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "apply (auto simp add: setroots sum_negf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})) =\n    rat_of_nat\n     (card\n       {x. poly p x = 0 \\<and>\n           (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0})", "apply (subst of_nat_sum[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat\n     (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                  {s. z_R I s = - 1}.\n        card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n    rat_of_nat\n     (card\n       {x. poly p x = 0 \\<and>\n           (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0})", "apply (subst of_nat_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec qs ` {x. poly p x = 0} \\<inter>\n                 {s. z_R I s = - 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) =\n    card\n     {x. poly p x = 0 \\<and>\n         (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n             poly p x = 0) \\<and>\n         poly (prod_list (retrieve_polys qs (snd I))) x < 0}", "apply (subst e2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0.\n       if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n              poly p x = 0) \\<and>\n          poly (prod_list (retrieve_polys qs (snd I))) x < 0\n       then 1 else 0) =\n    card\n     {x. poly p x = 0 \\<and>\n         (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n             poly p x = 0) \\<and>\n         poly (prod_list (retrieve_polys qs (snd I))) x < 0}", "apply (subst card_eq_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0.\n       if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n              poly p x = 0) \\<and>\n          poly (prod_list (retrieve_polys qs (snd I))) x < 0\n       then 1 else 0) =\n    (\\<Sum>x | poly p x = 0 \\<and>\n               (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                   poly p x = 0) \\<and>\n               poly (prod_list (retrieve_polys qs (snd I))) x < 0.\n       1)", "apply (rule sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {x. poly p x = 0}\n 2. {x. poly p x = 0 \\<and>\n        (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        poly (prod_list (retrieve_polys qs (snd I))) x < 0}\n    \\<subseteq> {x. poly p x = 0}\n 3. \\<forall>i\\<in>{x. poly p x = 0} -\n                   {x. poly p x = 0 \\<and>\n                       (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                           poly p x = 0) \\<and>\n                       poly (prod_list (retrieve_polys qs (snd I))) x < 0}.\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p i = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) i < 0\n        then 1 else 0) =\n       0\n 4. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and>\n                   (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                       poly p x = 0) \\<and>\n                   poly (prod_list (retrieve_polys qs (snd I))) x\n                   < 0} \\<Longrightarrow>\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0) =\n       1", "apply (metis List.finite_set setroots)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {x. poly p x = 0 \\<and>\n        (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n            poly p x = 0) \\<and>\n        poly (prod_list (retrieve_polys qs (snd I))) x < 0}\n    \\<subseteq> {x. poly p x = 0}\n 2. \\<forall>i\\<in>{x. poly p x = 0} -\n                   {x. poly p x = 0 \\<and>\n                       (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                           poly p x = 0) \\<and>\n                       poly (prod_list (retrieve_polys qs (snd I))) x < 0}.\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p i = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) i < 0\n        then 1 else 0) =\n       0\n 3. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and>\n                   (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                       poly p x = 0) \\<and>\n                   poly (prod_list (retrieve_polys qs (snd I))) x\n                   < 0} \\<Longrightarrow>\n       (if (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n               poly p x = 0) \\<and>\n           poly (prod_list (retrieve_polys qs (snd I))) x < 0\n        then 1 else 0) =\n       1", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  - rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "using gtchr ltchr obvzer setc"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                  poly p x = 0) \\<and>\n              0 < poly (prod_list (retrieve_polys qs (snd I))) x}))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  - rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  0\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "using \\<open>(\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p qs. z_R I s * rat_of_int (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) = (\\<Sum>s\\<in>set (map (consistent_sign_vec qs) (characterize_root_list_p p)). z_R I s * rat_of_int (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\\<close> \\<open>vec_of_list (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet> construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs) = (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p qs. z_R I s * rat_of_int (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\\<close> \\<open>vec_of_list (mtx_row_R signs I) \\<bullet> construct_lhs_vector_R p qs signs = vec_of_list (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet> construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs)\\<close> setc1"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                  poly p x = 0) \\<and>\n              0 < poly (prod_list (retrieve_polys qs (snd I))) x}))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  - rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  0\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs\n   (characterize_consistent_signs_at_roots p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots p\n                       qs. z_R I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec qs x = s})))\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  vec_of_list\n   (mtx_row_R (characterize_consistent_signs_at_roots p qs) I) \\<bullet>\n  construct_lhs_vector_R p qs (characterize_consistent_signs_at_roots p qs)\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)).\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 1} \\<union>\n               set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = - 1}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z_R I s = 0}.\n     z_R I s *\n     rat_of_int\n      (int (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                    poly p x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "by linarith"], ["proof (state)\nthis:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                  poly p x = 0) \\<and>\n              0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                  poly p x = 0) \\<and>\n              poly (prod_list (retrieve_polys qs (snd I))) x < 0}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_equation_main_step_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list*nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes welldefined1: \"list_constr (fst I) (length qs)\"\n  assumes welldefined2: \"list_constr (snd I) (length qs)\"\n  shows \"(vec_of_list (mtx_row_R signs I) \\<bullet>\n          (construct_lhs_vector_R p qs signs)) =  \n    construct_NofI_R p (retrieve_polys qs (fst I)) (retrieve_polys qs (snd I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    construct_NofI_R p (retrieve_polys qs (fst I))\n     (retrieve_polys qs (snd I))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    construct_NofI_R p (retrieve_polys qs (fst I))\n     (retrieve_polys qs (snd I))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    construct_NofI_R p (retrieve_polys qs (fst I))\n     (retrieve_polys qs (snd I))", "unfolding construct_NofI_prop_R[OF nonzero]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>q\\<in>set (retrieve_polys qs (fst I)).\n                    poly q x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x}) -\n      int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>q\\<in>set (retrieve_polys qs (fst I)).\n                    poly q x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "using matrix_equation_helper_step_R[OF assms]"], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                  poly p x = 0) \\<and>\n              0 < poly (prod_list (retrieve_polys qs (snd I))) x})) -\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              (\\<forall>p\\<in>set (retrieve_polys qs (fst I)).\n                  poly p x = 0) \\<and>\n              poly (prod_list (retrieve_polys qs (snd I))) x < 0}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row_R signs I) \\<bullet>\n    construct_lhs_vector_R p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>q\\<in>set (retrieve_polys qs (fst I)).\n                    poly q x = 0) \\<and>\n                0 < poly (prod_list (retrieve_polys qs (snd I))) x}) -\n      int (card\n            {x. poly p x = 0 \\<and>\n                (\\<forall>q\\<in>set (retrieve_polys qs (fst I)).\n                    poly q x = 0) \\<and>\n                poly (prod_list (retrieve_polys qs (snd I))) x < 0}))", "by linarith"], ["proof (state)\nthis:\n  vec_of_list (mtx_row_R signs I) \\<bullet>\n  construct_lhs_vector_R p qs signs =\n  construct_NofI_R p (retrieve_polys qs (fst I)) (retrieve_polys qs (snd I))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mtx_row_length_R:\n  \"list_all (\\<lambda>r. length r = length signs) (map (mtx_row_R signs) ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>r. length r = length signs)\n     (map (mtx_row_R signs) ls)", "apply (induction ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all (\\<lambda>r. length r = length signs)\n     (map (mtx_row_R signs) [])\n 2. \\<And>a ls.\n       list_all (\\<lambda>r. length r = length signs)\n        (map (mtx_row_R signs) ls) \\<Longrightarrow>\n       list_all (\\<lambda>r. length r = length signs)\n        (map (mtx_row_R signs) (a # ls))", "by (auto simp add: mtx_row_R_def)"], ["", "(* Shows that as long as we have a \"basis\" of sign assignments (see assumptions all_info, welldefined), \n  and some other mild assumptions on our inputs (given in nonzero, distinct_signs), the construction \n  will be satisfied *)"], ["", "theorem matrix_equation_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes subsets:: \"(nat list*nat list) list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes welldefined: \"all_list_constr_R (subsets) (length qs)\"\n  shows \"satisfy_equation_R p qs subsets signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs subsets signs", "unfolding satisfy_equation_R_def matrix_A_R_def\n    construct_lhs_vector_R_def construct_rhs_vector_R_def all_list_constr_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list (length signs)\n     (map (mtx_row_R signs) subsets) *\\<^sub>v\n    vec_of_list\n     (map (\\<lambda>w.\n              rat_of_int\n               (int (length\n                      (filter (\\<lambda>v. v = w)\n                        (map (consistent_sign_vec qs)\n                          (characterize_root_list_p p))))))\n       signs) =\n    vec_of_list\n     (map (\\<lambda>(I1, I2).\n              construct_NofI_R p (retrieve_polys qs I1)\n               (retrieve_polys qs I2))\n       subsets)", "apply (subst mult_mat_vec_of_list)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length\n     (map (\\<lambda>w.\n              rat_of_int\n               (int (length\n                      (filter (\\<lambda>v. v = w)\n                        (map (consistent_sign_vec qs)\n                          (characterize_root_list_p p))))))\n       signs) =\n    length signs\n 2. list_all (\\<lambda>r. length r = length signs)\n     (map (mtx_row_R signs) subsets)\n 3. vec_of_list\n     (map (\\<lambda>r.\n              vec_of_list r \\<bullet>\n              vec_of_list\n               (map (\\<lambda>w.\n                        rat_of_int\n                         (int (length\n                                (filter (\\<lambda>v. v = w)\n                                  (map (consistent_sign_vec qs)\n                                    (characterize_root_list_p p))))))\n                 signs))\n       (map (mtx_row_R signs) subsets)) =\n    vec_of_list\n     (map (\\<lambda>(I1, I2).\n              construct_NofI_R p (retrieve_polys qs I1)\n               (retrieve_polys qs I2))\n       subsets)", "apply (auto simp add: mtx_row_length_R intro!: map_vec_vec_of_list_eq_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set subsets \\<Longrightarrow>\n       vec_of_list (mtx_row_R signs (a, b)) \\<bullet>\n       map_vec\n        (\\<lambda>w.\n            rat_of_nat\n             (length\n               (filter ((\\<lambda>v. v = w) \\<circ> consistent_sign_vec qs)\n                 (characterize_root_list_p p))))\n        (vec_of_list signs) =\n       construct_NofI_R p (retrieve_polys qs a) (retrieve_polys qs b)", "using matrix_equation_main_step_R[OF assms(1-3), unfolded construct_lhs_vector_R_def]"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_constr (fst ?I) (length qs);\n   list_constr (snd ?I) (length qs)\\<rbrakk>\n  \\<Longrightarrow> vec_of_list (mtx_row_R signs ?I) \\<bullet>\n                    vec_of_list\n                     (map (\\<lambda>w.\n                              rat_of_int\n                               (int (length\n(filter (\\<lambda>v. v = w)\n  (map (consistent_sign_vec qs) (characterize_root_list_p p))))))\n                       signs) =\n                    construct_NofI_R p (retrieve_polys qs (fst ?I))\n                     (retrieve_polys qs (snd ?I))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set subsets \\<Longrightarrow>\n       vec_of_list (mtx_row_R signs (a, b)) \\<bullet>\n       map_vec\n        (\\<lambda>w.\n            rat_of_nat\n             (length\n               (filter ((\\<lambda>v. v = w) \\<circ> consistent_sign_vec qs)\n                 (characterize_root_list_p p))))\n        (vec_of_list signs) =\n       construct_NofI_R p (retrieve_polys qs a) (retrieve_polys qs b)", "using all_list_constr_R_def in_set_member welldefined"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_constr (fst ?I) (length qs);\n   list_constr (snd ?I) (length qs)\\<rbrakk>\n  \\<Longrightarrow> vec_of_list (mtx_row_R signs ?I) \\<bullet>\n                    vec_of_list\n                     (map (\\<lambda>w.\n                              rat_of_int\n                               (int (length\n(filter (\\<lambda>v. v = w)\n  (map (consistent_sign_vec qs) (characterize_root_list_p p))))))\n                       signs) =\n                    construct_NofI_R p (retrieve_polys qs (fst ?I))\n                     (retrieve_polys qs (snd ?I))\n  all_list_constr_R ?L ?n \\<equiv>\n  \\<forall>x.\n     List.member ?L x \\<longrightarrow>\n     list_constr (fst x) ?n \\<and> list_constr (snd x) ?n\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  all_list_constr_R subsets (length qs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set subsets \\<Longrightarrow>\n       vec_of_list (mtx_row_R signs (a, b)) \\<bullet>\n       map_vec\n        (\\<lambda>w.\n            rat_of_nat\n             (length\n               (filter ((\\<lambda>v. v = w) \\<circ> consistent_sign_vec qs)\n                 (characterize_root_list_p p))))\n        (vec_of_list signs) =\n       construct_NofI_R p (retrieve_polys qs a) (retrieve_polys qs b)", "by fastforce"], ["", "(* Prettifying some theorems*)"], ["", "lemma consistent_signs_at_roots_eq:\n  assumes \"p \\<noteq> 0\"\n  shows \"consistent_signs_at_roots p qs =\n         set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_signs_at_roots p qs =\n    set (characterize_consistent_signs_at_roots p qs)", "unfolding consistent_signs_at_roots_def characterize_consistent_signs_at_roots_def\n    characterize_root_list_p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn_vec qs ` roots p =\n    set (remdups (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       sgn_vec qs xa\n       \\<in> signs_at qs ` set (sorted_list_of_set {x. poly p x = 0})\n 2. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       signs_at qs xa \\<in> sgn_vec qs ` roots p", "apply (subst set_sorted_list_of_set)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa. xa \\<in> roots p \\<Longrightarrow> finite {x. poly p x = 0}\n 2. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       sgn_vec qs xa \\<in> signs_at qs ` {x. poly p x = 0}\n 3. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       signs_at qs xa \\<in> sgn_vec qs ` roots p", "using assms poly_roots_finite"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (3 subgoals):\n 1. \\<And>xa. xa \\<in> roots p \\<Longrightarrow> finite {x. poly p x = 0}\n 2. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       sgn_vec qs xa \\<in> signs_at qs ` {x. poly p x = 0}\n 3. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       signs_at qs xa \\<in> sgn_vec qs ` roots p", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       sgn_vec qs xa \\<in> signs_at qs ` {x. poly p x = 0}\n 2. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       signs_at qs xa \\<in> sgn_vec qs ` roots p", "unfolding sgn_vec_def sgn_def signs_at_def squash_def o_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       map (\\<lambda>x.\n               if 0 < poly x xa then 1\n               else if poly x xa < 0 then - 1 else 0)\n        qs\n       \\<in> (\\<lambda>x.\n                 map (\\<lambda>xa.\n                         if 0 < poly xa x then 1\n                         else if poly xa x < 0 then - 1 else 0)\n                  qs) `\n             {x. poly p x = 0}\n 2. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       map (\\<lambda>x.\n               if 0 < poly x xa then 1\n               else if poly x xa < 0 then - 1 else 0)\n        qs\n       \\<in> (\\<lambda>x.\n                 map (\\<lambda>xa.\n                         if 0 < poly xa x then 1\n                         else if poly xa x < 0 then - 1 else 0)\n                  qs) `\n             roots p", "using roots_def"], ["proof (prove)\nusing this:\n  roots ?p = {x. poly ?p x = 0}\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       map (\\<lambda>x.\n               if 0 < poly x xa then 1\n               else if poly x xa < 0 then - 1 else 0)\n        qs\n       \\<in> (\\<lambda>x.\n                 map (\\<lambda>xa.\n                         if 0 < poly xa x then 1\n                         else if poly xa x < 0 then - 1 else 0)\n                  qs) `\n             {x. poly p x = 0}\n 2. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       map (\\<lambda>x.\n               if 0 < poly x xa then 1\n               else if poly x xa < 0 then - 1 else 0)\n        qs\n       \\<in> (\\<lambda>x.\n                 map (\\<lambda>xa.\n                         if 0 < poly xa x then 1\n                         else if poly xa x < 0 then - 1 else 0)\n                  qs) `\n             roots p", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       map (\\<lambda>x.\n               if 0 < poly x xa then 1\n               else if poly x xa < 0 then - 1 else 0)\n        qs\n       \\<in> (\\<lambda>x.\n                 map (\\<lambda>xa.\n                         if 0 < poly xa x then 1\n                         else if poly xa x < 0 then - 1 else 0)\n                  qs) `\n             roots p", "by (smt Collect_cong assms image_iff poly_roots_finite roots_def sorted_list_of_set(1))"], ["", "abbreviation w_vec_R:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> rat list list  \\<Rightarrow> rat vec\"\n  where \"w_vec_R \\<equiv> construct_lhs_vector_R\""], ["", "abbreviation v_vec_R:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> (nat list*nat list) list \\<Rightarrow> rat vec\"\n  where \"v_vec_R \\<equiv> construct_rhs_vector_R\""], ["", "abbreviation M_mat_R:: \"rat list list \\<Rightarrow> (nat list*nat list) list \\<Rightarrow> rat mat\"\n  where \"M_mat_R \\<equiv> matrix_A_R\""], ["", "theorem matrix_equation_pretty:\n  fixes subsets:: \"(nat list*nat list) list\"\n  assumes \"p\\<noteq>0\"\n  assumes \"distinct signs\"\n  assumes \"consistent_signs_at_roots p qs \\<subseteq> set signs\"\n  assumes \"\\<And>a b i. (a, b) \\<in> set ( subsets) \\<Longrightarrow> (i \\<in> set a \\<or> i \\<in> set b) \\<Longrightarrow> i < length qs\"\n  shows \"M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs = v_vec_R p qs subsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs =\n    v_vec_R p qs subsets", "unfolding satisfy_equation_R_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs subsets signs", "using matrix_equation_R[of p signs qs subsets] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; distinct signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   all_list_constr_R subsets (length qs)\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R p qs subsets signs\n  p \\<noteq> 0\n  distinct signs\n  consistent_signs_at_roots p qs \\<subseteq> set signs\n  \\<lbrakk>(?a, ?b) \\<in> set subsets;\n   ?i \\<in> set ?a \\<or> ?i \\<in> set ?b\\<rbrakk>\n  \\<Longrightarrow> ?i < length qs\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs subsets signs", "using consistent_signs_at_roots_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; distinct signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   all_list_constr_R subsets (length qs)\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R p qs subsets signs\n  p \\<noteq> 0\n  distinct signs\n  consistent_signs_at_roots p qs \\<subseteq> set signs\n  \\<lbrakk>(?a, ?b) \\<in> set subsets;\n   ?i \\<in> set ?a \\<or> ?i \\<in> set ?b\\<rbrakk>\n  \\<Longrightarrow> ?i < length qs\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  consistent_signs_at_roots ?p ?qs =\n  set (characterize_consistent_signs_at_roots ?p ?qs)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs subsets signs", "unfolding all_list_constr_R_def list_constr_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; distinct signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   \\<forall>x.\n      List.member subsets x \\<longrightarrow>\n      list_all (\\<lambda>x. x < length qs) (fst x) \\<and>\n      list_all (\\<lambda>x. x < length qs) (snd x)\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R p qs subsets signs\n  p \\<noteq> 0\n  distinct signs\n  consistent_signs_at_roots p qs \\<subseteq> set signs\n  \\<lbrakk>(?a, ?b) \\<in> set subsets;\n   ?i \\<in> set ?a \\<or> ?i \\<in> set ?b\\<rbrakk>\n  \\<Longrightarrow> ?i < length qs\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  consistent_signs_at_roots ?p ?qs =\n  set (characterize_consistent_signs_at_roots ?p ?qs)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs subsets signs", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                List.member subsets (a, b) \\<longrightarrow>\n                list_all (\\<lambda>x. x < length qs) a \\<and>\n                list_all (\\<lambda>x. x < length qs) b \\<Longrightarrow>\n             satisfy_equation_R p qs subsets signs;\n     p \\<noteq> 0; distinct signs;\n     set (characterize_consistent_signs_at_roots p qs)\n     \\<subseteq> set signs;\n     \\<And>a b i.\n        \\<lbrakk>(a, b) \\<in> set subsets;\n         i \\<in> set a \\<or> i \\<in> set b\\<rbrakk>\n        \\<Longrightarrow> i < length qs;\n     \\<And>p qs.\n        p \\<noteq> 0 \\<Longrightarrow>\n        consistent_signs_at_roots p qs =\n        set (characterize_consistent_signs_at_roots p qs)\\<rbrakk>\n    \\<Longrightarrow> satisfy_equation_R p qs subsets signs", "by (metis (no_types, lifting) Ball_set in_set_member)"], ["", "section \"Base Case\""], ["", "definition satisfies_properties_R:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> (nat list*nat list) list \\<Rightarrow> rat list list \\<Rightarrow> rat mat \\<Rightarrow> bool\"\n  where \"satisfies_properties_R p qs subsets signs matrix = \n  ( all_list_constr_R subsets (length qs) \\<and> well_def_signs (length qs) signs \\<and> distinct signs\n  \\<and> satisfy_equation_R p qs subsets signs \\<and>  invertible_mat matrix  \\<and> matrix = matrix_A_R signs subsets\n  \\<and> set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\n  )\""], ["", "lemma mat_base_case_R:\n  shows \"matrix_A_R [[1],[0],[-1]] [([], []),([0], []),([], [0])] = (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n    mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]", "unfolding matrix_A_R_def mtx_row_R_def z_R_def map_sgas_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list (length [[1], [0], [- 1]])\n     (map (\\<lambda>index_list.\n              map (\\<lambda>sign_asg.\n                      prod_list\n                       (map ((!) (map (\\<lambda>r. 1 - r\\<^sup>2) sign_asg))\n                         (fst index_list)) *\n                      prod_list (map ((!) sign_asg) (snd index_list)))\n               [[1], [0], [- 1]])\n       [([], []), ([0], []), ([], [0])]) =\n    mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list (Suc (Suc (Suc 0)))\n     [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] =\n    mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]", "by (simp add: numeral_3_eq_3)"], ["", "lemma base_case_sgas_R:\n  fixes q p:: \"real poly\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"set (characterize_consistent_signs_at_roots p [q]) \\<subseteq> {[1],[0], [- 1]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p [q])\n    \\<subseteq> {[1], [0], [- 1]}", "unfolding characterize_consistent_signs_at_roots_def signs_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups\n          (map (\\<lambda>x. map (squash \\<circ> (\\<lambda>q. poly q x)) [q])\n            (characterize_root_list_p p)))\n    \\<subseteq> {[1], [0], [- 1]}", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (characterize_root_list_p p);\n        squash (poly q xa) \\<noteq> 1;\n        squash (poly q xa) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash (poly q xa) = - 1", "by (meson squash_def)"], ["", "lemma base_case_sgas_alt_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  assumes len1: \"length qs = 1\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> {[1], [0], [- 1]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> {[1], [0], [- 1]}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> {[1], [0], [- 1]}", "have ex_q: \"\\<exists>(q::real poly). qs = [q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. qs = [q]", "using len1"], ["proof (prove)\nusing this:\n  length qs = 1\n\ngoal (1 subgoal):\n 1. \\<exists>q. qs = [q]", "using length_Suc_conv[of qs 0]"], ["proof (prove)\nusing this:\n  length qs = 1\n  (length qs = Suc 0) = (\\<exists>y ys. qs = y # ys \\<and> length ys = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>q. qs = [q]", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. qs = [q]\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> {[1], [0], [- 1]}", "then"], ["proof (chain)\npicking this:\n  \\<exists>q. qs = [q]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>q. qs = [q]\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> {[1], [0], [- 1]}", "using base_case_sgas_R nonzero"], ["proof (prove)\nusing this:\n  \\<exists>q. qs = [q]\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  set (characterize_consistent_signs_at_roots ?p [?q])\n  \\<subseteq> {[1], [0], [- 1]}\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> {[1], [0], [- 1]}", "by auto"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> {[1], [0], [- 1]}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_case_satisfy_equation_R:\n  fixes q p:: \"real poly\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"satisfy_equation_R p [q] [([], []),([0], []),([], [0])] [[1],[0],[-1]] \""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p [q] [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfy_equation_R p [q] [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "have h1: \"set (characterize_consistent_signs_at_roots p [q]) \\<subseteq> {[1], [0],[- 1]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p [q])\n    \\<subseteq> {[1], [0], [- 1]}", "using base_case_sgas_R assms"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  set (characterize_consistent_signs_at_roots ?p [?q])\n  \\<subseteq> {[1], [0], [- 1]}\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p [q])\n    \\<subseteq> {[1], [0], [- 1]}", "by auto"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p [q])\n  \\<subseteq> {[1], [0], [- 1]}\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p [q] [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "have h2: \"all_list_constr_R [([], []),([0], []),([], [0])] (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr_R [([], []), ([0], []), ([], [0])] (Suc 0)", "unfolding all_list_constr_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member [([], []), ([0], []), ([], [0])] x \\<longrightarrow>\n       list_constr (fst x) (Suc 0) \\<and> list_constr (snd x) (Suc 0)", "by (simp add: list_constr_def member_def)"], ["proof (state)\nthis:\n  all_list_constr_R [([], []), ([0], []), ([], [0])] (Suc 0)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p [q] [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "then"], ["proof (chain)\npicking this:\n  all_list_constr_R [([], []), ([0], []), ([], [0])] (Suc 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  all_list_constr_R [([], []), ([0], []), ([], [0])] (Suc 0)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p [q] [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "using matrix_equation_R[where p = \"p\", where qs = \"[q]\", where signs = \"[[1],[0],[-1]] \", where subsets = \"[([], []),([0], []),([], [0])]\"]\n      nonzero h1  h2"], ["proof (prove)\nusing this:\n  all_list_constr_R [([], []), ([0], []), ([], [0])] (Suc 0)\n  \\<lbrakk>p \\<noteq> 0; distinct [[1], [0], [- 1]];\n   set (characterize_consistent_signs_at_roots p [q])\n   \\<subseteq> set [[1], [0], [- 1]];\n   all_list_constr_R [([], []), ([0], []), ([], [0])] (length [q])\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R p [q]\n                     [([], []), ([0], []), ([], [0])] [[1], [0], [- 1]]\n  p \\<noteq> 0\n  set (characterize_consistent_signs_at_roots p [q])\n  \\<subseteq> {[1], [0], [- 1]}\n  all_list_constr_R [([], []), ([0], []), ([], [0])] (Suc 0)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p [q] [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "by auto"], ["proof (state)\nthis:\n  satisfy_equation_R p [q] [([], []), ([0], []), ([], [0])]\n   [[1], [0], [- 1]]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_case_satisfy_equation_alt_R:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  assumes len1: \"length qs = 1\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"satisfy_equation_R p qs [([], []),([0], []),([], [0])] [[1],[0],[-1]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "have ex_q: \"\\<exists>(q::real poly). qs = [q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. qs = [q]", "using len1"], ["proof (prove)\nusing this:\n  length qs = 1\n\ngoal (1 subgoal):\n 1. \\<exists>q. qs = [q]", "using length_Suc_conv[of qs 0]"], ["proof (prove)\nusing this:\n  length qs = 1\n  (length qs = Suc 0) = (\\<exists>y ys. qs = y # ys \\<and> length ys = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>q. qs = [q]", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. qs = [q]\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "then"], ["proof (chain)\npicking this:\n  \\<exists>q. qs = [q]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>q. qs = [q]\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "using base_case_satisfy_equation_R nonzero"], ["proof (prove)\nusing this:\n  \\<exists>q. qs = [q]\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  satisfy_equation_R ?p [?q] [([], []), ([0], []), ([], [0])]\n   [[1], [0], [- 1]]\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "by auto"], ["proof (state)\nthis:\n  satisfy_equation_R p qs [([], []), ([0], []), ([], [0])] [[1], [0], [- 1]]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_case_matrix_eq:\n  fixes q p:: \"real poly\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"(mult_mat_vec (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]]) (construct_lhs_vector_R p [q] [[1],[0],[-1]]) = \n    (construct_rhs_vector_R p [q] [([], []),([0], []),([], [0])]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] *\\<^sub>v\n    w_vec_R p [q] [[1], [0], [- 1]] =\n    v_vec_R p [q] [([], []), ([0], []), ([], [0])]", "using mat_base_case_R base_case_satisfy_equation_R"], ["proof (prove)\nusing this:\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  satisfy_equation_R ?p [?q] [([], []), ([0], []), ([], [0])]\n   [[1], [0], [- 1]]\n\ngoal (1 subgoal):\n 1. mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] *\\<^sub>v\n    w_vec_R p [q] [[1], [0], [- 1]] =\n    v_vec_R p [q] [([], []), ([0], []), ([], [0])]", "unfolding satisfy_equation_R_def"], ["proof (prove)\nusing this:\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] *\\<^sub>v\n  w_vec_R ?p [?q] [[1], [0], [- 1]] =\n  v_vec_R ?p [?q] [([], []), ([0], []), ([], [0])]\n\ngoal (1 subgoal):\n 1. mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] *\\<^sub>v\n    w_vec_R p [q] [[1], [0], [- 1]] =\n    v_vec_R p [q] [([], []), ([0], []), ([], [0])]", "by (simp add: nonzero)"], ["", "lemma less_three: \"(n::nat) < Suc (Suc (Suc 0)) \\<longleftrightarrow> n = 0 \\<or> n = 1 \\<or> n = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < Suc (Suc (Suc 0))) = (n = 0 \\<or> n = 1 \\<or> n = 2)", "by auto"], ["", "lemma inverse_mat_base_case_R:\n  shows \"inverts_mat (mat_of_rows_list 3  [[1/2, -1/2, 1/2], [0, 1, 0], [1/2, -1/2, -1/2]]::rat mat) (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]]::rat mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat\n     (mat_of_rows_list 3\n       [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n     (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])", "unfolding inverts_mat_def mat_of_rows_list_def mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (length\n            [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n       3 (\\<lambda>(i, y).\n             [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n              [1 / 2, - 1 / 2, - 1 / 2]] !\n             i !\n             y) *\n      mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n       (\\<lambda>(i, y). [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! y)) =\n    dim_row\n     (1\\<^sub>m\n       (dim_row\n         (mat (length\n                [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                 [1 / 2, - 1 / 2, - 1 / 2]])\n           3 (\\<lambda>(i, y).\n                 [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                  [1 / 2, - 1 / 2, - 1 / 2]] !\n                 i !\n                 y)))) \\<and>\n    dim_col\n     (mat (length\n            [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n       3 (\\<lambda>(i, y).\n             [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n              [1 / 2, - 1 / 2, - 1 / 2]] !\n             i !\n             y) *\n      mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n       (\\<lambda>(i, y). [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! y)) =\n    dim_col\n     (1\\<^sub>m\n       (dim_row\n         (mat (length\n                [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                 [1 / 2, - 1 / 2, - 1 / 2]])\n           3 (\\<lambda>(i, y).\n                 [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                  [1 / 2, - 1 / 2, - 1 / 2]] !\n                 i !\n                 y)))) \\<and>\n    (\\<forall>i j.\n        i < dim_row\n             (1\\<^sub>m\n               (dim_row\n                 (mat (length\n                        [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                         [1 / 2, - 1 / 2, - 1 / 2]])\n                   3 (\\<lambda>(i, y).\n                         [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                          [1 / 2, - 1 / 2, - 1 / 2]] !\n                         i !\n                         y)))) \\<longrightarrow>\n        j < dim_col\n             (1\\<^sub>m\n               (dim_row\n                 (mat (length\n                        [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                         [1 / 2, - 1 / 2, - 1 / 2]])\n                   3 (\\<lambda>(i, y).\n                         [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                          [1 / 2, - 1 / 2, - 1 / 2]] !\n                         i !\n                         y)))) \\<longrightarrow>\n        (mat (length\n               [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                [1 / 2, - 1 / 2, - 1 / 2]])\n          3 (\\<lambda>(i, y).\n                [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                 [1 / 2, - 1 / 2, - 1 / 2]] !\n                i !\n                y) *\n         mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n          (\\<lambda>(i, y). [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! y)) $$\n        (i, j) =\n        1\\<^sub>m\n         (dim_row\n           (mat (length\n                  [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                   [1 / 2, - 1 / 2, - 1 / 2]])\n             3 (\\<lambda>(i, y).\n                   [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                    [1 / 2, - 1 / 2, - 1 / 2]] !\n                   i !\n                   y))) $$\n        (i, j))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       j < Suc (Suc (Suc 0)) \\<Longrightarrow>\n       vec 3\n        ((!) ([[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n               [1 / 2, - (1 / 2), - (1 / 2)]] !\n              j)) \\<bullet>\n       vec (Suc (Suc (Suc 0)))\n        (\\<lambda>i. [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! j) =\n       1\n 2. \\<And>i j.\n       \\<lbrakk>i < Suc (Suc (Suc 0)); i \\<noteq> j;\n        j < Suc (Suc (Suc 0))\\<rbrakk>\n       \\<Longrightarrow> vec 3\n                          ((!) ([[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n                                 [1 / 2, - (1 / 2), - (1 / 2)]] !\n                                i)) \\<bullet>\n                         vec (Suc (Suc (Suc 0)))\n                          (\\<lambda>i.\n                              [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! j) =\n                         0", "unfolding less_three"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       j = 0 \\<or> j = 1 \\<or> j = 2 \\<Longrightarrow>\n       vec 3\n        ((!) ([[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n               [1 / 2, - (1 / 2), - (1 / 2)]] !\n              j)) \\<bullet>\n       vec (Suc (Suc (Suc 0)))\n        (\\<lambda>i. [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! j) =\n       1\n 2. \\<And>i j.\n       \\<lbrakk>i = 0 \\<or> i = 1 \\<or> i = 2; i \\<noteq> j;\n        j = 0 \\<or> j = 1 \\<or> j = 2\\<rbrakk>\n       \\<Longrightarrow> vec 3\n                          ((!) ([[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n                                 [1 / 2, - (1 / 2), - (1 / 2)]] !\n                                i)) \\<bullet>\n                         vec (Suc (Suc (Suc 0)))\n                          (\\<lambda>i.\n                              [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! j) =\n                         0", "by (auto simp add: scalar_prod_def)"], ["", "lemma inverse_mat_base_case_2_R: \n  shows \"inverts_mat (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]]::rat mat) (mat_of_rows_list 3  [[1/2, -1/2, 1/2], [0, 1, 0], [1/2, -1/2, -1/2]]:: rat mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n     (mat_of_rows_list 3\n       [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])", "unfolding inverts_mat_def mat_of_rows_list_def mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n       (\\<lambda>(i, y). [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! y) *\n      mat (length\n            [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n       3 (\\<lambda>(i, y).\n             [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n              [1 / 2, - 1 / 2, - 1 / 2]] !\n             i !\n             y)) =\n    dim_row\n     (1\\<^sub>m\n       (dim_row\n         (mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n           (\\<lambda>(i, y).\n               [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! y)))) \\<and>\n    dim_col\n     (mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n       (\\<lambda>(i, y). [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! y) *\n      mat (length\n            [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n       3 (\\<lambda>(i, y).\n             [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n              [1 / 2, - 1 / 2, - 1 / 2]] !\n             i !\n             y)) =\n    dim_col\n     (1\\<^sub>m\n       (dim_row\n         (mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n           (\\<lambda>(i, y).\n               [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! y)))) \\<and>\n    (\\<forall>i j.\n        i < dim_row\n             (1\\<^sub>m\n               (dim_row\n                 (mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n                   (\\<lambda>(i, y).\n                       [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i !\n                       y)))) \\<longrightarrow>\n        j < dim_col\n             (1\\<^sub>m\n               (dim_row\n                 (mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n                   (\\<lambda>(i, y).\n                       [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i !\n                       y)))) \\<longrightarrow>\n        (mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n          (\\<lambda>(i, y). [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! y) *\n         mat (length\n               [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                [1 / 2, - 1 / 2, - 1 / 2]])\n          3 (\\<lambda>(i, y).\n                [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0],\n                 [1 / 2, - 1 / 2, - 1 / 2]] !\n                i !\n                y)) $$\n        (i, j) =\n        1\\<^sub>m\n         (dim_row\n           (mat (length [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]) 3\n             (\\<lambda>(i, y).\n                 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! y))) $$\n        (i, j))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       j < Suc (Suc (Suc 0)) \\<Longrightarrow>\n       vec 3 ((!) ([[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! j)) \\<bullet>\n       vec (Suc (Suc (Suc 0)))\n        (\\<lambda>i.\n            [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n             [1 / 2, - (1 / 2), - (1 / 2)]] !\n            i !\n            j) =\n       1\n 2. \\<And>i j.\n       \\<lbrakk>i < Suc (Suc (Suc 0)); i \\<noteq> j;\n        j < Suc (Suc (Suc 0))\\<rbrakk>\n       \\<Longrightarrow> vec 3\n                          ((!) ([[1, 1, 1], [0, 1, 0], [1, 0, - 1]] !\n                                i)) \\<bullet>\n                         vec (Suc (Suc (Suc 0)))\n                          (\\<lambda>i.\n                              [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n                               [1 / 2, - (1 / 2), - (1 / 2)]] !\n                              i !\n                              j) =\n                         0", "unfolding less_three"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       j = 0 \\<or> j = 1 \\<or> j = 2 \\<Longrightarrow>\n       vec 3 ((!) ([[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! j)) \\<bullet>\n       vec (Suc (Suc (Suc 0)))\n        (\\<lambda>i.\n            [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n             [1 / 2, - (1 / 2), - (1 / 2)]] !\n            i !\n            j) =\n       1\n 2. \\<And>i j.\n       \\<lbrakk>i = 0 \\<or> i = 1 \\<or> i = 2; i \\<noteq> j;\n        j = 0 \\<or> j = 1 \\<or> j = 2\\<rbrakk>\n       \\<Longrightarrow> vec 3\n                          ((!) ([[1, 1, 1], [0, 1, 0], [1, 0, - 1]] !\n                                i)) \\<bullet>\n                         vec (Suc (Suc (Suc 0)))\n                          (\\<lambda>i.\n                              [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n                               [1 / 2, - (1 / 2), - (1 / 2)]] !\n                              i !\n                              j) =\n                         0", "by (auto simp add: scalar_prod_def)"], ["", "lemma base_case_invertible_mat_R: \n  shows \"invertible_mat (matrix_A_R [[1],[0], [- 1]] [([], []),([0], []),([], [0])])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat\n     (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])", "unfolding invertible_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. square_mat\n     (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]) \\<and>\n    (\\<exists>B.\n        inverts_mat\n         (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])\n         B \\<and>\n        inverts_mat B\n         (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]))", "using inverse_mat_base_case_R inverse_mat_base_case_2_R"], ["proof (prove)\nusing this:\n  inverts_mat\n   (mat_of_rows_list 3\n     [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n   (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n  inverts_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n   (mat_of_rows_list 3\n     [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n\ngoal (1 subgoal):\n 1. square_mat\n     (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]) \\<and>\n    (\\<exists>B.\n        inverts_mat\n         (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])\n         B \\<and>\n        inverts_mat B\n         (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]))", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inverts_mat\n              (mat_of_rows_list 3\n                [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n                 [1 / 2, - (1 / 2), - (1 / 2)]])\n              (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]);\n     inverts_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n      (mat_of_rows_list 3\n        [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n         [1 / 2, - (1 / 2), - (1 / 2)]])\\<rbrakk>\n    \\<Longrightarrow> dim_col\n                       (M_mat_R [[1], [0], [- 1]]\n                         [([], []), ([0], []), ([], [0])]) =\n                      dim_row\n                       (M_mat_R [[1], [0], [- 1]]\n                         [([], []), ([0], []), ([], [0])])\n 2. \\<lbrakk>inverts_mat\n              (mat_of_rows_list 3\n                [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n                 [1 / 2, - (1 / 2), - (1 / 2)]])\n              (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]);\n     inverts_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n      (mat_of_rows_list 3\n        [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n         [1 / 2, - (1 / 2), - (1 / 2)]])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B.\n                         inverts_mat\n                          (M_mat_R [[1], [0], [- 1]]\n                            [([], []), ([0], []), ([], [0])])\n                          B \\<and>\n                         inverts_mat B\n                          (M_mat_R [[1], [0], [- 1]]\n                            [([], []), ([0], []), ([], [0])])", "apply (simp add: mat_base_case mat_of_rows_list_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inverts_mat\n              (mat (Suc (Suc (Suc 0))) 3\n                (\\<lambda>(i, j).\n                    [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n                     [1 / 2, - (1 / 2), - (1 / 2)]] !\n                    i !\n                    j))\n              (mat (Suc (Suc (Suc 0))) 3\n                (\\<lambda>(i, j).\n                    [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! j));\n     inverts_mat\n      (mat (Suc (Suc (Suc 0))) 3\n        (\\<lambda>(i, j). [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! j))\n      (mat (Suc (Suc (Suc 0))) 3\n        (\\<lambda>(i, j).\n            [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n             [1 / 2, - (1 / 2), - (1 / 2)]] !\n            i !\n            j))\\<rbrakk>\n    \\<Longrightarrow> dim_col\n                       (M_mat_R [[1], [0], [- 1]]\n                         [([], []), ([0], []), ([], [0])]) =\n                      dim_row\n                       (M_mat_R [[1], [0], [- 1]]\n                         [([], []), ([0], []), ([], [0])])\n 2. \\<lbrakk>inverts_mat\n              (mat_of_rows_list 3\n                [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n                 [1 / 2, - (1 / 2), - (1 / 2)]])\n              (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]);\n     inverts_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n      (mat_of_rows_list 3\n        [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n         [1 / 2, - (1 / 2), - (1 / 2)]])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B.\n                         inverts_mat\n                          (M_mat_R [[1], [0], [- 1]]\n                            [([], []), ([0], []), ([], [0])])\n                          B \\<and>\n                         inverts_mat B\n                          (M_mat_R [[1], [0], [- 1]]\n                            [([], []), ([0], []), ([], [0])])", "using mat_base_case_R"], ["proof (prove)\nusing this:\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>inverts_mat\n              (mat (Suc (Suc (Suc 0))) 3\n                (\\<lambda>(i, j).\n                    [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n                     [1 / 2, - (1 / 2), - (1 / 2)]] !\n                    i !\n                    j))\n              (mat (Suc (Suc (Suc 0))) 3\n                (\\<lambda>(i, j).\n                    [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! j));\n     inverts_mat\n      (mat (Suc (Suc (Suc 0))) 3\n        (\\<lambda>(i, j). [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] ! i ! j))\n      (mat (Suc (Suc (Suc 0))) 3\n        (\\<lambda>(i, j).\n            [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n             [1 / 2, - (1 / 2), - (1 / 2)]] !\n            i !\n            j))\\<rbrakk>\n    \\<Longrightarrow> dim_col\n                       (M_mat_R [[1], [0], [- 1]]\n                         [([], []), ([0], []), ([], [0])]) =\n                      dim_row\n                       (M_mat_R [[1], [0], [- 1]]\n                         [([], []), ([0], []), ([], [0])])\n 2. \\<lbrakk>inverts_mat\n              (mat_of_rows_list 3\n                [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n                 [1 / 2, - (1 / 2), - (1 / 2)]])\n              (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]);\n     inverts_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n      (mat_of_rows_list 3\n        [[1 / 2, - (1 / 2), 1 / 2], [0, 1, 0],\n         [1 / 2, - (1 / 2), - (1 / 2)]])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B.\n                         inverts_mat\n                          (M_mat_R [[1], [0], [- 1]]\n                            [([], []), ([0], []), ([], [0])])\n                          B \\<and>\n                         inverts_mat B\n                          (M_mat_R [[1], [0], [- 1]]\n                            [([], []), ([0], []), ([], [0])])", "by auto"], ["", "section \"Inductive Step\""], ["", "(***** Need some properties of smashing; smashing signs is just as it was in BKR *****)"], ["", "subsection \"Lemmas on smashing subsets \""], ["", "definition subsets_first_component_list::\"(nat list*nat list) list \\<Rightarrow> nat list list\"\n  where \"subsets_first_component_list I = map (\\<lambda>I. (fst I)) I\""], ["", "definition subsets_second_component_list::\"(nat list*nat list) list \\<Rightarrow> nat list list\"\n  where \"subsets_second_component_list I = map (\\<lambda>I. (snd I)) I\""], ["", "definition smash_list_list::\"('a list*'a list) list \\<Rightarrow>  ('a list*'a list) list \\<Rightarrow> ('a list*'a list) list\"\n  where \"smash_list_list s1 s2 = concat (map (\\<lambda>l1. map (\\<lambda>l2. (fst l1 @ fst l2, snd l1 @ snd l2)) s2) s1)\""], ["", "lemma smash_list_list_property_set:\n  fixes l1 l2 :: \"('a list*'a list) list\"\n  fixes a b:: \"nat\"\n  shows \"\\<forall> (elem :: ('a list*'a list)). (elem \\<in> (set (smash_list_list l1 l2)) \\<longrightarrow> \n    (\\<exists> (elem1:: ('a list*'a list)). \\<exists> (elem2:: ('a list*'a list)). \n      (elem1 \\<in> set(l1) \\<and> elem2 \\<in> set(l2) \\<and> elem = (fst elem1@ fst elem2, snd elem1 @ snd elem2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       elem \\<in> set (smash_list_list l1 l2) \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set l1 \\<and>\n           elem2 \\<in> set l2 \\<and>\n           elem = (fst elem1 @ fst elem2, snd elem1 @ snd elem2))", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (smash_list_list l1 l2) \\<Longrightarrow>\n       \\<exists>aa ba.\n          (aa, ba) \\<in> set l1 \\<and>\n          (\\<exists>ab bb.\n              (ab, bb) \\<in> set l2 \\<and> a = aa @ ab \\<and> b = ba @ bb)", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (smash_list_list l1 l2) \\<Longrightarrow>\n       \\<exists>aa ba.\n          (aa, ba) \\<in> set l1 \\<and>\n          (\\<exists>ab bb.\n              (ab, bb) \\<in> set l2 \\<and> a = aa @ ab \\<and> b = ba @ bb)", "assume assum: \"(a, b) \\<in> set (smash_list_list l1 l2)\""], ["proof (state)\nthis:\n  (a, b) \\<in> set (smash_list_list l1 l2)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (smash_list_list l1 l2) \\<Longrightarrow>\n       \\<exists>aa ba.\n          (aa, ba) \\<in> set l1 \\<and>\n          (\\<exists>ab bb.\n              (ab, bb) \\<in> set l2 \\<and> a = aa @ ab \\<and> b = ba @ bb)", "show \"\\<exists>aa ba. (aa, ba) \\<in> set l1 \\<and> (\\<exists>ab bb. (ab, bb) \\<in> set l2 \\<and> a = aa @ ab \\<and> b = ba @ bb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>aaa baa.\n       (aaa, baa) \\<in> set l1 \\<and>\n       (\\<exists>ab bb.\n           (ab, bb) \\<in> set l2 \\<and> a = aaa @ ab \\<and> b = baa @ bb)", "using assum"], ["proof (prove)\nusing this:\n  (a, b) \\<in> set (smash_list_list l1 l2)\n\ngoal (1 subgoal):\n 1. \\<exists>aaa baa.\n       (aaa, baa) \\<in> set l1 \\<and>\n       (\\<exists>ab bb.\n           (ab, bb) \\<in> set l2 \\<and> a = aaa @ ab \\<and> b = baa @ bb)", "unfolding smash_list_list_def"], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> set (concat\n              (map (\\<lambda>l1.\n                       map (\\<lambda>l2. (fst l1 @ fst l2, snd l1 @ snd l2))\n                        l2)\n                l1))\n\ngoal (1 subgoal):\n 1. \\<exists>aaa baa.\n       (aaa, baa) \\<in> set l1 \\<and>\n       (\\<exists>ab bb.\n           (ab, bb) \\<in> set l2 \\<and> a = aaa @ ab \\<and> b = baa @ bb)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aaa baa.\n       \\<lbrakk>(a, b) \\<in> set l1; (aaa, baa) \\<in> set l2; b = b @ baa;\n        a = a @ aaa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa ba.\n                            (aa, ba) \\<in> set l1 \\<and>\n                            (\\<exists>ab bb.\n                                (ab, bb) \\<in> set l2 \\<and>\n                                a @ aaa = aa @ ab \\<and> b @ baa = ba @ bb)", "by blast"], ["proof (state)\nthis:\n  \\<exists>aaa baa.\n     (aaa, baa) \\<in> set l1 \\<and>\n     (\\<exists>ab bb.\n         (ab, bb) \\<in> set l2 \\<and> a = aaa @ ab \\<and> b = baa @ bb)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subsets_smash_property_R:\n  fixes subsets1 subsets2 :: \"(nat list*nat list) list\"\n  fixes n:: \"nat\"\n  shows \"\\<forall> (elem :: nat list*nat list). (List.member (subsets_smash_R n subsets1 subsets2) elem) \\<longrightarrow> \n    (\\<exists> (elem1::nat list*nat list). \\<exists> (elem2::nat list*nat list).\n      (elem1 \\<in> set(subsets1) \\<and> elem2 \\<in> set(subsets2) \\<and> elem = ((fst elem1) @ (map ((+) n) (fst elem2)), (snd elem1) @ (map ((+) n) (snd elem2)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R n subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) n) (fst elem2),\n            snd elem1 @ map ((+) n) (snd elem2)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R n subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) n) (fst elem2),\n            snd elem1 @ map ((+) n) (snd elem2)))", "let ?fst_component2 = \"subsets_first_component_list subsets2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R n subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) n) (fst elem2),\n            snd elem1 @ map ((+) n) (snd elem2)))", "let ?snd_component2 = \"subsets_second_component_list subsets2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R n subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) n) (fst elem2),\n            snd elem1 @ map ((+) n) (snd elem2)))", "let ?new_subsets = \"map (\\<lambda>I. ((map ((+) n)) (fst I),  (map ((+) n)) (snd I))) subsets2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R n subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) n) (fst elem2),\n            snd elem1 @ map ((+) n) (snd elem2)))", "(* a slightly unorthodox use of signs_smash, but it closes the proof *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R n subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) n) (fst elem2),\n            snd elem1 @ map ((+) n) (snd elem2)))", "have \"subsets_smash_R n subsets1 subsets2 = smash_list_list subsets1 ?new_subsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsets_smash_R n subsets1 subsets2 =\n    smash_list_list subsets1\n     (map (\\<lambda>I. (map ((+) n) (fst I), map ((+) n) (snd I))) subsets2)", "unfolding subsets_smash_R_def smash_list_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>l1.\n              map (\\<lambda>l2.\n                      (fst l1 @ map ((+) n) (fst l2),\n                       snd l1 @ map ((+) n) (snd l2)))\n               subsets2)\n       subsets1) =\n    concat\n     (map (\\<lambda>l1.\n              map (\\<lambda>l2. (fst l1 @ fst l2, snd l1 @ snd l2))\n               (map (\\<lambda>I. (map ((+) n) (fst I), map ((+) n) (snd I)))\n                 subsets2))\n       subsets1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>l1.\n              map (\\<lambda>l2.\n                      (fst l1 @ map ((+) n) (fst l2),\n                       snd l1 @ map ((+) n) (snd l2)))\n               subsets2)\n       subsets1) =\n    concat\n     (map (\\<lambda>l1.\n              map ((\\<lambda>l2. (fst l1 @ fst l2, snd l1 @ snd l2)) \\<circ>\n                   (\\<lambda>I. (map ((+) n) (fst I), map ((+) n) (snd I))))\n               subsets2)\n       subsets1)", "by (simp add: comp_def)"], ["proof (state)\nthis:\n  subsets_smash_R n subsets1 subsets2 =\n  smash_list_list subsets1\n   (map (\\<lambda>I. (map ((+) n) (fst I), map ((+) n) (snd I))) subsets2)\n\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R n subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) n) (fst elem2),\n            snd elem1 @ map ((+) n) (snd elem2)))", "then"], ["proof (chain)\npicking this:\n  subsets_smash_R n subsets1 subsets2 =\n  smash_list_list subsets1\n   (map (\\<lambda>I. (map ((+) n) (fst I), map ((+) n) (snd I))) subsets2)", "show ?thesis"], ["proof (prove)\nusing this:\n  subsets_smash_R n subsets1 subsets2 =\n  smash_list_list subsets1\n   (map (\\<lambda>I. (map ((+) n) (fst I), map ((+) n) (snd I))) subsets2)\n\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R n subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) n) (fst elem2),\n            snd elem1 @ map ((+) n) (snd elem2)))", "using smash_list_list_property_set[of subsets1 ?new_subsets]"], ["proof (prove)\nusing this:\n  subsets_smash_R n subsets1 subsets2 =\n  smash_list_list subsets1\n   (map (\\<lambda>I. (map ((+) n) (fst I), map ((+) n) (snd I))) subsets2)\n  \\<forall>elem.\n     elem\n     \\<in> set (smash_list_list subsets1\n                 (map (\\<lambda>I.\n                          (map ((+) n) (fst I), map ((+) n) (snd I)))\n                   subsets2)) \\<longrightarrow>\n     (\\<exists>elem1 elem2.\n         elem1 \\<in> set subsets1 \\<and>\n         elem2\n         \\<in> set (map (\\<lambda>I.\n                            (map ((+) n) (fst I), map ((+) n) (snd I)))\n                     subsets2) \\<and>\n         elem = (fst elem1 @ fst elem2, snd elem1 @ snd elem2))\n\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R n subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) n) (fst elem2),\n            snd elem1 @ map ((+) n) (snd elem2)))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>subsets_smash_R n subsets1 subsets2 =\n                smash_list_list subsets1\n                 (map (\\<lambda>I.\n                          (map ((+) n) (fst I), map ((+) n) (snd I)))\n                   subsets2);\n        \\<forall>a b.\n           (a, b)\n           \\<in> set (smash_list_list subsets1\n                       (map (\\<lambda>I.\n                                (map ((+) n) (fst I), map ((+) n) (snd I)))\n                         subsets2)) \\<longrightarrow>\n           (\\<exists>aa ba.\n               (aa, ba) \\<in> set subsets1 \\<and>\n               (\\<exists>elem2\\<in>set subsets2.\n                   a = aa @ map ((+) n) (fst elem2) \\<and>\n                   b = ba @ map ((+) n) (snd elem2)));\n        List.member\n         (smash_list_list subsets1\n           (map (\\<lambda>I. (map ((+) n) (fst I), map ((+) n) (snd I)))\n             subsets2))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa ba.\n                            (aa, ba) \\<in> set subsets1 \\<and>\n                            (\\<exists>ab bb.\n                                (ab, bb) \\<in> set subsets2 \\<and>\n                                a = aa @ map ((+) n) ab \\<and>\n                                b = ba @ map ((+) n) bb)", "using imageE in_set_member set_map smash_list_list_property_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<in> ?f ` ?A;\n   \\<And>x.\n      \\<lbrakk>?b = ?f x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  set (map ?f ?xs) = ?f ` set ?xs\n  \\<forall>elem.\n     elem \\<in> set (smash_list_list ?l1.0 ?l2.0) \\<longrightarrow>\n     (\\<exists>elem1 elem2.\n         elem1 \\<in> set ?l1.0 \\<and>\n         elem2 \\<in> set ?l2.0 \\<and>\n         elem = (fst elem1 @ fst elem2, snd elem1 @ snd elem2))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>subsets_smash_R n subsets1 subsets2 =\n                smash_list_list subsets1\n                 (map (\\<lambda>I.\n                          (map ((+) n) (fst I), map ((+) n) (snd I)))\n                   subsets2);\n        \\<forall>a b.\n           (a, b)\n           \\<in> set (smash_list_list subsets1\n                       (map (\\<lambda>I.\n                                (map ((+) n) (fst I), map ((+) n) (snd I)))\n                         subsets2)) \\<longrightarrow>\n           (\\<exists>aa ba.\n               (aa, ba) \\<in> set subsets1 \\<and>\n               (\\<exists>elem2\\<in>set subsets2.\n                   a = aa @ map ((+) n) (fst elem2) \\<and>\n                   b = ba @ map ((+) n) (snd elem2)));\n        List.member\n         (smash_list_list subsets1\n           (map (\\<lambda>I. (map ((+) n) (fst I), map ((+) n) (snd I)))\n             subsets2))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa ba.\n                            (aa, ba) \\<in> set subsets1 \\<and>\n                            (\\<exists>ab bb.\n                                (ab, bb) \\<in> set subsets2 \\<and>\n                                a = aa @ map ((+) n) ab \\<and>\n                                b = ba @ map ((+) n) bb)", "by (smt (z3) prod.exhaust_sel)"], ["proof (state)\nthis:\n  \\<forall>elem.\n     List.member (subsets_smash_R n subsets1 subsets2)\n      elem \\<longrightarrow>\n     (\\<exists>elem1 elem2.\n         elem1 \\<in> set subsets1 \\<and>\n         elem2 \\<in> set subsets2 \\<and>\n         elem =\n         (fst elem1 @ map ((+) n) (fst elem2),\n          snd elem1 @ map ((+) n) (snd elem2)))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* If subsets for smaller systems are well-defined, then subsets for combined systems are, too *)"], ["", "subsection \"Well-defined subsets preserved when smashing\""], ["", "lemma well_def_step_R: \n  fixes qs1 qs2 :: \"real poly list\"\n  fixes subsets1 subsets2 :: \"(nat list*nat list) list\"\n  assumes well_def_subsets1: \"all_list_constr_R (subsets1) (length qs1)\"\n  assumes well_def_subsets2: \"all_list_constr_R (subsets2) (length qs2)\"\n  shows \"all_list_constr_R ((subsets_smash_R (length qs1) subsets1 subsets2))\n     (length (qs1 @ qs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "let ?n = \"(length qs1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "have h1: \"\\<forall>elem.\n     List.member (subsets_smash_R ?n subsets1 subsets2) elem \\<longrightarrow>\n     (\\<exists> (elem1::nat list*nat list). \\<exists> (elem2::nat list*nat list).\n      (elem1 \\<in> set(subsets1) \\<and> elem2 \\<in> set(subsets2) \\<and> elem = ((fst elem1) @ (map ((+) ?n) (fst elem2)), (snd elem1) @ (map ((+) ?n) (snd elem2)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R (length qs1) subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) (length qs1)) (fst elem2),\n            snd elem1 @ map ((+) (length qs1)) (snd elem2)))", "using subsets_smash_property_R"], ["proof (prove)\nusing this:\n  \\<forall>elem.\n     List.member (subsets_smash_R ?n ?subsets1.0 ?subsets2.0)\n      elem \\<longrightarrow>\n     (\\<exists>elem1 elem2.\n         elem1 \\<in> set ?subsets1.0 \\<and>\n         elem2 \\<in> set ?subsets2.0 \\<and>\n         elem =\n         (fst elem1 @ map ((+) ?n) (fst elem2),\n          snd elem1 @ map ((+) ?n) (snd elem2)))\n\ngoal (1 subgoal):\n 1. \\<forall>elem.\n       List.member (subsets_smash_R (length qs1) subsets1 subsets2)\n        elem \\<longrightarrow>\n       (\\<exists>elem1 elem2.\n           elem1 \\<in> set subsets1 \\<and>\n           elem2 \\<in> set subsets2 \\<and>\n           elem =\n           (fst elem1 @ map ((+) (length qs1)) (fst elem2),\n            snd elem1 @ map ((+) (length qs1)) (snd elem2)))", "by blast"], ["proof (state)\nthis:\n  \\<forall>elem.\n     List.member (subsets_smash_R (length qs1) subsets1 subsets2)\n      elem \\<longrightarrow>\n     (\\<exists>elem1 elem2.\n         elem1 \\<in> set subsets1 \\<and>\n         elem2 \\<in> set subsets2 \\<and>\n         elem =\n         (fst elem1 @ map ((+) (length qs1)) (fst elem2),\n          snd elem1 @ map ((+) (length qs1)) (snd elem2)))\n\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "have h2: \"\\<forall>elem1 elem2. (elem1 \\<in> set subsets1 \\<and> elem2 \\<in> set subsets2) \\<longrightarrow> list_constr ((fst elem1) @ map ((+) (length qs1)) (fst elem2)) (length (qs1 @ qs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>elem1 elem2.\n       elem1 \\<in> set subsets1 \\<and>\n       elem2 \\<in> set subsets2 \\<longrightarrow>\n       list_constr (fst elem1 @ map ((+) (length qs1)) (fst elem2))\n        (length (qs1 @ qs2))", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (a @ map ((+) (length qs1)) aa)\n                          (length qs1 + length qs2)", "fix elem1 b elem2 ba"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (a @ map ((+) (length qs1)) aa)\n                          (length qs1 + length qs2)", "assume e1: \"(elem1, b) \\<in> set subsets1\""], ["proof (state)\nthis:\n  (elem1, b) \\<in> set subsets1\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (a @ map ((+) (length qs1)) aa)\n                          (length qs1 + length qs2)", "assume e2: \"(elem2, ba) \\<in> set subsets2\""], ["proof (state)\nthis:\n  (elem2, ba) \\<in> set subsets2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (a @ map ((+) (length qs1)) aa)\n                          (length qs1 + length qs2)", "have h1: \"list_constr elem1  (length qs1 + length qs2) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1 + length qs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1 + length qs2)", "have h1: \"list_constr elem1  (length qs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1)", "using e1 well_def_subsets1"], ["proof (prove)\nusing this:\n  (elem1, b) \\<in> set subsets1\n  all_list_constr_R subsets1 (length qs1)\n\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1)", "unfolding all_list_constr_R_def"], ["proof (prove)\nusing this:\n  (elem1, b) \\<in> set subsets1\n  \\<forall>x.\n     List.member subsets1 x \\<longrightarrow>\n     list_constr (fst x) (length qs1) \\<and>\n     list_constr (snd x) (length qs1)\n\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(elem1, b) \\<in> set subsets1;\n     \\<forall>a b.\n        List.member subsets1 (a, b) \\<longrightarrow>\n        list_constr a (length qs1) \\<and>\n        list_constr b (length qs1)\\<rbrakk>\n    \\<Longrightarrow> list_constr elem1 (length qs1)", "by (simp add: in_set_member)"], ["proof (state)\nthis:\n  list_constr elem1 (length qs1)\n\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1 + length qs2)", "then"], ["proof (chain)\npicking this:\n  list_constr elem1 (length qs1)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_constr elem1 (length qs1)\n\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1 + length qs2)", "unfolding list_constr_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x < length qs1) elem1\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x < length qs1 + length qs2) elem1", "by (simp add: list.pred_mono_strong)"], ["proof (state)\nthis:\n  list_constr elem1 (length qs1 + length qs2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_constr elem1 (length qs1 + length qs2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (a @ map ((+) (length qs1)) aa)\n                          (length qs1 + length qs2)", "have h2: \"list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)", "have h1: \"list_constr elem2  (length qs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr elem2 (length qs2)", "using e2 well_def_subsets2"], ["proof (prove)\nusing this:\n  (elem2, ba) \\<in> set subsets2\n  all_list_constr_R subsets2 (length qs2)\n\ngoal (1 subgoal):\n 1. list_constr elem2 (length qs2)", "unfolding all_list_constr_R_def"], ["proof (prove)\nusing this:\n  (elem2, ba) \\<in> set subsets2\n  \\<forall>x.\n     List.member subsets2 x \\<longrightarrow>\n     list_constr (fst x) (length qs2) \\<and>\n     list_constr (snd x) (length qs2)\n\ngoal (1 subgoal):\n 1. list_constr elem2 (length qs2)", "by (simp add: in_set_member)"], ["proof (state)\nthis:\n  list_constr elem2 (length qs2)\n\ngoal (1 subgoal):\n 1. list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)", "then"], ["proof (chain)\npicking this:\n  list_constr elem2 (length qs2)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_constr elem2 (length qs2)\n\ngoal (1 subgoal):\n 1. list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)", "unfolding list_constr_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x < length qs2) elem2\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x < length qs1 + length qs2)\n     (map ((+) (length qs1)) elem2)", "by (simp add: list_all_length)"], ["proof (state)\nthis:\n  list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (a @ map ((+) (length qs1)) aa)\n                          (length qs1 + length qs2)", "show \"list_constr (elem1 @ map ((+) (length qs1)) elem2) (length qs1 + length qs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (elem1 @ map ((+) (length qs1)) elem2)\n     (length qs1 + length qs2)", "using h1 h2 list_constr_append"], ["proof (prove)\nusing this:\n  list_constr elem1 (length qs1 + length qs2)\n  list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)\n  list_constr ?a ?n \\<and> list_constr ?b ?n \\<longrightarrow>\n  list_constr (?a @ ?b) ?n\n\ngoal (1 subgoal):\n 1. list_constr (elem1 @ map ((+) (length qs1)) elem2)\n     (length qs1 + length qs2)", "by blast"], ["proof (state)\nthis:\n  list_constr (elem1 @ map ((+) (length qs1)) elem2)\n   (length qs1 + length qs2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>elem1 elem2.\n     elem1 \\<in> set subsets1 \\<and>\n     elem2 \\<in> set subsets2 \\<longrightarrow>\n     list_constr (fst elem1 @ map ((+) (length qs1)) (fst elem2))\n      (length (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "have h3: \"\\<forall>elem1 elem2. (elem1 \\<in> set subsets1 \\<and> elem2 \\<in> set subsets2) \\<longrightarrow> list_constr ((snd elem1) @ map ((+) (length qs1)) (snd elem2)) (length (qs1 @ qs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>elem1 elem2.\n       elem1 \\<in> set subsets1 \\<and>\n       elem2 \\<in> set subsets2 \\<longrightarrow>\n       list_constr (snd elem1 @ map ((+) (length qs1)) (snd elem2))\n        (length (qs1 @ qs2))", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (b @ map ((+) (length qs1)) ba)\n                          (length qs1 + length qs2)", "fix elem1 b elem2 ba"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (b @ map ((+) (length qs1)) ba)\n                          (length qs1 + length qs2)", "assume e1: \"(b, elem1) \\<in> set subsets1\""], ["proof (state)\nthis:\n  (b, elem1) \\<in> set subsets1\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (b @ map ((+) (length qs1)) ba)\n                          (length qs1 + length qs2)", "assume e2: \"(ba, elem2) \\<in> set subsets2\""], ["proof (state)\nthis:\n  (ba, elem2) \\<in> set subsets2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (b @ map ((+) (length qs1)) ba)\n                          (length qs1 + length qs2)", "have h1: \"list_constr elem1  (length qs1 + length qs2) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1 + length qs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1 + length qs2)", "have h1: \"list_constr elem1  (length qs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1)", "using e1 well_def_subsets1"], ["proof (prove)\nusing this:\n  (b, elem1) \\<in> set subsets1\n  all_list_constr_R subsets1 (length qs1)\n\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1)", "unfolding all_list_constr_R_def"], ["proof (prove)\nusing this:\n  (b, elem1) \\<in> set subsets1\n  \\<forall>x.\n     List.member subsets1 x \\<longrightarrow>\n     list_constr (fst x) (length qs1) \\<and>\n     list_constr (snd x) (length qs1)\n\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(b, elem1) \\<in> set subsets1;\n     \\<forall>a b.\n        List.member subsets1 (a, b) \\<longrightarrow>\n        list_constr a (length qs1) \\<and>\n        list_constr b (length qs1)\\<rbrakk>\n    \\<Longrightarrow> list_constr elem1 (length qs1)", "by (simp add: in_set_member)"], ["proof (state)\nthis:\n  list_constr elem1 (length qs1)\n\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1 + length qs2)", "then"], ["proof (chain)\npicking this:\n  list_constr elem1 (length qs1)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_constr elem1 (length qs1)\n\ngoal (1 subgoal):\n 1. list_constr elem1 (length qs1 + length qs2)", "unfolding list_constr_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x < length qs1) elem1\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x < length qs1 + length qs2) elem1", "by (simp add: list.pred_mono_strong)"], ["proof (state)\nthis:\n  list_constr elem1 (length qs1 + length qs2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_constr elem1 (length qs1 + length qs2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (b @ map ((+) (length qs1)) ba)\n                          (length qs1 + length qs2)", "have h2: \"list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)", "have h1: \"list_constr elem2  (length qs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr elem2 (length qs2)", "using e2 well_def_subsets2"], ["proof (prove)\nusing this:\n  (ba, elem2) \\<in> set subsets2\n  all_list_constr_R subsets2 (length qs2)\n\ngoal (1 subgoal):\n 1. list_constr elem2 (length qs2)", "unfolding all_list_constr_R_def"], ["proof (prove)\nusing this:\n  (ba, elem2) \\<in> set subsets2\n  \\<forall>x.\n     List.member subsets2 x \\<longrightarrow>\n     list_constr (fst x) (length qs2) \\<and>\n     list_constr (snd x) (length qs2)\n\ngoal (1 subgoal):\n 1. list_constr elem2 (length qs2)", "by (simp add: in_set_member)"], ["proof (state)\nthis:\n  list_constr elem2 (length qs2)\n\ngoal (1 subgoal):\n 1. list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)", "then"], ["proof (chain)\npicking this:\n  list_constr elem2 (length qs2)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_constr elem2 (length qs2)\n\ngoal (1 subgoal):\n 1. list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)", "unfolding list_constr_def"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x < length qs2) elem2\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x < length qs1 + length qs2)\n     (map ((+) (length qs1)) elem2)", "by (simp add: list_all_length)"], ["proof (state)\nthis:\n  list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set subsets1;\n        (aa, ba) \\<in> set subsets2\\<rbrakk>\n       \\<Longrightarrow> list_constr (b @ map ((+) (length qs1)) ba)\n                          (length qs1 + length qs2)", "show \"list_constr (elem1 @ map ((+) (length qs1)) elem2) (length qs1 + length qs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (elem1 @ map ((+) (length qs1)) elem2)\n     (length qs1 + length qs2)", "using h1 h2 list_constr_append"], ["proof (prove)\nusing this:\n  list_constr elem1 (length qs1 + length qs2)\n  list_constr (map ((+) (length qs1)) elem2) (length qs1 + length qs2)\n  list_constr ?a ?n \\<and> list_constr ?b ?n \\<longrightarrow>\n  list_constr (?a @ ?b) ?n\n\ngoal (1 subgoal):\n 1. list_constr (elem1 @ map ((+) (length qs1)) elem2)\n     (length qs1 + length qs2)", "by blast"], ["proof (state)\nthis:\n  list_constr (elem1 @ map ((+) (length qs1)) elem2)\n   (length qs1 + length qs2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>elem1 elem2.\n     elem1 \\<in> set subsets1 \\<and>\n     elem2 \\<in> set subsets2 \\<longrightarrow>\n     list_constr (snd elem1 @ map ((+) (length qs1)) (snd elem2))\n      (length (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "using h1 h2 h3"], ["proof (prove)\nusing this:\n  \\<forall>elem.\n     List.member (subsets_smash_R (length qs1) subsets1 subsets2)\n      elem \\<longrightarrow>\n     (\\<exists>elem1 elem2.\n         elem1 \\<in> set subsets1 \\<and>\n         elem2 \\<in> set subsets2 \\<and>\n         elem =\n         (fst elem1 @ map ((+) (length qs1)) (fst elem2),\n          snd elem1 @ map ((+) (length qs1)) (snd elem2)))\n  \\<forall>elem1 elem2.\n     elem1 \\<in> set subsets1 \\<and>\n     elem2 \\<in> set subsets2 \\<longrightarrow>\n     list_constr (fst elem1 @ map ((+) (length qs1)) (fst elem2))\n      (length (qs1 @ qs2))\n  \\<forall>elem1 elem2.\n     elem1 \\<in> set subsets1 \\<and>\n     elem2 \\<in> set subsets2 \\<longrightarrow>\n     list_constr (snd elem1 @ map ((+) (length qs1)) (snd elem2))\n      (length (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "unfolding all_list_constr_def"], ["proof (prove)\nusing this:\n  \\<forall>elem.\n     List.member (subsets_smash_R (length qs1) subsets1 subsets2)\n      elem \\<longrightarrow>\n     (\\<exists>elem1 elem2.\n         elem1 \\<in> set subsets1 \\<and>\n         elem2 \\<in> set subsets2 \\<and>\n         elem =\n         (fst elem1 @ map ((+) (length qs1)) (fst elem2),\n          snd elem1 @ map ((+) (length qs1)) (snd elem2)))\n  \\<forall>elem1 elem2.\n     elem1 \\<in> set subsets1 \\<and>\n     elem2 \\<in> set subsets2 \\<longrightarrow>\n     list_constr (fst elem1 @ map ((+) (length qs1)) (fst elem2))\n      (length (qs1 @ qs2))\n  \\<forall>elem1 elem2.\n     elem1 \\<in> set subsets1 \\<and>\n     elem2 \\<in> set subsets2 \\<longrightarrow>\n     list_constr (snd elem1 @ map ((+) (length qs1)) (snd elem2))\n      (length (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "by (metis all_list_constr_R_def fst_conv snd_conv)"], ["proof (state)\nthis:\n  all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n   (length (qs1 @ qs2))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Consistent Sign Assignments Preserved When Smashing\""], ["", "lemma subset_helper_R:\n  fixes p:: \"real poly\"\n  fixes qs1 qs2 :: \"real poly list\"\n  fixes signs1 signs2 :: \"rat list list\"\n  shows \"\\<forall> x \\<in> set (characterize_consistent_signs_at_roots p (qs1 @ qs2)). \n        \\<exists> x1 \\<in> set (characterize_consistent_signs_at_roots p qs1). \n        \\<exists> x2 \\<in> set (characterize_consistent_signs_at_roots p qs2).\n        x = x1@x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p\n                         (qs1 @ qs2)).\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (characterize_consistent_signs_at_roots p\n                     (qs1 @ qs2)) \\<Longrightarrow>\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (characterize_consistent_signs_at_roots p\n                     (qs1 @ qs2)) \\<Longrightarrow>\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "assume  x_in: \"x \\<in> set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\""], ["proof (state)\nthis:\n  x \\<in> set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (characterize_consistent_signs_at_roots p\n                     (qs1 @ qs2)) \\<Longrightarrow>\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "have x_in_csv: \"x \\<in> set(map (consistent_sign_vec (qs1 @ qs2)) (characterize_root_list_p p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (map (consistent_sign_vec (qs1 @ qs2))\n                  (characterize_root_list_p p))", "using x_in"], ["proof (prove)\nusing this:\n  x \\<in> set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. x \\<in> set (map (consistent_sign_vec (qs1 @ qs2))\n                  (characterize_root_list_p p))", "unfolding characterize_consistent_signs_at_roots_def"], ["proof (prove)\nusing this:\n  x \\<in> set (remdups\n                (map (signs_at (qs1 @ qs2)) (characterize_root_list_p p)))\n\ngoal (1 subgoal):\n 1. x \\<in> set (map (consistent_sign_vec (qs1 @ qs2))\n                  (characterize_root_list_p p))", "by (smt (z3) consistent_sign_vec_def map_eq_conv o_apply set_remdups signs_at_def squash_def)"], ["proof (state)\nthis:\n  x \\<in> set (map (consistent_sign_vec (qs1 @ qs2))\n                (characterize_root_list_p p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (characterize_consistent_signs_at_roots p\n                     (qs1 @ qs2)) \\<Longrightarrow>\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "have csv_hyp: \"\\<forall>r. consistent_sign_vec (qs1 @ qs2) r = (consistent_sign_vec qs1 r)@(consistent_sign_vec qs2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r.\n       consistent_sign_vec (qs1 @ qs2) r =\n       consistent_sign_vec qs1 r @ consistent_sign_vec qs2 r", "unfolding consistent_sign_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r.\n       map (\\<lambda>q.\n               if 0 < poly q r then 1 else if poly q r = 0 then 0 else - 1)\n        (qs1 @ qs2) =\n       map (\\<lambda>q.\n               if 0 < poly q r then 1 else if poly q r = 0 then 0 else - 1)\n        qs1 @\n       map (\\<lambda>q.\n               if 0 < poly q r then 1 else if poly q r = 0 then 0 else - 1)\n        qs2", "by auto"], ["proof (state)\nthis:\n  \\<forall>r.\n     consistent_sign_vec (qs1 @ qs2) r =\n     consistent_sign_vec qs1 r @ consistent_sign_vec qs2 r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (characterize_consistent_signs_at_roots p\n                     (qs1 @ qs2)) \\<Longrightarrow>\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "have exr_iff: \"(\\<exists>r \\<in> set (characterize_root_list_p p). x = consistent_sign_vec (qs1 @ qs2) r) \\<longleftrightarrow> (\\<exists>r \\<in> set (characterize_root_list_p p). x = (consistent_sign_vec qs1 r)@(consistent_sign_vec qs2 r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r\\<in>set (characterize_root_list_p p).\n        x = consistent_sign_vec (qs1 @ qs2) r) =\n    (\\<exists>r\\<in>set (characterize_root_list_p p).\n        x = consistent_sign_vec qs1 r @ consistent_sign_vec qs2 r)", "using csv_hyp"], ["proof (prove)\nusing this:\n  \\<forall>r.\n     consistent_sign_vec (qs1 @ qs2) r =\n     consistent_sign_vec qs1 r @ consistent_sign_vec qs2 r\n\ngoal (1 subgoal):\n 1. (\\<exists>r\\<in>set (characterize_root_list_p p).\n        x = consistent_sign_vec (qs1 @ qs2) r) =\n    (\\<exists>r\\<in>set (characterize_root_list_p p).\n        x = consistent_sign_vec qs1 r @ consistent_sign_vec qs2 r)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>r\\<in>set (characterize_root_list_p p).\n      x = consistent_sign_vec (qs1 @ qs2) r) =\n  (\\<exists>r\\<in>set (characterize_root_list_p p).\n      x = consistent_sign_vec qs1 r @ consistent_sign_vec qs2 r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (characterize_consistent_signs_at_roots p\n                     (qs1 @ qs2)) \\<Longrightarrow>\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "have exr: \"x \\<in> set(map (consistent_sign_vec (qs1 @ qs2)) (characterize_root_list_p p)) \\<longrightarrow> (\\<exists>r \\<in> set (characterize_root_list_p p). x = consistent_sign_vec (qs1 @ qs2) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (map (consistent_sign_vec (qs1 @ qs2))\n                  (characterize_root_list_p p)) \\<longrightarrow>\n    (\\<exists>r\\<in>set (characterize_root_list_p p).\n        x = consistent_sign_vec (qs1 @ qs2) r)", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (map (consistent_sign_vec (qs1 @ qs2))\n                (characterize_root_list_p p)) \\<longrightarrow>\n  (\\<exists>r\\<in>set (characterize_root_list_p p).\n      x = consistent_sign_vec (qs1 @ qs2) r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (characterize_consistent_signs_at_roots p\n                     (qs1 @ qs2)) \\<Longrightarrow>\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "have mem_list1: \"\\<forall> r \\<in> set (characterize_root_list_p p). (consistent_sign_vec qs1 r) \\<in> set(map (consistent_sign_vec qs1) (characterize_root_list_p p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set (characterize_root_list_p p).\n       consistent_sign_vec qs1 r\n       \\<in> set (map (consistent_sign_vec qs1)\n                   (characterize_root_list_p p))", "by simp"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set (characterize_root_list_p p).\n     consistent_sign_vec qs1 r\n     \\<in> set (map (consistent_sign_vec qs1) (characterize_root_list_p p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (characterize_consistent_signs_at_roots p\n                     (qs1 @ qs2)) \\<Longrightarrow>\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "have mem_list2: \"\\<forall> r \\<in> set (characterize_root_list_p p). (consistent_sign_vec qs2 r) \\<in> set(map (consistent_sign_vec qs2) (characterize_root_list_p p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set (characterize_root_list_p p).\n       consistent_sign_vec qs2 r\n       \\<in> set (map (consistent_sign_vec qs2)\n                   (characterize_root_list_p p))", "by simp"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set (characterize_root_list_p p).\n     consistent_sign_vec qs2 r\n     \\<in> set (map (consistent_sign_vec qs2) (characterize_root_list_p p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (characterize_consistent_signs_at_roots p\n                     (qs1 @ qs2)) \\<Longrightarrow>\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "then"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set (characterize_root_list_p p).\n     consistent_sign_vec qs2 r\n     \\<in> set (map (consistent_sign_vec qs2) (characterize_root_list_p p))", "show \"\\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n            \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p qs2). x = x1 @ x2\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set (characterize_root_list_p p).\n     consistent_sign_vec qs2 r\n     \\<in> set (map (consistent_sign_vec qs2) (characterize_root_list_p p))\n\ngoal (1 subgoal):\n 1. \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n       \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p qs2).\n          x = x1 @ x2", "using x_in_csv exr mem_list1 mem_list2 characterize_consistent_signs_at_roots_def exr_iff"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set (characterize_root_list_p p).\n     consistent_sign_vec qs2 r\n     \\<in> set (map (consistent_sign_vec qs2) (characterize_root_list_p p))\n  x \\<in> set (map (consistent_sign_vec (qs1 @ qs2))\n                (characterize_root_list_p p))\n  x \\<in> set (map (consistent_sign_vec (qs1 @ qs2))\n                (characterize_root_list_p p)) \\<longrightarrow>\n  (\\<exists>r\\<in>set (characterize_root_list_p p).\n      x = consistent_sign_vec (qs1 @ qs2) r)\n  \\<forall>r\\<in>set (characterize_root_list_p p).\n     consistent_sign_vec qs1 r\n     \\<in> set (map (consistent_sign_vec qs1) (characterize_root_list_p p))\n  \\<forall>r\\<in>set (characterize_root_list_p p).\n     consistent_sign_vec qs2 r\n     \\<in> set (map (consistent_sign_vec qs2) (characterize_root_list_p p))\n  characterize_consistent_signs_at_roots ?p ?qs =\n  remdups (map (signs_at ?qs) (characterize_root_list_p ?p))\n  (\\<exists>r\\<in>set (characterize_root_list_p p).\n      x = consistent_sign_vec (qs1 @ qs2) r) =\n  (\\<exists>r\\<in>set (characterize_root_list_p p).\n      x = consistent_sign_vec qs1 r @ consistent_sign_vec qs2 r)\n\ngoal (1 subgoal):\n 1. \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n       \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p qs2).\n          x = x1 @ x2", "using imageE image_eqI map_append set_map set_remdups signs_at_def x_in"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set (characterize_root_list_p p).\n     consistent_sign_vec qs2 r\n     \\<in> set (map (consistent_sign_vec qs2) (characterize_root_list_p p))\n  x \\<in> set (map (consistent_sign_vec (qs1 @ qs2))\n                (characterize_root_list_p p))\n  x \\<in> set (map (consistent_sign_vec (qs1 @ qs2))\n                (characterize_root_list_p p)) \\<longrightarrow>\n  (\\<exists>r\\<in>set (characterize_root_list_p p).\n      x = consistent_sign_vec (qs1 @ qs2) r)\n  \\<forall>r\\<in>set (characterize_root_list_p p).\n     consistent_sign_vec qs1 r\n     \\<in> set (map (consistent_sign_vec qs1) (characterize_root_list_p p))\n  \\<forall>r\\<in>set (characterize_root_list_p p).\n     consistent_sign_vec qs2 r\n     \\<in> set (map (consistent_sign_vec qs2) (characterize_root_list_p p))\n  characterize_consistent_signs_at_roots ?p ?qs =\n  remdups (map (signs_at ?qs) (characterize_root_list_p ?p))\n  (\\<exists>r\\<in>set (characterize_root_list_p p).\n      x = consistent_sign_vec (qs1 @ qs2) r) =\n  (\\<exists>r\\<in>set (characterize_root_list_p p).\n      x = consistent_sign_vec qs1 r @ consistent_sign_vec qs2 r)\n  \\<lbrakk>?b \\<in> ?f ` ?A;\n   \\<And>x.\n      \\<lbrakk>?b = ?f x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>?b = ?f ?x; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> ?f ` ?A\n  map ?f (?xs @ ?ys) = map ?f ?xs @ map ?f ?ys\n  set (map ?f ?xs) = ?f ` set ?xs\n  set (remdups ?xs) = set ?xs\n  signs_at ?qs ?x \\<equiv> map (squash \\<circ> (\\<lambda>q. poly q ?x)) ?qs\n  x \\<in> set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n       \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p qs2).\n          x = x1 @ x2", "by auto"], ["proof (state)\nthis:\n  \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n     \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p qs2).\n        x = x1 @ x2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subset_step_R:  \n  fixes p:: \"real poly\"\n  fixes qs1 qs2 :: \"real poly list\"\n  fixes signs1 signs2 :: \"rat list list\"\n  assumes csa1: \"set (characterize_consistent_signs_at_roots p qs1) \\<subseteq> set (signs1)\"\n  assumes csa2: \"set (characterize_consistent_signs_at_roots p qs2) \\<subseteq> set (signs2)\"  \n  shows \"set (characterize_consistent_signs_at_roots p\n          (qs1 @ qs2))\n    \\<subseteq> set (signs_smash signs1 signs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (signs_smash signs1 signs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (signs_smash signs1 signs2)", "have h0: \"\\<forall> x \\<in> set (characterize_consistent_signs_at_roots p (qs1 @ qs2)). \\<exists> x1 \\<in> set (characterize_consistent_signs_at_roots p qs1). \\<exists> x2 \\<in> set (characterize_consistent_signs_at_roots p qs2).\n     (x = x1@x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p\n                         (qs1 @ qs2)).\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "using subset_helper_R[of p qs1 qs2]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n        \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p qs2).\n           x = x1 @ x2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p\n                         (qs1 @ qs2)).\n       \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n          \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p\n                                qs2).\n             x = x1 @ x2", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n        \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p qs2).\n           x = x1 @ x2\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (signs_smash signs1 signs2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n        \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p qs2).\n           x = x1 @ x2", "have \"\\<forall>x \\<in> set (characterize_consistent_signs_at_roots p (qs1 @ qs2)). \n          x \\<in> set (signs_smash (characterize_consistent_signs_at_roots p qs1) \n          (characterize_consistent_signs_at_roots p qs2))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n        \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p qs2).\n           x = x1 @ x2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p\n                         (qs1 @ qs2)).\n       x \\<in> set (signs_smash\n                     (characterize_consistent_signs_at_roots p qs1)\n                     (characterize_consistent_signs_at_roots p qs2))", "unfolding signs_smash_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots p qs1).\n        \\<exists>x2\\<in>set (characterize_consistent_signs_at_roots p qs2).\n           x = x1 @ x2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p\n                         (qs1 @ qs2)).\n       x \\<in> set (concat\n                     (map (\\<lambda>l1.\n                              map ((@) l1)\n                               (characterize_consistent_signs_at_roots p\n                                 qs2))\n                       (characterize_consistent_signs_at_roots p qs1)))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set (characterize_consistent_signs_at_roots p\n                                     (qs1 @ qs2)).\n                   \\<exists>x1\\<in>set (characterize_consistent_signs_at_roots\n   p qs1).\n                      \\<exists>x2\\<in>set\n (characterize_consistent_signs_at_roots p qs2).\n                         x = x1 @ x2;\n        x \\<in> set (characterize_consistent_signs_at_roots p\n                      (qs1 @ qs2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>set\n    (characterize_consistent_signs_at_roots p qs1).\n                            x \\<in> (@) xa `\n                                    set (characterize_consistent_signs_at_roots\n    p qs2)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     x \\<in> set (signs_smash (characterize_consistent_signs_at_roots p qs1)\n                   (characterize_consistent_signs_at_roots p qs2))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (signs_smash signs1 signs2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     x \\<in> set (signs_smash (characterize_consistent_signs_at_roots p qs1)\n                   (characterize_consistent_signs_at_roots p qs2))", "have \"\\<forall>x \\<in> set (characterize_consistent_signs_at_roots p\n          (qs1 @ qs2)). x \\<in> set (signs_smash signs1 signs2)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     x \\<in> set (signs_smash (characterize_consistent_signs_at_roots p qs1)\n                   (characterize_consistent_signs_at_roots p qs2))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p\n                         (qs1 @ qs2)).\n       x \\<in> set (signs_smash signs1 signs2)", "using csa1 csa2 subset_smash_signs[of _ signs1 _ signs2]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     x \\<in> set (signs_smash (characterize_consistent_signs_at_roots p qs1)\n                   (characterize_consistent_signs_at_roots p qs2))\n  set (characterize_consistent_signs_at_roots p qs1) \\<subseteq> set signs1\n  set (characterize_consistent_signs_at_roots p qs2) \\<subseteq> set signs2\n  \\<lbrakk>set ?a1.0 \\<subseteq> set signs1;\n   set ?b1.0 \\<subseteq> set signs2\\<rbrakk>\n  \\<Longrightarrow> set (signs_smash ?a1.0 ?b1.0)\n                    \\<subseteq> set (signs_smash signs1 signs2)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p\n                         (qs1 @ qs2)).\n       x \\<in> set (signs_smash signs1 signs2)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set (characterize_consistent_signs_at_roots p\n                                     (qs1 @ qs2)).\n                   x \\<in> set (signs_smash\n                                 (characterize_consistent_signs_at_roots p\n                                   qs1)\n                                 (characterize_consistent_signs_at_roots p\n                                   qs2));\n        set (characterize_consistent_signs_at_roots p qs1)\n        \\<subseteq> set signs1;\n        set (characterize_consistent_signs_at_roots p qs2)\n        \\<subseteq> set signs2;\n        \\<And>a1 b1.\n           \\<lbrakk>set a1 \\<subseteq> set signs1;\n            set b1 \\<subseteq> set signs2\\<rbrakk>\n           \\<Longrightarrow> set (signs_smash a1 b1)\n                             \\<subseteq> set (signs_smash signs1 signs2);\n        x \\<in> set (characterize_consistent_signs_at_roots p\n                      (qs1 @ qs2))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (signs_smash signs1 signs2)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     x \\<in> set (signs_smash signs1 signs2)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (signs_smash signs1 signs2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (characterize_consistent_signs_at_roots p (qs1 @ qs2)).\n     x \\<in> set (signs_smash signs1 signs2)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (signs_smash signs1 signs2)", "by blast"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (signs_smash signs1 signs2)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Main Results\""], ["", "lemma dim_row_matrix_A_R[simp]:\n  shows \"dim_row (matrix_A_R signs subsets) = length subsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (M_mat_R signs subsets) = length subsets", "unfolding matrix_A_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat_of_rows_list (length signs) (map (mtx_row_R signs) subsets)) =\n    length subsets", "by auto"], ["", "lemma dim_col_matrix_A_R[simp]:\n  shows \"dim_col (matrix_A_R signs subsets) = length signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (M_mat_R signs subsets) = length signs", "unfolding matrix_A_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (mat_of_rows_list (length signs) (map (mtx_row_R signs) subsets)) =\n    length signs", "by auto"], ["", "lemma length_subsets_smash_R:\n  shows\n    \"length (subsets_smash_R n subs1 subs2) = length subs1 * length subs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (subsets_smash_R n subs1 subs2) = length subs1 * length subs2", "unfolding subsets_smash_R_def length_concat"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map length\n       (map (\\<lambda>l1.\n                map (\\<lambda>l2.\n                        (fst l1 @ map ((+) n) (fst l2),\n                         snd l1 @ map ((+) n) (snd l2)))\n                 subs2)\n         subs1)) =\n    length subs1 * length subs2", "by (auto simp add: o_def sum_list_triv)"], ["", "lemma z_append_R:\n  fixes xs:: \"(nat list * nat list)\"\n  assumes \"\\<And>i. i \\<in> set (fst xs) \\<Longrightarrow> i  < length as\"\n  assumes \"\\<And>i. i \\<in> set (snd xs) \\<Longrightarrow> i  < length as\"\n  shows \"z_R ((fst xs) @ (map ((+) (length as)) (fst ys)), (snd xs) @ (map ((+) (length as)) (snd ys))) (as @ bs) = z_R xs as * z_R ys bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R (fst xs @ map ((+) (length as)) (fst ys),\n         snd xs @ map ((+) (length as)) (snd ys))\n     (as @ bs) =\n    z_R xs as * z_R ys bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z_R (fst xs @ map ((+) (length as)) (fst ys),\n         snd xs @ map ((+) (length as)) (snd ys))\n     (as @ bs) =\n    z_R xs as * z_R ys bs", "have 1: \"map ((!) (as @ bs)) (fst xs) = map ((!) as) (fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (as @ bs)) (fst xs) = map ((!) as) (fst xs)", "unfolding list_eq_iff_nth_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ((!) (as @ bs)) (fst xs)) =\n    length (map ((!) as) (fst xs)) \\<and>\n    (\\<forall>i<length (map ((!) (as @ bs)) (fst xs)).\n        map ((!) (as @ bs)) (fst xs) ! i = map ((!) as) (fst xs) ! i)", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> set (fst xs) \\<Longrightarrow> ?i < length as\n  ?i \\<in> set (snd xs) \\<Longrightarrow> ?i < length as\n\ngoal (1 subgoal):\n 1. length (map ((!) (as @ bs)) (fst xs)) =\n    length (map ((!) as) (fst xs)) \\<and>\n    (\\<forall>i<length (map ((!) (as @ bs)) (fst xs)).\n        map ((!) (as @ bs)) (fst xs) ! i = map ((!) as) (fst xs) ! i)", "by (auto simp add:nth_append)"], ["proof (state)\nthis:\n  map ((!) (as @ bs)) (fst xs) = map ((!) as) (fst xs)\n\ngoal (1 subgoal):\n 1. z_R (fst xs @ map ((+) (length as)) (fst ys),\n         snd xs @ map ((+) (length as)) (snd ys))\n     (as @ bs) =\n    z_R xs as * z_R ys bs", "have 2: \"map ((!) (as @ bs) \\<circ> (+) (length as)) (fst ys) = map ((!) bs) (fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (as @ bs) \\<circ> (+) (length as)) (fst ys) =\n    map ((!) bs) (fst ys)", "unfolding list_eq_iff_nth_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ((!) (as @ bs) \\<circ> (+) (length as)) (fst ys)) =\n    length (map ((!) bs) (fst ys)) \\<and>\n    (\\<forall>i<length\n                 (map ((!) (as @ bs) \\<circ> (+) (length as)) (fst ys)).\n        map ((!) (as @ bs) \\<circ> (+) (length as)) (fst ys) ! i =\n        map ((!) bs) (fst ys) ! i)", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> set (fst xs) \\<Longrightarrow> ?i < length as\n  ?i \\<in> set (snd xs) \\<Longrightarrow> ?i < length as\n\ngoal (1 subgoal):\n 1. length (map ((!) (as @ bs) \\<circ> (+) (length as)) (fst ys)) =\n    length (map ((!) bs) (fst ys)) \\<and>\n    (\\<forall>i<length\n                 (map ((!) (as @ bs) \\<circ> (+) (length as)) (fst ys)).\n        map ((!) (as @ bs) \\<circ> (+) (length as)) (fst ys) ! i =\n        map ((!) bs) (fst ys) ! i)", "by auto"], ["proof (state)\nthis:\n  map ((!) (as @ bs) \\<circ> (+) (length as)) (fst ys) =\n  map ((!) bs) (fst ys)\n\ngoal (1 subgoal):\n 1. z_R (fst xs @ map ((+) (length as)) (fst ys),\n         snd xs @ map ((+) (length as)) (snd ys))\n     (as @ bs) =\n    z_R xs as * z_R ys bs", "have 3: \"map ((!) (as @ bs)) (snd xs) = map ((!) as) (snd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (as @ bs)) (snd xs) = map ((!) as) (snd xs)", "unfolding list_eq_iff_nth_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ((!) (as @ bs)) (snd xs)) =\n    length (map ((!) as) (snd xs)) \\<and>\n    (\\<forall>i<length (map ((!) (as @ bs)) (snd xs)).\n        map ((!) (as @ bs)) (snd xs) ! i = map ((!) as) (snd xs) ! i)", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> set (fst xs) \\<Longrightarrow> ?i < length as\n  ?i \\<in> set (snd xs) \\<Longrightarrow> ?i < length as\n\ngoal (1 subgoal):\n 1. length (map ((!) (as @ bs)) (snd xs)) =\n    length (map ((!) as) (snd xs)) \\<and>\n    (\\<forall>i<length (map ((!) (as @ bs)) (snd xs)).\n        map ((!) (as @ bs)) (snd xs) ! i = map ((!) as) (snd xs) ! i)", "by (auto simp add:nth_append)"], ["proof (state)\nthis:\n  map ((!) (as @ bs)) (snd xs) = map ((!) as) (snd xs)\n\ngoal (1 subgoal):\n 1. z_R (fst xs @ map ((+) (length as)) (fst ys),\n         snd xs @ map ((+) (length as)) (snd ys))\n     (as @ bs) =\n    z_R xs as * z_R ys bs", "have 4: \"map ((!) (as @ bs) \\<circ> (+) (length as)) (snd ys) = map ((!) bs) (snd ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (as @ bs) \\<circ> (+) (length as)) (snd ys) =\n    map ((!) bs) (snd ys)", "unfolding list_eq_iff_nth_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ((!) (as @ bs) \\<circ> (+) (length as)) (snd ys)) =\n    length (map ((!) bs) (snd ys)) \\<and>\n    (\\<forall>i<length\n                 (map ((!) (as @ bs) \\<circ> (+) (length as)) (snd ys)).\n        map ((!) (as @ bs) \\<circ> (+) (length as)) (snd ys) ! i =\n        map ((!) bs) (snd ys) ! i)", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> set (fst xs) \\<Longrightarrow> ?i < length as\n  ?i \\<in> set (snd xs) \\<Longrightarrow> ?i < length as\n\ngoal (1 subgoal):\n 1. length (map ((!) (as @ bs) \\<circ> (+) (length as)) (snd ys)) =\n    length (map ((!) bs) (snd ys)) \\<and>\n    (\\<forall>i<length\n                 (map ((!) (as @ bs) \\<circ> (+) (length as)) (snd ys)).\n        map ((!) (as @ bs) \\<circ> (+) (length as)) (snd ys) ! i =\n        map ((!) bs) (snd ys) ! i)", "by auto"], ["proof (state)\nthis:\n  map ((!) (as @ bs) \\<circ> (+) (length as)) (snd ys) =\n  map ((!) bs) (snd ys)\n\ngoal (1 subgoal):\n 1. z_R (fst xs @ map ((+) (length as)) (fst ys),\n         snd xs @ map ((+) (length as)) (snd ys))\n     (as @ bs) =\n    z_R xs as * z_R ys bs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R (fst xs @ map ((+) (length as)) (fst ys),\n         snd xs @ map ((+) (length as)) (snd ys))\n     (as @ bs) =\n    z_R xs as * z_R ys bs", "unfolding z_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list\n     (map ((!) (map_sgas (as @ bs)))\n       (fst (fst xs @ map ((+) (length as)) (fst ys),\n             snd xs @ map ((+) (length as)) (snd ys)))) *\n    prod_list\n     (map ((!) (as @ bs))\n       (snd (fst xs @ map ((+) (length as)) (fst ys),\n             snd xs @ map ((+) (length as)) (snd ys)))) =\n    prod_list (map ((!) (map_sgas as)) (fst xs)) *\n    prod_list (map ((!) as) (snd xs)) *\n    (prod_list (map ((!) (map_sgas bs)) (fst ys)) *\n     prod_list (map ((!) bs) (snd ys)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas (as @ bs))) (fst xs)) *\n    prod_list\n     (map ((!) (map_sgas (as @ bs)) \\<circ> (+) (length as)) (fst ys)) *\n    (prod_list (map ((!) (as @ bs)) (snd xs)) *\n     prod_list (map ((!) (as @ bs) \\<circ> (+) (length as)) (snd ys))) =\n    prod_list (map ((!) (map_sgas as)) (fst xs)) *\n    prod_list (map ((!) as) (snd xs)) *\n    (prod_list (map ((!) (map_sgas bs)) (fst ys)) *\n     prod_list (map ((!) bs) (snd ys)))", "unfolding 1 2 3 4"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) (map_sgas (as @ bs))) (fst xs)) *\n    prod_list\n     (map ((!) (map_sgas (as @ bs)) \\<circ> (+) (length as)) (fst ys)) *\n    (prod_list (map ((!) as) (snd xs)) *\n     prod_list (map ((!) bs) (snd ys))) =\n    prod_list (map ((!) (map_sgas as)) (fst xs)) *\n    prod_list (map ((!) as) (snd xs)) *\n    (prod_list (map ((!) (map_sgas bs)) (fst ys)) *\n     prod_list (map ((!) bs) (snd ys)))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> (!) as ` set (snd xs);\n     prod_list (map ((!) (map_sgas (as @ bs))) (fst xs)) *\n     prod_list\n      (map ((!) (map_sgas (as @ bs)) \\<circ> (+) (length as))\n        (fst ys)) \\<noteq>\n     prod_list (map ((!) (map_sgas as)) (fst xs)) *\n     prod_list (map ((!) (map_sgas bs)) (fst ys))\\<rbrakk>\n    \\<Longrightarrow> 0 \\<in> (!) bs ` set (snd ys)", "by (smt (z3) assms(1) comp_apply length_map map_append map_eq_conv map_sgas_def nth_append nth_append_length_plus)"], ["proof (state)\nthis:\n  z_R (fst xs @ map ((+) (length as)) (fst ys),\n       snd xs @ map ((+) (length as)) (snd ys))\n   (as @ bs) =\n  z_R xs as * z_R ys bs\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Shows that the matrix of a smashed system is the Kronecker product of the matrices of the two\n  systems being combined *)"], ["", "lemma matrix_construction_is_kronecker_product_R: \n  fixes qs1 :: \"real poly list\"\n  fixes subs1 subs2 :: \"(nat list*nat list) list\"\n  fixes signs1 signs2 :: \"rat list list\"\n    (* n1 is the number of polynomials in the \"1\" sets *)\n  assumes \"\\<And>l i. l \\<in> set subs1 \\<Longrightarrow> (i \\<in> set (fst l) \\<or> i \\<in> set (snd l)) \\<Longrightarrow> i < n1\"\n  assumes \"\\<And>j. j \\<in> set signs1 \\<Longrightarrow> length j = n1\"\n  shows \"(matrix_A_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2)) =\n    kronecker_product (matrix_A_R signs1 subs1) (matrix_A_R signs2 subs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2) =\n    kronecker_product (M_mat_R signs1 subs1) (M_mat_R signs2 subs2)", "unfolding mat_eq_iff dim_row_matrix_A_R dim_col_matrix_A_R\n    length_subsets_smash_R length_signs_smash dim_kronecker"], ["proof (prove)\ngoal (1 subgoal):\n 1. length subs1 * length subs2 = length subs1 * length subs2 \\<and>\n    length signs1 * length signs2 = length signs1 * length signs2 \\<and>\n    (\\<forall>i j.\n        i < length subs1 * length subs2 \\<longrightarrow>\n        j < length signs1 * length signs2 \\<longrightarrow>\n        M_mat_R (signs_smash signs1 signs2)\n         (subsets_smash_R n1 subs1 subs2) $$\n        (i, j) =\n        kronecker_product (M_mat_R signs1 subs1) (M_mat_R signs2 subs2) $$\n        (i, j))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "assume i: \"i < length subs1 * length subs2\""], ["proof (state)\nthis:\n  i < length subs1 * length subs2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "assume j: \"j < length signs1 * length signs2\""], ["proof (state)\nthis:\n  j < length signs1 * length signs2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "have ld: \"i div length subs2 < length subs1\"\n    \"j div length signs2 < length signs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i div length subs2 < length subs1 &&&\n    j div length signs2 < length signs1", "using i j less_mult_imp_div_less"], ["proof (prove)\nusing this:\n  i < length subs1 * length subs2\n  j < length signs1 * length signs2\n  ?m < ?i * ?n \\<Longrightarrow> ?m div ?n < ?i\n\ngoal (1 subgoal):\n 1. i div length subs2 < length subs1 &&&\n    j div length signs2 < length signs1", "by auto"], ["proof (state)\nthis:\n  i div length subs2 < length subs1\n  j div length signs2 < length signs1\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "have lm: \"i mod length subs2 < length subs2\"\n    \"j mod length signs2 < length signs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i mod length subs2 < length subs2 &&&\n    j mod length signs2 < length signs2", "using i j less_mult_imp_mod_less"], ["proof (prove)\nusing this:\n  i < length subs1 * length subs2\n  j < length signs1 * length signs2\n  ?m < ?n * ?i \\<Longrightarrow> ?m mod ?i < ?i\n\ngoal (1 subgoal):\n 1. i mod length subs2 < length subs2 &&&\n    j mod length signs2 < length signs2", "by auto"], ["proof (state)\nthis:\n  i mod length subs2 < length subs2\n  j mod length signs2 < length signs2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "have n1: \"n1 = length (signs1 ! (j div length signs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n1 = length (signs1 ! (j div length signs2))", "using assms(2) ld(2) nth_mem"], ["proof (prove)\nusing this:\n  ?j \\<in> set signs1 \\<Longrightarrow> length ?j = n1\n  j div length signs2 < length signs1\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. n1 = length (signs1 ! (j div length signs2))", "by blast"], ["proof (state)\nthis:\n  n1 = length (signs1 ! (j div length signs2))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "have 1: \"matrix_A_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2) $$ (i, j) =\n    z_R (subsets_smash_R n1 subs1 subs2 ! i) (signs_smash signs1 signs2 ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2) $$\n    (i, j) =\n    z_R (subsets_smash_R n1 subs1 subs2 ! i) (signs_smash signs1 signs2 ! j)", "unfolding mat_of_rows_list_def matrix_A_R_def mtx_row_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length\n          (map (\\<lambda>index_list.\n                   map (z_R index_list) (signs_smash signs1 signs2))\n            (subsets_smash_R n1 subs1 subs2)))\n     (length (signs_smash signs1 signs2))\n     (\\<lambda>(i, y).\n         map (\\<lambda>index_list.\n                 map (z_R index_list) (signs_smash signs1 signs2))\n          (subsets_smash_R n1 subs1 subs2) !\n         i !\n         y) $$\n    (i, j) =\n    z_R (subsets_smash_R n1 subs1 subs2 ! i) (signs_smash signs1 signs2 ! j)", "using i j"], ["proof (prove)\nusing this:\n  i < length subs1 * length subs2\n  j < length signs1 * length signs2\n\ngoal (1 subgoal):\n 1. mat (length\n          (map (\\<lambda>index_list.\n                   map (z_R index_list) (signs_smash signs1 signs2))\n            (subsets_smash_R n1 subs1 subs2)))\n     (length (signs_smash signs1 signs2))\n     (\\<lambda>(i, y).\n         map (\\<lambda>index_list.\n                 map (z_R index_list) (signs_smash signs1 signs2))\n          (subsets_smash_R n1 subs1 subs2) !\n         i !\n         y) $$\n    (i, j) =\n    z_R (subsets_smash_R n1 subs1 subs2 ! i) (signs_smash signs1 signs2 ! j)", "by (auto simp add: length_signs_smash length_subsets_smash_R)"], ["proof (state)\nthis:\n  M_mat_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2) $$\n  (i, j) =\n  z_R (subsets_smash_R n1 subs1 subs2 ! i) (signs_smash signs1 signs2 ! j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "have 2: \" ... = z_R ((fst (subs1 ! (i div length subs2)) @ map ((+) n1) (fst(subs2 ! (i mod length subs2)))),\n  (snd (subs1 ! (i div length subs2)) @ map ((+) n1) (snd (subs2 ! (i mod length subs2)))))\n     (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R (subsets_smash_R n1 subs1 subs2 ! i)\n     (signs_smash signs1 signs2 ! j) =\n    z_R (fst (subs1 ! (i div length subs2)) @\n         map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n         snd (subs1 ! (i div length subs2)) @\n         map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n     (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2))", "unfolding signs_smash_def subsets_smash_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R (concat\n          (map (\\<lambda>l1.\n                   map (\\<lambda>l2.\n                           (fst l1 @ map ((+) n1) (fst l2),\n                            snd l1 @ map ((+) n1) (snd l2)))\n                    subs2)\n            subs1) !\n         i)\n     (concat (map (\\<lambda>l1. map ((@) l1) signs2) signs1) ! j) =\n    z_R (fst (subs1 ! (i div length subs2)) @\n         map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n         snd (subs1 ! (i div length subs2)) @\n         map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n     (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2))", "apply (subst length_eq_concat)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>l1.\n                            map (\\<lambda>l2.\n                                    (fst l1 @ map ((+) n1) (fst l2),\n                                     snd l1 @ map ((+) n1) (snd l2)))\n                             subs2)\n                     subs1) \\<Longrightarrow>\n       length x = ?n\n 2. i < ?n *\n        length\n         (map (\\<lambda>l1.\n                  map (\\<lambda>l2.\n                          (fst l1 @ map ((+) n1) (fst l2),\n                           snd l1 @ map ((+) n1) (snd l2)))\n                   subs2)\n           subs1)\n 3. z_R (map (\\<lambda>l1.\n                 map (\\<lambda>l2.\n                         (fst l1 @ map ((+) n1) (fst l2),\n                          snd l1 @ map ((+) n1) (snd l2)))\n                  subs2)\n          subs1 !\n         (i div ?n) !\n         (i mod ?n))\n     (concat (map (\\<lambda>l1. map ((@) l1) signs2) signs1) ! j) =\n    z_R (fst (subs1 ! (i div length subs2)) @\n         map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n         snd (subs1 ! (i div length subs2)) @\n         map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n     (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2))", "using i"], ["proof (prove)\nusing this:\n  i < length subs1 * length subs2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> set (map (\\<lambda>l1.\n                            map (\\<lambda>l2.\n                                    (fst l1 @ map ((+) n1) (fst l2),\n                                     snd l1 @ map ((+) n1) (snd l2)))\n                             subs2)\n                     subs1) \\<Longrightarrow>\n       length x = ?n\n 2. i < ?n *\n        length\n         (map (\\<lambda>l1.\n                  map (\\<lambda>l2.\n                          (fst l1 @ map ((+) n1) (fst l2),\n                           snd l1 @ map ((+) n1) (snd l2)))\n                   subs2)\n           subs1)\n 3. z_R (map (\\<lambda>l1.\n                 map (\\<lambda>l2.\n                         (fst l1 @ map ((+) n1) (fst l2),\n                          snd l1 @ map ((+) n1) (snd l2)))\n                  subs2)\n          subs1 !\n         (i div ?n) !\n         (i mod ?n))\n     (concat (map (\\<lambda>l1. map ((@) l1) signs2) signs1) ! j) =\n    z_R (fst (subs1 ! (i div length subs2)) @\n         map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n         snd (subs1 ! (i div length subs2)) @\n         map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n     (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2))", "apply (auto simp add: mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length subs1 * length subs2 \\<Longrightarrow>\n    z_R (map (\\<lambda>l1.\n                 map (\\<lambda>l2.\n                         (fst l1 @ map ((+) n1) (fst l2),\n                          snd l1 @ map ((+) n1) (snd l2)))\n                  subs2)\n          subs1 !\n         (i div length subs2) !\n         (i mod length subs2))\n     (concat (map (\\<lambda>l1. map ((@) l1) signs2) signs1) ! j) =\n    z_R (fst (subs1 ! (i div length subs2)) @\n         map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n         snd (subs1 ! (i div length subs2)) @\n         map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n     (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2))", "apply (subst length_eq_concat)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>i < length subs1 * length subs2;\n        x \\<in> set (map (\\<lambda>l1. map ((@) l1) signs2) signs1)\\<rbrakk>\n       \\<Longrightarrow> length x = ?n11\n 2. i < length subs1 * length subs2 \\<Longrightarrow>\n    j < ?n11 * length (map (\\<lambda>l1. map ((@) l1) signs2) signs1)\n 3. i < length subs1 * length subs2 \\<Longrightarrow>\n    z_R (map (\\<lambda>l1.\n                 map (\\<lambda>l2.\n                         (fst l1 @ map ((+) n1) (fst l2),\n                          snd l1 @ map ((+) n1) (snd l2)))\n                  subs2)\n          subs1 !\n         (i div length subs2) !\n         (i mod length subs2))\n     (map (\\<lambda>l1. map ((@) l1) signs2) signs1 ! (j div ?n11) !\n      (j mod ?n11)) =\n    z_R (fst (subs1 ! (i div length subs2)) @\n         map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n         snd (subs1 ! (i div length subs2)) @\n         map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n     (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2))", "using j"], ["proof (prove)\nusing this:\n  j < length signs1 * length signs2\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>i < length subs1 * length subs2;\n        x \\<in> set (map (\\<lambda>l1. map ((@) l1) signs2) signs1)\\<rbrakk>\n       \\<Longrightarrow> length x = ?n11\n 2. i < length subs1 * length subs2 \\<Longrightarrow>\n    j < ?n11 * length (map (\\<lambda>l1. map ((@) l1) signs2) signs1)\n 3. i < length subs1 * length subs2 \\<Longrightarrow>\n    z_R (map (\\<lambda>l1.\n                 map (\\<lambda>l2.\n                         (fst l1 @ map ((+) n1) (fst l2),\n                          snd l1 @ map ((+) n1) (snd l2)))\n                  subs2)\n          subs1 !\n         (i div length subs2) !\n         (i mod length subs2))\n     (map (\\<lambda>l1. map ((@) l1) signs2) signs1 ! (j div ?n11) !\n      (j mod ?n11)) =\n    z_R (fst (subs1 ! (i div length subs2)) @\n         map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n         snd (subs1 ! (i div length subs2)) @\n         map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n     (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2))", "apply (auto simp add: mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length subs1 * length subs2;\n     j < length signs1 * length signs2\\<rbrakk>\n    \\<Longrightarrow> z_R (map (\\<lambda>l1.\n                                   map (\\<lambda>l2.\n     (fst l1 @ map ((+) n1) (fst l2), snd l1 @ map ((+) n1) (snd l2)))\n                                    subs2)\n                            subs1 !\n                           (i div length subs2) !\n                           (i mod length subs2))\n                       (map (\\<lambda>l1. map ((@) l1) signs2) signs1 !\n                        (j div length signs2) !\n                        (j mod length signs2)) =\n                      z_R (fst (subs1 ! (i div length subs2)) @\n                           map ((+) n1)\n                            (fst (subs2 ! (i mod length subs2))),\n                           snd (subs1 ! (i div length subs2)) @\n                           map ((+) n1)\n                            (snd (subs2 ! (i mod length subs2))))\n                       (signs1 ! (j div length signs2) @\n                        signs2 ! (j mod length signs2))", "using ld lm"], ["proof (prove)\nusing this:\n  i div length subs2 < length subs1\n  j div length signs2 < length signs1\n  i mod length subs2 < length subs2\n  j mod length signs2 < length signs2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length subs1 * length subs2;\n     j < length signs1 * length signs2\\<rbrakk>\n    \\<Longrightarrow> z_R (map (\\<lambda>l1.\n                                   map (\\<lambda>l2.\n     (fst l1 @ map ((+) n1) (fst l2), snd l1 @ map ((+) n1) (snd l2)))\n                                    subs2)\n                            subs1 !\n                           (i div length subs2) !\n                           (i mod length subs2))\n                       (map (\\<lambda>l1. map ((@) l1) signs2) signs1 !\n                        (j div length signs2) !\n                        (j mod length signs2)) =\n                      z_R (fst (subs1 ! (i div length subs2)) @\n                           map ((+) n1)\n                            (fst (subs2 ! (i mod length subs2))),\n                           snd (subs1 ! (i div length subs2)) @\n                           map ((+) n1)\n                            (snd (subs2 ! (i mod length subs2))))\n                       (signs1 ! (j div length signs2) @\n                        signs2 ! (j mod length signs2))", "by auto"], ["proof (state)\nthis:\n  z_R (subsets_smash_R n1 subs1 subs2 ! i) (signs_smash signs1 signs2 ! j) =\n  z_R (fst (subs1 ! (i div length subs2)) @\n       map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n       snd (subs1 ! (i div length subs2)) @\n       map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n   (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "have 3: \"... =\n  z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n  z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R (fst (subs1 ! (i div length subs2)) @\n         map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n         snd (subs1 ! (i div length subs2)) @\n         map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n     (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2)) =\n    z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n    z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))", "unfolding n1"], ["proof (prove)\ngoal (1 subgoal):\n 1. z_R (fst (subs1 ! (i div length subs2)) @\n         map ((+) (length (signs1 ! (j div length signs2))))\n          (fst (subs2 ! (i mod length subs2))),\n         snd (subs1 ! (i div length subs2)) @\n         map ((+) (length (signs1 ! (j div length signs2))))\n          (snd (subs2 ! (i mod length subs2))))\n     (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2)) =\n    z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n    z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))", "apply (subst z_append_R)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ia.\n       ia \\<in> set (fst (subs1 ! (i div length subs2))) \\<Longrightarrow>\n       ia < length (signs1 ! (j div length signs2))\n 2. \\<And>ia.\n       ia \\<in> set (snd (subs1 ! (i div length subs2))) \\<Longrightarrow>\n       ia < length (signs1 ! (j div length signs2))\n 3. z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n    z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2)) =\n    z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n    z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))", "apply (auto simp add: n1[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia \\<in> set (fst (subs1 ! (i div length subs2))) \\<Longrightarrow>\n       ia < n1\n 2. \\<And>ia.\n       ia \\<in> set (snd (subs1 ! (i div length subs2))) \\<Longrightarrow>\n       ia < n1", "using assms(1) ld(1) nth_mem"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<in> set subs1;\n   ?i \\<in> set (fst ?l) \\<or> ?i \\<in> set (snd ?l)\\<rbrakk>\n  \\<Longrightarrow> ?i < n1\n  i div length subs2 < length subs1\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia \\<in> set (fst (subs1 ! (i div length subs2))) \\<Longrightarrow>\n       ia < n1\n 2. \\<And>ia.\n       ia \\<in> set (snd (subs1 ! (i div length subs2))) \\<Longrightarrow>\n       ia < n1", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> set (snd (subs1 ! (i div length subs2))) \\<Longrightarrow>\n       ia < n1", "using assms(1) ld(1) nth_mem"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<in> set subs1;\n   ?i \\<in> set (fst ?l) \\<or> ?i \\<in> set (snd ?l)\\<rbrakk>\n  \\<Longrightarrow> ?i < n1\n  i div length subs2 < length subs1\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> set (snd (subs1 ! (i div length subs2))) \\<Longrightarrow>\n       ia < n1", "by blast"], ["proof (state)\nthis:\n  z_R (fst (subs1 ! (i div length subs2)) @\n       map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n       snd (subs1 ! (i div length subs2)) @\n       map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n   (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2)) =\n  z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n  z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "have 4: \"kronecker_product (matrix_A_R signs1 subs1) (matrix_A_R signs2 subs2) $$ (i,j) =\n    z_R (subs1 ! (i div length subs2))\n     (signs1 ! (j div length signs2)) *\n    z_R (subs2 ! (i mod length subs2))\n     (signs2 ! (j mod length signs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kronecker_product (M_mat_R signs1 subs1) (M_mat_R signs2 subs2) $$\n    (i, j) =\n    z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n    z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))", "unfolding kronecker_product_def matrix_A_R_def mat_of_rows_list_def mtx_row_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ra = dim_row\n               (mat (length\n                      (map (\\<lambda>index_list.\n                               map (z_R index_list) signs1)\n                        subs1))\n                 (length signs1)\n                 (\\<lambda>(i, y).\n                     map (\\<lambda>index_list. map (z_R index_list) signs1)\n                      subs1 !\n                     i !\n                     y));\n         ca = dim_col\n               (mat (length\n                      (map (\\<lambda>index_list.\n                               map (z_R index_list) signs1)\n                        subs1))\n                 (length signs1)\n                 (\\<lambda>(i, y).\n                     map (\\<lambda>index_list. map (z_R index_list) signs1)\n                      subs1 !\n                     i !\n                     y));\n         rb = dim_row\n               (mat (length\n                      (map (\\<lambda>index_list.\n                               map (z_R index_list) signs2)\n                        subs2))\n                 (length signs2)\n                 (\\<lambda>(i, y).\n                     map (\\<lambda>index_list. map (z_R index_list) signs2)\n                      subs2 !\n                     i !\n                     y));\n         cb = dim_col\n               (mat (length\n                      (map (\\<lambda>index_list.\n                               map (z_R index_list) signs2)\n                        subs2))\n                 (length signs2)\n                 (\\<lambda>(i, y).\n                     map (\\<lambda>index_list. map (z_R index_list) signs2)\n                      subs2 !\n                     i !\n                     y))\n     in mat (ra * rb) (ca * cb)\n         (\\<lambda>(i, j).\n             mat (length\n                   (map (\\<lambda>index_list. map (z_R index_list) signs1)\n                     subs1))\n              (length signs1)\n              (\\<lambda>(i, y).\n                  map (\\<lambda>index_list. map (z_R index_list) signs1)\n                   subs1 !\n                  i !\n                  y) $$\n             (i div rb, j div cb) *\n             mat (length\n                   (map (\\<lambda>index_list. map (z_R index_list) signs2)\n                     subs2))\n              (length signs2)\n              (\\<lambda>(i, y).\n                  map (\\<lambda>index_list. map (z_R index_list) signs2)\n                   subs2 !\n                  i !\n                  y) $$\n             (i mod rb, j mod cb))) $$\n    (i, j) =\n    z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n    z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))", "using i j"], ["proof (prove)\nusing this:\n  i < length subs1 * length subs2\n  j < length signs1 * length signs2\n\ngoal (1 subgoal):\n 1. (let ra = dim_row\n               (mat (length\n                      (map (\\<lambda>index_list.\n                               map (z_R index_list) signs1)\n                        subs1))\n                 (length signs1)\n                 (\\<lambda>(i, y).\n                     map (\\<lambda>index_list. map (z_R index_list) signs1)\n                      subs1 !\n                     i !\n                     y));\n         ca = dim_col\n               (mat (length\n                      (map (\\<lambda>index_list.\n                               map (z_R index_list) signs1)\n                        subs1))\n                 (length signs1)\n                 (\\<lambda>(i, y).\n                     map (\\<lambda>index_list. map (z_R index_list) signs1)\n                      subs1 !\n                     i !\n                     y));\n         rb = dim_row\n               (mat (length\n                      (map (\\<lambda>index_list.\n                               map (z_R index_list) signs2)\n                        subs2))\n                 (length signs2)\n                 (\\<lambda>(i, y).\n                     map (\\<lambda>index_list. map (z_R index_list) signs2)\n                      subs2 !\n                     i !\n                     y));\n         cb = dim_col\n               (mat (length\n                      (map (\\<lambda>index_list.\n                               map (z_R index_list) signs2)\n                        subs2))\n                 (length signs2)\n                 (\\<lambda>(i, y).\n                     map (\\<lambda>index_list. map (z_R index_list) signs2)\n                      subs2 !\n                     i !\n                     y))\n     in mat (ra * rb) (ca * cb)\n         (\\<lambda>(i, j).\n             mat (length\n                   (map (\\<lambda>index_list. map (z_R index_list) signs1)\n                     subs1))\n              (length signs1)\n              (\\<lambda>(i, y).\n                  map (\\<lambda>index_list. map (z_R index_list) signs1)\n                   subs1 !\n                  i !\n                  y) $$\n             (i div rb, j div cb) *\n             mat (length\n                   (map (\\<lambda>index_list. map (z_R index_list) signs2)\n                     subs2))\n              (length signs2)\n              (\\<lambda>(i, y).\n                  map (\\<lambda>index_list. map (z_R index_list) signs2)\n                   subs2 !\n                  i !\n                  y) $$\n             (i mod rb, j mod cb))) $$\n    (i, j) =\n    z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n    z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))", "apply (auto simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length subs1 * length subs2;\n     j < length signs1 * length signs2\\<rbrakk>\n    \\<Longrightarrow> mat (length subs1) (length signs1)\n                       (\\<lambda>(i, y).\n                           map (\\<lambda>index_list.\n                                   map (z_R index_list) signs1)\n                            subs1 !\n                           i !\n                           y) $$\n                      (i div length subs2, j div length signs2) *\n                      mat (length subs2) (length signs2)\n                       (\\<lambda>(i, y).\n                           map (\\<lambda>index_list.\n                                   map (z_R index_list) signs2)\n                            subs2 !\n                           i !\n                           y) $$\n                      (i mod length subs2, j mod length signs2) =\n                      z_R (subs1 ! (i div length subs2))\n                       (signs1 ! (j div length signs2)) *\n                      z_R (subs2 ! (i mod length subs2))\n                       (signs2 ! (j mod length signs2))", "apply (subst index_mat(1)[OF ld])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length subs1 * length subs2;\n     j < length signs1 * length signs2\\<rbrakk>\n    \\<Longrightarrow> (case (i div length subs2, j div length signs2) of\n                       (i, x) \\<Rightarrow>\n                         map (\\<lambda>index_list.\n                                 map (z_R index_list) signs1)\n                          subs1 !\n                         i !\n                         x) *\n                      mat (length subs2) (length signs2)\n                       (\\<lambda>(i, y).\n                           map (\\<lambda>index_list.\n                                   map (z_R index_list) signs2)\n                            subs2 !\n                           i !\n                           y) $$\n                      (i mod length subs2, j mod length signs2) =\n                      z_R (subs1 ! (i div length subs2))\n                       (signs1 ! (j div length signs2)) *\n                      z_R (subs2 ! (i mod length subs2))\n                       (signs2 ! (j mod length signs2))", "apply (subst index_mat(1)[OF lm])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length subs1 * length subs2;\n     j < length signs1 * length signs2\\<rbrakk>\n    \\<Longrightarrow> (case (i div length subs2, j div length signs2) of\n                       (i, x) \\<Rightarrow>\n                         map (\\<lambda>index_list.\n                                 map (z_R index_list) signs1)\n                          subs1 !\n                         i !\n                         x) *\n                      (case (i mod length subs2, j mod length signs2) of\n                       (i, x) \\<Rightarrow>\n                         map (\\<lambda>index_list.\n                                 map (z_R index_list) signs2)\n                          subs2 !\n                         i !\n                         x) =\n                      z_R (subs1 ! (i div length subs2))\n                       (signs1 ! (j div length signs2)) *\n                      z_R (subs2 ! (i mod length subs2))\n                       (signs2 ! (j mod length signs2))", "using ld lm"], ["proof (prove)\nusing this:\n  i div length subs2 < length subs1\n  j div length signs2 < length signs1\n  i mod length subs2 < length subs2\n  j mod length signs2 < length signs2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length subs1 * length subs2;\n     j < length signs1 * length signs2\\<rbrakk>\n    \\<Longrightarrow> (case (i div length subs2, j div length signs2) of\n                       (i, x) \\<Rightarrow>\n                         map (\\<lambda>index_list.\n                                 map (z_R index_list) signs1)\n                          subs1 !\n                         i !\n                         x) *\n                      (case (i mod length subs2, j mod length signs2) of\n                       (i, x) \\<Rightarrow>\n                         map (\\<lambda>index_list.\n                                 map (z_R index_list) signs2)\n                          subs2 !\n                         i !\n                         x) =\n                      z_R (subs1 ! (i div length subs2))\n                       (signs1 ! (j div length signs2)) *\n                      z_R (subs2 ! (i mod length subs2))\n                       (signs2 ! (j mod length signs2))", "by auto"], ["proof (state)\nthis:\n  kronecker_product (M_mat_R signs1 subs1) (M_mat_R signs2 subs2) $$\n  (i, j) =\n  z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n  z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subs1 * length subs2;\n        j < length signs1 * length signs2\\<rbrakk>\n       \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                          (subsets_smash_R n1 subs1 subs2) $$\n                         (i, j) =\n                         kronecker_product (M_mat_R signs1 subs1)\n                          (M_mat_R signs2 subs2) $$\n                         (i, j)", "show \"matrix_A_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2) $$ (i, j) =\n        kronecker_product (matrix_A_R signs1 subs1) (matrix_A_R signs2 subs2) $$ (i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2) $$\n    (i, j) =\n    kronecker_product (M_mat_R signs1 subs1) (M_mat_R signs2 subs2) $$\n    (i, j)", "using 1 2 3 4"], ["proof (prove)\nusing this:\n  M_mat_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2) $$\n  (i, j) =\n  z_R (subsets_smash_R n1 subs1 subs2 ! i) (signs_smash signs1 signs2 ! j)\n  z_R (subsets_smash_R n1 subs1 subs2 ! i) (signs_smash signs1 signs2 ! j) =\n  z_R (fst (subs1 ! (i div length subs2)) @\n       map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n       snd (subs1 ! (i div length subs2)) @\n       map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n   (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2))\n  z_R (fst (subs1 ! (i div length subs2)) @\n       map ((+) n1) (fst (subs2 ! (i mod length subs2))),\n       snd (subs1 ! (i div length subs2)) @\n       map ((+) n1) (snd (subs2 ! (i mod length subs2))))\n   (signs1 ! (j div length signs2) @ signs2 ! (j mod length signs2)) =\n  z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n  z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))\n  kronecker_product (M_mat_R signs1 subs1) (M_mat_R signs2 subs2) $$\n  (i, j) =\n  z_R (subs1 ! (i div length subs2)) (signs1 ! (j div length signs2)) *\n  z_R (subs2 ! (i mod length subs2)) (signs2 ! (j mod length signs2))\n\ngoal (1 subgoal):\n 1. M_mat_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2) $$\n    (i, j) =\n    kronecker_product (M_mat_R signs1 subs1) (M_mat_R signs2 subs2) $$\n    (i, j)", "by auto"], ["proof (state)\nthis:\n  M_mat_R (signs_smash signs1 signs2) (subsets_smash_R n1 subs1 subs2) $$\n  (i, j) =\n  kronecker_product (M_mat_R signs1 subs1) (M_mat_R signs2 subs2) $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Given that two smaller systems satisfy some mild constraints, show that their combined system\n  (after smashing the signs and subsets) satisfies the matrix equation, and that the matrix of the\n  combined system is invertible. *)"], ["", "lemma inductive_step_R:\n  fixes p:: \"real poly\"\n  fixes qs1 qs2 :: \"real poly list\"\n  fixes subsets1 subsets2 :: \"(nat list*nat list) list\"\n  fixes signs1 signs2 :: \"rat list list\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes nontriv1: \"length qs1 > 0\"\n  assumes nontriv2: \"length qs2 > 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs1) signs1\"\n  assumes welldefined_signs2: \"well_def_signs (length qs2) signs2\"\n  assumes distinct_signs1: \"distinct signs1\"\n  assumes distinct_signs2: \"distinct signs2\"\n  assumes all_info1: \"set (characterize_consistent_signs_at_roots p qs1) \\<subseteq> set(signs1)\"\n  assumes all_info2: \"set (characterize_consistent_signs_at_roots p qs2) \\<subseteq> set(signs2)\"\n  assumes welldefined_subsets1: \"all_list_constr_R (subsets1) (length qs1)\"\n  assumes welldefined_subsets2: \"all_list_constr_R (subsets2) (length qs2)\"\n  assumes invertibleMtx1: \"invertible_mat (matrix_A_R signs1 subsets1)\"\n  assumes invertibleMtx2: \"invertible_mat (matrix_A_R signs2 subsets2)\"\n  shows \"satisfy_equation_R p (qs1@qs2) (subsets_smash_R (length qs1) subsets1 subsets2) (signs_smash signs1 signs2) \n        \\<and> invertible_mat (matrix_A_R (signs_smash signs1 signs2) (subsets_smash_R (length qs1) subsets1 subsets2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2) \\<and>\n    invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2) \\<and>\n    invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "have h1: \"invertible_mat (matrix_A_R (signs_smash signs1 signs2) (subsets_smash_R (length qs1) subsets1 subsets2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "using matrix_construction_is_kronecker_product_R\n      kronecker_invertible invertibleMtx1 invertibleMtx2\n      welldefined_subsets1 welldefined_subsets2"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>l i.\n              \\<lbrakk>l \\<in> set ?subs1.0;\n               i \\<in> set (fst l) \\<or> i \\<in> set (snd l)\\<rbrakk>\n              \\<Longrightarrow> i < ?n1.0;\n   \\<And>j.\n      j \\<in> set ?signs1.0 \\<Longrightarrow> length j = ?n1.0\\<rbrakk>\n  \\<Longrightarrow> M_mat_R (signs_smash ?signs1.0 ?signs2.0)\n                     (subsets_smash_R ?n1.0 ?subs1.0 ?subs2.0) =\n                    kronecker_product (M_mat_R ?signs1.0 ?subs1.0)\n                     (M_mat_R ?signs2.0 ?subs2.0)\n  \\<lbrakk>invertible_mat ?A; invertible_mat ?B\\<rbrakk>\n  \\<Longrightarrow> invertible_mat (kronecker_product ?A ?B)\n  invertible_mat (M_mat_R signs1 subsets1)\n  invertible_mat (M_mat_R signs2 subsets2)\n  all_list_constr_R subsets1 (length qs1)\n  all_list_constr_R subsets2 (length qs2)\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "unfolding all_list_constr_R_def list_constr_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>l i.\n              \\<lbrakk>l \\<in> set ?subs1.0;\n               i \\<in> set (fst l) \\<or> i \\<in> set (snd l)\\<rbrakk>\n              \\<Longrightarrow> i < ?n1.0;\n   \\<And>j.\n      j \\<in> set ?signs1.0 \\<Longrightarrow> length j = ?n1.0\\<rbrakk>\n  \\<Longrightarrow> M_mat_R (signs_smash ?signs1.0 ?signs2.0)\n                     (subsets_smash_R ?n1.0 ?subs1.0 ?subs2.0) =\n                    kronecker_product (M_mat_R ?signs1.0 ?subs1.0)\n                     (M_mat_R ?signs2.0 ?subs2.0)\n  \\<lbrakk>invertible_mat ?A; invertible_mat ?B\\<rbrakk>\n  \\<Longrightarrow> invertible_mat (kronecker_product ?A ?B)\n  invertible_mat (M_mat_R signs1 subsets1)\n  invertible_mat (M_mat_R signs2 subsets2)\n  \\<forall>x.\n     List.member subsets1 x \\<longrightarrow>\n     list_all (\\<lambda>x. x < length qs1) (fst x) \\<and>\n     list_all (\\<lambda>x. x < length qs1) (snd x)\n  \\<forall>x.\n     List.member subsets2 x \\<longrightarrow>\n     list_all (\\<lambda>x. x < length qs2) (fst x) \\<and>\n     list_all (\\<lambda>x. x < length qs2) (snd x)\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "using Ball_set in_set_member well_def_signs_def welldefined_signs1 in_set_conv_nth list_all_length"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>l i.\n              \\<lbrakk>l \\<in> set ?subs1.0;\n               i \\<in> set (fst l) \\<or> i \\<in> set (snd l)\\<rbrakk>\n              \\<Longrightarrow> i < ?n1.0;\n   \\<And>j.\n      j \\<in> set ?signs1.0 \\<Longrightarrow> length j = ?n1.0\\<rbrakk>\n  \\<Longrightarrow> M_mat_R (signs_smash ?signs1.0 ?signs2.0)\n                     (subsets_smash_R ?n1.0 ?subs1.0 ?subs2.0) =\n                    kronecker_product (M_mat_R ?signs1.0 ?subs1.0)\n                     (M_mat_R ?signs2.0 ?subs2.0)\n  \\<lbrakk>invertible_mat ?A; invertible_mat ?B\\<rbrakk>\n  \\<Longrightarrow> invertible_mat (kronecker_product ?A ?B)\n  invertible_mat (M_mat_R signs1 subsets1)\n  invertible_mat (M_mat_R signs2 subsets2)\n  \\<forall>x.\n     List.member subsets1 x \\<longrightarrow>\n     list_all (\\<lambda>x. x < length qs1) (fst x) \\<and>\n     list_all (\\<lambda>x. x < length qs1) (snd x)\n  \\<forall>x.\n     List.member subsets2 x \\<longrightarrow>\n     list_all (\\<lambda>x. x < length qs2) (fst x) \\<and>\n     list_all (\\<lambda>x. x < length qs2) (snd x)\n  Ball (set ?xs) ?P = list_all ?P ?xs\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  well_def_signs ?num_polys ?sign_conds \\<equiv>\n  \\<forall>signs\\<in>set ?sign_conds. length signs = ?num_polys\n  well_def_signs (length qs1) signs1\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n  list_all ?P ?xs = (\\<forall>n<length ?xs. ?P (?xs ! n))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>subs1 n1 signs1 signs2 subs2.\n                \\<lbrakk>\\<And>a b i.\n                            \\<lbrakk>(a, b) \\<in> set subs1;\n                             i \\<in> set a \\<or> i \\<in> set b\\<rbrakk>\n                            \\<Longrightarrow> i < n1;\n                 \\<And>j.\n                    j \\<in> set signs1 \\<Longrightarrow>\n                    length j = n1\\<rbrakk>\n                \\<Longrightarrow> M_mat_R (signs_smash signs1 signs2)\n                                   (subsets_smash_R n1 subs1 subs2) =\n                                  kronecker_product (M_mat_R signs1 subs1)\n                                   (M_mat_R signs2 subs2);\n     \\<And>A B.\n        \\<lbrakk>invertible_mat A; invertible_mat B\\<rbrakk>\n        \\<Longrightarrow> invertible_mat (kronecker_product A B);\n     invertible_mat (M_mat_R signs1 subsets1);\n     invertible_mat (M_mat_R signs2 subsets2);\n     \\<forall>a b.\n        List.member subsets1 (a, b) \\<longrightarrow>\n        list_all (\\<lambda>x. x < length qs1) a \\<and>\n        list_all (\\<lambda>x. x < length qs1) b;\n     \\<forall>a b.\n        List.member subsets2 (a, b) \\<longrightarrow>\n        list_all (\\<lambda>x. x < length qs2) a \\<and>\n        list_all (\\<lambda>x. x < length qs2) b;\n     \\<And>xs P. (\\<forall>x\\<in>set xs. P x) = list_all P xs;\n     \\<And>x xs. (x \\<in> set xs) = List.member xs x;\n     \\<And>num_polys sign_conds.\n        well_def_signs num_polys sign_conds \\<equiv>\n        \\<forall>signs\\<in>set sign_conds. length signs = num_polys;\n     \\<forall>signs\\<in>set signs1. length signs = length qs1;\n     \\<And>x xs. (x \\<in> set xs) = (\\<exists>i<length xs. xs ! i = x);\n     \\<And>P xs. list_all P xs = (\\<forall>n<length xs. P (xs ! n))\\<rbrakk>\n    \\<Longrightarrow> invertible_mat\n                       (M_mat_R (signs_smash signs1 signs2)\n                         (subsets_smash_R (length qs1) subsets1 subsets2))", "by (smt (z3) Ball_set kronecker_invertible member_def)"], ["proof (state)\nthis:\n  invertible_mat\n   (M_mat_R (signs_smash signs1 signs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2))\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2) \\<and>\n    invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "have h2a: \"distinct (signs_smash signs1 signs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (signs_smash signs1 signs2)", "using distinct_signs1 distinct_signs2 welldefined_signs1 welldefined_signs2 nontriv1 nontriv2 \n      distinct_step"], ["proof (prove)\nusing this:\n  distinct signs1\n  distinct signs2\n  well_def_signs (length qs1) signs1\n  well_def_signs (length qs2) signs2\n  0 < length qs1\n  0 < length qs2\n  \\<lbrakk>well_def_signs ?n1.0 ?signs1.0; well_def_signs ?n2.0 ?signs2.0;\n   distinct ?signs1.0; distinct ?signs2.0\\<rbrakk>\n  \\<Longrightarrow> distinct (signs_smash ?signs1.0 ?signs2.0)\n\ngoal (1 subgoal):\n 1. distinct (signs_smash signs1 signs2)", "by auto"], ["proof (state)\nthis:\n  distinct (signs_smash signs1 signs2)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2) \\<and>\n    invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "have h2c: \"all_list_constr_R ((subsets_smash_R (length qs1) subsets1 subsets2)) (length (qs1@qs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "using well_def_step_R\n      welldefined_subsets1 welldefined_subsets2"], ["proof (prove)\nusing this:\n  \\<lbrakk>all_list_constr_R ?subsets1.0 (length ?qs1.0);\n   all_list_constr_R ?subsets2.0 (length ?qs2.0)\\<rbrakk>\n  \\<Longrightarrow> all_list_constr_R\n                     (subsets_smash_R (length ?qs1.0) ?subsets1.0\n                       ?subsets2.0)\n                     (length (?qs1.0 @ ?qs2.0))\n  all_list_constr_R subsets1 (length qs1)\n  all_list_constr_R subsets2 (length qs2)\n\ngoal (1 subgoal):\n 1. all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n     (length (qs1 @ qs2))", "by blast"], ["proof (state)\nthis:\n  all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n   (length (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2) \\<and>\n    invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "have h2d: \"set (characterize_consistent_signs_at_roots p (qs1@qs2)) \\<subseteq> set(signs_smash signs1 signs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (signs_smash signs1 signs2)", "using subset_step_R all_info1 all_info2"], ["proof (prove)\nusing this:\n  \\<lbrakk>set (characterize_consistent_signs_at_roots ?p ?qs1.0)\n           \\<subseteq> set ?signs1.0;\n   set (characterize_consistent_signs_at_roots ?p ?qs2.0)\n   \\<subseteq> set ?signs2.0\\<rbrakk>\n  \\<Longrightarrow> set (characterize_consistent_signs_at_roots ?p\n                          (?qs1.0 @ ?qs2.0))\n                    \\<subseteq> set (signs_smash ?signs1.0 ?signs2.0)\n  set (characterize_consistent_signs_at_roots p qs1) \\<subseteq> set signs1\n  set (characterize_consistent_signs_at_roots p qs2) \\<subseteq> set signs2\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (signs_smash signs1 signs2)", "by simp"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (signs_smash signs1 signs2)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2) \\<and>\n    invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "have h2: \"satisfy_equation_R p (qs1@qs2) (subsets_smash_R (length qs1) subsets1 subsets2) (signs_smash signs1 signs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2)", "using matrix_equation_R[where p=\"p\", where qs=\"qs1@qs2\", where subsets = \"subsets_smash_R (length qs1) subsets1 subsets2\",\n        where signs = \"signs_smash signs1 signs2\"] \n        h2a h2c h2d"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; distinct (signs_smash signs1 signs2);\n   set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n   \\<subseteq> set (signs_smash signs1 signs2);\n   all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n    (length (qs1 @ qs2))\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R p (qs1 @ qs2)\n                     (subsets_smash_R (length qs1) subsets1 subsets2)\n                     (signs_smash signs1 signs2)\n  distinct (signs_smash signs1 signs2)\n  all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n   (length (qs1 @ qs2))\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (signs_smash signs1 signs2)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n             satisfy_equation_R p (qs1 @ qs2)\n              (subsets_smash_R (length qs1) subsets1 subsets2)\n              (signs_smash signs1 signs2);\n     distinct (signs_smash signs1 signs2);\n     all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n      (length qs1 + length qs2);\n     set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n     \\<subseteq> set (signs_smash signs1 signs2)\\<rbrakk>\n    \\<Longrightarrow> satisfy_equation_R p (qs1 @ qs2)\n                       (subsets_smash_R (length qs1) subsets1 subsets2)\n                       (signs_smash signs1 signs2)", "using nonzero"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n             satisfy_equation_R p (qs1 @ qs2)\n              (subsets_smash_R (length qs1) subsets1 subsets2)\n              (signs_smash signs1 signs2);\n     distinct (signs_smash signs1 signs2);\n     all_list_constr_R (subsets_smash_R (length qs1) subsets1 subsets2)\n      (length qs1 + length qs2);\n     set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n     \\<subseteq> set (signs_smash signs1 signs2)\\<rbrakk>\n    \\<Longrightarrow> satisfy_equation_R p (qs1 @ qs2)\n                       (subsets_smash_R (length qs1) subsets1 subsets2)\n                       (signs_smash signs1 signs2)", "by blast"], ["proof (state)\nthis:\n  satisfy_equation_R p (qs1 @ qs2)\n   (subsets_smash_R (length qs1) subsets1 subsets2)\n   (signs_smash signs1 signs2)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2) \\<and>\n    invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2) \\<and>\n    invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "using h1 h2"], ["proof (prove)\nusing this:\n  invertible_mat\n   (M_mat_R (signs_smash signs1 signs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2))\n  satisfy_equation_R p (qs1 @ qs2)\n   (subsets_smash_R (length qs1) subsets1 subsets2)\n   (signs_smash signs1 signs2)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)\n     (signs_smash signs1 signs2) \\<and>\n    invertible_mat\n     (M_mat_R (signs_smash signs1 signs2)\n       (subsets_smash_R (length qs1) subsets1 subsets2))", "by blast"], ["proof (state)\nthis:\n  satisfy_equation_R p (qs1 @ qs2)\n   (subsets_smash_R (length qs1) subsets1 subsets2)\n   (signs_smash signs1 signs2) \\<and>\n  invertible_mat\n   (M_mat_R (signs_smash signs1 signs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2))\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Reduction Step Proofs\""], ["", "(* Some definitions *)"], ["", "definition get_matrix_R:: \"(rat mat \\<times> ((nat list*nat list) list \\<times> rat list list)) \\<Rightarrow> rat mat\"\n  where \"get_matrix_R data = fst(data)\""], ["", "definition get_subsets_R:: \"(rat mat \\<times> ((nat list*nat list) list \\<times> rat list list)) \\<Rightarrow>  (nat list*nat list) list\"\n  where \"get_subsets_R data = fst(snd(data))\""], ["", "definition get_signs_R:: \"(rat mat \\<times> ((nat list*nat list) list \\<times> rat list list)) \\<Rightarrow> rat list list\"\n  where \"get_signs_R data = snd(snd(data))\""], ["", "definition reduction_signs_R:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> rat list list \\<Rightarrow> (nat list*nat list) list \\<Rightarrow> rat mat \\<Rightarrow> rat list list\" \n  where \"reduction_signs_R p qs signs subsets matr = \n    (take_indices signs (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets matr)))\""], ["", "definition reduction_subsets_R:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> rat list list \\<Rightarrow> (nat list*nat list) list \\<Rightarrow> rat mat \\<Rightarrow> (nat list*nat list) list\" \n  where \"reduction_subsets_R p qs signs subsets matr = \n    (take_indices subsets (rows_to_keep (reduce_mat_cols matr (solve_for_lhs_R p qs subsets matr))))\""], ["", "(* Some basic lemmas *)"], ["", "lemma reduction_signs_is_get_signs_R: \"reduction_signs_R p qs signs subsets m =  get_signs_R (reduce_system_R p (qs, (m, (subsets, signs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduction_signs_R p qs signs subsets m =\n    get_signs_R (reduce_system_R p (qs, m, subsets, signs))", "unfolding reduction_signs_R_def get_signs_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_indices signs\n     (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets m)) =\n    snd (snd (reduce_system_R p (qs, m, subsets, signs)))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_indices signs\n     (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets m)) =\n    snd (snd (let reduce_cols_A =\n                    take_cols_from_matrix m\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets m));\n                  rows_keep = rows_to_keep reduce_cols_A\n              in (take_rows_from_matrix reduce_cols_A rows_keep,\n                  take_indices subsets rows_keep,\n                  take_indices signs\n                   (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets m)))))", "using reduction_step_R.elims snd_conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>reduction_step_R ?x ?xa ?xb ?xc = ?y;\n   \\<And>A signs subsets lhs_vec.\n      \\<lbrakk>?x = A; ?xa = signs; ?xb = subsets; ?xc = lhs_vec;\n       ?y =\n       (let reduce_cols_A = reduce_mat_cols A lhs_vec;\n            rows_keep = rows_to_keep reduce_cols_A\n        in (take_rows_from_matrix reduce_cols_A rows_keep,\n            take_indices subsets rows_keep,\n            take_indices signs\n             (find_nonzeros_from_input_vec lhs_vec)))\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. take_indices signs\n     (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets m)) =\n    snd (snd (let reduce_cols_A =\n                    take_cols_from_matrix m\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets m));\n                  rows_keep = rows_to_keep reduce_cols_A\n              in (take_rows_from_matrix reduce_cols_A rows_keep,\n                  take_indices subsets rows_keep,\n                  take_indices signs\n                   (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets m)))))", "by metis"], ["", "lemma reduction_subsets_is_get_subsets_R: \"reduction_subsets_R p qs signs subsets m =  get_subsets_R (reduce_system_R p (qs, (m, (subsets, signs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduction_subsets_R p qs signs subsets m =\n    get_subsets_R (reduce_system_R p (qs, m, subsets, signs))", "unfolding reduction_subsets_R_def get_subsets_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_indices subsets\n     (rows_to_keep (reduce_mat_cols m (solve_for_lhs_R p qs subsets m))) =\n    fst (snd (reduce_system_R p (qs, m, subsets, signs)))", "using reduce_system.simps reduction_step.elims fst_conv snd_conv"], ["proof (prove)\nusing this:\n  reduce_system ?p (?qs, ?m, ?subs, ?signs) =\n  reduction_step ?m ?signs ?subs (solve_for_lhs ?p ?qs ?subs ?m)\n  \\<lbrakk>reduction_step ?x ?xa ?xb ?xc = ?y;\n   \\<And>A signs subsets lhs_vec.\n      \\<lbrakk>?x = A; ?xa = signs; ?xb = subsets; ?xc = lhs_vec;\n       ?y =\n       (let reduce_cols_A = reduce_mat_cols A lhs_vec;\n            rows_keep = rows_to_keep reduce_cols_A\n        in (take_rows_from_matrix reduce_cols_A rows_keep,\n            take_indices subsets rows_keep,\n            take_indices signs\n             (find_nonzeros_from_input_vec lhs_vec)))\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  fst (?x1.0, ?x2.0) = ?x1.0\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. take_indices subsets\n     (rows_to_keep (reduce_mat_cols m (solve_for_lhs_R p qs subsets m))) =\n    fst (snd (reduce_system_R p (qs, m, subsets, signs)))", "by (metis reduce_system_R.simps reduction_step_R.simps)"], ["", "subsection \"Showing sign conditions preserved when reducing\""], ["", "lemma take_indices_lem_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes arb_list :: \"('a list*'a list) list\"\n  fixes index_list :: \"nat list\" \n  fixes n:: \"nat\"\n  assumes lest: \"n < length (take_indices arb_list index_list)\"\n  assumes well_def: \"\\<forall>q.(List.member index_list q \\<longrightarrow> q < length arb_list)\"\n  shows \"\\<exists>k<length arb_list.\n            (take_indices arb_list index_list) ! n =  arb_list ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<length arb_list.\n       take_indices arb_list index_list ! n = arb_list ! k", "using lest well_def"], ["proof (prove)\nusing this:\n  n < length (take_indices arb_list index_list)\n  \\<forall>q. List.member index_list q \\<longrightarrow> q < length arb_list\n\ngoal (1 subgoal):\n 1. \\<exists>k<length arb_list.\n       take_indices arb_list index_list ! n = arb_list ! k", "unfolding take_indices_def"], ["proof (prove)\nusing this:\n  n < length (map ((!) arb_list) index_list)\n  \\<forall>q. List.member index_list q \\<longrightarrow> q < length arb_list\n\ngoal (1 subgoal):\n 1. \\<exists>k<length arb_list.\n       map ((!) arb_list) index_list ! n = arb_list ! k", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length index_list;\n     \\<forall>q.\n        List.member index_list q \\<longrightarrow>\n        q < length arb_list\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k<length arb_list.\n                         arb_list ! (index_list ! n) = arb_list ! k", "by (metis member_def nth_mem)"], ["", "lemma size_of_mat_R:\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  shows \"(matrix_A_R signs subsets) \\<in> carrier_mat (length subsets) (length signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R signs subsets \\<in> carrier_mat (length subsets) (length signs)", "unfolding matrix_A_R_def carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list (length signs) (map (mtx_row_R signs) subsets)\n    \\<in> {m. dim_row m = length subsets \\<and> dim_col m = length signs}", "by auto"], ["", "lemma size_of_lhs_R: \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes signs :: \"rat list list\" \n  shows \"dim_vec (construct_lhs_vector_R p qs signs) = length signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (w_vec_R p qs signs) = length signs", "unfolding construct_lhs_vector_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (map (\\<lambda>w.\n                rat_of_int\n                 (int (length\n                        (filter (\\<lambda>v. v = w)\n                          (map (consistent_sign_vec qs)\n                            (characterize_root_list_p p))))))\n         signs)) =\n    length signs", "by simp"], ["", "lemma size_of_rhs_R: \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\" \n  shows \"dim_vec (construct_rhs_vector_R p qs subsets) = length subsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (v_vec_R p qs subsets) = length subsets", "unfolding construct_rhs_vector_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (map (\\<lambda>(I1, I2).\n                construct_NofI_R p (retrieve_polys qs I1)\n                 (retrieve_polys qs I2))\n         subsets)) =\n    length subsets", "by simp"], ["", "lemma same_size_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"length subsets = length signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length subsets = length signs", "using invertible_mat"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. length subsets = length signs", "unfolding invertible_mat_def"], ["proof (prove)\nusing this:\n  square_mat (M_mat_R signs subsets) \\<and>\n  (\\<exists>B.\n      inverts_mat (M_mat_R signs subsets) B \\<and>\n      inverts_mat B (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. length subsets = length signs", "using size_of_mat_R[of signs subsets] size_of_lhs_R[of p qs signs] size_of_rhs_R[of p qs subsets]"], ["proof (prove)\nusing this:\n  square_mat (M_mat_R signs subsets) \\<and>\n  (\\<exists>B.\n      inverts_mat (M_mat_R signs subsets) B \\<and>\n      inverts_mat B (M_mat_R signs subsets))\n  M_mat_R signs subsets \\<in> carrier_mat (length subsets) (length signs)\n  dim_vec (w_vec_R p qs signs) = length signs\n  dim_vec (v_vec_R p qs subsets) = length subsets\n\ngoal (1 subgoal):\n 1. length subsets = length signs", "by simp"], ["", "lemma construct_lhs_matches_solve_for_lhs_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"(construct_lhs_vector_R p qs signs) = solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "have matrix_equation_hyp: \"(mult_mat_vec (matrix_A_R signs subsets) (construct_lhs_vector_R p qs signs) = (construct_rhs_vector_R p qs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs =\n    v_vec_R p qs subsets", "using match"], ["proof (prove)\nusing this:\n  satisfy_equation_R p qs subsets signs\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs =\n    v_vec_R p qs subsets", "unfolding satisfy_equation_R_def"], ["proof (prove)\nusing this:\n  M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs = v_vec_R p qs subsets\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs =\n    v_vec_R p qs subsets", "by blast"], ["proof (state)\nthis:\n  M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs = v_vec_R p qs subsets\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "then"], ["proof (chain)\npicking this:\n  M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs = v_vec_R p qs subsets", "have eqn_hyp: \" ((matr_option (dim_row (matrix_A_R signs subsets))\n     (mat_inverse (matrix_A_R signs subsets))) *\\<^sub>v (mult_mat_vec (matrix_A_R signs subsets) (construct_lhs_vector_R p qs signs)) = \n      mult_mat_vec (matr_option (dim_row (matrix_A_R signs subsets))\n     (mat_inverse (matrix_A_R signs subsets))) (construct_rhs_vector_R p qs subsets))\""], ["proof (prove)\nusing this:\n  M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs = v_vec_R p qs subsets\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n    (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n    matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n    v_vec_R p qs subsets", "using invertible_mat"], ["proof (prove)\nusing this:\n  M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs = v_vec_R p qs subsets\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n    (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n    matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n    v_vec_R p qs subsets", "by (simp add: matrix_equation_hyp)"], ["proof (state)\nthis:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  v_vec_R p qs subsets\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "have match_hyp: \"length subsets = length signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length subsets = length signs", "using same_size_R invertible_mat"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R ?signs ?subsets) \\<Longrightarrow>\n  length ?subsets = length ?signs\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. length subsets = length signs", "by auto"], ["proof (state)\nthis:\n  length subsets = length signs\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "then"], ["proof (chain)\npicking this:\n  length subsets = length signs", "have dim_hyp1: \"matrix_A_R signs subsets \\<in> carrier_mat (length signs) (length signs)\""], ["proof (prove)\nusing this:\n  length subsets = length signs\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)", "using size_of_mat"], ["proof (prove)\nusing this:\n  length subsets = length signs\n  M_mat ?signs ?subsets \\<in> carrier_mat (length ?subsets) (length ?signs)\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)", "by auto"], ["proof (state)\nthis:\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "then"], ["proof (chain)\npicking this:\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)", "have dim_hyp2: \"matr_option (dim_row (matrix_A_R signs subsets))\n     (mat_inverse (matrix_A_R signs subsets)) \\<in> carrier_mat (length signs) (length signs)\""], ["proof (prove)\nusing this:\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets))\n    \\<in> carrier_mat (length signs) (length signs)", "using invertible_mat dim_invertible"], ["proof (prove)\nusing this:\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n  invertible_mat (M_mat_R signs subsets)\n  \\<lbrakk>invertible_mat ?A; ?A \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> matr_option (dim_row ?A) (mat_inverse ?A)\n                    \\<in> carrier_mat ?n ?n\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets))\n    \\<in> carrier_mat (length signs) (length signs)", "by blast"], ["proof (state)\nthis:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "have mult_assoc_hyp: \"((matr_option (dim_row (matrix_A_R signs subsets))\n     (mat_inverse (matrix_A_R signs subsets))) *\\<^sub>v (mult_mat_vec (matrix_A_R signs subsets) (construct_lhs_vector_R p qs signs)))\n    = (((matr_option (dim_row (matrix_A_R signs subsets))\n     (mat_inverse (matrix_A_R signs subsets))) * (matrix_A_R signs subsets)) *\\<^sub>v  (construct_lhs_vector_R p qs signs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n    (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n    matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\n    M_mat_R signs subsets *\\<^sub>v\n    w_vec_R p qs signs", "using mult_assoc dim_hyp1 dim_hyp2 size_of_lhs_R"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n;\n   dim_vec ?v = ?n\\<rbrakk>\n  \\<Longrightarrow> ?A *\\<^sub>v (?B *\\<^sub>v ?v) = ?A * ?B *\\<^sub>v ?v\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs) (length signs)\n  dim_vec (w_vec_R ?p ?qs ?signs) = length ?signs\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n    (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n    matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\n    M_mat_R signs subsets *\\<^sub>v\n    w_vec_R p qs signs", "by auto"], ["proof (state)\nthis:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets *\\<^sub>v\n  w_vec_R p qs signs\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "have cancel_helper: \"(((matr_option (dim_row (matrix_A_R signs subsets))\n     (mat_inverse (matrix_A_R signs subsets))) * (matrix_A_R signs subsets)) *\\<^sub>v  (construct_lhs_vector_R p qs signs))\n  = (1\\<^sub>m (length signs)) *\\<^sub>v   (construct_lhs_vector_R p qs signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\n    M_mat_R signs subsets *\\<^sub>v\n    w_vec_R p qs signs =\n    1\\<^sub>m (length signs) *\\<^sub>v w_vec_R p qs signs", "using invertible_means_mult_id[where A= \"matrix_A_R signs subsets\"] dim_hyp1"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets) \\<Longrightarrow>\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets =\n  1\\<^sub>m (dim_row (M_mat_R signs subsets))\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\n    M_mat_R signs subsets *\\<^sub>v\n    w_vec_R p qs signs =\n    1\\<^sub>m (length signs) *\\<^sub>v w_vec_R p qs signs", "by (simp add: invertible_mat match_hyp)"], ["proof (state)\nthis:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets *\\<^sub>v\n  w_vec_R p qs signs =\n  1\\<^sub>m (length signs) *\\<^sub>v w_vec_R p qs signs\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "then"], ["proof (chain)\npicking this:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets *\\<^sub>v\n  w_vec_R p qs signs =\n  1\\<^sub>m (length signs) *\\<^sub>v w_vec_R p qs signs", "have cancel_hyp: \"(((matr_option (dim_row (matrix_A_R signs subsets))\n     (mat_inverse (matrix_A_R signs subsets))) * (matrix_A_R signs subsets)) *\\<^sub>v  (construct_lhs_vector_R p qs signs))\n  = (construct_lhs_vector_R p qs signs)\""], ["proof (prove)\nusing this:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets *\\<^sub>v\n  w_vec_R p qs signs =\n  1\\<^sub>m (length signs) *\\<^sub>v w_vec_R p qs signs\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\n    M_mat_R signs subsets *\\<^sub>v\n    w_vec_R p qs signs =\n    w_vec_R p qs signs", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matr_option (length subsets) (mat_inverse (M_mat_R signs subsets)) *\n    M_mat_R signs subsets *\\<^sub>v\n    w_vec_R p qs signs =\n    1\\<^sub>m (length signs) *\\<^sub>v w_vec_R p qs signs \\<Longrightarrow>\n    1\\<^sub>m (length signs) *\\<^sub>v w_vec_R p qs signs =\n    w_vec_R p qs signs", "by (metis carrier_vec_dim_vec one_mult_mat_vec size_of_lhs_R)"], ["proof (state)\nthis:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets *\\<^sub>v\n  w_vec_R p qs signs =\n  w_vec_R p qs signs\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "then"], ["proof (chain)\npicking this:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets *\\<^sub>v\n  w_vec_R p qs signs =\n  w_vec_R p qs signs", "have mult_hyp: \"((matr_option (dim_row (matrix_A_R signs subsets))\n     (mat_inverse (matrix_A_R signs subsets))) *\\<^sub>v (mult_mat_vec (matrix_A_R signs subsets) (construct_lhs_vector_R p qs signs)))\n    = (construct_lhs_vector_R p qs signs)\""], ["proof (prove)\nusing this:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets *\\<^sub>v\n  w_vec_R p qs signs =\n  w_vec_R p qs signs\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n    (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n    w_vec_R p qs signs", "using mult_assoc_hyp cancel_hyp"], ["proof (prove)\nusing this:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets *\\<^sub>v\n  w_vec_R p qs signs =\n  w_vec_R p qs signs\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets *\\<^sub>v\n  w_vec_R p qs signs\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\n  M_mat_R signs subsets *\\<^sub>v\n  w_vec_R p qs signs =\n  w_vec_R p qs signs\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n    (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n    w_vec_R p qs signs", "by simp"], ["proof (state)\nthis:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n  w_vec_R p qs signs\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "then"], ["proof (chain)\npicking this:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n  w_vec_R p qs signs", "have \"(construct_lhs_vector_R p qs signs) =  (mult_mat_vec (matr_option (dim_row (matrix_A_R signs subsets))\n     (mat_inverse (matrix_A_R signs subsets))) (construct_rhs_vector_R p qs subsets)) \""], ["proof (prove)\nusing this:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n  w_vec_R p qs signs\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n    v_vec_R p qs subsets", "using eqn_hyp"], ["proof (prove)\nusing this:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n  w_vec_R p qs signs\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  (M_mat_R signs subsets *\\<^sub>v w_vec_R p qs signs) =\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  v_vec_R p qs subsets\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n    v_vec_R p qs subsets", "by simp"], ["proof (state)\nthis:\n  w_vec_R p qs signs =\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  v_vec_R p qs subsets\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "then"], ["proof (chain)\npicking this:\n  w_vec_R p qs signs =\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  v_vec_R p qs subsets", "show ?thesis"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs =\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  v_vec_R p qs subsets\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "unfolding solve_for_lhs_R_def"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs =\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets)) *\\<^sub>v\n  v_vec_R p qs subsets\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse_var (M_mat_R signs subsets)) *\\<^sub>v\n    v_vec_R p qs subsets", "by (simp add: mat_inverse_same)"], ["proof (state)\nthis:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Then show that dropping columns doesn't affect the consistent sign assignments *)"], ["", "lemma reduction_doesnt_break_things_signs_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(reduction_signs_R p qs signs subsets (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets))", "have dim_hyp2: \"matr_option (dim_row (matrix_A_R signs subsets))\n     (mat_inverse (matrix_A_R signs subsets)) \\<in> carrier_mat (length signs) (length signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets))\n    \\<in> carrier_mat (length signs) (length signs)", "using invertible_mat dim_invertible"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n  \\<lbrakk>invertible_mat ?A; ?A \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> matr_option (dim_row ?A) (mat_inverse ?A)\n                    \\<in> carrier_mat ?n ?n\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets))\n    \\<in> carrier_mat (length signs) (length signs)", "using same_size_R"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n  \\<lbrakk>invertible_mat ?A; ?A \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> matr_option (dim_row ?A) (mat_inverse ?A)\n                    \\<in> carrier_mat ?n ?n\n  invertible_mat (M_mat_R ?signs ?subsets) \\<Longrightarrow>\n  length ?subsets = length ?signs\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets))\n    \\<in> carrier_mat (length signs) (length signs)", "by fastforce"], ["proof (state)\nthis:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets))", "have \"(construct_lhs_vector_R p qs signs) = solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "using construct_lhs_matches_solve_for_lhs_R assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> w_vec_R ?p ?qs ?signs =\n                    solve_for_lhs_R ?p ?qs ?subsets\n                     (M_mat_R ?signs ?subsets)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "by auto"], ["proof (state)\nthis:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "have \"(solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)) =\n   vec_of_list (map rat_of_nat (map (\\<lambda>s. card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) signs))\""], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs))", "using construct_lhs_vector_cleaner_R assms"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  w_vec_R ?p ?qs ?signs =\n  vec_of_list\n   (map (\\<lambda>s.\n            rat_of_int\n             (int (card\n                    {x. poly ?p x = 0 \\<and>\n                        consistent_sign_vec ?qs x = s})))\n     ?signs)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs))", "by (metis (mono_tags, lifting) list.map_cong map_map o_apply of_int_of_nat_eq)"], ["proof (state)\nthis:\n  solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n  vec_of_list\n   (map rat_of_nat\n     (map (\\<lambda>s.\n              card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n       signs))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n  vec_of_list\n   (map rat_of_nat\n     (map (\\<lambda>s.\n              card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n       signs))", "have \"\\<forall> n < (dim_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))). \n       (((solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)) $ n = 0) \\<longrightarrow>\n       (nth signs n) \\<notin> set (characterize_consistent_signs_at_roots p qs))\""], ["proof (prove)\nusing this:\n  solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n  vec_of_list\n   (map rat_of_nat\n     (map (\\<lambda>s.\n              card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n       signs))\n\ngoal (1 subgoal):\n 1. \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n       0 \\<longrightarrow>\n       signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs)) \\<Longrightarrow>\n    \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n       0 \\<longrightarrow>\n       signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)", "have h0: \"\\<forall> n < (dim_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))). \n       (((solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)) $ n = 0) \\<longrightarrow> \n       rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = (nth signs n)}) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n       0 \\<longrightarrow>\n       rat_of_nat\n        (card\n          {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! n}) =\n       0", "by (metis (mono_tags, lifting) \\<open>construct_lhs_vector_R p qs signs = solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)\\<close> construct_lhs_vector_clean_R nonzero of_nat_0_eq_iff of_rat_of_nat_eq size_of_lhs_R)"], ["proof (state)\nthis:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n     0 \\<longrightarrow>\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! n}) =\n     0\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs)) \\<Longrightarrow>\n    \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n       0 \\<longrightarrow>\n       signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)", "have h1: \"\\<forall> w. (rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) = 0 \\<longrightarrow> \n        (\\<nexists> x. poly p x = 0 \\<and> consistent_sign_vec qs x = w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w.\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) =\n       0 \\<longrightarrow>\n       (\\<nexists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n                0;\n        poly p x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n                0;\n        poly p x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume card_asm: \"card {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = consistent_sign_vec qs x} = 0\""], ["proof (state)\nthis:\n  card\n   {xa.\n    poly p xa = 0 \\<and>\n    consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n                0;\n        poly p x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume zero_asm: \"poly p x = 0\""], ["proof (state)\nthis:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n                0;\n        poly p x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "have card_hyp: \"{xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = consistent_sign_vec qs x} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa.\n     poly p xa = 0 \\<and>\n     consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n    {}", "using card_eq_0_iff"], ["proof (prove)\nusing this:\n  (card ?A = 0) = (?A = {} \\<or> infinite ?A)\n\ngoal (1 subgoal):\n 1. {xa.\n     poly p xa = 0 \\<and>\n     consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n    {}", "using card_asm nonzero poly_roots_finite"], ["proof (prove)\nusing this:\n  (card ?A = 0) = (?A = {} \\<or> infinite ?A)\n  card\n   {xa.\n    poly p xa = 0 \\<and>\n    consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n  0\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. {xa.\n     poly p xa = 0 \\<and>\n     consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n    {}", "by (metis (full_types) finite_Collect_conjI)"], ["proof (state)\nthis:\n  {xa.\n   poly p xa = 0 \\<and>\n   consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n                0;\n        poly p x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "have \"x \\<in> {xa. poly p xa = 0 \\<and> consistent_sign_vec qs xa = consistent_sign_vec qs x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec qs xa = consistent_sign_vec qs x}", "using zero_asm"], ["proof (prove)\nusing this:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec qs xa = consistent_sign_vec qs x}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {xa.\n           poly p xa = 0 \\<and>\n           consistent_sign_vec qs xa = consistent_sign_vec qs x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n                0;\n        poly p x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  x \\<in> {xa.\n           poly p xa = 0 \\<and>\n           consistent_sign_vec qs xa = consistent_sign_vec qs x}\n\ngoal (1 subgoal):\n 1. False", "using card_hyp"], ["proof (prove)\nusing this:\n  x \\<in> {xa.\n           poly p xa = 0 \\<and>\n           consistent_sign_vec qs xa = consistent_sign_vec qs x}\n  {xa.\n   poly p xa = 0 \\<and>\n   consistent_sign_vec qs xa = consistent_sign_vec qs x} =\n  {}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>w.\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) =\n     0 \\<longrightarrow>\n     (\\<nexists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w)\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs)) \\<Longrightarrow>\n    \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n       0 \\<longrightarrow>\n       signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)", "have h2: \"\\<And> w. (rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) = 0 \\<Longrightarrow>\n       (\\<not>List.member (characterize_consistent_signs_at_roots p qs) w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) =\n       0 \\<Longrightarrow>\n       \\<not> List.member (characterize_consistent_signs_at_roots p qs) w", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w} =\n                0;\n        List.member (characterize_consistent_signs_at_roots p qs) w\\<rbrakk>\n       \\<Longrightarrow> False", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w} =\n                0;\n        List.member (characterize_consistent_signs_at_roots p qs) w\\<rbrakk>\n       \\<Longrightarrow> False", "assume card_asm: \"card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w} = 0\""], ["proof (state)\nthis:\n  card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w} = 0\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w} =\n                0;\n        List.member (characterize_consistent_signs_at_roots p qs) w\\<rbrakk>\n       \\<Longrightarrow> False", "assume mem_asm: \"List.member (characterize_consistent_signs_at_roots p qs) w\""], ["proof (state)\nthis:\n  List.member (characterize_consistent_signs_at_roots p qs) w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w} =\n                0;\n        List.member (characterize_consistent_signs_at_roots p qs) w\\<rbrakk>\n       \\<Longrightarrow> False", "have h0: \"\\<nexists> x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "using h1 card_asm"], ["proof (prove)\nusing this:\n  \\<forall>w.\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) =\n     0 \\<longrightarrow>\n     (\\<nexists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w)\n  card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w} = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "by (simp add: h1)"], ["proof (state)\nthis:\n  \\<nexists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w} =\n                0;\n        List.member (characterize_consistent_signs_at_roots p qs) w\\<rbrakk>\n       \\<Longrightarrow> False", "have h1: \"\\<exists> x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "using mem_asm"], ["proof (prove)\nusing this:\n  List.member (characterize_consistent_signs_at_roots p qs) w\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "unfolding characterize_consistent_signs_at_roots_def characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  List.member\n   (remdups (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0}))) w\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. List.member\n     (remdups (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))\n     w \\<Longrightarrow>\n    \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "have \"w \\<in> Collect (List.member (remdups (map (consistent_sign_vec qs) (sorted_list_of_set {r. poly p r = 0}))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> Collect\n             (List.member\n               (remdups\n                 (map (consistent_sign_vec qs)\n                   (sorted_list_of_set {r. poly p r = 0}))))", "using characterize_consistent_signs_at_roots_def mem_asm characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  characterize_consistent_signs_at_roots ?p ?qs =\n  remdups (map (signs_at ?qs) (characterize_root_list_p ?p))\n  List.member (characterize_consistent_signs_at_roots p qs) w\n  characterize_root_list_p ?p \\<equiv> sorted_list_of_set {x. poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. w \\<in> Collect\n             (List.member\n               (remdups\n                 (map (consistent_sign_vec qs)\n                   (sorted_list_of_set {r. poly p r = 0}))))", "by (smt (verit, ccfv_SIG) consistent_sign_vec_def h0 imageE in_set_member list.set_map map_cong mem_Collect_eq nonzero o_apply poly_roots_finite set_remdups set_sorted_list_of_set signs_at_def squash_def)"], ["proof (state)\nthis:\n  w \\<in> Collect\n           (List.member\n             (remdups\n               (map (consistent_sign_vec qs)\n                 (sorted_list_of_set {r. poly p r = 0}))))\n\ngoal (1 subgoal):\n 1. List.member\n     (remdups (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))\n     w \\<Longrightarrow>\n    \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "then"], ["proof (chain)\npicking this:\n  w \\<in> Collect\n           (List.member\n             (remdups\n               (map (consistent_sign_vec qs)\n                 (sorted_list_of_set {r. poly p r = 0}))))", "have f1: \"w \\<in> set (map (consistent_sign_vec qs) (sorted_list_of_set {r. poly p r = 0}))\""], ["proof (prove)\nusing this:\n  w \\<in> Collect\n           (List.member\n             (remdups\n               (map (consistent_sign_vec qs)\n                 (sorted_list_of_set {r. poly p r = 0}))))\n\ngoal (1 subgoal):\n 1. w \\<in> set (map (consistent_sign_vec qs)\n                  (sorted_list_of_set {r. poly p r = 0}))", "by (metis (no_types) in_set_member mem_Collect_eq set_remdups)"], ["proof (state)\nthis:\n  w \\<in> set (map (consistent_sign_vec qs)\n                (sorted_list_of_set {r. poly p r = 0}))\n\ngoal (1 subgoal):\n 1. List.member\n     (remdups (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))\n     w \\<Longrightarrow>\n    \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "have \"finite {r. poly p r = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {r. poly p r = 0}", "using nonzero poly_roots_finite"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. finite {r. poly p r = 0}", "by blast"], ["proof (state)\nthis:\n  finite {r. poly p r = 0}\n\ngoal (1 subgoal):\n 1. List.member\n     (remdups (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))\n     w \\<Longrightarrow>\n    \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "then"], ["proof (chain)\npicking this:\n  finite {r. poly p r = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {r. poly p r = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "using f1"], ["proof (prove)\nusing this:\n  finite {r. poly p r = 0}\n  w \\<in> set (map (consistent_sign_vec qs)\n                (sorted_list_of_set {r. poly p r = 0}))\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w} =\n                0;\n        List.member (characterize_consistent_signs_at_roots p qs) w\\<rbrakk>\n       \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using h0 h1"], ["proof (prove)\nusing this:\n  \\<nexists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\n  \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = ?w}) =\n  0 \\<Longrightarrow>\n  \\<not> List.member (characterize_consistent_signs_at_roots p qs) ?w\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs)) \\<Longrightarrow>\n    \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n       0 \\<longrightarrow>\n       signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = ?w}) =\n  0 \\<Longrightarrow>\n  \\<not> List.member (characterize_consistent_signs_at_roots p qs) ?w", "have h3: \"\\<forall> w. rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) = 0 \\<longrightarrow> \n        w \\<notin> set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\nusing this:\n  rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = ?w}) =\n  0 \\<Longrightarrow>\n  \\<not> List.member (characterize_consistent_signs_at_roots p qs) ?w\n\ngoal (1 subgoal):\n 1. \\<forall>w.\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) =\n       0 \\<longrightarrow>\n       w \\<notin> set (characterize_consistent_signs_at_roots p qs)", "by (simp add: in_set_member)"], ["proof (state)\nthis:\n  \\<forall>w.\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) =\n     0 \\<longrightarrow>\n     w \\<notin> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs)) \\<Longrightarrow>\n    \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n       0 \\<longrightarrow>\n       signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n       0 \\<longrightarrow>\n       signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)", "using h0 h3"], ["proof (prove)\nusing this:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n     0 \\<longrightarrow>\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! n}) =\n     0\n  \\<forall>w.\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) =\n     0 \\<longrightarrow>\n     w \\<notin> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n       0 \\<longrightarrow>\n       signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)", "by blast"], ["proof (state)\nthis:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n     0 \\<longrightarrow>\n     signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n     0 \\<longrightarrow>\n     signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n     0 \\<longrightarrow>\n     signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)", "have \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set (take_indices signs\n             (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))\""], ["proof (prove)\nusing this:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n     0 \\<longrightarrow>\n     signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (take_indices signs\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))", "using all_info\n      reduction_signs_set_helper_lemma[where A = \"set (characterize_consistent_signs_at_roots p qs)\", where B = \"signs\",\n      where C = \"(solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))\"]"], ["proof (prove)\nusing this:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n     0 \\<longrightarrow>\n     signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  \\<lbrakk>dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n           length signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   \\<forall>n<dim_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n      solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n      0 \\<longrightarrow>\n      signs ! n\n      \\<notin> set (characterize_consistent_signs_at_roots p qs)\\<rbrakk>\n  \\<Longrightarrow> set (characterize_consistent_signs_at_roots p qs)\n                    \\<subseteq> set (take_indices signs\n(find_nonzeros_from_input_vec\n  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (take_indices signs\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))", "using dim_hyp2 solve_for_lhs_R_def"], ["proof (prove)\nusing this:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n     0 \\<longrightarrow>\n     signs ! n \\<notin> set (characterize_consistent_signs_at_roots p qs)\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  \\<lbrakk>dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n           length signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   \\<forall>n<dim_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n      solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n      0 \\<longrightarrow>\n      signs ! n\n      \\<notin> set (characterize_consistent_signs_at_roots p qs)\\<rbrakk>\n  \\<Longrightarrow> set (characterize_consistent_signs_at_roots p qs)\n                    \\<subseteq> set (take_indices signs\n(find_nonzeros_from_input_vec\n  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs) (length signs)\n  solve_for_lhs_R ?p ?qs ?subsets ?matr =\n  matr_option (dim_row ?matr) (mat_inverse_var ?matr) *\\<^sub>v\n  v_vec_R ?p ?qs ?subsets\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (take_indices signs\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))", "by (simp add: mat_inverse_same)"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (take_indices signs\n                    (find_nonzeros_from_input_vec\n                      (solve_for_lhs_R p qs subsets\n                        (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (take_indices signs\n                    (find_nonzeros_from_input_vec\n                      (solve_for_lhs_R p qs subsets\n                        (M_mat_R signs subsets))))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (take_indices signs\n                    (find_nonzeros_from_input_vec\n                      (solve_for_lhs_R p qs subsets\n                        (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets))", "unfolding reduction_signs_R_def"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (take_indices signs\n                    (find_nonzeros_from_input_vec\n                      (solve_for_lhs_R p qs subsets\n                        (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (take_indices signs\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))", "by auto"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (reduction_signs_R p qs signs subsets\n                    (M_mat_R signs subsets))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduction_deletes_bad_sign_conds_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"set (characterize_consistent_signs_at_roots p qs) = set(reduction_signs_R p qs signs subsets (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs) =\n    set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs) =\n    set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "have dim_hyp2: \"matr_option (dim_row (matrix_A_R signs subsets))\n       (mat_inverse (matrix_A_R signs subsets)) \\<in> carrier_mat (length signs) (length signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets))\n    \\<in> carrier_mat (length signs) (length signs)", "using invertible_mat dim_invertible"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n  \\<lbrakk>invertible_mat ?A; ?A \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> matr_option (dim_row ?A) (mat_inverse ?A)\n                    \\<in> carrier_mat ?n ?n\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets))\n    \\<in> carrier_mat (length signs) (length signs)", "using same_size_R"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n  \\<lbrakk>invertible_mat ?A; ?A \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> matr_option (dim_row ?A) (mat_inverse ?A)\n                    \\<in> carrier_mat ?n ?n\n  invertible_mat (M_mat_R ?signs ?subsets) \\<Longrightarrow>\n  length ?subsets = length ?signs\n\ngoal (1 subgoal):\n 1. matr_option (dim_row (M_mat_R signs subsets))\n     (mat_inverse (M_mat_R signs subsets))\n    \\<in> carrier_mat (length signs) (length signs)", "by fastforce"], ["proof (state)\nthis:\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs) =\n    set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "have supset: \"set (characterize_consistent_signs_at_roots p qs) \\<supseteq> set(reduction_signs_R p qs signs subsets (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "have \"(construct_lhs_vector_R p qs signs) = solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "using construct_lhs_matches_solve_for_lhs_R assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> w_vec_R ?p ?qs ?signs =\n                    solve_for_lhs_R ?p ?qs ?subsets\n                     (M_mat_R ?signs ?subsets)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "by auto"], ["proof (state)\nthis:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "have \"(solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)) =\n       vec_of_list (map rat_of_nat (map (\\<lambda>s. card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) signs))\""], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs))", "using construct_lhs_vector_cleaner_R assms"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  w_vec_R ?p ?qs ?signs =\n  vec_of_list\n   (map (\\<lambda>s.\n            rat_of_int\n             (int (card\n                    {x. poly ?p x = 0 \\<and>\n                        consistent_sign_vec ?qs x = s})))\n     ?signs)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs))", "by (metis (mono_tags, lifting) list.map_cong map_map o_apply of_int_of_nat_eq)"], ["proof (state)\nthis:\n  solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n  vec_of_list\n   (map rat_of_nat\n     (map (\\<lambda>s.\n              card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n       signs))\n\ngoal (1 subgoal):\n 1. set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n  vec_of_list\n   (map rat_of_nat\n     (map (\\<lambda>s.\n              card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n       signs))", "have \"\\<forall> n < (dim_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))). \n           (((solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)) $ n \\<noteq> 0) \\<longrightarrow>\n           (nth signs n) \\<in> set (characterize_consistent_signs_at_roots p qs))\""], ["proof (prove)\nusing this:\n  solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n  vec_of_list\n   (map rat_of_nat\n     (map (\\<lambda>s.\n              card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n       signs))\n\ngoal (1 subgoal):\n 1. \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n       0 \\<longrightarrow>\n       signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs)) \\<Longrightarrow>\n    \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n       0 \\<longrightarrow>\n       signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)", "have h0: \"\\<forall> n < (dim_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))). \n           (((solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)) $ n = 0) \\<longrightarrow> \n           rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = (nth signs n)}) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n       0 \\<longrightarrow>\n       rat_of_nat\n        (card\n          {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! n}) =\n       0", "by (simp add: \\<open>solve_for_lhs_R p qs subsets (M_mat_R signs subsets) = vec_of_list (map rat_of_nat (map (\\<lambda>s. card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) signs))\\<close> vec_of_list_index)"], ["proof (state)\nthis:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n     0 \\<longrightarrow>\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! n}) =\n     0\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs)) \\<Longrightarrow>\n    \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n       0 \\<longrightarrow>\n       signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)", "have h1: \"\\<forall> w. (rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) \\<noteq> 0 \\<longrightarrow> \n            (\\<exists> x. poly p x = 0 \\<and> consistent_sign_vec qs x = w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w.\n       rat_of_nat\n        (card\n          {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) \\<noteq>\n       0 \\<longrightarrow>\n       (\\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       0 < card\n            {x. poly p x = 0 \\<and>\n                consistent_sign_vec qs x = w} \\<Longrightarrow>\n       \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       0 < card\n            {x. poly p x = 0 \\<and>\n                consistent_sign_vec qs x = w} \\<Longrightarrow>\n       \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "assume card_asm: \"0 < card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}\""], ["proof (state)\nthis:\n  0 < card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       0 < card\n            {x. poly p x = 0 \\<and>\n                consistent_sign_vec qs x = w} \\<Longrightarrow>\n       \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "show \"\\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "by (metis (mono_tags, lifting) Collect_empty_eq card_asm card_eq_0_iff gr_implies_not0)"], ["proof (state)\nthis:\n  \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>w.\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) \\<noteq>\n     0 \\<longrightarrow>\n     (\\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w)\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs)) \\<Longrightarrow>\n    \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n       0 \\<longrightarrow>\n       signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)", "have h2: \"\\<And> w. (rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) \\<noteq> 0 \\<Longrightarrow>\n           (List.member (characterize_consistent_signs_at_roots p qs) w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       rat_of_nat\n        (card\n          {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) \\<noteq>\n       0 \\<Longrightarrow>\n       List.member (characterize_consistent_signs_at_roots p qs) w", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       0 < card\n            {x. poly p x = 0 \\<and>\n                consistent_sign_vec qs x = w} \\<Longrightarrow>\n       List.member (characterize_consistent_signs_at_roots p qs) w", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       0 < card\n            {x. poly p x = 0 \\<and>\n                consistent_sign_vec qs x = w} \\<Longrightarrow>\n       List.member (characterize_consistent_signs_at_roots p qs) w", "assume card_asm: \" 0 < card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}\""], ["proof (state)\nthis:\n  0 < card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       0 < card\n            {x. poly p x = 0 \\<and>\n                consistent_sign_vec qs x = w} \\<Longrightarrow>\n       List.member (characterize_consistent_signs_at_roots p qs) w", "have h0: \"\\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "using card_asm"], ["proof (prove)\nusing this:\n  0 < card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "by (simp add: h1)"], ["proof (state)\nthis:\n  \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       0 < card\n            {x. poly p x = 0 \\<and>\n                consistent_sign_vec qs x = w} \\<Longrightarrow>\n       List.member (characterize_consistent_signs_at_roots p qs) w", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w", "show \"List.member (characterize_consistent_signs_at_roots p qs) w\""], ["proof (prove)\nusing this:\n  \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\n\ngoal (1 subgoal):\n 1. List.member (characterize_consistent_signs_at_roots p qs) w", "unfolding characterize_consistent_signs_at_roots_def"], ["proof (prove)\nusing this:\n  \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\n\ngoal (1 subgoal):\n 1. List.member (remdups (map (signs_at qs) (characterize_root_list_p p))) w", "using in_set_member nonzero poly_roots_finite characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  \\<exists>x. poly p x = 0 \\<and> consistent_sign_vec qs x = w\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n  characterize_root_list_p ?p \\<equiv> sorted_list_of_set {x. poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. List.member (remdups (map (signs_at qs) (characterize_root_list_p p))) w", "by (smt (verit) characterize_consistent_signs_at_roots_def in_set_R mem_Collect_eq)"], ["proof (state)\nthis:\n  List.member (characterize_consistent_signs_at_roots p qs) w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rat_of_nat\n   (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = ?w}) \\<noteq>\n  0 \\<Longrightarrow>\n  List.member (characterize_consistent_signs_at_roots p qs) ?w\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs)) \\<Longrightarrow>\n    \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n       0 \\<longrightarrow>\n       signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  rat_of_nat\n   (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = ?w}) \\<noteq>\n  0 \\<Longrightarrow>\n  List.member (characterize_consistent_signs_at_roots p qs) ?w", "have h3: \"\\<forall> w. rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) \\<noteq> 0 \\<longrightarrow> \n            w \\<in> set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\nusing this:\n  rat_of_nat\n   (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = ?w}) \\<noteq>\n  0 \\<Longrightarrow>\n  List.member (characterize_consistent_signs_at_roots p qs) ?w\n\ngoal (1 subgoal):\n 1. \\<forall>w.\n       rat_of_nat\n        (card\n          {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) \\<noteq>\n       0 \\<longrightarrow>\n       w \\<in> set (characterize_consistent_signs_at_roots p qs)", "by (simp add: in_set_member)"], ["proof (state)\nthis:\n  \\<forall>w.\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) \\<noteq>\n     0 \\<longrightarrow>\n     w \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. solve_for_lhs_R p qs subsets (M_mat_R signs subsets) =\n    vec_of_list\n     (map rat_of_nat\n       (map (\\<lambda>s.\n                card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s})\n         signs)) \\<Longrightarrow>\n    \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n       0 \\<longrightarrow>\n       signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n       0 \\<longrightarrow>\n       signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)", "using h0 h3"], ["proof (prove)\nusing this:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n =\n     0 \\<longrightarrow>\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = signs ! n}) =\n     0\n  \\<forall>w.\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = w}) \\<noteq>\n     0 \\<longrightarrow>\n     w \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. \\<forall>n<dim_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n       0 \\<longrightarrow>\n       signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)", "by (metis (no_types, lifting) \\<open>solve_for_lhs_R p qs subsets (matrix_A_R signs subsets) = vec_of_list (map rat_of_nat (map (\\<lambda>s. card {x. poly p x = 0 \\<and> consistent_sign_vec qs x = s}) signs))\\<close> dim_vec_of_list length_map nth_map vec_of_list_index)"], ["proof (state)\nthis:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n     0 \\<longrightarrow>\n     signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n     0 \\<longrightarrow>\n     signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n     0 \\<longrightarrow>\n     signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)", "have \"set (take_indices signs\n                 (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))) \\<subseteq>\n              set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\nusing this:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n     0 \\<longrightarrow>\n     signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (take_indices signs\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "using all_info\n        reduction_signs_set_helper_lemma2[where A = \"set (characterize_consistent_signs_at_roots p qs)\", where B = \"signs\",\n        where C = \"(solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))\"]"], ["proof (prove)\nusing this:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n     0 \\<longrightarrow>\n     signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  \\<lbrakk>distinct signs;\n   dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n   length signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   \\<forall>n<dim_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n      solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n      0 \\<longrightarrow>\n      signs ! n\n      \\<in> set (characterize_consistent_signs_at_roots p qs)\\<rbrakk>\n  \\<Longrightarrow> set (take_indices signs\n                          (find_nonzeros_from_input_vec\n                            (solve_for_lhs_R p qs subsets\n                              (M_mat_R signs subsets))))\n                    \\<subseteq> set (characterize_consistent_signs_at_roots\np qs)\n\ngoal (1 subgoal):\n 1. set (take_indices signs\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "using distinct_signs dim_hyp2 solve_for_lhs_R_def"], ["proof (prove)\nusing this:\n  \\<forall>n<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n     solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n     0 \\<longrightarrow>\n     signs ! n \\<in> set (characterize_consistent_signs_at_roots p qs)\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  \\<lbrakk>distinct signs;\n   dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n   length signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   \\<forall>n<dim_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)).\n      solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n      0 \\<longrightarrow>\n      signs ! n\n      \\<in> set (characterize_consistent_signs_at_roots p qs)\\<rbrakk>\n  \\<Longrightarrow> set (take_indices signs\n                          (find_nonzeros_from_input_vec\n                            (solve_for_lhs_R p qs subsets\n                              (M_mat_R signs subsets))))\n                    \\<subseteq> set (characterize_consistent_signs_at_roots\np qs)\n  distinct signs\n  matr_option (dim_row (M_mat_R signs subsets))\n   (mat_inverse (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs) (length signs)\n  solve_for_lhs_R ?p ?qs ?subsets ?matr =\n  matr_option (dim_row ?matr) (mat_inverse_var ?matr) *\\<^sub>v\n  v_vec_R ?p ?qs ?subsets\n\ngoal (1 subgoal):\n 1. set (take_indices signs\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "by (simp add: mat_inverse_same)"], ["proof (state)\nthis:\n  set (take_indices signs\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  set (take_indices signs\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (take_indices signs\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "unfolding reduction_signs_R_def"], ["proof (prove)\nusing this:\n  set (take_indices signs\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (take_indices signs\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (characterize_consistent_signs_at_roots p qs)", "by auto"], ["proof (state)\nthis:\n  set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n  \\<subseteq> set (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n  \\<subseteq> set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs) =\n    set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "have subset: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(reduction_signs_R p qs signs subsets (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets))", "using reduction_doesnt_break_things_signs_R[of p qs signs subsets] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs; distinct signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   satisfy_equation_R p qs subsets signs;\n   invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n  \\<Longrightarrow> set (characterize_consistent_signs_at_roots p qs)\n                    \\<subseteq> set (reduction_signs_R p qs signs subsets\n(M_mat_R signs subsets))\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets))", "by blast"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (reduction_signs_R p qs signs subsets\n                    (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs) =\n    set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (reduction_signs_R p qs signs subsets\n                    (M_mat_R signs subsets))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (reduction_signs_R p qs signs subsets\n                    (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs) =\n    set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "using supset subset"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (reduction_signs_R p qs signs subsets\n                    (M_mat_R signs subsets))\n  set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n  \\<subseteq> set (characterize_consistent_signs_at_roots p qs)\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (reduction_signs_R p qs signs subsets\n                    (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs) =\n    set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "by auto"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p qs) =\n  set (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem reduce_system_sign_conditions_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"set (get_signs_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs))))) = set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (get_signs_R\n          (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    set (characterize_consistent_signs_at_roots p qs)", "unfolding get_signs_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (qs, M_mat_R signs subsets, subsets, signs)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "using reduction_deletes_bad_sign_conds_R[of p qs signs subsets]"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs; distinct signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   satisfy_equation_R p qs subsets signs;\n   invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n  \\<Longrightarrow> set (characterize_consistent_signs_at_roots p qs) =\n                    set (reduction_signs_R p qs signs subsets\n                          (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (qs, M_mat_R signs subsets, subsets, signs)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs;\n                 distinct signs;\n                 set (characterize_consistent_signs_at_roots p qs)\n                 \\<subseteq> set signs;\n                 satisfy_equation_R p qs subsets signs;\n                 invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n                \\<Longrightarrow> set (characterize_consistent_signs_at_roots\n  p qs) =\n                                  set (reduction_signs_R p qs signs subsets\n  (M_mat_R signs subsets));\n        x \\<in> set (snd (snd (let reduce_cols_A =\n                                     take_cols_from_matrix\n(M_mat_R signs subsets)\n(find_nonzeros_from_input_vec\n  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n                                   rows_keep = rows_to_keep reduce_cols_A\n                               in (take_rows_from_matrix reduce_cols_A\n                                    rows_keep,\n                                   take_indices subsets rows_keep,\n                                   take_indices signs\n                                    (find_nonzeros_from_input_vec\n(solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (characterize_consistent_signs_at_roots\n p qs)\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs;\n                 distinct signs;\n                 set (characterize_consistent_signs_at_roots p qs)\n                 \\<subseteq> set signs;\n                 satisfy_equation_R p qs subsets signs;\n                 invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n                \\<Longrightarrow> set (characterize_consistent_signs_at_roots\n  p qs) =\n                                  set (reduction_signs_R p qs signs subsets\n  (M_mat_R signs subsets));\n        x \\<in> set (characterize_consistent_signs_at_roots p qs)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (snd\n (snd (let reduce_cols_A =\n             take_cols_from_matrix (M_mat_R signs subsets)\n              (find_nonzeros_from_input_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n           rows_keep = rows_to_keep reduce_cols_A\n       in (take_rows_from_matrix reduce_cols_A rows_keep,\n           take_indices subsets rows_keep,\n           take_indices signs\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))))", "apply (simp add: all_info distinct_signs match nonzero reduction_signs_def welldefined_signs1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>invertible_mat (M_mat_R signs subsets) \\<Longrightarrow>\n                set (characterize_consistent_signs_at_roots p qs) =\n                set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets));\n        x \\<in> set (snd (snd (let reduce_cols_A =\n                                     take_cols_from_matrix\n(M_mat_R signs subsets)\n(find_nonzeros_from_input_vec\n  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n                                   rows_keep = rows_to_keep reduce_cols_A\n                               in (take_rows_from_matrix reduce_cols_A\n                                    rows_keep,\n                                   take_indices subsets rows_keep,\n                                   take_indices signs\n                                    (find_nonzeros_from_input_vec\n(solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (characterize_consistent_signs_at_roots\n p qs)\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs;\n                 distinct signs;\n                 set (characterize_consistent_signs_at_roots p qs)\n                 \\<subseteq> set signs;\n                 satisfy_equation_R p qs subsets signs;\n                 invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n                \\<Longrightarrow> set (characterize_consistent_signs_at_roots\n  p qs) =\n                                  set (reduction_signs_R p qs signs subsets\n  (M_mat_R signs subsets));\n        x \\<in> set (characterize_consistent_signs_at_roots p qs)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (snd\n (snd (let reduce_cols_A =\n             take_cols_from_matrix (M_mat_R signs subsets)\n              (find_nonzeros_from_input_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n           rows_keep = rows_to_keep reduce_cols_A\n       in (take_rows_from_matrix reduce_cols_A rows_keep,\n           take_indices subsets rows_keep,\n           take_indices signs\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))))", "using nonzero invertible_mat snd_conv"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  invertible_mat (M_mat_R signs subsets)\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>invertible_mat (M_mat_R signs subsets) \\<Longrightarrow>\n                set (characterize_consistent_signs_at_roots p qs) =\n                set (reduction_signs_R p qs signs subsets\n                      (M_mat_R signs subsets));\n        x \\<in> set (snd (snd (let reduce_cols_A =\n                                     take_cols_from_matrix\n(M_mat_R signs subsets)\n(find_nonzeros_from_input_vec\n  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n                                   rows_keep = rows_to_keep reduce_cols_A\n                               in (take_rows_from_matrix reduce_cols_A\n                                    rows_keep,\n                                   take_indices subsets rows_keep,\n                                   take_indices signs\n                                    (find_nonzeros_from_input_vec\n(solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (characterize_consistent_signs_at_roots\n p qs)\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs;\n                 distinct signs;\n                 set (characterize_consistent_signs_at_roots p qs)\n                 \\<subseteq> set signs;\n                 satisfy_equation_R p qs subsets signs;\n                 invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n                \\<Longrightarrow> set (characterize_consistent_signs_at_roots\n  p qs) =\n                                  set (reduction_signs_R p qs signs subsets\n  (M_mat_R signs subsets));\n        x \\<in> set (characterize_consistent_signs_at_roots p qs)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (snd\n (snd (let reduce_cols_A =\n             take_cols_from_matrix (M_mat_R signs subsets)\n              (find_nonzeros_from_input_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n           rows_keep = rows_to_keep reduce_cols_A\n       in (take_rows_from_matrix reduce_cols_A rows_keep,\n           take_indices subsets rows_keep,\n           take_indices signs\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))))", "apply (metis reduction_signs_R_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs;\n                 distinct signs;\n                 set (characterize_consistent_signs_at_roots p qs)\n                 \\<subseteq> set signs;\n                 satisfy_equation_R p qs subsets signs;\n                 invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n                \\<Longrightarrow> set (characterize_consistent_signs_at_roots\n  p qs) =\n                                  set (reduction_signs_R p qs signs subsets\n  (M_mat_R signs subsets));\n        x \\<in> set (characterize_consistent_signs_at_roots p qs)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (snd\n (snd (let reduce_cols_A =\n             take_cols_from_matrix (M_mat_R signs subsets)\n              (find_nonzeros_from_input_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n           rows_keep = rows_to_keep reduce_cols_A\n       in (take_rows_from_matrix reduce_cols_A rows_keep,\n           take_indices subsets rows_keep,\n           take_indices signs\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))))", "by (metis all_info distinct_signs invertible_mat match nonzero reduction_signs_R_def snd_conv welldefined_signs1)"], ["", "subsection \"Showing matrix equation preserved when reducing\""], ["", "lemma reduce_system_matrix_equation_preserved_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs: \"well_def_signs (length qs) signs\"\n  assumes welldefined_subsets: \"all_list_constr_R (subsets) (length qs)\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes invertible_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"satisfy_equation_R p qs (get_subsets_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\n  (get_signs_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have poly_type_hyp: \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using nonzero"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have distinct_signs_hyp: \"distinct (snd (snd (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (snd (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct\n     (snd (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))", "let ?sym = \"(find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. distinct\n     (snd (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))", "have h1: \"\\<forall> i < length (take_indices signs ?sym). \\<forall>j < length(take_indices signs ?sym).\n      i \\<noteq> j \\<longrightarrow> nth (take_indices signs ?sym) i \\<noteq> nth (take_indices signs ?sym) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (take_indices signs\n                  (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets\n                      (M_mat_R signs subsets)))).\n       \\<forall>j<length\n                   (take_indices signs\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))).\n          i \\<noteq> j \\<longrightarrow>\n          take_indices signs\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n          i \\<noteq>\n          take_indices signs\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n          j", "using distinct_signs"], ["proof (prove)\nusing this:\n  distinct signs\n\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (take_indices signs\n                  (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets\n                      (M_mat_R signs subsets)))).\n       \\<forall>j<length\n                   (take_indices signs\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))).\n          i \\<noteq> j \\<longrightarrow>\n          take_indices signs\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n          i \\<noteq>\n          take_indices signs\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n          j", "unfolding take_indices_def"], ["proof (prove)\nusing this:\n  distinct signs\n\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (map ((!) signs)\n                  (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets\n                      (M_mat_R signs subsets)))).\n       \\<forall>j<length\n                   (map ((!) signs)\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))).\n          i \\<noteq> j \\<longrightarrow>\n          map ((!) signs)\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n          i \\<noteq>\n          map ((!) signs)\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n          j", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>distinct signs;\n        i < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        j < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        i \\<noteq> j;\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         i) =\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         j)\\<rbrakk>\n       \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>distinct signs;\n        i < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        j < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        i \\<noteq> j;\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         i) =\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         j)\\<rbrakk>\n       \\<Longrightarrow> False", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>distinct signs;\n        i < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        j < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        i \\<noteq> j;\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         i) =\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         j)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"distinct signs\""], ["proof (state)\nthis:\n  distinct signs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>distinct signs;\n        i < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        j < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        i \\<noteq> j;\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         i) =\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         j)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"i < length\n                (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\""], ["proof (state)\nthis:\n  i < length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>distinct signs;\n        i < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        j < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        i \\<noteq> j;\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         i) =\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         j)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"j < length\n                (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\""], ["proof (state)\nthis:\n  j < length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>distinct signs;\n        i < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        j < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        i \\<noteq> j;\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         i) =\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         j)\\<rbrakk>\n       \\<Longrightarrow> False", "assume neq_hyp: \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>distinct signs;\n        i < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        j < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        i \\<noteq> j;\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         i) =\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         j)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"signs ! (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets \n              (matrix_A_R signs subsets)) ! i) =\n           signs ! (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets \n              (matrix_A_R signs subsets)) ! j)\""], ["proof (state)\nthis:\n  signs !\n  (find_nonzeros_from_input_vec\n    (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n   i) =\n  signs !\n  (find_nonzeros_from_input_vec\n    (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n   j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>distinct signs;\n        i < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        j < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        i \\<noteq> j;\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         i) =\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         j)\\<rbrakk>\n       \\<Longrightarrow> False", "have h1: \"find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets \n              (matrix_A_R signs subsets)) ! i \\<noteq> find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets \n              (matrix_A_R signs subsets)) ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n    i \\<noteq>\n    find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n    j", "unfolding find_nonzeros_from_input_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n    i \\<noteq>\n    filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n    j", "using neq_hyp"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n    i \\<noteq>\n    filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n    j", "by (metis \\<open>i < length (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\\<close> \\<open>j < length (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\\<close> distinct_conv_nth distinct_filter distinct_upt find_nonzeros_from_input_vec_def)"], ["proof (state)\nthis:\n  find_nonzeros_from_input_vec\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n  i \\<noteq>\n  find_nonzeros_from_input_vec\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n  j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>distinct signs;\n        i < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        j < length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n        i \\<noteq> j;\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         i) =\n        signs !\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n         j)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  find_nonzeros_from_input_vec\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n  i \\<noteq>\n  find_nonzeros_from_input_vec\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n  j", "show \"False\""], ["proof (prove)\nusing this:\n  find_nonzeros_from_input_vec\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n  i \\<noteq>\n  find_nonzeros_from_input_vec\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n  j\n\ngoal (1 subgoal):\n 1. False", "using distinct_signs"], ["proof (prove)\nusing this:\n  find_nonzeros_from_input_vec\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n  i \\<noteq>\n  find_nonzeros_from_input_vec\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n  j\n  distinct signs\n\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n             i \\<noteq>\n             find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n             j;\n     distinct signs\\<rbrakk>\n    \\<Longrightarrow> False", "have f1: \"\\<forall>p ns n. ((n::nat) \\<in> {n \\<in> set ns. p n}) = (n \\<in> set ns \\<and> n \\<in> Collect p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p ns n.\n       (n \\<in> {n \\<in> set ns. p n}) =\n       (n \\<in> set ns \\<and> n \\<in> Collect p)", "by simp"], ["proof (state)\nthis:\n  \\<forall>p ns n.\n     (n \\<in> {n \\<in> set ns. p n}) =\n     (n \\<in> set ns \\<and> n \\<in> Collect p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n             i \\<noteq>\n             find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n             j;\n     distinct signs\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>p ns n.\n     (n \\<in> {n \\<in> set ns. p n}) =\n     (n \\<in> set ns \\<and> n \\<in> Collect p)", "have f2: \"filter (\\<lambda>n. solve_for_lhs_R p qs subsets (matrix_A_R signs subsets) $ n \\<noteq> 0) [0..<dim_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))] ! i \\<in> set [0..<length signs]\""], ["proof (prove)\nusing this:\n  \\<forall>p ns n.\n     (n \\<in> {n \\<in> set ns. p n}) =\n     (n \\<in> set ns \\<and> n \\<in> Collect p)\n\ngoal (1 subgoal):\n 1. filter\n     (\\<lambda>n.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n    i\n    \\<in> set [0..<length signs]", "by (metis (full_types) \\<open>i < length (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\\<close> construct_lhs_matches_solve_for_lhs_R find_nonzeros_from_input_vec_def invertible_mat match nth_mem set_filter size_of_lhs_R)"], ["proof (state)\nthis:\n  filter\n   (\\<lambda>n.\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq> 0)\n   [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n  i\n  \\<in> set [0..<length signs]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n             i \\<noteq>\n             find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n             j;\n     distinct signs\\<rbrakk>\n    \\<Longrightarrow> False", "have \"filter (\\<lambda>n. solve_for_lhs_R p qs subsets (matrix_A_R signs subsets) $ n \\<noteq> 0) [0..<dim_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))] ! j \\<in> set [0..<length signs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter\n     (\\<lambda>n.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n    j\n    \\<in> set [0..<length signs]", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>p ns n.\n     (n \\<in> {n \\<in> set ns. p n}) =\n     (n \\<in> set ns \\<and> n \\<in> Collect p)\n\ngoal (1 subgoal):\n 1. filter\n     (\\<lambda>n.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n    j\n    \\<in> set [0..<length signs]", "by (metis (full_types) \\<open>j < length (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\\<close> construct_lhs_matches_solve_for_lhs_R find_nonzeros_from_input_vec_def invertible_mat match nth_mem set_filter size_of_lhs_R)"], ["proof (state)\nthis:\n  filter\n   (\\<lambda>n.\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq> 0)\n   [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n  j\n  \\<in> set [0..<length signs]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n             i \\<noteq>\n             find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) !\n             j;\n     distinct signs\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  filter\n   (\\<lambda>n.\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq> 0)\n   [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n  j\n  \\<in> set [0..<length signs]", "show ?thesis"], ["proof (prove)\nusing this:\n  filter\n   (\\<lambda>n.\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq> 0)\n   [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n  j\n  \\<in> set [0..<length signs]\n\ngoal (1 subgoal):\n 1. False", "using f2"], ["proof (prove)\nusing this:\n  filter\n   (\\<lambda>n.\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq> 0)\n   [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n  j\n  \\<in> set [0..<length signs]\n  filter\n   (\\<lambda>n.\n       solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ n \\<noteq> 0)\n   [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))] !\n  i\n  \\<in> set [0..<length signs]\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>signs ! (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)) ! i) = signs ! (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)) ! j)\\<close> atLeastLessThan_iff distinct_conv_nth distinct_signs find_nonzeros_from_input_vec_def h1 set_upt)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length\n              (take_indices signs\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))).\n     \\<forall>j<length\n                 (take_indices signs\n                   (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets)))).\n        i \\<noteq> j \\<longrightarrow>\n        take_indices signs\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n        i \\<noteq>\n        take_indices signs\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n        j\n\ngoal (1 subgoal):\n 1. distinct\n     (snd (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length\n              (take_indices signs\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))).\n     \\<forall>j<length\n                 (take_indices signs\n                   (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets)))).\n        i \\<noteq> j \\<longrightarrow>\n        take_indices signs\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n        i \\<noteq>\n        take_indices signs\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n        j", "have \"distinct (take_indices signs (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))\""], ["proof (prove)\nusing this:\n  \\<forall>i<length\n              (take_indices signs\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))).\n     \\<forall>j<length\n                 (take_indices signs\n                   (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets)))).\n        i \\<noteq> j \\<longrightarrow>\n        take_indices signs\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n        i \\<noteq>\n        take_indices signs\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n        j\n\ngoal (1 subgoal):\n 1. distinct\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "using distinct_conv_nth"], ["proof (prove)\nusing this:\n  \\<forall>i<length\n              (take_indices signs\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))).\n     \\<forall>j<length\n                 (take_indices signs\n                   (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets)))).\n        i \\<noteq> j \\<longrightarrow>\n        take_indices signs\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n        i \\<noteq>\n        take_indices signs\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) !\n        j\n  distinct ?xs =\n  (\\<forall>i<length ?xs.\n      \\<forall>j<length ?xs.\n         i \\<noteq> j \\<longrightarrow> ?xs ! i \\<noteq> ?xs ! j)\n\ngoal (1 subgoal):\n 1. distinct\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "by blast"], ["proof (state)\nthis:\n  distinct\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. distinct\n     (snd (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))", "then"], ["proof (chain)\npicking this:\n  distinct\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. distinct\n     (snd (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))", "using get_signs_R_def reduction_signs_R_def reduction_signs_is_get_signs_R"], ["proof (prove)\nusing this:\n  distinct\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  get_signs_R ?data = snd (snd ?data)\n  reduction_signs_R ?p ?qs ?signs ?subsets ?matr =\n  take_indices ?signs\n   (find_nonzeros_from_input_vec (solve_for_lhs_R ?p ?qs ?subsets ?matr))\n  reduction_signs_R ?p ?qs ?signs ?subsets ?m =\n  get_signs_R (reduce_system_R ?p (?qs, ?m, ?subsets, ?signs))\n\ngoal (1 subgoal):\n 1. distinct\n     (snd (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))", "by auto"], ["proof (state)\nthis:\n  distinct\n   (snd (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct\n   (snd (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have all_info_hyp: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(snd (snd (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (snd (snd (reduce_system_R p\n                                (qs, M_mat_R signs subsets, subsets,\n                                 signs))))", "using reduce_system_sign_conditions_R assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; well_def_signs (length ?qs) ?signs;\n   distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> set (get_signs_R\n                          (reduce_system_R ?p\n                            (?qs, M_mat_R ?signs ?subsets, ?subsets,\n                             ?signs))) =\n                    set (characterize_consistent_signs_at_roots ?p ?qs)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  all_list_constr_R subsets (length qs)\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (snd (snd (reduce_system_R p\n                                (qs, M_mat_R signs subsets, subsets,\n                                 signs))))", "unfolding get_signs_R_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; well_def_signs (length ?qs) ?signs;\n   distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> set (snd (snd (reduce_system_R ?p\n                                    (?qs, M_mat_R ?signs ?subsets, ?subsets,\n                                     ?signs)))) =\n                    set (characterize_consistent_signs_at_roots ?p ?qs)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  all_list_constr_R subsets (length qs)\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (snd (snd (reduce_system_R p\n                                (qs, M_mat_R signs subsets, subsets,\n                                 signs))))", "by auto"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (snd (snd (reduce_system_R p\n                              (qs, M_mat_R signs subsets, subsets, signs))))\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have welldefined_hyp: \"all_list_constr_R (fst (snd (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))) (length qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (fst (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))\n     (length qs)", "using welldefined_subsets rows_to_keep_lem"], ["proof (prove)\nusing this:\n  all_list_constr_R subsets (length qs)\n  ?ell \\<in> set (rows_to_keep ?A) \\<Longrightarrow> ?ell < dim_row ?A\n\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (fst (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))\n     (length qs)", "unfolding all_list_constr_R_def List.member_def list_constr_def list_all_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> set subsets \\<longrightarrow>\n     (\\<forall>x\\<in>set (fst x). x < length qs) \\<and>\n     (\\<forall>x\\<in>set (snd x). x < length qs)\n  ?ell \\<in> set (rows_to_keep ?A) \\<Longrightarrow> ?ell < dim_row ?A\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> set (fst (snd (reduce_system_R p\n                               (qs, M_mat_R signs subsets, subsets,\n                                signs)))) \\<longrightarrow>\n       (\\<forall>x\\<in>set (fst x). x < length qs) \\<and>\n       (\\<forall>x\\<in>set (snd x). x < length qs)", "apply (auto simp add: Let_def take_indices_def take_cols_from_matrix_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x xa.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> set subsets \\<longrightarrow>\n                   (\\<forall>x\\<in>set a. x < length qs) \\<and>\n                   (\\<forall>x\\<in>set b. x < length qs);\n        \\<And>ell A.\n           ell \\<in> set (rows_to_keep A) \\<Longrightarrow> ell < dim_row A;\n        (a, b) = subsets ! x;\n        x \\<in> set (rows_to_keep\n                      (mat_of_cols (length subsets)\n                        (map ((!) (cols (M_mat_R signs subsets)))\n                          (find_nonzeros_from_input_vec\n                            (solve_for_lhs_R p qs subsets\n                              (M_mat_R signs subsets))))));\n        xa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> xa < length qs\n 2. \\<And>a b x xa.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> set subsets \\<longrightarrow>\n                   (\\<forall>x\\<in>set a. x < length qs) \\<and>\n                   (\\<forall>x\\<in>set b. x < length qs);\n        \\<And>ell A.\n           ell \\<in> set (rows_to_keep A) \\<Longrightarrow> ell < dim_row A;\n        (a, b) = subsets ! x;\n        x \\<in> set (rows_to_keep\n                      (mat_of_cols (length subsets)\n                        (map ((!) (cols (M_mat_R signs subsets)))\n                          (find_nonzeros_from_input_vec\n                            (solve_for_lhs_R p qs subsets\n                              (M_mat_R signs subsets))))));\n        xa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> xa < length qs", "using nth_mem"], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (2 subgoals):\n 1. \\<And>a b x xa.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> set subsets \\<longrightarrow>\n                   (\\<forall>x\\<in>set a. x < length qs) \\<and>\n                   (\\<forall>x\\<in>set b. x < length qs);\n        \\<And>ell A.\n           ell \\<in> set (rows_to_keep A) \\<Longrightarrow> ell < dim_row A;\n        (a, b) = subsets ! x;\n        x \\<in> set (rows_to_keep\n                      (mat_of_cols (length subsets)\n                        (map ((!) (cols (M_mat_R signs subsets)))\n                          (find_nonzeros_from_input_vec\n                            (solve_for_lhs_R p qs subsets\n                              (M_mat_R signs subsets))))));\n        xa \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> xa < length qs\n 2. \\<And>a b x xa.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> set subsets \\<longrightarrow>\n                   (\\<forall>x\\<in>set a. x < length qs) \\<and>\n                   (\\<forall>x\\<in>set b. x < length qs);\n        \\<And>ell A.\n           ell \\<in> set (rows_to_keep A) \\<Longrightarrow> ell < dim_row A;\n        (a, b) = subsets ! x;\n        x \\<in> set (rows_to_keep\n                      (mat_of_cols (length subsets)\n                        (map ((!) (cols (M_mat_R signs subsets)))\n                          (find_nonzeros_from_input_vec\n                            (solve_for_lhs_R p qs subsets\n                              (M_mat_R signs subsets))))));\n        xa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> xa < length qs", "apply (smt (z3) mat_of_cols_carrier(2) rows_to_keep_lem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> set subsets \\<longrightarrow>\n                   (\\<forall>x\\<in>set a. x < length qs) \\<and>\n                   (\\<forall>x\\<in>set b. x < length qs);\n        \\<And>ell A.\n           ell \\<in> set (rows_to_keep A) \\<Longrightarrow> ell < dim_row A;\n        (a, b) = subsets ! x;\n        x \\<in> set (rows_to_keep\n                      (mat_of_cols (length subsets)\n                        (map ((!) (cols (M_mat_R signs subsets)))\n                          (find_nonzeros_from_input_vec\n                            (solve_for_lhs_R p qs subsets\n                              (M_mat_R signs subsets))))));\n        xa \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> xa < length qs", "by (smt (z3) mat_of_cols_carrier(2) nth_mem rows_to_keep_lem)"], ["proof (state)\nthis:\n  all_list_constr_R\n   (fst (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n   (length qs)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  all_list_constr_R\n   (fst (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n   (length qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  all_list_constr_R\n   (fst (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n   (length qs)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "using poly_type_hyp distinct_signs_hyp all_info_hyp  welldefined_hyp"], ["proof (prove)\nusing this:\n  all_list_constr_R\n   (fst (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n   (length qs)\n  p \\<noteq> 0\n  distinct\n   (snd (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (snd (snd (reduce_system_R p\n                              (qs, M_mat_R signs subsets, subsets, signs))))\n  all_list_constr_R\n   (fst (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n   (length qs)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "using matrix_equation_R"], ["proof (prove)\nusing this:\n  all_list_constr_R\n   (fst (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n   (length qs)\n  p \\<noteq> 0\n  distinct\n   (snd (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (snd (snd (reduce_system_R p\n                              (qs, M_mat_R signs subsets, subsets, signs))))\n  all_list_constr_R\n   (fst (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n   (length qs)\n  \\<lbrakk>?p \\<noteq> 0; distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   all_list_constr_R ?subsets (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R ?p ?qs ?subsets ?signs\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "unfolding get_subsets_R_def get_signs_R_def"], ["proof (prove)\nusing this:\n  all_list_constr_R\n   (fst (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n   (length qs)\n  p \\<noteq> 0\n  distinct\n   (snd (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (snd (snd (reduce_system_R p\n                              (qs, M_mat_R signs subsets, subsets, signs))))\n  all_list_constr_R\n   (fst (snd (reduce_system_R p\n               (qs, M_mat_R signs subsets, subsets, signs))))\n   (length qs)\n  \\<lbrakk>?p \\<noteq> 0; distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   all_list_constr_R ?subsets (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R ?p ?qs ?subsets ?signs\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (fst (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))\n     (snd (snd (reduce_system_R p\n                 (qs, M_mat_R signs subsets, subsets, signs))))", "by blast"], ["proof (state)\nthis:\n  satisfy_equation_R p qs\n   (get_subsets_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n   (get_signs_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Show that we are tracking the correct matrix in the algorithm *)"], ["", "subsection \"Showing matrix preserved\""], ["", "lemma reduce_system_matrix_signs_helper_aux_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  fixes S:: \"nat list\"\n  assumes well_def_h: \"\\<forall>x. List.member S x \\<longrightarrow> x < length signs\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"alt_matrix_A_R (take_indices signs S) subsets = take_cols_from_matrix (alt_matrix_A_R signs subsets) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_matrix_A_R (take_indices signs S) subsets =\n    take_cols_from_matrix (alt_matrix_A_R signs subsets) S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alt_matrix_A_R (take_indices signs S) subsets =\n    take_cols_from_matrix (alt_matrix_A_R signs subsets) S", "have h0a: \"dim_col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) = length (take_indices signs S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) =\n    length (take_indices signs S)", "unfolding take_cols_from_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (mat_of_cols (dim_row (alt_matrix_A_R signs subsets))\n       (take_indices (cols (alt_matrix_A_R signs subsets)) S)) =\n    length (take_indices signs S)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take_indices (cols (alt_matrix_A_R signs subsets)) S) =\n    length (take_indices signs S)", "unfolding take_indices_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ((!) (cols (alt_matrix_A_R signs subsets))) S) =\n    length (map ((!) signs) S)", "by auto"], ["proof (state)\nthis:\n  dim_col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) =\n  length (take_indices signs S)\n\ngoal (1 subgoal):\n 1. alt_matrix_A_R (take_indices signs S) subsets =\n    take_cols_from_matrix (alt_matrix_A_R signs subsets) S", "have h0: \"\\<forall>i < length (take_indices signs S). (col (alt_matrix_A_R (take_indices signs S) subsets ) i = \ncol (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (take_indices signs S).\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "assume asm: \"i < length (take_indices signs S)\""], ["proof (state)\nthis:\n  i < length (take_indices signs S)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "have i_lt: \"i < length (map ((!) (cols (alt_matrix_A_R signs subsets))) S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (map ((!) (cols (alt_matrix_A_R signs subsets))) S)", "using asm"], ["proof (prove)\nusing this:\n  i < length (take_indices signs S)\n\ngoal (1 subgoal):\n 1. i < length (map ((!) (cols (alt_matrix_A_R signs subsets))) S)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (take_indices signs S) \\<Longrightarrow> i < length S", "unfolding take_indices_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (map ((!) signs) S) \\<Longrightarrow> i < length S", "by auto"], ["proof (state)\nthis:\n  i < length (map ((!) (cols (alt_matrix_A_R signs subsets))) S)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "have h0: \" vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (map ((!) signs) S ! i)) = \n      vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (length subsets)\n     (\\<lambda>j. z_R (subsets ! j) (map ((!) signs) S ! i)) =\n    vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i)))", "using nth_map"], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n\ngoal (1 subgoal):\n 1. vec (length subsets)\n     (\\<lambda>j. z_R (subsets ! j) (map ((!) signs) S ! i)) =\n    vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i)))", "by (metis \\<open>i < length (take_indices signs S)\\<close> length_map take_indices_def)"], ["proof (state)\nthis:\n  vec (length subsets)\n   (\\<lambda>j. z_R (subsets ! j) (map ((!) signs) S ! i)) =\n  vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "have dim: \"(map ((!) (cols (alt_matrix_A_R signs subsets))) S) ! i \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "have \"dim_col (alt_matrix_A_R signs subsets) = length (signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (alt_matrix_A_R signs subsets) = length signs", "by (simp add: alt_matrix_A_R_def)"], ["proof (state)\nthis:\n  dim_col (alt_matrix_A_R signs subsets) = length signs\n\ngoal (1 subgoal):\n 1. map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "have well_d: \"S ! i < length (signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S ! i < length signs", "using well_def_h"], ["proof (prove)\nusing this:\n  \\<forall>x. List.member S x \\<longrightarrow> x < length signs\n\ngoal (1 subgoal):\n 1. S ! i < length signs", "using i_lt in_set_member"], ["proof (prove)\nusing this:\n  \\<forall>x. List.member S x \\<longrightarrow> x < length signs\n  i < length (map ((!) (cols (alt_matrix_A_R signs subsets))) S)\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. S ! i < length signs", "by fastforce"], ["proof (state)\nthis:\n  S ! i < length signs\n\ngoal (1 subgoal):\n 1. map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "have \n        map_eq: \"(map ((!) (cols (alt_matrix_A_R signs subsets))) S) ! i  = nth (cols (alt_matrix_A_R signs subsets))  (S ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i =\n    cols (alt_matrix_A_R signs subsets) ! (S ! i)", "using i_lt"], ["proof (prove)\nusing this:\n  i < length (map ((!) (cols (alt_matrix_A_R signs subsets))) S)\n\ngoal (1 subgoal):\n 1. map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i =\n    cols (alt_matrix_A_R signs subsets) ! (S ! i)", "by auto"], ["proof (state)\nthis:\n  map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i =\n  cols (alt_matrix_A_R signs subsets) ! (S ! i)\n\ngoal (1 subgoal):\n 1. map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "have \"nth (cols (alt_matrix_A_R signs subsets))  (S ! i) \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols (alt_matrix_A_R signs subsets) ! (S ! i)\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "using col_dim"], ["proof (prove)\nusing this:\n  col ?A ?i \\<in> carrier_vec (dim_row ?A)\n\ngoal (1 subgoal):\n 1. cols (alt_matrix_A_R signs subsets) ! (S ! i)\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "unfolding cols_def"], ["proof (prove)\nusing this:\n  col ?A ?i \\<in> carrier_vec (dim_row ?A)\n\ngoal (1 subgoal):\n 1. map (col (alt_matrix_A_R signs subsets))\n     [0..<dim_col (alt_matrix_A_R signs subsets)] !\n    (S ! i)\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "using nth_map well_d"], ["proof (prove)\nusing this:\n  col ?A ?i \\<in> carrier_vec (dim_row ?A)\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n  S ! i < length signs\n\ngoal (1 subgoal):\n 1. map (col (alt_matrix_A_R signs subsets))\n     [0..<dim_col (alt_matrix_A_R signs subsets)] !\n    (S ! i)\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "by (simp add: \\<open>dim_col (alt_matrix_A_R signs subsets) = length signs\\<close>)"], ["proof (state)\nthis:\n  cols (alt_matrix_A_R signs subsets) ! (S ! i)\n  \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))\n\ngoal (1 subgoal):\n 1. map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  cols (alt_matrix_A_R signs subsets) ! (S ! i)\n  \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "show ?thesis"], ["proof (prove)\nusing this:\n  cols (alt_matrix_A_R signs subsets) ! (S ! i)\n  \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))\n\ngoal (1 subgoal):\n 1. map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "using map_eq"], ["proof (prove)\nusing this:\n  cols (alt_matrix_A_R signs subsets) ! (S ! i)\n  \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))\n  map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i =\n  cols (alt_matrix_A_R signs subsets) ! (S ! i)\n\ngoal (1 subgoal):\n 1. map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))", "by auto"], ["proof (state)\nthis:\n  map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n  \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n  \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "have h1: \"col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i = \n      col (mat_of_cols (dim_row (alt_matrix_A_R signs subsets)) (map ((!) (cols (alt_matrix_A_R signs subsets))) S)) i \""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i =\n    col (mat_of_cols (dim_row (alt_matrix_A_R signs subsets))\n          (map ((!) (cols (alt_matrix_A_R signs subsets))) S))\n     i", "by (simp add: take_cols_from_matrix_def take_indices_def)"], ["proof (state)\nthis:\n  col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i =\n  col (mat_of_cols (dim_row (alt_matrix_A_R signs subsets))\n        (map ((!) (cols (alt_matrix_A_R signs subsets))) S))\n   i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "have h2: \"col (mat_of_cols (dim_row (alt_matrix_A_R signs subsets)) (map ((!) (cols (alt_matrix_A_R signs subsets))) S)) i \n      = nth (map ((!) (cols (alt_matrix_A_R signs subsets))) S) i \""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mat_of_cols (dim_row (alt_matrix_A_R signs subsets))\n          (map ((!) (cols (alt_matrix_A_R signs subsets))) S))\n     i =\n    map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i", "using dim i_lt asm col_mat_of_cols[where j = \"i\", where n = \"(dim_row (alt_matrix_A_R signs subsets))\",\n          where vs = \"(map ((!) (cols (alt_matrix_A_R signs subsets))) S)\"]"], ["proof (prove)\nusing this:\n  map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n  \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))\n  i < length (map ((!) (cols (alt_matrix_A_R signs subsets))) S)\n  i < length (take_indices signs S)\n  \\<lbrakk>i < length (map ((!) (cols (alt_matrix_A_R signs subsets))) S);\n   map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n   \\<in> carrier_vec (dim_row (alt_matrix_A_R signs subsets))\\<rbrakk>\n  \\<Longrightarrow> col (mat_of_cols\n                          (dim_row (alt_matrix_A_R signs subsets))\n                          (map ((!) (cols (alt_matrix_A_R signs subsets)))\n                            S))\n                     i =\n                    map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n\ngoal (1 subgoal):\n 1. col (mat_of_cols (dim_row (alt_matrix_A_R signs subsets))\n          (map ((!) (cols (alt_matrix_A_R signs subsets))) S))\n     i =\n    map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i", "by blast"], ["proof (state)\nthis:\n  col (mat_of_cols (dim_row (alt_matrix_A_R signs subsets))\n        (map ((!) (cols (alt_matrix_A_R signs subsets))) S))\n   i =\n  map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "have h3: \"col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i = (col (alt_matrix_A_R signs subsets) (S !i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i =\n    col (alt_matrix_A_R signs subsets) (S ! i)", "using h1 h2"], ["proof (prove)\nusing this:\n  col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i =\n  col (mat_of_cols (dim_row (alt_matrix_A_R signs subsets))\n        (map ((!) (cols (alt_matrix_A_R signs subsets))) S))\n   i\n  col (mat_of_cols (dim_row (alt_matrix_A_R signs subsets))\n        (map ((!) (cols (alt_matrix_A_R signs subsets))) S))\n   i =\n  map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\n\ngoal (1 subgoal):\n 1. col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i =\n    col (alt_matrix_A_R signs subsets) (S ! i)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S)\n              i =\n             map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i;\n     col (mat_of_cols (dim_row (alt_matrix_A_R signs subsets))\n           (map ((!) (cols (alt_matrix_A_R signs subsets))) S))\n      i =\n     map ((!) (cols (alt_matrix_A_R signs subsets))) S ! i\\<rbrakk>\n    \\<Longrightarrow> map ((!) (cols (alt_matrix_A_R signs subsets))) S !\n                      i =\n                      col (alt_matrix_A_R signs subsets) (S ! i)", "by (metis alt_matrix_char_R asm cols_nth dim_col_mat(1) in_set_member length_map mat_of_rows_list_def matrix_A_R_def nth_map nth_mem take_indices_def well_def_h)"], ["proof (state)\nthis:\n  col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i =\n  col (alt_matrix_A_R signs subsets) (S ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "have \"vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i))) = (col (alt_matrix_A_R signs subsets) (S !i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i))) =\n    col (alt_matrix_A_R signs subsets) (S ! i)", "by (metis asm in_set_member length_map nth_mem signs_are_cols_R take_indices_def well_def_h)"], ["proof (state)\nthis:\n  vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i))) =\n  col (alt_matrix_A_R signs subsets) (S ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "then"], ["proof (chain)\npicking this:\n  vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i))) =\n  col (alt_matrix_A_R signs subsets) (S ! i)", "have \"vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (take_indices signs S ! i)) =\n      col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i \""], ["proof (prove)\nusing this:\n  vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i))) =\n  col (alt_matrix_A_R signs subsets) (S ! i)\n\ngoal (1 subgoal):\n 1. vec (length subsets)\n     (\\<lambda>j. z_R (subsets ! j) (take_indices signs S ! i)) =\n    col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "using h0 h3"], ["proof (prove)\nusing this:\n  vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i))) =\n  col (alt_matrix_A_R signs subsets) (S ! i)\n  vec (length subsets)\n   (\\<lambda>j. z_R (subsets ! j) (map ((!) signs) S ! i)) =\n  vec (length subsets) (\\<lambda>j. z_R (subsets ! j) (signs ! (S ! i)))\n  col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i =\n  col (alt_matrix_A_R signs subsets) (S ! i)\n\ngoal (1 subgoal):\n 1. vec (length subsets)\n     (\\<lambda>j. z_R (subsets ! j) (take_indices signs S ! i)) =\n    col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "by (simp add: take_indices_def)"], ["proof (state)\nthis:\n  vec (length subsets)\n   (\\<lambda>j. z_R (subsets ! j) (take_indices signs S ! i)) =\n  col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices signs S) \\<Longrightarrow>\n       col (alt_matrix_A_R (take_indices signs S) subsets) i =\n       col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "then"], ["proof (chain)\npicking this:\n  vec (length subsets)\n   (\\<lambda>j. z_R (subsets ! j) (take_indices signs S ! i)) =\n  col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "show \"col (alt_matrix_A_R (take_indices signs S) subsets) i =\n         col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i \""], ["proof (prove)\nusing this:\n  vec (length subsets)\n   (\\<lambda>j. z_R (subsets ! j) (take_indices signs S ! i)) =\n  col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i\n\ngoal (1 subgoal):\n 1. col (alt_matrix_A_R (take_indices signs S) subsets) i =\n    col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "using asm signs_are_cols_R[where signs = \"(take_indices signs S)\", where subsets = \"subsets\"]"], ["proof (prove)\nusing this:\n  vec (length subsets)\n   (\\<lambda>j. z_R (subsets ! j) (take_indices signs S ! i)) =\n  col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i\n  i < length (take_indices signs S)\n  \\<forall>i<length (take_indices signs S).\n     col (alt_matrix_A_R (take_indices signs S) subsets) i =\n     vec (length subsets)\n      (\\<lambda>j. z_R (subsets ! j) (take_indices signs S ! i))\n\ngoal (1 subgoal):\n 1. col (alt_matrix_A_R (take_indices signs S) subsets) i =\n    col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "by auto"], ["proof (state)\nthis:\n  col (alt_matrix_A_R (take_indices signs S) subsets) i =\n  col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length (take_indices signs S).\n     col (alt_matrix_A_R (take_indices signs S) subsets) i =\n     col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i\n\ngoal (1 subgoal):\n 1. alt_matrix_A_R (take_indices signs S) subsets =\n    take_cols_from_matrix (alt_matrix_A_R signs subsets) S", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length (take_indices signs S).\n     col (alt_matrix_A_R (take_indices signs S) subsets) i =\n     col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length (take_indices signs S).\n     col (alt_matrix_A_R (take_indices signs S) subsets) i =\n     col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) i\n\ngoal (1 subgoal):\n 1. alt_matrix_A_R (take_indices signs S) subsets =\n    take_cols_from_matrix (alt_matrix_A_R signs subsets) S", "unfolding alt_matrix_A_R_def take_cols_from_matrix_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length (take_indices signs S).\n     col (mat (length subsets) (length (take_indices signs S))\n           (\\<lambda>(i, j). z_R (subsets ! i) (take_indices signs S ! j)))\n      i =\n     col (mat_of_cols\n           (dim_row\n             (mat (length subsets) (length signs)\n               (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n           (take_indices\n             (cols\n               (mat (length subsets) (length signs)\n                 (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n             S))\n      i\n\ngoal (1 subgoal):\n 1. mat (length subsets) (length (take_indices signs S))\n     (\\<lambda>(i, j). z_R (subsets ! i) (take_indices signs S ! j)) =\n    mat_of_cols\n     (dim_row\n       (mat (length subsets) (length signs)\n         (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n     (take_indices\n       (cols\n         (mat (length subsets) (length signs)\n           (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n       S)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (take_indices signs S).\n       vec (length subsets)\n        (\\<lambda>ia. z_R (subsets ! ia) (take_indices signs S ! i)) =\n       col (mat_of_cols (length subsets)\n             (take_indices\n               (cols\n                 (mat (length subsets) (length signs)\n                   (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n               S))\n        i \\<Longrightarrow>\n    mat (length subsets) (length (take_indices signs S))\n     (\\<lambda>(i, j). z_R (subsets ! i) (take_indices signs S ! j)) =\n    mat_of_cols (length subsets)\n     (take_indices\n       (cols\n         (mat (length subsets) (length signs)\n           (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n       S)", "using h0a mat_col_eqI"], ["proof (prove)\nusing this:\n  dim_col (take_cols_from_matrix (alt_matrix_A_R signs subsets) S) =\n  length (take_indices signs S)\n  \\<lbrakk>\\<And>i. i < dim_col ?B \\<Longrightarrow> col ?A i = col ?B i;\n   dim_row ?A = dim_row ?B; dim_col ?A = dim_col ?B\\<rbrakk>\n  \\<Longrightarrow> ?A = ?B\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (take_indices signs S).\n       vec (length subsets)\n        (\\<lambda>ia. z_R (subsets ! ia) (take_indices signs S ! i)) =\n       col (mat_of_cols (length subsets)\n             (take_indices\n               (cols\n                 (mat (length subsets) (length signs)\n                   (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n               S))\n        i \\<Longrightarrow>\n    mat (length subsets) (length (take_indices signs S))\n     (\\<lambda>(i, j). z_R (subsets ! i) (take_indices signs S ! j)) =\n    mat_of_cols (length subsets)\n     (take_indices\n       (cols\n         (mat (length subsets) (length signs)\n           (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n       S)", "by (metis alt_matrix_A_R_def dim_col_mat(1) dim_row_mat(1) h0 mat_of_cols_def take_cols_from_matrix_def)"], ["proof (state)\nthis:\n  alt_matrix_A_R (take_indices signs S) subsets =\n  take_cols_from_matrix (alt_matrix_A_R signs subsets) S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduce_system_matrix_signs_helper_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  fixes S:: \"nat list\"\n  assumes well_def_h: \"\\<forall>x. List.member S x \\<longrightarrow> x < length signs\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"matrix_A_R (take_indices signs S) subsets = take_cols_from_matrix (matrix_A_R signs subsets) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R (take_indices signs S) subsets =\n    take_cols_from_matrix (M_mat_R signs subsets) S", "using reduce_system_matrix_signs_helper_aux_R alt_matrix_char_R assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x. List.member ?S x \\<longrightarrow> x < length ?signs;\n   ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> alt_matrix_A_R (take_indices ?signs ?S) ?subsets =\n                    take_cols_from_matrix (alt_matrix_A_R ?signs ?subsets)\n                     ?S\n  alt_matrix_A_R ?signs ?subsets = M_mat_R ?signs ?subsets\n  \\<forall>x. List.member S x \\<longrightarrow> x < length signs\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. M_mat_R (take_indices signs S) subsets =\n    take_cols_from_matrix (M_mat_R signs subsets) S", "by auto"], ["", "lemma reduce_system_matrix_subsets_helper_aux_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list* nat list) list\"\n  fixes signs :: \"rat list list\" \n  fixes S:: \"nat list\"\n  assumes inv: \"length subsets \\<ge> length signs\"\n  assumes well_def_h: \"\\<forall>x. List.member S x \\<longrightarrow> x < length subsets\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  shows \"alt_matrix_A_R signs (take_indices subsets S) = take_rows_from_matrix (alt_matrix_A_R signs subsets) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_matrix_A_R signs (take_indices subsets S) =\n    take_rows_from_matrix (alt_matrix_A_R signs subsets) S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alt_matrix_A_R signs (take_indices subsets S) =\n    take_rows_from_matrix (alt_matrix_A_R signs subsets) S", "have h0a: \"dim_row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) = length (take_indices subsets S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) =\n    length (take_indices subsets S)", "unfolding take_rows_from_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n       (take_indices (rows (alt_matrix_A_R signs subsets)) S)) =\n    length (take_indices subsets S)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take_indices (rows (alt_matrix_A_R signs subsets)) S) =\n    length (take_indices subsets S)", "unfolding take_indices_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ((!) (rows (alt_matrix_A_R signs subsets))) S) =\n    length (map ((!) subsets) S)", "by auto"], ["proof (state)\nthis:\n  dim_row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) =\n  length (take_indices subsets S)\n\ngoal (1 subgoal):\n 1. alt_matrix_A_R signs (take_indices subsets S) =\n    take_rows_from_matrix (alt_matrix_A_R signs subsets) S", "have h0: \"\\<forall>i < length (take_indices subsets S). (row (alt_matrix_A_R signs (take_indices subsets S) ) i = \nrow (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (take_indices subsets S).\n       row (alt_matrix_A_R signs (take_indices subsets S)) i =\n       row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices subsets S) \\<Longrightarrow>\n       row (alt_matrix_A_R signs (take_indices subsets S)) i =\n       row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices subsets S) \\<Longrightarrow>\n       row (alt_matrix_A_R signs (take_indices subsets S)) i =\n       row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "assume asm: \"i < length (take_indices subsets S)\""], ["proof (state)\nthis:\n  i < length (take_indices subsets S)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices subsets S) \\<Longrightarrow>\n       row (alt_matrix_A_R signs (take_indices subsets S)) i =\n       row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "have i_lt: \"i < length (map ((!) (rows (alt_matrix_A_R signs subsets))) S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (map ((!) (rows (alt_matrix_A_R signs subsets))) S)", "using asm"], ["proof (prove)\nusing this:\n  i < length (take_indices subsets S)\n\ngoal (1 subgoal):\n 1. i < length (map ((!) (rows (alt_matrix_A_R signs subsets))) S)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (take_indices subsets S) \\<Longrightarrow> i < length S", "unfolding take_indices_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (map ((!) subsets) S) \\<Longrightarrow> i < length S", "by auto"], ["proof (state)\nthis:\n  i < length (map ((!) (rows (alt_matrix_A_R signs subsets))) S)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices subsets S) \\<Longrightarrow>\n       row (alt_matrix_A_R signs (take_indices subsets S)) i =\n       row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "have h0: \"row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i =\n    row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets)) (map ((!) (rows (alt_matrix_A_R signs subsets))) S)) i \""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i =\n    row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n          (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n     i", "unfolding take_rows_from_matrix_def take_indices_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n          (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n     i =\n    row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n          (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n     i", "by auto"], ["proof (state)\nthis:\n  row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i =\n  row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n        (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n   i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices subsets S) \\<Longrightarrow>\n       row (alt_matrix_A_R signs (take_indices subsets S)) i =\n       row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "have dim: \"(map ((!) (rows (alt_matrix_A_R signs subsets))) S) ! i \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "have \"dim_col (alt_matrix_A_R signs subsets) = length (signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (alt_matrix_A_R signs subsets) = length signs", "by (simp add: alt_matrix_A_R_def)"], ["proof (state)\nthis:\n  dim_col (alt_matrix_A_R signs subsets) = length signs\n\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  dim_col (alt_matrix_A_R signs subsets) = length signs", "have lenh: \"dim_col (alt_matrix_A_R signs subsets) \\<le> length (subsets)\""], ["proof (prove)\nusing this:\n  dim_col (alt_matrix_A_R signs subsets) = length signs\n\ngoal (1 subgoal):\n 1. dim_col (alt_matrix_A_R signs subsets) \\<le> length subsets", "using assms"], ["proof (prove)\nusing this:\n  dim_col (alt_matrix_A_R signs subsets) = length signs\n  length signs \\<le> length subsets\n  \\<forall>x. List.member S x \\<longrightarrow> x < length subsets\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dim_col (alt_matrix_A_R signs subsets) \\<le> length subsets", "by auto"], ["proof (state)\nthis:\n  dim_col (alt_matrix_A_R signs subsets) \\<le> length subsets\n\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "have well_d: \"S ! i < length (subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S ! i < length subsets", "using well_def_h"], ["proof (prove)\nusing this:\n  \\<forall>x. List.member S x \\<longrightarrow> x < length subsets\n\ngoal (1 subgoal):\n 1. S ! i < length subsets", "using i_lt in_set_member"], ["proof (prove)\nusing this:\n  \\<forall>x. List.member S x \\<longrightarrow> x < length subsets\n  i < length (map ((!) (rows (alt_matrix_A_R signs subsets))) S)\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. S ! i < length subsets", "by fastforce"], ["proof (state)\nthis:\n  S ! i < length subsets\n\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "have \n        map_eq: \"(map ((!) (rows (alt_matrix_A_R signs subsets))) S) ! i  = nth (rows (alt_matrix_A_R signs subsets))  (S ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i =\n    rows (alt_matrix_A_R signs subsets) ! (S ! i)", "using i_lt"], ["proof (prove)\nusing this:\n  i < length (map ((!) (rows (alt_matrix_A_R signs subsets))) S)\n\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i =\n    rows (alt_matrix_A_R signs subsets) ! (S ! i)", "by auto"], ["proof (state)\nthis:\n  map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i =\n  rows (alt_matrix_A_R signs subsets) ! (S ! i)\n\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "have \"nth (rows (alt_matrix_A_R signs subsets))  (S ! i) \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rows (alt_matrix_A_R signs subsets) ! (S ! i)\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "using col_dim"], ["proof (prove)\nusing this:\n  col ?A ?i \\<in> carrier_vec (dim_row ?A)\n\ngoal (1 subgoal):\n 1. rows (alt_matrix_A_R signs subsets) ! (S ! i)\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "unfolding rows_def"], ["proof (prove)\nusing this:\n  col ?A ?i \\<in> carrier_vec (dim_row ?A)\n\ngoal (1 subgoal):\n 1. map (row (alt_matrix_A_R signs subsets))\n     [0..<dim_row (alt_matrix_A_R signs subsets)] !\n    (S ! i)\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "using nth_map well_d"], ["proof (prove)\nusing this:\n  col ?A ?i \\<in> carrier_vec (dim_row ?A)\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n  S ! i < length subsets\n\ngoal (1 subgoal):\n 1. map (row (alt_matrix_A_R signs subsets))\n     [0..<dim_row (alt_matrix_A_R signs subsets)] !\n    (S ! i)\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "using lenh"], ["proof (prove)\nusing this:\n  col ?A ?i \\<in> carrier_vec (dim_row ?A)\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n  S ! i < length subsets\n  dim_col (alt_matrix_A_R signs subsets) \\<le> length subsets\n\ngoal (1 subgoal):\n 1. map (row (alt_matrix_A_R signs subsets))\n     [0..<dim_row (alt_matrix_A_R signs subsets)] !\n    (S ! i)\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "by (simp add: alt_matrix_A_R_def)"], ["proof (state)\nthis:\n  rows (alt_matrix_A_R signs subsets) ! (S ! i)\n  \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\n\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  rows (alt_matrix_A_R signs subsets) ! (S ! i)\n  \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "show ?thesis"], ["proof (prove)\nusing this:\n  rows (alt_matrix_A_R signs subsets) ! (S ! i)\n  \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\n\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "using map_eq"], ["proof (prove)\nusing this:\n  rows (alt_matrix_A_R signs subsets) ! (S ! i)\n  \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\n  map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i =\n  rows (alt_matrix_A_R signs subsets) ! (S ! i)\n\ngoal (1 subgoal):\n 1. map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n    \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))", "unfolding alt_matrix_A_R_def"], ["proof (prove)\nusing this:\n  rows\n   (mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))) !\n  (S ! i)\n  \\<in> carrier_vec\n         (dim_col\n           (mat (length subsets) (length signs)\n             (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n  map ((!) (rows\n             (mat (length subsets) (length signs)\n               (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)))))\n   S !\n  i =\n  rows\n   (mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))) !\n  (S ! i)\n\ngoal (1 subgoal):\n 1. map ((!) (rows\n               (mat (length subsets) (length signs)\n                 (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j)))))\n     S !\n    i\n    \\<in> carrier_vec\n           (dim_col\n             (mat (length subsets) (length signs)\n               (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))", "by auto"], ["proof (state)\nthis:\n  map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n  \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n  \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices subsets S) \\<Longrightarrow>\n       row (alt_matrix_A_R signs (take_indices subsets S)) i =\n       row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "have h1: \" row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets)) (map ((!) (rows (alt_matrix_A_R signs subsets))) S)) i\n      = (row  (alt_matrix_A_R signs subsets) (S ! i)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n          (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n     i =\n    row (alt_matrix_A_R signs subsets) (S ! i)", "using dim i_lt mat_of_rows_row[where i = \"i\", where n = \"(dim_col (alt_matrix_A_R signs subsets))\",\n          where vs = \"(map ((!) (rows (alt_matrix_A_R signs subsets))) S)\"]"], ["proof (prove)\nusing this:\n  map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n  \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\n  i < length (map ((!) (rows (alt_matrix_A_R signs subsets))) S)\n  \\<lbrakk>i < length (map ((!) (rows (alt_matrix_A_R signs subsets))) S);\n   map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n   \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\\<rbrakk>\n  \\<Longrightarrow> row (mat_of_rows\n                          (dim_col (alt_matrix_A_R signs subsets))\n                          (map ((!) (rows (alt_matrix_A_R signs subsets)))\n                            S))\n                     i =\n                    map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n\ngoal (1 subgoal):\n 1. row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n          (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n     i =\n    row (alt_matrix_A_R signs subsets) (S ! i)", "using alt_matrix_char_R in_set_member nth_mem well_def_h"], ["proof (prove)\nusing this:\n  map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n  \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\n  i < length (map ((!) (rows (alt_matrix_A_R signs subsets))) S)\n  \\<lbrakk>i < length (map ((!) (rows (alt_matrix_A_R signs subsets))) S);\n   map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n   \\<in> carrier_vec (dim_col (alt_matrix_A_R signs subsets))\\<rbrakk>\n  \\<Longrightarrow> row (mat_of_rows\n                          (dim_col (alt_matrix_A_R signs subsets))\n                          (map ((!) (rows (alt_matrix_A_R signs subsets)))\n                            S))\n                     i =\n                    map ((!) (rows (alt_matrix_A_R signs subsets))) S ! i\n  alt_matrix_A_R ?signs ?subsets = M_mat_R ?signs ?subsets\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  \\<forall>x. List.member S x \\<longrightarrow> x < length subsets\n\ngoal (1 subgoal):\n 1. row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n          (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n     i =\n    row (alt_matrix_A_R signs subsets) (S ! i)", "by fastforce"], ["proof (state)\nthis:\n  row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n        (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n   i =\n  row (alt_matrix_A_R signs subsets) (S ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices subsets S) \\<Longrightarrow>\n       row (alt_matrix_A_R signs (take_indices subsets S)) i =\n       row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "have \"row (alt_matrix_A_R signs (take_indices subsets S) ) i = (row  (alt_matrix_A_R signs subsets) (S ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (alt_matrix_A_R signs (take_indices subsets S)) i =\n    row (alt_matrix_A_R signs subsets) (S ! i)", "using subsets_are_rows_R"], ["proof (prove)\nusing this:\n  \\<forall>i<length ?subsets.\n     row (alt_matrix_A_R ?signs ?subsets) i =\n     vec (length ?signs) (\\<lambda>j. z_R (?subsets ! i) (?signs ! j))\n\ngoal (1 subgoal):\n 1. row (alt_matrix_A_R signs (take_indices subsets S)) i =\n    row (alt_matrix_A_R signs subsets) (S ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>subsets signs.\n        \\<forall>i<length subsets.\n           row (alt_matrix_A_R signs subsets) i =\n           vec (length signs)\n            (\\<lambda>j. z_R (subsets ! i) (signs ! j))) \\<Longrightarrow>\n    row (alt_matrix_A_R signs (take_indices subsets S)) i =\n    row (alt_matrix_A_R signs subsets) (S ! i)", "have f1: \"i < length S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length S", "by (metis (no_types) asm length_map take_indices_def)"], ["proof (state)\nthis:\n  i < length S\n\ngoal (1 subgoal):\n 1. (\\<And>subsets signs.\n        \\<forall>i<length subsets.\n           row (alt_matrix_A_R signs subsets) i =\n           vec (length signs)\n            (\\<lambda>j. z_R (subsets ! i) (signs ! j))) \\<Longrightarrow>\n    row (alt_matrix_A_R signs (take_indices subsets S)) i =\n    row (alt_matrix_A_R signs subsets) (S ! i)", "then"], ["proof (chain)\npicking this:\n  i < length S", "have \"List.member S (S ! i)\""], ["proof (prove)\nusing this:\n  i < length S\n\ngoal (1 subgoal):\n 1. List.member S (S ! i)", "by (meson in_set_member nth_mem)"], ["proof (state)\nthis:\n  List.member S (S ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>subsets signs.\n        \\<forall>i<length subsets.\n           row (alt_matrix_A_R signs subsets) i =\n           vec (length signs)\n            (\\<lambda>j. z_R (subsets ! i) (signs ! j))) \\<Longrightarrow>\n    row (alt_matrix_A_R signs (take_indices subsets S)) i =\n    row (alt_matrix_A_R signs subsets) (S ! i)", "then"], ["proof (chain)\npicking this:\n  List.member S (S ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  List.member S (S ! i)\n\ngoal (1 subgoal):\n 1. row (alt_matrix_A_R signs (take_indices subsets S)) i =\n    row (alt_matrix_A_R signs subsets) (S ! i)", "using f1"], ["proof (prove)\nusing this:\n  List.member S (S ! i)\n  i < length S\n\ngoal (1 subgoal):\n 1. row (alt_matrix_A_R signs (take_indices subsets S)) i =\n    row (alt_matrix_A_R signs subsets) (S ! i)", "by (simp add: \\<open>\\<And>subsets signs. \\<forall>i<length subsets. row (alt_matrix_A_R signs subsets) i = vec (length signs) (\\<lambda>j. z_R (subsets ! i) (signs ! j))\\<close> take_indices_def well_def_h)"], ["proof (state)\nthis:\n  row (alt_matrix_A_R signs (take_indices subsets S)) i =\n  row (alt_matrix_A_R signs subsets) (S ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row (alt_matrix_A_R signs (take_indices subsets S)) i =\n  row (alt_matrix_A_R signs subsets) (S ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (take_indices subsets S) \\<Longrightarrow>\n       row (alt_matrix_A_R signs (take_indices subsets S)) i =\n       row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "then"], ["proof (chain)\npicking this:\n  row (alt_matrix_A_R signs (take_indices subsets S)) i =\n  row (alt_matrix_A_R signs subsets) (S ! i)", "show \"(row (alt_matrix_A_R signs (take_indices subsets S) ) i = \n      row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i)\""], ["proof (prove)\nusing this:\n  row (alt_matrix_A_R signs (take_indices subsets S)) i =\n  row (alt_matrix_A_R signs subsets) (S ! i)\n\ngoal (1 subgoal):\n 1. row (alt_matrix_A_R signs (take_indices subsets S)) i =\n    row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "using h0 h1"], ["proof (prove)\nusing this:\n  row (alt_matrix_A_R signs (take_indices subsets S)) i =\n  row (alt_matrix_A_R signs subsets) (S ! i)\n  row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i =\n  row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n        (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n   i\n  row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n        (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n   i =\n  row (alt_matrix_A_R signs subsets) (S ! i)\n\ngoal (1 subgoal):\n 1. row (alt_matrix_A_R signs (take_indices subsets S)) i =\n    row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "unfolding take_indices_def"], ["proof (prove)\nusing this:\n  row (alt_matrix_A_R signs (map ((!) subsets) S)) i =\n  row (alt_matrix_A_R signs subsets) (S ! i)\n  row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i =\n  row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n        (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n   i\n  row (mat_of_rows (dim_col (alt_matrix_A_R signs subsets))\n        (map ((!) (rows (alt_matrix_A_R signs subsets))) S))\n   i =\n  row (alt_matrix_A_R signs subsets) (S ! i)\n\ngoal (1 subgoal):\n 1. row (alt_matrix_A_R signs (map ((!) subsets) S)) i =\n    row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "by auto"], ["proof (state)\nthis:\n  row (alt_matrix_A_R signs (take_indices subsets S)) i =\n  row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length (take_indices subsets S).\n     row (alt_matrix_A_R signs (take_indices subsets S)) i =\n     row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i\n\ngoal (1 subgoal):\n 1. alt_matrix_A_R signs (take_indices subsets S) =\n    take_rows_from_matrix (alt_matrix_A_R signs subsets) S", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length (take_indices subsets S).\n     row (alt_matrix_A_R signs (take_indices subsets S)) i =\n     row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length (take_indices subsets S).\n     row (alt_matrix_A_R signs (take_indices subsets S)) i =\n     row (take_rows_from_matrix (alt_matrix_A_R signs subsets) S) i\n\ngoal (1 subgoal):\n 1. alt_matrix_A_R signs (take_indices subsets S) =\n    take_rows_from_matrix (alt_matrix_A_R signs subsets) S", "unfolding alt_matrix_A_R_def take_rows_from_matrix_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length (take_indices subsets S).\n     row (mat (length (take_indices subsets S)) (length signs)\n           (\\<lambda>(i, j). z_R (take_indices subsets S ! i) (signs ! j)))\n      i =\n     row (mat_of_rows\n           (dim_col\n             (mat (length subsets) (length signs)\n               (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n           (take_indices\n             (rows\n               (mat (length subsets) (length signs)\n                 (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n             S))\n      i\n\ngoal (1 subgoal):\n 1. mat (length (take_indices subsets S)) (length signs)\n     (\\<lambda>(i, j). z_R (take_indices subsets S ! i) (signs ! j)) =\n    mat_of_rows\n     (dim_col\n       (mat (length subsets) (length signs)\n         (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n     (take_indices\n       (rows\n         (mat (length subsets) (length signs)\n           (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n       S)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (take_indices subsets S).\n       vec (length signs)\n        (\\<lambda>j. z_R (take_indices subsets S ! i) (signs ! j)) =\n       row (mat_of_rows (length signs)\n             (take_indices\n               (rows\n                 (mat (length subsets) (length signs)\n                   (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n               S))\n        i \\<Longrightarrow>\n    mat (length (take_indices subsets S)) (length signs)\n     (\\<lambda>(i, j). z_R (take_indices subsets S ! i) (signs ! j)) =\n    mat_of_rows (length signs)\n     (take_indices\n       (rows\n         (mat (length subsets) (length signs)\n           (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n       S)", "using eq_rowI"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i. i < dim_row ?B \\<Longrightarrow> row ?A i = row ?B i;\n   dim_row ?A = dim_row ?B; dim_col ?A = dim_col ?B\\<rbrakk>\n  \\<Longrightarrow> ?A = ?B\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (take_indices subsets S).\n       vec (length signs)\n        (\\<lambda>j. z_R (take_indices subsets S ! i) (signs ! j)) =\n       row (mat_of_rows (length signs)\n             (take_indices\n               (rows\n                 (mat (length subsets) (length signs)\n                   (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n               S))\n        i \\<Longrightarrow>\n    mat (length (take_indices subsets S)) (length signs)\n     (\\<lambda>(i, j). z_R (take_indices subsets S ! i) (signs ! j)) =\n    mat_of_rows (length signs)\n     (take_indices\n       (rows\n         (mat (length subsets) (length signs)\n           (\\<lambda>(i, j). z_R (subsets ! i) (signs ! j))))\n       S)", "by (metis alt_matrix_A_R_def dim_col_mat(1) dim_row_mat(1) h0 h0a mat_of_rows_def take_rows_from_matrix_def)"], ["proof (state)\nthis:\n  alt_matrix_A_R signs (take_indices subsets S) =\n  take_rows_from_matrix (alt_matrix_A_R signs subsets) S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduce_system_matrix_subsets_helper_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  fixes S:: \"nat list\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes inv: \"length subsets \\<ge> length signs\"\n  assumes well_def_h: \"\\<forall>x. List.member S x \\<longrightarrow> x < length subsets\"\n  shows \"matrix_A_R signs (take_indices subsets S) = take_rows_from_matrix (matrix_A_R signs subsets) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R signs (take_indices subsets S) =\n    take_rows_from_matrix (M_mat_R signs subsets) S", "using assms reduce_system_matrix_subsets_helper_aux_R alt_matrix_char_R"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  length signs \\<le> length subsets\n  \\<forall>x. List.member S x \\<longrightarrow> x < length subsets\n  \\<lbrakk>length ?signs \\<le> length ?subsets;\n   \\<forall>x. List.member ?S x \\<longrightarrow> x < length ?subsets;\n   ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> alt_matrix_A_R ?signs (take_indices ?subsets ?S) =\n                    take_rows_from_matrix (alt_matrix_A_R ?signs ?subsets)\n                     ?S\n  alt_matrix_A_R ?signs ?subsets = M_mat_R ?signs ?subsets\n\ngoal (1 subgoal):\n 1. M_mat_R signs (take_indices subsets S) =\n    take_rows_from_matrix (M_mat_R signs subsets) S", "by auto"], ["", "lemma reduce_system_matrix_match_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  assumes inv: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"matrix_A_R (get_signs_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\n  (get_subsets_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs))))) = \n  (get_matrix_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "let ?A = \"(matrix_A_R signs subsets)\""], ["proof (state)\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "let ?lhs_vec = \"(solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))\""], ["proof (state)\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "let ?red_mtx = \"(take_rows_from_matrix (reduce_mat_cols (matrix_A_R signs subsets) ?lhs_vec) (rows_to_keep (reduce_mat_cols (matrix_A_R signs subsets) ?lhs_vec)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "have h1: \"matrix_A_R (get_signs_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\n  (get_subsets_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\n   = matrix_A_R (reduction_signs_R p qs signs subsets (matrix_A_R signs subsets)) (reduction_subsets_R p qs signs subsets (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    M_mat_R (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n     (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))", "using reduction_signs_is_get_signs_R reduction_subsets_is_get_subsets_R"], ["proof (prove)\nusing this:\n  reduction_signs_R ?p ?qs ?signs ?subsets ?m =\n  get_signs_R (reduce_system_R ?p (?qs, ?m, ?subsets, ?signs))\n  reduction_subsets_R ?p ?qs ?signs ?subsets ?m =\n  get_subsets_R (reduce_system_R ?p (?qs, ?m, ?subsets, ?signs))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    M_mat_R (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n     (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))", "by auto"], ["proof (state)\nthis:\n  M_mat_R\n   (get_signs_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n   (get_subsets_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n  M_mat_R (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n   (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "have h1_var: \"matrix_A_R (get_signs_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\n  (get_subsets_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\n   = matrix_A_R (take_indices signs (find_nonzeros_from_input_vec ?lhs_vec)) (take_indices subsets (rows_to_keep (reduce_mat_cols ?A ?lhs_vec)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    M_mat_R\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (take_indices subsets\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "using h1 reduction_signs_R_def reduction_subsets_R_def"], ["proof (prove)\nusing this:\n  M_mat_R\n   (get_signs_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n   (get_subsets_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n  M_mat_R (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n   (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))\n  reduction_signs_R ?p ?qs ?signs ?subsets ?matr =\n  take_indices ?signs\n   (find_nonzeros_from_input_vec (solve_for_lhs_R ?p ?qs ?subsets ?matr))\n  reduction_subsets_R ?p ?qs ?signs ?subsets ?matr =\n  take_indices ?subsets\n   (rows_to_keep\n     (reduce_mat_cols ?matr (solve_for_lhs_R ?p ?qs ?subsets ?matr)))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    M_mat_R\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (take_indices subsets\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "by auto"], ["proof (state)\nthis:\n  M_mat_R\n   (get_signs_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n   (get_subsets_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_indices subsets\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "have h2: \"?red_mtx = (take_rows_from_matrix (take_cols_from_matrix ?A (find_nonzeros_from_input_vec ?lhs_vec)) (rows_to_keep (take_cols_from_matrix ?A (find_nonzeros_from_input_vec ?lhs_vec))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n    take_rows_from_matrix\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (rows_to_keep\n       (take_cols_from_matrix (M_mat_R signs subsets)\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "by simp"], ["proof (state)\nthis:\n  take_rows_from_matrix\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n  take_rows_from_matrix\n   (take_cols_from_matrix (M_mat_R signs subsets)\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (rows_to_keep\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "have h30: \"(construct_lhs_vector_R p qs signs) = ?lhs_vec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "using assms construct_lhs_matches_solve_for_lhs_R"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n  \\<lbrakk>satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> w_vec_R ?p ?qs ?signs =\n                    solve_for_lhs_R ?p ?qs ?subsets\n                     (M_mat_R ?signs ?subsets)\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "by simp"], ["proof (state)\nthis:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "have h3a: \"\\<forall>x. List.member (find_nonzeros_from_input_vec ?lhs_vec) x \\<longrightarrow>x < length (signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n        x \\<longrightarrow>\n       x < length signs", "using h30 size_of_lhs_R[of p qs signs]"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  dim_vec (w_vec_R p qs signs) = length signs\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n        x \\<longrightarrow>\n       x < length signs", "unfolding find_nonzeros_from_input_vec_def"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  dim_vec (w_vec_R p qs signs) = length signs\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (filter\n          (\\<lambda>i.\n              solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $\n              i \\<noteq>\n              0)\n          [0..<\n           dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n        x \\<longrightarrow>\n       x < length signs", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>w_vec_R p qs signs =\n                solve_for_lhs_R p qs subsets (M_mat_R signs subsets);\n        dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n        length signs;\n        List.member\n         (filter\n           (\\<lambda>i.\n               solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $\n               i \\<noteq>\n               0)\n           [0..<length signs])\n         x\\<rbrakk>\n       \\<Longrightarrow> x < length signs", "using in_set_member"], ["proof (prove)\nusing this:\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>w_vec_R p qs signs =\n                solve_for_lhs_R p qs subsets (M_mat_R signs subsets);\n        dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n        length signs;\n        List.member\n         (filter\n           (\\<lambda>i.\n               solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $\n               i \\<noteq>\n               0)\n           [0..<length signs])\n         x\\<rbrakk>\n       \\<Longrightarrow> x < length signs", "by force"], ["proof (state)\nthis:\n  \\<forall>x.\n     List.member\n      (find_nonzeros_from_input_vec\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n      x \\<longrightarrow>\n     x < length signs\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "have h3b_a: \"\\<forall>x. List.member (find_nonzeros_from_input_vec ?lhs_vec) x \\<longrightarrow>x < length (subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n        x \\<longrightarrow>\n       x < length subsets", "using assms h30 size_of_lhs_R same_size_R"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  dim_vec (w_vec_R ?p ?qs ?signs) = length ?signs\n  invertible_mat (M_mat_R ?signs ?subsets) \\<Longrightarrow>\n  length ?subsets = length ?signs\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n        x \\<longrightarrow>\n       x < length subsets", "unfolding find_nonzeros_from_input_vec_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  dim_vec (w_vec_R ?p ?qs ?signs) = length ?signs\n  invertible_mat (M_mat_R ?signs ?subsets) \\<Longrightarrow>\n  length ?subsets = length ?signs\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (filter\n          (\\<lambda>i.\n              solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $\n              i \\<noteq>\n              0)\n          [0..<\n           dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n        x \\<longrightarrow>\n       x < length subsets", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs;\n        distinct signs;\n        set (characterize_consistent_signs_at_roots p qs)\n        \\<subseteq> set signs;\n        satisfy_equation_R p qs subsets signs;\n        invertible_mat (M_mat_R signs subsets);\n        w_vec_R p qs signs =\n        solve_for_lhs_R p qs subsets (M_mat_R signs subsets);\n        \\<And>p qs signs. dim_vec (w_vec_R p qs signs) = length signs;\n        \\<And>signs subsets.\n           invertible_mat (M_mat_R signs subsets) \\<Longrightarrow>\n           length subsets = length signs;\n        List.member\n         (filter\n           (\\<lambda>i.\n               solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $\n               i \\<noteq>\n               0)\n           [0..<\n            dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n         x\\<rbrakk>\n       \\<Longrightarrow> x < length signs", "by (simp add: find_nonzeros_from_input_vec_def h3a)"], ["proof (state)\nthis:\n  \\<forall>x.\n     List.member\n      (find_nonzeros_from_input_vec\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n      x \\<longrightarrow>\n     x < length subsets\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "have h3ba: \"length\n     (filter (\\<lambda>i. solve_for_lhs_R p qs subsets (matrix_A_R signs subsets) $ i \\<noteq> 0)\n       [0..<length subsets])\n    \\<le> length subsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>i.\n           solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n           0)\n       [0..<length subsets])\n    \\<le> length subsets", "using length_filter_le[where P = \"(\\<lambda>i. solve_for_lhs_R p qs subsets (matrix_A_R signs subsets) $ i \\<noteq> 0)\",\n    where xs = \"[0..<length subsets]\"] length_upto"], ["proof (prove)\nusing this:\n  length\n   (filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<length subsets])\n  \\<le> length [0..<length subsets]\n  length [?i..?j] = nat (?j - ?i + 1)\n\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>i.\n           solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n           0)\n       [0..<length subsets])\n    \\<le> length subsets", "by auto"], ["proof (state)\nthis:\n  length\n   (filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<length subsets])\n  \\<le> length subsets\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "have \" length subsets = dim_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length subsets =\n    dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))", "using h30 inv size_of_lhs_R same_size_R[of signs subsets]"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  invertible_mat (M_mat_R signs subsets)\n  dim_vec (w_vec_R ?p ?qs ?signs) = length ?signs\n  invertible_mat (M_mat_R signs subsets) \\<Longrightarrow>\n  length subsets = length signs\n\ngoal (1 subgoal):\n 1. length subsets =\n    dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w_vec_R p qs signs =\n             solve_for_lhs_R p qs subsets (M_mat_R signs subsets);\n     invertible_mat (M_mat_R signs subsets);\n     \\<And>p qs signs. dim_vec (w_vec_R p qs signs) = length signs;\n     length subsets = length signs\\<rbrakk>\n    \\<Longrightarrow> length signs =\n                      dim_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets))", "by metis"], ["proof (state)\nthis:\n  length subsets =\n  dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "then"], ["proof (chain)\npicking this:\n  length subsets =\n  dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))", "have \"length\n     (filter (\\<lambda>i. solve_for_lhs_R p qs subsets (matrix_A_R signs subsets) $ i \\<noteq> 0)\n       [0..<dim_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))])\n    \\<le> length subsets\""], ["proof (prove)\nusing this:\n  length subsets =\n  dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>i.\n           solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n           0)\n       [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n    \\<le> length subsets", "using h3ba"], ["proof (prove)\nusing this:\n  length subsets =\n  dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))\n  length\n   (filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<length subsets])\n  \\<le> length subsets\n\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>i.\n           solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n           0)\n       [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n    \\<le> length subsets", "by auto"], ["proof (state)\nthis:\n  length\n   (filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n  \\<le> length subsets\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "then"], ["proof (chain)\npicking this:\n  length\n   (filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n  \\<le> length subsets", "have h3b: \"length subsets \\<ge> length (take_indices signs (find_nonzeros_from_input_vec ?lhs_vec))\""], ["proof (prove)\nusing this:\n  length\n   (filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n  \\<le> length subsets\n\ngoal (1 subgoal):\n 1. length\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<le> length subsets", "unfolding take_indices_def find_nonzeros_from_input_vec_def"], ["proof (prove)\nusing this:\n  length\n   (filter\n     (\\<lambda>i.\n         solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n         0)\n     [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n  \\<le> length subsets\n\ngoal (1 subgoal):\n 1. length\n     (map ((!) signs)\n       (filter\n         (\\<lambda>i.\n             solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $\n             i \\<noteq>\n             0)\n         [0..<\n          dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))]))\n    \\<le> length subsets", "by auto"], ["proof (state)\nthis:\n  length\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<le> length subsets\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "have h3c: \"\\<forall>x. List.member (rows_to_keep (reduce_mat_cols ?A ?lhs_vec)) x \\<longrightarrow> x < length (subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (rows_to_keep\n          (reduce_mat_cols (M_mat_R signs subsets)\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n        x \\<longrightarrow>\n       x < length subsets", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member\n        (rows_to_keep\n          (take_cols_from_matrix (M_mat_R signs subsets)\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n        x \\<Longrightarrow>\n       x < length subsets", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member\n        (rows_to_keep\n          (take_cols_from_matrix (M_mat_R signs subsets)\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n        x \\<Longrightarrow>\n       x < length subsets", "assume x_mem: \"List.member (rows_to_keep\n            (take_cols_from_matrix (matrix_A_R signs subsets)\n              (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))) x\""], ["proof (state)\nthis:\n  List.member\n   (rows_to_keep\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member\n        (rows_to_keep\n          (take_cols_from_matrix (M_mat_R signs subsets)\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n        x \\<Longrightarrow>\n       x < length subsets", "obtain nn :: \"rat list list \\<Rightarrow> nat list \\<Rightarrow> nat\" where\n      \"\\<forall>x2 x3. (\\<exists>v4. v4 \\<in> set x3 \\<and> \\<not> v4 < length x2) = (nn x2 x3 \\<in> set x3 \\<and> \\<not> nn x2 x3 < length x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        \\<forall>x2 x3.\n           (\\<exists>v4. v4 \\<in> set x3 \\<and> \\<not> v4 < length x2) =\n           (nn x2 x3 \\<in> set x3 \\<and>\n            \\<not> nn x2 x3 < length x2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x2 x3.\n     (\\<exists>v4. v4 \\<in> set x3 \\<and> \\<not> v4 < length x2) =\n     (nn x2 x3 \\<in> set x3 \\<and> \\<not> nn x2 x3 < length x2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member\n        (rows_to_keep\n          (take_cols_from_matrix (M_mat_R signs subsets)\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n        x \\<Longrightarrow>\n       x < length subsets", "then"], ["proof (chain)\npicking this:\n  \\<forall>x2 x3.\n     (\\<exists>v4. v4 \\<in> set x3 \\<and> \\<not> v4 < length x2) =\n     (nn x2 x3 \\<in> set x3 \\<and> \\<not> nn x2 x3 < length x2)", "have f4: \"nn signs (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) \\<in> set (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) \\<and> \\<not> nn signs (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) < length signs \\<or> matrix_A_R (take_indices signs (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))) subsets = take_cols_from_matrix (matrix_A_R signs subsets) (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\""], ["proof (prove)\nusing this:\n  \\<forall>x2 x3.\n     (\\<exists>v4. v4 \\<in> set x3 \\<and> \\<not> v4 < length x2) =\n     (nn x2 x3 \\<in> set x3 \\<and> \\<not> nn x2 x3 < length x2)\n\ngoal (1 subgoal):\n 1. nn signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n    \\<in> set (find_nonzeros_from_input_vec\n                (solve_for_lhs_R p qs subsets\n                  (M_mat_R signs subsets))) \\<and>\n    \\<not> nn signs\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n           < length signs \\<or>\n    M_mat_R\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     subsets =\n    take_cols_from_matrix (M_mat_R signs subsets)\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "using nonzero"], ["proof (prove)\nusing this:\n  \\<forall>x2 x3.\n     (\\<exists>v4. v4 \\<in> set x3 \\<and> \\<not> v4 < length x2) =\n     (nn x2 x3 \\<in> set x3 \\<and> \\<not> nn x2 x3 < length x2)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. nn signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n    \\<in> set (find_nonzeros_from_input_vec\n                (solve_for_lhs_R p qs subsets\n                  (M_mat_R signs subsets))) \\<and>\n    \\<not> nn signs\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n           < length signs \\<or>\n    M_mat_R\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     subsets =\n    take_cols_from_matrix (M_mat_R signs subsets)\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "using h3a reduce_system_matrix_signs_helper_R"], ["proof (prove)\nusing this:\n  \\<forall>x2 x3.\n     (\\<exists>v4. v4 \\<in> set x3 \\<and> \\<not> v4 < length x2) =\n     (nn x2 x3 \\<in> set x3 \\<and> \\<not> nn x2 x3 < length x2)\n  p \\<noteq> 0\n  \\<forall>x.\n     List.member\n      (find_nonzeros_from_input_vec\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n      x \\<longrightarrow>\n     x < length signs\n  \\<lbrakk>\\<forall>x. List.member ?S x \\<longrightarrow> x < length ?signs;\n   ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> M_mat_R (take_indices ?signs ?S) ?subsets =\n                    take_cols_from_matrix (M_mat_R ?signs ?subsets) ?S\n\ngoal (1 subgoal):\n 1. nn signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n    \\<in> set (find_nonzeros_from_input_vec\n                (solve_for_lhs_R p qs subsets\n                  (M_mat_R signs subsets))) \\<and>\n    \\<not> nn signs\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n           < length signs \\<or>\n    M_mat_R\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     subsets =\n    take_cols_from_matrix (M_mat_R signs subsets)\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by auto"], ["proof (state)\nthis:\n  nn signs\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<in> set (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n  \\<not> nn signs\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n         < length signs \\<or>\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   subsets =\n  take_cols_from_matrix (M_mat_R signs subsets)\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member\n        (rows_to_keep\n          (take_cols_from_matrix (M_mat_R signs subsets)\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n        x \\<Longrightarrow>\n       x < length subsets", "then"], ["proof (chain)\npicking this:\n  nn signs\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<in> set (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n  \\<not> nn signs\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n         < length signs \\<or>\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   subsets =\n  take_cols_from_matrix (M_mat_R signs subsets)\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "have \"matrix_A_R (take_indices signs (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))) subsets = take_cols_from_matrix (matrix_A_R signs subsets) (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) \\<and> x \\<in> set (map snd (pivot_positions (gauss_jordan_single (take_cols_from_matrix (matrix_A_R signs subsets) (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))\\<^sup>T)))\""], ["proof (prove)\nusing this:\n  nn signs\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<in> set (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n  \\<not> nn signs\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n         < length signs \\<or>\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   subsets =\n  take_cols_from_matrix (M_mat_R signs subsets)\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     subsets =\n    take_cols_from_matrix (M_mat_R signs subsets)\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n    x \\<in> set (map snd\n                  (pivot_positions\n                    (gauss_jordan_single\n                      (take_cols_from_matrix (M_mat_R signs subsets)\n                        (find_nonzeros_from_input_vec\n                          (solve_for_lhs_R p qs subsets\n                            (M_mat_R signs subsets))))\\<^sup>T)))", "using f4"], ["proof (prove)\nusing this:\n  nn signs\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<in> set (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n  \\<not> nn signs\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n         < length signs \\<or>\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   subsets =\n  take_cols_from_matrix (M_mat_R signs subsets)\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  nn signs\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<in> set (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n  \\<not> nn signs\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n         < length signs \\<or>\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   subsets =\n  take_cols_from_matrix (M_mat_R signs subsets)\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     subsets =\n    take_cols_from_matrix (M_mat_R signs subsets)\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n    x \\<in> set (map snd\n                  (pivot_positions\n                    (gauss_jordan_single\n                      (take_cols_from_matrix (M_mat_R signs subsets)\n                        (find_nonzeros_from_input_vec\n                          (solve_for_lhs_R p qs subsets\n                            (M_mat_R signs subsets))))\\<^sup>T)))", "by (metis h3a in_set_member rows_to_keep_def x_mem)"], ["proof (state)\nthis:\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   subsets =\n  take_cols_from_matrix (M_mat_R signs subsets)\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n  x \\<in> set (map snd\n                (pivot_positions\n                  (gauss_jordan_single\n                    (take_cols_from_matrix (M_mat_R signs subsets)\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))\\<^sup>T)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member\n        (rows_to_keep\n          (take_cols_from_matrix (M_mat_R signs subsets)\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n        x \\<Longrightarrow>\n       x < length subsets", "thus \"x < length (subsets)\""], ["proof (prove)\nusing this:\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   subsets =\n  take_cols_from_matrix (M_mat_R signs subsets)\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n  x \\<in> set (map snd\n                (pivot_positions\n                  (gauss_jordan_single\n                    (take_cols_from_matrix (M_mat_R signs subsets)\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))\\<^sup>T)))\n\ngoal (1 subgoal):\n 1. x < length subsets", "using x_mem"], ["proof (prove)\nusing this:\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   subsets =\n  take_cols_from_matrix (M_mat_R signs subsets)\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n  x \\<in> set (map snd\n                (pivot_positions\n                  (gauss_jordan_single\n                    (take_cols_from_matrix (M_mat_R signs subsets)\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))\\<^sup>T)))\n  List.member\n   (rows_to_keep\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n   x\n\ngoal (1 subgoal):\n 1. x < length subsets", "unfolding rows_to_keep_def"], ["proof (prove)\nusing this:\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   subsets =\n  take_cols_from_matrix (M_mat_R signs subsets)\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) \\<and>\n  x \\<in> set (map snd\n                (pivot_positions\n                  (gauss_jordan_single\n                    (take_cols_from_matrix (M_mat_R signs subsets)\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))\\<^sup>T)))\n  List.member\n   (map snd\n     (pivot_positions\n       (gauss_jordan_single\n         (take_cols_from_matrix (M_mat_R signs subsets)\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets))))\\<^sup>T)))\n   x\n\ngoal (1 subgoal):\n 1. x < length subsets", "by (metis dim_row_matrix_A_R rows_to_keep_def rows_to_keep_lem)"], ["proof (state)\nthis:\n  x < length subsets\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     List.member\n      (rows_to_keep\n        (reduce_mat_cols (M_mat_R signs subsets)\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n      x \\<longrightarrow>\n     x < length subsets\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "have h3: \"matrix_A_R (take_indices signs (find_nonzeros_from_input_vec ?lhs_vec)) (take_indices subsets (rows_to_keep (reduce_mat_cols ?A ?lhs_vec))) = \n    (take_rows_from_matrix (take_cols_from_matrix ?A (find_nonzeros_from_input_vec ?lhs_vec)) (rows_to_keep (take_cols_from_matrix ?A (find_nonzeros_from_input_vec ?lhs_vec))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (take_indices subsets\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    take_rows_from_matrix\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (rows_to_keep\n       (take_cols_from_matrix (M_mat_R signs subsets)\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "using inv h3a h3b h3c reduce_system_matrix_subsets_helper_R reduce_system_matrix_signs_helper_R\n      assms"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n  \\<forall>x.\n     List.member\n      (find_nonzeros_from_input_vec\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n      x \\<longrightarrow>\n     x < length signs\n  length\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<le> length subsets\n  \\<forall>x.\n     List.member\n      (rows_to_keep\n        (reduce_mat_cols (M_mat_R signs subsets)\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n      x \\<longrightarrow>\n     x < length subsets\n  \\<lbrakk>?p \\<noteq> 0; length ?signs \\<le> length ?subsets;\n   \\<forall>x.\n      List.member ?S x \\<longrightarrow> x < length ?subsets\\<rbrakk>\n  \\<Longrightarrow> M_mat_R ?signs (take_indices ?subsets ?S) =\n                    take_rows_from_matrix (M_mat_R ?signs ?subsets) ?S\n  \\<lbrakk>\\<forall>x. List.member ?S x \\<longrightarrow> x < length ?signs;\n   ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> M_mat_R (take_indices ?signs ?S) ?subsets =\n                    take_cols_from_matrix (M_mat_R ?signs ?subsets) ?S\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (take_indices subsets\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    take_rows_from_matrix\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (rows_to_keep\n       (take_cols_from_matrix (M_mat_R signs subsets)\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "by auto"], ["proof (state)\nthis:\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_indices subsets\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  take_rows_from_matrix\n   (take_cols_from_matrix (M_mat_R signs subsets)\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (rows_to_keep\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "using h1 h2 h3"], ["proof (prove)\nusing this:\n  M_mat_R\n   (get_signs_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n   (get_subsets_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n  M_mat_R (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n   (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))\n  take_rows_from_matrix\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n  take_rows_from_matrix\n   (take_cols_from_matrix (M_mat_R signs subsets)\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (rows_to_keep\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n  M_mat_R\n   (take_indices signs\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_indices subsets\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  take_rows_from_matrix\n   (take_cols_from_matrix (M_mat_R signs subsets)\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (rows_to_keep\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "by (metis fst_conv get_matrix_R_def h1_var reduce_system_R.simps reduction_step_R.simps)"], ["proof (state)\nthis:\n  M_mat_R\n   (get_signs_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n   (get_subsets_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n  get_matrix_R\n   (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Showing invertibility preserved when reducing\""], ["", "(* gauss_jordan_single_rank is critically helpful in this subsection *)"], ["", "thm conjugatable_vec_space.gauss_jordan_single_rank"], ["", "thm vec_space.full_rank_lin_indpt"], ["", "(* Overall:\n  Start with a matrix equation.\n  Input a matrix, subsets, and signs.\n  Drop columns of the matrix based on the 0's on the LHS---so extract a list of 0's. Reduce signs accordingly.\n  Then find a list of rows to delete based on using rank (use the transpose result, pivot positions!),\n   and delete those rows.  Reduce subsets accordingly.\n  End with a reduced system! *)"], ["", "lemma well_def_find_zeros_from_lhs_vec_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes len_eq: \"length subsets = length signs\"\n  assumes inv: \"invertible_mat (matrix_A_R signs subsets)\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  shows \"(\\<And>j. j \\<in> set (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) \\<Longrightarrow>\n          j < length (cols (matrix_A_R signs subsets)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "assume j_in: \" j \\<in> set (find_nonzeros_from_input_vec\n                      (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) \""], ["proof (state)\nthis:\n  j \\<in> set (find_nonzeros_from_input_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "let ?og_mat = \"(matrix_A_R signs subsets)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "let ?lhs = \"(solve_for_lhs_R p qs subsets ?og_mat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "let ?new_mat = \"(take_rows_from_matrix (reduce_mat_cols ?og_mat ?lhs) (rows_to_keep (reduce_mat_cols ?og_mat ?lhs)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "have \"square_mat (matrix_A_R signs subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_mat (M_mat_R signs subsets)", "using inv"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. square_mat (M_mat_R signs subsets)", "using invertible_mat_def"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n  invertible_mat ?A \\<equiv>\n  square_mat ?A \\<and>\n  (\\<exists>B. inverts_mat ?A B \\<and> inverts_mat B ?A)\n\ngoal (1 subgoal):\n 1. square_mat (M_mat_R signs subsets)", "by blast"], ["proof (state)\nthis:\n  square_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  square_mat (M_mat_R signs subsets)", "have mat_size: \"?og_mat \\<in> carrier_mat (length signs) (length signs)\""], ["proof (prove)\nusing this:\n  square_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)", "using size_of_mat"], ["proof (prove)\nusing this:\n  square_mat (M_mat_R signs subsets)\n  M_mat ?signs ?subsets \\<in> carrier_mat (length ?subsets) (length ?signs)\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)", "by auto"], ["proof (state)\nthis:\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "have \"dim_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)) = (length signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n    length signs", "using size_of_lhs_R construct_lhs_matches_solve_for_lhs_R assms"], ["proof (prove)\nusing this:\n  dim_vec (w_vec_R ?p ?qs ?signs) = length ?signs\n  \\<lbrakk>satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> w_vec_R ?p ?qs ?signs =\n                    solve_for_lhs_R ?p ?qs ?subsets\n                     (M_mat_R ?signs ?subsets)\n  length subsets = length signs\n  invertible_mat (M_mat_R signs subsets)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n\ngoal (1 subgoal):\n 1. dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n    length signs", "by (metis (full_types))"], ["proof (state)\nthis:\n  dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n  length signs\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n  length signs", "have h: \"j < (length signs)\""], ["proof (prove)\nusing this:\n  dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n  length signs\n\ngoal (1 subgoal):\n 1. j < length signs", "using j_in"], ["proof (prove)\nusing this:\n  dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n  length signs\n  j \\<in> set (find_nonzeros_from_input_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. j < length signs", "unfolding find_nonzeros_from_input_vec_def"], ["proof (prove)\nusing this:\n  dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)) =\n  length signs\n  j \\<in> set (filter\n                (\\<lambda>i.\n                    solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $\n                    i \\<noteq>\n                    0)\n                [0..<\n                 dim_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n\ngoal (1 subgoal):\n 1. j < length signs", "by simp"], ["proof (state)\nthis:\n  j < length signs\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  j < length signs", "show \"j <  length (cols (matrix_A_R signs subsets))\""], ["proof (prove)\nusing this:\n  j < length signs\n\ngoal (1 subgoal):\n 1. j < length (cols (M_mat_R signs subsets))", "using mat_size"], ["proof (prove)\nusing this:\n  j < length signs\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. j < length (cols (M_mat_R signs subsets))", "by auto"], ["proof (state)\nthis:\n  j < length (cols (M_mat_R signs subsets))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma take_cols_subsets_og_cols_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes len_eq: \"length subsets = length signs\"\n  assumes inv: \"invertible_mat (matrix_A_R signs subsets)\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  shows \"set (take_indices (cols (matrix_A_R signs subsets))\n          (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))\n    \\<subseteq> set (cols (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take_indices (cols (M_mat_R signs subsets))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (cols (M_mat_R signs subsets))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (take_indices (cols (M_mat_R signs subsets))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (cols (M_mat_R signs subsets))", "have well_def: \"(\\<And>j. j \\<in> set (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) \\<Longrightarrow>\n          j < length (cols (matrix_A_R signs subsets)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "using assms well_def_find_zeros_from_lhs_vec_R"], ["proof (prove)\nusing this:\n  length subsets = length signs\n  invertible_mat (M_mat_R signs subsets)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  \\<lbrakk>length ?subsets = length ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets); ?p \\<noteq> 0;\n   well_def_signs (length ?qs) ?signs; distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   satisfy_equation_R ?p ?qs ?subsets ?signs;\n   ?j \\<in> set (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R ?p ?qs ?subsets\n                    (M_mat_R ?signs ?subsets)))\\<rbrakk>\n  \\<Longrightarrow> ?j < length (cols (M_mat_R ?signs ?subsets))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "by auto"], ["proof (state)\nthis:\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length (cols (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. set (take_indices (cols (M_mat_R signs subsets))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (cols (M_mat_R signs subsets))", "have \"\\<forall>x. x \\<in> set (take_indices (cols (matrix_A_R signs subsets))\n          (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))) \n    \\<longrightarrow> x \\<in>  set (cols (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))) \\<longrightarrow>\n       x \\<in> set (cols (M_mat_R signs subsets))", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))) \\<Longrightarrow>\n       x \\<in> set (cols (M_mat_R signs subsets))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))) \\<Longrightarrow>\n       x \\<in> set (cols (M_mat_R signs subsets))", "let ?og_list = \"(cols (matrix_A_R signs subsets))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))) \\<Longrightarrow>\n       x \\<in> set (cols (M_mat_R signs subsets))", "let ?ind_list = \"(find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))) \\<Longrightarrow>\n       x \\<in> set (cols (M_mat_R signs subsets))", "assume x_in: \"x \\<in> set (take_indices ?og_list ?ind_list)\""], ["proof (state)\nthis:\n  x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))) \\<Longrightarrow>\n       x \\<in> set (cols (M_mat_R signs subsets))", "show \"x \\<in> set (cols (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (cols (M_mat_R signs subsets))", "using x_in"], ["proof (prove)\nusing this:\n  x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. x \\<in> set (cols (M_mat_R signs subsets))", "unfolding take_indices_def"], ["proof (prove)\nusing this:\n  x \\<in> set (map ((!) (cols (M_mat_R signs subsets)))\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. x \\<in> set (cols (M_mat_R signs subsets))", "using in_set_member"], ["proof (prove)\nusing this:\n  x \\<in> set (map ((!) (cols (M_mat_R signs subsets)))\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. x \\<in> set (cols (M_mat_R signs subsets))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>x xs. (x \\<in> set xs) = List.member xs x;\n        xa \\<in> set (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)));\n        x = cols (M_mat_R signs subsets) ! xa\\<rbrakk>\n       \\<Longrightarrow> cols (M_mat_R signs subsets) ! xa\n                         \\<in> set (cols (M_mat_R signs subsets))", "using in_set_conv_nth well_def"], ["proof (prove)\nusing this:\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length (cols (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>x xs. (x \\<in> set xs) = List.member xs x;\n        xa \\<in> set (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)));\n        x = cols (M_mat_R signs subsets) ! xa\\<rbrakk>\n       \\<Longrightarrow> cols (M_mat_R signs subsets) ! xa\n                         \\<in> set (cols (M_mat_R signs subsets))", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> set (cols (M_mat_R signs subsets))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                   (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets)))) \\<longrightarrow>\n     x \\<in> set (cols (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. set (take_indices (cols (M_mat_R signs subsets))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (cols (M_mat_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                   (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets)))) \\<longrightarrow>\n     x \\<in> set (cols (M_mat_R signs subsets))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> set (take_indices (cols (M_mat_R signs subsets))\n                   (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets)))) \\<longrightarrow>\n     x \\<in> set (cols (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. set (take_indices (cols (M_mat_R signs subsets))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (cols (M_mat_R signs subsets))", "by blast"], ["proof (state)\nthis:\n  set (take_indices (cols (M_mat_R signs subsets))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (cols (M_mat_R signs subsets))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduction_doesnt_break_things_invertibility_step1_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes len_eq: \"length subsets = length signs\"\n  assumes inv: \"invertible_mat (matrix_A_R signs subsets)\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  shows \"vec_space.rank (length signs) (reduce_mat_cols (matrix_A_R signs subsets) (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) =\n    (length (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "let ?og_mat = \"(matrix_A_R signs subsets)\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "let ?lhs = \"(solve_for_lhs_R p qs subsets ?og_mat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "let ?new_mat = \"(take_rows_from_matrix (reduce_mat_cols ?og_mat ?lhs) (rows_to_keep (reduce_mat_cols ?og_mat ?lhs)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "have \"square_mat (matrix_A_R signs subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_mat (M_mat_R signs subsets)", "using inv"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. square_mat (M_mat_R signs subsets)", "using invertible_mat_def"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n  invertible_mat ?A \\<equiv>\n  square_mat ?A \\<and>\n  (\\<exists>B. inverts_mat ?A B \\<and> inverts_mat B ?A)\n\ngoal (1 subgoal):\n 1. square_mat (M_mat_R signs subsets)", "by blast"], ["proof (state)\nthis:\n  square_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "then"], ["proof (chain)\npicking this:\n  square_mat (M_mat_R signs subsets)", "have mat_size: \"?og_mat \\<in> carrier_mat (length signs) (length signs)\""], ["proof (prove)\nusing this:\n  square_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)", "using size_of_mat"], ["proof (prove)\nusing this:\n  square_mat (M_mat_R signs subsets)\n  M_mat ?signs ?subsets \\<in> carrier_mat (length ?subsets) (length ?signs)\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)", "by auto"], ["proof (state)\nthis:\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "then"], ["proof (chain)\npicking this:\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)", "have mat_size_alt: \"?og_mat \\<in> carrier_mat (length subsets) (length subsets)\""], ["proof (prove)\nusing this:\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets\n    \\<in> carrier_mat (length subsets) (length subsets)", "using size_of_mat same_size assms"], ["proof (prove)\nusing this:\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n  M_mat ?signs ?subsets \\<in> carrier_mat (length ?subsets) (length ?signs)\n  invertible_mat (M_mat ?signs ?subsets) \\<Longrightarrow>\n  length ?subsets = length ?signs\n  length subsets = length signs\n  invertible_mat (M_mat_R signs subsets)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets\n    \\<in> carrier_mat (length subsets) (length subsets)", "by auto"], ["proof (state)\nthis:\n  M_mat_R signs subsets \\<in> carrier_mat (length subsets) (length subsets)\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "have det_h: \"det ?og_mat \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (M_mat_R signs subsets) \\<noteq> 0", "using invertible_det[where A = \"matrix_A_R signs subsets\"] mat_size"], ["proof (prove)\nusing this:\n  M_mat_R signs subsets \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat (M_mat_R signs subsets) =\n  (det (M_mat_R signs subsets) \\<noteq> 0)\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. det (M_mat_R signs subsets) \\<noteq> 0", "using inv"], ["proof (prove)\nusing this:\n  M_mat_R signs subsets \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat (M_mat_R signs subsets) =\n  (det (M_mat_R signs subsets) \\<noteq> 0)\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. det (M_mat_R signs subsets) \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  det (M_mat_R signs subsets) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "then"], ["proof (chain)\npicking this:\n  det (M_mat_R signs subsets) \\<noteq> 0", "have rank_h: \"vec_space.rank (length signs) ?og_mat = (length signs)\""], ["proof (prove)\nusing this:\n  det (M_mat_R signs subsets) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs) (M_mat_R signs subsets) = length signs", "using vec_space.det_rank_iff  mat_size"], ["proof (prove)\nusing this:\n  det (M_mat_R signs subsets) \\<noteq> 0\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  (det ?A \\<noteq> (0::?'a)) = (vec_space.rank ?n ?A = ?n)\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs) (M_mat_R signs subsets) = length signs", "by auto"], ["proof (state)\nthis:\n  vec_space.rank (length signs) (M_mat_R signs subsets) = length signs\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "then"], ["proof (chain)\npicking this:\n  vec_space.rank (length signs) (M_mat_R signs subsets) = length signs", "have dist_cols: \"distinct (cols ?og_mat)\""], ["proof (prove)\nusing this:\n  vec_space.rank (length signs) (M_mat_R signs subsets) = length signs\n\ngoal (1 subgoal):\n 1. distinct (cols (M_mat_R signs subsets))", "using mat_size vec_space.non_distinct_low_rank[where A = ?og_mat, where n = \"length signs\"]"], ["proof (prove)\nusing this:\n  vec_space.rank (length signs) (M_mat_R signs subsets) = length signs\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n  \\<lbrakk>M_mat_R signs subsets\n           \\<in> carrier_mat (length signs) (length signs);\n   \\<not> distinct (cols (M_mat_R signs subsets))\\<rbrakk>\n  \\<Longrightarrow> vec_space.rank (length signs) (M_mat_R signs subsets)\n                    < length signs\n\ngoal (1 subgoal):\n 1. distinct (cols (M_mat_R signs subsets))", "by auto"], ["proof (state)\nthis:\n  distinct (cols (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "have well_def: \"(\\<And>j. j \\<in> set (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) \\<Longrightarrow>\n          j < length (cols (matrix_A_R signs subsets)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "using assms well_def_find_zeros_from_lhs_vec_R"], ["proof (prove)\nusing this:\n  length subsets = length signs\n  invertible_mat (M_mat_R signs subsets)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  \\<lbrakk>length ?subsets = length ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets); ?p \\<noteq> 0;\n   well_def_signs (length ?qs) ?signs; distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   satisfy_equation_R ?p ?qs ?subsets ?signs;\n   ?j \\<in> set (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R ?p ?qs ?subsets\n                    (M_mat_R ?signs ?subsets)))\\<rbrakk>\n  \\<Longrightarrow> ?j < length (cols (M_mat_R ?signs ?subsets))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length (cols (M_mat_R signs subsets))", "by auto"], ["proof (state)\nthis:\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length (cols (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "have dist1: \"distinct\n     (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "unfolding find_nonzeros_from_input_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (filter\n       (\\<lambda>i.\n           solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n           0)\n       [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])", "by auto"], ["proof (state)\nthis:\n  distinct\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "have clear: \"set (take_indices (cols (matrix_A_R signs subsets))\n          (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))\n    \\<subseteq> set (cols (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take_indices (cols (M_mat_R signs subsets))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (cols (M_mat_R signs subsets))", "using assms take_cols_subsets_og_cols_R"], ["proof (prove)\nusing this:\n  length subsets = length signs\n  invertible_mat (M_mat_R signs subsets)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  \\<lbrakk>length ?subsets = length ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets); ?p \\<noteq> 0;\n   well_def_signs (length ?qs) ?signs; distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   satisfy_equation_R ?p ?qs ?subsets ?signs\\<rbrakk>\n  \\<Longrightarrow> set (take_indices (cols (M_mat_R ?signs ?subsets))\n                          (find_nonzeros_from_input_vec\n                            (solve_for_lhs_R ?p ?qs ?subsets\n                              (M_mat_R ?signs ?subsets))))\n                    \\<subseteq> set (cols (M_mat_R ?signs ?subsets))\n\ngoal (1 subgoal):\n 1. set (take_indices (cols (M_mat_R signs subsets))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<subseteq> set (cols (M_mat_R signs subsets))", "by auto"], ["proof (state)\nthis:\n  set (take_indices (cols (M_mat_R signs subsets))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (cols (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "then"], ["proof (chain)\npicking this:\n  set (take_indices (cols (M_mat_R signs subsets))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (cols (M_mat_R signs subsets))", "have \"distinct (take_indices (cols (matrix_A_R signs subsets))\n          (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))\""], ["proof (prove)\nusing this:\n  set (take_indices (cols (M_mat_R signs subsets))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (cols (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. distinct\n     (take_indices (cols (M_mat_R signs subsets))\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "unfolding take_indices_def"], ["proof (prove)\nusing this:\n  set (map ((!) (cols (M_mat_R signs subsets)))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (cols (M_mat_R signs subsets))\n\ngoal (1 subgoal):\n 1. distinct\n     (map ((!) (cols (M_mat_R signs subsets)))\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "using dist1 dist_cols well_def conjugatable_vec_space.distinct_map_nth[where ls = \"cols (matrix_A_R signs subsets)\", where inds = \"(find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\"]"], ["proof (prove)\nusing this:\n  set (map ((!) (cols (M_mat_R signs subsets)))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (cols (M_mat_R signs subsets))\n  distinct\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  distinct (cols (M_mat_R signs subsets))\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length (cols (M_mat_R signs subsets))\n  \\<lbrakk>distinct (cols (M_mat_R signs subsets));\n   distinct\n    (find_nonzeros_from_input_vec\n      (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n   \\<And>j.\n      j \\<in> set (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets\n                      (M_mat_R signs subsets))) \\<Longrightarrow>\n      j < length (cols (M_mat_R signs subsets))\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (map ((!) (cols (M_mat_R signs subsets)))\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. distinct\n     (map ((!) (cols (M_mat_R signs subsets)))\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "by auto"], ["proof (state)\nthis:\n  distinct\n   (take_indices (cols (M_mat_R signs subsets))\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "then"], ["proof (chain)\npicking this:\n  distinct\n   (take_indices (cols (M_mat_R signs subsets))\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "have unfold_thesis: \"vec_space.rank (length signs) (mat_of_cols (dim_row ?og_mat) (take_indices (cols ?og_mat) (find_nonzeros_from_input_vec ?lhs)))\n= (length (find_nonzeros_from_input_vec ?lhs))\""], ["proof (prove)\nusing this:\n  distinct\n   (take_indices (cols (M_mat_R signs subsets))\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (mat_of_cols (dim_row (M_mat_R signs subsets))\n       (take_indices (cols (M_mat_R signs subsets))\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "using clear inv conjugatable_vec_space.rank_invertible_subset_cols[where A= \"matrix_A_R signs subsets\", where B = \"(take_indices (cols (matrix_A_R signs subsets))\n         (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))\"]"], ["proof (prove)\nusing this:\n  distinct\n   (take_indices (cols (M_mat_R signs subsets))\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  set (take_indices (cols (M_mat_R signs subsets))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<subseteq> set (cols (M_mat_R signs subsets))\n  invertible_mat (M_mat_R signs subsets)\n  \\<lbrakk>invertible_mat (M_mat_R signs subsets);\n   M_mat_R signs subsets \\<in> carrier_mat ?n ?n;\n   set (take_indices (cols (M_mat_R signs subsets))\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   \\<subseteq> set (cols (M_mat_R signs subsets));\n   distinct\n    (take_indices (cols (M_mat_R signs subsets))\n      (find_nonzeros_from_input_vec\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\\<rbrakk>\n  \\<Longrightarrow> vec_space.rank ?n\n                     (mat_of_cols ?n\n                       (take_indices (cols (M_mat_R signs subsets))\n                         (find_nonzeros_from_input_vec\n                           (solve_for_lhs_R p qs subsets\n                             (M_mat_R signs subsets))))) =\n                    length\n                     (take_indices (cols (M_mat_R signs subsets))\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (mat_of_cols (dim_row (M_mat_R signs subsets))\n       (take_indices (cols (M_mat_R signs subsets))\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by (simp add: len_eq mat_size take_indices_def)"], ["proof (state)\nthis:\n  vec_space.rank (length signs)\n   (mat_of_cols (dim_row (M_mat_R signs subsets))\n     (take_indices (cols (M_mat_R signs subsets))\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  length\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "then"], ["proof (chain)\npicking this:\n  vec_space.rank (length signs)\n   (mat_of_cols (dim_row (M_mat_R signs subsets))\n     (take_indices (cols (M_mat_R signs subsets))\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  length\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "show ?thesis"], ["proof (prove)\nusing this:\n  vec_space.rank (length signs)\n   (mat_of_cols (dim_row (M_mat_R signs subsets))\n     (take_indices (cols (M_mat_R signs subsets))\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  length\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (mat_of_cols (length subsets)\n       (take_indices (cols (M_mat_R signs subsets))\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets\n         (M_mat_R signs subsets))) \\<Longrightarrow>\n    vec_space.rank (length signs)\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "unfolding take_cols_from_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (mat_of_cols (length subsets)\n       (take_indices (cols (M_mat_R signs subsets))\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets\n         (M_mat_R signs subsets))) \\<Longrightarrow>\n    vec_space.rank (length signs)\n     (mat_of_cols (dim_row (M_mat_R signs subsets))\n       (take_indices (cols (M_mat_R signs subsets))\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by auto"], ["proof (state)\nthis:\n  vec_space.rank (length signs)\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n  length\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduction_doesnt_break_things_invertibility_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes len_eq: \"length subsets = length signs\"\n  assumes inv: \"invertible_mat (matrix_A_R signs subsets)\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes welldefined_signs1: \"well_def_signs (length qs) signs\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(signs)\"\n  assumes match: \"satisfy_equation_R p qs subsets signs\"\n  shows \"invertible_mat (get_matrix_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "let ?og_mat = \"(matrix_A_R signs subsets)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "let ?lhs = \"(solve_for_lhs_R p qs subsets ?og_mat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "let ?step1_mat = \"(reduce_mat_cols ?og_mat ?lhs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "let ?new_mat = \"take_rows_from_matrix ?step1_mat (rows_to_keep ?step1_mat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "let ?ind_list = \"(find_nonzeros_from_input_vec  ?lhs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have \"square_mat (matrix_A_R signs subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_mat (M_mat_R signs subsets)", "using inv"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. square_mat (M_mat_R signs subsets)", "using invertible_mat_def"], ["proof (prove)\nusing this:\n  invertible_mat (M_mat_R signs subsets)\n  invertible_mat ?A \\<equiv>\n  square_mat ?A \\<and>\n  (\\<exists>B. inverts_mat ?A B \\<and> inverts_mat B ?A)\n\ngoal (1 subgoal):\n 1. square_mat (M_mat_R signs subsets)", "by blast"], ["proof (state)\nthis:\n  square_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  square_mat (M_mat_R signs subsets)", "have og_mat_size: \"?og_mat \\<in> carrier_mat (length signs) (length signs)\""], ["proof (prove)\nusing this:\n  square_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)", "using size_of_mat"], ["proof (prove)\nusing this:\n  square_mat (M_mat_R signs subsets)\n  M_mat ?signs ?subsets \\<in> carrier_mat (length ?subsets) (length ?signs)\n\ngoal (1 subgoal):\n 1. M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)", "by auto"], ["proof (state)\nthis:\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have \"dim_col (mat_of_cols (dim_row ?og_mat) (take_indices (cols ?og_mat) ?ind_list))\n      = (length (find_nonzeros_from_input_vec ?lhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (mat_of_cols (dim_row (M_mat_R signs subsets))\n       (take_indices (cols (M_mat_R signs subsets))\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by (simp add: take_indices_def)"], ["proof (state)\nthis:\n  dim_col\n   (mat_of_cols (dim_row (M_mat_R signs subsets))\n     (take_indices (cols (M_mat_R signs subsets))\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  length\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  dim_col\n   (mat_of_cols (dim_row (M_mat_R signs subsets))\n     (take_indices (cols (M_mat_R signs subsets))\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  length\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "have \"mat_of_cols (dim_row ?og_mat) (take_indices (cols ?og_mat) ?ind_list)\n      \\<in> carrier_mat (length signs) (length (find_nonzeros_from_input_vec ?lhs))\""], ["proof (prove)\nusing this:\n  dim_col\n   (mat_of_cols (dim_row (M_mat_R signs subsets))\n     (take_indices (cols (M_mat_R signs subsets))\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  length\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row (M_mat_R signs subsets))\n     (take_indices (cols (M_mat_R signs subsets))\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    \\<in> carrier_mat (length signs)\n           (length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "by (simp add: len_eq mat_of_cols_def)"], ["proof (state)\nthis:\n  mat_of_cols (dim_row (M_mat_R signs subsets))\n   (take_indices (cols (M_mat_R signs subsets))\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<in> carrier_mat (length signs)\n         (length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  mat_of_cols (dim_row (M_mat_R signs subsets))\n   (take_indices (cols (M_mat_R signs subsets))\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<in> carrier_mat (length signs)\n         (length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "have step1_mat_size: \"?step1_mat \\<in> carrier_mat (length signs) (length (find_nonzeros_from_input_vec ?lhs))\""], ["proof (prove)\nusing this:\n  mat_of_cols (dim_row (M_mat_R signs subsets))\n   (take_indices (cols (M_mat_R signs subsets))\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  \\<in> carrier_mat (length signs)\n         (length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))\n    \\<in> carrier_mat (length signs)\n           (length\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "by (simp add: take_cols_from_matrix_def)"], ["proof (state)\nthis:\n  reduce_mat_cols (M_mat_R signs subsets)\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs)\n         (length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  reduce_mat_cols (M_mat_R signs subsets)\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs)\n         (length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "have \"dim_row ?step1_mat \\<ge> dim_col ?step1_mat\""], ["proof (prove)\nusing this:\n  reduce_mat_cols (M_mat_R signs subsets)\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs)\n         (length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n    \\<le> dim_row\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by (metis carrier_matD(1) carrier_matD(2) construct_lhs_matches_solve_for_lhs_R diff_zero find_nonzeros_from_input_vec_def inv length_filter_le length_upt match size_of_lhs_R)"], ["proof (state)\nthis:\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<le> dim_row\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<le> dim_row\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "have gt_eq_assm: \"dim_col ?step1_mat\\<^sup>T  \\<ge> dim_row  ?step1_mat\\<^sup>T\""], ["proof (prove)\nusing this:\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<le> dim_row\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. dim_row\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n    \\<le> dim_col\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  dim_row\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n  \\<le> dim_col\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have det_h: \"det ?og_mat \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (M_mat_R signs subsets) \\<noteq> 0", "using invertible_det[where A = \"matrix_A_R signs subsets\"] og_mat_size"], ["proof (prove)\nusing this:\n  M_mat_R signs subsets \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat (M_mat_R signs subsets) =\n  (det (M_mat_R signs subsets) \\<noteq> 0)\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. det (M_mat_R signs subsets) \\<noteq> 0", "using inv"], ["proof (prove)\nusing this:\n  M_mat_R signs subsets \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat (M_mat_R signs subsets) =\n  (det (M_mat_R signs subsets) \\<noteq> 0)\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. det (M_mat_R signs subsets) \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  det (M_mat_R signs subsets) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  det (M_mat_R signs subsets) \\<noteq> 0", "have rank_h: \"vec_space.rank (length signs) ?og_mat = (length signs)\""], ["proof (prove)\nusing this:\n  det (M_mat_R signs subsets) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs) (M_mat_R signs subsets) = length signs", "using vec_space.det_rank_iff  og_mat_size"], ["proof (prove)\nusing this:\n  det (M_mat_R signs subsets) \\<noteq> 0\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  (det ?A \\<noteq> (0::?'a)) = (vec_space.rank ?n ?A = ?n)\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs) (M_mat_R signs subsets) = length signs", "by auto"], ["proof (state)\nthis:\n  vec_space.rank (length signs) (M_mat_R signs subsets) = length signs\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have rank_drop_cols: \"vec_space.rank (length signs) ?step1_mat = (dim_col ?step1_mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "using assms reduction_doesnt_break_things_invertibility_step1_R step1_mat_size"], ["proof (prove)\nusing this:\n  length subsets = length signs\n  invertible_mat (M_mat_R signs subsets)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  \\<lbrakk>length ?subsets = length ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets); ?p \\<noteq> 0;\n   well_def_signs (length ?qs) ?signs; distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   satisfy_equation_R ?p ?qs ?subsets ?signs\\<rbrakk>\n  \\<Longrightarrow> vec_space.rank (length ?signs)\n                     (reduce_mat_cols (M_mat_R ?signs ?subsets)\n                       (solve_for_lhs_R ?p ?qs ?subsets\n                         (M_mat_R ?signs ?subsets))) =\n                    length\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R ?p ?qs ?subsets\n                         (M_mat_R ?signs ?subsets)))\n  reduce_mat_cols (M_mat_R signs subsets)\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs)\n         (length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by auto"], ["proof (state)\nthis:\n  vec_space.rank (length signs)\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "let ?step1_T = \"?step1_mat\\<^sup>T\""], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have rank_transpose: \"vec_space.rank (length signs) ?step1_mat = vec_space.rank (length (find_nonzeros_from_input_vec ?lhs)) ?step1_T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T", "using transpose_rank[of ?step1_mat]"], ["proof (prove)\nusing this:\n  vec_space.rank\n   (dim_row\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n  vec_space.rank\n   (dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T", "using step1_mat_size"], ["proof (prove)\nusing this:\n  vec_space.rank\n   (dim_row\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n  vec_space.rank\n   (dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n  reduce_mat_cols (M_mat_R signs subsets)\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs)\n         (length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. vec_space.rank (length signs)\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n    vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T", "by auto"], ["proof (state)\nthis:\n  vec_space.rank (length signs)\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have obv: \"?step1_T \\<in> carrier_mat (dim_row ?step1_T) (dim_col ?step1_T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (reduce_mat_cols (M_mat_R signs subsets)\n      (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n    \\<in> carrier_mat\n           (dim_row\n             (reduce_mat_cols (M_mat_R signs subsets)\n               (solve_for_lhs_R p qs subsets\n                 (M_mat_R signs subsets)))\\<^sup>T)\n           (dim_col\n             (reduce_mat_cols (M_mat_R signs subsets)\n               (solve_for_lhs_R p qs subsets\n                 (M_mat_R signs subsets)))\\<^sup>T)", "by auto"], ["proof (state)\nthis:\n  (reduce_mat_cols (M_mat_R signs subsets)\n    (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n  \\<in> carrier_mat\n         (dim_row\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)\n         (dim_col\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have should_have_this:\"vec_space.rank (length (find_nonzeros_from_input_vec ?lhs)) (take_cols ?step1_T (map snd (pivot_positions (gauss_jordan_single (?step1_T))))) = vec_space.rank (length (find_nonzeros_from_input_vec ?lhs)) ?step1_T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (take_cols\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n       (map snd\n         (pivot_positions\n           (gauss_jordan_single\n             (reduce_mat_cols (M_mat_R signs subsets)\n               (solve_for_lhs_R p qs subsets\n                 (M_mat_R signs subsets)))\\<^sup>T)))) =\n    vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T", "using obv gt_eq_assm conjugatable_vec_space.gauss_jordan_single_rank[where A = \"?step1_T\", where n = \"dim_row ?step1_T\", where nc = \"dim_col ?step1_T\"]"], ["proof (prove)\nusing this:\n  (reduce_mat_cols (M_mat_R signs subsets)\n    (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n  \\<in> carrier_mat\n         (dim_row\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)\n         (dim_col\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)\n  dim_row\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n  \\<le> dim_col\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n  \\<lbrakk>(reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n           \\<in> carrier_mat\n                  (dim_row\n                    (reduce_mat_cols (M_mat_R signs subsets)\n                      (solve_for_lhs_R p qs subsets\n                        (M_mat_R signs subsets)))\\<^sup>T)\n                  (dim_col\n                    (reduce_mat_cols (M_mat_R signs subsets)\n                      (solve_for_lhs_R p qs subsets\n                        (M_mat_R signs subsets)))\\<^sup>T);\n   dim_row\n    (reduce_mat_cols (M_mat_R signs subsets)\n      (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n   \\<le> dim_col\n          (reduce_mat_cols (M_mat_R signs subsets)\n            (solve_for_lhs_R p qs subsets\n              (M_mat_R signs subsets)))\\<^sup>T\\<rbrakk>\n  \\<Longrightarrow> vec_space.rank\n                     (dim_row\n                       (reduce_mat_cols (M_mat_R signs subsets)\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets)))\\<^sup>T)\n                     (take_cols\n                       (reduce_mat_cols (M_mat_R signs subsets)\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets)))\\<^sup>T\n                       (map snd\n                         (pivot_positions\n                           (gauss_jordan_single\n                             (reduce_mat_cols (M_mat_R signs subsets)\n                               (solve_for_lhs_R p qs subsets\n                                 (M_mat_R signs subsets)))\\<^sup>T)))) =\n                    vec_space.rank\n                     (dim_row\n                       (reduce_mat_cols (M_mat_R signs subsets)\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets)))\\<^sup>T)\n                     (reduce_mat_cols (M_mat_R signs subsets)\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (take_cols\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n       (map snd\n         (pivot_positions\n           (gauss_jordan_single\n             (reduce_mat_cols (M_mat_R signs subsets)\n               (solve_for_lhs_R p qs subsets\n                 (M_mat_R signs subsets)))\\<^sup>T)))) =\n    vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T", "by (simp add: take_cols_from_matrix_def take_indices_def)"], ["proof (state)\nthis:\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_cols\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n     (map snd\n       (pivot_positions\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)))) =\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_cols\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n     (map snd\n       (pivot_positions\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)))) =\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T", "have \"vec_space.rank (length (find_nonzeros_from_input_vec ?lhs)) (take_cols ?step1_T (map snd (pivot_positions (gauss_jordan_single (?step1_T))))) = dim_col ?step1_mat\""], ["proof (prove)\nusing this:\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_cols\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n     (map snd\n       (pivot_positions\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)))) =\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (take_cols\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n       (map snd\n         (pivot_positions\n           (gauss_jordan_single\n             (reduce_mat_cols (M_mat_R signs subsets)\n               (solve_for_lhs_R p qs subsets\n                 (M_mat_R signs subsets)))\\<^sup>T)))) =\n    dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "using rank_drop_cols rank_transpose"], ["proof (prove)\nusing this:\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_cols\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n     (map snd\n       (pivot_positions\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)))) =\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n  vec_space.rank (length signs)\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  vec_space.rank (length signs)\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n\ngoal (1 subgoal):\n 1. vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (take_cols\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n       (map snd\n         (pivot_positions\n           (gauss_jordan_single\n             (reduce_mat_cols (M_mat_R signs subsets)\n               (solve_for_lhs_R p qs subsets\n                 (M_mat_R signs subsets)))\\<^sup>T)))) =\n    dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by auto"], ["proof (state)\nthis:\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_cols\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n     (map snd\n       (pivot_positions\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_cols\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n     (map snd\n       (pivot_positions\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "have with_take_cols_from_matrix: \"vec_space.rank (length (find_nonzeros_from_input_vec ?lhs)) (take_cols_from_matrix ?step1_T (map snd (pivot_positions (gauss_jordan_single (?step1_T))))) = dim_col ?step1_mat\""], ["proof (prove)\nusing this:\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_cols\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n     (map snd\n       (pivot_positions\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (take_cols_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n       (map snd\n         (pivot_positions\n           (gauss_jordan_single\n             (reduce_mat_cols (M_mat_R signs subsets)\n               (solve_for_lhs_R p qs subsets\n                 (M_mat_R signs subsets)))\\<^sup>T)))) =\n    dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "using rank_transpose rechar_take_cols conjugatable_vec_space.gjs_and_take_cols_var"], ["proof (prove)\nusing this:\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_cols\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n     (map snd\n       (pivot_positions\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  vec_space.rank (length signs)\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))) =\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n  take_cols_var ?A ?B = take_cols_from_matrix ?A ?B\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?nc; ?n \\<le> ?nc\\<rbrakk>\n  \\<Longrightarrow> take_cols ?A\n                     (map snd (pivot_positions (gauss_jordan_single ?A))) =\n                    take_cols_var ?A\n                     (map snd (pivot_positions (gauss_jordan_single ?A)))\n\ngoal (1 subgoal):\n 1. vec_space.rank\n     (length\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n     (take_cols_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n       (map snd\n         (pivot_positions\n           (gauss_jordan_single\n             (reduce_mat_cols (M_mat_R signs subsets)\n               (solve_for_lhs_R p qs subsets\n                 (M_mat_R signs subsets)))\\<^sup>T)))) =\n    dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vec_space.rank\n              (length\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n              (take_cols\n                (take_cols_from_matrix (M_mat_R signs subsets)\n                  (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets\n                      (M_mat_R signs subsets))))\\<^sup>T\n                (map snd\n                  (pivot_positions\n                    (gauss_jordan_single\n                      (take_cols_from_matrix (M_mat_R signs subsets)\n                        (find_nonzeros_from_input_vec\n                          (solve_for_lhs_R p qs subsets\n                            (M_mat_R signs subsets))))\\<^sup>T)))) =\n             dim_col\n              (take_cols_from_matrix (M_mat_R signs subsets)\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))));\n     vec_space.rank (length signs)\n      (take_cols_from_matrix (M_mat_R signs subsets)\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n     vec_space.rank\n      (length\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n      (take_cols_from_matrix (M_mat_R signs subsets)\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\\<^sup>T;\n     \\<And>A B. take_cols_var A B = take_cols_from_matrix A B;\n     \\<And>A n nc.\n        \\<lbrakk>A \\<in> carrier_mat n nc; n \\<le> nc\\<rbrakk>\n        \\<Longrightarrow> take_cols A\n                           (map snd\n                             (pivot_positions (gauss_jordan_single A))) =\n                          take_cols_var A\n                           (map snd\n                             (pivot_positions\n                               (gauss_jordan_single A)))\\<rbrakk>\n    \\<Longrightarrow> vec_space.rank\n                       (length\n                         (find_nonzeros_from_input_vec\n                           (solve_for_lhs_R p qs subsets\n                             (M_mat_R signs subsets))))\n                       (take_cols_from_matrix\n                         (take_cols_from_matrix (M_mat_R signs subsets)\n                           (find_nonzeros_from_input_vec\n                             (solve_for_lhs_R p qs subsets\n                               (M_mat_R signs subsets))))\\<^sup>T\n                         (map snd\n                           (pivot_positions\n                             (gauss_jordan_single\n                               (take_cols_from_matrix\n                                 (M_mat_R signs subsets)\n                                 (find_nonzeros_from_input_vec\n                                   (solve_for_lhs_R p qs subsets\n                                     (M_mat_R signs\n subsets))))\\<^sup>T)))) =\n                      dim_col\n                       (take_cols_from_matrix (M_mat_R signs subsets)\n                         (find_nonzeros_from_input_vec\n                           (solve_for_lhs_R p qs subsets\n                             (M_mat_R signs subsets))))", "by (smt conjugatable_vec_space.gjs_and_take_cols_var gt_eq_assm obv rechar_take_cols reduce_mat_cols.simps)"], ["proof (state)\nthis:\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_cols_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n     (map snd\n       (pivot_positions\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have \"(take_rows_from_matrix ?step1_mat (rows_to_keep ?step1_mat)) = (take_cols_from_matrix ?step1_T  (rows_to_keep ?step1_mat))\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n    (take_cols_from_matrix\n      (reduce_mat_cols (M_mat_R signs subsets)\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n      (rows_to_keep\n        (reduce_mat_cols (M_mat_R signs subsets)\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\\<^sup>T", "using take_rows_and_take_cols"], ["proof (prove)\nusing this:\n  take_rows_from_matrix ?M ?r =\n  (take_cols_from_matrix ?M\\<^sup>T ?r)\\<^sup>T\n\ngoal (1 subgoal):\n 1. take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n    (take_cols_from_matrix\n      (reduce_mat_cols (M_mat_R signs subsets)\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n      (rows_to_keep\n        (reduce_mat_cols (M_mat_R signs subsets)\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\\<^sup>T", "by blast"], ["proof (state)\nthis:\n  take_rows_from_matrix\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n  (take_cols_from_matrix\n    (reduce_mat_cols (M_mat_R signs subsets)\n      (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n    (rows_to_keep\n      (reduce_mat_cols (M_mat_R signs subsets)\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\\<^sup>T\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  take_rows_from_matrix\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n  (take_cols_from_matrix\n    (reduce_mat_cols (M_mat_R signs subsets)\n      (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n    (rows_to_keep\n      (reduce_mat_cols (M_mat_R signs subsets)\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\\<^sup>T", "have rank_new_mat: \"vec_space.rank (dim_row ?new_mat) ?new_mat = dim_col ?step1_mat\""], ["proof (prove)\nusing this:\n  take_rows_from_matrix\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n  (take_cols_from_matrix\n    (reduce_mat_cols (M_mat_R signs subsets)\n      (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n    (rows_to_keep\n      (reduce_mat_cols (M_mat_R signs subsets)\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\\<^sup>T\n\ngoal (1 subgoal):\n 1. vec_space.rank\n     (dim_row\n       (take_rows_from_matrix\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n         (rows_to_keep\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))))\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "using with_take_cols_from_matrix transpose_rank"], ["proof (prove)\nusing this:\n  take_rows_from_matrix\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n  (take_cols_from_matrix\n    (reduce_mat_cols (M_mat_R signs subsets)\n      (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n    (rows_to_keep\n      (reduce_mat_cols (M_mat_R signs subsets)\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\\<^sup>T\n  vec_space.rank\n   (length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n   (take_cols_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n     (map snd\n       (pivot_positions\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  vec_space.rank (dim_row ?A) ?A = vec_space.rank (dim_col ?A) ?A\\<^sup>T\n\ngoal (1 subgoal):\n 1. vec_space.rank\n     (dim_row\n       (take_rows_from_matrix\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n         (rows_to_keep\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))))\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>take_rows_from_matrix\n              (take_cols_from_matrix (M_mat_R signs subsets)\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n              (rows_to_keep\n                (take_cols_from_matrix (M_mat_R signs subsets)\n                  (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets\n                      (M_mat_R signs subsets))))) =\n             (take_cols_from_matrix\n               (take_cols_from_matrix (M_mat_R signs subsets)\n                 (find_nonzeros_from_input_vec\n                   (solve_for_lhs_R p qs subsets\n                     (M_mat_R signs subsets))))\\<^sup>T\n               (rows_to_keep\n                 (take_cols_from_matrix (M_mat_R signs subsets)\n                   (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))))))\\<^sup>T;\n     vec_space.rank\n      (length\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n      (take_cols_from_matrix\n        (take_cols_from_matrix (M_mat_R signs subsets)\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\\<^sup>T\n        (map snd\n          (pivot_positions\n            (gauss_jordan_single\n              (take_cols_from_matrix (M_mat_R signs subsets)\n                (find_nonzeros_from_input_vec\n                  (solve_for_lhs_R p qs subsets\n                    (M_mat_R signs subsets))))\\<^sup>T)))) =\n     dim_col\n      (take_cols_from_matrix (M_mat_R signs subsets)\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))));\n     \\<And>A.\n        vec_space.rank (dim_row A) A =\n        vec_space.rank (dim_col A) A\\<^sup>T\\<rbrakk>\n    \\<Longrightarrow> vec_space.rank\n                       (dim_col\n                         (take_cols_from_matrix\n                           (take_cols_from_matrix (M_mat_R signs subsets)\n                             (find_nonzeros_from_input_vec\n                               (solve_for_lhs_R p qs subsets\n                                 (M_mat_R signs subsets))))\\<^sup>T\n                           (rows_to_keep\n                             (take_cols_from_matrix (M_mat_R signs subsets)\n                               (find_nonzeros_from_input_vec\n                                 (solve_for_lhs_R p qs subsets\n                                   (M_mat_R signs subsets)))))))\n                       (take_cols_from_matrix\n                         (take_cols_from_matrix (M_mat_R signs subsets)\n                           (find_nonzeros_from_input_vec\n                             (solve_for_lhs_R p qs subsets\n                               (M_mat_R signs subsets))))\\<^sup>T\n                         (rows_to_keep\n                           (take_cols_from_matrix (M_mat_R signs subsets)\n                             (find_nonzeros_from_input_vec\n                               (solve_for_lhs_R p qs subsets\n                                 (M_mat_R signs subsets))))))\\<^sup>T =\n                      dim_col\n                       (take_cols_from_matrix (M_mat_R signs subsets)\n                         (find_nonzeros_from_input_vec\n                           (solve_for_lhs_R p qs subsets\n                             (M_mat_R signs subsets))))", "by (smt (verit, ccfv_threshold) carrier_matD(2) index_transpose_mat(2) mat_of_cols_carrier(2) reduce_mat_cols.simps rows_to_keep_def step1_mat_size take_cols_from_matrix_def transpose_rank)"], ["proof (state)\nthis:\n  vec_space.rank\n   (dim_row\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))))\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have \"length (pivot_positions (gauss_jordan_single (?step1_mat\\<^sup>T))) \\<le> (length (find_nonzeros_from_input_vec ?lhs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (pivot_positions\n       (gauss_jordan_single\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n    \\<le> length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "using obv length_pivot_positions_dim_row[where A = \"(gauss_jordan_single (?step1_mat\\<^sup>T))\"]"], ["proof (prove)\nusing this:\n  (reduce_mat_cols (M_mat_R signs subsets)\n    (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T\n  \\<in> carrier_mat\n         (dim_row\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)\n         (dim_col\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)\n  row_echelon_form\n   (gauss_jordan_single\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets\n         (M_mat_R signs subsets)))\\<^sup>T) \\<Longrightarrow>\n  length\n   (pivot_positions\n     (gauss_jordan_single\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n  \\<le> dim_row\n         (gauss_jordan_single\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. length\n     (pivot_positions\n       (gauss_jordan_single\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n    \\<le> length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by (metis carrier_matD(1) carrier_matD(2) gauss_jordan_single(2) gauss_jordan_single(3) index_transpose_mat(2) step1_mat_size)"], ["proof (state)\nthis:\n  length\n   (pivot_positions\n     (gauss_jordan_single\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n  \\<le> length\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  length\n   (pivot_positions\n     (gauss_jordan_single\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n  \\<le> length\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "have len_lt_eq: \"length (pivot_positions (gauss_jordan_single (?step1_mat\\<^sup>T))) \\<le> dim_col ?step1_mat\""], ["proof (prove)\nusing this:\n  length\n   (pivot_positions\n     (gauss_jordan_single\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n  \\<le> length\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. length\n     (pivot_positions\n       (gauss_jordan_single\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n    \\<le> dim_col\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "using step1_mat_size"], ["proof (prove)\nusing this:\n  length\n   (pivot_positions\n     (gauss_jordan_single\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n  \\<le> length\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  reduce_mat_cols (M_mat_R signs subsets)\n   (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))\n  \\<in> carrier_mat (length signs)\n         (length\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. length\n     (pivot_positions\n       (gauss_jordan_single\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n    \\<le> dim_col\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by simp"], ["proof (state)\nthis:\n  length\n   (pivot_positions\n     (gauss_jordan_single\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n  \\<le> dim_col\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have len_gt_false: \"length (rows_to_keep ?step1_mat) < (dim_col ?step1_mat) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    < dim_col\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets\n           (M_mat_R signs subsets))) \\<Longrightarrow>\n    False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    < dim_col\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets\n           (M_mat_R signs subsets))) \\<Longrightarrow>\n    False", "assume length_lt: \"length (rows_to_keep ?step1_mat) < (dim_col ?step1_mat)\""], ["proof (state)\nthis:\n  length\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  < dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. length\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    < dim_col\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets\n           (M_mat_R signs subsets))) \\<Longrightarrow>\n    False", "have h: \"dim_row ?new_mat < (dim_col ?step1_mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n    < dim_col\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by (metis Matrix.transpose_transpose index_transpose_mat(3) length_lt length_map mat_of_cols_carrier(3) take_cols_from_matrix_def take_indices_def take_rows_and_take_cols)"], ["proof (state)\nthis:\n  dim_row\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n  < dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. length\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n    < dim_col\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets\n           (M_mat_R signs subsets))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  dim_row\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n  < dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "show \"False\""], ["proof (prove)\nusing this:\n  dim_row\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n  < dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. False", "using rank_new_mat"], ["proof (prove)\nusing this:\n  dim_row\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n  < dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  vec_space.rank\n   (dim_row\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))))\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. False", "by (metis Matrix.transpose_transpose carrier_matI index_transpose_mat(2) nat_less_le not_less_iff_gr_or_eq transpose_rank vec_space.rank_le_nc)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  < dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets\n         (M_mat_R signs subsets))) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  length\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  < dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets\n         (M_mat_R signs subsets))) \\<Longrightarrow>\n  False", "have len_gt_eq: \"length (rows_to_keep ?step1_mat) \\<ge> (dim_col ?step1_mat)\""], ["proof (prove)\nusing this:\n  length\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  < dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets\n         (M_mat_R signs subsets))) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n    \\<le> length\n           (rows_to_keep\n             (reduce_mat_cols (M_mat_R signs subsets)\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "using not_less"], ["proof (prove)\nusing this:\n  length\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n  < dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets\n         (M_mat_R signs subsets))) \\<Longrightarrow>\n  False\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n    \\<le> length\n           (rows_to_keep\n             (reduce_mat_cols (M_mat_R signs subsets)\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "by blast"], ["proof (state)\nthis:\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<le> length\n         (rows_to_keep\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have len_match: \"length (rows_to_keep ?step1_mat) = (dim_col ?step1_mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n    dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "using len_lt_eq len_gt_eq"], ["proof (prove)\nusing this:\n  length\n   (pivot_positions\n     (gauss_jordan_single\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\\<^sup>T))\n  \\<le> dim_col\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<le> length\n         (rows_to_keep\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. length\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n    dim_col\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by (simp add: rows_to_keep_def)"], ["proof (state)\nthis:\n  length\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have mat_match: \"matrix_A_R (get_signs_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\n  (get_subsets_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs))))) = \n  (get_matrix_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "using reduce_system_matrix_match_R[of p qs signs subsets]  assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs; distinct signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   satisfy_equation_R p qs subsets signs;\n   invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n  \\<Longrightarrow> M_mat_R\n                     (get_signs_R\n                       (reduce_system_R p\n                         (qs, M_mat_R signs subsets, subsets, signs)))\n                     (get_subsets_R\n                       (reduce_system_R p\n                         (qs, M_mat_R signs subsets, subsets, signs))) =\n                    get_matrix_R\n                     (reduce_system_R p\n                       (qs, M_mat_R signs subsets, subsets, signs))\n  length subsets = length signs\n  invertible_mat (M_mat_R signs subsets)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n     (get_subsets_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n    get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))", "by blast"], ["proof (state)\nthis:\n  M_mat_R\n   (get_signs_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n   (get_subsets_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n  get_matrix_R\n   (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have f2: \"length (get_subsets_R (take_rows_from_matrix (mat_of_cols (dim_row (matrix_A_R signs subsets)) (map ((!) (cols (matrix_A_R signs subsets))) (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))) (rows_to_keep (mat_of_cols (dim_row (matrix_A_R signs subsets)) (map ((!) (cols (matrix_A_R signs subsets))) (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))))), map ((!) subsets) (rows_to_keep (mat_of_cols (dim_row (matrix_A_R signs subsets)) (map ((!) (cols (matrix_A_R signs subsets))) (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))))), map ((!) signs) (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))) = length (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (get_subsets_R\n       (take_rows_from_matrix\n         (mat_of_cols (dim_row (M_mat_R signs subsets))\n           (map ((!) (cols (M_mat_R signs subsets)))\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n         (rows_to_keep\n           (mat_of_cols (dim_row (M_mat_R signs subsets))\n             (map ((!) (cols (M_mat_R signs subsets)))\n               (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))),\n        map ((!) subsets)\n         (rows_to_keep\n           (mat_of_cols (dim_row (M_mat_R signs subsets))\n             (map ((!) (cols (M_mat_R signs subsets)))\n               (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))),\n        map ((!) signs)\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    length\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "by (metis (no_types) \\<open>dim_col (mat_of_cols (dim_row (matrix_A_R signs subsets)) (take_indices (cols (matrix_A_R signs subsets)) (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))) = length (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\\<close> \\<open>length (rows_to_keep (reduce_mat_cols (matrix_A_R signs subsets) (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))) = dim_col (reduce_mat_cols (matrix_A_R signs subsets) (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\\<close> length_map reduce_mat_cols.simps reduce_system_R.simps reduction_step_R.simps reduction_subsets_R_def reduction_subsets_is_get_subsets_R take_cols_from_matrix_def take_indices_def)"], ["proof (state)\nthis:\n  length\n   (get_subsets_R\n     (take_rows_from_matrix\n       (mat_of_cols (dim_row (M_mat_R signs subsets))\n         (map ((!) (cols (M_mat_R signs subsets)))\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n       (rows_to_keep\n         (mat_of_cols (dim_row (M_mat_R signs subsets))\n           (map ((!) (cols (M_mat_R signs subsets)))\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))),\n      map ((!) subsets)\n       (rows_to_keep\n         (mat_of_cols (dim_row (M_mat_R signs subsets))\n           (map ((!) (cols (M_mat_R signs subsets)))\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))),\n      map ((!) signs)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  length\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have f3: \"\\<forall>p ps rss nss m. map ((!) rss) (find_nonzeros_from_input_vec (solve_for_lhs_R p ps nss m)) = get_signs_R (reduce_system_R p (ps, m, nss, rss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p ps rss nss m.\n       map ((!) rss)\n        (find_nonzeros_from_input_vec (solve_for_lhs_R p ps nss m)) =\n       get_signs_R (reduce_system_R p (ps, m, nss, rss))", "by (metis (no_types) reduction_signs_R_def reduction_signs_is_get_signs_R take_indices_def)"], ["proof (state)\nthis:\n  \\<forall>p ps rss nss m.\n     map ((!) rss)\n      (find_nonzeros_from_input_vec (solve_for_lhs_R p ps nss m)) =\n     get_signs_R (reduce_system_R p (ps, m, nss, rss))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have square_final_mat: \"square_mat (get_matrix_R (reduce_system_R p (qs, ((matrix_A_R signs subsets), (subsets, signs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "using mat_match assms size_of_mat_R same_size_R"], ["proof (prove)\nusing this:\n  M_mat_R\n   (get_signs_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n   (get_subsets_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))) =\n  get_matrix_R\n   (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs))\n  length subsets = length signs\n  invertible_mat (M_mat_R signs subsets)\n  p \\<noteq> 0\n  well_def_signs (length qs) signs\n  distinct signs\n  set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs\n  satisfy_equation_R p qs subsets signs\n  M_mat_R ?signs ?subsets\n  \\<in> carrier_mat (length ?subsets) (length ?signs)\n  invertible_mat (M_mat_R ?signs ?subsets) \\<Longrightarrow>\n  length ?subsets = length ?signs\n\ngoal (1 subgoal):\n 1. square_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M_mat_R\n              (get_signs_R\n                (let reduce_cols_A =\n                       take_cols_from_matrix (M_mat_R signs subsets)\n                        (find_nonzeros_from_input_vec\n                          (solve_for_lhs_R p qs subsets\n                            (M_mat_R signs subsets)));\n                     rows_keep = rows_to_keep reduce_cols_A\n                 in (take_rows_from_matrix reduce_cols_A rows_keep,\n                     take_indices subsets rows_keep,\n                     take_indices signs\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))))\n              (get_subsets_R\n                (let reduce_cols_A =\n                       take_cols_from_matrix (M_mat_R signs subsets)\n                        (find_nonzeros_from_input_vec\n                          (solve_for_lhs_R p qs subsets\n                            (M_mat_R signs subsets)));\n                     rows_keep = rows_to_keep reduce_cols_A\n                 in (take_rows_from_matrix reduce_cols_A rows_keep,\n                     take_indices subsets rows_keep,\n                     take_indices signs\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets)))))) =\n             get_matrix_R\n              (let reduce_cols_A =\n                     take_cols_from_matrix (M_mat_R signs subsets)\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets)));\n                   rows_keep = rows_to_keep reduce_cols_A\n               in (take_rows_from_matrix reduce_cols_A rows_keep,\n                   take_indices subsets rows_keep,\n                   take_indices signs\n                    (find_nonzeros_from_input_vec\n                      (solve_for_lhs_R p qs subsets\n                        (M_mat_R signs subsets)))));\n     invertible_mat (M_mat_R signs subsets); p \\<noteq> 0;\n     well_def_signs (length qs) signs; distinct signs;\n     set (characterize_consistent_signs_at_roots p qs)\n     \\<subseteq> set signs;\n     satisfy_equation_R p qs subsets signs;\n     \\<And>signs subsets.\n        M_mat_R signs subsets\n        \\<in> carrier_mat (length subsets) (length signs);\n     \\<And>signs subsets.\n        invertible_mat (M_mat_R signs subsets) \\<Longrightarrow>\n        length subsets = length signs\\<rbrakk>\n    \\<Longrightarrow> dim_col\n                       (get_matrix_R\n                         (let reduce_cols_A =\n                                take_cols_from_matrix\n                                 (M_mat_R signs subsets)\n                                 (find_nonzeros_from_input_vec\n                                   (solve_for_lhs_R p qs subsets\n                                     (M_mat_R signs subsets)));\n                              rows_keep = rows_to_keep reduce_cols_A\n                          in (take_rows_from_matrix reduce_cols_A rows_keep,\n                              take_indices subsets rows_keep,\n                              take_indices signs\n                               (find_nonzeros_from_input_vec\n                                 (solve_for_lhs_R p qs subsets\n                                   (M_mat_R signs subsets)))))) =\n                      dim_row\n                       (get_matrix_R\n                         (let reduce_cols_A =\n                                take_cols_from_matrix\n                                 (M_mat_R signs subsets)\n                                 (find_nonzeros_from_input_vec\n                                   (solve_for_lhs_R p qs subsets\n                                     (M_mat_R signs subsets)));\n                              rows_keep = rows_to_keep reduce_cols_A\n                          in (take_rows_from_matrix reduce_cols_A rows_keep,\n                              take_indices subsets rows_keep,\n                              take_indices signs\n                               (find_nonzeros_from_input_vec\n                                 (solve_for_lhs_R p qs subsets\n                                   (M_mat_R signs subsets))))))", "using f2 f3"], ["proof (prove)\nusing this:\n  length\n   (get_subsets_R\n     (take_rows_from_matrix\n       (mat_of_cols (dim_row (M_mat_R signs subsets))\n         (map ((!) (cols (M_mat_R signs subsets)))\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n       (rows_to_keep\n         (mat_of_cols (dim_row (M_mat_R signs subsets))\n           (map ((!) (cols (M_mat_R signs subsets)))\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))),\n      map ((!) subsets)\n       (rows_to_keep\n         (mat_of_cols (dim_row (M_mat_R signs subsets))\n           (map ((!) (cols (M_mat_R signs subsets)))\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))),\n      map ((!) signs)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  length\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  \\<forall>p ps rss nss m.\n     map ((!) rss)\n      (find_nonzeros_from_input_vec (solve_for_lhs_R p ps nss m)) =\n     get_signs_R (reduce_system_R p (ps, m, nss, rss))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>M_mat_R\n              (get_signs_R\n                (let reduce_cols_A =\n                       take_cols_from_matrix (M_mat_R signs subsets)\n                        (find_nonzeros_from_input_vec\n                          (solve_for_lhs_R p qs subsets\n                            (M_mat_R signs subsets)));\n                     rows_keep = rows_to_keep reduce_cols_A\n                 in (take_rows_from_matrix reduce_cols_A rows_keep,\n                     take_indices subsets rows_keep,\n                     take_indices signs\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))))\n              (get_subsets_R\n                (let reduce_cols_A =\n                       take_cols_from_matrix (M_mat_R signs subsets)\n                        (find_nonzeros_from_input_vec\n                          (solve_for_lhs_R p qs subsets\n                            (M_mat_R signs subsets)));\n                     rows_keep = rows_to_keep reduce_cols_A\n                 in (take_rows_from_matrix reduce_cols_A rows_keep,\n                     take_indices subsets rows_keep,\n                     take_indices signs\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets)))))) =\n             get_matrix_R\n              (let reduce_cols_A =\n                     take_cols_from_matrix (M_mat_R signs subsets)\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets)));\n                   rows_keep = rows_to_keep reduce_cols_A\n               in (take_rows_from_matrix reduce_cols_A rows_keep,\n                   take_indices subsets rows_keep,\n                   take_indices signs\n                    (find_nonzeros_from_input_vec\n                      (solve_for_lhs_R p qs subsets\n                        (M_mat_R signs subsets)))));\n     invertible_mat (M_mat_R signs subsets); p \\<noteq> 0;\n     well_def_signs (length qs) signs; distinct signs;\n     set (characterize_consistent_signs_at_roots p qs)\n     \\<subseteq> set signs;\n     satisfy_equation_R p qs subsets signs;\n     \\<And>signs subsets.\n        M_mat_R signs subsets\n        \\<in> carrier_mat (length subsets) (length signs);\n     \\<And>signs subsets.\n        invertible_mat (M_mat_R signs subsets) \\<Longrightarrow>\n        length subsets = length signs\\<rbrakk>\n    \\<Longrightarrow> dim_col\n                       (get_matrix_R\n                         (let reduce_cols_A =\n                                take_cols_from_matrix\n                                 (M_mat_R signs subsets)\n                                 (find_nonzeros_from_input_vec\n                                   (solve_for_lhs_R p qs subsets\n                                     (M_mat_R signs subsets)));\n                              rows_keep = rows_to_keep reduce_cols_A\n                          in (take_rows_from_matrix reduce_cols_A rows_keep,\n                              take_indices subsets rows_keep,\n                              take_indices signs\n                               (find_nonzeros_from_input_vec\n                                 (solve_for_lhs_R p qs subsets\n                                   (M_mat_R signs subsets)))))) =\n                      dim_row\n                       (get_matrix_R\n                         (let reduce_cols_A =\n                                take_cols_from_matrix\n                                 (M_mat_R signs subsets)\n                                 (find_nonzeros_from_input_vec\n                                   (solve_for_lhs_R p qs subsets\n                                     (M_mat_R signs subsets)));\n                              rows_keep = rows_to_keep reduce_cols_A\n                          in (take_rows_from_matrix reduce_cols_A rows_keep,\n                              take_indices subsets rows_keep,\n                              take_indices signs\n                               (find_nonzeros_from_input_vec\n                                 (solve_for_lhs_R p qs subsets\n                                   (M_mat_R signs subsets))))))", "by (metis (no_types, lifting) Matrix.transpose_transpose fst_conv get_matrix_R_def index_transpose_mat(2) len_match length_map mat_of_cols_carrier(2) mat_of_cols_carrier(3) reduce_mat_cols.simps take_cols_from_matrix_def take_indices_def take_rows_and_take_cols)"], ["proof (state)\nthis:\n  square_mat\n   (get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have rank_match: \"vec_space.rank (dim_row ?new_mat) ?new_mat = dim_row ?new_mat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank\n     (dim_row\n       (take_rows_from_matrix\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n         (rows_to_keep\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))))\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    dim_row\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "using len_match rank_new_mat"], ["proof (prove)\nusing this:\n  length\n   (rows_to_keep\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  vec_space.rank\n   (dim_row\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))))\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  dim_col\n   (reduce_mat_cols (M_mat_R signs subsets)\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. vec_space.rank\n     (dim_row\n       (take_rows_from_matrix\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n         (rows_to_keep\n           (reduce_mat_cols (M_mat_R signs subsets)\n             (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))))\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n    dim_row\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "by (simp add: take_cols_from_matrix_def take_indices_def take_rows_and_take_cols)"], ["proof (state)\nthis:\n  vec_space.rank\n   (dim_row\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))))\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))) =\n  dim_row\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "have \"invertible_mat ?new_mat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "using invertible_det og_mat_size"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat ?A = (det ?A \\<noteq> (0::?'a))\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "using vec_space.det_rank_iff square_final_mat"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat ?A = (det ?A \\<noteq> (0::?'a))\n  M_mat_R signs subsets \\<in> carrier_mat (length signs) (length signs)\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  (det ?A \\<noteq> (0::?'a)) = (vec_space.rank ?n ?A = ?n)\n  square_mat\n   (get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (take_rows_from_matrix\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n       (rows_to_keep\n         (reduce_mat_cols (M_mat_R signs subsets)\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "by (metis dim_col_matrix_A_R dim_row_matrix_A_R fst_conv get_matrix_R_def mat_match rank_match reduce_system_R.simps reduction_step_R.simps size_of_mat_R square_mat.elims(2))"], ["proof (state)\nthis:\n  invertible_mat\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  invertible_mat\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))", "show ?thesis"], ["proof (prove)\nusing this:\n  invertible_mat\n   (take_rows_from_matrix\n     (reduce_mat_cols (M_mat_R signs subsets)\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n     (rows_to_keep\n       (reduce_mat_cols (M_mat_R signs subsets)\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat\n     (take_rows_from_matrix\n       (take_cols_from_matrix (M_mat_R signs subsets)\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n       (rows_to_keep\n         (take_cols_from_matrix (M_mat_R signs subsets)\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets)))))) \\<Longrightarrow>\n    invertible_mat\n     (get_matrix_R\n       (let reduce_cols_A =\n              take_cols_from_matrix (M_mat_R signs subsets)\n               (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n            rows_keep = rows_to_keep reduce_cols_A\n        in (take_rows_from_matrix reduce_cols_A rows_keep,\n            take_indices subsets rows_keep,\n            take_indices signs\n             (find_nonzeros_from_input_vec\n               (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))))", "by (metis fst_conv get_matrix_R_def)"], ["proof (state)\nthis:\n  invertible_mat\n   (get_matrix_R\n     (reduce_system_R p (qs, M_mat_R signs subsets, subsets, signs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Well def signs preserved when reducing\""], ["", "lemma reduction_doesnt_break_length_signs_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes length_init : \"\\<forall> x\\<in> set(signs). length x = length qs\"\n  assumes sat_eq: \"satisfy_equation_R p qs subsets signs\"\n  assumes inv_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"\\<forall>x \\<in> set(reduction_signs_R p qs signs subsets (matrix_A_R signs subsets)). \n    length x = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (reduction_signs_R p qs signs subsets\n                         (M_mat_R signs subsets)).\n       length x = length qs", "unfolding reduction_signs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (reduction_signs_R p qs signs subsets\n                         (M_mat_R signs subsets)).\n       length x = length qs", "using take_indices_lem"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n < length (take_indices ?arb_list ?index_list);\n   \\<forall>q.\n      List.member ?index_list q \\<longrightarrow>\n      q < length ?arb_list\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k<length ?arb_list.\n                       take_indices ?arb_list ?index_list ! ?n =\n                       ?arb_list ! k\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (reduction_signs_R p qs signs subsets\n                         (M_mat_R signs subsets)).\n       length x = length qs", "by (smt (verit) atLeastLessThan_iff construct_lhs_matches_solve_for_lhs_R filter_is_subset find_nonzeros_from_input_vec_def in_set_conv_nth in_set_member inv_mat length_init reduction_signs_R_def sat_eq set_upt size_of_lhs_R subset_code(1))"], ["", "subsection \"Distinct signs preserved when reducing\""], ["", "lemma reduction_signs_are_distinct_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes sat_eq: \"satisfy_equation_R p qs subsets signs\"\n  assumes inv_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  assumes distinct_init: \"distinct signs\"\n  shows \"distinct (reduction_signs_R p qs signs subsets (matrix_A_R signs subsets))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "have solve_construct: \"construct_lhs_vector_R p qs signs =\n  solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "using construct_lhs_matches_solve_for_lhs_R assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> w_vec_R ?p ?qs ?signs =\n                    solve_for_lhs_R ?p ?qs ?subsets\n                     (M_mat_R ?signs ?subsets)\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n  distinct signs\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "by simp"], ["proof (state)\nthis:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. distinct (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "have h1: \"distinct (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))", "unfolding find_nonzeros_from_input_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (filter\n       (\\<lambda>i.\n           solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n           0)\n       [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])", "using distinct_filter"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow> distinct (filter ?P ?xs)\n\ngoal (1 subgoal):\n 1. distinct\n     (filter\n       (\\<lambda>i.\n           solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n           0)\n       [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])", "using distinct_upt"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow> distinct (filter ?P ?xs)\n  distinct [?i..<?j]\n\ngoal (1 subgoal):\n 1. distinct\n     (filter\n       (\\<lambda>i.\n           solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $ i \\<noteq>\n           0)\n       [0..<dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])", "by blast"], ["proof (state)\nthis:\n  distinct\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. distinct (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "have h2: \"(\\<And>j. j \\<in> set (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))) \\<Longrightarrow>\n          j < length signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length signs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length signs", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length signs", "assume \"j \\<in> set (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\""], ["proof (state)\nthis:\n  j \\<in> set (find_nonzeros_from_input_vec\n                (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (find_nonzeros_from_input_vec\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets))) \\<Longrightarrow>\n       j < length signs", "show \"j < length signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length signs", "using solve_construct size_of_lhs_R"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  dim_vec (w_vec_R ?p ?qs ?signs) = length ?signs\n\ngoal (1 subgoal):\n 1. j < length signs", "by (metis \\<open>j \\<in> set (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\\<close> atLeastLessThan_iff filter_is_subset find_nonzeros_from_input_vec_def set_upt subset_iff)"], ["proof (state)\nthis:\n  j < length signs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length signs\n\ngoal (1 subgoal):\n 1. distinct (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "then"], ["proof (chain)\npicking this:\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length signs", "show ?thesis"], ["proof (prove)\nusing this:\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length signs\n\ngoal (1 subgoal):\n 1. distinct (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))", "unfolding reduction_signs_R_def"], ["proof (prove)\nusing this:\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length signs\n\ngoal (1 subgoal):\n 1. distinct\n     (take_indices signs\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "unfolding take_indices_def"], ["proof (prove)\nusing this:\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length signs\n\ngoal (1 subgoal):\n 1. distinct\n     (map ((!) signs)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "using distinct_init h1 h2 conjugatable_vec_space.distinct_map_nth[where ls = \"signs\", where inds = \"(find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))\"]"], ["proof (prove)\nusing this:\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length signs\n  distinct signs\n  distinct\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n  ?j \\<in> set (find_nonzeros_from_input_vec\n                 (solve_for_lhs_R p qs subsets\n                   (M_mat_R signs subsets))) \\<Longrightarrow>\n  ?j < length signs\n  \\<lbrakk>distinct signs;\n   distinct\n    (find_nonzeros_from_input_vec\n      (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)));\n   \\<And>j.\n      j \\<in> set (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets\n                      (M_mat_R signs subsets))) \\<Longrightarrow>\n      j < length signs\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (map ((!) signs)\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))\n\ngoal (1 subgoal):\n 1. distinct\n     (map ((!) signs)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))", "by blast"], ["proof (state)\nthis:\n  distinct (reduction_signs_R p qs signs subsets (M_mat_R signs subsets))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Well def subsets preserved when reducing\""], ["", "lemma reduction_doesnt_break_subsets_R:  \n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list* nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes length_init : \"all_list_constr_R subsets (length qs)\"\n  assumes sat_eq: \"satisfy_equation_R p qs subsets signs\"\n  assumes inv_mat: \"invertible_mat (matrix_A_R signs subsets)\"\n  shows \"all_list_constr_R (reduction_subsets_R p qs signs subsets (matrix_A_R signs subsets)) (length qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))\n     (length qs)", "unfolding all_list_constr_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))\n        x \\<longrightarrow>\n       list_constr (fst x) (length qs) \\<and>\n       list_constr (snd x) (length qs)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       List.member\n        (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))\n        (a, b) \\<Longrightarrow>\n       list_constr a (length qs) \\<and> list_constr b (length qs)", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       List.member\n        (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))\n        (a, b) \\<Longrightarrow>\n       list_constr a (length qs) \\<and> list_constr b (length qs)", "assume in_red_subsets: \"List.member (reduction_subsets_R p qs signs subsets (matrix_A_R signs subsets)) (a, b) \""], ["proof (state)\nthis:\n  List.member\n   (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets)) (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       List.member\n        (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))\n        (a, b) \\<Longrightarrow>\n       list_constr a (length qs) \\<and> list_constr b (length qs)", "have solve_construct: \"construct_lhs_vector_R p qs signs =\n  solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "using construct_lhs_matches_solve_for_lhs_R assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> w_vec_R ?p ?qs ?signs =\n                    solve_for_lhs_R ?p ?qs ?subsets\n                     (M_mat_R ?signs ?subsets)\n  p \\<noteq> 0\n  all_list_constr_R subsets (length qs)\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "by simp"], ["proof (state)\nthis:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       List.member\n        (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))\n        (a, b) \\<Longrightarrow>\n       list_constr a (length qs) \\<and> list_constr b (length qs)", "have rows_to_keep_hyp: \"\\<forall>y. y \\<in> set (rows_to_keep (reduce_mat_cols (matrix_A_R signs subsets) (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))) \\<longrightarrow> \n      y < length subsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       y \\<in> set (rows_to_keep\n                     (reduce_mat_cols (M_mat_R signs subsets)\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))) \\<longrightarrow>\n       y < length subsets", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set (rows_to_keep\n                     (take_cols_from_matrix (M_mat_R signs subsets)\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))) \\<Longrightarrow>\n       y < length subsets", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set (rows_to_keep\n                     (take_cols_from_matrix (M_mat_R signs subsets)\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))) \\<Longrightarrow>\n       y < length subsets", "assume in_set: \"y \\<in> set (rows_to_keep\n                   (take_cols_from_matrix (matrix_A_R signs subsets) (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))))\""], ["proof (state)\nthis:\n  y \\<in> set (rows_to_keep\n                (take_cols_from_matrix (M_mat_R signs subsets)\n                  (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets\n                      (M_mat_R signs subsets)))))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set (rows_to_keep\n                     (take_cols_from_matrix (M_mat_R signs subsets)\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))) \\<Longrightarrow>\n       y < length subsets", "have in_set_2: \"y \\<in> set (rows_to_keep\n                   (take_cols_from_matrix (matrix_A_R signs subsets) (find_nonzeros_from_input_vec (construct_lhs_vector_R p qs signs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (rows_to_keep\n                  (take_cols_from_matrix (M_mat_R signs subsets)\n                    (find_nonzeros_from_input_vec (w_vec_R p qs signs))))", "using in_set solve_construct"], ["proof (prove)\nusing this:\n  y \\<in> set (rows_to_keep\n                (take_cols_from_matrix (M_mat_R signs subsets)\n                  (find_nonzeros_from_input_vec\n                    (solve_for_lhs_R p qs subsets\n                      (M_mat_R signs subsets)))))\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. y \\<in> set (rows_to_keep\n                  (take_cols_from_matrix (M_mat_R signs subsets)\n                    (find_nonzeros_from_input_vec (w_vec_R p qs signs))))", "by simp"], ["proof (state)\nthis:\n  y \\<in> set (rows_to_keep\n                (take_cols_from_matrix (M_mat_R signs subsets)\n                  (find_nonzeros_from_input_vec (w_vec_R p qs signs))))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set (rows_to_keep\n                     (take_cols_from_matrix (M_mat_R signs subsets)\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))) \\<Longrightarrow>\n       y < length subsets", "let ?lhs_vec = \"(solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set (rows_to_keep\n                     (take_cols_from_matrix (M_mat_R signs subsets)\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))) \\<Longrightarrow>\n       y < length subsets", "have h30: \"(construct_lhs_vector_R p qs signs) = ?lhs_vec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "using assms construct_lhs_matches_solve_for_lhs_R"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  all_list_constr_R subsets (length qs)\n  satisfy_equation_R p qs subsets signs\n  invertible_mat (M_mat_R signs subsets)\n  \\<lbrakk>satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> w_vec_R ?p ?qs ?signs =\n                    solve_for_lhs_R ?p ?qs ?subsets\n                     (M_mat_R ?signs ?subsets)\n\ngoal (1 subgoal):\n 1. w_vec_R p qs signs =\n    solve_for_lhs_R p qs subsets (M_mat_R signs subsets)", "by simp"], ["proof (state)\nthis:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set (rows_to_keep\n                     (take_cols_from_matrix (M_mat_R signs subsets)\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))) \\<Longrightarrow>\n       y < length subsets", "have h3a: \"\\<forall>x. List.member (find_nonzeros_from_input_vec ?lhs_vec) x \\<longrightarrow>x < length (signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n        x \\<longrightarrow>\n       x < length signs", "using h30 size_of_lhs_R"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  dim_vec (w_vec_R ?p ?qs ?signs) = length ?signs\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n        x \\<longrightarrow>\n       x < length signs", "unfolding find_nonzeros_from_input_vec_def"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  dim_vec (w_vec_R ?p ?qs ?signs) = length ?signs\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (filter\n          (\\<lambda>i.\n              solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $\n              i \\<noteq>\n              0)\n          [0..<\n           dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n        x \\<longrightarrow>\n       x < length signs", "using atLeastLessThan_iff filter_is_subset member_def set_upt subset_eq"], ["proof (prove)\nusing this:\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n  dim_vec (w_vec_R ?p ?qs ?signs) = length ?signs\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  set (filter ?P ?xs) \\<subseteq> set ?xs\n  List.member ?xs ?x = (?x \\<in> set ?xs)\n  set [?i..<?j] = {?i..<?j}\n  (?A \\<subseteq> ?B) = (\\<forall>x\\<in>?A. x \\<in> ?B)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (filter\n          (\\<lambda>i.\n              solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $\n              i \\<noteq>\n              0)\n          [0..<\n           dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n        x \\<longrightarrow>\n       x < length signs", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>w_vec_R p qs signs =\n                solve_for_lhs_R p qs subsets (M_mat_R signs subsets);\n        \\<And>p qs signs. dim_vec (w_vec_R p qs signs) = length signs;\n        \\<And>xs x. List.member xs x = (x \\<in> set xs);\n        \\<And>A B. (A \\<subseteq> B) = (\\<forall>x\\<in>A. x \\<in> B);\n        List.member\n         (filter\n           (\\<lambda>i.\n               solve_for_lhs_R p qs subsets (M_mat_R signs subsets) $\n               i \\<noteq>\n               0)\n           [0..<\n            dim_vec (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))])\n         x\\<rbrakk>\n       \\<Longrightarrow> x < length signs", "by (smt (verit, best) atLeastLessThan_iff in_set_member mem_Collect_eq set_filter set_upt)"], ["proof (state)\nthis:\n  \\<forall>x.\n     List.member\n      (find_nonzeros_from_input_vec\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n      x \\<longrightarrow>\n     x < length signs\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set (rows_to_keep\n                     (take_cols_from_matrix (M_mat_R signs subsets)\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))) \\<Longrightarrow>\n       y < length subsets", "have h3c: \"\\<forall>x. List.member (rows_to_keep (reduce_mat_cols (matrix_A_R signs subsets) (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets)))) x \\<longrightarrow> x < length (subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member\n        (rows_to_keep\n          (reduce_mat_cols (M_mat_R signs subsets)\n            (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n        x \\<longrightarrow>\n       x < length subsets", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member\n        (rows_to_keep\n          (take_cols_from_matrix (M_mat_R signs subsets)\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n        x \\<Longrightarrow>\n       x < length subsets", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member\n        (rows_to_keep\n          (take_cols_from_matrix (M_mat_R signs subsets)\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n        x \\<Longrightarrow>\n       x < length subsets", "assume x_mem: \"List.member (rows_to_keep\n            (take_cols_from_matrix (matrix_A_R signs subsets)\n              (find_nonzeros_from_input_vec (solve_for_lhs_R p qs subsets (matrix_A_R signs subsets))))) x\""], ["proof (state)\nthis:\n  List.member\n   (rows_to_keep\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.member\n        (rows_to_keep\n          (take_cols_from_matrix (M_mat_R signs subsets)\n            (find_nonzeros_from_input_vec\n              (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n        x \\<Longrightarrow>\n       x < length subsets", "show \"x < length (subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < length subsets", "using x_mem"], ["proof (prove)\nusing this:\n  List.member\n   (rows_to_keep\n     (take_cols_from_matrix (M_mat_R signs subsets)\n       (find_nonzeros_from_input_vec\n         (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))))\n   x\n\ngoal (1 subgoal):\n 1. x < length subsets", "unfolding rows_to_keep_def"], ["proof (prove)\nusing this:\n  List.member\n   (map snd\n     (pivot_positions\n       (gauss_jordan_single\n         (take_cols_from_matrix (M_mat_R signs subsets)\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets))))\\<^sup>T)))\n   x\n\ngoal (1 subgoal):\n 1. x < length subsets", "using pivot_positions"], ["proof (prove)\nusing this:\n  List.member\n   (map snd\n     (pivot_positions\n       (gauss_jordan_single\n         (take_cols_from_matrix (M_mat_R signs subsets)\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets))))\\<^sup>T)))\n   x\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions ?A) =\n                    {(i, ?f i) |i. i < ?nr \\<and> ?f i \\<noteq> ?nc}\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (pivot_positions ?A))\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (pivot_positions ?A))\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> length (pivot_positions ?A) =\n                    card {i. i < ?nr \\<and> row ?A i \\<noteq> 0\\<^sub>v ?nc}\n\ngoal (1 subgoal):\n 1. x < length subsets", "using  dim_row_matrix_A h3a in_set_member nonzero reduce_system_matrix_signs_helper_R rows_to_keep_def rows_to_keep_lem"], ["proof (prove)\nusing this:\n  List.member\n   (map snd\n     (pivot_positions\n       (gauss_jordan_single\n         (take_cols_from_matrix (M_mat_R signs subsets)\n           (find_nonzeros_from_input_vec\n             (solve_for_lhs_R p qs subsets\n               (M_mat_R signs subsets))))\\<^sup>T)))\n   x\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions ?A) =\n                    {(i, ?f i) |i. i < ?nr \\<and> ?f i \\<noteq> ?nc}\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (pivot_positions ?A))\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (pivot_positions ?A))\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> length (pivot_positions ?A) =\n                    card {i. i < ?nr \\<and> row ?A i \\<noteq> 0\\<^sub>v ?nc}\n  dim_row (M_mat ?signs ?subsets) = length ?subsets\n  \\<forall>x.\n     List.member\n      (find_nonzeros_from_input_vec\n        (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n      x \\<longrightarrow>\n     x < length signs\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  p \\<noteq> 0\n  \\<lbrakk>\\<forall>x. List.member ?S x \\<longrightarrow> x < length ?signs;\n   ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> M_mat_R (take_indices ?signs ?S) ?subsets =\n                    take_cols_from_matrix (M_mat_R ?signs ?subsets) ?S\n  rows_to_keep ?A =\n  map snd (pivot_positions (gauss_jordan_single ?A\\<^sup>T))\n  ?ell \\<in> set (rows_to_keep ?A) \\<Longrightarrow> ?ell < dim_row ?A\n\ngoal (1 subgoal):\n 1. x < length subsets", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member\n              (map snd\n                (pivot_positions\n                  (gauss_jordan_single\n                    (take_cols_from_matrix (M_mat_R signs subsets)\n                      (find_nonzeros_from_input_vec\n                        (solve_for_lhs_R p qs subsets\n                          (M_mat_R signs subsets))))\\<^sup>T)))\n              x;\n     \\<And>A nr nc f.\n        \\<lbrakk>A \\<in> carrier_mat nr nc; pivot_fun A f nc\\<rbrakk>\n        \\<Longrightarrow> set (pivot_positions A) =\n                          {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc};\n     \\<And>A nr nc f.\n        \\<lbrakk>A \\<in> carrier_mat nr nc; pivot_fun A f nc\\<rbrakk>\n        \\<Longrightarrow> distinct (map fst (pivot_positions A));\n     \\<And>A nr nc f.\n        \\<lbrakk>A \\<in> carrier_mat nr nc; pivot_fun A f nc\\<rbrakk>\n        \\<Longrightarrow> distinct (map snd (pivot_positions A));\n     \\<And>A nr nc f.\n        \\<lbrakk>A \\<in> carrier_mat nr nc; pivot_fun A f nc\\<rbrakk>\n        \\<Longrightarrow> length (pivot_positions A) =\n                          card\n                           {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc};\n     \\<forall>x.\n        List.member\n         (find_nonzeros_from_input_vec\n           (solve_for_lhs_R p qs subsets (M_mat_R signs subsets)))\n         x \\<longrightarrow>\n        x < length signs;\n     \\<And>x xs. (x \\<in> set xs) = List.member xs x; p \\<noteq> 0;\n     \\<And>S signs p subsets.\n        \\<lbrakk>\\<forall>x.\n                    List.member S x \\<longrightarrow> x < length signs;\n         p \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> M_mat_R (take_indices signs S) subsets =\n                          take_cols_from_matrix (M_mat_R signs subsets) S;\n     \\<And>A.\n        rows_to_keep A =\n        map snd (pivot_positions (gauss_jordan_single A\\<^sup>T));\n     \\<And>ell A.\n        ell \\<in> set (rows_to_keep A) \\<Longrightarrow>\n        ell < dim_row A\\<rbrakk>\n    \\<Longrightarrow> x < length subsets", "by (smt (verit, best) List.member_def dim_row_matrix_A_R rows_to_keep_def rows_to_keep_lem)"], ["proof (state)\nthis:\n  x < length subsets\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     List.member\n      (rows_to_keep\n        (reduce_mat_cols (M_mat_R signs subsets)\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n      x \\<longrightarrow>\n     x < length subsets\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set (rows_to_keep\n                     (take_cols_from_matrix (M_mat_R signs subsets)\n                       (find_nonzeros_from_input_vec\n                         (solve_for_lhs_R p qs subsets\n                           (M_mat_R signs subsets))))) \\<Longrightarrow>\n       y < length subsets", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     List.member\n      (rows_to_keep\n        (reduce_mat_cols (M_mat_R signs subsets)\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n      x \\<longrightarrow>\n     x < length subsets", "show \"y < length subsets\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     List.member\n      (rows_to_keep\n        (reduce_mat_cols (M_mat_R signs subsets)\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n      x \\<longrightarrow>\n     x < length subsets\n\ngoal (1 subgoal):\n 1. y < length subsets", "using in_set_member"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     List.member\n      (rows_to_keep\n        (reduce_mat_cols (M_mat_R signs subsets)\n          (solve_for_lhs_R p qs subsets (M_mat_R signs subsets))))\n      x \\<longrightarrow>\n     x < length subsets\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. y < length subsets", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                List.member\n                 (rows_to_keep\n                   (take_cols_from_matrix (M_mat_R signs subsets)\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))))\n                 x \\<longrightarrow>\n                x < length subsets;\n     \\<And>x xs. (x \\<in> set xs) = List.member xs x\\<rbrakk>\n    \\<Longrightarrow> y < length subsets", "using in_set_2 solve_construct"], ["proof (prove)\nusing this:\n  y \\<in> set (rows_to_keep\n                (take_cols_from_matrix (M_mat_R signs subsets)\n                  (find_nonzeros_from_input_vec (w_vec_R p qs signs))))\n  w_vec_R p qs signs = solve_for_lhs_R p qs subsets (M_mat_R signs subsets)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                List.member\n                 (rows_to_keep\n                   (take_cols_from_matrix (M_mat_R signs subsets)\n                     (find_nonzeros_from_input_vec\n                       (solve_for_lhs_R p qs subsets\n                         (M_mat_R signs subsets)))))\n                 x \\<longrightarrow>\n                x < length subsets;\n     \\<And>x xs. (x \\<in> set xs) = List.member xs x\\<rbrakk>\n    \\<Longrightarrow> y < length subsets", "by fastforce"], ["proof (state)\nthis:\n  y < length subsets\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y.\n     y \\<in> set (rows_to_keep\n                   (reduce_mat_cols (M_mat_R signs subsets)\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets)))) \\<longrightarrow>\n     y < length subsets\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       List.member\n        (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets))\n        (a, b) \\<Longrightarrow>\n       list_constr a (length qs) \\<and> list_constr b (length qs)", "show \"list_constr a (length qs) \\<and> list_constr b (length qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr a (length qs) \\<and> list_constr b (length qs)", "using in_red_subsets"], ["proof (prove)\nusing this:\n  List.member\n   (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets)) (a, b)\n\ngoal (1 subgoal):\n 1. list_constr a (length qs) \\<and> list_constr b (length qs)", "unfolding  reduction_subsets_def"], ["proof (prove)\nusing this:\n  List.member\n   (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets)) (a, b)\n\ngoal (1 subgoal):\n 1. list_constr a (length qs) \\<and> list_constr b (length qs)", "using take_indices_lem_R[of _ subsets]  rows_to_keep_hyp"], ["proof (prove)\nusing this:\n  List.member\n   (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets)) (a, b)\n  \\<lbrakk>?n < length (take_indices subsets ?index_list);\n   \\<forall>q.\n      List.member ?index_list q \\<longrightarrow>\n      q < length subsets\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k<length subsets.\n                       take_indices subsets ?index_list ! ?n = subsets ! k\n  \\<forall>y.\n     y \\<in> set (rows_to_keep\n                   (reduce_mat_cols (M_mat_R signs subsets)\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets)))) \\<longrightarrow>\n     y < length subsets\n\ngoal (1 subgoal):\n 1. list_constr a (length qs) \\<and> list_constr b (length qs)", "using all_list_constr_R_def in_set_conv_nth in_set_member length_init"], ["proof (prove)\nusing this:\n  List.member\n   (reduction_subsets_R p qs signs subsets (M_mat_R signs subsets)) (a, b)\n  \\<lbrakk>?n < length (take_indices subsets ?index_list);\n   \\<forall>q.\n      List.member ?index_list q \\<longrightarrow>\n      q < length subsets\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k<length subsets.\n                       take_indices subsets ?index_list ! ?n = subsets ! k\n  \\<forall>y.\n     y \\<in> set (rows_to_keep\n                   (reduce_mat_cols (M_mat_R signs subsets)\n                     (solve_for_lhs_R p qs subsets\n                       (M_mat_R signs subsets)))) \\<longrightarrow>\n     y < length subsets\n  all_list_constr_R ?L ?n \\<equiv>\n  \\<forall>x.\n     List.member ?L x \\<longrightarrow>\n     list_constr (fst x) ?n \\<and> list_constr (snd x) ?n\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  all_list_constr_R subsets (length qs)\n\ngoal (1 subgoal):\n 1. list_constr a (length qs) \\<and> list_constr b (length qs)", "by (metis fst_conv reduction_subsets_R_def snd_conv)"], ["proof (state)\nthis:\n  list_constr a (length qs) \\<and> list_constr b (length qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Overall Lemmas\""], ["", "lemma combining_to_smash_R:  \"combine_systems_R p (qs1, m1, (sub1, sgn1)) (qs2, m2, (sub2, sgn2))\n =  smash_systems_R p qs1 qs2 sub1 sub2 sgn1 sgn2 m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. combine_systems_R p (qs1, m1, sub1, sgn1) (qs2, m2, sub2, sgn2) =\n    smash_systems_R p qs1 qs2 sub1 sub2 sgn1 sgn2 m1 m2", "by simp"], ["", "lemma getter_functions_R: \"calculate_data_R p qs = (get_matrix_R (calculate_data_R p qs), (get_subsets_R (calculate_data_R p qs), get_signs_R (calculate_data_R p qs))) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. calculate_data_R p qs =\n    (get_matrix_R (calculate_data_R p qs),\n     get_subsets_R (calculate_data_R p qs),\n     get_signs_R (calculate_data_R p qs))", "unfolding get_matrix_R_def get_subsets_R_def get_signs_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. calculate_data_R p qs =\n    (fst (calculate_data_R p qs), fst (snd (calculate_data_R p qs)),\n     snd (snd (calculate_data_R p qs)))", "by auto"], ["", "subsection \"Key properties preserved\""], ["", "subsubsection \"Properties preserved when combining and reducing systems\""], ["", "lemma combining_sys_satisfies_properties_helper_R:\n  fixes p:: \"real poly\"\n  fixes qs1 :: \"real poly list\"\n  fixes qs2 :: \"real poly list\"\n  fixes subsets1 subsets2 :: \"(nat list * nat list) list\"\n  fixes signs1 signs2 :: \"rat list list\" \n  fixes matrix1 matrix2:: \"rat mat\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes nontriv1: \"length qs1 > 0\"\n  assumes nontriv2: \"length qs2 > 0\"\n  assumes satisfies_properties_sys1: \"satisfies_properties_R p qs1 subsets1 signs1 matrix1\"\n  assumes satisfies_properties_sys2: \"satisfies_properties_R p qs2 subsets2 signs2 matrix2\"\n  shows  \"satisfies_properties_R p (qs1@qs2) (get_subsets_R (snd ((combine_systems_R p (qs1,(matrix1, (subsets1, signs1))) (qs2,(matrix2, (subsets2, signs2))))))) \n  (get_signs_R (snd ((combine_systems_R p (qs1,(matrix1, (subsets1, signs1))) (qs2,(matrix2, (subsets2, signs2))))))) \n  (get_matrix_R (snd ((combine_systems_R p (qs1,(matrix1, (subsets1, signs1))) (qs2,(matrix2, (subsets2, signs2)))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "let ?subsets = \"(get_subsets_R (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "let ?signs = \"(get_signs_R (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1) (qs2, matrix2, subsets2, signs2))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "let ?matrix = \"(get_matrix_R (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1) (qs2, matrix2, subsets2, signs2))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "have h1: \"all_list_constr_R ?subsets (length (qs1 @ qs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (length (qs1 @ qs2))", "using well_def_step_R[of subsets1 qs1 subsets2 qs2] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>all_list_constr_R subsets1 (length qs1);\n   all_list_constr_R subsets2 (length qs2)\\<rbrakk>\n  \\<Longrightarrow> all_list_constr_R\n                     (subsets_smash_R (length qs1) subsets1 subsets2)\n                     (length (qs1 @ qs2))\n  p \\<noteq> 0\n  0 < length qs1\n  0 < length qs2\n  satisfies_properties_R p qs1 subsets1 signs1 matrix1\n  satisfies_properties_R p qs2 subsets2 signs2 matrix2\n\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (length (qs1 @ qs2))", "by (simp add: nontriv2 get_subsets_R_def satisfies_properties_R_def smash_systems_R_def)"], ["proof (state)\nthis:\n  all_list_constr_R\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n   (length (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "have h2: \"well_def_signs (length (qs1 @ qs2)) ?signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def_signs (length (qs1 @ qs2))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "using well_def_signs_step[of qs1 qs2 signs1 signs2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length qs1; 0 < length qs2;\n   well_def_signs (length qs1) signs1;\n   well_def_signs (length qs2) signs2\\<rbrakk>\n  \\<Longrightarrow> well_def_signs (length (qs1 @ qs2))\n                     (signs_smash signs1 signs2)\n\ngoal (1 subgoal):\n 1. well_def_signs (length (qs1 @ qs2))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "using get_signs_R_def nontriv1 nontriv2 satisfies_properties_R_def satisfies_properties_sys1 satisfies_properties_sys2 smash_systems_R_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length qs1; 0 < length qs2;\n   well_def_signs (length qs1) signs1;\n   well_def_signs (length qs2) signs2\\<rbrakk>\n  \\<Longrightarrow> well_def_signs (length (qs1 @ qs2))\n                     (signs_smash signs1 signs2)\n  get_signs_R ?data = snd (snd ?data)\n  0 < length qs1\n  0 < length qs2\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n  satisfies_properties_R p qs1 subsets1 signs1 matrix1\n  satisfies_properties_R p qs2 subsets2 signs2 matrix2\n  smash_systems_R ?p ?qs1.0 ?qs2.0 ?subsets1.0 ?subsets2.0 ?signs1.0\n   ?signs2.0 ?mat1.0 ?mat2.0 =\n  (?qs1.0 @ ?qs2.0, kronecker_product ?mat1.0 ?mat2.0,\n   subsets_smash_R (length ?qs1.0) ?subsets1.0 ?subsets2.0,\n   signs_smash ?signs1.0 ?signs2.0)\n\ngoal (1 subgoal):\n 1. well_def_signs (length (qs1 @ qs2))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "by auto"], ["proof (state)\nthis:\n  well_def_signs (length (qs1 @ qs2))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "have h3: \"distinct ?signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "using distinct_step[of _ signs1 _ signs2] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_def_signs ?n1.0 signs1; well_def_signs ?n2.0 signs2;\n   distinct signs1; distinct signs2\\<rbrakk>\n  \\<Longrightarrow> distinct (signs_smash signs1 signs2)\n  p \\<noteq> 0\n  0 < length qs1\n  0 < length qs2\n  satisfies_properties_R p qs1 subsets1 signs1 matrix1\n  satisfies_properties_R p qs2 subsets2 signs2 matrix2\n\ngoal (1 subgoal):\n 1. distinct\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "using combine_systems.simps get_signs_R_def satisfies_properties_R_def smash_systems_R_def snd_conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_def_signs ?n1.0 signs1; well_def_signs ?n2.0 signs2;\n   distinct signs1; distinct signs2\\<rbrakk>\n  \\<Longrightarrow> distinct (signs_smash signs1 signs2)\n  p \\<noteq> 0\n  0 < length qs1\n  0 < length qs2\n  satisfies_properties_R p qs1 subsets1 signs1 matrix1\n  satisfies_properties_R p qs2 subsets2 signs2 matrix2\n  combine_systems ?p (?qs1.0, ?m1.0, ?sub1.0, ?sgn1.0)\n   (?qs2.0, ?m2.0, ?sub2.0, ?sgn2.0) =\n  smash_systems ?p ?qs1.0 ?qs2.0 ?sub1.0 ?sub2.0 ?sgn1.0 ?sgn2.0 ?m1.0 ?m2.0\n  get_signs_R ?data = snd (snd ?data)\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n  smash_systems_R ?p ?qs1.0 ?qs2.0 ?subsets1.0 ?subsets2.0 ?signs1.0\n   ?signs2.0 ?mat1.0 ?mat2.0 =\n  (?qs1.0 @ ?qs2.0, kronecker_product ?mat1.0 ?mat2.0,\n   subsets_smash_R (length ?qs1.0) ?subsets1.0 ?subsets2.0,\n   signs_smash ?signs1.0 ?signs2.0)\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. distinct\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "by auto"], ["proof (state)\nthis:\n  distinct\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "have h4: \"satisfy_equation_R p (qs1 @ qs2) ?subsets ?signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "using assms inductive_step_R[of p qs1 qs2 signs1 signs2 subsets1 subsets2]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 < length qs1\n  0 < length qs2\n  satisfies_properties_R p qs1 subsets1 signs1 matrix1\n  satisfies_properties_R p qs2 subsets2 signs2 matrix2\n  \\<lbrakk>p \\<noteq> 0; 0 < length qs1; 0 < length qs2;\n   well_def_signs (length qs1) signs1; well_def_signs (length qs2) signs2;\n   distinct signs1; distinct signs2;\n   set (characterize_consistent_signs_at_roots p qs1)\n   \\<subseteq> set signs1;\n   set (characterize_consistent_signs_at_roots p qs2)\n   \\<subseteq> set signs2;\n   all_list_constr_R subsets1 (length qs1);\n   all_list_constr_R subsets2 (length qs2);\n   invertible_mat (M_mat_R signs1 subsets1);\n   invertible_mat (M_mat_R signs2 subsets2)\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R p (qs1 @ qs2)\n                     (subsets_smash_R (length qs1) subsets1 subsets2)\n                     (signs_smash signs1 signs2) \\<and>\n                    invertible_mat\n                     (M_mat_R (signs_smash signs1 signs2)\n                       (subsets_smash_R (length qs1) subsets1 subsets2))\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "using get_signs_R_def get_subsets_R_def satisfies_properties_R_def smash_systems_R_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 < length qs1\n  0 < length qs2\n  satisfies_properties_R p qs1 subsets1 signs1 matrix1\n  satisfies_properties_R p qs2 subsets2 signs2 matrix2\n  \\<lbrakk>p \\<noteq> 0; 0 < length qs1; 0 < length qs2;\n   well_def_signs (length qs1) signs1; well_def_signs (length qs2) signs2;\n   distinct signs1; distinct signs2;\n   set (characterize_consistent_signs_at_roots p qs1)\n   \\<subseteq> set signs1;\n   set (characterize_consistent_signs_at_roots p qs2)\n   \\<subseteq> set signs2;\n   all_list_constr_R subsets1 (length qs1);\n   all_list_constr_R subsets2 (length qs2);\n   invertible_mat (M_mat_R signs1 subsets1);\n   invertible_mat (M_mat_R signs2 subsets2)\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R p (qs1 @ qs2)\n                     (subsets_smash_R (length qs1) subsets1 subsets2)\n                     (signs_smash signs1 signs2) \\<and>\n                    invertible_mat\n                     (M_mat_R (signs_smash signs1 signs2)\n                       (subsets_smash_R (length qs1) subsets1 subsets2))\n  get_signs_R ?data = snd (snd ?data)\n  get_subsets_R ?data = fst (snd ?data)\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n  smash_systems_R ?p ?qs1.0 ?qs2.0 ?subsets1.0 ?subsets2.0 ?signs1.0\n   ?signs2.0 ?mat1.0 ?mat2.0 =\n  (?qs1.0 @ ?qs2.0, kronecker_product ?mat1.0 ?mat2.0,\n   subsets_smash_R (length ?qs1.0) ?subsets1.0 ?subsets2.0,\n   signs_smash ?signs1.0 ?signs2.0)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "by auto"], ["proof (state)\nthis:\n  satisfy_equation_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "have h5: \" invertible_mat ?matrix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "using assms inductive_step_R[of p qs1 qs2 signs1 signs2 subsets1 subsets2]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 < length qs1\n  0 < length qs2\n  satisfies_properties_R p qs1 subsets1 signs1 matrix1\n  satisfies_properties_R p qs2 subsets2 signs2 matrix2\n  \\<lbrakk>p \\<noteq> 0; 0 < length qs1; 0 < length qs2;\n   well_def_signs (length qs1) signs1; well_def_signs (length qs2) signs2;\n   distinct signs1; distinct signs2;\n   set (characterize_consistent_signs_at_roots p qs1)\n   \\<subseteq> set signs1;\n   set (characterize_consistent_signs_at_roots p qs2)\n   \\<subseteq> set signs2;\n   all_list_constr_R subsets1 (length qs1);\n   all_list_constr_R subsets2 (length qs2);\n   invertible_mat (M_mat_R signs1 subsets1);\n   invertible_mat (M_mat_R signs2 subsets2)\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R p (qs1 @ qs2)\n                     (subsets_smash_R (length qs1) subsets1 subsets2)\n                     (signs_smash signs1 signs2) \\<and>\n                    invertible_mat\n                     (M_mat_R (signs_smash signs1 signs2)\n                       (subsets_smash_R (length qs1) subsets1 subsets2))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "by (metis combining_to_smash_R fst_conv get_matrix_R_def kronecker_invertible satisfies_properties_R_def smash_systems_R_def snd_conv)"], ["proof (state)\nthis:\n  invertible_mat\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "have h6: \"?matrix = matrix_A_R ?signs ?subsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_matrix_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))) =\n    M_mat_R\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "unfolding get_matrix_R_def combine_systems_R.simps smash_systems_R_def get_signs_R_def get_subsets_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (qs1 @ qs2, kronecker_product matrix1 matrix2,\n              subsets_smash_R (length qs1) subsets1 subsets2,\n              signs_smash signs1 signs2)) =\n    M_mat_R\n     (snd (snd (snd (qs1 @ qs2, kronecker_product matrix1 matrix2,\n                     subsets_smash_R (length qs1) subsets1 subsets2,\n                     signs_smash signs1 signs2))))\n     (fst (snd (snd (qs1 @ qs2, kronecker_product matrix1 matrix2,\n                     subsets_smash_R (length qs1) subsets1 subsets2,\n                     signs_smash signs1 signs2))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. kronecker_product matrix1 matrix2 =\n    M_mat_R (signs_smash signs1 signs2)\n     (subsets_smash_R (length qs1) subsets1 subsets2)", "apply (subst matrix_construction_is_kronecker_product_R[of subsets1 _ signs1 signs2 subsets2])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l i.\n       \\<lbrakk>l \\<in> set subsets1;\n        i \\<in> set (fst l) \\<or> i \\<in> set (snd l)\\<rbrakk>\n       \\<Longrightarrow> i < length qs1\n 2. \\<And>j. j \\<in> set signs1 \\<Longrightarrow> length j = length qs1\n 3. kronecker_product matrix1 matrix2 =\n    kronecker_product (M_mat_R signs1 subsets1) (M_mat_R signs2 subsets2)", "apply (metis Ball_set all_list_constr_R_def in_set_member list_constr_def satisfies_properties_R_def satisfies_properties_sys1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j. j \\<in> set signs1 \\<Longrightarrow> length j = length qs1\n 2. kronecker_product matrix1 matrix2 =\n    kronecker_product (M_mat_R signs1 subsets1) (M_mat_R signs2 subsets2)", "using satisfies_properties_R_def satisfies_properties_sys1 well_def_signs_def"], ["proof (prove)\nusing this:\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n  satisfies_properties_R p qs1 subsets1 signs1 matrix1\n  well_def_signs ?num_polys ?sign_conds \\<equiv>\n  \\<forall>signs\\<in>set ?sign_conds. length signs = ?num_polys\n\ngoal (2 subgoals):\n 1. \\<And>j. j \\<in> set signs1 \\<Longrightarrow> length j = length qs1\n 2. kronecker_product matrix1 matrix2 =\n    kronecker_product (M_mat_R signs1 subsets1) (M_mat_R signs2 subsets2)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. kronecker_product matrix1 matrix2 =\n    kronecker_product (M_mat_R signs1 subsets1) (M_mat_R signs2 subsets2)", "using satisfies_properties_R_def satisfies_properties_sys1 satisfies_properties_sys2"], ["proof (prove)\nusing this:\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n  satisfies_properties_R p qs1 subsets1 signs1 matrix1\n  satisfies_properties_R p qs2 subsets2 signs2 matrix2\n\ngoal (1 subgoal):\n 1. kronecker_product matrix1 matrix2 =\n    kronecker_product (M_mat_R signs1 subsets1) (M_mat_R signs2 subsets2)", "by auto"], ["proof (state)\nthis:\n  get_matrix_R\n   (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n          (qs2, matrix2, subsets2, signs2))) =\n  M_mat_R\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "have h7: \"set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (?signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (get_signs_R\n                      (snd (combine_systems_R p\n                             (qs1, matrix1, subsets1, signs1)\n                             (qs2, matrix2, subsets2, signs2))))", "using subset_step_R[of p qs1 signs1 qs2  signs2] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>set (characterize_consistent_signs_at_roots p qs1)\n           \\<subseteq> set signs1;\n   set (characterize_consistent_signs_at_roots p qs2)\n   \\<subseteq> set signs2\\<rbrakk>\n  \\<Longrightarrow> set (characterize_consistent_signs_at_roots p\n                          (qs1 @ qs2))\n                    \\<subseteq> set (signs_smash signs1 signs2)\n  p \\<noteq> 0\n  0 < length qs1\n  0 < length qs2\n  satisfies_properties_R p qs1 subsets1 signs1 matrix1\n  satisfies_properties_R p qs2 subsets2 signs2 matrix2\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (get_signs_R\n                      (snd (combine_systems_R p\n                             (qs1, matrix1, subsets1, signs1)\n                             (qs2, matrix2, subsets2, signs2))))", "by (simp add: nonzero get_signs_R_def satisfies_properties_R_def smash_systems_R_def)"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (get_signs_R\n                    (snd (combine_systems_R p\n                           (qs1, matrix1, subsets1, signs1)\n                           (qs2, matrix2, subsets2, signs2))))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "then"], ["proof (chain)\npicking this:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (get_signs_R\n                    (snd (combine_systems_R p\n                           (qs1, matrix1, subsets1, signs1)\n                           (qs2, matrix2, subsets2, signs2))))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (get_signs_R\n                    (snd (combine_systems_R p\n                           (qs1, matrix1, subsets1, signs1)\n                           (qs2, matrix2, subsets2, signs2))))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))", "unfolding satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (get_signs_R\n                    (snd (combine_systems_R p\n                           (qs1, matrix1, subsets1, signs1)\n                           (qs2, matrix2, subsets2, signs2))))\n\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (length (qs1 @ qs2)) \\<and>\n    well_def_signs (length (qs1 @ qs2))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2)))) \\<and>\n    distinct\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2)))) \\<and>\n    satisfy_equation_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2)))) \\<and>\n    invertible_mat\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2)))) \\<and>\n    get_matrix_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))) =\n    M_mat_R\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2)))) \\<and>\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (get_signs_R\n                      (snd (combine_systems_R p\n                             (qs1, matrix1, subsets1, signs1)\n                             (qs2, matrix2, subsets2, signs2))))", "using h1 h2 h3 h4 h5 h6 h7"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (get_signs_R\n                    (snd (combine_systems_R p\n                           (qs1, matrix1, subsets1, signs1)\n                           (qs2, matrix2, subsets2, signs2))))\n  all_list_constr_R\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n   (length (qs1 @ qs2))\n  well_def_signs (length (qs1 @ qs2))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n  distinct\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n  satisfy_equation_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n  invertible_mat\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n  get_matrix_R\n   (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n          (qs2, matrix2, subsets2, signs2))) =\n  M_mat_R\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (get_signs_R\n                    (snd (combine_systems_R p\n                           (qs1, matrix1, subsets1, signs1)\n                           (qs2, matrix2, subsets2, signs2))))\n\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (length (qs1 @ qs2)) \\<and>\n    well_def_signs (length (qs1 @ qs2))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2)))) \\<and>\n    distinct\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2)))) \\<and>\n    satisfy_equation_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2)))) \\<and>\n    invertible_mat\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2)))) \\<and>\n    get_matrix_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))) =\n    M_mat_R\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2))))\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n              (qs2, matrix2, subsets2, signs2)))) \\<and>\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (get_signs_R\n                      (snd (combine_systems_R p\n                             (qs1, matrix1, subsets1, signs1)\n                             (qs2, matrix2, subsets2, signs2))))", "by blast"], ["proof (state)\nthis:\n  satisfies_properties_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, matrix1, subsets1, signs1)\n            (qs2, matrix2, subsets2, signs2))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma combining_sys_satisfies_properties_R:\n  fixes p:: \"real poly\"\n  fixes qs1 :: \"real poly list\"\n  fixes qs2 :: \"real poly list\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes nontriv1: \"length qs1 > 0\"\n  assumes nontriv2: \"length qs2 > 0\"\n  assumes satisfies_properties_sys1: \"satisfies_properties_R p qs1 (get_subsets_R (calculate_data_R p qs1)) (get_signs_R (calculate_data_R p qs1)) (get_matrix_R (calculate_data_R p qs1))\"\n  assumes satisfies_properties_sys2: \"satisfies_properties_R p qs2 (get_subsets_R (calculate_data_R p qs2)) (get_signs_R (calculate_data_R p qs2)) (get_matrix_R (calculate_data_R p qs2))\"\n  shows  \"satisfies_properties_R p (qs1@qs2) (get_subsets_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2))))) \n  (get_signs_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2))))) \n  (get_matrix_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "using combining_sys_satisfies_properties_helper_R[of p qs1 qs2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; 0 < length qs1; 0 < length qs2;\n   satisfies_properties_R p qs1 ?subsets1.0 ?signs1.0 ?matrix1.0;\n   satisfies_properties_R p qs2 ?subsets2.0 ?signs2.0 ?matrix2.0\\<rbrakk>\n  \\<Longrightarrow> satisfies_properties_R p (qs1 @ qs2)\n                     (get_subsets_R\n                       (snd (combine_systems_R p\n                              (qs1, ?matrix1.0, ?subsets1.0, ?signs1.0)\n                              (qs2, ?matrix2.0, ?subsets2.0, ?signs2.0))))\n                     (get_signs_R\n                       (snd (combine_systems_R p\n                              (qs1, ?matrix1.0, ?subsets1.0, ?signs1.0)\n                              (qs2, ?matrix2.0, ?subsets2.0, ?signs2.0))))\n                     (get_matrix_R\n                       (snd (combine_systems_R p\n                              (qs1, ?matrix1.0, ?subsets1.0, ?signs1.0)\n                              (qs2, ?matrix2.0, ?subsets2.0, ?signs2.0))))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "by (metis getter_functions_R nontriv1 nontriv2 nonzero satisfies_properties_sys1 satisfies_properties_sys2)"], ["", "lemma reducing_sys_satisfies_properties_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  fixes matrix:: \"rat mat\"\n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes nontriv: \"length qs > 0\"\n  assumes satisfies_properties_sys: \"satisfies_properties_R p qs subsets signs matrix\"\n  shows  \"satisfies_properties_R p qs (get_subsets_R (reduce_system_R p (qs,matrix,subsets,signs)))\n  (get_signs_R (reduce_system_R p (qs,matrix,subsets,signs)))\n  (get_matrix_R (reduce_system_R p (qs,matrix,subsets,signs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "have h1: \" all_list_constr_R (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs))) (length qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (length qs)", "using reduction_doesnt_break_subsets_R assms reduction_subsets_is_get_subsets_R satisfies_properties_R_def satisfies_properties_sys"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; all_list_constr_R ?subsets (length ?qs);\n   satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> all_list_constr_R\n                     (reduction_subsets_R ?p ?qs ?signs ?subsets\n                       (M_mat_R ?signs ?subsets))\n                     (length ?qs)\n  p \\<noteq> 0\n  0 < length qs\n  satisfies_properties_R p qs subsets signs matrix\n  reduction_subsets_R ?p ?qs ?signs ?subsets ?m =\n  get_subsets_R (reduce_system_R ?p (?qs, ?m, ?subsets, ?signs))\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n  satisfies_properties_R p qs subsets signs matrix\n\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (length qs)", "by auto"], ["proof (state)\nthis:\n  all_list_constr_R\n   (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n   (length qs)\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "have h2: \"well_def_signs (length qs) (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def_signs (length qs)\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))", "using reduction_doesnt_break_length_signs_R[of signs qs p subsets] assms reduction_signs_is_get_signs_R satisfies_properties_R_def well_def_signs_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set signs. length x = length qs;\n   satisfy_equation_R p qs subsets signs;\n   invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (reduction_signs_R p qs signs subsets\n   (M_mat_R signs subsets)).\n                       length x = length qs\n  p \\<noteq> 0\n  0 < length qs\n  satisfies_properties_R p qs subsets signs matrix\n  reduction_signs_R ?p ?qs ?signs ?subsets ?m =\n  get_signs_R (reduce_system_R ?p (?qs, ?m, ?subsets, ?signs))\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n  well_def_signs ?num_polys ?sign_conds \\<equiv>\n  \\<forall>signs\\<in>set ?sign_conds. length signs = ?num_polys\n\ngoal (1 subgoal):\n 1. well_def_signs (length qs)\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))", "by auto"], ["proof (state)\nthis:\n  well_def_signs (length qs)\n   (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "have h3: \"distinct (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))", "using reduction_signs_are_distinct_R[of p qs subsets signs] assms reduction_signs_is_get_signs_R satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>satisfy_equation_R p qs subsets signs;\n   invertible_mat (M_mat_R signs subsets); distinct signs\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (reduction_signs_R p qs signs subsets\n                       (M_mat_R signs subsets))\n  p \\<noteq> 0\n  0 < length qs\n  satisfies_properties_R p qs subsets signs matrix\n  reduction_signs_R ?p ?qs ?signs ?subsets ?m =\n  get_signs_R (reduce_system_R ?p (?qs, ?m, ?subsets, ?signs))\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. distinct (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))", "by auto"], ["proof (state)\nthis:\n  distinct (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "have h4: \"satisfy_equation_R p qs (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))", "using reduce_system_matrix_equation_preserved_R[of p qs signs subsets] assms satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs;\n   all_list_constr_R subsets (length qs); distinct signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   satisfy_equation_R p qs subsets signs;\n   invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R p qs\n                     (get_subsets_R\n                       (reduce_system_R p\n                         (qs, M_mat_R signs subsets, subsets, signs)))\n                     (get_signs_R\n                       (reduce_system_R p\n                         (qs, M_mat_R signs subsets, subsets, signs)))\n  p \\<noteq> 0\n  0 < length qs\n  satisfies_properties_R p qs subsets signs matrix\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))", "by auto"], ["proof (state)\nthis:\n  satisfy_equation_R p qs\n   (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n   (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "have h5: \"invertible_mat (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "using reduction_doesnt_break_things_invertibility_R assms same_size_R satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?subsets = length ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets); ?p \\<noteq> 0;\n   well_def_signs (length ?qs) ?signs; distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   satisfy_equation_R ?p ?qs ?subsets ?signs\\<rbrakk>\n  \\<Longrightarrow> invertible_mat\n                     (get_matrix_R\n                       (reduce_system_R ?p\n                         (?qs, M_mat_R ?signs ?subsets, ?subsets, ?signs)))\n  p \\<noteq> 0\n  0 < length qs\n  satisfies_properties_R p qs subsets signs matrix\n  invertible_mat (M_mat_R ?signs ?subsets) \\<Longrightarrow>\n  length ?subsets = length ?signs\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "by auto"], ["proof (state)\nthis:\n  invertible_mat\n   (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "have h6: \"get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)) =\n    matrix_A_R (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)) =\n    M_mat_R (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))", "using reduce_system_matrix_match_R[of p qs signs subsets] assms satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs; distinct signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   satisfy_equation_R p qs subsets signs;\n   invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n  \\<Longrightarrow> M_mat_R\n                     (get_signs_R\n                       (reduce_system_R p\n                         (qs, M_mat_R signs subsets, subsets, signs)))\n                     (get_subsets_R\n                       (reduce_system_R p\n                         (qs, M_mat_R signs subsets, subsets, signs))) =\n                    get_matrix_R\n                     (reduce_system_R p\n                       (qs, M_mat_R signs subsets, subsets, signs))\n  p \\<noteq> 0\n  0 < length qs\n  satisfies_properties_R p qs subsets signs matrix\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)) =\n    M_mat_R (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))", "by auto"], ["proof (state)\nthis:\n  get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)) =\n  M_mat_R (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n   (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "have h7: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (get_signs_R\n                      (reduce_system_R p (qs, matrix, subsets, signs)))", "using reduction_doesnt_break_things_signs_R[of p qs signs subsets] assms reduction_signs_is_get_signs_R satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) signs; distinct signs;\n   set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set signs;\n   satisfy_equation_R p qs subsets signs;\n   invertible_mat (M_mat_R signs subsets)\\<rbrakk>\n  \\<Longrightarrow> set (characterize_consistent_signs_at_roots p qs)\n                    \\<subseteq> set (reduction_signs_R p qs signs subsets\n(M_mat_R signs subsets))\n  p \\<noteq> 0\n  0 < length qs\n  satisfies_properties_R p qs subsets signs matrix\n  reduction_signs_R ?p ?qs ?signs ?subsets ?m =\n  get_signs_R (reduce_system_R ?p (?qs, ?m, ?subsets, ?signs))\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (get_signs_R\n                      (reduce_system_R p (qs, matrix, subsets, signs)))", "by auto"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (get_signs_R\n                    (reduce_system_R p (qs, matrix, subsets, signs)))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "then"], ["proof (chain)\npicking this:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (get_signs_R\n                    (reduce_system_R p (qs, matrix, subsets, signs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (get_signs_R\n                    (reduce_system_R p (qs, matrix, subsets, signs)))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))", "unfolding satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (get_signs_R\n                    (reduce_system_R p (qs, matrix, subsets, signs)))\n\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (length qs) \\<and>\n    well_def_signs (length qs)\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs))) \\<and>\n    distinct\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs))) \\<and>\n    satisfy_equation_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs))) \\<and>\n    invertible_mat\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs))) \\<and>\n    get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)) =\n    M_mat_R (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs))) \\<and>\n    set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (get_signs_R\n                      (reduce_system_R p (qs, matrix, subsets, signs)))", "using h1 h2 h3 h4 h5 h6 h7"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (get_signs_R\n                    (reduce_system_R p (qs, matrix, subsets, signs)))\n  all_list_constr_R\n   (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n   (length qs)\n  well_def_signs (length qs)\n   (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n  distinct (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n  satisfy_equation_R p qs\n   (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n   (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n  invertible_mat\n   (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))\n  get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)) =\n  M_mat_R (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n   (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set (get_signs_R\n                    (reduce_system_R p (qs, matrix, subsets, signs)))\n\ngoal (1 subgoal):\n 1. all_list_constr_R\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (length qs) \\<and>\n    well_def_signs (length qs)\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs))) \\<and>\n    distinct\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs))) \\<and>\n    satisfy_equation_R p qs\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs))) \\<and>\n    invertible_mat\n     (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs))) \\<and>\n    get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)) =\n    M_mat_R (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n     (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs))) \\<and>\n    set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set (get_signs_R\n                      (reduce_system_R p (qs, matrix, subsets, signs)))", "by blast"], ["proof (state)\nthis:\n  satisfies_properties_R p qs\n   (get_subsets_R (reduce_system_R p (qs, matrix, subsets, signs)))\n   (get_signs_R (reduce_system_R p (qs, matrix, subsets, signs)))\n   (get_matrix_R (reduce_system_R p (qs, matrix, subsets, signs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"For length 1 qs\""], ["", "lemma  length_1_calculate_data_satisfies_properties_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes len1: \"length qs = 1\"\n  shows \"satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs)) (get_signs_R (calculate_data_R p qs)) (get_matrix_R (calculate_data_R p qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "have h1: \"all_list_constr_R  [([], []),([0], []),([], [0])] (length qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr_R [([], []), ([0], []), ([], [0])] (length qs)", "using len1"], ["proof (prove)\nusing this:\n  length qs = 1\n\ngoal (1 subgoal):\n 1. all_list_constr_R [([], []), ([0], []), ([], [0])] (length qs)", "unfolding all_list_constr_R_def list_constr_def"], ["proof (prove)\nusing this:\n  length qs = 1\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member [([], []), ([0], []), ([], [0])] x \\<longrightarrow>\n       list_all (\\<lambda>x. x < length qs) (fst x) \\<and>\n       list_all (\\<lambda>x. x < length qs) (snd x)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>length qs = Suc 0;\n        List.member [([], []), ([0], []), ([], [0])] (a, b)\\<rbrakk>\n       \\<Longrightarrow> list_all (\\<lambda>x. x = 0) a\n 2. \\<And>a b.\n       \\<lbrakk>length qs = Suc 0;\n        List.member [([], []), ([0], []), ([], [0])] (a, b)\\<rbrakk>\n       \\<Longrightarrow> list_all (\\<lambda>x. x = 0) b", "apply (smt (verit, best) Ball_set in_set_member member_rec(1) member_rec(2) prod.inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>length qs = Suc 0;\n        List.member [([], []), ([0], []), ([], [0])] (a, b)\\<rbrakk>\n       \\<Longrightarrow> list_all (\\<lambda>x. x = 0) b", "by (smt (verit, ccfv_threshold) Ball_set in_set_member member_rec(1) member_rec(2) prod.inject)"], ["proof (state)\nthis:\n  all_list_constr_R [([], []), ([0], []), ([], [0])] (length qs)\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "have h2: \"well_def_signs (length qs) [[1],[-1]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def_signs (length qs) [[1], [- 1]]", "unfolding well_def_signs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>signs\\<in>set [[1], [- 1]]. length signs = length qs", "using len1 in_set_member"], ["proof (prove)\nusing this:\n  length qs = 1\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. \\<forall>signs\\<in>set [[1], [- 1]]. length signs = length qs", "by auto"], ["proof (state)\nthis:\n  well_def_signs (length qs) [[1], [- 1]]\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "have h3: \"distinct ([[1],[0],[-1]]::rat list list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [[1], [0], [- 1]]", "unfolding distinct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_list True (\\<lambda>x xs. (\\<and>) (x \\<notin> set xs))\n     [[1], [0], [- 1]]", "using in_set_member"], ["proof (prove)\nusing this:\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. rec_list True (\\<lambda>x xs. (\\<and>) (x \\<notin> set xs))\n     [[1], [0], [- 1]]", "by auto"], ["proof (state)\nthis:\n  distinct [[1], [0], [- 1]]\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "have h4: \"satisfy_equation_R p qs [([], []),([0], []),([], [0])] [[1],[0],[-1]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "using assms base_case_satisfy_equation_alt_R[of qs p]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  length qs = 1\n  \\<lbrakk>length qs = 1; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n                     [[1], [0], [- 1]]\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "by auto"], ["proof (state)\nthis:\n  satisfy_equation_R p qs [([], []), ([0], []), ([], [0])] [[1], [0], [- 1]]\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "have h6: \"(mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]]::rat mat) = (matrix_A_R ([[1],[0],[-1]]) ([([], []),([0], []),([], [0])]) :: rat mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] =\n    M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]", "using mat_base_case_R"], ["proof (prove)\nusing this:\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]\n\ngoal (1 subgoal):\n 1. mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] =\n    M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]", "by auto"], ["proof (state)\nthis:\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] =\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "then"], ["proof (chain)\npicking this:\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] =\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]", "have h5: \"invertible_mat (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]]::rat mat)\""], ["proof (prove)\nusing this:\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] =\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]\n\ngoal (1 subgoal):\n 1. invertible_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])", "using base_case_invertible_mat_R"], ["proof (prove)\nusing this:\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] =\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]\n  invertible_mat\n   (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])\n\ngoal (1 subgoal):\n 1. invertible_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])", "by simp"], ["proof (state)\nthis:\n  invertible_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "have h7:  \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set ([[1],[0],[-1]])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set [[1], [0], [- 1]]", "using assms base_case_sgas_alt_R[of qs p]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  length qs = 1\n  \\<lbrakk>length qs = 1; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> set (characterize_consistent_signs_at_roots p qs)\n                    \\<subseteq> {[1], [0], [- 1]}\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set [[1], [0], [- 1]]", "by simp"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set [[1], [0], [- 1]]\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "have base_case_hyp: \"satisfies_properties_R p qs [([], []),([0], []),([], [0])] [[1],[0],[-1]] (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]]::rat mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]\n     (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])", "using h1 h2 h3 h4 h5 h6 h7"], ["proof (prove)\nusing this:\n  all_list_constr_R [([], []), ([0], []), ([], [0])] (length qs)\n  well_def_signs (length qs) [[1], [- 1]]\n  distinct [[1], [0], [- 1]]\n  satisfy_equation_R p qs [([], []), ([0], []), ([], [0])] [[1], [0], [- 1]]\n  invertible_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] =\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set [[1], [0], [- 1]]\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]\n     (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])", "using satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  all_list_constr_R [([], []), ([0], []), ([], [0])] (length qs)\n  well_def_signs (length qs) [[1], [- 1]]\n  distinct [[1], [0], [- 1]]\n  satisfy_equation_R p qs [([], []), ([0], []), ([], [0])] [[1], [0], [- 1]]\n  invertible_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] =\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set [[1], [0], [- 1]]\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]\n     (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_list_constr_R [([], []), ([0], []), ([], [0])] (length qs);\n     well_def_signs (length qs) [[1], [- 1]];\n     satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n      [[1], [0], [- 1]];\n     invertible_mat\n      (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]);\n     mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]] =\n     M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])];\n     set (characterize_consistent_signs_at_roots p qs)\n     \\<subseteq> {[1], [0], [- 1]};\n     \\<And>p qs subsets signs matrix.\n        satisfies_properties_R p qs subsets signs matrix =\n        (all_list_constr_R subsets (length qs) \\<and>\n         well_def_signs (length qs) signs \\<and>\n         distinct signs \\<and>\n         satisfy_equation_R p qs subsets signs \\<and>\n         invertible_mat matrix \\<and>\n         matrix = M_mat_R signs subsets \\<and>\n         set (characterize_consistent_signs_at_roots p qs)\n         \\<subseteq> set signs)\\<rbrakk>\n    \\<Longrightarrow> well_def_signs (length qs) [[1], [0], [- 1]]", "by (simp add: well_def_signs_def)"], ["proof (state)\nthis:\n  satisfies_properties_R p qs [([], []), ([0], []), ([], [0])]\n   [[1], [0], [- 1]]\n   (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "then"], ["proof (chain)\npicking this:\n  satisfies_properties_R p qs [([], []), ([0], []), ([], [0])]\n   [[1], [0], [- 1]]\n   (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])", "have key_hyp: \"satisfies_properties_R p qs (get_subsets_R (reduce_system_R p (qs,base_case_info_R))) (get_signs_R (reduce_system_R p (qs,base_case_info_R))) (get_matrix_R (reduce_system_R p (qs,base_case_info_R)))\""], ["proof (prove)\nusing this:\n  satisfies_properties_R p qs [([], []), ([0], []), ([], [0])]\n   [[1], [0], [- 1]]\n   (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, base_case_info_R)))\n     (get_signs_R (reduce_system_R p (qs, base_case_info_R)))\n     (get_matrix_R (reduce_system_R p (qs, base_case_info_R)))", "using reducing_sys_satisfies_properties_R"], ["proof (prove)\nusing this:\n  satisfies_properties_R p qs [([], []), ([0], []), ([], [0])]\n   [[1], [0], [- 1]]\n   (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n  \\<lbrakk>?p \\<noteq> 0; 0 < length ?qs;\n   satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix\\<rbrakk>\n  \\<Longrightarrow> satisfies_properties_R ?p ?qs\n                     (get_subsets_R\n                       (reduce_system_R ?p\n                         (?qs, ?matrix, ?subsets, ?signs)))\n                     (get_signs_R\n                       (reduce_system_R ?p\n                         (?qs, ?matrix, ?subsets, ?signs)))\n                     (get_matrix_R\n                       (reduce_system_R ?p\n                         (?qs, ?matrix, ?subsets, ?signs)))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs\n     (get_subsets_R (reduce_system_R p (qs, base_case_info_R)))\n     (get_signs_R (reduce_system_R p (qs, base_case_info_R)))\n     (get_matrix_R (reduce_system_R p (qs, base_case_info_R)))", "by (metis base_case_info_R_def len1 nonzero nonzero zero_less_one_class.zero_less_one)"], ["proof (state)\nthis:\n  satisfies_properties_R p qs\n   (get_subsets_R (reduce_system_R p (qs, base_case_info_R)))\n   (get_signs_R (reduce_system_R p (qs, base_case_info_R)))\n   (get_matrix_R (reduce_system_R p (qs, base_case_info_R)))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "by (simp add: key_hyp len1)"], ["proof (state)\nthis:\n  satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n   (get_signs_R (calculate_data_R p qs))\n   (get_matrix_R (calculate_data_R p qs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"For arbitrary qs\""], ["", "lemma  calculate_data_satisfies_properties_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  shows \"(p \\<noteq> 0 \\<and> (length qs > 0))\n    \\<longrightarrow> satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs)) (get_signs_R (calculate_data_R p qs)) (get_matrix_R (calculate_data_R p qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "proof (induction \"length qs\" arbitrary: qs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "case less"], ["proof (state)\nthis:\n  length ?qs < length qs \\<Longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R p ?qs (get_subsets_R (calculate_data_R p ?qs))\n   (get_signs_R (calculate_data_R p ?qs))\n   (get_matrix_R (calculate_data_R p ?qs))\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "have len1_h: \"length qs = 1 \\<longrightarrow> ( p \\<noteq> 0 \\<and> (length qs > 0)) \\<longrightarrow> satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs)) (get_signs_R (calculate_data_R p qs)) (get_matrix_R (calculate_data_R p qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = 1 \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "using  length_1_calculate_data_satisfies_properties_R"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; length ?qs = 1\\<rbrakk>\n  \\<Longrightarrow> satisfies_properties_R ?p ?qs\n                     (get_subsets_R (calculate_data_R ?p ?qs))\n                     (get_signs_R (calculate_data_R ?p ?qs))\n                     (get_matrix_R (calculate_data_R ?p ?qs))\n\ngoal (1 subgoal):\n 1. length qs = 1 \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "by blast"], ["proof (state)\nthis:\n  length qs = 1 \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n   (get_signs_R (calculate_data_R p qs))\n   (get_matrix_R (calculate_data_R p qs))\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "let ?len = \"length qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "let ?q1 = \"take (?len div 2) qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "let ?left = \"calculate_data_R p ?q1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "let ?q2 = \"drop (?len div 2) qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "let ?right = \"calculate_data_R p ?q2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "let ?comb = \"combine_systems_R p (?q1,?left) (?q2,?right)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "let ?red =  \"reduce_system_R p ?comb\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "have h_q1_len: \"length qs > 1 \\<longrightarrow> (length ?q1 > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow> 0 < length (take (length qs div 2) qs)", "by auto"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow> 0 < length (take (length qs div 2) qs)\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "have h_q2_len: \"length qs > 1 \\<longrightarrow> (length ?q2 > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow> 0 < length (drop (length qs div 2) qs)", "by auto"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow> 0 < length (drop (length qs div 2) qs)\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "have q1_sat_props: \"length qs > 1 \\<longrightarrow> (p \\<noteq> 0 \\<and> (length qs > 0)) \\<longrightarrow> satisfies_properties_R p ?q1 (get_subsets_R (calculate_data_R p ?q1)) (get_signs_R (calculate_data_R p ?q1)) (get_matrix_R (calculate_data_R p ?q1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p (take (length qs div 2) qs)\n     (get_subsets_R (calculate_data_R p (take (length qs div 2) qs)))\n     (get_signs_R (calculate_data_R p (take (length qs div 2) qs)))\n     (get_matrix_R (calculate_data_R p (take (length qs div 2) qs)))", "using less.hyps[of ?q1] h_q1_len"], ["proof (prove)\nusing this:\n  length (take (length qs div 2) qs) < length qs \\<Longrightarrow>\n  p \\<noteq> 0 \\<and>\n  0 < length (take (length qs div 2) qs) \\<longrightarrow>\n  satisfies_properties_R p (take (length qs div 2) qs)\n   (get_subsets_R (calculate_data_R p (take (length qs div 2) qs)))\n   (get_signs_R (calculate_data_R p (take (length qs div 2) qs)))\n   (get_matrix_R (calculate_data_R p (take (length qs div 2) qs)))\n  1 < length qs \\<longrightarrow> 0 < length (take (length qs div 2) qs)\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p (take (length qs div 2) qs)\n     (get_subsets_R (calculate_data_R p (take (length qs div 2) qs)))\n     (get_signs_R (calculate_data_R p (take (length qs div 2) qs)))\n     (get_matrix_R (calculate_data_R p (take (length qs div 2) qs)))", "by (metis div_le_dividend div_less_dividend length_take min.absorb2 one_less_numeral_iff semiring_norm(76))"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p (take (length qs div 2) qs)\n   (get_subsets_R (calculate_data_R p (take (length qs div 2) qs)))\n   (get_signs_R (calculate_data_R p (take (length qs div 2) qs)))\n   (get_matrix_R (calculate_data_R p (take (length qs div 2) qs)))\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "have q2_help: \"length qs > 1 \\<longrightarrow> length (drop (length qs div 2) qs) < length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    length (drop (length qs div 2) qs) < length qs", "using h_q1_len"], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow> 0 < length (take (length qs div 2) qs)\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    length (drop (length qs div 2) qs) < length qs", "by auto"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  length (drop (length qs div 2) qs) < length qs\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "then"], ["proof (chain)\npicking this:\n  1 < length qs \\<longrightarrow>\n  length (drop (length qs div 2) qs) < length qs", "have q2_sat_props: \"length qs > 1 \\<longrightarrow> (p \\<noteq> 0 \\<and> (length qs > 0)) \\<longrightarrow> satisfies_properties_R p ?q2 (get_subsets_R (calculate_data_R p ?q2)) (get_signs_R (calculate_data_R p ?q2)) (get_matrix_R (calculate_data_R p ?q2))\""], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow>\n  length (drop (length qs div 2) qs) < length qs\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p (drop (length qs div 2) qs)\n     (get_subsets_R (calculate_data_R p (drop (length qs div 2) qs)))\n     (get_signs_R (calculate_data_R p (drop (length qs div 2) qs)))\n     (get_matrix_R (calculate_data_R p (drop (length qs div 2) qs)))", "using less.hyps[of ?q2] h_q2_len"], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow>\n  length (drop (length qs div 2) qs) < length qs\n  length (drop (length qs div 2) qs) < length qs \\<Longrightarrow>\n  p \\<noteq> 0 \\<and>\n  0 < length (drop (length qs div 2) qs) \\<longrightarrow>\n  satisfies_properties_R p (drop (length qs div 2) qs)\n   (get_subsets_R (calculate_data_R p (drop (length qs div 2) qs)))\n   (get_signs_R (calculate_data_R p (drop (length qs div 2) qs)))\n   (get_matrix_R (calculate_data_R p (drop (length qs div 2) qs)))\n  1 < length qs \\<longrightarrow> 0 < length (drop (length qs div 2) qs)\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p (drop (length qs div 2) qs)\n     (get_subsets_R (calculate_data_R p (drop (length qs div 2) qs)))\n     (get_signs_R (calculate_data_R p (drop (length qs div 2) qs)))\n     (get_matrix_R (calculate_data_R p (drop (length qs div 2) qs)))", "by blast"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p (drop (length qs div 2) qs)\n   (get_subsets_R (calculate_data_R p (drop (length qs div 2) qs)))\n   (get_signs_R (calculate_data_R p (drop (length qs div 2) qs)))\n   (get_matrix_R (calculate_data_R p (drop (length qs div 2) qs)))\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "have put_tog: \"?q1@?q2 = qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length qs div 2) qs @ drop (length qs div 2) qs = qs", "using append_take_drop_id"], ["proof (prove)\nusing this:\n  take ?n ?xs @ drop ?n ?xs = ?xs\n\ngoal (1 subgoal):\n 1. take (length qs div 2) qs @ drop (length qs div 2) qs = qs", "by blast"], ["proof (state)\nthis:\n  take (length qs div 2) qs @ drop (length qs div 2) qs = qs\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "then"], ["proof (chain)\npicking this:\n  take (length qs div 2) qs @ drop (length qs div 2) qs = qs", "have comb_sat_props: \"length qs > 1 \\<longrightarrow> (p \\<noteq> 0 \\<and> (length qs > 0)) \\<longrightarrow> (satisfies_properties_R p (qs) (get_subsets_R (snd ((combine_systems_R p (?q1,calculate_data_R p ?q1) (?q2,calculate_data_R p ?q2))))) \n  (get_signs_R (snd ((combine_systems_R p (?q1,calculate_data_R p ?q1) (?q2,calculate_data_R p ?q2))))) \n  (get_matrix_R (snd ((combine_systems_R p (?q1,calculate_data_R p ?q1) (?q2,calculate_data_R p ?q2))))))\""], ["proof (prove)\nusing this:\n  take (length qs div 2) qs @ drop (length qs div 2) qs = qs\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs\n     (get_subsets_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_signs_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_matrix_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))", "using q1_sat_props q2_sat_props  combining_sys_satisfies_properties_R"], ["proof (prove)\nusing this:\n  take (length qs div 2) qs @ drop (length qs div 2) qs = qs\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p (take (length qs div 2) qs)\n   (get_subsets_R (calculate_data_R p (take (length qs div 2) qs)))\n   (get_signs_R (calculate_data_R p (take (length qs div 2) qs)))\n   (get_matrix_R (calculate_data_R p (take (length qs div 2) qs)))\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p (drop (length qs div 2) qs)\n   (get_subsets_R (calculate_data_R p (drop (length qs div 2) qs)))\n   (get_signs_R (calculate_data_R p (drop (length qs div 2) qs)))\n   (get_matrix_R (calculate_data_R p (drop (length qs div 2) qs)))\n  \\<lbrakk>?p \\<noteq> 0; 0 < length ?qs1.0; 0 < length ?qs2.0;\n   satisfies_properties_R ?p ?qs1.0\n    (get_subsets_R (calculate_data_R ?p ?qs1.0))\n    (get_signs_R (calculate_data_R ?p ?qs1.0))\n    (get_matrix_R (calculate_data_R ?p ?qs1.0));\n   satisfies_properties_R ?p ?qs2.0\n    (get_subsets_R (calculate_data_R ?p ?qs2.0))\n    (get_signs_R (calculate_data_R ?p ?qs2.0))\n    (get_matrix_R (calculate_data_R ?p ?qs2.0))\\<rbrakk>\n  \\<Longrightarrow> satisfies_properties_R ?p (?qs1.0 @ ?qs2.0)\n                     (get_subsets_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n                     (get_signs_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n                     (get_matrix_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs\n     (get_subsets_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_signs_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_matrix_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))", "using h_q1_len h_q2_len  put_tog"], ["proof (prove)\nusing this:\n  take (length qs div 2) qs @ drop (length qs div 2) qs = qs\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p (take (length qs div 2) qs)\n   (get_subsets_R (calculate_data_R p (take (length qs div 2) qs)))\n   (get_signs_R (calculate_data_R p (take (length qs div 2) qs)))\n   (get_matrix_R (calculate_data_R p (take (length qs div 2) qs)))\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p (drop (length qs div 2) qs)\n   (get_subsets_R (calculate_data_R p (drop (length qs div 2) qs)))\n   (get_signs_R (calculate_data_R p (drop (length qs div 2) qs)))\n   (get_matrix_R (calculate_data_R p (drop (length qs div 2) qs)))\n  \\<lbrakk>?p \\<noteq> 0; 0 < length ?qs1.0; 0 < length ?qs2.0;\n   satisfies_properties_R ?p ?qs1.0\n    (get_subsets_R (calculate_data_R ?p ?qs1.0))\n    (get_signs_R (calculate_data_R ?p ?qs1.0))\n    (get_matrix_R (calculate_data_R ?p ?qs1.0));\n   satisfies_properties_R ?p ?qs2.0\n    (get_subsets_R (calculate_data_R ?p ?qs2.0))\n    (get_signs_R (calculate_data_R ?p ?qs2.0))\n    (get_matrix_R (calculate_data_R ?p ?qs2.0))\\<rbrakk>\n  \\<Longrightarrow> satisfies_properties_R ?p (?qs1.0 @ ?qs2.0)\n                     (get_subsets_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n                     (get_signs_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n                     (get_matrix_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n  1 < length qs \\<longrightarrow> 0 < length (take (length qs div 2) qs)\n  1 < length qs \\<longrightarrow> 0 < length (drop (length qs div 2) qs)\n  take (length qs div 2) qs @ drop (length qs div 2) qs = qs\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs\n     (get_subsets_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_signs_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_matrix_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))", "by metis"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs\n   (get_subsets_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_signs_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_matrix_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "then"], ["proof (chain)\npicking this:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs\n   (get_subsets_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_signs_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_matrix_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))", "have comb_sat: \"length qs > 1 \\<longrightarrow> (p \\<noteq> 0 \\<and> (length qs > 0)) \\<longrightarrow> \n      (satisfies_properties_R p (qs) (get_subsets_R (snd ?comb)) (get_signs_R (snd ?comb)) (get_matrix_R (snd ?comb)))\""], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs\n   (get_subsets_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_signs_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_matrix_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs\n     (get_subsets_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_signs_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_matrix_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))", "by blast"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs\n   (get_subsets_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_signs_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_matrix_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "have red_char: \"?red = (reduce_system_R p (qs,(get_matrix_R (snd ?comb)),(get_subsets_R (snd ?comb)),(get_signs_R (snd ?comb))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce_system_R p\n     (combine_systems_R p\n       (take (length qs div 2) qs,\n        calculate_data_R p (take (length qs div 2) qs))\n       (drop (length qs div 2) qs,\n        calculate_data_R p (drop (length qs div 2) qs))) =\n    reduce_system_R p\n     (qs,\n      get_matrix_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))),\n      get_subsets_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))),\n      get_signs_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))", "using getter_functions"], ["proof (prove)\nusing this:\n  calculate_data ?p ?qs =\n  (get_matrix (calculate_data ?p ?qs), get_subsets (calculate_data ?p ?qs),\n   get_signs (calculate_data ?p ?qs))\n\ngoal (1 subgoal):\n 1. reduce_system_R p\n     (combine_systems_R p\n       (take (length qs div 2) qs,\n        calculate_data_R p (take (length qs div 2) qs))\n       (drop (length qs div 2) qs,\n        calculate_data_R p (drop (length qs div 2) qs))) =\n    reduce_system_R p\n     (qs,\n      get_matrix_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))),\n      get_subsets_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))),\n      get_signs_R\n       (snd (combine_systems_R p\n              (take (length qs div 2) qs,\n               calculate_data_R p (take (length qs div 2) qs))\n              (drop (length qs div 2) qs,\n               calculate_data_R p (drop (length qs div 2) qs)))))", "by (smt (z3) combine_systems_R.simps find_consistent_signs_at_roots_R_def find_consistent_signs_at_roots_thm_R fst_conv get_matrix_R_def get_signs_R_def get_subsets_R_def prod.collapse put_tog smash_systems_R_def)"], ["proof (state)\nthis:\n  reduce_system_R p\n   (combine_systems_R p\n     (take (length qs div 2) qs,\n      calculate_data_R p (take (length qs div 2) qs))\n     (drop (length qs div 2) qs,\n      calculate_data_R p (drop (length qs div 2) qs))) =\n  reduce_system_R p\n   (qs,\n    get_matrix_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))),\n    get_subsets_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))),\n    get_signs_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "then"], ["proof (chain)\npicking this:\n  reduce_system_R p\n   (combine_systems_R p\n     (take (length qs div 2) qs,\n      calculate_data_R p (take (length qs div 2) qs))\n     (drop (length qs div 2) qs,\n      calculate_data_R p (drop (length qs div 2) qs))) =\n  reduce_system_R p\n   (qs,\n    get_matrix_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))),\n    get_subsets_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))),\n    get_signs_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))", "have \"length qs > 1 \\<longrightarrow> (p \\<noteq> 0 \\<and> (length qs > 0))  \\<longrightarrow> (satisfies_properties_R p qs (get_subsets_R ?red) (get_signs_R ?red) (get_matrix_R ?red))\""], ["proof (prove)\nusing this:\n  reduce_system_R p\n   (combine_systems_R p\n     (take (length qs div 2) qs,\n      calculate_data_R p (take (length qs div 2) qs))\n     (drop (length qs div 2) qs,\n      calculate_data_R p (drop (length qs div 2) qs))) =\n  reduce_system_R p\n   (qs,\n    get_matrix_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))),\n    get_subsets_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))),\n    get_signs_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs\n     (get_subsets_R\n       (reduce_system_R p\n         (combine_systems_R p\n           (take (length qs div 2) qs,\n            calculate_data_R p (take (length qs div 2) qs))\n           (drop (length qs div 2) qs,\n            calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_signs_R\n       (reduce_system_R p\n         (combine_systems_R p\n           (take (length qs div 2) qs,\n            calculate_data_R p (take (length qs div 2) qs))\n           (drop (length qs div 2) qs,\n            calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_matrix_R\n       (reduce_system_R p\n         (combine_systems_R p\n           (take (length qs div 2) qs,\n            calculate_data_R p (take (length qs div 2) qs))\n           (drop (length qs div 2) qs,\n            calculate_data_R p (drop (length qs div 2) qs)))))", "using reducing_sys_satisfies_properties_R comb_sat"], ["proof (prove)\nusing this:\n  reduce_system_R p\n   (combine_systems_R p\n     (take (length qs div 2) qs,\n      calculate_data_R p (take (length qs div 2) qs))\n     (drop (length qs div 2) qs,\n      calculate_data_R p (drop (length qs div 2) qs))) =\n  reduce_system_R p\n   (qs,\n    get_matrix_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))),\n    get_subsets_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))),\n    get_signs_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n  \\<lbrakk>?p \\<noteq> 0; 0 < length ?qs;\n   satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix\\<rbrakk>\n  \\<Longrightarrow> satisfies_properties_R ?p ?qs\n                     (get_subsets_R\n                       (reduce_system_R ?p\n                         (?qs, ?matrix, ?subsets, ?signs)))\n                     (get_signs_R\n                       (reduce_system_R ?p\n                         (?qs, ?matrix, ?subsets, ?signs)))\n                     (get_matrix_R\n                       (reduce_system_R ?p\n                         (?qs, ?matrix, ?subsets, ?signs)))\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs\n   (get_subsets_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_signs_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_matrix_R\n     (snd (combine_systems_R p\n            (take (length qs div 2) qs,\n             calculate_data_R p (take (length qs div 2) qs))\n            (drop (length qs div 2) qs,\n             calculate_data_R p (drop (length qs div 2) qs)))))\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs\n     (get_subsets_R\n       (reduce_system_R p\n         (combine_systems_R p\n           (take (length qs div 2) qs,\n            calculate_data_R p (take (length qs div 2) qs))\n           (drop (length qs div 2) qs,\n            calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_signs_R\n       (reduce_system_R p\n         (combine_systems_R p\n           (take (length qs div 2) qs,\n            calculate_data_R p (take (length qs div 2) qs))\n           (drop (length qs div 2) qs,\n            calculate_data_R p (drop (length qs div 2) qs)))))\n     (get_matrix_R\n       (reduce_system_R p\n         (combine_systems_R p\n           (take (length qs div 2) qs,\n            calculate_data_R p (take (length qs div 2) qs))\n           (drop (length qs div 2) qs,\n            calculate_data_R p (drop (length qs div 2) qs)))))", "by presburger"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs\n   (get_subsets_R\n     (reduce_system_R p\n       (combine_systems_R p\n         (take (length qs div 2) qs,\n          calculate_data_R p (take (length qs div 2) qs))\n         (drop (length qs div 2) qs,\n          calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_signs_R\n     (reduce_system_R p\n       (combine_systems_R p\n         (take (length qs div 2) qs,\n          calculate_data_R p (take (length qs div 2) qs))\n         (drop (length qs div 2) qs,\n          calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_matrix_R\n     (reduce_system_R p\n       (combine_systems_R p\n         (take (length qs div 2) qs,\n          calculate_data_R p (take (length qs div 2) qs))\n         (drop (length qs div 2) qs,\n          calculate_data_R p (drop (length qs div 2) qs)))))\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "then"], ["proof (chain)\npicking this:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs\n   (get_subsets_R\n     (reduce_system_R p\n       (combine_systems_R p\n         (take (length qs div 2) qs,\n          calculate_data_R p (take (length qs div 2) qs))\n         (drop (length qs div 2) qs,\n          calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_signs_R\n     (reduce_system_R p\n       (combine_systems_R p\n         (take (length qs div 2) qs,\n          calculate_data_R p (take (length qs div 2) qs))\n         (drop (length qs div 2) qs,\n          calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_matrix_R\n     (reduce_system_R p\n       (combine_systems_R p\n         (take (length qs div 2) qs,\n          calculate_data_R p (take (length qs div 2) qs))\n         (drop (length qs div 2) qs,\n          calculate_data_R p (drop (length qs div 2) qs)))))", "have len_gt1: \"length qs > 1 \\<longrightarrow> (p \\<noteq> 0 \\<and> (length qs > 0) ) \\<longrightarrow> satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs)) (get_signs_R (calculate_data_R p qs)) (get_matrix_R (calculate_data_R p qs))\""], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs\n   (get_subsets_R\n     (reduce_system_R p\n       (combine_systems_R p\n         (take (length qs div 2) qs,\n          calculate_data_R p (take (length qs div 2) qs))\n         (drop (length qs div 2) qs,\n          calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_signs_R\n     (reduce_system_R p\n       (combine_systems_R p\n         (take (length qs div 2) qs,\n          calculate_data_R p (take (length qs div 2) qs))\n         (drop (length qs div 2) qs,\n          calculate_data_R p (drop (length qs div 2) qs)))))\n   (get_matrix_R\n     (reduce_system_R p\n       (combine_systems_R p\n         (take (length qs div 2) qs,\n          calculate_data_R p (take (length qs div 2) qs))\n         (drop (length qs div 2) qs,\n          calculate_data_R p (drop (length qs div 2) qs)))))\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < length qs;\n     satisfies_properties_R p qs\n      (get_subsets_R\n        (reduce_system_R p\n          (combine_systems_R p\n            (take (length qs div 2) qs,\n             let len = min (length qs) (length qs div 2)\n             in if len = 0\n                then case reduce_system_R p ([1], base_case_info_R) of\n                     (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                else if len \\<le> 1\n                     then reduce_system_R p\n                           (take (length qs div 2) qs, base_case_info_R)\n                     else let q1 = take (len div 2)\n                                    (take (length qs div 2) qs);\n                              left = calculate_data_R p q1;\n                              q2 = drop (len div 2)\n                                    (take (length qs div 2) qs);\n                              right = calculate_data_R p q2\n                          in Let (combine_systems_R p (q1, left)\n                                   (q2, right))\n                              (reduce_system_R p))\n            (drop (length qs div 2) qs,\n             let len = length qs - length qs div 2\n             in if length qs \\<le> length qs div 2\n                then case reduce_system_R p ([1], base_case_info_R) of\n                     (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                else if len \\<le> 1\n                     then reduce_system_R p\n                           (drop (length qs div 2) qs, base_case_info_R)\n                     else let q1 = take (len div 2)\n                                    (drop (length qs div 2) qs);\n                              left = calculate_data_R p q1;\n                              q2 = drop (len div 2)\n                                    (drop (length qs div 2) qs);\n                              right = calculate_data_R p q2\n                          in Let (combine_systems_R p (q1, left)\n                                   (q2, right))\n                              (reduce_system_R p)))))\n      (get_signs_R\n        (reduce_system_R p\n          (combine_systems_R p\n            (take (length qs div 2) qs,\n             let len = min (length qs) (length qs div 2)\n             in if len = 0\n                then case reduce_system_R p ([1], base_case_info_R) of\n                     (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                else if len \\<le> 1\n                     then reduce_system_R p\n                           (take (length qs div 2) qs, base_case_info_R)\n                     else let q1 = take (len div 2)\n                                    (take (length qs div 2) qs);\n                              left = calculate_data_R p q1;\n                              q2 = drop (len div 2)\n                                    (take (length qs div 2) qs);\n                              right = calculate_data_R p q2\n                          in Let (combine_systems_R p (q1, left)\n                                   (q2, right))\n                              (reduce_system_R p))\n            (drop (length qs div 2) qs,\n             let len = length qs - length qs div 2\n             in if length qs \\<le> length qs div 2\n                then case reduce_system_R p ([1], base_case_info_R) of\n                     (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                else if len \\<le> 1\n                     then reduce_system_R p\n                           (drop (length qs div 2) qs, base_case_info_R)\n                     else let q1 = take (len div 2)\n                                    (drop (length qs div 2) qs);\n                              left = calculate_data_R p q1;\n                              q2 = drop (len div 2)\n                                    (drop (length qs div 2) qs);\n                              right = calculate_data_R p q2\n                          in Let (combine_systems_R p (q1, left)\n                                   (q2, right))\n                              (reduce_system_R p)))))\n      (get_matrix_R\n        (reduce_system_R p\n          (combine_systems_R p\n            (take (length qs div 2) qs,\n             let len = min (length qs) (length qs div 2)\n             in if len = 0\n                then case reduce_system_R p ([1], base_case_info_R) of\n                     (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                else if len \\<le> 1\n                     then reduce_system_R p\n                           (take (length qs div 2) qs, base_case_info_R)\n                     else let q1 = take (len div 2)\n                                    (take (length qs div 2) qs);\n                              left = calculate_data_R p q1;\n                              q2 = drop (len div 2)\n                                    (take (length qs div 2) qs);\n                              right = calculate_data_R p q2\n                          in Let (combine_systems_R p (q1, left)\n                                   (q2, right))\n                              (reduce_system_R p))\n            (drop (length qs div 2) qs,\n             let len = length qs - length qs div 2\n             in if length qs \\<le> length qs div 2\n                then case reduce_system_R p ([1], base_case_info_R) of\n                     (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                else if len \\<le> 1\n                     then reduce_system_R p\n                           (drop (length qs div 2) qs, base_case_info_R)\n                     else let q1 = take (len div 2)\n                                    (drop (length qs div 2) qs);\n                              left = calculate_data_R p q1;\n                              q2 = drop (len div 2)\n                                    (drop (length qs div 2) qs);\n                              right = calculate_data_R p q2\n                          in Let (combine_systems_R p (q1, left)\n                                   (q2, right))\n                              (reduce_system_R p)))));\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> satisfies_properties_R p qs\n                       (get_subsets_R\n                         (let len = length qs; q1 = take (len div 2) qs;\n                              q2 = drop (len div 2) qs\n                          in reduce_system_R p\n                              (combine_systems_R p\n                                (q1,\n                                 let lena = min len (len div 2)\n                                 in if len div 2 = 0\n                                    then case reduce_system_R p\n         ([1], base_case_info_R) of\n   (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                                    else if lena \\<le> 1\n   then reduce_system_R p (q1, base_case_info_R)\n   else let q1a = take (lena div 2) q1; left = calculate_data_R p q1a;\n            q2 = drop (lena div 2) q1; right = calculate_data_R p q2\n        in Let (combine_systems_R p (q1a, left) (q2, right))\n            (reduce_system_R p))\n                                (q2,\n                                 let lena = len - len div 2\n                                 in if len \\<le> len div 2\n                                    then case reduce_system_R p\n         ([1], base_case_info_R) of\n   (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                                    else if lena \\<le> 1\n   then reduce_system_R p (q2, base_case_info_R)\n   else let q1 = take (lena div 2) q2; left = calculate_data_R p q1;\n            q2 = drop (lena div 2) q2; right = calculate_data_R p q2\n        in Let (combine_systems_R p (q1, left) (q2, right))\n            (reduce_system_R p)))))\n                       (get_signs_R\n                         (let len = length qs; q1 = take (len div 2) qs;\n                              q2 = drop (len div 2) qs\n                          in reduce_system_R p\n                              (combine_systems_R p\n                                (q1,\n                                 let lena = min len (len div 2)\n                                 in if len div 2 = 0\n                                    then case reduce_system_R p\n         ([1], base_case_info_R) of\n   (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                                    else if lena \\<le> 1\n   then reduce_system_R p (q1, base_case_info_R)\n   else let q1a = take (lena div 2) q1; left = calculate_data_R p q1a;\n            q2 = drop (lena div 2) q1; right = calculate_data_R p q2\n        in Let (combine_systems_R p (q1a, left) (q2, right))\n            (reduce_system_R p))\n                                (q2,\n                                 let lena = len - len div 2\n                                 in if len \\<le> len div 2\n                                    then case reduce_system_R p\n         ([1], base_case_info_R) of\n   (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                                    else if lena \\<le> 1\n   then reduce_system_R p (q2, base_case_info_R)\n   else let q1 = take (lena div 2) q2; left = calculate_data_R p q1;\n            q2 = drop (lena div 2) q2; right = calculate_data_R p q2\n        in Let (combine_systems_R p (q1, left) (q2, right))\n            (reduce_system_R p)))))\n                       (get_matrix_R\n                         (let len = length qs; q1 = take (len div 2) qs;\n                              q2 = drop (len div 2) qs\n                          in reduce_system_R p\n                              (combine_systems_R p\n                                (q1,\n                                 let lena = min len (len div 2)\n                                 in if len div 2 = 0\n                                    then case reduce_system_R p\n         ([1], base_case_info_R) of\n   (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                                    else if lena \\<le> 1\n   then reduce_system_R p (q1, base_case_info_R)\n   else let q1a = take (lena div 2) q1; left = calculate_data_R p q1a;\n            q2 = drop (lena div 2) q1; right = calculate_data_R p q2\n        in Let (combine_systems_R p (q1a, left) (q2, right))\n            (reduce_system_R p))\n                                (q2,\n                                 let lena = len - len div 2\n                                 in if len \\<le> len div 2\n                                    then case reduce_system_R p\n         ([1], base_case_info_R) of\n   (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n                                    else if lena \\<le> 1\n   then reduce_system_R p (q2, base_case_info_R)\n   else let q1 = take (lena div 2) q2; left = calculate_data_R p q1;\n            q2 = drop (lena div 2) q2; right = calculate_data_R p q2\n        in Let (combine_systems_R p (q1, left) (q2, right))\n            (reduce_system_R p)))))", "by (smt (z3) div_le_dividend min.absorb2)"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n   (get_signs_R (calculate_data_R p qs))\n   (get_matrix_R (calculate_data_R p qs))\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           satisfies_properties_R p qsa\n            (get_subsets_R (calculate_data_R p qsa))\n            (get_signs_R (calculate_data_R p qsa))\n            (get_matrix_R (calculate_data_R p qsa))) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n        (get_signs_R (calculate_data_R p qs))\n        (get_matrix_R (calculate_data_R p qs))", "then"], ["proof (chain)\npicking this:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n   (get_signs_R (calculate_data_R p qs))\n   (get_matrix_R (calculate_data_R p qs))", "show ?case"], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n   (get_signs_R (calculate_data_R p qs))\n   (get_matrix_R (calculate_data_R p qs))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "using len1_h len_gt1"], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n   (get_signs_R (calculate_data_R p qs))\n   (get_matrix_R (calculate_data_R p qs))\n  length qs = 1 \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n   (get_signs_R (calculate_data_R p qs))\n   (get_matrix_R (calculate_data_R p qs))\n  1 < length qs \\<longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n   (get_signs_R (calculate_data_R p qs))\n   (get_matrix_R (calculate_data_R p qs))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n     (get_signs_R (calculate_data_R p qs))\n     (get_matrix_R (calculate_data_R p qs))", "by (metis One_nat_def Suc_lessI)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  satisfies_properties_R p qs (get_subsets_R (calculate_data_R p qs))\n   (get_signs_R (calculate_data_R p qs))\n   (get_matrix_R (calculate_data_R p qs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Some key results on consistent sign assignments\""], ["", "lemma find_consistent_signs_at_roots_len1_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes len1: \"length qs = 1\"\n  shows \"set (find_consistent_signs_at_roots_R p qs) = set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "let ?signs = \"[[1],[0],[-1]]::rat list list\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "let ?subsets = \"[([], []),([0], []),([], [0])]::(nat list*nat list) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "let ?mat = \"(mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]])\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "have mat_help: \"matrix_A_R ?signs ?subsets = (mat_of_rows_list 3 [[1,1,1], [0,1,0], [1,0,-1]])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n    mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]", "using mat_base_case_R"], ["proof (prove)\nusing this:\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]\n\ngoal (1 subgoal):\n 1. M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n    mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]", "by auto"], ["proof (state)\nthis:\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "have well_def_signs: \"well_def_signs (length qs) ?signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def_signs (length qs) [[1], [0], [- 1]]", "unfolding well_def_signs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>signs\\<in>set [[1], [0], [- 1]]. length signs = length qs", "using len1"], ["proof (prove)\nusing this:\n  length qs = 1\n\ngoal (1 subgoal):\n 1. \\<forall>signs\\<in>set [[1], [0], [- 1]]. length signs = length qs", "by auto"], ["proof (state)\nthis:\n  well_def_signs (length qs) [[1], [0], [- 1]]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "have distinct_signs: \"distinct ?signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [[1], [0], [- 1]]", "unfolding distinct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_list True (\\<lambda>x xs. (\\<and>) (x \\<notin> set xs))\n     [[1], [0], [- 1]]", "by auto"], ["proof (state)\nthis:\n  distinct [[1], [0], [- 1]]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "have ex_q: \"\\<exists>(q::real poly). qs = [q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. qs = [q]", "using len1"], ["proof (prove)\nusing this:\n  length qs = 1\n\ngoal (1 subgoal):\n 1. \\<exists>q. qs = [q]", "using length_Suc_conv[of qs 0]"], ["proof (prove)\nusing this:\n  length qs = 1\n  (length qs = Suc 0) = (\\<exists>y ys. qs = y # ys \\<and> length ys = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>q. qs = [q]", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. qs = [q]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>q. qs = [q]", "have all_info: \"set (characterize_consistent_signs_at_roots p qs) \\<subseteq> set(?signs)\""], ["proof (prove)\nusing this:\n  \\<exists>q. qs = [q]\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set [[1], [0], [- 1]]", "using assms base_case_sgas_R"], ["proof (prove)\nusing this:\n  \\<exists>q. qs = [q]\n  p \\<noteq> 0\n  length qs = 1\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  set (characterize_consistent_signs_at_roots ?p [?q])\n  \\<subseteq> {[1], [0], [- 1]}\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p qs)\n    \\<subseteq> set [[1], [0], [- 1]]", "by auto"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set [[1], [0], [- 1]]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "have match: \"satisfy_equation_R p qs ?subsets ?signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "using ex_q base_case_satisfy_equation_R nonzero"], ["proof (prove)\nusing this:\n  \\<exists>q. qs = [q]\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  satisfy_equation_R ?p [?q] [([], []), ([0], []), ([], [0])]\n   [[1], [0], [- 1]]\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n     [[1], [0], [- 1]]", "by auto"], ["proof (state)\nthis:\n  satisfy_equation_R p qs [([], []), ([0], []), ([], [0])] [[1], [0], [- 1]]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "have invertible_mat: \"invertible_mat (matrix_A_R ?signs ?subsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat\n     (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])", "using inverse_mat_base_case_R inverse_mat_base_case_2_R"], ["proof (prove)\nusing this:\n  inverts_mat\n   (mat_of_rows_list 3\n     [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n   (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n  inverts_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n   (mat_of_rows_list 3\n     [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])", "unfolding invertible_mat_def"], ["proof (prove)\nusing this:\n  inverts_mat\n   (mat_of_rows_list 3\n     [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n   (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n  inverts_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n   (mat_of_rows_list 3\n     [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n\ngoal (1 subgoal):\n 1. square_mat\n     (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]) \\<and>\n    (\\<exists>B.\n        inverts_mat\n         (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])\n         B \\<and>\n        inverts_mat B\n         (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]))", "using mat_base_case_R"], ["proof (prove)\nusing this:\n  inverts_mat\n   (mat_of_rows_list 3\n     [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n   (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n  inverts_mat (mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]])\n   (mat_of_rows_list 3\n     [[1 / 2, - 1 / 2, 1 / 2], [0, 1, 0], [1 / 2, - 1 / 2, - 1 / 2]])\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]\n\ngoal (1 subgoal):\n 1. square_mat\n     (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]) \\<and>\n    (\\<exists>B.\n        inverts_mat\n         (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])\n         B \\<and>\n        inverts_mat B\n         (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])]))", "by auto"], ["proof (state)\nthis:\n  invertible_mat\n   (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "have h: \"set (get_signs_R (reduce_system_R p (qs, ((matrix_A_R ?signs ?subsets), (?subsets, ?signs))))) = \n    set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (get_signs_R\n          (reduce_system_R p\n            (qs, M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])],\n             [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]]))) =\n    set (characterize_consistent_signs_at_roots p qs)", "using nonzero nonzero well_def_signs distinct_signs all_info match invertible_mat\n      reduce_system_sign_conditions_R[where p = \"p\", where qs = \"qs\", where signs = ?signs, where subsets = ?subsets]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p \\<noteq> 0\n  well_def_signs (length qs) [[1], [0], [- 1]]\n  distinct [[1], [0], [- 1]]\n  set (characterize_consistent_signs_at_roots p qs)\n  \\<subseteq> set [[1], [0], [- 1]]\n  satisfy_equation_R p qs [([], []), ([0], []), ([], [0])] [[1], [0], [- 1]]\n  invertible_mat\n   (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])\n  \\<lbrakk>p \\<noteq> 0; well_def_signs (length qs) [[1], [0], [- 1]];\n   distinct [[1], [0], [- 1]];\n   set (characterize_consistent_signs_at_roots p qs)\n   \\<subseteq> set [[1], [0], [- 1]];\n   satisfy_equation_R p qs [([], []), ([0], []), ([], [0])]\n    [[1], [0], [- 1]];\n   invertible_mat\n    (M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])])\\<rbrakk>\n  \\<Longrightarrow> set (get_signs_R\n                          (reduce_system_R p\n                            (qs,\n                             M_mat_R [[1], [0], [- 1]]\n                              [([], []), ([0], []), ([], [0])],\n                             [([], []), ([0], []), ([], [0])],\n                             [[1], [0], [- 1]]))) =\n                    set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (get_signs_R\n          (reduce_system_R p\n            (qs, M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])],\n             [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]]))) =\n    set (characterize_consistent_signs_at_roots p qs)", "by blast"], ["proof (state)\nthis:\n  set (get_signs_R\n        (reduce_system_R p\n          (qs, M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])],\n           [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]]))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  set (get_signs_R\n        (reduce_system_R p\n          (qs, M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])],\n           [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]]))) =\n  set (characterize_consistent_signs_at_roots p qs)", "have  \"set (snd (snd (reduce_system_R p (qs, (?mat, (?subsets, ?signs)))))) = \n    set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\nusing this:\n  set (get_signs_R\n        (reduce_system_R p\n          (qs, M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])],\n           [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]]))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (qs,\n                     mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]],\n                     [([], []), ([0], []), ([], [0])],\n                     [[1], [0], [- 1]])))) =\n    set (characterize_consistent_signs_at_roots p qs)", "unfolding get_signs_R_def"], ["proof (prove)\nusing this:\n  set (snd (snd (reduce_system_R p\n                  (qs,\n                   M_mat_R [[1], [0], [- 1]]\n                    [([], []), ([0], []), ([], [0])],\n                   [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]])))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (qs,\n                     mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]],\n                     [([], []), ([0], []), ([], [0])],\n                     [[1], [0], [- 1]])))) =\n    set (characterize_consistent_signs_at_roots p qs)", "using mat_help"], ["proof (prove)\nusing this:\n  set (snd (snd (reduce_system_R p\n                  (qs,\n                   M_mat_R [[1], [0], [- 1]]\n                    [([], []), ([0], []), ([], [0])],\n                   [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]])))) =\n  set (characterize_consistent_signs_at_roots p qs)\n  M_mat_R [[1], [0], [- 1]] [([], []), ([0], []), ([], [0])] =\n  mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]]\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (qs,\n                     mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]],\n                     [([], []), ([0], []), ([], [0])],\n                     [[1], [0], [- 1]])))) =\n    set (characterize_consistent_signs_at_roots p qs)", "by auto"], ["proof (state)\nthis:\n  set (snd (snd (reduce_system_R p\n                  (qs,\n                   mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]],\n                   [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]])))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  set (snd (snd (reduce_system_R p\n                  (qs,\n                   mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]],\n                   [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]])))) =\n  set (characterize_consistent_signs_at_roots p qs)", "have \"set (snd (snd (reduce_system_R p (qs, base_case_info_R)))) = set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\nusing this:\n  set (snd (snd (reduce_system_R p\n                  (qs,\n                   mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]],\n                   [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]])))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p (qs, base_case_info_R)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "unfolding base_case_info_R_def"], ["proof (prove)\nusing this:\n  set (snd (snd (reduce_system_R p\n                  (qs,\n                   mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]],\n                   [([], []), ([0], []), ([], [0])], [[1], [0], [- 1]])))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (qs,\n                     mat_of_rows_list 3 [[1, 1, 1], [0, 1, 0], [1, 0, - 1]],\n                     [([], []), ([0], []), ([], [0])],\n                     [[1], [0], [- 1]])))) =\n    set (characterize_consistent_signs_at_roots p qs)", "by auto"], ["proof (state)\nthis:\n  set (snd (snd (reduce_system_R p (qs, base_case_info_R)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  set (snd (snd (reduce_system_R p (qs, base_case_info_R)))) =\n  set (characterize_consistent_signs_at_roots p qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (snd (snd (reduce_system_R p (qs, base_case_info_R)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "using len1"], ["proof (prove)\nusing this:\n  set (snd (snd (reduce_system_R p (qs, base_case_info_R)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n  length qs = 1\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "by (simp add: find_consistent_signs_at_roots_thm_R)"], ["proof (state)\nthis:\n  set (find_consistent_signs_at_roots_R p qs) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smaller_sys_are_good_R:\n  fixes p:: \"real poly\"\n  fixes qs1 :: \"real poly list\"\n  fixes qs2 :: \"real poly list\"\n  fixes subsets :: \"(nat list*nat list) list\"\n  fixes signs :: \"rat list list\" \n  assumes nonzero: \"p \\<noteq> 0\"\n  assumes nontriv1: \"length qs1 > 0\"\n  assumes nontriv2: \"length qs2 > 0\"\n  assumes \"set(find_consistent_signs_at_roots_R p qs1) = set(characterize_consistent_signs_at_roots p qs1)\"\n  assumes \"set(find_consistent_signs_at_roots_R p qs2) = set(characterize_consistent_signs_at_roots p qs2)\"\n  shows \"set(snd(snd(reduce_system_R p (combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2)))))\n    = set(characterize_consistent_signs_at_roots p (qs1@qs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "let ?signs = \"(get_signs_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2))))) \""], ["proof (state)\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "let ?subsets = \"(get_subsets_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2))))) \""], ["proof (state)\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have h0: \"satisfies_properties_R p (qs1@qs2) ?subsets ?signs\n    (get_matrix_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "using calculate_data_satisfies_properties_R combining_sys_satisfies_properties_R"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n  \\<lbrakk>?p \\<noteq> 0; 0 < length ?qs1.0; 0 < length ?qs2.0;\n   satisfies_properties_R ?p ?qs1.0\n    (get_subsets_R (calculate_data_R ?p ?qs1.0))\n    (get_signs_R (calculate_data_R ?p ?qs1.0))\n    (get_matrix_R (calculate_data_R ?p ?qs1.0));\n   satisfies_properties_R ?p ?qs2.0\n    (get_subsets_R (calculate_data_R ?p ?qs2.0))\n    (get_signs_R (calculate_data_R ?p ?qs2.0))\n    (get_matrix_R (calculate_data_R ?p ?qs2.0))\\<rbrakk>\n  \\<Longrightarrow> satisfies_properties_R ?p (?qs1.0 @ ?qs2.0)\n                     (get_subsets_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n                     (get_signs_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n                     (get_matrix_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "using nontriv1 nontriv2 nonzero nonzero"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n  \\<lbrakk>?p \\<noteq> 0; 0 < length ?qs1.0; 0 < length ?qs2.0;\n   satisfies_properties_R ?p ?qs1.0\n    (get_subsets_R (calculate_data_R ?p ?qs1.0))\n    (get_signs_R (calculate_data_R ?p ?qs1.0))\n    (get_matrix_R (calculate_data_R ?p ?qs1.0));\n   satisfies_properties_R ?p ?qs2.0\n    (get_subsets_R (calculate_data_R ?p ?qs2.0))\n    (get_signs_R (calculate_data_R ?p ?qs2.0))\n    (get_matrix_R (calculate_data_R ?p ?qs2.0))\\<rbrakk>\n  \\<Longrightarrow> satisfies_properties_R ?p (?qs1.0 @ ?qs2.0)\n                     (get_subsets_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n                     (get_signs_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n                     (get_matrix_R\n                       (snd (combine_systems_R ?p\n                              (?qs1.0, calculate_data_R ?p ?qs1.0)\n                              (?qs2.0, calculate_data_R ?p ?qs2.0))))\n  0 < length qs1\n  0 < length qs2\n  p \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. satisfies_properties_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_matrix_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "by simp"], ["proof (state)\nthis:\n  satisfies_properties_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "then"], ["proof (chain)\npicking this:\n  satisfies_properties_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))", "have h1: \"set(characterize_consistent_signs_at_roots p (qs1@qs2)) \\<subseteq> set ?signs\""], ["proof (prove)\nusing this:\n  satisfies_properties_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (get_signs_R\n                      (snd (combine_systems_R p\n                             (qs1, calculate_data_R p qs1)\n                             (qs2, calculate_data_R p qs2))))", "unfolding satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  all_list_constr_R\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (length (qs1 @ qs2)) \\<and>\n  well_def_signs (length (qs1 @ qs2))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))) \\<and>\n  distinct\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))) \\<and>\n  satisfy_equation_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))) \\<and>\n  invertible_mat\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))) \\<and>\n  get_matrix_R\n   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n          (qs2, calculate_data_R p qs2))) =\n  M_mat_R\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))) \\<and>\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (get_signs_R\n                    (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                           (qs2, calculate_data_R p qs2))))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n    \\<subseteq> set (get_signs_R\n                      (snd (combine_systems_R p\n                             (qs1, calculate_data_R p qs1)\n                             (qs2, calculate_data_R p qs2))))", "by linarith"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (get_signs_R\n                    (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                           (qs2, calculate_data_R p qs2))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have h2: \"well_def_signs (length (qs1@qs2)) ?signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def_signs (length (qs1 @ qs2))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "using calculate_data_satisfies_properties_R"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n\ngoal (1 subgoal):\n 1. well_def_signs (length (qs1 @ qs2))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "using h0 satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n  satisfies_properties_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. well_def_signs (length (qs1 @ qs2))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "by blast"], ["proof (state)\nthis:\n  well_def_signs (length (qs1 @ qs2))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have h3: \"distinct ?signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "using calculate_data_satisfies_properties_R"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n\ngoal (1 subgoal):\n 1. distinct\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "using h0 satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n  satisfies_properties_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. distinct\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "by blast"], ["proof (state)\nthis:\n  distinct\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have h4: \"satisfy_equation_R p (qs1@qs2) ?subsets ?signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "using calculate_data_satisfies_properties_R"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "using h0 satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n  satisfies_properties_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. satisfy_equation_R p (qs1 @ qs2)\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))", "by blast"], ["proof (state)\nthis:\n  satisfy_equation_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have h5: \"invertible_mat (matrix_A_R ?signs ?subsets) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat\n     (M_mat_R\n       (get_signs_R\n         (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                (qs2, calculate_data_R p qs2))))\n       (get_subsets_R\n         (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                (qs2, calculate_data_R p qs2)))))", "using calculate_data_satisfies_properties_R"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (M_mat_R\n       (get_signs_R\n         (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                (qs2, calculate_data_R p qs2))))\n       (get_subsets_R\n         (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                (qs2, calculate_data_R p qs2)))))", "using h0 satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n  satisfies_properties_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_matrix_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. invertible_mat\n     (M_mat_R\n       (get_signs_R\n         (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                (qs2, calculate_data_R p qs2))))\n       (get_subsets_R\n         (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                (qs2, calculate_data_R p qs2)))))", "by auto"], ["proof (state)\nthis:\n  invertible_mat\n   (M_mat_R\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2)))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have h: \"set (take_indices ?signs \n            (find_nonzeros_from_input_vec (solve_for_lhs_R p (qs1@qs2) ?subsets  (matrix_A_R ?signs ?subsets))))\n        =  set(characterize_consistent_signs_at_roots p (qs1@qs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take_indices\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p (qs1 @ qs2)\n              (get_subsets_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2))))\n              (M_mat_R\n                (get_signs_R\n                  (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                         (qs2, calculate_data_R p qs2))))\n                (get_subsets_R\n                  (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                         (qs2, calculate_data_R p qs2)))))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "using h1 h2 h3 h4 h5 reduction_deletes_bad_sign_conds_R"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (get_signs_R\n                    (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                           (qs2, calculate_data_R p qs2))))\n  well_def_signs (length (qs1 @ qs2))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n  distinct\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n  satisfy_equation_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n  invertible_mat\n   (M_mat_R\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2)))))\n  \\<lbrakk>?p \\<noteq> 0; well_def_signs (length ?qs) ?signs;\n   distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> set (characterize_consistent_signs_at_roots ?p ?qs) =\n                    set (reduction_signs_R ?p ?qs ?signs ?subsets\n                          (M_mat_R ?signs ?subsets))\n\ngoal (1 subgoal):\n 1. set (take_indices\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p (qs1 @ qs2)\n              (get_subsets_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2))))\n              (M_mat_R\n                (get_signs_R\n                  (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                         (qs2, calculate_data_R p qs2))))\n                (get_subsets_R\n                  (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                         (qs2, calculate_data_R p qs2)))))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "using nonzero reduction_signs_R_def"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n  \\<subseteq> set (get_signs_R\n                    (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                           (qs2, calculate_data_R p qs2))))\n  well_def_signs (length (qs1 @ qs2))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n  distinct\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n  satisfy_equation_R p (qs1 @ qs2)\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n  invertible_mat\n   (M_mat_R\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2)))))\n  \\<lbrakk>?p \\<noteq> 0; well_def_signs (length ?qs) ?signs;\n   distinct ?signs;\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs;\n   satisfy_equation_R ?p ?qs ?subsets ?signs;\n   invertible_mat (M_mat_R ?signs ?subsets)\\<rbrakk>\n  \\<Longrightarrow> set (characterize_consistent_signs_at_roots ?p ?qs) =\n                    set (reduction_signs_R ?p ?qs ?signs ?subsets\n                          (M_mat_R ?signs ?subsets))\n  p \\<noteq> 0\n  reduction_signs_R ?p ?qs ?signs ?subsets ?matr =\n  take_indices ?signs\n   (find_nonzeros_from_input_vec (solve_for_lhs_R ?p ?qs ?subsets ?matr))\n\ngoal (1 subgoal):\n 1. set (take_indices\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p (qs1 @ qs2)\n              (get_subsets_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2))))\n              (M_mat_R\n                (get_signs_R\n                  (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                         (qs2, calculate_data_R p qs2))))\n                (get_subsets_R\n                  (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                         (qs2, calculate_data_R p qs2)))))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "by auto"], ["proof (state)\nthis:\n  set (take_indices\n        (get_signs_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p (qs1 @ qs2)\n            (get_subsets_R\n              (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                     (qs2, calculate_data_R p qs2))))\n            (M_mat_R\n              (get_signs_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2))))\n              (get_subsets_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2)))))))) =\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "then"], ["proof (chain)\npicking this:\n  set (take_indices\n        (get_signs_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p (qs1 @ qs2)\n            (get_subsets_R\n              (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                     (qs2, calculate_data_R p qs2))))\n            (M_mat_R\n              (get_signs_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2))))\n              (get_subsets_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2)))))))) =\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have h: \"set (characterize_consistent_signs_at_roots p (qs1@qs2)) =\n    set (reduction_signs_R p (qs1@qs2) ?signs ?subsets  (matrix_A_R ?signs ?subsets ))\""], ["proof (prove)\nusing this:\n  set (take_indices\n        (get_signs_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p (qs1 @ qs2)\n            (get_subsets_R\n              (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                     (qs2, calculate_data_R p qs2))))\n            (M_mat_R\n              (get_signs_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2))))\n              (get_subsets_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2)))))))) =\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2)) =\n    set (reduction_signs_R p (qs1 @ qs2)\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (get_subsets_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (M_mat_R\n            (get_signs_R\n              (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                     (qs2, calculate_data_R p qs2))))\n            (get_subsets_R\n              (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                     (qs2, calculate_data_R p qs2))))))", "unfolding reduction_signs_R_def get_signs_R_def"], ["proof (prove)\nusing this:\n  set (take_indices\n        (snd (snd (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                         (qs2, calculate_data_R p qs2)))))\n        (find_nonzeros_from_input_vec\n          (solve_for_lhs_R p (qs1 @ qs2)\n            (get_subsets_R\n              (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                     (qs2, calculate_data_R p qs2))))\n            (M_mat_R\n              (snd (snd (snd (combine_systems_R p\n                               (qs1, calculate_data_R p qs1)\n                               (qs2, calculate_data_R p qs2)))))\n              (get_subsets_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2)))))))) =\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p (qs1 @ qs2)) =\n    set (take_indices\n          (snd (snd (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                           (qs2, calculate_data_R p qs2)))))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p (qs1 @ qs2)\n              (get_subsets_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2))))\n              (M_mat_R\n                (snd (snd (snd (combine_systems_R p\n                                 (qs1, calculate_data_R p qs1)\n                                 (qs2, calculate_data_R p qs2)))))\n                (get_subsets_R\n                  (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                         (qs2, calculate_data_R p qs2))))))))", "by blast"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2)) =\n  set (reduction_signs_R p (qs1 @ qs2)\n        (get_signs_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (get_subsets_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (M_mat_R\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (get_subsets_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have help_h: \"reduction_signs_R p (qs1@qs2) ?signs ?subsets  (matrix_A_R ?signs ?subsets) \n      = (take_indices ?signs (find_nonzeros_from_input_vec (solve_for_lhs_R p (qs1@qs2) ?subsets  (matrix_A_R?signs ?subsets))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduction_signs_R p (qs1 @ qs2)\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (M_mat_R\n       (get_signs_R\n         (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                (qs2, calculate_data_R p qs2))))\n       (get_subsets_R\n         (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                (qs2, calculate_data_R p qs2))))) =\n    take_indices\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p (qs1 @ qs2)\n         (get_subsets_R\n           (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                  (qs2, calculate_data_R p qs2))))\n         (M_mat_R\n           (get_signs_R\n             (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2))))\n           (get_subsets_R\n             (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2)))))))", "unfolding reduction_signs_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_indices\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p (qs1 @ qs2)\n         (get_subsets_R\n           (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                  (qs2, calculate_data_R p qs2))))\n         (M_mat_R\n           (get_signs_R\n             (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2))))\n           (get_subsets_R\n             (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2))))))) =\n    take_indices\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (find_nonzeros_from_input_vec\n       (solve_for_lhs_R p (qs1 @ qs2)\n         (get_subsets_R\n           (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                  (qs2, calculate_data_R p qs2))))\n         (M_mat_R\n           (get_signs_R\n             (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2))))\n           (get_subsets_R\n             (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2)))))))", "by auto"], ["proof (state)\nthis:\n  reduction_signs_R p (qs1 @ qs2)\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (M_mat_R\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))) =\n  take_indices\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (find_nonzeros_from_input_vec\n     (solve_for_lhs_R p (qs1 @ qs2)\n       (get_subsets_R\n         (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                (qs2, calculate_data_R p qs2))))\n       (M_mat_R\n         (get_signs_R\n           (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                  (qs2, calculate_data_R p qs2))))\n         (get_subsets_R\n           (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                  (qs2, calculate_data_R p qs2)))))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have clear_signs: \"(signs_smash (get_signs_R (calculate_data_R p qs1)) (get_signs_R (calculate_data_R p qs2))) = (get_signs_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signs_smash (get_signs_R (calculate_data_R p qs1))\n     (get_signs_R (calculate_data_R p qs2)) =\n    get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))", "using combining_to_smash get_signs_R_def getter_functions_R smash_systems_R_def snd_conv"], ["proof (prove)\nusing this:\n  combine_systems ?p (?qs1.0, ?m1.0, ?sub1.0, ?sgn1.0)\n   (?qs2.0, ?m2.0, ?sub2.0, ?sgn2.0) =\n  smash_systems ?p ?qs1.0 ?qs2.0 ?sub1.0 ?sub2.0 ?sgn1.0 ?sgn2.0 ?m1.0 ?m2.0\n  get_signs_R ?data = snd (snd ?data)\n  calculate_data_R ?p ?qs =\n  (get_matrix_R (calculate_data_R ?p ?qs),\n   get_subsets_R (calculate_data_R ?p ?qs),\n   get_signs_R (calculate_data_R ?p ?qs))\n  smash_systems_R ?p ?qs1.0 ?qs2.0 ?subsets1.0 ?subsets2.0 ?signs1.0\n   ?signs2.0 ?mat1.0 ?mat2.0 =\n  (?qs1.0 @ ?qs2.0, kronecker_product ?mat1.0 ?mat2.0,\n   subsets_smash_R (length ?qs1.0) ?subsets1.0 ?subsets2.0,\n   signs_smash ?signs1.0 ?signs2.0)\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. signs_smash (get_signs_R (calculate_data_R p qs1))\n     (get_signs_R (calculate_data_R p qs2)) =\n    get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p qs1 m1 sub1 sgn1 qs2 m2 sub2 sgn2.\n                combine_systems p (qs1, m1, sub1, sgn1)\n                 (qs2, m2, sub2, sgn2) =\n                smash_systems p qs1 qs2 sub1 sub2 sgn1 sgn2 m1 m2;\n     \\<And>data. get_signs_R data = snd (snd data);\n     \\<And>p qs.\n        calculate_data_R p qs =\n        (get_matrix_R (calculate_data_R p qs),\n         get_subsets_R (calculate_data_R p qs),\n         get_signs_R (calculate_data_R p qs));\n     \\<And>p qs1 qs2 subsets1 subsets2 signs1 signs2 mat1 mat2.\n        smash_systems_R p qs1 qs2 subsets1 subsets2 signs1 signs2 mat1\n         mat2 =\n        (qs1 @ qs2, kronecker_product mat1 mat2,\n         subsets_smash_R (length qs1) subsets1 subsets2,\n         signs_smash signs1 signs2);\n     \\<And>x1 x2. snd (x1, x2) = x2\\<rbrakk>\n    \\<Longrightarrow> signs_smash (get_signs_R (calculate_data_R p qs1))\n                       (get_signs_R (calculate_data_R p qs2)) =\n                      get_signs_R\n                       (snd (combine_systems_R p\n                              (qs1, calculate_data_R p qs1)\n                              (qs2, calculate_data_R p qs2)))", "have \"combine_systems_R p (qs1, calculate_data_R p qs1) (qs2, calculate_data_R p qs2) = (qs1 @ qs2, kronecker_product (get_matrix_R (calculate_data_R p qs1)) (get_matrix_R (calculate_data_R p qs2)), subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1)) (get_subsets_R (calculate_data_R p qs2)), signs_smash (snd (snd (calculate_data_R p qs1))) (snd (snd (calculate_data_R p qs2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. combine_systems_R p (qs1, calculate_data_R p qs1)\n     (qs2, calculate_data_R p qs2) =\n    (qs1 @ qs2,\n     kronecker_product (get_matrix_R (calculate_data_R p qs1))\n      (get_matrix_R (calculate_data_R p qs2)),\n     subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n      (get_subsets_R (calculate_data_R p qs2)),\n     signs_smash (snd (snd (calculate_data_R p qs1)))\n      (snd (snd (calculate_data_R p qs2))))", "by (metis (no_types) combine_systems_R.simps get_signs_R_def getter_functions_R smash_systems_R_def)"], ["proof (state)\nthis:\n  combine_systems_R p (qs1, calculate_data_R p qs1)\n   (qs2, calculate_data_R p qs2) =\n  (qs1 @ qs2,\n   kronecker_product (get_matrix_R (calculate_data_R p qs1))\n    (get_matrix_R (calculate_data_R p qs2)),\n   subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n    (get_subsets_R (calculate_data_R p qs2)),\n   signs_smash (snd (snd (calculate_data_R p qs1)))\n    (snd (snd (calculate_data_R p qs2))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p qs1 m1 sub1 sgn1 qs2 m2 sub2 sgn2.\n                combine_systems p (qs1, m1, sub1, sgn1)\n                 (qs2, m2, sub2, sgn2) =\n                smash_systems p qs1 qs2 sub1 sub2 sgn1 sgn2 m1 m2;\n     \\<And>data. get_signs_R data = snd (snd data);\n     \\<And>p qs.\n        calculate_data_R p qs =\n        (get_matrix_R (calculate_data_R p qs),\n         get_subsets_R (calculate_data_R p qs),\n         get_signs_R (calculate_data_R p qs));\n     \\<And>p qs1 qs2 subsets1 subsets2 signs1 signs2 mat1 mat2.\n        smash_systems_R p qs1 qs2 subsets1 subsets2 signs1 signs2 mat1\n         mat2 =\n        (qs1 @ qs2, kronecker_product mat1 mat2,\n         subsets_smash_R (length qs1) subsets1 subsets2,\n         signs_smash signs1 signs2);\n     \\<And>x1 x2. snd (x1, x2) = x2\\<rbrakk>\n    \\<Longrightarrow> signs_smash (get_signs_R (calculate_data_R p qs1))\n                       (get_signs_R (calculate_data_R p qs2)) =\n                      get_signs_R\n                       (snd (combine_systems_R p\n                              (qs1, calculate_data_R p qs1)\n                              (qs2, calculate_data_R p qs2)))", "then"], ["proof (chain)\npicking this:\n  combine_systems_R p (qs1, calculate_data_R p qs1)\n   (qs2, calculate_data_R p qs2) =\n  (qs1 @ qs2,\n   kronecker_product (get_matrix_R (calculate_data_R p qs1))\n    (get_matrix_R (calculate_data_R p qs2)),\n   subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n    (get_subsets_R (calculate_data_R p qs2)),\n   signs_smash (snd (snd (calculate_data_R p qs1)))\n    (snd (snd (calculate_data_R p qs2))))", "show ?thesis"], ["proof (prove)\nusing this:\n  combine_systems_R p (qs1, calculate_data_R p qs1)\n   (qs2, calculate_data_R p qs2) =\n  (qs1 @ qs2,\n   kronecker_product (get_matrix_R (calculate_data_R p qs1))\n    (get_matrix_R (calculate_data_R p qs2)),\n   subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n    (get_subsets_R (calculate_data_R p qs2)),\n   signs_smash (snd (snd (calculate_data_R p qs1)))\n    (snd (snd (calculate_data_R p qs2))))\n\ngoal (1 subgoal):\n 1. signs_smash (get_signs_R (calculate_data_R p qs1))\n     (get_signs_R (calculate_data_R p qs2)) =\n    get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))", "by (simp add: get_signs_R_def)"], ["proof (state)\nthis:\n  signs_smash (get_signs_R (calculate_data_R p qs1))\n   (get_signs_R (calculate_data_R p qs2)) =\n  get_signs_R\n   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n          (qs2, calculate_data_R p qs2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  signs_smash (get_signs_R (calculate_data_R p qs1))\n   (get_signs_R (calculate_data_R p qs2)) =\n  get_signs_R\n   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n          (qs2, calculate_data_R p qs2)))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have clear_subsets: \"(subsets_smash_R (length qs1) (get_subsets_R(calculate_data_R p qs1)) (get_subsets_R (calculate_data_R p qs2))) = (get_subsets_R (snd ((combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n     (get_subsets_R (calculate_data_R p qs2)) =\n    get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))", "using Pair_inject combining_to_smash get_subsets_R_def prod.collapse smash_systems_R_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b) = (?a', ?b');\n   \\<lbrakk>?a = ?a'; ?b = ?b'\\<rbrakk> \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  combine_systems ?p (?qs1.0, ?m1.0, ?sub1.0, ?sgn1.0)\n   (?qs2.0, ?m2.0, ?sub2.0, ?sgn2.0) =\n  smash_systems ?p ?qs1.0 ?qs2.0 ?sub1.0 ?sub2.0 ?sgn1.0 ?sgn2.0 ?m1.0 ?m2.0\n  get_subsets_R ?data = fst (snd ?data)\n  (fst ?prod, snd ?prod) = ?prod\n  smash_systems_R ?p ?qs1.0 ?qs2.0 ?subsets1.0 ?subsets2.0 ?signs1.0\n   ?signs2.0 ?mat1.0 ?mat2.0 =\n  (?qs1.0 @ ?qs2.0, kronecker_product ?mat1.0 ?mat2.0,\n   subsets_smash_R (length ?qs1.0) ?subsets1.0 ?subsets2.0,\n   signs_smash ?signs1.0 ?signs2.0)\n\ngoal (1 subgoal):\n 1. subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n     (get_subsets_R (calculate_data_R p qs2)) =\n    get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))", "by (smt (z3) combine_systems_R.simps)"], ["proof (state)\nthis:\n  subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n   (get_subsets_R (calculate_data_R p qs2)) =\n  get_subsets_R\n   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n          (qs2, calculate_data_R p qs2)))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have \"well_def_signs (length qs1) (get_signs_R (calculate_data_R p qs1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def_signs (length qs1) (get_signs_R (calculate_data_R p qs1))", "using calculate_data_satisfies_properties_R"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n\ngoal (1 subgoal):\n 1. well_def_signs (length qs1) (get_signs_R (calculate_data_R p qs1))", "using nontriv1 nonzero nonzero satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n  0 < length qs1\n  p \\<noteq> 0\n  p \\<noteq> 0\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. well_def_signs (length qs1) (get_signs_R (calculate_data_R p qs1))", "by auto"], ["proof (state)\nthis:\n  well_def_signs (length qs1) (get_signs_R (calculate_data_R p qs1))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "then"], ["proof (chain)\npicking this:\n  well_def_signs (length qs1) (get_signs_R (calculate_data_R p qs1))", "have well_def_signs1: \"(\\<And>j. j \\<in> set (get_signs_R (calculate_data_R p qs1)) \\<Longrightarrow> length j = (length qs1))\""], ["proof (prove)\nusing this:\n  well_def_signs (length qs1) (get_signs_R (calculate_data_R p qs1))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (get_signs_R (calculate_data_R p qs1)) \\<Longrightarrow>\n       length j = length qs1", "using well_def_signs_def"], ["proof (prove)\nusing this:\n  well_def_signs (length qs1) (get_signs_R (calculate_data_R p qs1))\n  well_def_signs ?num_polys ?sign_conds \\<equiv>\n  \\<forall>signs\\<in>set ?sign_conds. length signs = ?num_polys\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> set (get_signs_R (calculate_data_R p qs1)) \\<Longrightarrow>\n       length j = length qs1", "by blast"], ["proof (state)\nthis:\n  ?j \\<in> set (get_signs_R (calculate_data_R p qs1)) \\<Longrightarrow>\n  length ?j = length qs1\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have \"all_list_constr_R (get_subsets_R(calculate_data_R p qs1))  (length qs1) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr_R (get_subsets_R (calculate_data_R p qs1)) (length qs1)", "using calculate_data_satisfies_properties_R"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n\ngoal (1 subgoal):\n 1. all_list_constr_R (get_subsets_R (calculate_data_R p qs1)) (length qs1)", "using nontriv1 nonzero nonzero satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n  0 < length qs1\n  p \\<noteq> 0\n  p \\<noteq> 0\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. all_list_constr_R (get_subsets_R (calculate_data_R p qs1)) (length qs1)", "by auto"], ["proof (state)\nthis:\n  all_list_constr_R (get_subsets_R (calculate_data_R p qs1)) (length qs1)\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "then"], ["proof (chain)\npicking this:\n  all_list_constr_R (get_subsets_R (calculate_data_R p qs1)) (length qs1)", "have well_def_subsets1: \"(\\<And>l i. l \\<in> set (get_subsets_R(calculate_data_R p qs1)) \\<Longrightarrow> (i \\<in> set (fst l) \\<longrightarrow> i < (length qs1)) \\<and> (i \\<in> set (snd l) \\<longrightarrow> i < (length qs1)))\""], ["proof (prove)\nusing this:\n  all_list_constr_R (get_subsets_R (calculate_data_R p qs1)) (length qs1)\n\ngoal (1 subgoal):\n 1. \\<And>l i.\n       l \\<in> set (get_subsets_R\n                     (calculate_data_R p qs1)) \\<Longrightarrow>\n       (i \\<in> set (fst l) \\<longrightarrow> i < length qs1) \\<and>\n       (i \\<in> set (snd l) \\<longrightarrow> i < length qs1)", "unfolding all_list_constr_R_def list_constr_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     List.member (get_subsets_R (calculate_data_R p qs1))\n      x \\<longrightarrow>\n     list_all (\\<lambda>x. x < length qs1) (fst x) \\<and>\n     list_all (\\<lambda>x. x < length qs1) (snd x)\n\ngoal (1 subgoal):\n 1. \\<And>l i.\n       l \\<in> set (get_subsets_R\n                     (calculate_data_R p qs1)) \\<Longrightarrow>\n       (i \\<in> set (fst l) \\<longrightarrow> i < length qs1) \\<and>\n       (i \\<in> set (snd l) \\<longrightarrow> i < length qs1)", "using in_set_member"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     List.member (get_subsets_R (calculate_data_R p qs1))\n      x \\<longrightarrow>\n     list_all (\\<lambda>x. x < length qs1) (fst x) \\<and>\n     list_all (\\<lambda>x. x < length qs1) (snd x)\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. \\<And>l i.\n       l \\<in> set (get_subsets_R\n                     (calculate_data_R p qs1)) \\<Longrightarrow>\n       (i \\<in> set (fst l) \\<longrightarrow> i < length qs1) \\<and>\n       (i \\<in> set (snd l) \\<longrightarrow> i < length qs1)", "by (metis in_set_conv_nth list_all_length)"], ["proof (state)\nthis:\n  ?l \\<in> set (get_subsets_R (calculate_data_R p qs1)) \\<Longrightarrow>\n  (?i \\<in> set (fst ?l) \\<longrightarrow> ?i < length qs1) \\<and>\n  (?i \\<in> set (snd ?l) \\<longrightarrow> ?i < length qs1)\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have extra_matrix_same: \"matrix_A_R (signs_smash (get_signs_R (calculate_data_R p qs1)) (get_signs_R (calculate_data_R p qs2)))\n         (subsets_smash_R (length qs1) (get_subsets_R(calculate_data_R p qs1)) (get_subsets_R (calculate_data_R p qs2))) \n        = kronecker_product (get_matrix_R (calculate_data_R p qs1)) (get_matrix_R (calculate_data_R p qs2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat_R\n     (signs_smash (get_signs_R (calculate_data_R p qs1))\n       (get_signs_R (calculate_data_R p qs2)))\n     (subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n       (get_subsets_R (calculate_data_R p qs2))) =\n    kronecker_product (get_matrix_R (calculate_data_R p qs1))\n     (get_matrix_R (calculate_data_R p qs2))", "using  well_def_signs1 well_def_subsets1"], ["proof (prove)\nusing this:\n  ?j \\<in> set (get_signs_R (calculate_data_R p qs1)) \\<Longrightarrow>\n  length ?j = length qs1\n  ?l \\<in> set (get_subsets_R (calculate_data_R p qs1)) \\<Longrightarrow>\n  (?i \\<in> set (fst ?l) \\<longrightarrow> ?i < length qs1) \\<and>\n  (?i \\<in> set (snd ?l) \\<longrightarrow> ?i < length qs1)\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (signs_smash (get_signs_R (calculate_data_R p qs1))\n       (get_signs_R (calculate_data_R p qs2)))\n     (subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n       (get_subsets_R (calculate_data_R p qs2))) =\n    kronecker_product (get_matrix_R (calculate_data_R p qs1))\n     (get_matrix_R (calculate_data_R p qs2))", "using matrix_construction_is_kronecker_product_R"], ["proof (prove)\nusing this:\n  ?j \\<in> set (get_signs_R (calculate_data_R p qs1)) \\<Longrightarrow>\n  length ?j = length qs1\n  ?l \\<in> set (get_subsets_R (calculate_data_R p qs1)) \\<Longrightarrow>\n  (?i \\<in> set (fst ?l) \\<longrightarrow> ?i < length qs1) \\<and>\n  (?i \\<in> set (snd ?l) \\<longrightarrow> ?i < length qs1)\n  \\<lbrakk>\\<And>l i.\n              \\<lbrakk>l \\<in> set ?subs1.0;\n               i \\<in> set (fst l) \\<or> i \\<in> set (snd l)\\<rbrakk>\n              \\<Longrightarrow> i < ?n1.0;\n   \\<And>j.\n      j \\<in> set ?signs1.0 \\<Longrightarrow> length j = ?n1.0\\<rbrakk>\n  \\<Longrightarrow> M_mat_R (signs_smash ?signs1.0 ?signs2.0)\n                     (subsets_smash_R ?n1.0 ?subs1.0 ?subs2.0) =\n                    kronecker_product (M_mat_R ?signs1.0 ?subs1.0)\n                     (M_mat_R ?signs2.0 ?subs2.0)\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (signs_smash (get_signs_R (calculate_data_R p qs1))\n       (get_signs_R (calculate_data_R p qs2)))\n     (subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n       (get_subsets_R (calculate_data_R p qs2))) =\n    kronecker_product (get_matrix_R (calculate_data_R p qs1))\n     (get_matrix_R (calculate_data_R p qs2))", "using calculate_data_satisfies_properties_R nontriv1 nontriv2 nonzero  nonzero satisfies_properties_R_def"], ["proof (prove)\nusing this:\n  ?j \\<in> set (get_signs_R (calculate_data_R p qs1)) \\<Longrightarrow>\n  length ?j = length qs1\n  ?l \\<in> set (get_subsets_R (calculate_data_R p qs1)) \\<Longrightarrow>\n  (?i \\<in> set (fst ?l) \\<longrightarrow> ?i < length qs1) \\<and>\n  (?i \\<in> set (snd ?l) \\<longrightarrow> ?i < length qs1)\n  \\<lbrakk>\\<And>l i.\n              \\<lbrakk>l \\<in> set ?subs1.0;\n               i \\<in> set (fst l) \\<or> i \\<in> set (snd l)\\<rbrakk>\n              \\<Longrightarrow> i < ?n1.0;\n   \\<And>j.\n      j \\<in> set ?signs1.0 \\<Longrightarrow> length j = ?n1.0\\<rbrakk>\n  \\<Longrightarrow> M_mat_R (signs_smash ?signs1.0 ?signs2.0)\n                     (subsets_smash_R ?n1.0 ?subs1.0 ?subs2.0) =\n                    kronecker_product (M_mat_R ?signs1.0 ?subs1.0)\n                     (M_mat_R ?signs2.0 ?subs2.0)\n  ?p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  satisfies_properties_R ?p ?qs (get_subsets_R (calculate_data_R ?p ?qs))\n   (get_signs_R (calculate_data_R ?p ?qs))\n   (get_matrix_R (calculate_data_R ?p ?qs))\n  0 < length qs1\n  0 < length qs2\n  p \\<noteq> 0\n  p \\<noteq> 0\n  satisfies_properties_R ?p ?qs ?subsets ?signs ?matrix =\n  (all_list_constr_R ?subsets (length ?qs) \\<and>\n   well_def_signs (length ?qs) ?signs \\<and>\n   distinct ?signs \\<and>\n   satisfy_equation_R ?p ?qs ?subsets ?signs \\<and>\n   invertible_mat ?matrix \\<and>\n   ?matrix = M_mat_R ?signs ?subsets \\<and>\n   set (characterize_consistent_signs_at_roots ?p ?qs)\n   \\<subseteq> set ?signs)\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (signs_smash (get_signs_R (calculate_data_R p qs1))\n       (get_signs_R (calculate_data_R p qs2)))\n     (subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n       (get_subsets_R (calculate_data_R p qs2))) =\n    kronecker_product (get_matrix_R (calculate_data_R p qs1))\n     (get_matrix_R (calculate_data_R p qs2))", "by fastforce"], ["proof (state)\nthis:\n  M_mat_R\n   (signs_smash (get_signs_R (calculate_data_R p qs1))\n     (get_signs_R (calculate_data_R p qs2)))\n   (subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n     (get_subsets_R (calculate_data_R p qs2))) =\n  kronecker_product (get_matrix_R (calculate_data_R p qs1))\n   (get_matrix_R (calculate_data_R p qs2))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "then"], ["proof (chain)\npicking this:\n  M_mat_R\n   (signs_smash (get_signs_R (calculate_data_R p qs1))\n     (get_signs_R (calculate_data_R p qs2)))\n   (subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n     (get_subsets_R (calculate_data_R p qs2))) =\n  kronecker_product (get_matrix_R (calculate_data_R p qs1))\n   (get_matrix_R (calculate_data_R p qs2))", "have matrix_same: \"matrix_A_R ?signs ?subsets = kronecker_product (get_matrix_R (calculate_data_R p qs1)) (get_matrix_R (calculate_data_R p qs2))\""], ["proof (prove)\nusing this:\n  M_mat_R\n   (signs_smash (get_signs_R (calculate_data_R p qs1))\n     (get_signs_R (calculate_data_R p qs2)))\n   (subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n     (get_subsets_R (calculate_data_R p qs2))) =\n  kronecker_product (get_matrix_R (calculate_data_R p qs1))\n   (get_matrix_R (calculate_data_R p qs2))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2)))) =\n    kronecker_product (get_matrix_R (calculate_data_R p qs1))\n     (get_matrix_R (calculate_data_R p qs2))", "using clear_signs clear_subsets"], ["proof (prove)\nusing this:\n  M_mat_R\n   (signs_smash (get_signs_R (calculate_data_R p qs1))\n     (get_signs_R (calculate_data_R p qs2)))\n   (subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n     (get_subsets_R (calculate_data_R p qs2))) =\n  kronecker_product (get_matrix_R (calculate_data_R p qs1))\n   (get_matrix_R (calculate_data_R p qs2))\n  signs_smash (get_signs_R (calculate_data_R p qs1))\n   (get_signs_R (calculate_data_R p qs2)) =\n  get_signs_R\n   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n          (qs2, calculate_data_R p qs2)))\n  subsets_smash_R (length qs1) (get_subsets_R (calculate_data_R p qs1))\n   (get_subsets_R (calculate_data_R p qs2)) =\n  get_subsets_R\n   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n          (qs2, calculate_data_R p qs2)))\n\ngoal (1 subgoal):\n 1. M_mat_R\n     (get_signs_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2))))\n     (get_subsets_R\n       (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n              (qs2, calculate_data_R p qs2)))) =\n    kronecker_product (get_matrix_R (calculate_data_R p qs1))\n     (get_matrix_R (calculate_data_R p qs2))", "by simp"], ["proof (state)\nthis:\n  M_mat_R\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))) =\n  kronecker_product (get_matrix_R (calculate_data_R p qs1))\n   (get_matrix_R (calculate_data_R p qs2))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "have comb_sys_h: \"snd(snd(reduce_system_R p (combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2)))) =\n      snd(snd(reduce_system_R p (qs1@qs2, (matrix_A_R ?signs ?subsets, (?subsets, ?signs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (reduce_system_R p\n               (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2)))) =\n    snd (snd (reduce_system_R p\n               (qs1 @ qs2,\n                M_mat_R\n                 (get_signs_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))\n                 (get_subsets_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2)))),\n                get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))),\n                get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))))", "unfolding get_signs_R_def get_subsets_R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (reduce_system_R p\n               (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2)))) =\n    snd (snd (reduce_system_R p\n               (qs1 @ qs2,\n                M_mat_R\n                 (snd (snd (snd (combine_systems_R p\n                                  (qs1, calculate_data_R p qs1)\n                                  (qs2, calculate_data_R p qs2)))))\n                 (fst (snd (snd (combine_systems_R p\n                                  (qs1, calculate_data_R p qs1)\n                                  (qs2, calculate_data_R p qs2))))),\n                fst (snd (snd (combine_systems_R p\n                                (qs1, calculate_data_R p qs1)\n                                (qs2, calculate_data_R p qs2)))),\n                snd (snd (snd (combine_systems_R p\n                                (qs1, calculate_data_R p qs1)\n                                (qs2, calculate_data_R p qs2)))))))", "using matrix_same"], ["proof (prove)\nusing this:\n  M_mat_R\n   (get_signs_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2))))\n   (get_subsets_R\n     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n            (qs2, calculate_data_R p qs2)))) =\n  kronecker_product (get_matrix_R (calculate_data_R p qs1))\n   (get_matrix_R (calculate_data_R p qs2))\n\ngoal (1 subgoal):\n 1. snd (snd (reduce_system_R p\n               (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2)))) =\n    snd (snd (reduce_system_R p\n               (qs1 @ qs2,\n                M_mat_R\n                 (snd (snd (snd (combine_systems_R p\n                                  (qs1, calculate_data_R p qs1)\n                                  (qs2, calculate_data_R p qs2)))))\n                 (fst (snd (snd (combine_systems_R p\n                                  (qs1, calculate_data_R p qs1)\n                                  (qs2, calculate_data_R p qs2))))),\n                fst (snd (snd (combine_systems_R p\n                                (qs1, calculate_data_R p qs1)\n                                (qs2, calculate_data_R p qs2)))),\n                snd (snd (snd (combine_systems_R p\n                                (qs1, calculate_data_R p qs1)\n                                (qs2, calculate_data_R p qs2)))))))", "by (metis (full_types) clear_signs clear_subsets combine_systems_R.simps get_signs_R_def get_subsets_R_def getter_functions_R smash_systems_R_def)"], ["proof (state)\nthis:\n  snd (snd (reduce_system_R p\n             (combine_systems_R p (qs1, calculate_data_R p qs1)\n               (qs2, calculate_data_R p qs2)))) =\n  snd (snd (reduce_system_R p\n             (qs1 @ qs2,\n              M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))),\n              get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))),\n              get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "then"], ["proof (chain)\npicking this:\n  snd (snd (reduce_system_R p\n             (combine_systems_R p (qs1, calculate_data_R p qs1)\n               (qs2, calculate_data_R p qs2)))) =\n  snd (snd (reduce_system_R p\n             (qs1 @ qs2,\n              M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))),\n              get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))),\n              get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))))", "have extra_h: \" snd(snd(reduce_system_R p (qs1@qs2, (matrix_A_R ?signs ?subsets, (?subsets, ?signs))))) = \n      snd(snd(reduction_step_R (matrix_A_R ?signs ?subsets) ?signs ?subsets (solve_for_lhs_R p (qs1@qs2) ?subsets (matrix_A_R ?signs ?subsets)))) \""], ["proof (prove)\nusing this:\n  snd (snd (reduce_system_R p\n             (combine_systems_R p (qs1, calculate_data_R p qs1)\n               (qs2, calculate_data_R p qs2)))) =\n  snd (snd (reduce_system_R p\n             (qs1 @ qs2,\n              M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))),\n              get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))),\n              get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))))\n\ngoal (1 subgoal):\n 1. snd (snd (reduce_system_R p\n               (qs1 @ qs2,\n                M_mat_R\n                 (get_signs_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))\n                 (get_subsets_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2)))),\n                get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))),\n                get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))))) =\n    snd (snd (reduction_step_R\n               (M_mat_R\n                 (get_signs_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))\n                 (get_subsets_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2)))))\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (solve_for_lhs_R p (qs1 @ qs2)\n                 (get_subsets_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))\n                 (M_mat_R\n                   (get_signs_R\n                     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                            (qs2, calculate_data_R p qs2))))\n                   (get_subsets_R\n                     (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                            (qs2, calculate_data_R p qs2))))))))", "by simp"], ["proof (state)\nthis:\n  snd (snd (reduce_system_R p\n             (qs1 @ qs2,\n              M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))),\n              get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))),\n              get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2)))))) =\n  snd (snd (reduction_step_R\n             (M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))))\n             (get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))\n             (get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))\n             (solve_for_lhs_R p (qs1 @ qs2)\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (M_mat_R\n                 (get_signs_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))\n                 (get_subsets_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "then"], ["proof (chain)\npicking this:\n  snd (snd (reduce_system_R p\n             (qs1 @ qs2,\n              M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))),\n              get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))),\n              get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2)))))) =\n  snd (snd (reduction_step_R\n             (M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))))\n             (get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))\n             (get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))\n             (solve_for_lhs_R p (qs1 @ qs2)\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (M_mat_R\n                 (get_signs_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))\n                 (get_subsets_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))))))", "have same_h: \"set(snd(snd(reduce_system_R p (combine_systems_R p (qs1,calculate_data_R p qs1) (qs2,calculate_data_R p qs2))))) \n      = set (reduction_signs_R p (qs1@qs2) ?signs ?subsets  (matrix_A_R ?signs ?subsets ))\""], ["proof (prove)\nusing this:\n  snd (snd (reduce_system_R p\n             (qs1 @ qs2,\n              M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))),\n              get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))),\n              get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2)))))) =\n  snd (snd (reduction_step_R\n             (M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))))\n             (get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))\n             (get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))\n             (solve_for_lhs_R p (qs1 @ qs2)\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (M_mat_R\n                 (get_signs_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))\n                 (get_subsets_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (reduction_signs_R p (qs1 @ qs2)\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (get_subsets_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (M_mat_R\n            (get_signs_R\n              (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                     (qs2, calculate_data_R p qs2))))\n            (get_subsets_R\n              (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                     (qs2, calculate_data_R p qs2))))))", "using comb_sys_h"], ["proof (prove)\nusing this:\n  snd (snd (reduce_system_R p\n             (qs1 @ qs2,\n              M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))),\n              get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))),\n              get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2)))))) =\n  snd (snd (reduction_step_R\n             (M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))))\n             (get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))\n             (get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))\n             (solve_for_lhs_R p (qs1 @ qs2)\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (M_mat_R\n                 (get_signs_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))\n                 (get_subsets_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))))))\n  snd (snd (reduce_system_R p\n             (combine_systems_R p (qs1, calculate_data_R p qs1)\n               (qs2, calculate_data_R p qs2)))) =\n  snd (snd (reduce_system_R p\n             (qs1 @ qs2,\n              M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))),\n              get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))),\n              get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (reduction_signs_R p (qs1 @ qs2)\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (get_subsets_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (M_mat_R\n            (get_signs_R\n              (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                     (qs2, calculate_data_R p qs2))))\n            (get_subsets_R\n              (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                     (qs2, calculate_data_R p qs2))))))", "unfolding reduction_signs_R_def"], ["proof (prove)\nusing this:\n  snd (snd (reduce_system_R p\n             (qs1 @ qs2,\n              M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))),\n              get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))),\n              get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2)))))) =\n  snd (snd (reduction_step_R\n             (M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))))\n             (get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))\n             (get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))\n             (solve_for_lhs_R p (qs1 @ qs2)\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (M_mat_R\n                 (get_signs_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))\n                 (get_subsets_R\n                   (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                          (qs2, calculate_data_R p qs2))))))))\n  snd (snd (reduce_system_R p\n             (combine_systems_R p (qs1, calculate_data_R p qs1)\n               (qs2, calculate_data_R p qs2)))) =\n  snd (snd (reduce_system_R p\n             (qs1 @ qs2,\n              M_mat_R\n               (get_signs_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2))))\n               (get_subsets_R\n                 (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                        (qs2, calculate_data_R p qs2)))),\n              get_subsets_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))),\n              get_signs_R\n               (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (take_indices\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (find_nonzeros_from_input_vec\n            (solve_for_lhs_R p (qs1 @ qs2)\n              (get_subsets_R\n                (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                       (qs2, calculate_data_R p qs2))))\n              (M_mat_R\n                (get_signs_R\n                  (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                         (qs2, calculate_data_R p qs2))))\n                (get_subsets_R\n                  (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                         (qs2, calculate_data_R p qs2))))))))", "by (metis get_signs_R_def help_h reduction_signs_is_get_signs_R)"], ["proof (state)\nthis:\n  set (snd (snd (reduce_system_R p\n                  (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2))))) =\n  set (reduction_signs_R p (qs1 @ qs2)\n        (get_signs_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (get_subsets_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (M_mat_R\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (get_subsets_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "then"], ["proof (chain)\npicking this:\n  set (snd (snd (reduce_system_R p\n                  (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2))))) =\n  set (reduction_signs_R p (qs1 @ qs2)\n        (get_signs_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (get_subsets_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (M_mat_R\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (get_subsets_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (snd (snd (reduce_system_R p\n                  (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2))))) =\n  set (reduction_signs_R p (qs1 @ qs2)\n        (get_signs_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (get_subsets_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (M_mat_R\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (get_subsets_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "using h"], ["proof (prove)\nusing this:\n  set (snd (snd (reduce_system_R p\n                  (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2))))) =\n  set (reduction_signs_R p (qs1 @ qs2)\n        (get_signs_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (get_subsets_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (M_mat_R\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (get_subsets_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))))\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2)) =\n  set (reduction_signs_R p (qs1 @ qs2)\n        (get_signs_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (get_subsets_R\n          (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                 (qs2, calculate_data_R p qs2))))\n        (M_mat_R\n          (get_signs_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))\n          (get_subsets_R\n            (snd (combine_systems_R p (qs1, calculate_data_R p qs1)\n                   (qs2, calculate_data_R p qs2))))))\n\ngoal (1 subgoal):\n 1. set (snd (snd (reduce_system_R p\n                    (combine_systems_R p (qs1, calculate_data_R p qs1)\n                      (qs2, calculate_data_R p qs2))))) =\n    set (characterize_consistent_signs_at_roots p (qs1 @ qs2))", "by blast"], ["proof (state)\nthis:\n  set (snd (snd (reduce_system_R p\n                  (combine_systems_R p (qs1, calculate_data_R p qs1)\n                    (qs2, calculate_data_R p qs2))))) =\n  set (characterize_consistent_signs_at_roots p (qs1 @ qs2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_consistent_signs_at_roots_1_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  shows \"(p \\<noteq> 0 \\<and> length qs > 0) \\<longrightarrow> \n    set(find_consistent_signs_at_roots_R p qs) = set(characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "proof (induction \"length qs\" arbitrary: qs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           set (find_consistent_signs_at_roots_R p qsa) =\n           set (characterize_consistent_signs_at_roots p\n                 qsa)) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       set (find_consistent_signs_at_roots_R p qs) =\n       set (characterize_consistent_signs_at_roots p qs)", "case less"], ["proof (state)\nthis:\n  length ?qs < length qs \\<Longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  set (find_consistent_signs_at_roots_R p ?qs) =\n  set (characterize_consistent_signs_at_roots p ?qs)\n\ngoal (1 subgoal):\n 1. \\<And>qs.\n       (\\<And>qsa.\n           length qsa < length qs \\<Longrightarrow>\n           p \\<noteq> 0 \\<and> 0 < length qsa \\<longrightarrow>\n           set (find_consistent_signs_at_roots_R p qsa) =\n           set (characterize_consistent_signs_at_roots p\n                 qsa)) \\<Longrightarrow>\n       p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n       set (find_consistent_signs_at_roots_R p qs) =\n       set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  length ?qs < length qs \\<Longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  set (find_consistent_signs_at_roots_R p ?qs) =\n  set (characterize_consistent_signs_at_roots p ?qs)", "show ?case"], ["proof (prove)\nusing this:\n  length ?qs < length qs \\<Longrightarrow>\n  p \\<noteq> 0 \\<and> 0 < length ?qs \\<longrightarrow>\n  set (find_consistent_signs_at_roots_R p ?qs) =\n  set (characterize_consistent_signs_at_roots p ?qs)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n    set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "assume ind_hyp: \"(\\<And>qsa.\n        length qsa < length qs \\<Longrightarrow> qsa \\<noteq> [] \\<longrightarrow>\n        set (find_consistent_signs_at_roots_R p qsa) =\n        set (characterize_consistent_signs_at_roots p qsa))\""], ["proof (state)\nthis:\n  length ?qsa < length qs \\<Longrightarrow>\n  ?qsa \\<noteq> [] \\<longrightarrow>\n  set (find_consistent_signs_at_roots_R p ?qsa) =\n  set (characterize_consistent_signs_at_roots p ?qsa)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "assume nonzero: \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "assume nontriv: \"qs \\<noteq> []\""], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "let ?len = \"length qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "let ?q1 = \"take ((?len) div 2) qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "let ?left = \"calculate_data_R p ?q1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "let ?q2 = \"drop ((?len) div 2) qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "let ?right = \"calculate_data_R p ?q2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "have nontriv_q1: \"length qs>1 \\<longrightarrow> length ?q1 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow> 0 < length (take (length qs div 2) qs)", "by auto"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow> 0 < length (take (length qs div 2) qs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "have qs_more_q1: \"length qs>1 \\<longrightarrow> length qs > length ?q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    length (take (length qs div 2) qs) < length qs", "by auto"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  length (take (length qs div 2) qs) < length qs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "have nontriv_q2: \"length qs>1 \\<longrightarrow>length ?q2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow> 0 < length (drop (length qs div 2) qs)", "by auto"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow> 0 < length (drop (length qs div 2) qs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "have qs_more_q2: \"length qs>1 \\<longrightarrow> length qs > length ?q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    length (drop (length qs div 2) qs) < length qs", "by auto"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  length (drop (length qs div 2) qs) < length qs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "have key_h: \"set (snd (snd (if ?len \\<le> Suc 0 then reduce_system_R p (qs, base_case_info_R)\n                        else   Let (combine_systems_R p (?q1, ?left) (?q2, ?right))\n                                  (reduce_system_R p)))) =\n       set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "have h_len1 : \"?len = 1 \\<longrightarrow> set (snd (snd (if ?len \\<le> Suc 0 then reduce_system_R p (qs, base_case_info_R)\n                        else   Let (combine_systems_R p (?q1, ?left) (?q2, ?right))\n                                  (reduce_system_R p)))) =\n       set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = 1 \\<longrightarrow>\n    set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "using find_consistent_signs_at_roots_len1_R[of p qs] nonzero nontriv"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; length qs = 1\\<rbrakk>\n  \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                    set (characterize_consistent_signs_at_roots p qs)\n  p \\<noteq> 0\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. length qs = 1 \\<longrightarrow>\n    set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "by (simp add: find_consistent_signs_at_roots_thm_R)"], ["proof (state)\nthis:\n  length qs = 1 \\<longrightarrow>\n  set (snd (snd (if length qs \\<le> Suc 0\n                 then reduce_system_R p (qs, base_case_info_R)\n                 else Let (combine_systems_R p\n                            (take (length qs div 2) qs,\n                             calculate_data_R p (take (length qs div 2) qs))\n                            (drop (length qs div 2) qs,\n                             calculate_data_R p\n                              (drop (length qs div 2) qs)))\n                       (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "have h_len_gt1 : \"?len > 1 \\<longrightarrow> set (snd (snd (if ?len \\<le> Suc 0 then reduce_system_R p (qs, base_case_info_R)\n                        else   Let (combine_systems_R p (?q1, ?left) (?q2, ?right))\n                                  (reduce_system_R p)))) =\n       set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "have h_imp_a: \"?len > 1 \\<longrightarrow> set (snd (snd (reduce_system_R p (combine_systems_R p (?q1, ?left) (?q2, ?right))))) =\n              set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (reduce_system_R p\n                    (combine_systems_R p\n                      (take (length qs div 2) qs,\n                       calculate_data_R p (take (length qs div 2) qs))\n                      (drop (length qs div 2) qs,\n                       calculate_data_R p (drop (length qs div 2) qs)))))) =\n    set (characterize_consistent_signs_at_roots p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (reduce_system_R p\n                    (combine_systems_R p\n                      (take (length qs div 2) qs,\n                       calculate_data_R p (take (length qs div 2) qs))\n                      (drop (length qs div 2) qs,\n                       calculate_data_R p (drop (length qs div 2) qs)))))) =\n    set (characterize_consistent_signs_at_roots p qs)", "have h1: \"?len > 1 \\<longrightarrow> set(snd(snd(?left))) = set (characterize_consistent_signs_at_roots p ?q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (calculate_data_R p (take (length qs div 2) qs)))) =\n    set (characterize_consistent_signs_at_roots p\n          (take (length qs div 2) qs))", "using nontriv_q1 ind_hyp[of ?q1] qs_more_q1"], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow> 0 < length (take (length qs div 2) qs)\n  length (take (length qs div 2) qs) < length qs \\<Longrightarrow>\n  take (length qs div 2) qs \\<noteq> [] \\<longrightarrow>\n  set (find_consistent_signs_at_roots_R p (take (length qs div 2) qs)) =\n  set (characterize_consistent_signs_at_roots p (take (length qs div 2) qs))\n  1 < length qs \\<longrightarrow>\n  length (take (length qs div 2) qs) < length qs\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (calculate_data_R p (take (length qs div 2) qs)))) =\n    set (characterize_consistent_signs_at_roots p\n          (take (length qs div 2) qs))", "by (metis find_consistent_signs_at_roots_thm_R less_numeral_extra(3) list.size(3))"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (calculate_data_R p (take (length qs div 2) qs)))) =\n  set (characterize_consistent_signs_at_roots p (take (length qs div 2) qs))\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (reduce_system_R p\n                    (combine_systems_R p\n                      (take (length qs div 2) qs,\n                       calculate_data_R p (take (length qs div 2) qs))\n                      (drop (length qs div 2) qs,\n                       calculate_data_R p (drop (length qs div 2) qs)))))) =\n    set (characterize_consistent_signs_at_roots p qs)", "have h2: \"?len > 1 \\<longrightarrow> set(snd(snd(?right))) = set (characterize_consistent_signs_at_roots p ?q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (calculate_data_R p (drop (length qs div 2) qs)))) =\n    set (characterize_consistent_signs_at_roots p\n          (drop (length qs div 2) qs))", "using nontriv_q2 ind_hyp[of ?q2] qs_more_q2"], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow> 0 < length (drop (length qs div 2) qs)\n  length (drop (length qs div 2) qs) < length qs \\<Longrightarrow>\n  drop (length qs div 2) qs \\<noteq> [] \\<longrightarrow>\n  set (find_consistent_signs_at_roots_R p (drop (length qs div 2) qs)) =\n  set (characterize_consistent_signs_at_roots p (drop (length qs div 2) qs))\n  1 < length qs \\<longrightarrow>\n  length (drop (length qs div 2) qs) < length qs\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (calculate_data_R p (drop (length qs div 2) qs)))) =\n    set (characterize_consistent_signs_at_roots p\n          (drop (length qs div 2) qs))", "by (metis (full_types) find_consistent_signs_at_roots_thm_R list.size(3) not_less_zero)"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (calculate_data_R p (drop (length qs div 2) qs)))) =\n  set (characterize_consistent_signs_at_roots p (drop (length qs div 2) qs))\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (reduce_system_R p\n                    (combine_systems_R p\n                      (take (length qs div 2) qs,\n                       calculate_data_R p (take (length qs div 2) qs))\n                      (drop (length qs div 2) qs,\n                       calculate_data_R p (drop (length qs div 2) qs)))))) =\n    set (characterize_consistent_signs_at_roots p qs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (reduce_system_R p\n                    (combine_systems_R p\n                      (take (length qs div 2) qs,\n                       calculate_data_R p (take (length qs div 2) qs))\n                      (drop (length qs div 2) qs,\n                       calculate_data_R p (drop (length qs div 2) qs)))))) =\n    set (characterize_consistent_signs_at_roots p qs)", "using nonzero nontriv_q1 nontriv_q2 h1 h2 smaller_sys_are_good_R"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  1 < length qs \\<longrightarrow> 0 < length (take (length qs div 2) qs)\n  1 < length qs \\<longrightarrow> 0 < length (drop (length qs div 2) qs)\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (calculate_data_R p (take (length qs div 2) qs)))) =\n  set (characterize_consistent_signs_at_roots p (take (length qs div 2) qs))\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (calculate_data_R p (drop (length qs div 2) qs)))) =\n  set (characterize_consistent_signs_at_roots p (drop (length qs div 2) qs))\n  \\<lbrakk>?p \\<noteq> 0; 0 < length ?qs1.0; 0 < length ?qs2.0;\n   set (find_consistent_signs_at_roots_R ?p ?qs1.0) =\n   set (characterize_consistent_signs_at_roots ?p ?qs1.0);\n   set (find_consistent_signs_at_roots_R ?p ?qs2.0) =\n   set (characterize_consistent_signs_at_roots ?p ?qs2.0)\\<rbrakk>\n  \\<Longrightarrow> set (snd (snd (reduce_system_R ?p\n                                    (combine_systems_R ?p\n(?qs1.0, calculate_data_R ?p ?qs1.0)\n(?qs2.0, calculate_data_R ?p ?qs2.0))))) =\n                    set (characterize_consistent_signs_at_roots ?p\n                          (?qs1.0 @ ?qs2.0))\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (reduce_system_R p\n                    (combine_systems_R p\n                      (take (length qs div 2) qs,\n                       calculate_data_R p (take (length qs div 2) qs))\n                      (drop (length qs div 2) qs,\n                       calculate_data_R p (drop (length qs div 2) qs)))))) =\n    set (characterize_consistent_signs_at_roots p qs)", "by (metis append_take_drop_id find_consistent_signs_at_roots_thm_R)"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (reduce_system_R p\n                  (combine_systems_R p\n                    (take (length qs div 2) qs,\n                     calculate_data_R p (take (length qs div 2) qs))\n                    (drop (length qs div 2) qs,\n                     calculate_data_R p (drop (length qs div 2) qs)))))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (reduce_system_R p\n                  (combine_systems_R p\n                    (take (length qs div 2) qs,\n                     calculate_data_R p (take (length qs div 2) qs))\n                    (drop (length qs div 2) qs,\n                     calculate_data_R p (drop (length qs div 2) qs)))))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (reduce_system_R p\n                  (combine_systems_R p\n                    (take (length qs div 2) qs,\n                     calculate_data_R p (take (length qs div 2) qs))\n                    (drop (length qs div 2) qs,\n                     calculate_data_R p (drop (length qs div 2) qs)))))) =\n  set (characterize_consistent_signs_at_roots p qs)", "have h_imp: \"?len > 1 \\<longrightarrow> set (snd (snd (Let (combine_systems_R p (?q1, ?left) (?q2, ?right))\n                                  (reduce_system_R p)))) =\n       set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (reduce_system_R p\n                  (combine_systems_R p\n                    (take (length qs div 2) qs,\n                     calculate_data_R p (take (length qs div 2) qs))\n                    (drop (length qs div 2) qs,\n                     calculate_data_R p (drop (length qs div 2) qs)))))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (Let (combine_systems_R p\n                         (take (length qs div 2) qs,\n                          calculate_data_R p (take (length qs div 2) qs))\n                         (drop (length qs div 2) qs,\n                          calculate_data_R p (drop (length qs div 2) qs)))\n                    (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "by auto"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (Let (combine_systems_R p\n                       (take (length qs div 2) qs,\n                        calculate_data_R p (take (length qs div 2) qs))\n                       (drop (length qs div 2) qs,\n                        calculate_data_R p (drop (length qs div 2) qs)))\n                  (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (Let (combine_systems_R p\n                       (take (length qs div 2) qs,\n                        calculate_data_R p (take (length qs div 2) qs))\n                       (drop (length qs div 2) qs,\n                        calculate_data_R p (drop (length qs div 2) qs)))\n                  (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (Let (combine_systems_R p\n                       (take (length qs div 2) qs,\n                        calculate_data_R p (take (length qs div 2) qs))\n                       (drop (length qs div 2) qs,\n                        calculate_data_R p (drop (length qs div 2) qs)))\n                  (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. 1 < length qs \\<longrightarrow>\n    set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "by auto"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (if length qs \\<le> Suc 0\n                 then reduce_system_R p (qs, base_case_info_R)\n                 else Let (combine_systems_R p\n                            (take (length qs div 2) qs,\n                             calculate_data_R p (take (length qs div 2) qs))\n                            (drop (length qs div 2) qs,\n                             calculate_data_R p\n                              (drop (length qs div 2) qs)))\n                       (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (if length qs \\<le> Suc 0\n                 then reduce_system_R p (qs, base_case_info_R)\n                 else Let (combine_systems_R p\n                            (take (length qs div 2) qs,\n                             calculate_data_R p (take (length qs div 2) qs))\n                            (drop (length qs div 2) qs,\n                             calculate_data_R p\n                              (drop (length qs div 2) qs)))\n                       (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "using h_len1 h_len_gt1"], ["proof (prove)\nusing this:\n  length qs = 1 \\<longrightarrow>\n  set (snd (snd (if length qs \\<le> Suc 0\n                 then reduce_system_R p (qs, base_case_info_R)\n                 else Let (combine_systems_R p\n                            (take (length qs div 2) qs,\n                             calculate_data_R p (take (length qs div 2) qs))\n                            (drop (length qs div 2) qs,\n                             calculate_data_R p\n                              (drop (length qs div 2) qs)))\n                       (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n  1 < length qs \\<longrightarrow>\n  set (snd (snd (if length qs \\<le> Suc 0\n                 then reduce_system_R p (qs, base_case_info_R)\n                 else Let (combine_systems_R p\n                            (take (length qs div 2) qs,\n                             calculate_data_R p (take (length qs div 2) qs))\n                            (drop (length qs div 2) qs,\n                             calculate_data_R p\n                              (drop (length qs div 2) qs)))\n                       (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (snd (snd (if length qs \\<le> Suc 0\n                   then reduce_system_R p (qs, base_case_info_R)\n                   else Let (combine_systems_R p\n                              (take (length qs div 2) qs,\n                               calculate_data_R p\n                                (take (length qs div 2) qs))\n                              (drop (length qs div 2) qs,\n                               calculate_data_R p\n                                (drop (length qs div 2) qs)))\n                         (reduce_system_R p)))) =\n    set (characterize_consistent_signs_at_roots p qs)", "by (meson \\<open>qs \\<noteq> []\\<close> length_0_conv less_one nat_neq_iff)"], ["proof (state)\nthis:\n  set (snd (snd (if length qs \\<le> Suc 0\n                 then reduce_system_R p (qs, base_case_info_R)\n                 else Let (combine_systems_R p\n                            (take (length qs div 2) qs,\n                             calculate_data_R p (take (length qs div 2) qs))\n                            (drop (length qs div 2) qs,\n                             calculate_data_R p\n                              (drop (length qs div 2) qs)))\n                       (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (snd (snd (if length qs \\<le> Suc 0\n                 then reduce_system_R p (qs, base_case_info_R)\n                 else Let (combine_systems_R p\n                            (take (length qs div 2) qs,\n                             calculate_data_R p (take (length qs div 2) qs))\n                            (drop (length qs div 2) qs,\n                             calculate_data_R p\n                              (drop (length qs div 2) qs)))\n                       (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qs.\n                length qs < length qs \\<Longrightarrow>\n                qs \\<noteq> [] \\<longrightarrow>\n                set (find_consistent_signs_at_roots_R p qs) =\n                set (characterize_consistent_signs_at_roots p qs);\n     p \\<noteq> 0; qs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> set (find_consistent_signs_at_roots_R p qs) =\n                      set (characterize_consistent_signs_at_roots p qs)", "then"], ["proof (chain)\npicking this:\n  set (snd (snd (if length qs \\<le> Suc 0\n                 then reduce_system_R p (qs, base_case_info_R)\n                 else Let (combine_systems_R p\n                            (take (length qs div 2) qs,\n                             calculate_data_R p (take (length qs div 2) qs))\n                            (drop (length qs div 2) qs,\n                             calculate_data_R p\n                              (drop (length qs div 2) qs)))\n                       (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)", "show \"set (find_consistent_signs_at_roots_R p qs) = set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\nusing this:\n  set (snd (snd (if length qs \\<le> Suc 0\n                 then reduce_system_R p (qs, base_case_info_R)\n                 else Let (combine_systems_R p\n                            (take (length qs div 2) qs,\n                             calculate_data_R p (take (length qs div 2) qs))\n                            (drop (length qs div 2) qs,\n                             calculate_data_R p\n                              (drop (length qs div 2) qs)))\n                       (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "using One_nat_def calculate_data.simps find_consistent_signs_at_roots_thm length_0_conv nontriv"], ["proof (prove)\nusing this:\n  set (snd (snd (if length qs \\<le> Suc 0\n                 then reduce_system_R p (qs, base_case_info_R)\n                 else Let (combine_systems_R p\n                            (take (length qs div 2) qs,\n                             calculate_data_R p (take (length qs div 2) qs))\n                            (drop (length qs div 2) qs,\n                             calculate_data_R p\n                              (drop (length qs div 2) qs)))\n                       (reduce_system_R p)))) =\n  set (characterize_consistent_signs_at_roots p qs)\n  1 = Suc 0\n  calculate_data ?p ?qs =\n  (let len = length ?qs\n   in if len = 0\n      then case reduce_system ?p ([1], base_case_info) of\n           (a, b, c) \\<Rightarrow> (a, b, map (drop 1) c)\n      else if len \\<le> 1 then reduce_system ?p (?qs, base_case_info)\n           else let q1 = take (len div 2) ?qs; left = calculate_data ?p q1;\n                    q2 = drop (len div 2) ?qs; right = calculate_data ?p q2\n                in Let (combine_systems ?p (q1, left) (q2, right))\n                    (reduce_system ?p))\n  find_consistent_signs_at_roots ?p ?qs = snd (snd (calculate_data ?p ?qs))\n  (length ?xs = 0) = (?xs = [])\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "by (smt (z3) calculate_data_R.simps find_consistent_signs_at_roots_thm_R)"], ["proof (state)\nthis:\n  set (find_consistent_signs_at_roots_R p qs) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<and> 0 < length qs \\<longrightarrow>\n  set (find_consistent_signs_at_roots_R p qs) =\n  set (characterize_consistent_signs_at_roots p qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_consistent_signs_at_roots_0_R:\n  fixes p:: \"real poly\"\n  assumes \"p \\<noteq> 0\"\n  shows \"set(find_consistent_signs_at_roots_R p []) =\n         set(characterize_consistent_signs_at_roots p [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p []) =\n    set (characterize_consistent_signs_at_roots p [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p []) =\n    set (characterize_consistent_signs_at_roots p [])", "obtain a b c where abc: \"reduce_system_R p ([1], base_case_info_R) = (a,b,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c.\n        reduce_system_R p ([1], base_case_info_R) =\n        (a, b, c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod_cases3"], ["proof (prove)\nusing this:\n  (\\<And>a b c. ?y = (a, b, c) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a b c.\n        reduce_system_R p ([1], base_case_info_R) =\n        (a, b, c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  reduce_system_R p ([1], base_case_info_R) = (a, b, c)\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p []) =\n    set (characterize_consistent_signs_at_roots p [])", "have \"find_consistent_signs_at_roots_R p [1] = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_consistent_signs_at_roots_R p [1] = c", "using abc"], ["proof (prove)\nusing this:\n  reduce_system_R p ([1], base_case_info_R) = (a, b, c)\n\ngoal (1 subgoal):\n 1. find_consistent_signs_at_roots_R p [1] = c", "by (simp add: find_consistent_signs_at_roots_thm_R)"], ["proof (state)\nthis:\n  find_consistent_signs_at_roots_R p [1] = c\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p []) =\n    set (characterize_consistent_signs_at_roots p [])", "have *: \"set (find_consistent_signs_at_roots_R p [1]) = set (characterize_consistent_signs_at_roots p [1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p [1]) =\n    set (characterize_consistent_signs_at_roots p [1])", "apply (subst find_consistent_signs_at_roots_1_R)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and> 0 < length [1]\n 2. set (characterize_consistent_signs_at_roots p [1]) =\n    set (characterize_consistent_signs_at_roots p [1])", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and> 0 < length [1]\n 2. set (characterize_consistent_signs_at_roots p [1]) =\n    set (characterize_consistent_signs_at_roots p [1])", "by auto"], ["proof (state)\nthis:\n  set (find_consistent_signs_at_roots_R p [1]) =\n  set (characterize_consistent_signs_at_roots p [1])\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p []) =\n    set (characterize_consistent_signs_at_roots p [])", "have \"set(characterize_consistent_signs_at_roots p []) = drop 1 ` set(characterize_consistent_signs_at_roots p [1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p []) =\n    drop 1 ` set (characterize_consistent_signs_at_roots p [1])", "unfolding characterize_consistent_signs_at_roots_def consistent_sign_vec_def signs_at_def squash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups\n          (map (\\<lambda>x.\n                   map ((\\<lambda>x.\n                            if 0 < x then 1\n                            else if x < 0 then - 1 else 0) \\<circ>\n                        (\\<lambda>q. poly q x))\n                    [])\n            (characterize_root_list_p p))) =\n    drop 1 `\n    set (remdups\n          (map (\\<lambda>x.\n                   map ((\\<lambda>x.\n                            if 0 < x then 1\n                            else if x < 0 then - 1 else 0) \\<circ>\n                        (\\<lambda>q. poly q x))\n                    [1])\n            (characterize_root_list_p p)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. []) ` set (characterize_root_list_p p) =\n    drop (Suc 0) ` (\\<lambda>x. [1]) ` set (characterize_root_list_p p)", "using drop0 drop_Suc_Cons image_cong image_image"], ["proof (prove)\nusing this:\n  drop 0 = (\\<lambda>x. x)\n  drop (Suc ?n) (?x # ?xs) = drop ?n ?xs\n  \\<lbrakk>?M = ?N;\n   \\<And>x. x \\<in> ?N \\<Longrightarrow> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?M = ?g ` ?N\n  ?f ` ?g ` ?A = (\\<lambda>x. ?f (?g x)) ` ?A\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. []) ` set (characterize_root_list_p p) =\n    drop (Suc 0) ` (\\<lambda>x. [1]) ` set (characterize_root_list_p p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>drop 0 = (\\<lambda>x. x);\n     \\<And>n x xs. drop (Suc n) (x # xs) = drop n xs;\n     \\<And>M N f g.\n        \\<lbrakk>M = N;\n         \\<And>x. x \\<in> N \\<Longrightarrow> f x = g x\\<rbrakk>\n        \\<Longrightarrow> f ` M = g ` N;\n     \\<And>f g A. f ` g ` A = (\\<lambda>x. f (g x)) ` A\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. []) ` set (characterize_root_list_p p) =\n                      drop (Suc 0) `\n                      (\\<lambda>x. [1]) ` set (characterize_root_list_p p)", "have \"(\\<lambda>r. []) ` set (characterize_root_list_p p) = (\\<lambda>r. drop (Suc 0) [1::rat]) ` set (characterize_root_list_p p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>r. []) ` set (characterize_root_list_p p) =\n    (\\<lambda>r. drop (Suc 0) [1]) ` set (characterize_root_list_p p)", "by force"], ["proof (state)\nthis:\n  (\\<lambda>r. []) ` set (characterize_root_list_p p) =\n  (\\<lambda>r. drop (Suc 0) [1]) ` set (characterize_root_list_p p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>drop 0 = (\\<lambda>x. x);\n     \\<And>n x xs. drop (Suc n) (x # xs) = drop n xs;\n     \\<And>M N f g.\n        \\<lbrakk>M = N;\n         \\<And>x. x \\<in> N \\<Longrightarrow> f x = g x\\<rbrakk>\n        \\<Longrightarrow> f ` M = g ` N;\n     \\<And>f g A. f ` g ` A = (\\<lambda>x. f (g x)) ` A\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. []) ` set (characterize_root_list_p p) =\n                      drop (Suc 0) `\n                      (\\<lambda>x. [1]) ` set (characterize_root_list_p p)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>r. []) ` set (characterize_root_list_p p) =\n  (\\<lambda>r. drop (Suc 0) [1]) ` set (characterize_root_list_p p)", "show \"(\\<lambda>r. []) ` set (characterize_root_list_p p) = drop (Suc 0) ` (\\<lambda>r. [1::rat]) ` set (characterize_root_list_p p)\""], ["proof (prove)\nusing this:\n  (\\<lambda>r. []) ` set (characterize_root_list_p p) =\n  (\\<lambda>r. drop (Suc 0) [1]) ` set (characterize_root_list_p p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>r. []) ` set (characterize_root_list_p p) =\n    drop (Suc 0) ` (\\<lambda>r. [1]) ` set (characterize_root_list_p p)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>r. []) ` set (characterize_root_list_p p) =\n  drop (Suc 0) ` (\\<lambda>r. [1]) ` set (characterize_root_list_p p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots p []) =\n  drop 1 ` set (characterize_consistent_signs_at_roots p [1])\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p []) =\n    set (characterize_consistent_signs_at_roots p [])", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p []) =\n  drop 1 ` set (characterize_consistent_signs_at_roots p [1])\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p []) =\n    set (characterize_consistent_signs_at_roots p [])", "using abc *"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots p []) =\n  drop 1 ` set (characterize_consistent_signs_at_roots p [1])\n  reduce_system_R p ([1], base_case_info_R) = (a, b, c)\n  set (find_consistent_signs_at_roots_R p [1]) =\n  set (characterize_consistent_signs_at_roots p [1])\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p []) =\n    set (characterize_consistent_signs_at_roots p [])", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>set (characterize_consistent_signs_at_roots p []) =\n                drop (Suc 0) `\n                set (characterize_consistent_signs_at_roots p [1]);\n        reduce_system_R p ([1], base_case_info_R) = (a, b, c);\n        set (find_consistent_signs_at_roots_R p [1]) =\n        set (characterize_consistent_signs_at_roots p [1]);\n        x \\<in> set (find_consistent_signs_at_roots_R p [])\\<rbrakk>\n       \\<Longrightarrow> x \\<in> drop (Suc 0) `\n                                 set (characterize_consistent_signs_at_roots\n p [1])\n 2. \\<And>xa.\n       \\<lbrakk>set (characterize_consistent_signs_at_roots p []) =\n                drop (Suc 0) `\n                set (characterize_consistent_signs_at_roots p [1]);\n        reduce_system_R p ([1], base_case_info_R) = (a, b, c);\n        set (find_consistent_signs_at_roots_R p [1]) =\n        set (characterize_consistent_signs_at_roots p [1]);\n        xa \\<in> set (characterize_consistent_signs_at_roots p [1])\\<rbrakk>\n       \\<Longrightarrow> drop (Suc 0) xa\n                         \\<in> set (find_consistent_signs_at_roots_R p [])", "apply (simp add: find_consistent_signs_at_roots_thm_R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>set (characterize_consistent_signs_at_roots p []) =\n                drop (Suc 0) `\n                set (characterize_consistent_signs_at_roots p [1]);\n        reduce_system_R p ([1], base_case_info_R) = (a, b, c);\n        set (find_consistent_signs_at_roots_R p [1]) =\n        set (characterize_consistent_signs_at_roots p [1]);\n        xa \\<in> set (characterize_consistent_signs_at_roots p [1])\\<rbrakk>\n       \\<Longrightarrow> drop (Suc 0) xa\n                         \\<in> set (find_consistent_signs_at_roots_R p [])", "by (simp add: find_consistent_signs_at_roots_thm_R)"], ["proof (state)\nthis:\n  set (find_consistent_signs_at_roots_R p []) =\n  set (characterize_consistent_signs_at_roots p [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_consistent_signs_at_roots_R:\n  fixes p:: \"real poly\"\n  fixes qs :: \"real poly list\"\n  assumes \"p \\<noteq> 0\"\n  shows \"set(find_consistent_signs_at_roots_R p qs) = set(characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R p qs) =\n    set (characterize_consistent_signs_at_roots p qs)", "by (metis assms find_consistent_signs_at_roots_0_R find_consistent_signs_at_roots_1_R length_greater_0_conv)"], ["", "end"]]}