{"file_name": "/home/qj213/afp-2021-10-22/thys/BenOr_Kozen_Reif/Renegar_Decision.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BenOr_Kozen_Reif", "problem_names": ["lemma prod_list_var_nonzero:\n  shows \"prod_list_var qs \\<noteq> 0\"", "lemma q_dvd_prod_list_var_prop:\n  assumes \"q \\<in> set qs\"\n  assumes \"q \\<noteq> 0\"\n  shows \"q dvd prod_list_var qs\"", "lemma check_all_const_deg_prop: \n  shows \"check_all_const_deg l = True \\<longleftrightarrow> (\\<forall>p \\<in> set(l). degree p = 0)\"", "lemma poly_f_nonzero:\n  fixes qs :: \"real poly list\"\n  shows \"(poly_f qs) \\<noteq> 0\"", "lemma poly_f_roots_prop_1: \n  fixes qs:: \"real poly list\"\n  assumes non_const: \"check_all_const_deg qs = False\"\n  shows \"\\<forall>x1. \\<forall>x2. ((x1 < x2 \\<and> (\\<exists>q1 \\<in> set (qs). q1 \\<noteq> 0 \\<and> (poly q1 x1) = 0) \\<and> (\\<exists>q2\\<in> set(qs). q2 \\<noteq> 0 \\<and> (poly q2 x2) = 0)) \\<longrightarrow> (\\<exists>q. x1 < q \\<and> q < x2 \\<and> poly (poly_f qs) q = 0))\"", "lemma main_step_aux1_R:\n  fixes qs:: \"real poly list\"\n  assumes non_const: \"check_all_const_deg qs = True\"\n  shows \"set (find_consistent_signs_R qs) =  consistent_sign_vectors_R qs UNIV\"", "lemma sorted_list_lemma_var:\n  fixes l:: \"real list\"\n  fixes x:: \"real\"\n  assumes \"length l > 1\"\n  assumes strict_sort: \"strict_sorted l\"\n  assumes x_not_in: \"\\<not> (List.member l x)\"\n  assumes lt_a: \"x > (l ! 0)\"\n  assumes b_lt: \"x < (l ! (length l - 1))\"\n  shows \"(\\<exists>n. n < length l - 1 \\<and> x > l ! n \\<and> x < l !(n+1))\"", "lemma all_sample_points_prop:\n  assumes is_not_const: \"check_all_const_deg qs = False\"\n  assumes s_is: \"S = (characterize_root_list_p (pderiv (prod_list_var qs) * (prod_list_var qs) * ([:-(crb (prod_list_var qs)),1:]) * ([:(crb (prod_list_var qs)),1:])))\"(* properties about S*)\n  shows \"consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)\"", "lemma main_step_aux2_R:\n  fixes qs:: \"real poly list\"\n  assumes is_not_const: \"check_all_const_deg qs = False\"\n  shows \"set (find_consistent_signs_R qs) =  consistent_sign_vectors_R qs UNIV\"", "lemma main_step_R:\n  fixes qs:: \"real poly list\"\n  shows \"set (find_consistent_signs_R qs) =  consistent_sign_vectors_R qs UNIV\"", "lemma consistent_sign_vec_semantics_R:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length ls\"\n  shows \"lookup_sem fml (map (\\<lambda>p. poly p x) ls) = lookup_sem fml (consistent_sign_vec ls x)\"", "lemma universal_lookup_sem_R:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length qs\"\n  assumes \"set signs = consistent_sign_vectors_R qs UNIV\"\n  shows \"(\\<forall>x::real. lookup_sem fml (map (\\<lambda>p. poly p x) qs)) \\<longleftrightarrow>\n    list_all (lookup_sem fml) signs\"", "lemma existential_lookup_sem_R:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length qs\"\n  assumes \"set signs = consistent_sign_vectors_R qs UNIV\"\n  shows \"(\\<exists>x::real. lookup_sem fml (map (\\<lambda>p. poly p x) qs)) \\<longleftrightarrow>\n    find (lookup_sem fml) signs \\<noteq> None\"", "lemma decide_univ_lem_helper_R:\n  fixes fml:: \"real poly fml\"\n  assumes \"(fml_struct,polys) = convert fml\"\n  shows \"(\\<forall>x::real. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) \\<longleftrightarrow> (decide_universal_R fml)\"", "lemma decide_exis_lem_helper_R:\n  fixes fml:: \"real poly fml\"\n  assumes \"(fml_struct,polys) = convert fml\"\n  shows \"(\\<exists>x::real. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) \\<longleftrightarrow> (decide_existential_R fml)\"", "lemma convert_semantics_lem_R:\n  assumes \"\\<And>p. p \\<in> set (poly_list fml) \\<Longrightarrow>\n    ls ! (index_of ps p) = poly p x\"\n  shows \"real_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls\"", "lemma convert_semantics_R:\n  shows \"real_sem fml x = lookup_sem (fst (convert fml)) (map (\\<lambda>p. poly p x) (snd (convert fml)))\"", "theorem decision_procedure_R:\n  shows \"(\\<forall>x::real. real_sem fml x) \\<longleftrightarrow> (decide_universal_R fml)\"\n    \"\\<exists>x::real. real_sem fml x \\<longleftrightarrow> (decide_existential_R fml)\""], "translations": [["", "lemma prod_list_var_nonzero:\n  shows \"prod_list_var qs \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list_var qs \\<noteq> 0", "proof (induct qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. prod_list_var [] \\<noteq> 0\n 2. \\<And>a qs.\n       prod_list_var qs \\<noteq> 0 \\<Longrightarrow>\n       prod_list_var (a # qs) \\<noteq> 0", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. prod_list_var [] \\<noteq> 0\n 2. \\<And>a qs.\n       prod_list_var qs \\<noteq> 0 \\<Longrightarrow>\n       prod_list_var (a # qs) \\<noteq> 0", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list_var [] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  prod_list_var [] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       prod_list_var qs \\<noteq> 0 \\<Longrightarrow>\n       prod_list_var (a # qs) \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       prod_list_var qs \\<noteq> 0 \\<Longrightarrow>\n       prod_list_var (a # qs) \\<noteq> 0", "case (Cons a qs)"], ["proof (state)\nthis:\n  prod_list_var qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       prod_list_var qs \\<noteq> 0 \\<Longrightarrow>\n       prod_list_var (a # qs) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  prod_list_var qs \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  prod_list_var qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list_var (a # qs) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  prod_list_var (a # qs) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma q_dvd_prod_list_var_prop:\n  assumes \"q \\<in> set qs\"\n  assumes \"q \\<noteq> 0\"\n  shows \"q dvd prod_list_var qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q dvd prod_list_var qs", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q dvd prod_list_var qs", "proof (induct qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>q \\<in> set []; q \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> q dvd prod_list_var []\n 2. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> q dvd prod_list_var qs;\n        q \\<in> set (a # qs); q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> q dvd prod_list_var (a # qs)", "case Nil"], ["proof (state)\nthis:\n  q \\<in> set []\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>q \\<in> set []; q \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> q dvd prod_list_var []\n 2. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> q dvd prod_list_var qs;\n        q \\<in> set (a # qs); q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> q dvd prod_list_var (a # qs)", "then"], ["proof (chain)\npicking this:\n  q \\<in> set []\n  q \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  q \\<in> set []\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q dvd prod_list_var []", "by auto"], ["proof (state)\nthis:\n  q dvd prod_list_var []\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> q dvd prod_list_var qs;\n        q \\<in> set (a # qs); q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> q dvd prod_list_var (a # qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> q dvd prod_list_var qs;\n        q \\<in> set (a # qs); q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> q dvd prod_list_var (a # qs)", "case (Cons a qs)"], ["proof (state)\nthis:\n  \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q dvd prod_list_var qs\n  q \\<in> set (a # qs)\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> q dvd prod_list_var qs;\n        q \\<in> set (a # qs); q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> q dvd prod_list_var (a # qs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q dvd prod_list_var qs\n  q \\<in> set (a # qs)\n  q \\<noteq> 0", "have eo: \"q = a \\<or>q \\<in> set qs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q dvd prod_list_var qs\n  q \\<in> set (a # qs)\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q = a \\<or> q \\<in> set qs", "by auto"], ["proof (state)\nthis:\n  q = a \\<or> q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> q dvd prod_list_var qs;\n        q \\<in> set (a # qs); q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> q dvd prod_list_var (a # qs)", "have c1: \"q = a \\<Longrightarrow> q dvd prod_list_var (a#qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = a \\<Longrightarrow> q dvd prod_list_var (a # qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q = a \\<Longrightarrow> q dvd prod_list_var (a # qs)", "assume \"q = a\""], ["proof (state)\nthis:\n  q = a\n\ngoal (1 subgoal):\n 1. q = a \\<Longrightarrow> q dvd prod_list_var (a # qs)", "then"], ["proof (chain)\npicking this:\n  q = a", "have \"prod_list_var (a#qs) = q*(prod_list_var qs)\""], ["proof (prove)\nusing this:\n  q = a\n\ngoal (1 subgoal):\n 1. prod_list_var (a # qs) = q * prod_list_var qs", "using Cons.prems"], ["proof (prove)\nusing this:\n  q = a\n  q \\<in> set (a # qs)\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list_var (a # qs) = q * prod_list_var qs", "unfolding prod_list_var_def"], ["proof (prove)\nusing this:\n  q = a\n  q \\<in> set (a # qs)\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rec_list 1 (\\<lambda>h T Ta. if h = 0 then Ta else h * Ta) (a # qs) =\n    q * rec_list 1 (\\<lambda>h T Ta. if h = 0 then Ta else h * Ta) qs", "by auto"], ["proof (state)\nthis:\n  prod_list_var (a # qs) = q * prod_list_var qs\n\ngoal (1 subgoal):\n 1. q = a \\<Longrightarrow> q dvd prod_list_var (a # qs)", "then"], ["proof (chain)\npicking this:\n  prod_list_var (a # qs) = q * prod_list_var qs", "show ?thesis"], ["proof (prove)\nusing this:\n  prod_list_var (a # qs) = q * prod_list_var qs\n\ngoal (1 subgoal):\n 1. q dvd prod_list_var (a # qs)", "using prod_list_var_nonzero[of qs]"], ["proof (prove)\nusing this:\n  prod_list_var (a # qs) = q * prod_list_var qs\n  prod_list_var qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q dvd prod_list_var (a # qs)", "by auto"], ["proof (state)\nthis:\n  q dvd prod_list_var (a # qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q = a \\<Longrightarrow> q dvd prod_list_var (a # qs)\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> q dvd prod_list_var qs;\n        q \\<in> set (a # qs); q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> q dvd prod_list_var (a # qs)", "have c2: \"q \\<in> set qs \\<longrightarrow> q dvd prod_list_var qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set qs \\<longrightarrow> q dvd prod_list_var qs", "using Cons.prems Cons.hyps"], ["proof (prove)\nusing this:\n  q \\<in> set (a # qs)\n  q \\<noteq> 0\n  \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q dvd prod_list_var qs\n\ngoal (1 subgoal):\n 1. q \\<in> set qs \\<longrightarrow> q dvd prod_list_var qs", "unfolding prod_list_var_def"], ["proof (prove)\nusing this:\n  q \\<in> set (a # qs)\n  q \\<noteq> 0\n  \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q dvd\n                    rec_list 1\n                     (\\<lambda>h T Ta. if h = 0 then Ta else h * Ta) qs\n\ngoal (1 subgoal):\n 1. q \\<in> set qs \\<longrightarrow>\n    q dvd rec_list 1 (\\<lambda>h T Ta. if h = 0 then Ta else h * Ta) qs", "by auto"], ["proof (state)\nthis:\n  q \\<in> set qs \\<longrightarrow> q dvd prod_list_var qs\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> q dvd prod_list_var qs;\n        q \\<in> set (a # qs); q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> q dvd prod_list_var (a # qs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. q dvd prod_list_var (a # qs)", "using eo c1 c2"], ["proof (prove)\nusing this:\n  q = a \\<or> q \\<in> set qs\n  q = a \\<Longrightarrow> q dvd prod_list_var (a # qs)\n  q \\<in> set qs \\<longrightarrow> q dvd prod_list_var qs\n\ngoal (1 subgoal):\n 1. q dvd prod_list_var (a # qs)", "by auto"], ["proof (state)\nthis:\n  q dvd prod_list_var (a # qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_all_const_deg_prop: \n  shows \"check_all_const_deg l = True \\<longleftrightarrow> (\\<forall>p \\<in> set(l). degree p = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (check_all_const_deg l = True) = (\\<forall>p\\<in>set l. degree p = 0)", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. (check_all_const_deg [] = True) = (\\<forall>p\\<in>set []. degree p = 0)\n 2. \\<And>a l.\n       (check_all_const_deg l = True) =\n       (\\<forall>p\\<in>set l. degree p = 0) \\<Longrightarrow>\n       (check_all_const_deg (a # l) = True) =\n       (\\<forall>p\\<in>set (a # l). degree p = 0)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (check_all_const_deg [] = True) = (\\<forall>p\\<in>set []. degree p = 0)\n 2. \\<And>a l.\n       (check_all_const_deg l = True) =\n       (\\<forall>p\\<in>set l. degree p = 0) \\<Longrightarrow>\n       (check_all_const_deg (a # l) = True) =\n       (\\<forall>p\\<in>set (a # l). degree p = 0)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (check_all_const_deg [] = True) = (\\<forall>p\\<in>set []. degree p = 0)", "by auto"], ["proof (state)\nthis:\n  (check_all_const_deg [] = True) = (\\<forall>p\\<in>set []. degree p = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       (check_all_const_deg l = True) =\n       (\\<forall>p\\<in>set l. degree p = 0) \\<Longrightarrow>\n       (check_all_const_deg (a # l) = True) =\n       (\\<forall>p\\<in>set (a # l). degree p = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       (check_all_const_deg l = True) =\n       (\\<forall>p\\<in>set l. degree p = 0) \\<Longrightarrow>\n       (check_all_const_deg (a # l) = True) =\n       (\\<forall>p\\<in>set (a # l). degree p = 0)", "case (Cons a l)"], ["proof (state)\nthis:\n  (check_all_const_deg l = True) = (\\<forall>p\\<in>set l. degree p = 0)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       (check_all_const_deg l = True) =\n       (\\<forall>p\\<in>set l. degree p = 0) \\<Longrightarrow>\n       (check_all_const_deg (a # l) = True) =\n       (\\<forall>p\\<in>set (a # l). degree p = 0)", "then"], ["proof (chain)\npicking this:\n  (check_all_const_deg l = True) = (\\<forall>p\\<in>set l. degree p = 0)", "show ?case"], ["proof (prove)\nusing this:\n  (check_all_const_deg l = True) = (\\<forall>p\\<in>set l. degree p = 0)\n\ngoal (1 subgoal):\n 1. (check_all_const_deg (a # l) = True) =\n    (\\<forall>p\\<in>set (a # l). degree p = 0)", "by auto"], ["proof (state)\nthis:\n  (check_all_const_deg (a # l) = True) =\n  (\\<forall>p\\<in>set (a # l). degree p = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* lemma prod_zero shows that the product of the polynomial list is 0 at x iff there is a polynomial \n  in the list that is 0 at x *)"], ["", "lemma poly_f_nonzero:\n  fixes qs :: \"real poly list\"\n  shows \"(poly_f qs) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_f qs \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_f qs \\<noteq> 0", "have eo: \"(\\<forall>p \\<in> set qs. degree p = 0) \\<or> (\\<exists>p \\<in> set qs. degree p > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set qs. degree p = 0) \\<or>\n    (\\<exists>p\\<in>set qs. 0 < degree p)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>p\\<in>set qs. degree p = 0) \\<or>\n  (\\<exists>p\\<in>set qs. 0 < degree p)\n\ngoal (1 subgoal):\n 1. poly_f qs \\<noteq> 0", "have c1: \"(\\<forall>p \\<in> set qs. degree p = 0) \\<longrightarrow> (poly_f qs) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set qs. degree p = 0) \\<longrightarrow>\n    poly_f qs \\<noteq> 0", "unfolding poly_f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set qs. degree p = 0) \\<longrightarrow>\n    (if check_all_const_deg qs = True then [:0, 1:]\n     else pderiv (prod_list_var qs) * prod_list_var qs *\n          [:real_of_int (- crb (prod_list_var qs)), 1:] *\n          [:real_of_int (crb (prod_list_var qs)), 1:]) \\<noteq>\n    0", "using check_all_const_deg_prop"], ["proof (prove)\nusing this:\n  (check_all_const_deg ?l = True) = (\\<forall>p\\<in>set ?l. degree p = 0)\n\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set qs. degree p = 0) \\<longrightarrow>\n    (if check_all_const_deg qs = True then [:0, 1:]\n     else pderiv (prod_list_var qs) * prod_list_var qs *\n          [:real_of_int (- crb (prod_list_var qs)), 1:] *\n          [:real_of_int (crb (prod_list_var qs)), 1:]) \\<noteq>\n    0", "by auto"], ["proof (state)\nthis:\n  (\\<forall>p\\<in>set qs. degree p = 0) \\<longrightarrow>\n  poly_f qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_f qs \\<noteq> 0", "have c2: \"(\\<exists>p \\<in> set qs. degree p > 0) \\<longrightarrow> (poly_f qs) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p\\<in>set qs. 0 < degree p) \\<longrightarrow>\n    poly_f qs \\<noteq> 0", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p \\<in> set qs; 0 < degree p; poly_f qs = 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p \\<in> set qs; 0 < degree p; poly_f qs = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume q_in: \"q \\<in> set qs\""], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p \\<in> set qs; 0 < degree p; poly_f qs = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume deg_q: \"0 < degree q\""], ["proof (state)\nthis:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p \\<in> set qs; 0 < degree p; poly_f qs = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume contrad: \"poly_f qs = 0\""], ["proof (state)\nthis:\n  poly_f qs = 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p \\<in> set qs; 0 < degree p; poly_f qs = 0\\<rbrakk>\n       \\<Longrightarrow> False", "have nonconst: \"check_all_const_deg qs = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_all_const_deg qs = False", "using deg_q check_all_const_deg_prop\n        q_in"], ["proof (prove)\nusing this:\n  0 < degree q\n  (check_all_const_deg ?l = True) = (\\<forall>p\\<in>set ?l. degree p = 0)\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. check_all_const_deg qs = False", "by auto"], ["proof (state)\nthis:\n  check_all_const_deg qs = False\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p \\<in> set qs; 0 < degree p; poly_f qs = 0\\<rbrakk>\n       \\<Longrightarrow> False", "have h1: \"prod_list_var qs \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list_var qs \\<noteq> 0", "using prod_list_var_nonzero"], ["proof (prove)\nusing this:\n  prod_list_var ?qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list_var qs \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  prod_list_var qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p \\<in> set qs; 0 < degree p; poly_f qs = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  prod_list_var qs \\<noteq> 0", "have \"degree (prod_list_var qs) > 0\""], ["proof (prove)\nusing this:\n  prod_list_var qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree (prod_list_var qs)", "using q_in deg_q h1"], ["proof (prove)\nusing this:\n  prod_list_var qs \\<noteq> 0\n  q \\<in> set qs\n  0 < degree q\n  prod_list_var qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree (prod_list_var qs)", "proof (induct qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>prod_list_var [] \\<noteq> 0; q \\<in> set []; 0 < degree q;\n     prod_list_var [] \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < degree (prod_list_var [])\n 2. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "case Nil"], ["proof (state)\nthis:\n  prod_list_var [] \\<noteq> 0\n  q \\<in> set []\n  0 < degree q\n  prod_list_var [] \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>prod_list_var [] \\<noteq> 0; q \\<in> set []; 0 < degree q;\n     prod_list_var [] \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < degree (prod_list_var [])\n 2. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "then"], ["proof (chain)\npicking this:\n  prod_list_var [] \\<noteq> 0\n  q \\<in> set []\n  0 < degree q\n  prod_list_var [] \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  prod_list_var [] \\<noteq> 0\n  q \\<in> set []\n  0 < degree q\n  prod_list_var [] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree (prod_list_var [])", "by auto"], ["proof (state)\nthis:\n  0 < degree (prod_list_var [])\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "case (Cons a qs)"], ["proof (state)\nthis:\n  \\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs; 0 < degree q;\n   prod_list_var qs \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> 0 < degree (prod_list_var qs)\n  prod_list_var (a # qs) \\<noteq> 0\n  q \\<in> set (a # qs)\n  0 < degree q\n  prod_list_var (a # qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "have q_nonz: \"q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using Cons.prems"], ["proof (prove)\nusing this:\n  prod_list_var (a # qs) \\<noteq> 0\n  q \\<in> set (a # qs)\n  0 < degree q\n  prod_list_var (a # qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "have q_ins: \"q \\<in> set (a # qs) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set (a # qs)", "using Cons.prems"], ["proof (prove)\nusing this:\n  prod_list_var (a # qs) \\<noteq> 0\n  q \\<in> set (a # qs)\n  0 < degree q\n  prod_list_var (a # qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<in> set (a # qs)", "by auto"], ["proof (state)\nthis:\n  q \\<in> set (a # qs)\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "then"], ["proof (chain)\npicking this:\n  q \\<in> set (a # qs)", "have \"q = a \\<or> q \\<in> set qs\""], ["proof (prove)\nusing this:\n  q \\<in> set (a # qs)\n\ngoal (1 subgoal):\n 1. q = a \\<or> q \\<in> set qs", "by auto"], ["proof (state)\nthis:\n  q = a \\<or> q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "then"], ["proof (chain)\npicking this:\n  q = a \\<or> q \\<in> set qs", "have eo: \" q = a \\<or> List.member qs q\""], ["proof (prove)\nusing this:\n  q = a \\<or> q \\<in> set qs\n\ngoal (1 subgoal):\n 1. q = a \\<or> List.member qs q", "using in_set_member[of q qs]"], ["proof (prove)\nusing this:\n  q = a \\<or> q \\<in> set qs\n  (q \\<in> set qs) = List.member qs q\n\ngoal (1 subgoal):\n 1. q = a \\<or> List.member qs q", "by auto"], ["proof (state)\nthis:\n  q = a \\<or> List.member qs q\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "have degq: \"degree q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree q", "using Cons.prems"], ["proof (prove)\nusing this:\n  prod_list_var (a # qs) \\<noteq> 0\n  q \\<in> set (a # qs)\n  0 < degree q\n  prod_list_var (a # qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree q", "by auto"], ["proof (state)\nthis:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "have h2: \"(prod_list (a # qs)) = a* (prod_list qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (a # qs) = a * prod_list qs", "by auto"], ["proof (state)\nthis:\n  prod_list (a # qs) = a * prod_list qs\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "have isa: \"q = a \\<longrightarrow> 0 < degree (prod_list_var (a # qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = a \\<longrightarrow> 0 < degree (prod_list_var (a # qs))", "using h2 degree_mult_eq_0[where p = \"q\", where q = \"prod_list_var qs\"]\n          Cons.prems"], ["proof (prove)\nusing this:\n  prod_list (a # qs) = a * prod_list qs\n  (degree (q * prod_list_var qs) = 0) =\n  (q = 0 \\<or>\n   prod_list_var qs = 0 \\<or>\n   q \\<noteq> 0 \\<and>\n   prod_list_var qs \\<noteq> 0 \\<and>\n   degree q = 0 \\<and> degree (prod_list_var qs) = 0)\n  prod_list_var (a # qs) \\<noteq> 0\n  q \\<in> set (a # qs)\n  0 < degree q\n  prod_list_var (a # qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q = a \\<longrightarrow> 0 < degree (prod_list_var (a # qs))", "by auto"], ["proof (state)\nthis:\n  q = a \\<longrightarrow> 0 < degree (prod_list_var (a # qs))\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "have inl: \"List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))", "have nonzprod: \"prod_list_var (a # qs) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list_var (a # qs) \\<noteq> 0", "using prod_list_var_nonzero"], ["proof (prove)\nusing this:\n  prod_list_var ?qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list_var (a # qs) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  prod_list_var (a # qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))", "have \"q dvd prod_list_var (a # qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q dvd prod_list_var (a # qs)", "using q_dvd_prod_list_var_prop[where q = \"q\", where qs = \"(a#qs)\"] q_nonz q_ins"], ["proof (prove)\nusing this:\n  \\<lbrakk>q \\<in> set (a # qs); q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q dvd prod_list_var (a # qs)\n  q \\<noteq> 0\n  q \\<in> set (a # qs)\n\ngoal (1 subgoal):\n 1. q dvd prod_list_var (a # qs)", "by auto"], ["proof (state)\nthis:\n  q dvd prod_list_var (a # qs)\n\ngoal (1 subgoal):\n 1. List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))", "then"], ["proof (chain)\npicking this:\n  q dvd prod_list_var (a # qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  q dvd prod_list_var (a # qs)\n\ngoal (1 subgoal):\n 1. List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))", "using divides_degree[where p = \"q\", where q = \"prod_list_var (a # qs)\"] nonzprod degq"], ["proof (prove)\nusing this:\n  q dvd prod_list_var (a # qs)\n  q dvd prod_list_var (a # qs) \\<Longrightarrow>\n  degree q \\<le> degree (prod_list_var (a # qs)) \\<or>\n  prod_list_var (a # qs) = 0\n  prod_list_var (a # qs) \\<noteq> 0\n  0 < degree q\n\ngoal (1 subgoal):\n 1. List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))", "by auto"], ["proof (state)\nthis:\n  List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>\\<lbrakk>prod_list_var qs \\<noteq> 0; q \\<in> set qs;\n                 0 < degree q; prod_list_var qs \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> 0 < degree (prod_list_var qs);\n        prod_list_var (a # qs) \\<noteq> 0; q \\<in> set (a # qs);\n        0 < degree q; prod_list_var (a # qs) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 0 < degree (prod_list_var (a # qs))", "then"], ["proof (chain)\npicking this:\n  List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))", "show ?case"], ["proof (prove)\nusing this:\n  List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))\n\ngoal (1 subgoal):\n 1. 0 < degree (prod_list_var (a # qs))", "using eo isa"], ["proof (prove)\nusing this:\n  List.member qs q \\<longrightarrow> 0 < degree (prod_list_var (a # qs))\n  q = a \\<or> List.member qs q\n  q = a \\<longrightarrow> 0 < degree (prod_list_var (a # qs))\n\ngoal (1 subgoal):\n 1. 0 < degree (prod_list_var (a # qs))", "by auto"], ["proof (state)\nthis:\n  0 < degree (prod_list_var (a # qs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < degree (prod_list_var qs)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p \\<in> set qs; 0 < degree p; poly_f qs = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < degree (prod_list_var qs)", "have h2: \"pderiv (prod_list_var qs) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree (prod_list_var qs)\n\ngoal (1 subgoal):\n 1. pderiv (prod_list_var qs) \\<noteq> 0", "using pderiv_eq_0_iff[where p = \"prod_list_var qs\"]"], ["proof (prove)\nusing this:\n  0 < degree (prod_list_var qs)\n  (pderiv (prod_list_var qs) = 0) = (degree (prod_list_var qs) = 0)\n\ngoal (1 subgoal):\n 1. pderiv (prod_list_var qs) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  pderiv (prod_list_var qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p \\<in> set qs; 0 < degree p; poly_f qs = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  pderiv (prod_list_var qs) \\<noteq> 0", "have \"pderiv (prod_list_var qs) * prod_list_var qs \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pderiv (prod_list_var qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv (prod_list_var qs) * prod_list_var qs \\<noteq> 0", "using prod_list_var_nonzero h2"], ["proof (prove)\nusing this:\n  pderiv (prod_list_var qs) \\<noteq> 0\n  prod_list_var ?qs \\<noteq> 0\n  pderiv (prod_list_var qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv (prod_list_var qs) * prod_list_var qs \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  pderiv (prod_list_var qs) * prod_list_var qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p \\<in> set qs; 0 < degree p; poly_f qs = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  pderiv (prod_list_var qs) * prod_list_var qs \\<noteq> 0", "show \"False\""], ["proof (prove)\nusing this:\n  pderiv (prod_list_var qs) * prod_list_var qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using contrad nonconst"], ["proof (prove)\nusing this:\n  pderiv (prod_list_var qs) * prod_list_var qs \\<noteq> 0\n  poly_f qs = 0\n  check_all_const_deg qs = False\n\ngoal (1 subgoal):\n 1. False", "unfolding poly_f_def deg_q"], ["proof (prove)\nusing this:\n  pderiv (prod_list_var qs) * prod_list_var qs \\<noteq> 0\n  (if check_all_const_deg qs = True then [:0, 1:]\n   else pderiv (prod_list_var qs) * prod_list_var qs *\n        [:real_of_int (- crb (prod_list_var qs)), 1:] *\n        [:real_of_int (crb (prod_list_var qs)), 1:]) =\n  0\n  check_all_const_deg qs = False\n\ngoal (1 subgoal):\n 1. False", "by (smt (z3) mult_eq_0_iff pCons_eq_0_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>p\\<in>set qs. 0 < degree p) \\<longrightarrow>\n  poly_f qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_f qs \\<noteq> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_f qs \\<noteq> 0", "using eo c1 c2"], ["proof (prove)\nusing this:\n  (\\<forall>p\\<in>set qs. degree p = 0) \\<or>\n  (\\<exists>p\\<in>set qs. 0 < degree p)\n  (\\<forall>p\\<in>set qs. degree p = 0) \\<longrightarrow>\n  poly_f qs \\<noteq> 0\n  (\\<exists>p\\<in>set qs. 0 < degree p) \\<longrightarrow>\n  poly_f qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_f qs \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly_f qs \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_f_roots_prop_1: \n  fixes qs:: \"real poly list\"\n  assumes non_const: \"check_all_const_deg qs = False\"\n  shows \"\\<forall>x1. \\<forall>x2. ((x1 < x2 \\<and> (\\<exists>q1 \\<in> set (qs). q1 \\<noteq> 0 \\<and> (poly q1 x1) = 0) \\<and> (\\<exists>q2\\<in> set(qs). q2 \\<noteq> 0 \\<and> (poly q2 x2) = 0)) \\<longrightarrow> (\\<exists>q. x1 < q \\<and> q < x2 \\<and> poly (poly_f qs) q = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x1 x2.\n       x1 < x2 \\<and>\n       (\\<exists>q1\\<in>set qs. q1 \\<noteq> 0 \\<and> poly q1 x1 = 0) \\<and>\n       (\\<exists>q2\\<in>set qs.\n           q2 \\<noteq> 0 \\<and> poly q2 x2 = 0) \\<longrightarrow>\n       (\\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "fix x1:: \"real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "fix x2:: \"real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "fix q1:: \"real poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "fix q2:: \"real poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "assume \"x1 < x2\""], ["proof (state)\nthis:\n  x1 < x2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "assume q1_in: \"q1 \\<in> set qs\""], ["proof (state)\nthis:\n  q1 \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "assume q1_0: \"poly q1 x1 = 0\""], ["proof (state)\nthis:\n  poly q1 x1 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "assume q1_nonz: \"q1 \\<noteq> 0\""], ["proof (state)\nthis:\n  q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "assume q2_in: \"q2 \\<in> set qs\""], ["proof (state)\nthis:\n  q2 \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "assume q2_0: \"poly q2 x2 = 0\""], ["proof (state)\nthis:\n  poly q2 x2 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "assume q2_nonz: \"q2 \\<noteq> 0\""], ["proof (state)\nthis:\n  q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "have prod_z_x1: \"poly (prod_list_var qs) x1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list_var qs) x1 = 0", "using q1_in q1_0"], ["proof (prove)\nusing this:\n  q1 \\<in> set qs\n  poly q1 x1 = 0\n\ngoal (1 subgoal):\n 1. poly (prod_list_var qs) x1 = 0", "using q1_nonz q_dvd_prod_list_var_prop[of q1 qs]"], ["proof (prove)\nusing this:\n  q1 \\<in> set qs\n  poly q1 x1 = 0\n  q1 \\<noteq> 0\n  \\<lbrakk>q1 \\<in> set qs; q1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q1 dvd prod_list_var qs\n\ngoal (1 subgoal):\n 1. poly (prod_list_var qs) x1 = 0", "by auto"], ["proof (state)\nthis:\n  poly (prod_list_var qs) x1 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "have prod_z_x2: \"poly (prod_list_var qs) x2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list_var qs) x2 = 0", "using q2_in q2_0"], ["proof (prove)\nusing this:\n  q2 \\<in> set qs\n  poly q2 x2 = 0\n\ngoal (1 subgoal):\n 1. poly (prod_list_var qs) x2 = 0", "using q2_nonz q_dvd_prod_list_var_prop[of q2 qs]"], ["proof (prove)\nusing this:\n  q2 \\<in> set qs\n  poly q2 x2 = 0\n  q2 \\<noteq> 0\n  \\<lbrakk>q2 \\<in> set qs; q2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q2 dvd prod_list_var qs\n\ngoal (1 subgoal):\n 1. poly (prod_list_var qs) x2 = 0", "by auto"], ["proof (state)\nthis:\n  poly (prod_list_var qs) x2 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "have \"\\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0", "using Rolle_pderiv[where q = \"prod_list_var qs\"] prod_z_x1 prod_z_x2"], ["proof (prove)\nusing this:\n  ?x1.0 < ?x2.0 \\<and>\n  poly (prod_list_var qs) ?x1.0 = 0 \\<and>\n  poly (prod_list_var qs) ?x2.0 = 0 \\<longrightarrow>\n  (\\<exists>w>?x1.0.\n      w < ?x2.0 \\<and> poly (pderiv (prod_list_var qs)) w = 0)\n  poly (prod_list_var qs) x1 = 0\n  poly (prod_list_var qs) x2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0", "using \\<open>x1 < x2\\<close>"], ["proof (prove)\nusing this:\n  ?x1.0 < ?x2.0 \\<and>\n  poly (prod_list_var qs) ?x1.0 = 0 \\<and>\n  poly (prod_list_var qs) ?x2.0 = 0 \\<longrightarrow>\n  (\\<exists>w>?x1.0.\n      w < ?x2.0 \\<and> poly (pderiv (prod_list_var qs)) w = 0)\n  poly (prod_list_var qs) x1 = 0\n  poly (prod_list_var qs) x2 = 0\n  x1 < x2\n\ngoal (1 subgoal):\n 1. \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0", "obtain w where w_def: \"w > x1 \\<and>w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0\""], ["proof (prove)\nusing this:\n  \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        x1 < w \\<and>\n        w < x2 \\<and>\n        poly (pderiv (prod_list_var qs)) w = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "then"], ["proof (chain)\npicking this:\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0", "have \"poly (poly_f qs) w = 0\""], ["proof (prove)\nusing this:\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0\n\ngoal (1 subgoal):\n 1. poly (poly_f qs) w = 0", "unfolding poly_f_def"], ["proof (prove)\nusing this:\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0\n\ngoal (1 subgoal):\n 1. poly\n     (if check_all_const_deg qs = True then [:0, 1:]\n      else pderiv (prod_list_var qs) * prod_list_var qs *\n           [:real_of_int (- crb (prod_list_var qs)), 1:] *\n           [:real_of_int (crb (prod_list_var qs)), 1:])\n     w =\n    0", "using non_const"], ["proof (prove)\nusing this:\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0\n  check_all_const_deg qs = False\n\ngoal (1 subgoal):\n 1. poly\n     (if check_all_const_deg qs = True then [:0, 1:]\n      else pderiv (prod_list_var qs) * prod_list_var qs *\n           [:real_of_int (- crb (prod_list_var qs)), 1:] *\n           [:real_of_int (crb (prod_list_var qs)), 1:])\n     w =\n    0", "by simp"], ["proof (state)\nthis:\n  poly (poly_f qs) w = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; q2 \\<in> set qs; q1 \\<noteq> 0;\n        poly q1 x1 = 0; q2 \\<noteq> 0; poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "then"], ["proof (chain)\npicking this:\n  poly (poly_f qs) w = 0", "show \"\\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0\""], ["proof (prove)\nusing this:\n  poly (poly_f qs) w = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "using w_def"], ["proof (prove)\nusing this:\n  poly (poly_f qs) w = 0\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list_var qs)) w = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma main_step_aux1_R:\n  fixes qs:: \"real poly list\"\n  assumes non_const: \"check_all_const_deg qs = True\"\n  shows \"set (find_consistent_signs_R qs) =  consistent_sign_vectors_R qs UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "have poly_f_is: \"poly_f qs = [:0, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_f qs = [:0, 1:]", "unfolding poly_f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if check_all_const_deg qs = True then [:0, 1:]\n     else pderiv (prod_list_var qs) * prod_list_var qs *\n          [:real_of_int (- crb (prod_list_var qs)), 1:] *\n          [:real_of_int (crb (prod_list_var qs)), 1:]) =\n    [:0, 1:]", "using assms"], ["proof (prove)\nusing this:\n  check_all_const_deg qs = True\n\ngoal (1 subgoal):\n 1. (if check_all_const_deg qs = True then [:0, 1:]\n     else pderiv (prod_list_var qs) * prod_list_var qs *\n          [:real_of_int (- crb (prod_list_var qs)), 1:] *\n          [:real_of_int (crb (prod_list_var qs)), 1:]) =\n    [:0, 1:]", "by auto"], ["proof (state)\nthis:\n  poly_f qs = [:0, 1:]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "have same: \"set (find_consistent_signs_at_roots_R [:0, 1:] qs) =\n  set (characterize_consistent_signs_at_roots [:0, 1:] qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R [:0, 1:] qs) =\n    set (characterize_consistent_signs_at_roots [:0, 1:] qs)", "using find_consistent_signs_at_roots_R[of \"[:0, 1:]\" qs]"], ["proof (prove)\nusing this:\n  [:0, 1:] \\<noteq> 0 \\<Longrightarrow>\n  set (find_consistent_signs_at_roots_R [:0, 1:] qs) =\n  set (characterize_consistent_signs_at_roots [:0, 1:] qs)\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R [:0, 1:] qs) =\n    set (characterize_consistent_signs_at_roots [:0, 1:] qs)", "by auto"], ["proof (state)\nthis:\n  set (find_consistent_signs_at_roots_R [:0, 1:] qs) =\n  set (characterize_consistent_signs_at_roots [:0, 1:] qs)\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "have rech: \"(sorted_list_of_set {x. poly ([:0, 1:]::real poly) x = 0}) = [0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. poly [:0, 1:] x = 0} = [0]", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set {x. poly [:0, 1:] x = 0} = [0]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "have alldeg0: \"(\\<forall>p \\<in> set qs. degree p = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set qs. degree p = 0", "using non_const check_all_const_deg_prop"], ["proof (prove)\nusing this:\n  check_all_const_deg qs = True\n  (check_all_const_deg ?l = True) = (\\<forall>p\\<in>set ?l. degree p = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set qs. degree p = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set qs. degree p = 0\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set qs. degree p = 0", "have allconst: \"\\<forall>p \\<in> set qs. (\\<exists>(k::real). p = [:k:])\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set qs. degree p = 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set qs. \\<exists>k. p = [:k:]", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>set qs. degree p = 0; p \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k. p = [:k:]", "by (meson degree_eq_zeroE)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set qs. \\<exists>k. p = [:k:]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set qs. \\<exists>k. p = [:k:]", "have allconstvar: \"\\<forall>p \\<in> set qs. \\<forall>(x::real). \\<forall>(y::real). poly p x = poly p y\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set qs. \\<exists>k. p = [:k:]\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set qs. \\<forall>x y. poly p x = poly p y", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set qs. \\<forall>x y. poly p x = poly p y\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "have e1: \"set (remdups (map (signs_at qs) [0])) \\<subseteq>\n    consistent_sign_vectors_R qs UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups (map (signs_at qs) [0]))\n    \\<subseteq> consistent_sign_vectors_R qs UNIV", "unfolding signs_at_def squash_def consistent_sign_vectors_R_def consistent_sign_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups\n          (map (\\<lambda>x.\n                   map ((\\<lambda>x.\n                            if 0 < x then 1\n                            else if x < 0 then - 1 else 0) \\<circ>\n                        (\\<lambda>q. poly q x))\n                    qs)\n            [0]))\n    \\<subseteq> range\n                 (\\<lambda>x.\n                     map (\\<lambda>q.\n                             if 0 < poly q x then 1\n                             else if poly q x = 0 then 0 else - 1)\n                      qs)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>x. if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n         (\\<lambda>q. poly q 0))\n     qs\n    \\<in> range\n           (\\<lambda>x.\n               map (\\<lambda>q.\n                       if 0 < poly q x then 1\n                       else if poly q x = 0 then 0 else - 1)\n                qs)", "by (smt (verit, best) class_ring.ring_simprules(2) comp_def image_iff length_map map_nth_eq_conv)"], ["proof (state)\nthis:\n  set (remdups (map (signs_at qs) [0]))\n  \\<subseteq> consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "have e2: \"consistent_sign_vectors_R qs UNIV \\<subseteq> set (remdups (map (signs_at qs) [0])) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV\n    \\<subseteq> set (remdups (map (signs_at qs) [0]))", "unfolding signs_at_def squash_def consistent_sign_vectors_R_def consistent_sign_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range\n     (\\<lambda>x.\n         map (\\<lambda>q.\n                 if 0 < poly q x then 1\n                 else if poly q x = 0 then 0 else - 1)\n          qs)\n    \\<subseteq> set (remdups\n                      (map (\\<lambda>x.\n                               map ((\\<lambda>x.\n  if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n                                    (\\<lambda>q. poly q x))\n                                qs)\n                        [0]))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. range\n     (\\<lambda>x.\n         map (\\<lambda>q.\n                 if 0 < poly q x then 1\n                 else if poly q x = 0 then 0 else - 1)\n          qs)\n    \\<subseteq> {map ((\\<lambda>x.\n                          if 0 < x then 1\n                          else if x < 0 then - 1 else 0) \\<circ>\n                      (\\<lambda>q. poly q 0))\n                  qs}", "using allconstvar"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set qs. \\<forall>x y. poly p x = poly p y\n\ngoal (1 subgoal):\n 1. range\n     (\\<lambda>x.\n         map (\\<lambda>q.\n                 if 0 < poly q x then 1\n                 else if poly q x = 0 then 0 else - 1)\n          qs)\n    \\<subseteq> {map ((\\<lambda>x.\n                          if 0 < x then 1\n                          else if x < 0 then - 1 else 0) \\<circ>\n                      (\\<lambda>q. poly q 0))\n                  qs}", "by (smt (verit, best) comp_apply image_iff insert_iff map_eq_conv subsetI)"], ["proof (state)\nthis:\n  consistent_sign_vectors_R qs UNIV\n  \\<subseteq> set (remdups (map (signs_at qs) [0]))\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "have \"set (remdups (map (signs_at qs) [0])) =\n    consistent_sign_vectors_R qs UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups (map (signs_at qs) [0])) =\n    consistent_sign_vectors_R qs UNIV", "using e1 e2"], ["proof (prove)\nusing this:\n  set (remdups (map (signs_at qs) [0]))\n  \\<subseteq> consistent_sign_vectors_R qs UNIV\n  consistent_sign_vectors_R qs UNIV\n  \\<subseteq> set (remdups (map (signs_at qs) [0]))\n\ngoal (1 subgoal):\n 1. set (remdups (map (signs_at qs) [0])) =\n    consistent_sign_vectors_R qs UNIV", "by auto"], ["proof (state)\nthis:\n  set (remdups (map (signs_at qs) [0])) = consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "then"], ["proof (chain)\npicking this:\n  set (remdups (map (signs_at qs) [0])) = consistent_sign_vectors_R qs UNIV", "have \"set (characterize_consistent_signs_at_roots [:0, 1:] qs) = consistent_sign_vectors_R qs UNIV\""], ["proof (prove)\nusing this:\n  set (remdups (map (signs_at qs) [0])) = consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots [:0, 1:] qs) =\n    consistent_sign_vectors_R qs UNIV", "unfolding characterize_consistent_signs_at_roots_def characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  set (remdups (map (signs_at qs) [0])) = consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. set (remdups\n          (map (signs_at qs)\n            (sorted_list_of_set {x. poly [:0, 1:] x = 0}))) =\n    consistent_sign_vectors_R qs UNIV", "using rech"], ["proof (prove)\nusing this:\n  set (remdups (map (signs_at qs) [0])) = consistent_sign_vectors_R qs UNIV\n  sorted_list_of_set {x. poly [:0, 1:] x = 0} = [0]\n\ngoal (1 subgoal):\n 1. set (remdups\n          (map (signs_at qs)\n            (sorted_list_of_set {x. poly [:0, 1:] x = 0}))) =\n    consistent_sign_vectors_R qs UNIV", "by auto"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots [:0, 1:] qs) =\n  consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "then"], ["proof (chain)\npicking this:\n  set (characterize_consistent_signs_at_roots [:0, 1:] qs) =\n  consistent_sign_vectors_R qs UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots [:0, 1:] qs) =\n  consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "using same poly_f_is"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots [:0, 1:] qs) =\n  consistent_sign_vectors_R qs UNIV\n  set (find_consistent_signs_at_roots_R [:0, 1:] qs) =\n  set (characterize_consistent_signs_at_roots [:0, 1:] qs)\n  poly_f qs = [:0, 1:]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "unfolding find_consistent_signs_R_def"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots [:0, 1:] qs) =\n  consistent_sign_vectors_R qs UNIV\n  set (find_consistent_signs_at_roots_R [:0, 1:] qs) =\n  set (characterize_consistent_signs_at_roots [:0, 1:] qs)\n  poly_f qs = [:0, 1:]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R (poly_f qs) qs) =\n    consistent_sign_vectors_R qs UNIV", "by auto"], ["proof (state)\nthis:\n  set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_list_lemma_var:\n  fixes l:: \"real list\"\n  fixes x:: \"real\"\n  assumes \"length l > 1\"\n  assumes strict_sort: \"strict_sorted l\"\n  assumes x_not_in: \"\\<not> (List.member l x)\"\n  assumes lt_a: \"x > (l ! 0)\"\n  assumes b_lt: \"x < (l ! (length l - 1))\"\n  shows \"(\\<exists>n. n < length l - 1 \\<and> x > l ! n \\<and> x < l !(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n<length l - 1. l ! n < x \\<and> x < l ! (n + 1)", "using assms"], ["proof (prove)\nusing this:\n  1 < length l\n  strict_sorted l\n  \\<not> List.member l x\n  l ! 0 < x\n  x < l ! (length l - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length l - 1. l ! n < x \\<and> x < l ! (n + 1)", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 < length []; strict_sorted []; \\<not> List.member [] x;\n     [] ! 0 < x; x < [] ! (length [] - 1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length [] - 1.\n                         [] ! n < x \\<and> x < [] ! (n + 1)\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>1 < length l; strict_sorted l;\n                 \\<not> List.member l x; l ! 0 < x;\n                 x < l ! (length l - 1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n<length l - 1.\n                                     l ! n < x \\<and> x < l ! (n + 1);\n        1 < length (a # l); strict_sorted (a # l);\n        \\<not> List.member (a # l) x; (a # l) ! 0 < x;\n        x < (a # l) ! (length (a # l) - 1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length (a # l) - 1.\n                            (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "case Nil"], ["proof (state)\nthis:\n  1 < length []\n  strict_sorted []\n  \\<not> List.member [] x\n  [] ! 0 < x\n  x < [] ! (length [] - 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 < length []; strict_sorted []; \\<not> List.member [] x;\n     [] ! 0 < x; x < [] ! (length [] - 1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length [] - 1.\n                         [] ! n < x \\<and> x < [] ! (n + 1)\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>1 < length l; strict_sorted l;\n                 \\<not> List.member l x; l ! 0 < x;\n                 x < l ! (length l - 1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n<length l - 1.\n                                     l ! n < x \\<and> x < l ! (n + 1);\n        1 < length (a # l); strict_sorted (a # l);\n        \\<not> List.member (a # l) x; (a # l) ! 0 < x;\n        x < (a # l) ! (length (a # l) - 1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length (a # l) - 1.\n                            (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "then"], ["proof (chain)\npicking this:\n  1 < length []\n  strict_sorted []\n  \\<not> List.member [] x\n  [] ! 0 < x\n  x < [] ! (length [] - 1)", "show ?case"], ["proof (prove)\nusing this:\n  1 < length []\n  strict_sorted []\n  \\<not> List.member [] x\n  [] ! 0 < x\n  x < [] ! (length [] - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length [] - 1. [] ! n < x \\<and> x < [] ! (n + 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>n<length [] - 1. [] ! n < x \\<and> x < [] ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>1 < length l; strict_sorted l;\n                 \\<not> List.member l x; l ! 0 < x;\n                 x < l ! (length l - 1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n<length l - 1.\n                                     l ! n < x \\<and> x < l ! (n + 1);\n        1 < length (a # l); strict_sorted (a # l);\n        \\<not> List.member (a # l) x; (a # l) ! 0 < x;\n        x < (a # l) ! (length (a # l) - 1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length (a # l) - 1.\n                            (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>1 < length l; strict_sorted l;\n                 \\<not> List.member l x; l ! 0 < x;\n                 x < l ! (length l - 1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n<length l - 1.\n                                     l ! n < x \\<and> x < l ! (n + 1);\n        1 < length (a # l); strict_sorted (a # l);\n        \\<not> List.member (a # l) x; (a # l) ! 0 < x;\n        x < (a # l) ! (length (a # l) - 1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length (a # l) - 1.\n                            (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "case (Cons a l)"], ["proof (state)\nthis:\n  \\<lbrakk>1 < length l; strict_sorted l; \\<not> List.member l x; l ! 0 < x;\n   x < l ! (length l - 1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n<length l - 1.\n                       l ! n < x \\<and> x < l ! (n + 1)\n  1 < length (a # l)\n  strict_sorted (a # l)\n  \\<not> List.member (a # l) x\n  (a # l) ! 0 < x\n  x < (a # l) ! (length (a # l) - 1)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>1 < length l; strict_sorted l;\n                 \\<not> List.member l x; l ! 0 < x;\n                 x < l ! (length l - 1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n<length l - 1.\n                                     l ! n < x \\<and> x < l ! (n + 1);\n        1 < length (a # l); strict_sorted (a # l);\n        \\<not> List.member (a # l) x; (a # l) ! 0 < x;\n        x < (a # l) ! (length (a # l) - 1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length (a # l) - 1.\n                            (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "have len_gteq: \"length l \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> length l", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  1 < length (a # l)\n\ngoal (1 subgoal):\n 1. 1 \\<le> length l", "by (metis One_nat_def Suc_eq_plus1 list.size(4) not_le not_less_eq)"], ["proof (state)\nthis:\n  1 \\<le> length l\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>1 < length l; strict_sorted l;\n                 \\<not> List.member l x; l ! 0 < x;\n                 x < l ! (length l - 1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n<length l - 1.\n                                     l ! n < x \\<and> x < l ! (n + 1);\n        1 < length (a # l); strict_sorted (a # l);\n        \\<not> List.member (a # l) x; (a # l) ! 0 < x;\n        x < (a # l) ! (length (a # l) - 1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length (a # l) - 1.\n                            (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "have len_one: \"length l = 1 \\<Longrightarrow> (\\<exists>n. n < length (a#l) - 1 \\<and> x > (a#l) ! n \\<and> x < (a#l) !(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = 1 \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length l = 1 \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "assume len_is: \"length l = 1\""], ["proof (state)\nthis:\n  length l = 1\n\ngoal (1 subgoal):\n 1. length l = 1 \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "then"], ["proof (chain)\npicking this:\n  length l = 1", "have \"x > (a#l) ! 0 \\<and> x < (a#l) !1 \""], ["proof (prove)\nusing this:\n  length l = 1\n\ngoal (1 subgoal):\n 1. (a # l) ! 0 < x \\<and> x < (a # l) ! 1", "using Cons.prems(4) Cons.prems(5)"], ["proof (prove)\nusing this:\n  length l = 1\n  (a # l) ! 0 < x\n  x < (a # l) ! (length (a # l) - 1)\n\ngoal (1 subgoal):\n 1. (a # l) ! 0 < x \\<and> x < (a # l) ! 1", "by auto"], ["proof (state)\nthis:\n  (a # l) ! 0 < x \\<and> x < (a # l) ! 1\n\ngoal (1 subgoal):\n 1. length l = 1 \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "then"], ["proof (chain)\npicking this:\n  (a # l) ! 0 < x \\<and> x < (a # l) ! 1", "show \"(\\<exists>n. n < length (a#l) - 1 \\<and> x > (a#l) ! n \\<and> x < (a#l) !(n+1))\""], ["proof (prove)\nusing this:\n  (a # l) ! 0 < x \\<and> x < (a # l) ! 1\n\ngoal (1 subgoal):\n 1. \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "using len_is"], ["proof (prove)\nusing this:\n  (a # l) ! 0 < x \\<and> x < (a # l) ! 1\n  length l = 1\n\ngoal (1 subgoal):\n 1. \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length l = 1 \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>1 < length l; strict_sorted l;\n                 \\<not> List.member l x; l ! 0 < x;\n                 x < l ! (length l - 1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n<length l - 1.\n                                     l ! n < x \\<and> x < l ! (n + 1);\n        1 < length (a # l); strict_sorted (a # l);\n        \\<not> List.member (a # l) x; (a # l) ! 0 < x;\n        x < (a # l) ! (length (a # l) - 1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length (a # l) - 1.\n                            (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "have len_gt: \"length l > 1 \\<Longrightarrow> (\\<exists>n. n < length (a#l) - 1 \\<and> x > (a#l) ! n \\<and> x < (a#l) !(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length l \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < length l \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "assume len_gt_one: \"length l > 1\""], ["proof (state)\nthis:\n  1 < length l\n\ngoal (1 subgoal):\n 1. 1 < length l \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "have eo: \"x \\<noteq> l ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> l ! 0", "using Cons.prems(3)"], ["proof (prove)\nusing this:\n  \\<not> List.member (a # l) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> l ! 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> List.member (a # l) (l ! 0); x = l ! 0\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis One_nat_def Suc_lessD in_set_member len_gt_one member_rec(1) nth_mem)"], ["proof (state)\nthis:\n  x \\<noteq> l ! 0\n\ngoal (1 subgoal):\n 1. 1 < length l \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "have c1: \"x < l ! 0 \\<Longrightarrow> (\\<exists>n. n < length (a#l) - 1 \\<and> x > (a#l) ! n \\<and> x < (a#l) !(n+1)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < l ! 0 \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < l ! 0 \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "assume xlt: \"x < l !0\""], ["proof (state)\nthis:\n  x < l ! 0\n\ngoal (1 subgoal):\n 1. x < l ! 0 \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "then"], ["proof (chain)\npicking this:\n  x < l ! 0", "have \"x < (a#l) ! 1 \""], ["proof (prove)\nusing this:\n  x < l ! 0\n\ngoal (1 subgoal):\n 1. x < (a # l) ! 1", "by simp"], ["proof (state)\nthis:\n  x < (a # l) ! 1\n\ngoal (1 subgoal):\n 1. x < l ! 0 \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "then"], ["proof (chain)\npicking this:\n  x < (a # l) ! 1", "show ?thesis"], ["proof (prove)\nusing this:\n  x < (a # l) ! 1\n\ngoal (1 subgoal):\n 1. \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "using  Cons.prems(4) len_gt_one"], ["proof (prove)\nusing this:\n  x < (a # l) ! 1\n  (a # l) ! 0 < x\n  1 < length l\n\ngoal (1 subgoal):\n 1. \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < l ! 0; a < x; Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length l. (a # l) ! n < x \\<and> x < l ! n", "using Cons.prems(4) Suc_lessD"], ["proof (prove)\nusing this:\n  (a # l) ! 0 < x\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < l ! 0; a < x; Suc 0 < length l\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length l. (a # l) ! n < x \\<and> x < l ! n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < l ! 0 \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal (1 subgoal):\n 1. 1 < length l \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "have c2: \"x > l ! 0 \\<Longrightarrow> (\\<exists>n. n < length (a#l) - 1 \\<and> x > (a#l) ! n \\<and> x < (a#l) !(n+1)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. l ! 0 < x \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l ! 0 < x \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "assume asm: \"x > l ! 0\""], ["proof (state)\nthis:\n  l ! 0 < x\n\ngoal (1 subgoal):\n 1. l ! 0 < x \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "have xlt_1: \" x < l ! (length l - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < l ! (length l - 1)", "using Cons.prems(5)"], ["proof (prove)\nusing this:\n  x < (a # l) ! (length (a # l) - 1)\n\ngoal (1 subgoal):\n 1. x < l ! (length l - 1)", "by (metis Cons.prems(1) One_nat_def add_diff_cancel_right' list.size(4) nth_Cons_pos zero_less_diff)"], ["proof (state)\nthis:\n  x < l ! (length l - 1)\n\ngoal (1 subgoal):\n 1. l ! 0 < x \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "have ssl: \"strict_sorted l \""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted l", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  strict_sorted (a # l)\n\ngoal (1 subgoal):\n 1. strict_sorted l", "using strict_sorted.simps(2)"], ["proof (prove)\nusing this:\n  strict_sorted (a # l)\n  strict_sorted (?x # ?ys) =\n  (Ball (set ?ys) ((<) ?x) \\<and> strict_sorted ?ys)\n\ngoal (1 subgoal):\n 1. strict_sorted l", "by blast"], ["proof (state)\nthis:\n  strict_sorted l\n\ngoal (1 subgoal):\n 1. l ! 0 < x \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "have \" \\<not> List.member l x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> List.member l x", "using Cons.prems(3)"], ["proof (prove)\nusing this:\n  \\<not> List.member (a # l) x\n\ngoal (1 subgoal):\n 1. \\<not> List.member l x", "by (meson member_rec(1))"], ["proof (state)\nthis:\n  \\<not> List.member l x\n\ngoal (1 subgoal):\n 1. l ! 0 < x \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "then"], ["proof (chain)\npicking this:\n  \\<not> List.member l x", "have \" \\<exists>n<length l - 1. l ! n < x \\<and> x < l ! (n + 1)\""], ["proof (prove)\nusing this:\n  \\<not> List.member l x\n\ngoal (1 subgoal):\n 1. \\<exists>n<length l - 1. l ! n < x \\<and> x < l ! (n + 1)", "using asm xlt_1 len_gt_one ssl Cons.hyps"], ["proof (prove)\nusing this:\n  \\<not> List.member l x\n  l ! 0 < x\n  x < l ! (length l - 1)\n  1 < length l\n  strict_sorted l\n  \\<lbrakk>1 < length l; strict_sorted l; \\<not> List.member l x; l ! 0 < x;\n   x < l ! (length l - 1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n<length l - 1.\n                       l ! n < x \\<and> x < l ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length l - 1. l ! n < x \\<and> x < l ! (n + 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>n<length l - 1. l ! n < x \\<and> x < l ! (n + 1)\n\ngoal (1 subgoal):\n 1. l ! 0 < x \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n<length l - 1. l ! n < x \\<and> x < l ! (n + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>n<length l - 1. l ! n < x \\<and> x < l ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "by (metis One_nat_def Suc_eq_plus1 diff_Suc_1 less_diff_conv list.size(4) nth_Cons_Suc)"], ["proof (state)\nthis:\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l ! 0 < x \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal (1 subgoal):\n 1. 1 < length l \\<Longrightarrow>\n    \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "show \"(\\<exists>n. n < length (a#l) - 1 \\<and> x > (a#l) ! n \\<and> x < (a#l) !(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "using eo c1 c2"], ["proof (prove)\nusing this:\n  x \\<noteq> l ! 0\n  x < l ! 0 \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n  l ! 0 < x \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "by (meson linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 < length l \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>1 < length l; strict_sorted l;\n                 \\<not> List.member l x; l ! 0 < x;\n                 x < l ! (length l - 1)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>n<length l - 1.\n                                     l ! n < x \\<and> x < l ! (n + 1);\n        1 < length (a # l); strict_sorted (a # l);\n        \\<not> List.member (a # l) x; (a # l) ! 0 < x;\n        x < (a # l) ! (length (a # l) - 1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length (a # l) - 1.\n                            (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "then"], ["proof (chain)\npicking this:\n  1 < length l \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "show ?case"], ["proof (prove)\nusing this:\n  1 < length l \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "using len_gteq len_one len_gt"], ["proof (prove)\nusing this:\n  1 < length l \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n  1 \\<le> length l\n  length l = 1 \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n  1 < length l \\<Longrightarrow>\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length (a # l) - 1.\n       (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < length l \\<Longrightarrow>\n             \\<exists>n<length l. (a # l) ! n < x \\<and> x < l ! n;\n     Suc 0 \\<le> length l;\n     length l = Suc 0 \\<Longrightarrow> a < x \\<and> x < l ! 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length l. (a # l) ! n < x \\<and> x < l ! n", "by (metis One_nat_def less_numeral_extra(1) linorder_neqE_nat not_less nth_Cons_0)"], ["proof (state)\nthis:\n  \\<exists>n<length (a # l) - 1.\n     (a # l) ! n < x \\<and> x < (a # l) ! (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* We want to show that our auxiliary polynomial has roots in all relevant intervals:\n so it captures all of the zeros, and also it captures all of the points in between! *)"], ["", "lemma all_sample_points_prop:\n  assumes is_not_const: \"check_all_const_deg qs = False\"\n  assumes s_is: \"S = (characterize_root_list_p (pderiv (prod_list_var qs) * (prod_list_var qs) * ([:-(crb (prod_list_var qs)),1:]) * ([:(crb (prod_list_var qs)),1:])))\"(* properties about S*)\n  shows \"consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)", "let ?zer_list = \"sorted_list_of_set {(x::real). (\\<exists>q \\<in> set(qs). (q \\<noteq> 0 \\<and> poly q x = 0))} :: real list\""], ["proof (state)\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)", "have strict_sorted_h: \"strict_sorted ?zer_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})", "using sorted_sorted_list_of_set\n      strict_sorted_iff"], ["proof (prove)\nusing this:\n  sorted (sorted_list_of_set ?A)\n  strict_sorted ?l = (sorted ?l \\<and> distinct ?l)\n\ngoal (1 subgoal):\n 1. strict_sorted\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})", "by auto"], ["proof (state)\nthis:\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)", "have poly_f_is: \"poly_f qs  = (pderiv (prod_list_var qs) * prod_list_var qs)* ([:-(crb (prod_list_var qs)),1:]) * ([:(crb (prod_list_var qs)),1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_f qs =\n    pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:]", "unfolding poly_f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if check_all_const_deg qs = True then [:0, 1:]\n     else pderiv (prod_list_var qs) * prod_list_var qs *\n          [:real_of_int (- crb (prod_list_var qs)), 1:] *\n          [:real_of_int (crb (prod_list_var qs)), 1:]) =\n    pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:]", "using is_not_const"], ["proof (prove)\nusing this:\n  check_all_const_deg qs = False\n\ngoal (1 subgoal):\n 1. (if check_all_const_deg qs = True then [:0, 1:]\n     else pderiv (prod_list_var qs) * prod_list_var qs *\n          [:real_of_int (- crb (prod_list_var qs)), 1:] *\n          [:real_of_int (crb (prod_list_var qs)), 1:]) =\n    pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:]", "by auto"], ["proof (state)\nthis:\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)", "then"], ["proof (chain)\npicking this:\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]", "have set_S_char: \"set S = ({x. poly (poly_f qs) x = 0}::real set)\""], ["proof (prove)\nusing this:\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n\ngoal (1 subgoal):\n 1. set S = {x. poly (poly_f qs) x = 0}", "using poly_roots_finite[of \"poly_f qs\"] set_sorted_list_of_set poly_f_nonzero[of qs]"], ["proof (prove)\nusing this:\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n  poly_f qs \\<noteq> 0 \\<Longrightarrow> finite {x. poly (poly_f qs) x = 0}\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  poly_f qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set S = {x. poly (poly_f qs) x = 0}", "using s_is"], ["proof (prove)\nusing this:\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n  poly_f qs \\<noteq> 0 \\<Longrightarrow> finite {x. poly (poly_f qs) x = 0}\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  poly_f qs \\<noteq> 0\n  S =\n  characterize_root_list_p\n   (pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:])\n\ngoal (1 subgoal):\n 1. set S = {x. poly (poly_f qs) x = 0}", "unfolding characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n  poly_f qs \\<noteq> 0 \\<Longrightarrow> finite {x. poly (poly_f qs) x = 0}\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  poly_f qs \\<noteq> 0\n  S =\n  sorted_list_of_set\n   {x. poly\n        (pderiv (prod_list_var qs) * prod_list_var qs *\n         [:real_of_int (- crb (prod_list_var qs)), 1:] *\n         [:real_of_int (crb (prod_list_var qs)), 1:])\n        x =\n       0}\n\ngoal (1 subgoal):\n 1. set S = {x. poly (poly_f qs) x = 0}", "by auto"], ["proof (state)\nthis:\n  set S = {x. poly (poly_f qs) x = 0}\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)", "have difficult_direction: \"consistent_sign_vectors_R qs UNIV \\<subseteq> consistent_sign_vectors_R qs (set S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV\n    \\<subseteq> consistent_sign_vectors_R qs (set S)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> consistent_sign_vectors_R qs UNIV \\<Longrightarrow>\n       x \\<in> consistent_sign_vectors_R qs (set S)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> consistent_sign_vectors_R qs UNIV \\<Longrightarrow>\n       x \\<in> consistent_sign_vectors_R qs (set S)", "assume \"x \\<in> consistent_sign_vectors_R qs UNIV \""], ["proof (state)\nthis:\n  x \\<in> consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> consistent_sign_vectors_R qs UNIV \\<Longrightarrow>\n       x \\<in> consistent_sign_vectors_R qs (set S)", "then"], ["proof (chain)\npicking this:\n  x \\<in> consistent_sign_vectors_R qs UNIV", "have \"\\<exists>y. x  = (consistent_sign_vec qs y)\""], ["proof (prove)\nusing this:\n  x \\<in> consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>y. x = consistent_sign_vec qs y", "unfolding consistent_sign_vectors_R_def"], ["proof (prove)\nusing this:\n  x \\<in> range (consistent_sign_vec qs)\n\ngoal (1 subgoal):\n 1. \\<exists>y. x = consistent_sign_vec qs y", "by auto"], ["proof (state)\nthis:\n  \\<exists>y. x = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> consistent_sign_vectors_R qs UNIV \\<Longrightarrow>\n       x \\<in> consistent_sign_vectors_R qs (set S)", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. x = consistent_sign_vec qs y", "obtain y where y_prop: \"x = consistent_sign_vec qs y\""], ["proof (prove)\nusing this:\n  \\<exists>y. x = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        x = consistent_sign_vec qs y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> consistent_sign_vectors_R qs UNIV \\<Longrightarrow>\n       x \\<in> consistent_sign_vectors_R qs (set S)", "then"], ["proof (chain)\npicking this:\n  x = consistent_sign_vec qs y", "have \"\\<exists> k \\<in> (set S). consistent_sign_vec qs k = consistent_sign_vec qs y\""], ["proof (prove)\nusing this:\n  x = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = consistent_sign_vec qs y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have c1: \"(\\<exists>q \\<in> (set qs). q \\<noteq> 0 \\<and> poly q y = 0) \\<Longrightarrow> (\\<exists> k \\<in> (set S). consistent_sign_vec qs k = consistent_sign_vec qs y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs.\n       q \\<noteq> 0 \\<and> poly q y = 0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs.\n       q \\<noteq> 0 \\<and> poly q y = 0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "assume \"(\\<exists>q \\<in> (set qs). q \\<noteq> 0 \\<and> poly q y = 0)\""], ["proof (state)\nthis:\n  \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs.\n       q \\<noteq> 0 \\<and> poly q y = 0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0", "obtain q where \"q \\<in> (set qs) \\<and> q \\<noteq> 0 \\<and> poly q y = 0\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> set qs \\<and>\n        q \\<noteq> 0 \\<and> poly q y = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> set qs \\<and> q \\<noteq> 0 \\<and> poly q y = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs.\n       q \\<noteq> 0 \\<and> poly q y = 0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  q \\<in> set qs \\<and> q \\<noteq> 0 \\<and> poly q y = 0", "have \"poly (prod_list_var qs) y = 0\""], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> q \\<noteq> 0 \\<and> poly q y = 0\n\ngoal (1 subgoal):\n 1. poly (prod_list_var qs) y = 0", "using q_dvd_prod_list_var_prop[of q qs]"], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> q \\<noteq> 0 \\<and> poly q y = 0\n  \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q dvd prod_list_var qs\n\ngoal (1 subgoal):\n 1. poly (prod_list_var qs) y = 0", "by auto"], ["proof (state)\nthis:\n  poly (prod_list_var qs) y = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs.\n       q \\<noteq> 0 \\<and> poly q y = 0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  poly (prod_list_var qs) y = 0", "have \"poly (pderiv (prod_list_var qs) * (prod_list_var qs)*([:-(crb (prod_list_var qs)),1:]) * ([:(crb (prod_list_var qs)),1:])) y = 0\""], ["proof (prove)\nusing this:\n  poly (prod_list_var qs) y = 0\n\ngoal (1 subgoal):\n 1. poly\n     (pderiv (prod_list_var qs) * prod_list_var qs *\n      [:real_of_int (- crb (prod_list_var qs)), 1:] *\n      [:real_of_int (crb (prod_list_var qs)), 1:])\n     y =\n    0", "by auto"], ["proof (state)\nthis:\n  poly\n   (pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:])\n   y =\n  0\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs.\n       q \\<noteq> 0 \\<and> poly q y = 0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  poly\n   (pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:])\n   y =\n  0", "have \"y \\<in> (set S)\""], ["proof (prove)\nusing this:\n  poly\n   (pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:])\n   y =\n  0\n\ngoal (1 subgoal):\n 1. y \\<in> set S", "using s_is"], ["proof (prove)\nusing this:\n  poly\n   (pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:])\n   y =\n  0\n  S =\n  characterize_root_list_p\n   (pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:])\n\ngoal (1 subgoal):\n 1. y \\<in> set S", "unfolding characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  poly\n   (pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:])\n   y =\n  0\n  S =\n  sorted_list_of_set\n   {x. poly\n        (pderiv (prod_list_var qs) * prod_list_var qs *\n         [:real_of_int (- crb (prod_list_var qs)), 1:] *\n         [:real_of_int (crb (prod_list_var qs)), 1:])\n        x =\n       0}\n\ngoal (1 subgoal):\n 1. y \\<in> set S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly\n              (pderiv (prod_list_var qs) * prod_list_var qs *\n               [:real_of_int (- crb (prod_list_var qs)), 1:] *\n               [:real_of_int (crb (prod_list_var qs)), 1:])\n              y =\n             0;\n     S =\n     sorted_list_of_set\n      {x. poly\n           (pderiv (prod_list_var qs) * prod_list_var qs *\n            [:real_of_int (- crb (prod_list_var qs)), 1:] *\n            [:real_of_int (crb (prod_list_var qs)), 1:])\n           x =\n          0}\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set S", "have \"y \\<in> {r. poly (pderiv (prod_list_var qs) * (prod_list_var qs)*([:-(crb (prod_list_var qs)),1:]) * ([:(crb (prod_list_var qs)),1:])) r = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {r. poly\n                 (pderiv (prod_list_var qs) * prod_list_var qs *\n                  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n                  [:real_of_int (crb (prod_list_var qs)), 1:])\n                 r =\n                0}", "using \\<open>poly (pderiv (prod_list_var qs) * (prod_list_var qs)*([:-(crb (prod_list_var qs)),1:]) * ([:(crb (prod_list_var qs)),1:])) y = 0\\<close>"], ["proof (prove)\nusing this:\n  poly\n   (pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:])\n   y =\n  0\n\ngoal (1 subgoal):\n 1. y \\<in> {r. poly\n                 (pderiv (prod_list_var qs) * prod_list_var qs *\n                  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n                  [:real_of_int (crb (prod_list_var qs)), 1:])\n                 r =\n                0}", "by force"], ["proof (state)\nthis:\n  y \\<in> {r. poly\n               (pderiv (prod_list_var qs) * prod_list_var qs *\n                [:real_of_int (- crb (prod_list_var qs)), 1:] *\n                [:real_of_int (crb (prod_list_var qs)), 1:])\n               r =\n              0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>poly\n              (pderiv (prod_list_var qs) * prod_list_var qs *\n               [:real_of_int (- crb (prod_list_var qs)), 1:] *\n               [:real_of_int (crb (prod_list_var qs)), 1:])\n              y =\n             0;\n     S =\n     sorted_list_of_set\n      {x. poly\n           (pderiv (prod_list_var qs) * prod_list_var qs *\n            [:real_of_int (- crb (prod_list_var qs)), 1:] *\n            [:real_of_int (crb (prod_list_var qs)), 1:])\n           x =\n          0}\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set S", "then"], ["proof (chain)\npicking this:\n  y \\<in> {r. poly\n               (pderiv (prod_list_var qs) * prod_list_var qs *\n                [:real_of_int (- crb (prod_list_var qs)), 1:] *\n                [:real_of_int (crb (prod_list_var qs)), 1:])\n               r =\n              0}", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> {r. poly\n               (pderiv (prod_list_var qs) * prod_list_var qs *\n                [:real_of_int (- crb (prod_list_var qs)), 1:] *\n                [:real_of_int (crb (prod_list_var qs)), 1:])\n               r =\n              0}\n\ngoal (1 subgoal):\n 1. y \\<in> set S", "by (metis characterize_root_list_p_def is_not_const poly_f_def poly_f_nonzero poly_roots_finite s_is set_sorted_list_of_set)"], ["proof (state)\nthis:\n  y \\<in> set S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> set S\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs.\n       q \\<noteq> 0 \\<and> poly q y = 0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  y \\<in> set S", "show \"\\<exists> k \\<in> (set S). consistent_sign_vec qs k = consistent_sign_vec qs y\""], ["proof (prove)\nusing this:\n  y \\<in> set S\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "by auto"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0 \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. x = consistent_sign_vec qs y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have len_gtz_prop: \"length ?zer_list > 0 \\<longrightarrow>\n            ((\\<exists>w. w < length ?zer_list \\<and> y = ?zer_list ! w) \\<or>\n             (y < ?zer_list ! 0) \\<or> \n             (y > ?zer_list ! (length ?zer_list - 1)) \\<or> \n             (\\<exists>k < (length ?zer_list - 1). y > ?zer_list ! k  \\<and> y < ?zer_list ! (k+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "let ?c = \"(\\<exists>w. w < length ?zer_list \\<and> y = ?zer_list ! w) \\<or>\n             (y < ?zer_list ! 0) \\<or> \n             (y > ?zer_list ! (length ?zer_list - 1)) \\<or> \n             (\\<exists>k < (length ?zer_list - 1). y > ?zer_list ! k  \\<and> y < ?zer_list ! (k+1))\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "have lis1: \"length ?zer_list = 1 \\<Longrightarrow> ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n    1 \\<Longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "by auto"], ["proof (state)\nthis:\n  length\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n  1 \\<Longrightarrow>\n  (\\<exists>w<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}).\n      y =\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      w) \\<or>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<or>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<or>\n  (\\<exists>k<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1.\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      k\n      < y \\<and>\n      y < sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (k + 1))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "have h1: \"\\<not>(\\<exists>w. w < length ?zer_list \\<and> y = ?zer_list ! w) \\<Longrightarrow> \\<not> (List.member ?zer_list y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>w<length\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs.\n                                 q \\<noteq> 0 \\<and> poly q x = 0}).\n               y =\n               sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               w) \\<Longrightarrow>\n    \\<not> List.member\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n            y", "by (metis (no_types, lifting) in_set_conv_nth in_set_member)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n          y\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "have h2: \"(length ?zer_list > 0 \\<and> \\<not>(\\<exists>w. w < length ?zer_list \\<and> y = ?zer_list ! w) \\<and> \\<not> (y < ?zer_list ! 0)) \\<Longrightarrow> y > ?zer_list ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n    \\<not> (\\<exists>w<length\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs.\n                                 q \\<noteq> 0 \\<and> poly q x = 0}).\n               y =\n               sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               w) \\<and>\n    \\<not> y < sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               0 \\<Longrightarrow>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0\n    < y", "by auto"], ["proof (state)\nthis:\n  0 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<and>\n  \\<not> y < sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             0 \\<Longrightarrow>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  < y\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "have h3: \"(length ?zer_list > 1 \\<and> \\<not>(\\<exists>w. w < length ?zer_list \\<and> y = ?zer_list ! w) \\<and>  \\<not> (y > ?zer_list ! (length ?zer_list - 1))) \\<Longrightarrow>\n          y < ?zer_list ! (length ?zer_list - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n    \\<not> (\\<exists>w<length\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs.\n                                 q \\<noteq> 0 \\<and> poly q x = 0}).\n               y =\n               sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               w) \\<and>\n    \\<not> sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs.\n                      q \\<noteq> 0 \\<and> poly q x = 0}) -\n            1)\n           < y \\<Longrightarrow>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        (length\n          (sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n         1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0\n             < card\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0};\n     \\<forall>w<card\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}.\n        y \\<noteq>\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w;\n     \\<not> sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (card\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} -\n             Suc 0)\n            < y\\<rbrakk>\n    \\<Longrightarrow> y < sorted_list_of_set\n                           {x. \\<exists>q\\<in>set qs.\n                                  q \\<noteq> 0 \\<and> poly q x = 0} !\n                          (card\n                            {x. \\<exists>q\\<in>set qs.\n                                   q \\<noteq> 0 \\<and> poly q x = 0} -\n                           Suc 0)", "by (smt (z3) diff_Suc_less gr_implies_not0 not_gr_zero)"], ["proof (state)\nthis:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<and>\n  \\<not> sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (length\n           (sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n          1)\n         < y \\<Longrightarrow>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (length\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n       1)\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "have \"length ?zer_list > 1 \\<and> \\<not>(\\<exists>w. w < length ?zer_list \\<and> y = ?zer_list ! w) \\<and> \\<not> (y < ?zer_list ! 0) \\<and> \\<not> (y > ?zer_list ! (length ?zer_list - 1))\n              \\<Longrightarrow>  (\\<exists>k < (length ?zer_list - 1). y > ?zer_list ! k  \\<and> y < ?zer_list ! (k+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n    \\<not> (\\<exists>w<length\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs.\n                                 q \\<noteq> 0 \\<and> poly q x = 0}).\n               y =\n               sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               w) \\<and>\n    \\<not> y < sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               0 \\<and>\n    \\<not> sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs.\n                      q \\<noteq> 0 \\<and> poly q x = 0}) -\n            1)\n           < y \\<Longrightarrow>\n    \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1)", "using h1 h2 h3 strict_sorted_h sorted_list_lemma_var[of ?zer_list y]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n          y\n  0 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<and>\n  \\<not> y < sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             0 \\<Longrightarrow>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  < y\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<and>\n  \\<not> sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (length\n           (sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n          1)\n         < y \\<Longrightarrow>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (length\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n       1)\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n  \\<lbrakk>1 < length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0});\n   strict_sorted\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0});\n   \\<not> List.member\n           (sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n           y;\n   sorted_list_of_set\n    {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n   0\n   < y;\n   y < sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n        1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n<length\n                                (sorted_list_of_set\n                                  {x. \\<exists>q\\<in>set qs.\n   q \\<noteq> 0 \\<and> poly q x = 0}) -\n                               1.\n                       sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0} !\n                       n\n                       < y \\<and>\n                       y < sorted_list_of_set\n                            {x. \\<exists>q\\<in>set qs.\n                                   q \\<noteq> 0 \\<and> poly q x = 0} !\n                           (n + 1)\n\ngoal (1 subgoal):\n 1. 1 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n    \\<not> (\\<exists>w<length\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs.\n                                 q \\<noteq> 0 \\<and> poly q x = 0}).\n               y =\n               sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               w) \\<and>\n    \\<not> y < sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               0 \\<and>\n    \\<not> sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs.\n                      q \\<noteq> 0 \\<and> poly q x = 0}) -\n            1)\n           < y \\<Longrightarrow>\n    \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1)", "using One_nat_def Suc_lessD"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n          y\n  0 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<and>\n  \\<not> y < sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             0 \\<Longrightarrow>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  < y\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<and>\n  \\<not> sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (length\n           (sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n          1)\n         < y \\<Longrightarrow>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (length\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n       1)\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n  \\<lbrakk>1 < length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0});\n   strict_sorted\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0});\n   \\<not> List.member\n           (sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n           y;\n   sorted_list_of_set\n    {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n   0\n   < y;\n   y < sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n        1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n<length\n                                (sorted_list_of_set\n                                  {x. \\<exists>q\\<in>set qs.\n   q \\<noteq> 0 \\<and> poly q x = 0}) -\n                               1.\n                       sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0} !\n                       n\n                       < y \\<and>\n                       y < sorted_list_of_set\n                            {x. \\<exists>q\\<in>set qs.\n                                   q \\<noteq> 0 \\<and> poly q x = 0} !\n                           (n + 1)\n  1 = Suc 0\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n\ngoal (1 subgoal):\n 1. 1 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n    \\<not> (\\<exists>w<length\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs.\n                                 q \\<noteq> 0 \\<and> poly q x = 0}).\n               y =\n               sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               w) \\<and>\n    \\<not> y < sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               0 \\<and>\n    \\<not> sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs.\n                      q \\<noteq> 0 \\<and> poly q x = 0}) -\n            1)\n           < y \\<Longrightarrow>\n    \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1)", "by presburger"], ["proof (state)\nthis:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<and>\n  \\<not> y < sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             0 \\<and>\n  \\<not> sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (length\n           (sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n          1)\n         < y \\<Longrightarrow>\n  \\<exists>k<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < y \\<and>\n     y < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1)\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "then"], ["proof (chain)\npicking this:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<and>\n  \\<not> y < sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             0 \\<and>\n  \\<not> sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (length\n           (sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n          1)\n         < y \\<Longrightarrow>\n  \\<exists>k<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < y \\<and>\n     y < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1)", "have lgt1: \"length ?zer_list > 1 \\<Longrightarrow> ?c\""], ["proof (prove)\nusing this:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  \\<not> (\\<exists>w<length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}).\n             y =\n             sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             w) \\<and>\n  \\<not> y < sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             0 \\<and>\n  \\<not> sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (length\n           (sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n          1)\n         < y \\<Longrightarrow>\n  \\<exists>k<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < y \\<and>\n     y < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1)\n\ngoal (1 subgoal):\n 1. 1 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "by auto"], ["proof (state)\nthis:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n  (\\<exists>w<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}).\n      y =\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      w) \\<or>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<or>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<or>\n  (\\<exists>k<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1.\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      k\n      < y \\<and>\n      y < sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (k + 1))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "then"], ["proof (chain)\npicking this:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n  (\\<exists>w<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}).\n      y =\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      w) \\<or>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<or>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<or>\n  (\\<exists>k<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1.\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      k\n      < y \\<and>\n      y < sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (k + 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n  (\\<exists>w<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}).\n      y =\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      w) \\<or>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<or>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<or>\n  (\\<exists>k<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1.\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      k\n      < y \\<and>\n      y < sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (k + 1))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "using lis1 lgt1"], ["proof (prove)\nusing this:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n  (\\<exists>w<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}).\n      y =\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      w) \\<or>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<or>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<or>\n  (\\<exists>k<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1.\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      k\n      < y \\<and>\n      y < sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (k + 1))\n  length\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n  1 \\<Longrightarrow>\n  (\\<exists>w<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}).\n      y =\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      w) \\<or>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<or>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<or>\n  (\\<exists>k<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1.\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      k\n      < y \\<and>\n      y < sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (k + 1))\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n  (\\<exists>w<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}).\n      y =\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      w) \\<or>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<or>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<or>\n  (\\<exists>k<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1.\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      k\n      < y \\<and>\n      y < sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (k + 1))\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n    (\\<exists>w<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}).\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w) \\<or>\n    y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<or>\n    sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<or>\n    (\\<exists>k<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}) -\n                1.\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1))", "by (smt (z3) diff_is_0_eq' not_less)"], ["proof (state)\nthis:\n  0 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n  (\\<exists>w<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}).\n      y =\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      w) \\<or>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<or>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<or>\n  (\\<exists>k<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1.\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      k\n      < y \\<and>\n      y < sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (k + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n  (\\<exists>w<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}).\n      y =\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      w) \\<or>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<or>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<or>\n  (\\<exists>k<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1.\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      k\n      < y \\<and>\n      y < sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (k + 1))\n\ngoal (1 subgoal):\n 1. x = consistent_sign_vec qs y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have neg_crb_in: \"(- crb (prod_list_var qs)) \\<in> set S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (- crb (prod_list_var qs)) \\<in> set S", "using set_S_char poly_f_is"], ["proof (prove)\nusing this:\n  set S = {x. poly (poly_f qs) x = 0}\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n\ngoal (1 subgoal):\n 1. real_of_int (- crb (prod_list_var qs)) \\<in> set S", "by auto"], ["proof (state)\nthis:\n  real_of_int (- crb (prod_list_var qs)) \\<in> set S\n\ngoal (1 subgoal):\n 1. x = consistent_sign_vec qs y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have pos_crb_in: \"(crb (prod_list_var qs)) \\<in> set S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (crb (prod_list_var qs)) \\<in> set S", "using set_S_char poly_f_is"], ["proof (prove)\nusing this:\n  set S = {x. poly (poly_f qs) x = 0}\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n\ngoal (1 subgoal):\n 1. real_of_int (crb (prod_list_var qs)) \\<in> set S", "by auto"], ["proof (state)\nthis:\n  real_of_int (crb (prod_list_var qs)) \\<in> set S\n\ngoal (1 subgoal):\n 1. x = consistent_sign_vec qs y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have set_S_nonempty: \"set S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set S \\<noteq> {}", "using neg_crb_in"], ["proof (prove)\nusing this:\n  real_of_int (- crb (prod_list_var qs)) \\<in> set S\n\ngoal (1 subgoal):\n 1. set S \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  set S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x = consistent_sign_vec qs y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have finset: \"finite  {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "have \"\\<forall>q \\<in> set qs.  q\\<noteq> 0 \\<longrightarrow> finite {x. poly q x = 0} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       q \\<noteq> 0 \\<longrightarrow> finite {x. poly q x = 0}", "using poly_roots_finite"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       q \\<noteq> 0 \\<longrightarrow> finite {x. poly q x = 0}", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow> finite {x. poly q x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow> finite {x. poly q x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow> finite {x. poly q x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "by auto"], ["proof (state)\nthis:\n  finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. x = consistent_sign_vec qs y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have c2: \"\\<not>(\\<exists>q \\<in> (set qs). q \\<noteq> 0 \\<and> poly q y = 0) \\<Longrightarrow> \\<exists> k \\<in> (set S). consistent_sign_vec qs k = consistent_sign_vec qs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>set qs.\n               q \\<noteq> 0 \\<and> poly q y = 0) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>set qs.\n               q \\<noteq> 0 \\<and> poly q y = 0) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "assume \"\\<not>(\\<exists>q \\<in> (set qs). q \\<noteq> 0 \\<and> poly q y = 0)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>set qs.\n               q \\<noteq> 0 \\<and> poly q y = 0) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have c_c1: \"length ?zer_list = 0 \\<Longrightarrow>  \\<exists> k \\<in> (set S). consistent_sign_vec qs k = consistent_sign_vec qs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n    0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n    0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "assume \"length ?zer_list = 0\""], ["proof (state)\nthis:\n  length\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n  0\n\ngoal (1 subgoal):\n 1. length\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n    0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  length\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n  0", "have \"\\<forall>q \\<in> set (qs). \\<forall> (x:: real). \\<forall>(y::real). squash (poly q x) = squash (poly q y)\""], ["proof (prove)\nusing this:\n  length\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n  0\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       \\<forall>x y. squash (poly q x) = squash (poly q y)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q x y.\n       \\<lbrakk>card\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0} =\n                0;\n        q \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "fix q x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q x y.\n       \\<lbrakk>card\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0} =\n                0;\n        q \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "assume czer: \"card {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = 0\""], ["proof (state)\nthis:\n  card {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = 0\n\ngoal (1 subgoal):\n 1. \\<And>q x y.\n       \\<lbrakk>card\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0} =\n                0;\n        q \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "assume qin: \"q \\<in> set qs\""], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>q x y.\n       \\<lbrakk>card\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0} =\n                0;\n        q \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "have fin_means_empty: \"{x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = {}", "using finset czer"], ["proof (prove)\nusing this:\n  finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n  card {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = 0\n\ngoal (1 subgoal):\n 1. {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = {}", "by auto"], ["proof (state)\nthis:\n  {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = {}\n\ngoal (1 subgoal):\n 1. \\<And>q x y.\n       \\<lbrakk>card\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0} =\n                0;\n        q \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "have qzer: \"q = 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "by auto"], ["proof (state)\nthis:\n  q = 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<And>q x y.\n       \\<lbrakk>card\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0} =\n                0;\n        q \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "have qnonz: \"q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "assume qnonz: \"q \\<noteq> 0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  q \\<noteq> 0", "have noroots: \"{x. poly q x = 0} = {}\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly q x = 0} = {}", "using qin finset"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  q \\<in> set qs\n  finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. {x. poly q x = 0} = {}", "using Collect_empty_eq fin_means_empty"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  q \\<in> set qs\n  finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n  (Collect ?P = {}) = (\\<forall>x. \\<not> ?P x)\n  {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = {}\n\ngoal (1 subgoal):\n 1. {x. poly q x = 0} = {}", "by auto"], ["proof (state)\nthis:\n  {x. poly q x = 0} = {}\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "have nonzsq1: \"squash (poly q x) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (poly q x) \\<noteq> 0", "using fin_means_empty qnonz czer qin"], ["proof (prove)\nusing this:\n  {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = {}\n  q \\<noteq> 0\n  card {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = 0\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. squash (poly q x) \\<noteq> 0", "unfolding squash_def"], ["proof (prove)\nusing this:\n  {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = {}\n  q \\<noteq> 0\n  card {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} = 0\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. (if 0 < poly q x then 1 else if poly q x < 0 then - 1 else 0) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  squash (poly q x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  squash (poly q x) \\<noteq> 0", "have  eo: \"(poly q x) > 0 \\<or> (poly q x) < 0\""], ["proof (prove)\nusing this:\n  squash (poly q x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly q x \\<or> poly q x < 0", "unfolding squash_def"], ["proof (prove)\nusing this:\n  (if 0 < poly q x then 1 else if poly q x < 0 then - 1 else 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly q x \\<or> poly q x < 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if 0 < poly q x then 1\n              else if poly q x < 0 then - 1 else 0) \\<noteq>\n             0;\n     \\<not> poly q x < 0\\<rbrakk>\n    \\<Longrightarrow> 0 < poly q x", "by presburger"], ["proof (state)\nthis:\n  0 < poly q x \\<or> poly q x < 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "have eo1: \"poly q x > 0 \\<Longrightarrow> poly q y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly q x \\<Longrightarrow> 0 < poly q y", "using noroots poly_IVT_pos[of y x q] poly_IVT_neg[of x y q]"], ["proof (prove)\nusing this:\n  {x. poly q x = 0} = {}\n  \\<lbrakk>y < x; poly q y < 0; 0 < poly q x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>y. x < x \\<and> poly q x = 0\n  \\<lbrakk>x < y; 0 < poly q x; poly q y < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x. x < y \\<and> poly q x = 0\n\ngoal (1 subgoal):\n 1. 0 < poly q x \\<Longrightarrow> 0 < poly q y", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly q x; \\<forall>x. poly q x \\<noteq> 0;\n     \\<lbrakk>y < x; poly q y < 0\\<rbrakk> \\<Longrightarrow> False;\n     \\<lbrakk>x < y; poly q y < 0\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> 0 < poly q y", "by (metis linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  0 < poly q x \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "have eo2: \"poly q x < 0 \\<Longrightarrow> poly q y < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x < 0 \\<Longrightarrow> poly q y < 0", "using noroots poly_IVT_pos[of x y q] poly_IVT_neg[of y x q]"], ["proof (prove)\nusing this:\n  {x. poly q x = 0} = {}\n  \\<lbrakk>x < y; poly q x < 0; 0 < poly q y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x. x < y \\<and> poly q x = 0\n  \\<lbrakk>y < x; 0 < poly q y; poly q x < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>y. x < x \\<and> poly q x = 0\n\ngoal (1 subgoal):\n 1. poly q x < 0 \\<Longrightarrow> poly q y < 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly q x < 0; \\<forall>x. poly q x \\<noteq> 0;\n     \\<lbrakk>x < y; 0 < poly q y\\<rbrakk> \\<Longrightarrow> False;\n     \\<lbrakk>y < x; 0 < poly q y\\<rbrakk> \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> poly q y < 0", "by (metis linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  poly q x < 0 \\<Longrightarrow> poly q y < 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  poly q x < 0 \\<Longrightarrow> poly q y < 0", "show \"squash (poly q x) = squash (poly q y)\""], ["proof (prove)\nusing this:\n  poly q x < 0 \\<Longrightarrow> poly q y < 0\n\ngoal (1 subgoal):\n 1. squash (poly q x) = squash (poly q y)", "using eo eo1 eo2"], ["proof (prove)\nusing this:\n  poly q x < 0 \\<Longrightarrow> poly q y < 0\n  0 < poly q x \\<or> poly q x < 0\n  0 < poly q x \\<Longrightarrow> 0 < poly q y\n  poly q x < 0 \\<Longrightarrow> poly q y < 0\n\ngoal (1 subgoal):\n 1. squash (poly q x) = squash (poly q y)", "unfolding squash_def"], ["proof (prove)\nusing this:\n  poly q x < 0 \\<Longrightarrow> poly q y < 0\n  0 < poly q x \\<or> poly q x < 0\n  0 < poly q x \\<Longrightarrow> 0 < poly q y\n  poly q x < 0 \\<Longrightarrow> poly q y < 0\n\ngoal (1 subgoal):\n 1. (if 0 < poly q x then 1 else if poly q x < 0 then - 1 else 0) =\n    (if 0 < poly q y then 1 else if poly q y < 0 then - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  squash (poly q x) = squash (poly q y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<And>q x y.\n       \\<lbrakk>card\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0} =\n                0;\n        q \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> squash (poly q x) = squash (poly q y)", "show \"squash (poly q x) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (poly q x) = squash (poly q y)", "using qzer qnonz"], ["proof (prove)\nusing this:\n  q = 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)\n  q \\<noteq> 0 \\<Longrightarrow> squash (poly q x) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. squash (poly q x) = squash (poly q y)", "by blast"], ["proof (state)\nthis:\n  squash (poly q x) = squash (poly q y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. \\<forall>x y. squash (poly q x) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. length\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n    0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs. \\<forall>x y. squash (poly q x) = squash (poly q y)", "have \"\\<forall>q \\<in> set (qs). squash (poly q y) = squash (poly q (- crb (prod_list_var qs)))\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. \\<forall>x y. squash (poly q x) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       squash (poly q y) =\n       squash (poly q (real_of_int (- crb (prod_list_var qs))))", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     squash (poly q y) =\n     squash (poly q (real_of_int (- crb (prod_list_var qs))))\n\ngoal (1 subgoal):\n 1. length\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n    0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs.\n     squash (poly q y) =\n     squash (poly q (real_of_int (- crb (prod_list_var qs))))", "show \"\\<exists> k \\<in> (set S). consistent_sign_vec qs k = consistent_sign_vec qs y\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     squash (poly q y) =\n     squash (poly q (real_of_int (- crb (prod_list_var qs))))\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "using neg_crb_in"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     squash (poly q y) =\n     squash (poly q (real_of_int (- crb (prod_list_var qs))))\n  real_of_int (- crb (prod_list_var qs)) \\<in> set S\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "unfolding consistent_sign_vec_def squash_def"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     (if 0 < poly q y then 1 else if poly q y < 0 then - 1 else 0) =\n     (if 0 < poly q (real_of_int (- crb (prod_list_var qs))) then 1\n      else if poly q (real_of_int (- crb (prod_list_var qs))) < 0 then - 1\n           else 0)\n  real_of_int (- crb (prod_list_var qs)) \\<in> set S\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       map (\\<lambda>q.\n               if 0 < poly q k then 1 else if poly q k = 0 then 0 else - 1)\n        qs =\n       map (\\<lambda>q.\n               if 0 < poly q y then 1 else if poly q y = 0 then 0 else - 1)\n        qs", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q\\<in>set qs.\n                (if 0 < poly q y then 1\n                 else if poly q y < 0 then - 1 else 0) =\n                (if 0 < poly q (- real_of_int (crb (prod_list_var qs)))\n                 then 1\n                 else if poly q (real_of_int (- crb (prod_list_var qs))) < 0\n                      then - 1 else 0);\n     - real_of_int (crb (prod_list_var qs)) \\<in> set S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k\\<in>set S.\n                         \\<forall>x\\<in>set qs.\n                            (poly x k = 0 \\<longrightarrow>\n                             poly x y = 0) \\<and>\n                            (poly x k \\<noteq> 0 \\<longrightarrow>\n                             (0 < poly x k \\<longrightarrow>\n                              poly x y \\<noteq> 0 \\<and>\n                              (poly x y \\<noteq> 0 \\<longrightarrow>\n                               0 < poly x y)) \\<and>\n                             (\\<not> 0 < poly x k \\<longrightarrow>\n                              poly x y \\<noteq> 0 \\<and>\n                              (poly x y \\<noteq> 0 \\<longrightarrow>\n                               \\<not> 0 < poly x y)))", "by (metis (no_types, hide_lams) antisym_conv3 class_field.neg_1_not_0 equal_neg_zero less_irrefl of_int_minus)"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n  0 \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>set qs.\n               q \\<noteq> 0 \\<and> poly q y = 0) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have c_c2: \"length ?zer_list > 0 \\<Longrightarrow>  \\<exists> k \\<in> (set S). consistent_sign_vec qs k = consistent_sign_vec qs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "assume lengt: \"length ?zer_list > 0\""], ["proof (state)\nthis:\n  0 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "let ?t = \" \\<exists> k \\<in> (set S). consistent_sign_vec qs k = consistent_sign_vec qs y\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have sg1: \"(\\<exists>w. w < length ?zer_list \\<and> y = ?zer_list ! w) \\<Longrightarrow> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}).\n       y =\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       w \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}).\n       y =\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       w \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "assume \"(\\<exists>w. w < length ?zer_list \\<and> y = ?zer_list ! w)\""], ["proof (state)\nthis:\n  \\<exists>w<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}).\n     y =\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     w\n\ngoal (1 subgoal):\n 1. \\<exists>w<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}).\n       y =\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       w \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<exists>w<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}).\n     y =\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     w", "obtain w where w_prop: \"w < length ?zer_list \\<and> y = ?zer_list ! w\""], ["proof (prove)\nusing this:\n  \\<exists>w<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}).\n     y =\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     w\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w < length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs.\n                      q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n        y =\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  y =\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  w\n\ngoal (1 subgoal):\n 1. \\<exists>w<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}).\n       y =\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       w \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  w < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  y =\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  w", "have \" y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\""], ["proof (prove)\nusing this:\n  w < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  y =\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  w\n\ngoal (1 subgoal):\n 1. y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "using finset set_sorted_list_of_set[of \"{x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\"]"], ["proof (prove)\nusing this:\n  w < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<and>\n  y =\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  w\n  finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n  finite\n   {x. \\<exists>q\\<in>set qs.\n          q \\<noteq> 0 \\<and> poly q x = 0} \\<Longrightarrow>\n  set (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n  {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "by (smt (verit, best) nth_mem)"], ["proof (state)\nthis:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>w<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}).\n       y =\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       w \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "have \"y \\<in> {x. poly (poly_f qs) x = 0}\""], ["proof (prove)\nusing this:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. y \\<in> {x. poly (poly_f qs) x = 0}", "using poly_f_is"], ["proof (prove)\nusing this:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n\ngoal (1 subgoal):\n 1. y \\<in> {x. poly (poly_f qs) x = 0}", "using \\<open>\\<not> (\\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0)\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n  \\<not> (\\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0)\n\ngoal (1 subgoal):\n 1. y \\<in> {x. poly (poly_f qs) x = 0}", "by blast"], ["proof (state)\nthis:\n  y \\<in> {x. poly (poly_f qs) x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>w<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}).\n       y =\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       w \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  y \\<in> {x. poly (poly_f qs) x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> {x. poly (poly_f qs) x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "using set_S_char"], ["proof (prove)\nusing this:\n  y \\<in> {x. poly (poly_f qs) x = 0}\n  set S = {x. poly (poly_f qs) x = 0}\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "by blast"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}).\n     y =\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     w \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have sg2: \"(y < ?zer_list ! 0) \\<Longrightarrow> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "assume ylt: \"y < ?zer_list ! 0\""], ["proof (state)\nthis:\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0\n\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have ynonzat_some_qs: \"\\<forall>q \\<in> (set qs). q \\<noteq> 0 \\<longrightarrow> poly q y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       q \\<noteq> 0 \\<longrightarrow> poly q y \\<noteq> 0", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume q_in: \"q \\<in> set qs\""], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume qnonz: \"q \\<noteq> 0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"poly q y = 0\""], ["proof (state)\nthis:\n  poly q y = 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly q y = 0", "have \"y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\""], ["proof (prove)\nusing this:\n  poly q y = 0\n\ngoal (1 subgoal):\n 1. y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "using q_in qnonz"], ["proof (prove)\nusing this:\n  poly q y = 0\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "by auto"], ["proof (state)\nthis:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "have \"List.member ?zer_list y\""], ["proof (prove)\nusing this:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n     y", "by (smt (verit, best) finset in_set_member mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   y\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   y", "have \"y \\<ge> ?zer_list ! 0\""], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   y\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0\n    \\<le> y", "using strict_sorted_h"], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   y\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0\n    \\<le> y", "using \\<open>\\<not> (\\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0)\\<close> \\<open>poly q y = 0\\<close> q_in qnonz"], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   y\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n  \\<not> (\\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0)\n  poly q y = 0\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0\n    \\<le> y", "by blast"], ["proof (state)\nthis:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> y", "show \"False\""], ["proof (prove)\nusing this:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> y\n\ngoal (1 subgoal):\n 1. False", "using ylt"], ["proof (prove)\nusing this:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> y\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0 \\<longrightarrow> poly q y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "let ?ncrb = \"(- crb (prod_list_var qs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have \"\\<forall>x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}. poly (prod_list_var qs) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}.\n       poly (prod_list_var qs) x = 0", "using q_dvd_prod_list_var_prop"], ["proof (prove)\nusing this:\n  \\<lbrakk>?q \\<in> set ?qs; ?q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?q dvd prod_list_var ?qs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}.\n       poly (prod_list_var qs) x = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}.\n     poly (prod_list_var qs) x = 0\n\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}.\n     poly (prod_list_var qs) x = 0", "have \"poly (prod_list_var qs) (sorted_list_of_set {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} ! 0) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}.\n     poly (prod_list_var qs) x = 0\n\ngoal (1 subgoal):\n 1. poly (prod_list_var qs)\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0) =\n    0", "using finset set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}.\n     poly (prod_list_var qs) x = 0\n  finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n\ngoal (1 subgoal):\n 1. poly (prod_list_var qs)\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0) =\n    0", "by (metis (no_types, lifting) lengt nth_mem)"], ["proof (state)\nthis:\n  poly (prod_list_var qs)\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0) =\n  0\n\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  poly (prod_list_var qs)\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0) =\n  0", "have ncrblt: \"?ncrb < ?zer_list ! 0\""], ["proof (prove)\nusing this:\n  poly (prod_list_var qs)\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0) =\n  0\n\ngoal (1 subgoal):\n 1. real_of_int (- crb (prod_list_var qs))\n    < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0", "using prod_list_var_nonzero crb_lem_neg[of \"prod_list_var qs\" \"?zer_list ! 0\"]"], ["proof (prove)\nusing this:\n  poly (prod_list_var qs)\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0) =\n  0\n  prod_list_var ?qs \\<noteq> 0\n  \\<lbrakk>poly (prod_list_var qs)\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             0) =\n           0;\n   prod_list_var qs \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> real_of_int (- crb (prod_list_var qs))\n                    < sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs.\n                              q \\<noteq> 0 \\<and> poly q x = 0} !\n                      0\n\ngoal (1 subgoal):\n 1. real_of_int (- crb (prod_list_var qs))\n    < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0", "by auto"], ["proof (state)\nthis:\n  real_of_int (- crb (prod_list_var qs))\n  < sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0\n\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have qzerh: \"\\<forall>q \\<in> (set qs). q = 0 \\<longrightarrow> squash (poly q ?ncrb) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       q = 0 \\<longrightarrow>\n       squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n       squash (poly q y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     q = 0 \\<longrightarrow>\n     squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have \"\\<forall>q \\<in> (set qs). q \\<noteq> 0 \\<longrightarrow> squash (poly q ?ncrb) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       q \\<noteq> 0 \\<longrightarrow>\n       squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n       squash (poly q y)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q\n                            (- real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q\n                            (- real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "assume q_in: \"q \\<in> set qs\""], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q\n                            (- real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "assume qnonz: \"q \\<noteq> 0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q\n                            (- real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "have nonzylt:\"\\<not>(\\<exists>x \\<le> y. poly q x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<le>y. poly q x = 0)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> y; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> y; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "assume xlt: \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> y; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "assume \"poly q x = 0\""], ["proof (state)\nthis:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> y; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly q x = 0", "have \"x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\""], ["proof (prove)\nusing this:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "using q_in qnonz"], ["proof (prove)\nusing this:\n  poly q x = 0\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> y; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "have \"List.member ?zer_list x\""], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n     x", "by (smt (verit, best) finset in_set_member mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> y; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x", "have \"x \\<ge> ?zer_list ! 0\""], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0\n    \\<le> x", "using strict_sorted_h"], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0\n    \\<le> x", "by (metis (no_types, lifting) gr_implies_not0 in_set_conv_nth in_set_member not_less sorted_iff_nth_mono sorted_list_of_set(2))"], ["proof (state)\nthis:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> y; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> x", "show \"False\""], ["proof (prove)\nusing this:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> x\n\ngoal (1 subgoal):\n 1. False", "using xlt ylt"], ["proof (prove)\nusing this:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> x\n  x \\<le> y\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x\\<le>y. poly q x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q\n                            (- real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "have nonzncrb:\"\\<not>(\\<exists>x \\<le> (real_of_int ?ncrb). poly q x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<le>real_of_int (- crb (prod_list_var qs)).\n               poly q x = 0)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> - real_of_int (crb (prod_list_var qs));\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> - real_of_int (crb (prod_list_var qs));\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume xlt: \"x \\<le> - real_of_int (crb (prod_list_var qs))\""], ["proof (state)\nthis:\n  x \\<le> - real_of_int (crb (prod_list_var qs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> - real_of_int (crb (prod_list_var qs));\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"poly q x = 0\""], ["proof (state)\nthis:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> - real_of_int (crb (prod_list_var qs));\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly q x = 0", "have \"x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\""], ["proof (prove)\nusing this:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "using q_in qnonz"], ["proof (prove)\nusing this:\n  poly q x = 0\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> - real_of_int (crb (prod_list_var qs));\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "have \"List.member ?zer_list x\""], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n     x", "by (smt (verit, best) finset in_set_member mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> - real_of_int (crb (prod_list_var qs));\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x", "have \"x \\<ge> ?zer_list ! 0\""], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0\n    \\<le> x", "using strict_sorted_h"], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0\n    \\<le> x", "by (metis (no_types, lifting) gr_implies_not0 in_set_conv_nth in_set_member not_less sorted_iff_nth_mono sorted_list_of_set(2))"], ["proof (state)\nthis:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> - real_of_int (crb (prod_list_var qs));\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> x", "show \"False\""], ["proof (prove)\nusing this:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> x\n\ngoal (1 subgoal):\n 1. False", "using xlt ncrblt"], ["proof (prove)\nusing this:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  0\n  \\<le> x\n  x \\<le> - real_of_int (crb (prod_list_var qs))\n  real_of_int (- crb (prod_list_var qs))\n  < sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x\\<le>real_of_int (- crb (prod_list_var qs)).\n             poly q x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q\n                            (- real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "have c1: \" (poly q ?ncrb) > 0 \\<Longrightarrow> (poly q y) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "assume qncrbgt: \"(poly q ?ncrb) > 0\""], ["proof (state)\nthis:\n  0 < poly q (real_of_int (- crb (prod_list_var qs)))\n\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "then"], ["proof (chain)\npicking this:\n  0 < poly q (real_of_int (- crb (prod_list_var qs)))", "have eq: \"?ncrb = y \\<Longrightarrow> poly q y > 0 \""], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (- crb (prod_list_var qs)))\n\ngoal (1 subgoal):\n 1. real_of_int (- crb (prod_list_var qs)) = y \\<Longrightarrow>\n    0 < poly q y", "by auto"], ["proof (state)\nthis:\n  real_of_int (- crb (prod_list_var qs)) = y \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "have gt: \" ?ncrb > y \\<Longrightarrow> poly q y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < real_of_int (- crb (prod_list_var qs)) \\<Longrightarrow>\n    0 < poly q y", "using qncrbgt qnonz poly_IVT_pos[of y ?ncrb q] poly_IVT_neg[of ?ncrb y q] nonzncrb nonzylt"], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (- crb (prod_list_var qs)))\n  q \\<noteq> 0\n  \\<lbrakk>y < real_of_int (- crb (prod_list_var qs)); poly q y < 0;\n   0 < poly q (real_of_int (- crb (prod_list_var qs)))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>y.\n                       x < real_of_int (- crb (prod_list_var qs)) \\<and>\n                       poly q x = 0\n  \\<lbrakk>real_of_int (- crb (prod_list_var qs)) < y;\n   0 < poly q (real_of_int (- crb (prod_list_var qs)));\n   poly q y < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>real_of_int (- crb (prod_list_var qs)).\n                       x < y \\<and> poly q x = 0\n  \\<not> (\\<exists>x\\<le>real_of_int (- crb (prod_list_var qs)).\n             poly q x = 0)\n  \\<not> (\\<exists>x\\<le>y. poly q x = 0)\n\ngoal (1 subgoal):\n 1. y < real_of_int (- crb (prod_list_var qs)) \\<Longrightarrow>\n    0 < poly q y", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < - real_of_int (crb (prod_list_var qs));\n     0 < poly q (- real_of_int (crb (prod_list_var qs))); q \\<noteq> 0;\n     poly q y < 0 \\<Longrightarrow>\n     \\<exists>x>y.\n        x < - real_of_int (crb (prod_list_var qs)) \\<and> poly q x = 0;\n     \\<forall>x\\<le>- real_of_int (crb (prod_list_var qs)).\n        poly q x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < poly q y", "by (meson less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  y < real_of_int (- crb (prod_list_var qs)) \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "have lt: \"?ncrb < y \\<Longrightarrow> poly q y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (- crb (prod_list_var qs)) < y \\<Longrightarrow>\n    0 < poly q y", "using qncrbgt"], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (- crb (prod_list_var qs)))\n\ngoal (1 subgoal):\n 1. real_of_int (- crb (prod_list_var qs)) < y \\<Longrightarrow>\n    0 < poly q y", "using qnonz poly_IVT_pos[of y ?ncrb q] poly_IVT_neg[of ?ncrb y q] nonzncrb nonzylt"], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (- crb (prod_list_var qs)))\n  q \\<noteq> 0\n  \\<lbrakk>y < real_of_int (- crb (prod_list_var qs)); poly q y < 0;\n   0 < poly q (real_of_int (- crb (prod_list_var qs)))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>y.\n                       x < real_of_int (- crb (prod_list_var qs)) \\<and>\n                       poly q x = 0\n  \\<lbrakk>real_of_int (- crb (prod_list_var qs)) < y;\n   0 < poly q (real_of_int (- crb (prod_list_var qs)));\n   poly q y < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>real_of_int (- crb (prod_list_var qs)).\n                       x < y \\<and> poly q x = 0\n  \\<not> (\\<exists>x\\<le>real_of_int (- crb (prod_list_var qs)).\n             poly q x = 0)\n  \\<not> (\\<exists>x\\<le>y. poly q x = 0)\n\ngoal (1 subgoal):\n 1. real_of_int (- crb (prod_list_var qs)) < y \\<Longrightarrow>\n    0 < poly q y", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- real_of_int (crb (prod_list_var qs)) < y;\n     0 < poly q (- real_of_int (crb (prod_list_var qs))); q \\<noteq> 0;\n     poly q y < 0 \\<Longrightarrow>\n     \\<exists>x>- real_of_int (crb (prod_list_var qs)).\n        x < y \\<and> poly q x = 0;\n     \\<forall>x\\<le>y. poly q x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < poly q y", "by (meson less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  real_of_int (- crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "then"], ["proof (chain)\npicking this:\n  real_of_int (- crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (- crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. 0 < poly q y", "using eq gt lt"], ["proof (prove)\nusing this:\n  real_of_int (- crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y\n  real_of_int (- crb (prod_list_var qs)) = y \\<Longrightarrow> 0 < poly q y\n  y < real_of_int (- crb (prod_list_var qs)) \\<Longrightarrow> 0 < poly q y\n  real_of_int (- crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. 0 < poly q y", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- real_of_int (crb (prod_list_var qs)) = y \\<Longrightarrow>\n             0 < poly q y;\n     y < - real_of_int (crb (prod_list_var qs)) \\<Longrightarrow>\n     0 < poly q y;\n     - real_of_int (crb (prod_list_var qs)) < y \\<Longrightarrow>\n     0 < poly q y\\<rbrakk>\n    \\<Longrightarrow> 0 < poly q y", "by (meson linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  0 < poly q y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<Longrightarrow>\n  0 < poly q y\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q\n                            (- real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "have c2: \"(poly q ?ncrb) < 0 \\<Longrightarrow>  (poly q y) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q (real_of_int (- crb (prod_list_var qs))) < 0 \\<Longrightarrow>\n    poly q y < 0", "using poly_IVT_pos[of ?ncrb y q] poly_IVT_neg[of y ?ncrb q] nonzncrb nonzylt"], ["proof (prove)\nusing this:\n  \\<lbrakk>real_of_int (- crb (prod_list_var qs)) < y;\n   poly q (real_of_int (- crb (prod_list_var qs))) < 0;\n   0 < poly q y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>real_of_int (- crb (prod_list_var qs)).\n                       x < y \\<and> poly q x = 0\n  \\<lbrakk>y < real_of_int (- crb (prod_list_var qs)); 0 < poly q y;\n   poly q (real_of_int (- crb (prod_list_var qs))) < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>y.\n                       x < real_of_int (- crb (prod_list_var qs)) \\<and>\n                       poly q x = 0\n  \\<not> (\\<exists>x\\<le>real_of_int (- crb (prod_list_var qs)).\n             poly q x = 0)\n  \\<not> (\\<exists>x\\<le>y. poly q x = 0)\n\ngoal (1 subgoal):\n 1. poly q (real_of_int (- crb (prod_list_var qs))) < 0 \\<Longrightarrow>\n    poly q y < 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly q (- real_of_int (crb (prod_list_var qs))) < 0;\n     \\<lbrakk>- real_of_int (crb (prod_list_var qs)) < y;\n      0 < poly q y\\<rbrakk>\n     \\<Longrightarrow> \\<exists>x>- real_of_int (crb (prod_list_var qs)).\n                          x < y \\<and> poly q x = 0;\n     \\<lbrakk>y < - real_of_int (crb (prod_list_var qs));\n      0 < poly q y\\<rbrakk>\n     \\<Longrightarrow> \\<exists>x>y.\n                          x < - real_of_int (crb (prod_list_var qs)) \\<and>\n                          poly q x = 0;\n     \\<forall>x\\<le>- real_of_int (crb (prod_list_var qs)).\n        poly q x \\<noteq> 0;\n     \\<forall>x\\<le>y. poly q x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> poly q y < 0", "by (metis less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  poly q (real_of_int (- crb (prod_list_var qs))) < 0 \\<Longrightarrow>\n  poly q y < 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q\n                            (- real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "have eo: \"(poly q ?ncrb) > 0 \\<or>  (poly q ?ncrb) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<or>\n    poly q (real_of_int (- crb (prod_list_var qs))) < 0", "using nonzncrb"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x\\<le>real_of_int (- crb (prod_list_var qs)).\n             poly q x = 0)\n\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<or>\n    poly q (real_of_int (- crb (prod_list_var qs))) < 0", "by auto"], ["proof (state)\nthis:\n  0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<or>\n  poly q (real_of_int (- crb (prod_list_var qs))) < 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q\n                            (- real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<or>\n  poly q (real_of_int (- crb (prod_list_var qs))) < 0", "show \"squash (poly q (- real_of_int (crb (prod_list_var qs)))) = squash (poly q y)\""], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<or>\n  poly q (real_of_int (- crb (prod_list_var qs))) < 0\n\ngoal (1 subgoal):\n 1. squash (poly q (- real_of_int (crb (prod_list_var qs)))) =\n    squash (poly q y)", "using   c1 c2"], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<or>\n  poly q (real_of_int (- crb (prod_list_var qs))) < 0\n  0 < poly q (real_of_int (- crb (prod_list_var qs))) \\<Longrightarrow>\n  0 < poly q y\n  poly q (real_of_int (- crb (prod_list_var qs))) < 0 \\<Longrightarrow>\n  poly q y < 0\n\ngoal (1 subgoal):\n 1. squash (poly q (- real_of_int (crb (prod_list_var qs)))) =\n    squash (poly q y)", "by (smt (verit, ccfv_SIG) of_int_minus squash_def)"], ["proof (state)\nthis:\n  squash (poly q (- real_of_int (crb (prod_list_var qs)))) =\n  squash (poly q y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow>\n     squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow>\n     squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n     squash (poly q y)", "have \"\\<forall>q \\<in> (set qs). squash (poly q ?ncrb) = squash (poly q y)\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow>\n     squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n       squash (poly q y)", "using qzerh"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow>\n     squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n     squash (poly q y)\n  \\<forall>q\\<in>set qs.\n     q = 0 \\<longrightarrow>\n     squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n       squash (poly q y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs.\n     squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n     squash (poly q y)", "have \"consistent_sign_vec qs ?ncrb = consistent_sign_vec qs y\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     squash (poly q (real_of_int (- crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. consistent_sign_vec qs (real_of_int (- crb (prod_list_var qs))) =\n    consistent_sign_vec qs y", "unfolding consistent_sign_vec_def squash_def"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     (if 0 < poly q (real_of_int (- crb (prod_list_var qs))) then 1\n      else if poly q (real_of_int (- crb (prod_list_var qs))) < 0 then - 1\n           else 0) =\n     (if 0 < poly q y then 1 else if poly q y < 0 then - 1 else 0)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>q.\n            if 0 < poly q (real_of_int (- crb (prod_list_var qs))) then 1\n            else if poly q (real_of_int (- crb (prod_list_var qs))) = 0\n                 then 0 else - 1)\n     qs =\n    map (\\<lambda>q.\n            if 0 < poly q y then 1 else if poly q y = 0 then 0 else - 1)\n     qs", "by (smt (z3) map_eq_conv)"], ["proof (state)\nthis:\n  consistent_sign_vec qs (real_of_int (- crb (prod_list_var qs))) =\n  consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. y < sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        0 \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  consistent_sign_vec qs (real_of_int (- crb (prod_list_var qs))) =\n  consistent_sign_vec qs y", "show ?thesis"], ["proof (prove)\nusing this:\n  consistent_sign_vec qs (real_of_int (- crb (prod_list_var qs))) =\n  consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "using neg_crb_in"], ["proof (prove)\nusing this:\n  consistent_sign_vec qs (real_of_int (- crb (prod_list_var qs))) =\n  consistent_sign_vec qs y\n  real_of_int (- crb (prod_list_var qs)) \\<in> set S\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "by auto"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have sg3: \" (y > ?zer_list ! (length ?zer_list - 1)) \\<Longrightarrow> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "assume ygt: \"y  > ?zer_list ! (length ?zer_list - 1)\""], ["proof (state)\nthis:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have ynonzat_some_qs: \"\\<forall>q \\<in> (set qs). q \\<noteq> 0 \\<longrightarrow> poly q y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       q \\<noteq> 0 \\<longrightarrow> poly q y \\<noteq> 0", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume q_in: \"q \\<in> set qs\""], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume qnonz: \"q \\<noteq> 0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"poly q y = 0\""], ["proof (state)\nthis:\n  poly q y = 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly q y = 0", "have \"y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\""], ["proof (prove)\nusing this:\n  poly q y = 0\n\ngoal (1 subgoal):\n 1. y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "using q_in qnonz"], ["proof (prove)\nusing this:\n  poly q y = 0\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "by auto"], ["proof (state)\nthis:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "have \"List.member ?zer_list y\""], ["proof (prove)\nusing this:\n  y \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n     y", "by (smt (verit, best) finset in_set_member mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   y\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   y", "have \"y \\<le> ?zer_list ! (length ?zer_list - 1)\""], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   y\n\ngoal (1 subgoal):\n 1. y \\<le> sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1)", "using strict_sorted_h"], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   y\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n\ngoal (1 subgoal):\n 1. y \\<le> sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1)", "using \\<open>\\<not> (\\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0)\\<close> \\<open>poly q y = 0\\<close> q_in qnonz"], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   y\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n  \\<not> (\\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0)\n  poly q y = 0\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<le> sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1)", "by blast"], ["proof (state)\nthis:\n  y \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0; poly q y = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)", "show \"False\""], ["proof (prove)\nusing this:\n  y \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)\n\ngoal (1 subgoal):\n 1. False", "using ygt"], ["proof (prove)\nusing this:\n  y \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0 \\<longrightarrow> poly q y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "let ?crb = \"crb (prod_list_var qs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have \"\\<forall>x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}. poly (prod_list_var qs) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}.\n       poly (prod_list_var qs) x = 0", "using q_dvd_prod_list_var_prop"], ["proof (prove)\nusing this:\n  \\<lbrakk>?q \\<in> set ?qs; ?q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?q dvd prod_list_var ?qs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                          q \\<noteq> 0 \\<and> poly q x = 0}.\n       poly (prod_list_var qs) x = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}.\n     poly (prod_list_var qs) x = 0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}.\n     poly (prod_list_var qs) x = 0", "have \"poly (prod_list_var qs) (sorted_list_of_set {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} ! 0) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}.\n     poly (prod_list_var qs) x = 0\n\ngoal (1 subgoal):\n 1. poly (prod_list_var qs)\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0) =\n    0", "using finset set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}.\n     poly (prod_list_var qs) x = 0\n  finite {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n\ngoal (1 subgoal):\n 1. poly (prod_list_var qs)\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0) =\n    0", "by (metis (no_types, lifting) lengt nth_mem)"], ["proof (state)\nthis:\n  poly (prod_list_var qs)\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0) =\n  0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  poly (prod_list_var qs)\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0) =\n  0", "have crbgt: \"?crb > ?zer_list ! (length ?zer_list - 1)\""], ["proof (prove)\nusing this:\n  poly (prod_list_var qs)\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0) =\n  0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < real_of_int (crb (prod_list_var qs))", "using prod_list_var_nonzero crb_lem_pos[of \"prod_list_var qs\" \"?zer_list ! (length ?zer_list - 1)\"]"], ["proof (prove)\nusing this:\n  poly (prod_list_var qs)\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    0) =\n  0\n  prod_list_var ?qs \\<noteq> 0\n  \\<lbrakk>poly (prod_list_var qs)\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             (length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1)) =\n           0;\n   prod_list_var qs \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sorted_list_of_set\n                     {x. \\<exists>q\\<in>set qs.\n                            q \\<noteq> 0 \\<and> poly q x = 0} !\n                    (length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs.\n                               q \\<noteq> 0 \\<and> poly q x = 0}) -\n                     1)\n                    < real_of_int (crb (prod_list_var qs))\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < real_of_int (crb (prod_list_var qs))", "by (metis (no_types, lifting) \\<open>\\<forall>x\\<in>{x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}. poly (prod_list_var qs) x = 0\\<close> diff_less finset lengt less_numeral_extra(1) nth_mem set_sorted_list_of_set)"], ["proof (state)\nthis:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < real_of_int (crb (prod_list_var qs))\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have qzerh: \"\\<forall>q \\<in> (set qs). q = 0 \\<longrightarrow> squash (poly q ?crb) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       q = 0 \\<longrightarrow>\n       squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n       squash (poly q y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     q = 0 \\<longrightarrow>\n     squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have \"\\<forall>q \\<in> (set qs). q \\<noteq> 0 \\<longrightarrow> squash (poly q ?crb) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       q \\<noteq> 0 \\<longrightarrow>\n       squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n       squash (poly q y)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q (real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q (real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "assume q_in: \"q \\<in> set qs\""], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q (real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "assume qnonz: \"q \\<noteq> 0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q (real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "have nonzylt:\"\\<not>(\\<exists>x \\<ge> y. poly q x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<ge>y. poly q x = 0)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>y \\<le> x; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>y \\<le> x; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "assume xgt: \"x \\<ge> y\""], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>y \\<le> x; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "assume \"poly q x = 0\""], ["proof (state)\nthis:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>y \\<le> x; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly q x = 0", "have \"x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\""], ["proof (prove)\nusing this:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "using q_in qnonz"], ["proof (prove)\nusing this:\n  poly q x = 0\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>y \\<le> x; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "have \"List.member ?zer_list x\""], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n     x", "by (smt (verit, best) finset in_set_member mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>y \\<le> x; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x", "have \"x \\<le> ?zer_list ! (length ?zer_list - 1)\""], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n\ngoal (1 subgoal):\n 1. x \\<le> sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1)", "using strict_sorted_h"], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n\ngoal (1 subgoal):\n 1. x \\<le> sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1)", "by (metis (no_types, lifting) One_nat_def Suc_leI Suc_pred diff_Suc_less in_set_conv_nth in_set_member lengt not_less sorted_iff_nth_mono sorted_list_of_set(2))"], ["proof (state)\nthis:\n  x \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>y \\<le> x; poly q x = 0\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)", "show \"False\""], ["proof (prove)\nusing this:\n  x \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)\n\ngoal (1 subgoal):\n 1. False", "using xgt ygt"], ["proof (prove)\nusing this:\n  x \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)\n  y \\<le> x\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x\\<ge>y. poly q x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q (real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "have nonzcrb:\"\\<not>(\\<exists>x \\<ge> (real_of_int ?crb). poly q x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<ge>real_of_int (crb (prod_list_var qs)).\n               poly q x = 0)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_int (crb (prod_list_var qs)) \\<le> x;\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_int (crb (prod_list_var qs)) \\<le> x;\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume xgt: \"x \\<ge> real_of_int (crb (prod_list_var qs))\""], ["proof (state)\nthis:\n  real_of_int (crb (prod_list_var qs)) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_int (crb (prod_list_var qs)) \\<le> x;\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"poly q x = 0\""], ["proof (state)\nthis:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_int (crb (prod_list_var qs)) \\<le> x;\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly q x = 0", "have \"x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\""], ["proof (prove)\nusing this:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "using q_in qnonz"], ["proof (prove)\nusing this:\n  poly q x = 0\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_int (crb (prod_list_var qs)) \\<le> x;\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}", "have \"List.member ?zer_list x\""], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n     x", "by (smt (verit, best) finset in_set_member mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_int (crb (prod_list_var qs)) \\<le> x;\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x", "have \"x \\<le> ?zer_list ! (length ?zer_list - 1)\""], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n\ngoal (1 subgoal):\n 1. x \\<le> sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1)", "using strict_sorted_h"], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n   x\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n\ngoal (1 subgoal):\n 1. x \\<le> sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1)", "by (meson \\<open>\\<forall>x\\<in>{x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}. poly (prod_list_var qs) x = 0\\<close> \\<open>x \\<in> {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}\\<close> crb_lem_pos not_less prod_list_var_nonzero xgt)"], ["proof (state)\nthis:\n  x \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_int (crb (prod_list_var qs)) \\<le> x;\n        poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)", "show \"False\""], ["proof (prove)\nusing this:\n  x \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)\n\ngoal (1 subgoal):\n 1. False", "using xgt crbgt"], ["proof (prove)\nusing this:\n  x \\<le> sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (length\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs.\n                     q \\<noteq> 0 \\<and> poly q x = 0}) -\n           1)\n  real_of_int (crb (prod_list_var qs)) \\<le> x\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < real_of_int (crb (prod_list_var qs))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x\\<ge>real_of_int (crb (prod_list_var qs)). poly q x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q (real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "have c1: \" (poly q ?crb) > 0 \\<Longrightarrow> (poly q y) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "assume qcrbgt: \"(poly q ?crb) > 0\""], ["proof (state)\nthis:\n  0 < poly q (real_of_int (crb (prod_list_var qs)))\n\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "then"], ["proof (chain)\npicking this:\n  0 < poly q (real_of_int (crb (prod_list_var qs)))", "have eq: \"?crb = y \\<Longrightarrow> poly q y > 0 \""], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (crb (prod_list_var qs)))\n\ngoal (1 subgoal):\n 1. real_of_int (crb (prod_list_var qs)) = y \\<Longrightarrow> 0 < poly q y", "by auto"], ["proof (state)\nthis:\n  real_of_int (crb (prod_list_var qs)) = y \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "have gt: \" ?crb > y \\<Longrightarrow> poly q y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < real_of_int (crb (prod_list_var qs)) \\<Longrightarrow> 0 < poly q y", "using qcrbgt qnonz poly_IVT_pos[of y ?crb q] poly_IVT_neg[of ?crb y q] nonzcrb nonzylt"], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (crb (prod_list_var qs)))\n  q \\<noteq> 0\n  \\<lbrakk>y < real_of_int (crb (prod_list_var qs)); poly q y < 0;\n   0 < poly q (real_of_int (crb (prod_list_var qs)))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>y.\n                       x < real_of_int (crb (prod_list_var qs)) \\<and>\n                       poly q x = 0\n  \\<lbrakk>real_of_int (crb (prod_list_var qs)) < y;\n   0 < poly q (real_of_int (crb (prod_list_var qs))); poly q y < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>real_of_int (crb (prod_list_var qs)).\n                       x < y \\<and> poly q x = 0\n  \\<not> (\\<exists>x\\<ge>real_of_int (crb (prod_list_var qs)). poly q x = 0)\n  \\<not> (\\<exists>x\\<ge>y. poly q x = 0)\n\ngoal (1 subgoal):\n 1. y < real_of_int (crb (prod_list_var qs)) \\<Longrightarrow> 0 < poly q y", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < real_of_int (crb (prod_list_var qs));\n     0 < poly q (real_of_int (crb (prod_list_var qs))); q \\<noteq> 0;\n     poly q y < 0 \\<Longrightarrow>\n     \\<exists>x>y.\n        x < real_of_int (crb (prod_list_var qs)) \\<and> poly q x = 0;\n     \\<forall>x\\<ge>y. poly q x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < poly q y", "by (meson less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  y < real_of_int (crb (prod_list_var qs)) \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "have lt: \"?crb < y \\<Longrightarrow> poly q y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y", "using qcrbgt"], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (crb (prod_list_var qs)))\n\ngoal (1 subgoal):\n 1. real_of_int (crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y", "using qnonz poly_IVT_pos[of y ?crb q] poly_IVT_neg[of ?crb y q] nonzcrb nonzylt"], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (crb (prod_list_var qs)))\n  q \\<noteq> 0\n  \\<lbrakk>y < real_of_int (crb (prod_list_var qs)); poly q y < 0;\n   0 < poly q (real_of_int (crb (prod_list_var qs)))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>y.\n                       x < real_of_int (crb (prod_list_var qs)) \\<and>\n                       poly q x = 0\n  \\<lbrakk>real_of_int (crb (prod_list_var qs)) < y;\n   0 < poly q (real_of_int (crb (prod_list_var qs))); poly q y < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>real_of_int (crb (prod_list_var qs)).\n                       x < y \\<and> poly q x = 0\n  \\<not> (\\<exists>x\\<ge>real_of_int (crb (prod_list_var qs)). poly q x = 0)\n  \\<not> (\\<exists>x\\<ge>y. poly q x = 0)\n\ngoal (1 subgoal):\n 1. real_of_int (crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>real_of_int (crb (prod_list_var qs)) < y;\n     0 < poly q (real_of_int (crb (prod_list_var qs))); q \\<noteq> 0;\n     poly q y < 0 \\<Longrightarrow>\n     \\<exists>x>real_of_int (crb (prod_list_var qs)).\n        x < y \\<and> poly q x = 0;\n     \\<forall>x\\<ge>real_of_int (crb (prod_list_var qs)).\n        poly q x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < poly q y", "by (meson less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  real_of_int (crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (crb (prod_list_var qs))) \\<Longrightarrow>\n    0 < poly q y", "then"], ["proof (chain)\npicking this:\n  real_of_int (crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. 0 < poly q y", "using eq gt lt"], ["proof (prove)\nusing this:\n  real_of_int (crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y\n  real_of_int (crb (prod_list_var qs)) = y \\<Longrightarrow> 0 < poly q y\n  y < real_of_int (crb (prod_list_var qs)) \\<Longrightarrow> 0 < poly q y\n  real_of_int (crb (prod_list_var qs)) < y \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. 0 < poly q y", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>real_of_int (crb (prod_list_var qs)) = y \\<Longrightarrow>\n             0 < poly q y;\n     y < real_of_int (crb (prod_list_var qs)) \\<Longrightarrow>\n     0 < poly q y;\n     real_of_int (crb (prod_list_var qs)) < y \\<Longrightarrow>\n     0 < poly q y\\<rbrakk>\n    \\<Longrightarrow> 0 < poly q y", "by (meson linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  0 < poly q y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < poly q (real_of_int (crb (prod_list_var qs))) \\<Longrightarrow>\n  0 < poly q y\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q (real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "have c2: \"(poly q ?crb) < 0 \\<Longrightarrow>  (poly q y) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q (real_of_int (crb (prod_list_var qs))) < 0 \\<Longrightarrow>\n    poly q y < 0", "using poly_IVT_pos[of ?crb y q] poly_IVT_neg[of y ?crb q] nonzcrb nonzylt"], ["proof (prove)\nusing this:\n  \\<lbrakk>real_of_int (crb (prod_list_var qs)) < y;\n   poly q (real_of_int (crb (prod_list_var qs))) < 0; 0 < poly q y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>real_of_int (crb (prod_list_var qs)).\n                       x < y \\<and> poly q x = 0\n  \\<lbrakk>y < real_of_int (crb (prod_list_var qs)); 0 < poly q y;\n   poly q (real_of_int (crb (prod_list_var qs))) < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>y.\n                       x < real_of_int (crb (prod_list_var qs)) \\<and>\n                       poly q x = 0\n  \\<not> (\\<exists>x\\<ge>real_of_int (crb (prod_list_var qs)). poly q x = 0)\n  \\<not> (\\<exists>x\\<ge>y. poly q x = 0)\n\ngoal (1 subgoal):\n 1. poly q (real_of_int (crb (prod_list_var qs))) < 0 \\<Longrightarrow>\n    poly q y < 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly q (real_of_int (crb (prod_list_var qs))) < 0;\n     \\<lbrakk>real_of_int (crb (prod_list_var qs)) < y;\n      0 < poly q y\\<rbrakk>\n     \\<Longrightarrow> \\<exists>x>real_of_int (crb (prod_list_var qs)).\n                          x < y \\<and> poly q x = 0;\n     \\<lbrakk>y < real_of_int (crb (prod_list_var qs));\n      0 < poly q y\\<rbrakk>\n     \\<Longrightarrow> \\<exists>x>y.\n                          x < real_of_int (crb (prod_list_var qs)) \\<and>\n                          poly q x = 0;\n     \\<forall>x\\<ge>real_of_int (crb (prod_list_var qs)).\n        poly q x \\<noteq> 0;\n     \\<forall>x\\<ge>y. poly q x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> poly q y < 0", "by (metis less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  poly q (real_of_int (crb (prod_list_var qs))) < 0 \\<Longrightarrow>\n  poly q y < 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q (real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "have eo: \"(poly q ?crb) > 0 \\<or>  (poly q ?crb) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (crb (prod_list_var qs))) \\<or>\n    poly q (real_of_int (crb (prod_list_var qs))) < 0", "using nonzcrb"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x\\<ge>real_of_int (crb (prod_list_var qs)). poly q x = 0)\n\ngoal (1 subgoal):\n 1. 0 < poly q (real_of_int (crb (prod_list_var qs))) \\<or>\n    poly q (real_of_int (crb (prod_list_var qs))) < 0", "by auto"], ["proof (state)\nthis:\n  0 < poly q (real_of_int (crb (prod_list_var qs))) \\<or>\n  poly q (real_of_int (crb (prod_list_var qs))) < 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash\n                          (poly q (real_of_int (crb (prod_list_var qs)))) =\n                         squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  0 < poly q (real_of_int (crb (prod_list_var qs))) \\<or>\n  poly q (real_of_int (crb (prod_list_var qs))) < 0", "show \"squash (poly q (real_of_int (crb (prod_list_var qs)))) = squash (poly q y)\""], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (crb (prod_list_var qs))) \\<or>\n  poly q (real_of_int (crb (prod_list_var qs))) < 0\n\ngoal (1 subgoal):\n 1. squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n    squash (poly q y)", "using   c1 c2"], ["proof (prove)\nusing this:\n  0 < poly q (real_of_int (crb (prod_list_var qs))) \\<or>\n  poly q (real_of_int (crb (prod_list_var qs))) < 0\n  0 < poly q (real_of_int (crb (prod_list_var qs))) \\<Longrightarrow>\n  0 < poly q y\n  poly q (real_of_int (crb (prod_list_var qs))) < 0 \\<Longrightarrow>\n  poly q y < 0\n\ngoal (1 subgoal):\n 1. squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n    squash (poly q y)", "by (smt (verit, ccfv_SIG) of_int_minus squash_def)"], ["proof (state)\nthis:\n  squash (poly q (real_of_int (crb (prod_list_var qs)))) = squash (poly q y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow>\n     squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow>\n     squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n     squash (poly q y)", "have \"\\<forall>q \\<in> (set qs). squash (poly q ?crb) = squash (poly q y)\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow>\n     squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n       squash (poly q y)", "using qzerh"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow>\n     squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n     squash (poly q y)\n  \\<forall>q\\<in>set qs.\n     q = 0 \\<longrightarrow>\n     squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n       squash (poly q y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs.\n     squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n     squash (poly q y)", "have \"consistent_sign_vec qs ?crb = consistent_sign_vec qs y\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     squash (poly q (real_of_int (crb (prod_list_var qs)))) =\n     squash (poly q y)\n\ngoal (1 subgoal):\n 1. consistent_sign_vec qs (real_of_int (crb (prod_list_var qs))) =\n    consistent_sign_vec qs y", "unfolding consistent_sign_vec_def squash_def"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     (if 0 < poly q (real_of_int (crb (prod_list_var qs))) then 1\n      else if poly q (real_of_int (crb (prod_list_var qs))) < 0 then - 1\n           else 0) =\n     (if 0 < poly q y then 1 else if poly q y < 0 then - 1 else 0)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>q.\n            if 0 < poly q (real_of_int (crb (prod_list_var qs))) then 1\n            else if poly q (real_of_int (crb (prod_list_var qs))) = 0 then 0\n                 else - 1)\n     qs =\n    map (\\<lambda>q.\n            if 0 < poly q y then 1 else if poly q y = 0 then 0 else - 1)\n     qs", "by (smt (z3) map_eq_conv)"], ["proof (state)\nthis:\n  consistent_sign_vec qs (real_of_int (crb (prod_list_var qs))) =\n  consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n     1)\n    < y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  consistent_sign_vec qs (real_of_int (crb (prod_list_var qs))) =\n  consistent_sign_vec qs y", "show ?thesis"], ["proof (prove)\nusing this:\n  consistent_sign_vec qs (real_of_int (crb (prod_list_var qs))) =\n  consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "using pos_crb_in"], ["proof (prove)\nusing this:\n  consistent_sign_vec qs (real_of_int (crb (prod_list_var qs))) =\n  consistent_sign_vec qs y\n  real_of_int (crb (prod_list_var qs)) \\<in> set S\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "by auto"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have sg4: \" (\\<exists>k < (length ?zer_list - 1). y > ?zer_list ! k  \\<and> y < ?zer_list ! (k+1)) \\<Longrightarrow> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "assume \" (\\<exists>k < (length ?zer_list - 1). y > ?zer_list ! k  \\<and> y < ?zer_list ! (k+1))\""], ["proof (state)\nthis:\n  \\<exists>k<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < y \\<and>\n     y < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<exists>k<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < y \\<and>\n     y < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1)", "obtain k where k_prop: \"k < (length ?zer_list - 1) \\<and> y > ?zer_list ! k  \\<and> y < ?zer_list ! (k+1)\""], ["proof (prove)\nusing this:\n  \\<exists>k<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < y \\<and>\n     y < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k < length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs.\n                      q \\<noteq> 0 \\<and> poly q x = 0}) -\n            1 \\<and>\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < y \\<and>\n        y < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < y \\<and>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have ltk: \"(?zer_list ! k) < (?zer_list ! (k+1)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    k\n    < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)", "using strict_sorted_h"], ["proof (prove)\nusing this:\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    k\n    < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)", "using k_prop"], ["proof (prove)\nusing this:\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n  k < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < y \\<and>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    k\n    < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)", "by linarith"], ["proof (state)\nthis:\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (k + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have q1e: \"(\\<exists>q1\\<in>set qs. q1 \\<noteq> 0 \\<and> poly q1 (?zer_list ! k) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q1\\<in>set qs.\n       q1 \\<noteq> 0 \\<and>\n       poly q1\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         k) =\n       0", "by (smt (z3) One_nat_def Suc_lessD add.right_neutral add_Suc_right finset k_prop less_diff_conv mem_Collect_eq nth_mem set_sorted_list_of_set)"], ["proof (state)\nthis:\n  \\<exists>q1\\<in>set qs.\n     q1 \\<noteq> 0 \\<and>\n     poly q1\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k) =\n     0\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have q2e: \"(\\<exists>q2\\<in>set qs. q2 \\<noteq> 0 \\<and> poly q2 (?zer_list ! (k + 1)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q2\\<in>set qs.\n       q2 \\<noteq> 0 \\<and>\n       poly q2\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1)) =\n       0", "by (smt (verit, del_insts) finset k_prop less_diff_conv mem_Collect_eq nth_mem set_sorted_list_of_set)"], ["proof (state)\nthis:\n  \\<exists>q2\\<in>set qs.\n     q2 \\<noteq> 0 \\<and>\n     poly q2\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (k + 1)) =\n     0\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<exists>q2\\<in>set qs.\n     q2 \\<noteq> 0 \\<and>\n     poly q2\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (k + 1)) =\n     0", "have \"(\\<exists>q>(?zer_list ! k). q < (?zer_list ! (k + 1)) \\<and> poly (poly_f qs) q = 0)\""], ["proof (prove)\nusing this:\n  \\<exists>q2\\<in>set qs.\n     q2 \\<noteq> 0 \\<and>\n     poly q2\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (k + 1)) =\n     0\n\ngoal (1 subgoal):\n 1. \\<exists>q>sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               k.\n       q < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<and>\n       poly (poly_f qs) q = 0", "using poly_f_roots_prop_1[of qs] q1e q2e ltk is_not_const"], ["proof (prove)\nusing this:\n  \\<exists>q2\\<in>set qs.\n     q2 \\<noteq> 0 \\<and>\n     poly q2\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (k + 1)) =\n     0\n  check_all_const_deg qs = False \\<Longrightarrow>\n  \\<forall>x1 x2.\n     x1 < x2 \\<and>\n     (\\<exists>q1\\<in>set qs. q1 \\<noteq> 0 \\<and> poly q1 x1 = 0) \\<and>\n     (\\<exists>q2\\<in>set qs.\n         q2 \\<noteq> 0 \\<and> poly q2 x2 = 0) \\<longrightarrow>\n     (\\<exists>q>x1. q < x2 \\<and> poly (poly_f qs) q = 0)\n  \\<exists>q1\\<in>set qs.\n     q1 \\<noteq> 0 \\<and>\n     poly q1\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k) =\n     0\n  \\<exists>q2\\<in>set qs.\n     q2 \\<noteq> 0 \\<and>\n     poly q2\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (k + 1)) =\n     0\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n    (k + 1)\n  check_all_const_deg qs = False\n\ngoal (1 subgoal):\n 1. \\<exists>q>sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0} !\n               k.\n       q < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<and>\n       poly (poly_f qs) q = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>q>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             k.\n     q < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1) \\<and>\n     poly (poly_f qs) q = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<exists>q>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             k.\n     q < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1) \\<and>\n     poly (poly_f qs) q = 0", "have \"\\<exists>s \\<in> set S. s > ?zer_list ! k  \\<and> s < ?zer_list ! (k+1)\""], ["proof (prove)\nusing this:\n  \\<exists>q>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             k.\n     q < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1) \\<and>\n     poly (poly_f qs) q = 0\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>set S.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < s \\<and>\n       s < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1)", "using poly_f_is"], ["proof (prove)\nusing this:\n  \\<exists>q>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n             k.\n     q < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1) \\<and>\n     poly (poly_f qs) q = 0\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>set S.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < s \\<and>\n       s < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1)", "by (smt (z3) k_prop mem_Collect_eq set_S_char)"], ["proof (state)\nthis:\n  \\<exists>s\\<in>set S.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < s \\<and>\n     s < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<exists>s\\<in>set S.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < s \\<and>\n     s < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1)", "obtain s where s_prop: \"s \\<in> set S \\<and> s > ?zer_list ! k  \\<and> s < ?zer_list ! (k+1)\""], ["proof (prove)\nusing this:\n  \\<exists>s\\<in>set S.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < s \\<and>\n     s < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> set S \\<and>\n        sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n        k\n        < s \\<and>\n        s < sorted_list_of_set\n             {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n            (k + 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> set S \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < s \\<and>\n  s < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have qnon: \"\\<forall>q \\<in> set qs. q\\<noteq> 0 \\<longrightarrow> squash (poly q s) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       q \\<noteq> 0 \\<longrightarrow> squash (poly q s) = squash (poly q y)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "assume q_in: \"q \\<in> set qs\""], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "assume qnonz: \"q \\<noteq> 0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "have sgt: \"s > y \\<Longrightarrow> squash (poly q s) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < s \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y < s \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "assume \"s > y\""], ["proof (state)\nthis:\n  y < s\n\ngoal (1 subgoal):\n 1. y < s \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  y < s", "have \"\\<nexists>x. List.member ?zer_list x \\<and> y \\<le> x \\<and> x \\<le> s\""], ["proof (prove)\nusing this:\n  y < s\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       List.member\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n        x \\<and>\n       y \\<le> x \\<and> x \\<le> s", "using sorted_list_lemma[of y s k ?zer_list] k_prop strict_sorted_h s_prop y_prop"], ["proof (prove)\nusing this:\n  y < s\n  \\<lbrakk>y < s;\n   k + 1\n   < length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0});\n   strict_sorted\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0});\n   sorted_list_of_set\n    {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n   k\n   < y;\n   s < sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (k + 1)\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>x.\n                       List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs.\n                                 q \\<noteq> 0 \\<and> poly q x = 0})\n                        x \\<and>\n                       y \\<le> x \\<and> x \\<le> s\n  k < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < y \\<and>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n  s \\<in> set S \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < s \\<and>\n  s < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n  x = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       List.member\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n        x \\<and>\n       y \\<le> x \\<and> x \\<le> s", "using less_diff_conv"], ["proof (prove)\nusing this:\n  y < s\n  \\<lbrakk>y < s;\n   k + 1\n   < length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0});\n   strict_sorted\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0});\n   sorted_list_of_set\n    {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n   k\n   < y;\n   s < sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (k + 1)\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>x.\n                       List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs.\n                                 q \\<noteq> 0 \\<and> poly q x = 0})\n                        x \\<and>\n                       y \\<le> x \\<and> x \\<le> s\n  k < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < y \\<and>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n  s \\<in> set S \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < s \\<and>\n  s < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n  x = consistent_sign_vec qs y\n  (?i < ?j - ?k) = (?i + ?k < ?j)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       List.member\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n        x \\<and>\n       y \\<le> x \\<and> x \\<le> s", "by blast"], ["proof (state)\nthis:\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n      x \\<and>\n     y \\<le> x \\<and> x \\<le> s\n\ngoal (1 subgoal):\n 1. y < s \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n      x \\<and>\n     y \\<le> x \\<and> x \\<le> s", "have nox: \"\\<nexists>x. poly q x = 0 \\<and> y \\<le> x \\<and> x \\<le> s\""], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n      x \\<and>\n     y \\<le> x \\<and> x \\<le> s\n\ngoal (1 subgoal):\n 1. \\<nexists>x. poly q x = 0 \\<and> y \\<le> x \\<and> x \\<le> s", "using q_in qnonz"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n      x \\<and>\n     y \\<le> x \\<and> x \\<le> s\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>x. poly q x = 0 \\<and> y \\<le> x \\<and> x \\<le> s", "by (metis (mono_tags, lifting) finset in_set_member mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  \\<nexists>x. poly q x = 0 \\<and> y \\<le> x \\<and> x \\<le> s\n\ngoal (1 subgoal):\n 1. y < s \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  \\<nexists>x. poly q x = 0 \\<and> y \\<le> x \\<and> x \\<le> s", "have c1: \"poly q s \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<nexists>x. poly q x = 0 \\<and> y \\<le> x \\<and> x \\<le> s\n\ngoal (1 subgoal):\n 1. poly q s \\<noteq> 0", "using s_prop q_in qnonz"], ["proof (prove)\nusing this:\n  \\<nexists>x. poly q x = 0 \\<and> y \\<le> x \\<and> x \\<le> s\n  s \\<in> set S \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < s \\<and>\n  s < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q s \\<noteq> 0", "by (metis (mono_tags, lifting) \\<open>y < s\\<close> less_eq_real_def )"], ["proof (state)\nthis:\n  poly q s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y < s \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "have c2: \"poly q s > 0 \\<Longrightarrow> poly q y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly q s \\<Longrightarrow> 0 < poly q y", "using poly_IVT_pos poly_IVT_neg nox"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < ?b; poly ?p ?a < 0; 0 < poly ?p ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n  \\<lbrakk>?a < ?b; 0 < poly ?p ?a; poly ?p ?b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n  \\<nexists>x. poly q x = 0 \\<and> y \\<le> x \\<and> x \\<le> s\n\ngoal (1 subgoal):\n 1. 0 < poly q s \\<Longrightarrow> 0 < poly q y", "by (meson \\<open>y < s\\<close> less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  0 < poly q s \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. y < s \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "have c3: \"poly q s < 0 \\<Longrightarrow> poly q y < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q s < 0 \\<Longrightarrow> poly q y < 0", "using poly_IVT_pos poly_IVT_neg nox"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < ?b; poly ?p ?a < 0; 0 < poly ?p ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n  \\<lbrakk>?a < ?b; 0 < poly ?p ?a; poly ?p ?b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n  \\<nexists>x. poly q x = 0 \\<and> y \\<le> x \\<and> x \\<le> s\n\ngoal (1 subgoal):\n 1. poly q s < 0 \\<Longrightarrow> poly q y < 0", "by (meson \\<open>y < s\\<close> less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  poly q s < 0 \\<Longrightarrow> poly q y < 0\n\ngoal (1 subgoal):\n 1. y < s \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (poly q s) = squash (poly q y)", "using c1 c2 c3"], ["proof (prove)\nusing this:\n  poly q s \\<noteq> 0\n  0 < poly q s \\<Longrightarrow> 0 < poly q y\n  poly q s < 0 \\<Longrightarrow> poly q y < 0\n\ngoal (1 subgoal):\n 1. squash (poly q s) = squash (poly q y)", "unfolding squash_def"], ["proof (prove)\nusing this:\n  poly q s \\<noteq> 0\n  0 < poly q s \\<Longrightarrow> 0 < poly q y\n  poly q s < 0 \\<Longrightarrow> poly q y < 0\n\ngoal (1 subgoal):\n 1. (if 0 < poly q s then 1 else if poly q s < 0 then - 1 else 0) =\n    (if 0 < poly q y then 1 else if poly q y < 0 then - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  squash (poly q s) = squash (poly q y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y < s \\<Longrightarrow> squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "have slt: \"s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "assume slt: \"s < y\""], ["proof (state)\nthis:\n  s < y\n\ngoal (1 subgoal):\n 1. s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  s < y", "have \"\\<nexists>x. List.member ?zer_list x \\<and> s \\<le> x \\<and> x \\<le> y\""], ["proof (prove)\nusing this:\n  s < y\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       List.member\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n        x \\<and>\n       s \\<le> x \\<and> x \\<le> y", "using sorted_list_lemma[of s y k ?zer_list] k_prop strict_sorted_h s_prop y_prop"], ["proof (prove)\nusing this:\n  s < y\n  \\<lbrakk>s < y;\n   k + 1\n   < length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0});\n   strict_sorted\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0});\n   sorted_list_of_set\n    {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n   k\n   < s;\n   y < sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (k + 1)\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>x.\n                       List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs.\n                                 q \\<noteq> 0 \\<and> poly q x = 0})\n                        x \\<and>\n                       s \\<le> x \\<and> x \\<le> y\n  k < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < y \\<and>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n  s \\<in> set S \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < s \\<and>\n  s < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n  x = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       List.member\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n        x \\<and>\n       s \\<le> x \\<and> x \\<le> y", "using less_diff_conv"], ["proof (prove)\nusing this:\n  s < y\n  \\<lbrakk>s < y;\n   k + 1\n   < length\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0});\n   strict_sorted\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0});\n   sorted_list_of_set\n    {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n   k\n   < s;\n   y < sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       (k + 1)\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>x.\n                       List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs.\n                                 q \\<noteq> 0 \\<and> poly q x = 0})\n                        x \\<and>\n                       s \\<le> x \\<and> x \\<le> y\n  k < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < y \\<and>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n  strict_sorted\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n  s \\<in> set S \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < s \\<and>\n  s < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n  x = consistent_sign_vec qs y\n  (?i < ?j - ?k) = (?i + ?k < ?j)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       List.member\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n        x \\<and>\n       s \\<le> x \\<and> x \\<le> y", "by blast"], ["proof (state)\nthis:\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n      x \\<and>\n     s \\<le> x \\<and> x \\<le> y\n\ngoal (1 subgoal):\n 1. s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n      x \\<and>\n     s \\<le> x \\<and> x \\<le> y", "have nox: \"\\<nexists>x. poly q x = 0 \\<and> s \\<le> x \\<and> x \\<le> y\""], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n      x \\<and>\n     s \\<le> x \\<and> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<nexists>x. poly q x = 0 \\<and> s \\<le> x \\<and> x \\<le> y", "using q_in qnonz"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n      x \\<and>\n     s \\<le> x \\<and> x \\<le> y\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>x. poly q x = 0 \\<and> s \\<le> x \\<and> x \\<le> y", "by (metis (mono_tags, lifting) finset in_set_member mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  \\<nexists>x. poly q x = 0 \\<and> s \\<le> x \\<and> x \\<le> y\n\ngoal (1 subgoal):\n 1. s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  \\<nexists>x. poly q x = 0 \\<and> s \\<le> x \\<and> x \\<le> y", "have c1: \"poly q s \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<nexists>x. poly q x = 0 \\<and> s \\<le> x \\<and> x \\<le> y\n\ngoal (1 subgoal):\n 1. poly q s \\<noteq> 0", "using s_prop q_in qnonz"], ["proof (prove)\nusing this:\n  \\<nexists>x. poly q x = 0 \\<and> s \\<le> x \\<and> x \\<le> y\n  s \\<in> set S \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < s \\<and>\n  s < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n  q \\<in> set qs\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q s \\<noteq> 0", "by (metis (mono_tags, lifting) \\<open>s < y\\<close> less_eq_real_def )"], ["proof (state)\nthis:\n  poly q s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "have c2: \"poly q s > 0 \\<Longrightarrow> poly q y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly q s \\<Longrightarrow> 0 < poly q y", "using poly_IVT_pos poly_IVT_neg nox"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < ?b; poly ?p ?a < 0; 0 < poly ?p ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n  \\<lbrakk>?a < ?b; 0 < poly ?p ?a; poly ?p ?b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n  \\<nexists>x. poly q x = 0 \\<and> s \\<le> x \\<and> x \\<le> y\n\ngoal (1 subgoal):\n 1. 0 < poly q s \\<Longrightarrow> 0 < poly q y", "by (meson \\<open>s < y\\<close> less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  0 < poly q s \\<Longrightarrow> 0 < poly q y\n\ngoal (1 subgoal):\n 1. s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "have c3: \"poly q s < 0 \\<Longrightarrow> poly q y < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q s < 0 \\<Longrightarrow> poly q y < 0", "using poly_IVT_pos poly_IVT_neg nox"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < ?b; poly ?p ?a < 0; 0 < poly ?p ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n  \\<lbrakk>?a < ?b; 0 < poly ?p ?a; poly ?p ?b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n  \\<nexists>x. poly q x = 0 \\<and> s \\<le> x \\<and> x \\<le> y\n\ngoal (1 subgoal):\n 1. poly q s < 0 \\<Longrightarrow> poly q y < 0", "by (meson \\<open>s < y\\<close> less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  poly q s < 0 \\<Longrightarrow> poly q y < 0\n\ngoal (1 subgoal):\n 1. s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (poly q s) = squash (poly q y)", "using c1 c2 c3"], ["proof (prove)\nusing this:\n  poly q s \\<noteq> 0\n  0 < poly q s \\<Longrightarrow> 0 < poly q y\n  poly q s < 0 \\<Longrightarrow> poly q y < 0\n\ngoal (1 subgoal):\n 1. squash (poly q s) = squash (poly q y)", "unfolding squash_def"], ["proof (prove)\nusing this:\n  poly q s \\<noteq> 0\n  0 < poly q s \\<Longrightarrow> 0 < poly q y\n  poly q s < 0 \\<Longrightarrow> poly q y < 0\n\ngoal (1 subgoal):\n 1. (if 0 < poly q s then 1 else if poly q s < 0 then - 1 else 0) =\n    (if 0 < poly q y then 1 else if poly q y < 0 then - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  squash (poly q s) = squash (poly q y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "have \"s = y \\<Longrightarrow> squash (poly q s) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = y \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "by auto"], ["proof (state)\nthis:\n  s = y \\<Longrightarrow> squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set qs; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "then"], ["proof (chain)\npicking this:\n  s = y \\<Longrightarrow> squash (poly q s) = squash (poly q y)", "show \"squash (poly q s) = squash (poly q y)\""], ["proof (prove)\nusing this:\n  s = y \\<Longrightarrow> squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. squash (poly q s) = squash (poly q y)", "using sgt slt"], ["proof (prove)\nusing this:\n  s = y \\<Longrightarrow> squash (poly q s) = squash (poly q y)\n  y < s \\<Longrightarrow> squash (poly q s) = squash (poly q y)\n  s < y \\<Longrightarrow> squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. squash (poly q s) = squash (poly q y)", "by (meson linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  squash (poly q s) = squash (poly q y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow> squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "have \"\\<forall>q \\<in> set qs. q= 0 \\<longrightarrow> squash (poly q s) = squash (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       q = 0 \\<longrightarrow> squash (poly q s) = squash (poly q y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     q = 0 \\<longrightarrow> squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs.\n     q = 0 \\<longrightarrow> squash (poly q s) = squash (poly q y)", "have \"\\<forall>q \\<in> set qs. squash (poly q s) = squash (poly q y)\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     q = 0 \\<longrightarrow> squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. squash (poly q s) = squash (poly q y)", "using qnon"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     q = 0 \\<longrightarrow> squash (poly q s) = squash (poly q y)\n  \\<forall>q\\<in>set qs.\n     q \\<noteq> 0 \\<longrightarrow> squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. squash (poly q s) = squash (poly q y)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs.\n                         q \\<noteq> 0 \\<and> poly q x = 0}) -\n               1.\n       sorted_list_of_set\n        {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n       k\n       < y \\<and>\n       y < sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n           (k + 1) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs. squash (poly q s) = squash (poly q y)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. squash (poly q s) = squash (poly q y)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "using s_prop"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. squash (poly q s) = squash (poly q y)\n  s \\<in> set S \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < s \\<and>\n  s < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "unfolding squash_def consistent_sign_vec_def"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     (if 0 < poly q s then 1 else if poly q s < 0 then - 1 else 0) =\n     (if 0 < poly q y then 1 else if poly q y < 0 then - 1 else 0)\n  s \\<in> set S \\<and>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  k\n  < s \\<and>\n  s < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      (k + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       map (\\<lambda>q.\n               if 0 < poly q k then 1 else if poly q k = 0 then 0 else - 1)\n        qs =\n       map (\\<lambda>q.\n               if 0 < poly q y then 1 else if poly q y = 0 then 0 else - 1)\n        qs", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q\\<in>set qs.\n                (if 0 < poly q s then 1\n                 else if poly q s < 0 then - 1 else 0) =\n                (if 0 < poly q y then 1\n                 else if poly q y < 0 then - 1 else 0);\n     s \\<in> set S;\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < s;\n     s < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k\\<in>set S.\n                         \\<forall>x\\<in>set qs.\n                            (poly x k = 0 \\<longrightarrow>\n                             poly x y = 0) \\<and>\n                            (poly x k \\<noteq> 0 \\<longrightarrow>\n                             (0 < poly x k \\<longrightarrow>\n                              poly x y \\<noteq> 0 \\<and>\n                              (poly x y \\<noteq> 0 \\<longrightarrow>\n                               0 < poly x y)) \\<and>\n                             (\\<not> 0 < poly x k \\<longrightarrow>\n                              poly x y \\<noteq> 0 \\<and>\n                              (poly x y \\<noteq> 0 \\<longrightarrow>\n                               \\<not> 0 < poly x y)))", "by (metis (no_types, hide_lams) class_field.neg_1_not_0 equal_neg_zero less_irrefl linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < y \\<and>\n     y < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1) \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs.\n                  q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "using lengt sg1 sg2 sg3 sg4 len_gtz_prop is_not_const"], ["proof (prove)\nusing this:\n  0 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0})\n  \\<exists>w<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}).\n     y =\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     w \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n  \\<exists>k<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs.\n                       q \\<noteq> 0 \\<and> poly q x = 0}) -\n             1.\n     sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n     k\n     < y \\<and>\n     y < sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n         (k + 1) \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n  0 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<longrightarrow>\n  (\\<exists>w<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}).\n      y =\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      w) \\<or>\n  y < sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      0 \\<or>\n  sorted_list_of_set\n   {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n  (length\n    (sorted_list_of_set\n      {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) -\n   1)\n  < y \\<or>\n  (\\<exists>k<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs.\n                        q \\<noteq> 0 \\<and> poly q x = 0}) -\n              1.\n      sorted_list_of_set\n       {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n      k\n      < y \\<and>\n      y < sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0} !\n          (k + 1))\n  check_all_const_deg qs = False\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>set qs.\n               q \\<noteq> 0 \\<and> poly q y = 0) \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "show \"\\<exists> k \\<in> (set S). consistent_sign_vec qs k = consistent_sign_vec qs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "using c_c1 c_c2"], ["proof (prove)\nusing this:\n  length\n   (sorted_list_of_set\n     {x. \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q x = 0}) =\n  0 \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n  0 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs.\n                q \\<noteq> 0 \\<and> poly q x = 0}) \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "by auto"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>q\\<in>set qs.\n             q \\<noteq> 0 \\<and> poly q y = 0) \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. x = consistent_sign_vec qs y \\<Longrightarrow>\n    \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "using c1 c2"], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>set qs. q \\<noteq> 0 \\<and> poly q y = 0 \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n  \\<not> (\\<exists>q\\<in>set qs.\n             q \\<noteq> 0 \\<and> poly q y = 0) \\<Longrightarrow>\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<exists>k\\<in>set S.\n       consistent_sign_vec qs k = consistent_sign_vec qs y", "by auto"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> consistent_sign_vectors_R qs UNIV \\<Longrightarrow>\n       x \\<in> consistent_sign_vectors_R qs (set S)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y", "show \"x \\<in> consistent_sign_vectors_R qs (set S)\""], ["proof (prove)\nusing this:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. x \\<in> consistent_sign_vectors_R qs (set S)", "using y_prop"], ["proof (prove)\nusing this:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n  x = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. x \\<in> consistent_sign_vectors_R qs (set S)", "unfolding consistent_sign_vectors_R_def"], ["proof (prove)\nusing this:\n  \\<exists>k\\<in>set S. consistent_sign_vec qs k = consistent_sign_vec qs y\n  x = consistent_sign_vec qs y\n\ngoal (1 subgoal):\n 1. x \\<in> consistent_sign_vec qs ` set S", "by (metis imageI)"], ["proof (state)\nthis:\n  x \\<in> consistent_sign_vectors_R qs (set S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  consistent_sign_vectors_R qs UNIV\n  \\<subseteq> consistent_sign_vectors_R qs (set S)\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)", "have easy_direction: \"consistent_sign_vectors_R qs (set S) \\<subseteq> consistent_sign_vectors_R qs UNIV \""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs (set S)\n    \\<subseteq> consistent_sign_vectors_R qs UNIV", "using consistent_sign_vectors_R_def"], ["proof (prove)\nusing this:\n  consistent_sign_vectors_R ?qs ?S = consistent_sign_vec ?qs ` ?S\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs (set S)\n    \\<subseteq> consistent_sign_vectors_R qs UNIV", "by auto"], ["proof (state)\nthis:\n  consistent_sign_vectors_R qs (set S)\n  \\<subseteq> consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)", "then"], ["proof (chain)\npicking this:\n  consistent_sign_vectors_R qs (set S)\n  \\<subseteq> consistent_sign_vectors_R qs UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  consistent_sign_vectors_R qs (set S)\n  \\<subseteq> consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)", "using difficult_direction easy_direction"], ["proof (prove)\nusing this:\n  consistent_sign_vectors_R qs (set S)\n  \\<subseteq> consistent_sign_vectors_R qs UNIV\n  consistent_sign_vectors_R qs UNIV\n  \\<subseteq> consistent_sign_vectors_R qs (set S)\n  consistent_sign_vectors_R qs (set S)\n  \\<subseteq> consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)", "by auto"], ["proof (state)\nthis:\n  consistent_sign_vectors_R qs UNIV = consistent_sign_vectors_R qs (set S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma main_step_aux2_R:\n  fixes qs:: \"real poly list\"\n  assumes is_not_const: \"check_all_const_deg qs = False\"\n  shows \"set (find_consistent_signs_R qs) =  consistent_sign_vectors_R qs UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "have poly_f_is: \"poly_f qs = (pderiv (prod_list_var qs)) * (prod_list_var qs)* ([:-(crb (prod_list_var qs)),1:]) * ([:(crb (prod_list_var qs)),1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_f qs =\n    pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:]", "using is_not_const"], ["proof (prove)\nusing this:\n  check_all_const_deg qs = False\n\ngoal (1 subgoal):\n 1. poly_f qs =\n    pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:]", "unfolding poly_f_def"], ["proof (prove)\nusing this:\n  check_all_const_deg qs = False\n\ngoal (1 subgoal):\n 1. (if check_all_const_deg qs = True then [:0, 1:]\n     else pderiv (prod_list_var qs) * prod_list_var qs *\n          [:real_of_int (- crb (prod_list_var qs)), 1:] *\n          [:real_of_int (crb (prod_list_var qs)), 1:]) =\n    pderiv (prod_list_var qs) * prod_list_var qs *\n    [:real_of_int (- crb (prod_list_var qs)), 1:] *\n    [:real_of_int (crb (prod_list_var qs)), 1:]", "by auto"], ["proof (state)\nthis:\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "let ?p = \"(pderiv (prod_list_var qs)) * (prod_list_var qs)*  ([:-(crb (prod_list_var qs)),1:]) * ([:(crb (prod_list_var qs)),1:])\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "let ?S = \"characterize_root_list_p (pderiv (prod_list_var qs) * (prod_list_var qs) *  ([:-(crb (prod_list_var qs)),1:]) * ([:(crb (prod_list_var qs)),1:]))\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "have \"set (remdups\n          (map (signs_at qs) ?S)) \n      = consistent_sign_vectors_R qs (set ?S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups\n          (map (signs_at qs)\n            (characterize_root_list_p\n              (pderiv (prod_list_var qs) * prod_list_var qs *\n               [:real_of_int (- crb (prod_list_var qs)), 1:] *\n               [:real_of_int (crb (prod_list_var qs)), 1:])))) =\n    consistent_sign_vectors_R qs\n     (set (characterize_root_list_p\n            (pderiv (prod_list_var qs) * prod_list_var qs *\n             [:real_of_int (- crb (prod_list_var qs)), 1:] *\n             [:real_of_int (crb (prod_list_var qs)), 1:])))", "unfolding signs_at_def squash_def consistent_sign_vectors_R_def consistent_sign_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups\n          (map (\\<lambda>x.\n                   map ((\\<lambda>x.\n                            if 0 < x then 1\n                            else if x < 0 then - 1 else 0) \\<circ>\n                        (\\<lambda>q. poly q x))\n                    qs)\n            (characterize_root_list_p\n              (pderiv (prod_list_var qs) * prod_list_var qs *\n               [:real_of_int (- crb (prod_list_var qs)), 1:] *\n               [:real_of_int (crb (prod_list_var qs)), 1:])))) =\n    (\\<lambda>x.\n        map (\\<lambda>q.\n                if 0 < poly q x then 1 else if poly q x = 0 then 0 else - 1)\n         qs) `\n    set (characterize_root_list_p\n          (pderiv (prod_list_var qs) * prod_list_var qs *\n           [:real_of_int (- crb (prod_list_var qs)), 1:] *\n           [:real_of_int (crb (prod_list_var qs)), 1:]))", "by (smt (verit, best) comp_apply map_eq_conv set_map set_remdups)"], ["proof (state)\nthis:\n  set (remdups\n        (map (signs_at qs)\n          (characterize_root_list_p\n            (pderiv (prod_list_var qs) * prod_list_var qs *\n             [:real_of_int (- crb (prod_list_var qs)), 1:] *\n             [:real_of_int (crb (prod_list_var qs)), 1:])))) =\n  consistent_sign_vectors_R qs\n   (set (characterize_root_list_p\n          (pderiv (prod_list_var qs) * prod_list_var qs *\n           [:real_of_int (- crb (prod_list_var qs)), 1:] *\n           [:real_of_int (crb (prod_list_var qs)), 1:])))\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "then"], ["proof (chain)\npicking this:\n  set (remdups\n        (map (signs_at qs)\n          (characterize_root_list_p\n            (pderiv (prod_list_var qs) * prod_list_var qs *\n             [:real_of_int (- crb (prod_list_var qs)), 1:] *\n             [:real_of_int (crb (prod_list_var qs)), 1:])))) =\n  consistent_sign_vectors_R qs\n   (set (characterize_root_list_p\n          (pderiv (prod_list_var qs) * prod_list_var qs *\n           [:real_of_int (- crb (prod_list_var qs)), 1:] *\n           [:real_of_int (crb (prod_list_var qs)), 1:])))", "have \"set (characterize_consistent_signs_at_roots ?p qs) = consistent_sign_vectors_R qs UNIV\""], ["proof (prove)\nusing this:\n  set (remdups\n        (map (signs_at qs)\n          (characterize_root_list_p\n            (pderiv (prod_list_var qs) * prod_list_var qs *\n             [:real_of_int (- crb (prod_list_var qs)), 1:] *\n             [:real_of_int (crb (prod_list_var qs)), 1:])))) =\n  consistent_sign_vectors_R qs\n   (set (characterize_root_list_p\n          (pderiv (prod_list_var qs) * prod_list_var qs *\n           [:real_of_int (- crb (prod_list_var qs)), 1:] *\n           [:real_of_int (crb (prod_list_var qs)), 1:])))\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots\n          (pderiv (prod_list_var qs) * prod_list_var qs *\n           [:real_of_int (- crb (prod_list_var qs)), 1:] *\n           [:real_of_int (crb (prod_list_var qs)), 1:])\n          qs) =\n    consistent_sign_vectors_R qs UNIV", "unfolding characterize_consistent_signs_at_roots_def"], ["proof (prove)\nusing this:\n  set (remdups\n        (map (signs_at qs)\n          (characterize_root_list_p\n            (pderiv (prod_list_var qs) * prod_list_var qs *\n             [:real_of_int (- crb (prod_list_var qs)), 1:] *\n             [:real_of_int (crb (prod_list_var qs)), 1:])))) =\n  consistent_sign_vectors_R qs\n   (set (characterize_root_list_p\n          (pderiv (prod_list_var qs) * prod_list_var qs *\n           [:real_of_int (- crb (prod_list_var qs)), 1:] *\n           [:real_of_int (crb (prod_list_var qs)), 1:])))\n\ngoal (1 subgoal):\n 1. set (remdups\n          (map (signs_at qs)\n            (characterize_root_list_p\n              (pderiv (prod_list_var qs) * prod_list_var qs *\n               [:real_of_int (- crb (prod_list_var qs)), 1:] *\n               [:real_of_int (crb (prod_list_var qs)), 1:])))) =\n    consistent_sign_vectors_R qs UNIV", "using assms all_sample_points_prop[of qs]"], ["proof (prove)\nusing this:\n  set (remdups\n        (map (signs_at qs)\n          (characterize_root_list_p\n            (pderiv (prod_list_var qs) * prod_list_var qs *\n             [:real_of_int (- crb (prod_list_var qs)), 1:] *\n             [:real_of_int (crb (prod_list_var qs)), 1:])))) =\n  consistent_sign_vectors_R qs\n   (set (characterize_root_list_p\n          (pderiv (prod_list_var qs) * prod_list_var qs *\n           [:real_of_int (- crb (prod_list_var qs)), 1:] *\n           [:real_of_int (crb (prod_list_var qs)), 1:])))\n  check_all_const_deg qs = False\n  \\<lbrakk>check_all_const_deg qs = False;\n   ?S =\n   characterize_root_list_p\n    (pderiv (prod_list_var qs) * prod_list_var qs *\n     [:real_of_int (- crb (prod_list_var qs)), 1:] *\n     [:real_of_int (crb (prod_list_var qs)), 1:])\\<rbrakk>\n  \\<Longrightarrow> consistent_sign_vectors_R qs UNIV =\n                    consistent_sign_vectors_R qs (set ?S)\n\ngoal (1 subgoal):\n 1. set (remdups\n          (map (signs_at qs)\n            (characterize_root_list_p\n              (pderiv (prod_list_var qs) * prod_list_var qs *\n               [:real_of_int (- crb (prod_list_var qs)), 1:] *\n               [:real_of_int (crb (prod_list_var qs)), 1:])))) =\n    consistent_sign_vectors_R qs UNIV", "by auto"], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots\n        (pderiv (prod_list_var qs) * prod_list_var qs *\n         [:real_of_int (- crb (prod_list_var qs)), 1:] *\n         [:real_of_int (crb (prod_list_var qs)), 1:])\n        qs) =\n  consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "then"], ["proof (chain)\npicking this:\n  set (characterize_consistent_signs_at_roots\n        (pderiv (prod_list_var qs) * prod_list_var qs *\n         [:real_of_int (- crb (prod_list_var qs)), 1:] *\n         [:real_of_int (crb (prod_list_var qs)), 1:])\n        qs) =\n  consistent_sign_vectors_R qs UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots\n        (pderiv (prod_list_var qs) * prod_list_var qs *\n         [:real_of_int (- crb (prod_list_var qs)), 1:] *\n         [:real_of_int (crb (prod_list_var qs)), 1:])\n        qs) =\n  consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "unfolding find_consistent_signs_R_def"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots\n        (pderiv (prod_list_var qs) * prod_list_var qs *\n         [:real_of_int (- crb (prod_list_var qs)), 1:] *\n         [:real_of_int (crb (prod_list_var qs)), 1:])\n        qs) =\n  consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R (poly_f qs) qs) =\n    consistent_sign_vectors_R qs UNIV", "using find_consistent_signs_at_roots_R poly_f_is poly_f_nonzero[of qs]"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots\n        (pderiv (prod_list_var qs) * prod_list_var qs *\n         [:real_of_int (- crb (prod_list_var qs)), 1:] *\n         [:real_of_int (crb (prod_list_var qs)), 1:])\n        qs) =\n  consistent_sign_vectors_R qs UNIV\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  set (find_consistent_signs_at_roots_R ?p ?qs) =\n  set (characterize_consistent_signs_at_roots ?p ?qs)\n  poly_f qs =\n  pderiv (prod_list_var qs) * prod_list_var qs *\n  [:real_of_int (- crb (prod_list_var qs)), 1:] *\n  [:real_of_int (crb (prod_list_var qs)), 1:]\n  poly_f qs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots_R (poly_f qs) qs) =\n    consistent_sign_vectors_R qs UNIV", "by auto"], ["proof (state)\nthis:\n  set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma main_step_R:\n  fixes qs:: \"real poly list\"\n  shows \"set (find_consistent_signs_R qs) =  consistent_sign_vectors_R qs UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "using main_step_aux1_R main_step_aux2_R"], ["proof (prove)\nusing this:\n  check_all_const_deg ?qs = True \\<Longrightarrow>\n  set (find_consistent_signs_R ?qs) = consistent_sign_vectors_R ?qs UNIV\n  check_all_const_deg ?qs = False \\<Longrightarrow>\n  set (find_consistent_signs_R ?qs) = consistent_sign_vectors_R ?qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_R qs) = consistent_sign_vectors_R qs UNIV", "by auto"], ["", "(* The universal and existential decision procedure for real polys are easy \n   if we know the consistent sign vectors *)"], ["", "lemma consistent_sign_vec_semantics_R:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length ls\"\n  shows \"lookup_sem fml (map (\\<lambda>p. poly p x) ls) = lookup_sem fml (consistent_sign_vec ls x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_sem fml (map (\\<lambda>p. poly p x) ls) =\n    lookup_sem fml (consistent_sign_vec ls x)", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> set_fml fml \\<Longrightarrow> ?i < length ls\n\ngoal (1 subgoal):\n 1. lookup_sem fml (map (\\<lambda>p. poly p x) ls) =\n    lookup_sem fml (consistent_sign_vec ls x)", "apply (induction)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(\\<And>i.\n                    i \\<in> set_fml x1 \\<Longrightarrow>\n                    i < length ls) \\<Longrightarrow>\n                lookup_sem x1 (map (\\<lambda>p. poly p x) ls) =\n                lookup_sem x1 (consistent_sign_vec ls x);\n        (\\<And>i.\n            i \\<in> set_fml x2 \\<Longrightarrow>\n            i < length ls) \\<Longrightarrow>\n        lookup_sem x2 (map (\\<lambda>p. poly p x) ls) =\n        lookup_sem x2 (consistent_sign_vec ls x);\n        \\<And>i.\n           i \\<in> set_fml (And x1 x2) \\<Longrightarrow>\n           i < length ls\\<rbrakk>\n       \\<Longrightarrow> lookup_sem (And x1 x2)\n                          (map (\\<lambda>p. poly p x) ls) =\n                         lookup_sem (And x1 x2) (consistent_sign_vec ls x)\n 2. \\<And>x1 x2.\n       \\<lbrakk>(\\<And>i.\n                    i \\<in> set_fml x1 \\<Longrightarrow>\n                    i < length ls) \\<Longrightarrow>\n                lookup_sem x1 (map (\\<lambda>p. poly p x) ls) =\n                lookup_sem x1 (consistent_sign_vec ls x);\n        (\\<And>i.\n            i \\<in> set_fml x2 \\<Longrightarrow>\n            i < length ls) \\<Longrightarrow>\n        lookup_sem x2 (map (\\<lambda>p. poly p x) ls) =\n        lookup_sem x2 (consistent_sign_vec ls x);\n        \\<And>i.\n           i \\<in> set_fml (Or x1 x2) \\<Longrightarrow>\n           i < length ls\\<rbrakk>\n       \\<Longrightarrow> lookup_sem (Or x1 x2)\n                          (map (\\<lambda>p. poly p x) ls) =\n                         lookup_sem (Or x1 x2) (consistent_sign_vec ls x)\n 3. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (fml.Gt xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (fml.Gt xa) (map (\\<lambda>p. poly p x) ls) =\n       lookup_sem (fml.Gt xa) (consistent_sign_vec ls x)\n 4. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (Geq xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (Geq xa) (map (\\<lambda>p. poly p x) ls) =\n       lookup_sem (Geq xa) (consistent_sign_vec ls x)\n 5. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (fml.Lt xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (fml.Lt xa) (map (\\<lambda>p. poly p x) ls) =\n       lookup_sem (fml.Lt xa) (consistent_sign_vec ls x)\n 6. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (Leq xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (Leq xa) (map (\\<lambda>p. poly p x) ls) =\n       lookup_sem (Leq xa) (consistent_sign_vec ls x)\n 7. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (fml.Eq xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (fml.Eq xa) (map (\\<lambda>p. poly p x) ls) =\n       lookup_sem (fml.Eq xa) (consistent_sign_vec ls x)\n 8. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (Neq xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (Neq xa) (map (\\<lambda>p. poly p x) ls) =\n       lookup_sem (Neq xa) (consistent_sign_vec ls x)", "by (auto simp add: consistent_sign_vec_def)"], ["", "lemma universal_lookup_sem_R:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length qs\"\n  assumes \"set signs = consistent_sign_vectors_R qs UNIV\"\n  shows \"(\\<forall>x::real. lookup_sem fml (map (\\<lambda>p. poly p x) qs)) \\<longleftrightarrow>\n    list_all (lookup_sem fml) signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n    list_all (lookup_sem fml) signs", "using assms(2)"], ["proof (prove)\nusing this:\n  set signs = consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<forall>x. lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n    list_all (lookup_sem fml) signs", "unfolding consistent_sign_vectors_R_def list_all_iff"], ["proof (prove)\nusing this:\n  set signs = range (consistent_sign_vec qs)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n    Ball (set signs) (lookup_sem fml)", "by (simp add: assms(1) consistent_sign_vec_semantics_R)"], ["", "lemma existential_lookup_sem_R:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length qs\"\n  assumes \"set signs = consistent_sign_vectors_R qs UNIV\"\n  shows \"(\\<exists>x::real. lookup_sem fml (map (\\<lambda>p. poly p x) qs)) \\<longleftrightarrow>\n    find (lookup_sem fml) signs \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n    (find (lookup_sem fml) signs \\<noteq> None)", "using assms(2)"], ["proof (prove)\nusing this:\n  set signs = consistent_sign_vectors_R qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<exists>x. lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n    (find (lookup_sem fml) signs \\<noteq> None)", "unfolding consistent_sign_vectors_R_def find_None_iff"], ["proof (prove)\nusing this:\n  set signs = range (consistent_sign_vec qs)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n    (\\<not> (\\<nexists>x. x \\<in> set signs \\<and> lookup_sem fml x))", "by (simp add: assms(1) consistent_sign_vec_semantics_R)"], ["", "lemma decide_univ_lem_helper_R:\n  fixes fml:: \"real poly fml\"\n  assumes \"(fml_struct,polys) = convert fml\"\n  shows \"(\\<forall>x::real. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) \\<longleftrightarrow> (decide_universal_R fml)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n    decide_universal_R fml", "using assms universal_lookup_sem_R main_step_R"], ["proof (prove)\nusing this:\n  (fml_struct, polys) = convert fml\n  \\<lbrakk>\\<And>i. i \\<in> set_fml ?fml \\<Longrightarrow> i < length ?qs;\n   set ?signs = consistent_sign_vectors_R ?qs UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x.\n                        lookup_sem ?fml (map (\\<lambda>p. poly p x) ?qs)) =\n                    list_all (lookup_sem ?fml) ?signs\n  set (find_consistent_signs_R ?qs) = consistent_sign_vectors_R ?qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<forall>x. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n    decide_universal_R fml", "unfolding decide_universal_R_def"], ["proof (prove)\nusing this:\n  (fml_struct, polys) = convert fml\n  \\<lbrakk>\\<And>i. i \\<in> set_fml ?fml \\<Longrightarrow> i < length ?qs;\n   set ?signs = consistent_sign_vectors_R ?qs UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x.\n                        lookup_sem ?fml (map (\\<lambda>p. poly p x) ?qs)) =\n                    list_all (lookup_sem ?fml) ?signs\n  set (find_consistent_signs_R ?qs) = consistent_sign_vectors_R ?qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<forall>x. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n    (let (fml_struct, polys) = convert fml\n     in Let (find_consistent_signs_R polys)\n         (list_all (lookup_sem fml_struct)))", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>fml qs signs.\n                \\<lbrakk>\\<And>i.\n                            i \\<in> set_fml fml \\<Longrightarrow>\n                            i < length qs;\n                 set signs = consistent_sign_vectors_R qs UNIV\\<rbrakk>\n                \\<Longrightarrow> (\\<forall>x.\nlookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n                                  list_all (lookup_sem fml) signs;\n     \\<And>qs.\n        set (find_consistent_signs_R qs) =\n        consistent_sign_vectors_R qs UNIV;\n     \\<forall>x. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys);\n     convert fml = (fml_struct, polys)\\<rbrakk>\n    \\<Longrightarrow> list_all (lookup_sem fml_struct)\n                       (find_consistent_signs_R polys)\n 2. \\<And>xa.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors_R qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>x.\n   lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n                                     list_all (lookup_sem fml) signs;\n        \\<And>qs.\n           set (find_consistent_signs_R qs) =\n           consistent_sign_vectors_R qs UNIV;\n        convert fml = (fml_struct, polys);\n        list_all (lookup_sem fml_struct)\n         (find_consistent_signs_R polys)\\<rbrakk>\n       \\<Longrightarrow> lookup_sem fml_struct\n                          (map (\\<lambda>p. poly p xa) polys)", "apply (metis assms convert_closed fst_conv snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors_R qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>x.\n   lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n                                     list_all (lookup_sem fml) signs;\n        \\<And>qs.\n           set (find_consistent_signs_R qs) =\n           consistent_sign_vectors_R qs UNIV;\n        convert fml = (fml_struct, polys);\n        list_all (lookup_sem fml_struct)\n         (find_consistent_signs_R polys)\\<rbrakk>\n       \\<Longrightarrow> lookup_sem fml_struct\n                          (map (\\<lambda>p. poly p xa) polys)", "by (metis (full_types) assms convert_closed fst_conv snd_conv)"], ["", "lemma decide_exis_lem_helper_R:\n  fixes fml:: \"real poly fml\"\n  assumes \"(fml_struct,polys) = convert fml\"\n  shows \"(\\<exists>x::real. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) \\<longleftrightarrow> (decide_existential_R fml)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n    decide_existential_R fml", "using assms existential_lookup_sem_R main_step_R"], ["proof (prove)\nusing this:\n  (fml_struct, polys) = convert fml\n  \\<lbrakk>\\<And>i. i \\<in> set_fml ?fml \\<Longrightarrow> i < length ?qs;\n   set ?signs = consistent_sign_vectors_R ?qs UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        lookup_sem ?fml (map (\\<lambda>p. poly p x) ?qs)) =\n                    (find (lookup_sem ?fml) ?signs \\<noteq> None)\n  set (find_consistent_signs_R ?qs) = consistent_sign_vectors_R ?qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<exists>x. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n    decide_existential_R fml", "unfolding decide_existential_R_def"], ["proof (prove)\nusing this:\n  (fml_struct, polys) = convert fml\n  \\<lbrakk>\\<And>i. i \\<in> set_fml ?fml \\<Longrightarrow> i < length ?qs;\n   set ?signs = consistent_sign_vectors_R ?qs UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        lookup_sem ?fml (map (\\<lambda>p. poly p x) ?qs)) =\n                    (find (lookup_sem ?fml) ?signs \\<noteq> None)\n  set (find_consistent_signs_R ?qs) = consistent_sign_vectors_R ?qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<exists>x. lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n    (let (fml_struct, polys) = convert fml;\n         conds = find_consistent_signs_R polys\n     in find (lookup_sem fml_struct) conds \\<noteq> None)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors_R qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>x.\n   lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n                                     (\\<exists>y.\n   find (lookup_sem fml) signs = Some y);\n        \\<And>qs.\n           set (find_consistent_signs_R qs) =\n           consistent_sign_vectors_R qs UNIV;\n        convert fml = (fml_struct, polys);\n        lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            find (lookup_sem fml_struct)\n                             (find_consistent_signs_R polys) =\n                            Some y\n 2. \\<And>ya.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors_R qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>x.\n   lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n                                     (\\<exists>y.\n   find (lookup_sem fml) signs = Some y);\n        \\<And>qs.\n           set (find_consistent_signs_R qs) =\n           consistent_sign_vectors_R qs UNIV;\n        convert fml = (fml_struct, polys);\n        find (lookup_sem fml_struct) (find_consistent_signs_R polys) =\n        Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            lookup_sem fml_struct\n                             (map (\\<lambda>p. poly p x) polys)", "apply (metis assms convert_closed fst_conv snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors_R qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>x.\n   lookup_sem fml (map (\\<lambda>p. poly p x) qs)) =\n                                     (\\<exists>y.\n   find (lookup_sem fml) signs = Some y);\n        \\<And>qs.\n           set (find_consistent_signs_R qs) =\n           consistent_sign_vectors_R qs UNIV;\n        convert fml = (fml_struct, polys);\n        find (lookup_sem fml_struct) (find_consistent_signs_R polys) =\n        Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            lookup_sem fml_struct\n                             (map (\\<lambda>p. poly p x) polys)", "by (metis (full_types) assms convert_closed fst_conv snd_conv)"], ["", "lemma convert_semantics_lem_R:\n  assumes \"\\<And>p. p \\<in> set (poly_list fml) \\<Longrightarrow>\n    ls ! (index_of ps p) = poly p x\"\n  shows \"real_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls", "using assms"], ["proof (prove)\nusing this:\n  ?p \\<in> set (poly_list fml) \\<Longrightarrow>\n  ls ! index_of ps ?p = poly ?p x\n\ngoal (1 subgoal):\n 1. real_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls", "apply (induct fml)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>fml1 fml2.\n       \\<lbrakk>(\\<And>p.\n                    p \\<in> set (poly_list fml1) \\<Longrightarrow>\n                    ls ! index_of ps p = poly p x) \\<Longrightarrow>\n                real_sem fml1 x =\n                lookup_sem (map_fml (index_of ps) fml1) ls;\n        (\\<And>p.\n            p \\<in> set (poly_list fml2) \\<Longrightarrow>\n            ls ! index_of ps p = poly p x) \\<Longrightarrow>\n        real_sem fml2 x = lookup_sem (map_fml (index_of ps) fml2) ls;\n        \\<And>p.\n           p \\<in> set (poly_list (And fml1 fml2)) \\<Longrightarrow>\n           ls ! index_of ps p = poly p x\\<rbrakk>\n       \\<Longrightarrow> real_sem (And fml1 fml2) x =\n                         lookup_sem (map_fml (index_of ps) (And fml1 fml2))\n                          ls\n 2. \\<And>fml1 fml2.\n       \\<lbrakk>(\\<And>p.\n                    p \\<in> set (poly_list fml1) \\<Longrightarrow>\n                    ls ! index_of ps p = poly p x) \\<Longrightarrow>\n                real_sem fml1 x =\n                lookup_sem (map_fml (index_of ps) fml1) ls;\n        (\\<And>p.\n            p \\<in> set (poly_list fml2) \\<Longrightarrow>\n            ls ! index_of ps p = poly p x) \\<Longrightarrow>\n        real_sem fml2 x = lookup_sem (map_fml (index_of ps) fml2) ls;\n        \\<And>p.\n           p \\<in> set (poly_list (Or fml1 fml2)) \\<Longrightarrow>\n           ls ! index_of ps p = poly p x\\<rbrakk>\n       \\<Longrightarrow> real_sem (Or fml1 fml2) x =\n                         lookup_sem (map_fml (index_of ps) (Or fml1 fml2))\n                          ls\n 3. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (fml.Gt xa)) \\<Longrightarrow>\n           ls ! index_of ps p = poly p x) \\<Longrightarrow>\n       real_sem (fml.Gt xa) x =\n       lookup_sem (map_fml (index_of ps) (fml.Gt xa)) ls\n 4. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (Geq xa)) \\<Longrightarrow>\n           ls ! index_of ps p = poly p x) \\<Longrightarrow>\n       real_sem (Geq xa) x = lookup_sem (map_fml (index_of ps) (Geq xa)) ls\n 5. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (fml.Lt xa)) \\<Longrightarrow>\n           ls ! index_of ps p = poly p x) \\<Longrightarrow>\n       real_sem (fml.Lt xa) x =\n       lookup_sem (map_fml (index_of ps) (fml.Lt xa)) ls\n 6. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (Leq xa)) \\<Longrightarrow>\n           ls ! index_of ps p = poly p x) \\<Longrightarrow>\n       real_sem (Leq xa) x = lookup_sem (map_fml (index_of ps) (Leq xa)) ls\n 7. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (fml.Eq xa)) \\<Longrightarrow>\n           ls ! index_of ps p = poly p x) \\<Longrightarrow>\n       real_sem (fml.Eq xa) x =\n       lookup_sem (map_fml (index_of ps) (fml.Eq xa)) ls\n 8. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (Neq xa)) \\<Longrightarrow>\n           ls ! index_of ps p = poly p x) \\<Longrightarrow>\n       real_sem (Neq xa) x = lookup_sem (map_fml (index_of ps) (Neq xa)) ls", "by auto"], ["", "lemma convert_semantics_R:\n  shows \"real_sem fml x = lookup_sem (fst (convert fml)) (map (\\<lambda>p. poly p x) (snd (convert fml)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_sem fml x =\n    lookup_sem (fst (convert fml))\n     (map (\\<lambda>p. poly p x) (snd (convert fml)))", "unfolding convert_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_sem fml x =\n    lookup_sem\n     (fst (map_fml (index_of (remdups (poly_list fml))) fml,\n           remdups (poly_list fml)))\n     (map (\\<lambda>p. poly p x)\n       (snd (map_fml (index_of (remdups (poly_list fml))) fml,\n             remdups (poly_list fml))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_sem fml x =\n    lookup_sem (map_fml (index_of (remdups (poly_list fml))) fml)\n     (map (\\<lambda>p. poly p x) (remdups (poly_list fml)))", "apply (intro convert_semantics_lem_R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> set (poly_list fml) \\<Longrightarrow>\n       map (\\<lambda>p. poly p x) (remdups (poly_list fml)) !\n       index_of (remdups (poly_list fml)) p =\n       poly p x", "by (simp add: index_of_lookup(1) index_of_lookup(2))"], ["", "(* Main result *)"], ["", "theorem decision_procedure_R:\n  shows \"(\\<forall>x::real. real_sem fml x) \\<longleftrightarrow> (decide_universal_R fml)\"\n    \"\\<exists>x::real. real_sem fml x \\<longleftrightarrow> (decide_existential_R fml)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. real_sem fml x) = decide_universal_R fml &&&\n    \\<exists>x. real_sem fml x = decide_existential_R fml", "using  convert_semantics_lem_R decide_univ_lem_helper_R"], ["proof (prove)\nusing this:\n  (\\<And>p.\n      p \\<in> set (poly_list ?fml) \\<Longrightarrow>\n      ?ls ! index_of ?ps p = poly p ?x) \\<Longrightarrow>\n  real_sem ?fml ?x = lookup_sem (map_fml (index_of ?ps) ?fml) ?ls\n  (?fml_struct, ?polys) = convert ?fml \\<Longrightarrow>\n  (\\<forall>x. lookup_sem ?fml_struct (map (\\<lambda>p. poly p x) ?polys)) =\n  decide_universal_R ?fml\n\ngoal (1 subgoal):\n 1. (\\<forall>x. real_sem fml x) = decide_universal_R fml &&&\n    \\<exists>x. real_sem fml x = decide_existential_R fml", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>fml ls ps x.\n                (\\<And>p.\n                    p \\<in> set (poly_list fml) \\<Longrightarrow>\n                    ls ! index_of ps p = poly p x) \\<Longrightarrow>\n                real_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls;\n     \\<And>fml_struct polys fml.\n        (fml_struct, polys) = convert fml \\<Longrightarrow>\n        (\\<forall>x.\n            lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n        decide_universal_R fml;\n     \\<forall>x. real_sem fml x\\<rbrakk>\n    \\<Longrightarrow> decide_universal_R fml\n 2. \\<And>x.\n       \\<lbrakk>\\<And>fml ls ps x.\n                   (\\<And>p.\n                       p \\<in> set (poly_list fml) \\<Longrightarrow>\n                       ls ! index_of ps p = poly p x) \\<Longrightarrow>\n                   real_sem fml x =\n                   lookup_sem (map_fml (index_of ps) fml) ls;\n        \\<And>fml_struct polys fml.\n           (fml_struct, polys) = convert fml \\<Longrightarrow>\n           (\\<forall>x.\n               lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n           decide_universal_R fml;\n        decide_universal_R fml\\<rbrakk>\n       \\<Longrightarrow> real_sem fml x\n 3. \\<lbrakk>\\<And>fml ls ps x.\n                (\\<And>p.\n                    p \\<in> set (poly_list fml) \\<Longrightarrow>\n                    ls ! index_of ps p = poly p x) \\<Longrightarrow>\n                real_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls;\n     \\<And>fml_struct polys fml.\n        (fml_struct, polys) = convert fml \\<Longrightarrow>\n        (\\<forall>x.\n            lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n        decide_universal_R fml\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. real_sem fml x = decide_existential_R fml", "apply (simp add: convert_semantics_R)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>fml ls ps x.\n                   (\\<And>p.\n                       p \\<in> set (poly_list fml) \\<Longrightarrow>\n                       ls ! index_of ps p = poly p x) \\<Longrightarrow>\n                   real_sem fml x =\n                   lookup_sem (map_fml (index_of ps) fml) ls;\n        \\<And>fml_struct polys fml.\n           (fml_struct, polys) = convert fml \\<Longrightarrow>\n           (\\<forall>x.\n               lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n           decide_universal_R fml;\n        decide_universal_R fml\\<rbrakk>\n       \\<Longrightarrow> real_sem fml x\n 2. \\<lbrakk>\\<And>fml ls ps x.\n                (\\<And>p.\n                    p \\<in> set (poly_list fml) \\<Longrightarrow>\n                    ls ! index_of ps p = poly p x) \\<Longrightarrow>\n                real_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls;\n     \\<And>fml_struct polys fml.\n        (fml_struct, polys) = convert fml \\<Longrightarrow>\n        (\\<forall>x.\n            lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n        decide_universal_R fml\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. real_sem fml x = decide_existential_R fml", "apply (metis convert_def convert_semantics_R fst_conv snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>fml ls ps x.\n                (\\<And>p.\n                    p \\<in> set (poly_list fml) \\<Longrightarrow>\n                    ls ! index_of ps p = poly p x) \\<Longrightarrow>\n                real_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls;\n     \\<And>fml_struct polys fml.\n        (fml_struct, polys) = convert fml \\<Longrightarrow>\n        (\\<forall>x.\n            lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n        decide_universal_R fml\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. real_sem fml x = decide_existential_R fml", "using convert_semantics_lem_R"], ["proof (prove)\nusing this:\n  (\\<And>p.\n      p \\<in> set (poly_list ?fml) \\<Longrightarrow>\n      ?ls ! index_of ?ps p = poly p ?x) \\<Longrightarrow>\n  real_sem ?fml ?x = lookup_sem (map_fml (index_of ?ps) ?fml) ?ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>fml ls ps x.\n                (\\<And>p.\n                    p \\<in> set (poly_list fml) \\<Longrightarrow>\n                    ls ! index_of ps p = poly p x) \\<Longrightarrow>\n                real_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls;\n     \\<And>fml_struct polys fml.\n        (fml_struct, polys) = convert fml \\<Longrightarrow>\n        (\\<forall>x.\n            lookup_sem fml_struct (map (\\<lambda>p. poly p x) polys)) =\n        decide_universal_R fml\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. real_sem fml x = decide_existential_R fml", "by (metis convert_def convert_semantics_R decide_exis_lem_helper_R fst_conv snd_conv)"], ["", "end"]]}