{"file_name": "/home/qj213/afp-2021-10-22/thys/BenOr_Kozen_Reif/More_Matrix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BenOr_Kozen_Reif", "problem_names": ["lemma arith:\n  assumes \"d < a\"\n  assumes \"c < b\"\n  shows \"b*d+c < a*(b::nat)\"", "lemma dim_kronecker[simp]:\n  \"dim_row (kronecker_product A B) = dim_row A * dim_row B\"\n  \"dim_col (kronecker_product A B) = dim_col A * dim_col B\"", "lemma kronecker_inverse_index:\n  assumes \"r < dim_row A\" \"s < dim_col A\"\n  assumes \"v < dim_row B\" \"w < dim_col B\"\n  shows \"kronecker_product A B $$ (dim_row B*r+v, dim_col B*s+w) = A $$ (r,s) * B $$ (v,w)\"", "lemma kronecker_distr_left:\n  assumes \"dim_row B = dim_row C\" \"dim_col B = dim_col C\"\n  shows \"kronecker_product A (B+C) = kronecker_product A B + kronecker_product A C\"", "lemma kronecker_distr_right:\n  assumes \"dim_row B = dim_row C\" \"dim_col B = dim_col C\"\n  shows \"kronecker_product (B+C) A = kronecker_product B A + kronecker_product C A\"", "lemma index_mat_mod[simp]: \"nr > 0 & nc > 0 \\<Longrightarrow> mat nr nc f $$ (i mod nr,j mod nc) = f (i mod nr,j mod nc)\"", "lemma kronecker_assoc:\n  shows \"kronecker_product A (kronecker_product B C) = kronecker_product (kronecker_product A B) C\"", "lemma sum_sum_mod_div:\n  \"(\\<Sum>ia = 0::nat..<x. \\<Sum>ja = 0..<y. f ia ja) =\n   (\\<Sum>ia = 0..<x*y. f (ia div y) (ia mod y))\"", "lemma kronecker_of_mult:\n  assumes \"dim_col (A :: 'a :: comm_ring mat) = dim_row C\"\n  assumes \"dim_col B = dim_row D\"\n  shows \"kronecker_product A B * kronecker_product C D = kronecker_product (A * C) (B * D)\"", "lemma inverts_mat_length:\n  assumes \"square_mat A\" \"inverts_mat A B\" \"inverts_mat B A\"\n  shows \"dim_row B = dim_row A\" \"dim_col B = dim_col A\"", "lemma less_mult_imp_mod_less:\n  \"m mod i < i\" if \"m < n * i\" for m n i :: nat", "lemma kronecker_one:\n  shows \"kronecker_product ((1\\<^sub>m x)::'a :: ring_1 mat) (1\\<^sub>m y) = 1\\<^sub>m (x*y)\"", "lemma kronecker_invertible:\n  assumes \"invertible_mat (A :: 'a :: comm_ring_1 mat)\" \"invertible_mat B\"\n  shows \"invertible_mat (kronecker_product A B)\"", "lemma dim_row_conjugate[simp]: \"dim_row (conjugate m) = dim_row m\"", "lemma dim_col_conjugate[simp]: \"dim_col (conjugate m) = dim_col m\"", "lemma carrier_vec_conjugate[simp]: \"m \\<in> carrier_mat nr nc \\<Longrightarrow> conjugate m \\<in> carrier_mat nr nc\"", "lemma mat_index_conjugate[simp]:\n  shows \"i < dim_row m \\<Longrightarrow> j < dim_col m \\<Longrightarrow> conjugate m  $$ (i,j) = conjugate (m $$ (i,j))\"", "lemma row_conjugate[simp]: \"i < dim_row m \\<Longrightarrow> row (conjugate m) i = conjugate (row m i)\"", "lemma col_conjugate[simp]: \"i < dim_col m \\<Longrightarrow> col (conjugate m) i = conjugate (col m i)\"", "lemma rows_conjugate: \"rows (conjugate m) = map conjugate (rows m)\"", "lemma cols_conjugate: \"cols (conjugate m) = map conjugate (cols m)\"", "lemma transpose_conjugate:\n  shows \"(conjugate A)\\<^sup>T = A\\<^sup>H\"", "lemma vec_module_col_helper:\n  fixes A:: \"('a :: field) mat\"\n  shows \"(0\\<^sub>v (dim_row A) \\<in> LinearCombinations.module.span class_ring \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr> (set (cols A)))\"", "lemma vec_module_col_helper2:\n  fixes A:: \"('a :: field) mat\"\n  shows \"\\<And>a x. x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined,\n                   zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n           (\\<And>a b v. (a + b) \\<cdot>\\<^sub>v v = a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n           a \\<cdot>\\<^sub>v x\n           \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined,\n                  zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\"", "lemma vec_module_col: \"module (class_ring :: 'a :: field ring)\n  (module_vec TYPE('a) \n    (dim_row A)\n      \\<lparr>carrier :=\n         LinearCombinations.module.span\n          class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\"", "lemma vec_vs_col: \"vectorspace (class_ring :: 'a :: field ring)\n  (module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n         LinearCombinations.module.span\n          class_ring\n          (module_vec TYPE('a)\n            (dim_row A))\n          (set (cols A))\\<rparr>)\"", "lemma cols_mat_mul_map:\n  shows \"cols (A * B) = map ((*\\<^sub>v) A) (cols B)\"", "lemma cols_mat_mul:\n  shows \"set (cols (A * B)) = (*\\<^sub>v) A ` set (cols B)\"", "lemma set_obtain_sublist:\n  assumes \"S \\<subseteq> set ls\"\n  obtains ss where \"distinct ss\" \"S = set ss\"", "lemma mul_mat_of_cols:\n  assumes \"A \\<in> carrier_mat nr n\"\n  assumes \"\\<And>j. j < length cs \\<Longrightarrow> cs ! j \\<in> carrier_vec n\"\n  shows \"A * (mat_of_cols n cs) = mat_of_cols nr (map ((*\\<^sub>v) A) cs)\"", "lemma helper:\n  fixes x y z ::\"'a :: {conjugatable_ring, comm_ring}\"\n  shows \"x * (y * z) = y * x * z\"", "lemma cscalar_prod_conjugate_transpose:\n  fixes x y ::\"'a :: {conjugatable_ring, comm_ring} vec\"\n  assumes \"A \\<in> carrier_mat nr nc\"\n  assumes \"x \\<in> carrier_vec nr\"\n  assumes \"y \\<in> carrier_vec nc\"\n  shows \"x \\<bullet>c (A *\\<^sub>v y) = (A\\<^sup>H *\\<^sub>v x) \\<bullet>c y\"", "lemma mat_mul_conjugate_transpose_vec_eq_0:                        \n  fixes v ::\"'a :: {conjugatable_ordered_ring,semiring_no_zero_divisors,comm_ring} vec\"\n  assumes \"A \\<in> carrier_mat nr nc\"\n  assumes \"v \\<in> carrier_vec nr\"\n  assumes \"A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v) = 0\\<^sub>v nr\"\n  shows \"A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc\"", "lemma row_mat_of_cols:\n  assumes \"i < nr\"\n  shows \"row (mat_of_cols nr ls) i = vec (length ls) (\\<lambda>j. (ls ! j) $i)\"", "lemma mat_of_cols_cons_mat_vec:\n  fixes v ::\"'a::comm_ring vec\"\n  assumes \"v \\<in> carrier_vec (length ls)\"\n  assumes \"dim_vec a = nr\"\n  shows\n    \"mat_of_cols nr (a # ls) *\\<^sub>v (vCons m v) =\n   m \\<cdot>\\<^sub>v a + mat_of_cols nr ls *\\<^sub>v v\"", "lemma smult_vec_zero:\n  fixes v ::\"'a::ring vec\"\n  shows \"0 \\<cdot>\\<^sub>v v = 0\\<^sub>v (dim_vec v)\"", "lemma helper2:\n  fixes A ::\"'a::comm_ring mat\"\n  fixes v ::\"'a vec\"\n  assumes \"v \\<in> carrier_vec (length ss)\"\n  assumes \"\\<And>x. x \\<in> set ls \\<Longrightarrow> dim_vec x = nr\"\n  shows\n    \"mat_of_cols nr ss *\\<^sub>v v =\n   mat_of_cols nr (ls @ ss) *\\<^sub>v (0\\<^sub>v (length ls) @\\<^sub>v v)\"", "lemma mat_of_cols_mult_mat_vec_permute_list:\n  fixes v ::\"'a::comm_ring list\"\n  assumes \"f permutes {..<length ss}\"\n  assumes \"length ss = length v\"\n  shows\n    \"mat_of_cols nr (permute_list f ss) *\\<^sub>v vec_of_list (permute_list f v) =\n     mat_of_cols nr ss *\\<^sub>v vec_of_list v\"", "lemma subindex_permutation:\n  assumes \"distinct ss\" \"set ss \\<subseteq> {..<length ls}\"\n  obtains f where \"f permutes {..<length ls}\"\n    \"permute_list f ls = map ((!) ls) (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @ map ((!) ls) ss\"", "lemma subindex_permutation2:\n  assumes \"distinct ss\" \"set ss \\<subseteq> {..<length ls}\"\n  obtains f where \"f permutes {..<length ls}\"\n    \"ls = permute_list f (map ((!) ls) (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @ map ((!) ls) ss)\"", "lemma distinct_list_subset_nths:\n  assumes \"distinct ss\" \"set ss \\<subseteq> set ls\"\n  obtains ids where \"distinct ids\" \"set ids \\<subseteq> {..<length ls}\" \"ss = map ((!) ls) ids\"", "lemma helper3: \n  fixes A ::\"'a::comm_ring mat\"\n  assumes A: \"A \\<in> carrier_mat nr nc\"\n  assumes ss:\"distinct ss\" \"set ss \\<subseteq> set (cols A)\"\n  assumes \"v \\<in> carrier_vec (length ss)\"\n  obtains c where \"mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c\" \"dim_vec c = nc\"", "lemma mat_mul_conjugate_transpose_sub_vec_eq_0:                        \n  fixes A ::\"'a :: {conjugatable_ordered_ring,semiring_no_zero_divisors,comm_ring} mat\"\n  assumes \"A \\<in> carrier_mat nr nc\"\n  assumes \"distinct ss\" \"set ss \\<subseteq> set (cols (A\\<^sup>H))\"\n  assumes \"v \\<in> carrier_vec (length ss)\"\n  assumes \"A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v v) = 0\\<^sub>v nr\"\n  shows \"(mat_of_cols nc ss *\\<^sub>v v) = 0\\<^sub>v nc\"", "lemma Units_invertible:\n  fixes A:: \"'a::semiring_1 mat\"\n  assumes \"A \\<in> Units (ring_mat TYPE('a) n b)\"\n  shows \"invertible_mat A\"", "lemma invertible_Units:\n  fixes A:: \"'a::semiring_1 mat\"\n  assumes \"invertible_mat A\"\n  shows \"A \\<in> Units (ring_mat TYPE('a) (dim_row A) b)\"", "lemma invertible_det:\n  fixes A:: \"'a::field mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"invertible_mat A \\<longleftrightarrow> det A \\<noteq> 0\"", "lemma find_indices_distinct:\n  assumes \"distinct ss\"\n  assumes \"i < length ss\"\n  shows \"find_indices (ss ! i) ss = [i]\"", "lemma lin_indpt_lin_comb_list:\n  assumes \"distinct ss\"\n  assumes \"lin_indpt (set ss)\"\n  assumes \"set ss \\<subseteq> carrier_vec n\"\n  assumes \"lincomb_list f ss = 0\\<^sub>v n\"\n  assumes \"i < length ss\"\n  shows \"f i = 0\"", "lemma span_mat_mul_subset:\n  assumes \"A \\<in> carrier_mat n d\"\n  assumes \"B \\<in> carrier_mat d nc\"\n  shows \"span (set (cols (A * B))) \\<subseteq> span (set (cols A))\"", "lemma rank_mat_mul_right:\n  assumes \"A \\<in> carrier_mat n d\"\n  assumes \"B \\<in> carrier_mat d nc\"\n  shows \"rank (A * B) \\<le> rank A\"", "lemma sumlist_drop:\n  assumes \"\\<And>v. v \\<in> set ls \\<Longrightarrow> dim_vec v = n\"\n  shows \"sumlist ls = sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls)\"", "lemma lincomb_list_alt:\n  shows \"lincomb_list c s =\n    sumlist (map2 (\\<lambda>i j. i \\<cdot>\\<^sub>v s ! j) (map (\\<lambda>i. c i) [0..<length s]) [0..<length s])\"", "lemma lincomb_list_alt2:\n  assumes \"\\<And>v. v \\<in> set s \\<Longrightarrow> dim_vec v = n\"\n  assumes \"\\<And>i. i \\<in> set ls \\<Longrightarrow> i < length s\"\n  shows \"\n    sumlist (map2 (\\<lambda>i j. i \\<cdot>\\<^sub>v s ! j) (map (\\<lambda>i. c i) ls) ls) =\n    sumlist (map2 (\\<lambda>i j. i \\<cdot>\\<^sub>v s ! j) (map (\\<lambda>i. c i) (filter (\\<lambda>i. c i \\<noteq> 0) ls)) (filter (\\<lambda>i. c i \\<noteq> 0) ls))\"", "lemma two_set:\n  assumes \"distinct ls\"\n  assumes \"set ls = set [a,b]\"\n  assumes \"a \\<noteq> b\"\n  shows \"ls = [a,b] \\<or> ls = [b,a]\"", "lemma filter_disj_inds:\n  assumes \"i < length ls\" \"j < length ls\" \"i \\<noteq> j\"\n  shows \"filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i) [0..<length ls] = [i, j] \\<or>\n  filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i) [0..<length ls] = [j,i]\"", "lemma lincomb_list_indpt_distinct:\n  assumes \"\\<And>v. v \\<in> set ls \\<Longrightarrow> dim_vec v = n\"\n  assumes\n    \"\\<And>c. lincomb_list c ls = 0\\<^sub>v n \\<Longrightarrow> (\\<forall>i. i < (length ls) \\<longrightarrow> c i = 0)\"\n  shows \"distinct ls\"", "lemma transpose_rank_mul_conjugate_transpose:\n  fixes A :: \"'a mat\"\n  assumes \"A \\<in> carrier_mat n nc\"\n  shows \"vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)\"", "lemma conjugate_transpose_rank_le:\n  assumes \"A \\<in> carrier_mat n nc\"\n  shows \"vec_space.rank nc (A\\<^sup>H) \\<le> rank A\"", "lemma conjugate_finsum:\n  assumes f: \"f : U \\<rightarrow> carrier_vec n\"\n  shows \"conjugate (finsum V f U) = finsum V (conjugate \\<circ> f) U\"", "lemma rank_conjugate_le:\n  assumes A:\"A \\<in> carrier_mat n d\"\n  shows \"rank (conjugate (A)) \\<le> rank A\"", "lemma rank_conjugate:\n  assumes \"A \\<in> carrier_mat n d\"\n  shows \"rank (conjugate A) = rank A\"", "lemma conjugate_transpose_rank:\n  fixes A::\"'a::{conjugatable_ordered_field} mat\"\n  shows \"vec_space.rank (dim_row A) A = vec_space.rank (dim_col A) (A\\<^sup>H)\"", "lemma transpose_rank:\n  fixes A::\"'a::{conjugatable_ordered_field} mat\"\n  shows \"vec_space.rank (dim_row A) A = vec_space.rank (dim_col A) (A\\<^sup>T)\"", "lemma rank_mat_mul_left:\n  fixes A::\"'a::{conjugatable_ordered_field} mat\"\n  assumes \"A \\<in> carrier_mat n d\"\n  assumes \"B \\<in> carrier_mat d nc\"\n  shows \"vec_space.rank n (A * B) \\<le> vec_space.rank d B\"", "lemma cong1:\n  \"x = y \\<Longrightarrow>  mat_of_cols n x = mat_of_cols n y\"", "lemma nth_filter:\n  assumes \"j < length (filter P ls)\"\n  shows \"P  ((filter P ls) ! j)\"", "lemma take_cols_mat_mul:\n  assumes \"A \\<in> carrier_mat nr n\"\n  assumes \"B \\<in> carrier_mat n nc\"\n  shows \"A * take_cols B inds = take_cols (A * B) inds\"", "lemma take_cols_carrier_mat:\n  assumes \"A \\<in> carrier_mat nr nc\"\n  obtains n where \"take_cols A inds \\<in> carrier_mat nr n\"", "lemma take_cols_carrier_mat_strict:\n  assumes \"A \\<in> carrier_mat nr nc\"\n  assumes \"\\<And>i. i \\<in> set inds \\<Longrightarrow> i < nc\"\n  shows \"take_cols A inds \\<in> carrier_mat nr (length inds)\"", "lemma gauss_jordan_take_cols:  \n  assumes \"gauss_jordan A (take_cols A inds) = (C,D)\"\n  shows \"D = take_cols C inds\"", "lemma dim_col_take_cols:\n  assumes \"\\<And>j. j \\<in> set inds \\<Longrightarrow> j < dim_col A\"\n  shows \"dim_col (take_cols A inds) = length inds\"", "lemma dim_col_take_rows[simp]:\n  shows \"dim_col (take_rows A inds) = dim_col A\"", "lemma cols_take_cols_subset:\n  shows \"set (cols (take_cols A inds)) \\<subseteq> set (cols A)\"", "lemma dim_row_take_cols[simp]:\n  shows \"dim_row (take_cols A ls) = dim_row A\"", "lemma dim_row_append_rows[simp]:\n  shows \"dim_row (A @\\<^sub>r B) = dim_row A + dim_row B\"", "lemma rows_inj:\n  assumes \"dim_col A = dim_col B\"\n  assumes \"rows A = rows B\"\n  shows \"A = B\"", "lemma append_rows_index:\n  assumes \"dim_col A = dim_col B\"\n  assumes \"i < dim_row A + dim_row B\"\n  assumes \"j < dim_col A\"\n  shows \"(A @\\<^sub>r B) $$ (i,j) = (if i < dim_row A then A $$ (i,j) else B $$ (i-dim_row A,j))\"", "lemma row_append_rows:\n  assumes \"dim_col A = dim_col B\"\n  assumes \"i < dim_row A + dim_row B\"\n  shows \"row (A @\\<^sub>r B) i = (if i < dim_row A then row A i else row B (i-dim_row A))\"", "lemma append_rows_mat_mul:\n  assumes \"dim_col A = dim_col B\"\n  shows \"(A @\\<^sub>r B) * C = A * C @\\<^sub>r B * C\"", "lemma cardlt:\n  shows \"card  {i. i < (n::nat)} \\<le> n\"", "lemma row_echelon_form_zero_rows:\n  assumes row_ech: \"row_echelon_form A\"\n  assumes dim_asm: \"dim_col A \\<ge> dim_row A\"\n  shows \"take_rows A [0..<length (pivot_positions A)] @\\<^sub>r  0\\<^sub>m (dim_row A - length (pivot_positions A))  (dim_col A) = A\"", "lemma length_pivot_positions_dim_row:\n  assumes \"row_echelon_form A\"\n  shows \"length (pivot_positions A) \\<le> dim_row A\"", "lemma rref_pivot_positions:\n  assumes \"row_echelon_form R\"\n  assumes R: \"R \\<in> carrier_mat nr nc\"\n  shows \"\\<And>i j. (i,j) \\<in> set (pivot_positions R) \\<Longrightarrow> i < nr \\<and> j < nc\"", "lemma pivot_fun_monoton: \n  assumes pf: \"pivot_fun A f (dim_col A)\"\n  assumes dr: \"dim_row A = nr\"\n  shows \"\\<And> i. i < nr \\<Longrightarrow> (\\<And> k. ((k < nr \\<and> i < k) \\<longrightarrow> f i \\<le> f k))\"", "lemma pivot_positions_contains:\n  assumes row_ech: \"row_echelon_form A\"\n  assumes dim_h: \"dim_col A \\<ge> dim_row A\"\n  assumes \"pivot_fun A f (dim_col A)\"\n  shows \"\\<forall>i < (length (pivot_positions A)). (i, f i) \\<in> set (pivot_positions A)\"", "lemma pivot_positions_form_helper_1:\n  shows \"(a, b) \\<in> set (pivot_positions_main_gen z A nr nc i j) \\<Longrightarrow> i \\<le> a\"", "lemma pivot_positions_form_helper_2:\n  shows \"strict_sorted (map fst (pivot_positions_main_gen z A nr nc i j))\"", "lemma sorted_pivot_positions:\n  shows \"strict_sorted (map fst (pivot_positions A))\"", "lemma pivot_positions_form:\n  assumes row_ech: \"row_echelon_form A\"\n  assumes dim_h: \"dim_col A \\<ge> dim_row A\"\n  shows \"\\<forall> i < (length (pivot_positions A)). fst ((pivot_positions A) ! i) = i\"", "lemma take_cols_pivot_eq:\n  assumes row_ech: \"row_echelon_form A\"\n  assumes dim_h: \"dim_col A \\<ge> dim_row A\"\n  shows \"take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (length (pivot_positions A))\"", "lemma rref_right_mul:\n  assumes \"row_echelon_form A\"\n  assumes \"dim_col A \\<ge> dim_row A\"\n  shows\n    \"take_cols A (map snd (pivot_positions A)) * take_rows A [0..<length (pivot_positions A)] = A\"", "lemma lin_indpt_id:\n  shows \"lin_indpt (set (cols (1\\<^sub>m n)::'a vec list))\"", "lemma lin_indpt_take_cols_id:\n  shows \"lin_indpt (set (cols (take_cols (1\\<^sub>m n) inds)))\"", "lemma cols_id_unit_vecs:\n  shows \"cols (1\\<^sub>m d) = unit_vecs d\"", "lemma distinct_cols_id:\n  shows \"distinct (cols (1\\<^sub>m d)::'a vec list)\"", "lemma distinct_map_nth:\n  assumes \"distinct ls\"\n  assumes \"distinct inds\"\n  assumes \"\\<And>j. j \\<in> set inds \\<Longrightarrow> j < length ls\"\n  shows \"distinct (map ((!) ls) inds)\"", "lemma distinct_take_cols_id:\n  assumes \"distinct inds\"\n  shows \"distinct (cols (take_cols (1\\<^sub>m n) inds) :: 'a vec list)\"", "lemma rank_take_cols:\n  assumes \"distinct inds\"\n  shows \"rank (take_cols (1\\<^sub>m n) inds) = length (filter ((>) n) inds)\"", "lemma rank_mul_left_invertible_mat:\n  fixes A::\"'a mat\"\n  assumes \"invertible_mat A\"\n  assumes \"A \\<in> carrier_mat n n\"\n  assumes \"B \\<in> carrier_mat n nc\"\n  shows \"rank (A * B) = rank B\"", "lemma invertible_take_cols_rank:\n  fixes A::\"'a mat\"\n  assumes \"invertible_mat A\"\n  assumes \"A \\<in> carrier_mat n n\"\n  assumes \"distinct inds\"\n  shows \"rank (take_cols A inds) = length (filter ((>) n) inds)\"", "lemma rank_take_cols_leq:\n  assumes R:\"R \\<in> carrier_mat n nc\"\n  shows \"rank (take_cols R ls) \\<le> rank R\"", "lemma rank_take_cols_geq:\n  assumes R:\"R \\<in> carrier_mat n nc\"\n  assumes t:\"take_cols R ls \\<in> carrier_mat n r\"\n  assumes B:\"B \\<in> carrier_mat r nc\"\n  assumes \"R = (take_cols R ls) * B\"\n  shows \"rank (take_cols R ls) \\<ge> rank R\"", "lemma rref_drop_pivots:\n  assumes row_ech: \"row_echelon_form R\"\n  assumes dims: \"R \\<in> carrier_mat n nc\"\n  assumes order: \"nc \\<ge> n\"\n  shows \"rank (take_cols R (map snd (pivot_positions R))) = rank R\"", "lemma gjs_and_take_cols_var:\n  fixes A::\"'a mat\"\n  assumes A:\"A \\<in> carrier_mat n nc\"\n  assumes order: \"nc \\<ge> n\"\n  shows \"(take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) = \n  (take_cols_var A (map snd (pivot_positions (gauss_jordan_single A))))\"", "lemma gauss_jordan_single_rank:\n  fixes A::\"'a mat\"\n  assumes A:\"A \\<in> carrier_mat n nc\"\n  assumes order: \"nc \\<ge> n\"\n  shows \"rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) = rank A\"", "lemma lin_indpt_subset_cols:\n  fixes A:: \"'a mat\"\n  fixes B:: \"'a vec set\"\n  assumes \"A \\<in> carrier_mat n n\"\n  assumes inv: \"invertible_mat A\"\n  assumes \"B \\<subseteq> set (cols A)\"\n  shows \"lin_indpt B\"", "lemma rank_invertible_subset_cols:\n  fixes A:: \"'a mat\"\n  fixes B:: \"'a vec list\"\n  assumes inv: \"invertible_mat A\"\n  assumes A_square: \"A \\<in> carrier_mat n n\"\n  assumes set_sub: \"set (B) \\<subseteq> set (cols A)\"\n  assumes dist_B: \"distinct B\"\n  shows \"rank (mat_of_cols n B) = length B\""], "translations": [["", "lemma arith:\n  assumes \"d < a\"\n  assumes \"c < b\"\n  shows \"b*d+c < a*(b::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * d + c < a * b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b * d + c < a * b", "have \"b*d+c < b*(d+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * d + c < b * (d + 1)", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  b * d + c < b * (d + 1)\n\ngoal (1 subgoal):\n 1. b * d + c < a * b", "thus ?thesis"], ["proof (prove)\nusing this:\n  b * d + c < b * (d + 1)\n\ngoal (1 subgoal):\n 1. b * d + c < a * b", "by (metis One_nat_def Suc_leI add.right_neutral add_Suc_right assms(1) less_le_trans mult.commute mult_le_cancel2)"], ["proof (state)\nthis:\n  b * d + c < a * b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_kronecker[simp]:\n  \"dim_row (kronecker_product A B) = dim_row A * dim_row B\"\n  \"dim_col (kronecker_product A B) = dim_col A * dim_col B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (kronecker_product A B) = dim_row A * dim_row B &&&\n    dim_col (kronecker_product A B) = dim_col A * dim_col B", "unfolding kronecker_product_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n       (\\<lambda>(i, j).\n           A $$ (i div dim_row B, j div dim_col B) *\n           B $$ (i mod dim_row B, j mod dim_col B))) =\n    dim_row A * dim_row B &&&\n    dim_col\n     (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n       (\\<lambda>(i, j).\n           A $$ (i div dim_row B, j div dim_col B) *\n           B $$ (i mod dim_row B, j mod dim_col B))) =\n    dim_col A * dim_col B", "by auto"], ["", "lemma kronecker_inverse_index:\n  assumes \"r < dim_row A\" \"s < dim_col A\"\n  assumes \"v < dim_row B\" \"w < dim_col B\"\n  shows \"kronecker_product A B $$ (dim_row B*r+v, dim_col B*s+w) = A $$ (r,s) * B $$ (v,w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kronecker_product A B $$ (dim_row B * r + v, dim_col B * s + w) =\n    A $$ (r, s) * B $$ (v, w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. kronecker_product A B $$ (dim_row B * r + v, dim_col B * s + w) =\n    A $$ (r, s) * B $$ (v, w)", "from arith[OF assms(1) assms(3)]"], ["proof (chain)\npicking this:\n  dim_row B * r + v < dim_row A * dim_row B", "have \"dim_row B*r+v < dim_row A * dim_row B\""], ["proof (prove)\nusing this:\n  dim_row B * r + v < dim_row A * dim_row B\n\ngoal (1 subgoal):\n 1. dim_row B * r + v < dim_row A * dim_row B", "."], ["proof (state)\nthis:\n  dim_row B * r + v < dim_row A * dim_row B\n\ngoal (1 subgoal):\n 1. kronecker_product A B $$ (dim_row B * r + v, dim_col B * s + w) =\n    A $$ (r, s) * B $$ (v, w)", "moreover"], ["proof (state)\nthis:\n  dim_row B * r + v < dim_row A * dim_row B\n\ngoal (1 subgoal):\n 1. kronecker_product A B $$ (dim_row B * r + v, dim_col B * s + w) =\n    A $$ (r, s) * B $$ (v, w)", "from arith[OF assms(2) assms(4)]"], ["proof (chain)\npicking this:\n  dim_col B * s + w < dim_col A * dim_col B", "have \"dim_col B * s + w < dim_col A * dim_col B\""], ["proof (prove)\nusing this:\n  dim_col B * s + w < dim_col A * dim_col B\n\ngoal (1 subgoal):\n 1. dim_col B * s + w < dim_col A * dim_col B", "."], ["proof (state)\nthis:\n  dim_col B * s + w < dim_col A * dim_col B\n\ngoal (1 subgoal):\n 1. kronecker_product A B $$ (dim_row B * r + v, dim_col B * s + w) =\n    A $$ (r, s) * B $$ (v, w)", "ultimately"], ["proof (chain)\npicking this:\n  dim_row B * r + v < dim_row A * dim_row B\n  dim_col B * s + w < dim_col A * dim_col B", "show ?thesis"], ["proof (prove)\nusing this:\n  dim_row B * r + v < dim_row A * dim_row B\n  dim_col B * s + w < dim_col A * dim_col B\n\ngoal (1 subgoal):\n 1. kronecker_product A B $$ (dim_row B * r + v, dim_col B * s + w) =\n    A $$ (r, s) * B $$ (v, w)", "unfolding kronecker_product_def Let_def"], ["proof (prove)\nusing this:\n  dim_row B * r + v < dim_row A * dim_row B\n  dim_col B * s + w < dim_col A * dim_col B\n\ngoal (1 subgoal):\n 1. mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n     (\\<lambda>(i, j).\n         A $$ (i div dim_row B, j div dim_col B) *\n         B $$ (i mod dim_row B, j mod dim_col B)) $$\n    (dim_row B * r + v, dim_col B * s + w) =\n    A $$ (r, s) * B $$ (v, w)", "using assms"], ["proof (prove)\nusing this:\n  dim_row B * r + v < dim_row A * dim_row B\n  dim_col B * s + w < dim_col A * dim_col B\n  r < dim_row A\n  s < dim_col A\n  v < dim_row B\n  w < dim_col B\n\ngoal (1 subgoal):\n 1. mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n     (\\<lambda>(i, j).\n         A $$ (i div dim_row B, j div dim_col B) *\n         B $$ (i mod dim_row B, j mod dim_col B)) $$\n    (dim_row B * r + v, dim_col B * s + w) =\n    A $$ (r, s) * B $$ (v, w)", "by auto"], ["proof (state)\nthis:\n  kronecker_product A B $$ (dim_row B * r + v, dim_col B * s + w) =\n  A $$ (r, s) * B $$ (v, w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kronecker_distr_left:\n  assumes \"dim_row B = dim_row C\" \"dim_col B = dim_col C\"\n  shows \"kronecker_product A (B+C) = kronecker_product A B + kronecker_product A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kronecker_product A (B + C) =\n    kronecker_product A B + kronecker_product A C", "unfolding kronecker_product_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row A * dim_row (B + C)) (dim_col A * dim_col (B + C))\n     (\\<lambda>(i, j).\n         A $$ (i div dim_row (B + C), j div dim_col (B + C)) *\n         (B + C) $$ (i mod dim_row (B + C), j mod dim_col (B + C))) =\n    mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n     (\\<lambda>(i, j).\n         A $$ (i div dim_row B, j div dim_col B) *\n         B $$ (i mod dim_row B, j mod dim_col B)) +\n    mat (dim_row A * dim_row C) (dim_col A * dim_col C)\n     (\\<lambda>(i, j).\n         A $$ (i div dim_row C, j div dim_col C) *\n         C $$ (i mod dim_row C, j mod dim_col C))", "using assms"], ["proof (prove)\nusing this:\n  dim_row B = dim_row C\n  dim_col B = dim_col C\n\ngoal (1 subgoal):\n 1. mat (dim_row A * dim_row (B + C)) (dim_col A * dim_col (B + C))\n     (\\<lambda>(i, j).\n         A $$ (i div dim_row (B + C), j div dim_col (B + C)) *\n         (B + C) $$ (i mod dim_row (B + C), j mod dim_col (B + C))) =\n    mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n     (\\<lambda>(i, j).\n         A $$ (i div dim_row B, j div dim_col B) *\n         B $$ (i mod dim_row B, j mod dim_col B)) +\n    mat (dim_row A * dim_row C) (dim_col A * dim_col C)\n     (\\<lambda>(i, j).\n         A $$ (i div dim_row C, j div dim_col C) *\n         C $$ (i mod dim_row C, j mod dim_col C))", "apply (auto simp add: mat_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>dim_row B = dim_row C; dim_col B = dim_col C;\n        i < dim_row A * dim_row C; j < dim_col A * dim_col C\\<rbrakk>\n       \\<Longrightarrow> A $$ (i div dim_row C, j div dim_col C) *\n                         (B + C) $$ (i mod dim_row C, j mod dim_col C) =\n                         A $$ (i div dim_row C, j div dim_col C) *\n                         B $$ (i mod dim_row C, j mod dim_col C) +\n                         A $$ (i div dim_row C, j div dim_col C) *\n                         C $$ (i mod dim_row C, j mod dim_col C)", "by (metis (no_types, lifting) distrib_left index_add_mat(1) mod_less_divisor mult_eq_0_iff neq0_conv not_less_zero)"], ["", "lemma kronecker_distr_right:\n  assumes \"dim_row B = dim_row C\" \"dim_col B = dim_col C\"\n  shows \"kronecker_product (B+C) A = kronecker_product B A + kronecker_product C A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kronecker_product (B + C) A =\n    kronecker_product B A + kronecker_product C A", "unfolding kronecker_product_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row (B + C) * dim_row A) (dim_col (B + C) * dim_col A)\n     (\\<lambda>(i, j).\n         (B + C) $$ (i div dim_row A, j div dim_col A) *\n         A $$ (i mod dim_row A, j mod dim_col A)) =\n    mat (dim_row B * dim_row A) (dim_col B * dim_col A)\n     (\\<lambda>(i, j).\n         B $$ (i div dim_row A, j div dim_col A) *\n         A $$ (i mod dim_row A, j mod dim_col A)) +\n    mat (dim_row C * dim_row A) (dim_col C * dim_col A)\n     (\\<lambda>(i, j).\n         C $$ (i div dim_row A, j div dim_col A) *\n         A $$ (i mod dim_row A, j mod dim_col A))", "using assms"], ["proof (prove)\nusing this:\n  dim_row B = dim_row C\n  dim_col B = dim_col C\n\ngoal (1 subgoal):\n 1. mat (dim_row (B + C) * dim_row A) (dim_col (B + C) * dim_col A)\n     (\\<lambda>(i, j).\n         (B + C) $$ (i div dim_row A, j div dim_col A) *\n         A $$ (i mod dim_row A, j mod dim_col A)) =\n    mat (dim_row B * dim_row A) (dim_col B * dim_col A)\n     (\\<lambda>(i, j).\n         B $$ (i div dim_row A, j div dim_col A) *\n         A $$ (i mod dim_row A, j mod dim_col A)) +\n    mat (dim_row C * dim_row A) (dim_col C * dim_col A)\n     (\\<lambda>(i, j).\n         C $$ (i div dim_row A, j div dim_col A) *\n         A $$ (i mod dim_row A, j mod dim_col A))", "by (auto simp add: mat_eq_iff less_mult_imp_div_less distrib_right)"], ["", "lemma index_mat_mod[simp]: \"nr > 0 & nc > 0 \\<Longrightarrow> mat nr nc f $$ (i mod nr,j mod nc) = f (i mod nr,j mod nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < nr \\<and> 0 < nc \\<Longrightarrow>\n    mat nr nc f $$ (i mod nr, j mod nc) = f (i mod nr, j mod nc)", "by auto"], ["", "lemma kronecker_assoc:\n  shows \"kronecker_product A (kronecker_product B C) = kronecker_product (kronecker_product A B) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kronecker_product A (kronecker_product B C) =\n    kronecker_product (kronecker_product A B) C", "unfolding kronecker_product_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row A *\n         dim_row\n          (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n            (\\<lambda>(i, j).\n                B $$ (i div dim_row C, j div dim_col C) *\n                C $$ (i mod dim_row C, j mod dim_col C))))\n     (dim_col A *\n      dim_col\n       (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n         (\\<lambda>(i, j).\n             B $$ (i div dim_row C, j div dim_col C) *\n             C $$ (i mod dim_row C, j mod dim_col C))))\n     (\\<lambda>(i, j).\n         A $$\n         (i div\n          dim_row\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C))),\n          j div\n          dim_col\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C)))) *\n         mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n          (\\<lambda>(i, j).\n              B $$ (i div dim_row C, j div dim_col C) *\n              C $$ (i mod dim_row C, j mod dim_col C)) $$\n         (i mod\n          dim_row\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C))),\n          j mod\n          dim_col\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C))))) =\n    mat (dim_row\n          (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n            (\\<lambda>(i, j).\n                A $$ (i div dim_row B, j div dim_col B) *\n                B $$ (i mod dim_row B, j mod dim_col B))) *\n         dim_row C)\n     (dim_col\n       (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n         (\\<lambda>(i, j).\n             A $$ (i div dim_row B, j div dim_col B) *\n             B $$ (i mod dim_row B, j mod dim_col B))) *\n      dim_col C)\n     (\\<lambda>(i, j).\n         mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n          (\\<lambda>(i, j).\n              A $$ (i div dim_row B, j div dim_col B) *\n              B $$ (i mod dim_row B, j mod dim_col B)) $$\n         (i div dim_row C, j div dim_col C) *\n         C $$ (i mod dim_row C, j mod dim_col C))", "apply (case_tac \"dim_row B * dim_row C > 0 & dim_col B * dim_col C > 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < dim_row B * dim_row C \\<and>\n    0 < dim_col B * dim_col C \\<Longrightarrow>\n    mat (dim_row A *\n         dim_row\n          (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n            (\\<lambda>(i, j).\n                B $$ (i div dim_row C, j div dim_col C) *\n                C $$ (i mod dim_row C, j mod dim_col C))))\n     (dim_col A *\n      dim_col\n       (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n         (\\<lambda>(i, j).\n             B $$ (i div dim_row C, j div dim_col C) *\n             C $$ (i mod dim_row C, j mod dim_col C))))\n     (\\<lambda>(i, j).\n         A $$\n         (i div\n          dim_row\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C))),\n          j div\n          dim_col\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C)))) *\n         mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n          (\\<lambda>(i, j).\n              B $$ (i div dim_row C, j div dim_col C) *\n              C $$ (i mod dim_row C, j mod dim_col C)) $$\n         (i mod\n          dim_row\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C))),\n          j mod\n          dim_col\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C))))) =\n    mat (dim_row\n          (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n            (\\<lambda>(i, j).\n                A $$ (i div dim_row B, j div dim_col B) *\n                B $$ (i mod dim_row B, j mod dim_col B))) *\n         dim_row C)\n     (dim_col\n       (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n         (\\<lambda>(i, j).\n             A $$ (i div dim_row B, j div dim_col B) *\n             B $$ (i mod dim_row B, j mod dim_col B))) *\n      dim_col C)\n     (\\<lambda>(i, j).\n         mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n          (\\<lambda>(i, j).\n              A $$ (i div dim_row B, j div dim_col B) *\n              B $$ (i mod dim_row B, j mod dim_col B)) $$\n         (i div dim_row C, j div dim_col C) *\n         C $$ (i mod dim_row C, j mod dim_col C))\n 2. \\<not> (0 < dim_row B * dim_row C \\<and>\n            0 < dim_col B * dim_col C) \\<Longrightarrow>\n    mat (dim_row A *\n         dim_row\n          (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n            (\\<lambda>(i, j).\n                B $$ (i div dim_row C, j div dim_col C) *\n                C $$ (i mod dim_row C, j mod dim_col C))))\n     (dim_col A *\n      dim_col\n       (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n         (\\<lambda>(i, j).\n             B $$ (i div dim_row C, j div dim_col C) *\n             C $$ (i mod dim_row C, j mod dim_col C))))\n     (\\<lambda>(i, j).\n         A $$\n         (i div\n          dim_row\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C))),\n          j div\n          dim_col\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C)))) *\n         mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n          (\\<lambda>(i, j).\n              B $$ (i div dim_row C, j div dim_col C) *\n              C $$ (i mod dim_row C, j mod dim_col C)) $$\n         (i mod\n          dim_row\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C))),\n          j mod\n          dim_col\n           (mat (dim_row B * dim_row C) (dim_col B * dim_col C)\n             (\\<lambda>(i, j).\n                 B $$ (i div dim_row C, j div dim_col C) *\n                 C $$ (i mod dim_row C, j mod dim_col C))))) =\n    mat (dim_row\n          (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n            (\\<lambda>(i, j).\n                A $$ (i div dim_row B, j div dim_col B) *\n                B $$ (i mod dim_row B, j mod dim_col B))) *\n         dim_row C)\n     (dim_col\n       (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n         (\\<lambda>(i, j).\n             A $$ (i div dim_row B, j div dim_col B) *\n             B $$ (i mod dim_row B, j mod dim_col B))) *\n      dim_col C)\n     (\\<lambda>(i, j).\n         mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n          (\\<lambda>(i, j).\n              A $$ (i div dim_row B, j div dim_col B) *\n              B $$ (i mod dim_row B, j mod dim_col B)) $$\n         (i div dim_row C, j div dim_col C) *\n         C $$ (i mod dim_row C, j mod dim_col C))", "apply (auto simp add: mat_eq_iff less_mult_imp_div_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>0 < dim_row B; 0 < dim_row C; 0 < dim_col B; 0 < dim_col C;\n        i < dim_row A * dim_row B * dim_row C;\n        j < dim_col A * dim_col B * dim_col C\\<rbrakk>\n       \\<Longrightarrow> A $$\n                         (i div (dim_row B * dim_row C),\n                          j div (dim_col B * dim_col C)) *\n                         (B $$\n                          (i mod (dim_row B * dim_row C) div dim_row C,\n                           j mod (dim_col B * dim_col C) div dim_col C) *\n                          C $$\n                          (i mod (dim_row B * dim_row C) mod dim_row C,\n                           j mod (dim_col B * dim_col C) mod dim_col C)) =\n                         A $$\n                         (i div dim_row C div dim_row B,\n                          j div dim_col C div dim_col B) *\n                         B $$\n                         (i div dim_row C mod dim_row B,\n                          j div dim_col C mod dim_col B) *\n                         C $$ (i mod dim_row C, j mod dim_col C)", "by (smt div_mult2_eq div_mult_mod_eq kronecker_inverse_index less_mult_imp_div_less linordered_semiring_strict_class.mult_pos_pos mod_less_divisor mod_mult2_eq mult.assoc mult.commute)"], ["", "lemma sum_sum_mod_div:\n  \"(\\<Sum>ia = 0::nat..<x. \\<Sum>ja = 0..<y. f ia ja) =\n   (\\<Sum>ia = 0..<x*y. f (ia div y) (ia mod y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n    (\\<Sum>ia = 0..<x * y. f (ia div y) (ia mod y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n    (\\<Sum>ia = 0..<x * y. f (ia div y) (ia mod y))", "have 1: \"inj_on (\\<lambda>ia. (ia div y, ia mod y)) {0..<x * y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>ia. (ia div y, ia mod y)) {0..<x * y}", "by (smt (verit, best) Pair_inject div_mod_decomp inj_onI)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>ia. (ia div y, ia mod y)) {0..<x * y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n    (\\<Sum>ia = 0..<x * y. f (ia div y) (ia mod y))", "have 21: \"{0..<x} \\<times> {0..<y} \\<subseteq> (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<x} \\<times> {0..<y}\n    \\<subseteq> (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < x; b < y\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (\\<lambda>ia. (ia div y, ia mod y)) `\n                               {0..<x * y}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < x; b < y\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (\\<lambda>ia. (ia div y, ia mod y)) `\n                               {0..<x * y}", "assume *:\"a < x\" \"b < y\""], ["proof (state)\nthis:\n  a < x\n  b < y\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < x; b < y\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (\\<lambda>ia. (ia div y, ia mod y)) `\n                               {0..<x * y}", "have \"a * y +  b \\<in> {0..<x*y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * y + b \\<in> {0..<x * y}", "by (metis arith * atLeastLessThan_iff le0 mult.commute)"], ["proof (state)\nthis:\n  a * y + b \\<in> {0..<x * y}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a < x; b < y\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (\\<lambda>ia. (ia div y, ia mod y)) `\n                               {0..<x * y}", "thus \"(a, b) \\<in> (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\""], ["proof (prove)\nusing this:\n  a * y + b \\<in> {0..<x * y}\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}", "by (metis (no_types, lifting) \"*\"(2) Euclidean_Division.div_eq_0_iff add_cancel_right_right div_mult_self3 gr_implies_not0 image_iff mod_less mod_mult_self3)"], ["proof (state)\nthis:\n  (a, b) \\<in> (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {0..<x} \\<times> {0..<y}\n  \\<subseteq> (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n    (\\<Sum>ia = 0..<x * y. f (ia div y) (ia mod y))", "have 22:\"(\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y} \\<subseteq> {0..<x} \\<times> {0..<y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n    \\<subseteq> {0..<x} \\<times> {0..<y}", "using less_mult_imp_div_less"], ["proof (prove)\nusing this:\n  ?m < ?i * ?n \\<Longrightarrow> ?m div ?n < ?i\n\ngoal (1 subgoal):\n 1. (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n    \\<subseteq> {0..<x} \\<times> {0..<y}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>\\<And>m i n. m < i * n \\<Longrightarrow> m div n < i;\n        ia < x * y\\<rbrakk>\n       \\<Longrightarrow> ia mod y < y", "by (metis mod_less_divisor mult.commute neq0_conv not_less_zero)"], ["proof (state)\nthis:\n  (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n  \\<subseteq> {0..<x} \\<times> {0..<y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n    (\\<Sum>ia = 0..<x * y. f (ia div y) (ia mod y))", "have 2: \"{0..<x} \\<times> {0..<y} = (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<x} \\<times> {0..<y} =\n    (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}", "using 21 22"], ["proof (prove)\nusing this:\n  {0..<x} \\<times> {0..<y}\n  \\<subseteq> (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n  (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n  \\<subseteq> {0..<x} \\<times> {0..<y}\n\ngoal (1 subgoal):\n 1. {0..<x} \\<times> {0..<y} =\n    (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}", "by auto"], ["proof (state)\nthis:\n  {0..<x} \\<times> {0..<y} =\n  (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n    (\\<Sum>ia = 0..<x * y. f (ia div y) (ia mod y))", "have *: \"(\\<Sum>ia = 0::nat..<x. \\<Sum>ja = 0..<y. f ia ja) =\n        (\\<Sum>(x, y)\\<in>{0..<x} \\<times> {0..<y}. f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n    (\\<Sum>(x, y)\\<in>{0..<x} \\<times> {0..<y}. f x y)", "by (auto simp add: sum.cartesian_product)"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n  (\\<Sum>(x, y)\\<in>{0..<x} \\<times> {0..<y}. f x y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n    (\\<Sum>ia = 0..<x * y. f (ia div y) (ia mod y))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n    (\\<Sum>ia = 0..<x * y. f (ia div y) (ia mod y))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(x, y)\\<in>{0..<x} \\<times> {0..<y}. f x y) =\n    (\\<Sum>ia = 0..<x * y. f (ia div y) (ia mod y))", "apply (intro sum.reindex_cong[of \"\\<lambda>ia. (ia div y, ia mod y)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>ia. (ia div y, ia mod y)) {0..<x * y}\n 2. {0..<x} \\<times> {0..<y} =\n    (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n 3. \\<And>xa.\n       xa \\<in> {0..<x * y} \\<Longrightarrow>\n       (case (xa div y, xa mod y) of (x, xa) \\<Rightarrow> f x xa) =\n       f (xa div y) (xa mod y)", "using 1 2"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>ia. (ia div y, ia mod y)) {0..<x * y}\n  {0..<x} \\<times> {0..<y} =\n  (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>ia. (ia div y, ia mod y)) {0..<x * y}\n 2. {0..<x} \\<times> {0..<y} =\n    (\\<lambda>ia. (ia div y, ia mod y)) ` {0..<x * y}\n 3. \\<And>xa.\n       xa \\<in> {0..<x * y} \\<Longrightarrow>\n       (case (xa div y, xa mod y) of (x, xa) \\<Rightarrow> f x xa) =\n       f (xa div y) (xa mod y)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<x. sum (f ia) {0..<y}) =\n  (\\<Sum>ia = 0..<x * y. f (ia div y) (ia mod y))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Kronecker product distributes over matrix multiplication *)"], ["", "lemma kronecker_of_mult:\n  assumes \"dim_col (A :: 'a :: comm_ring mat) = dim_row C\"\n  assumes \"dim_col B = dim_row D\"\n  shows \"kronecker_product A B * kronecker_product C D = kronecker_product (A * C) (B * D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kronecker_product A B * kronecker_product C D =\n    kronecker_product (A * C) (B * D)", "unfolding kronecker_product_def Let_def mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n       (\\<lambda>(i, j).\n           A $$ (i div dim_row B, j div dim_col B) *\n           B $$ (i mod dim_row B, j mod dim_col B)) *\n      mat (dim_row C * dim_row D) (dim_col C * dim_col D)\n       (\\<lambda>(i, j).\n           C $$ (i div dim_row D, j div dim_col D) *\n           D $$ (i mod dim_row D, j mod dim_col D))) =\n    dim_row\n     (mat (dim_row (A * C) * dim_row (B * D))\n       (dim_col (A * C) * dim_col (B * D))\n       (\\<lambda>(i, j).\n           (A * C) $$ (i div dim_row (B * D), j div dim_col (B * D)) *\n           (B * D) $$\n           (i mod dim_row (B * D), j mod dim_col (B * D)))) \\<and>\n    dim_col\n     (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n       (\\<lambda>(i, j).\n           A $$ (i div dim_row B, j div dim_col B) *\n           B $$ (i mod dim_row B, j mod dim_col B)) *\n      mat (dim_row C * dim_row D) (dim_col C * dim_col D)\n       (\\<lambda>(i, j).\n           C $$ (i div dim_row D, j div dim_col D) *\n           D $$ (i mod dim_row D, j mod dim_col D))) =\n    dim_col\n     (mat (dim_row (A * C) * dim_row (B * D))\n       (dim_col (A * C) * dim_col (B * D))\n       (\\<lambda>(i, j).\n           (A * C) $$ (i div dim_row (B * D), j div dim_col (B * D)) *\n           (B * D) $$\n           (i mod dim_row (B * D), j mod dim_col (B * D)))) \\<and>\n    (\\<forall>i j.\n        i < dim_row\n             (mat (dim_row (A * C) * dim_row (B * D))\n               (dim_col (A * C) * dim_col (B * D))\n               (\\<lambda>(i, j).\n                   (A * C) $$\n                   (i div dim_row (B * D), j div dim_col (B * D)) *\n                   (B * D) $$\n                   (i mod dim_row (B * D),\n                    j mod dim_col (B * D)))) \\<longrightarrow>\n        j < dim_col\n             (mat (dim_row (A * C) * dim_row (B * D))\n               (dim_col (A * C) * dim_col (B * D))\n               (\\<lambda>(i, j).\n                   (A * C) $$\n                   (i div dim_row (B * D), j div dim_col (B * D)) *\n                   (B * D) $$\n                   (i mod dim_row (B * D),\n                    j mod dim_col (B * D)))) \\<longrightarrow>\n        (mat (dim_row A * dim_row B) (dim_col A * dim_col B)\n          (\\<lambda>(i, j).\n              A $$ (i div dim_row B, j div dim_col B) *\n              B $$ (i mod dim_row B, j mod dim_col B)) *\n         mat (dim_row C * dim_row D) (dim_col C * dim_col D)\n          (\\<lambda>(i, j).\n              C $$ (i div dim_row D, j div dim_col D) *\n              D $$ (i mod dim_row D, j mod dim_col D))) $$\n        (i, j) =\n        mat (dim_row (A * C) * dim_row (B * D))\n         (dim_col (A * C) * dim_col (B * D))\n         (\\<lambda>(i, j).\n             (A * C) $$ (i div dim_row (B * D), j div dim_col (B * D)) *\n             (B * D) $$ (i mod dim_row (B * D), j mod dim_col (B * D))) $$\n        (i, j))", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A * dim_row B;\n        j < dim_col C * dim_col D\\<rbrakk>\n       \\<Longrightarrow> vec (dim_col A * dim_col B)\n                          (\\<lambda>j.\n                              A $$ (i div dim_row B, j div dim_col B) *\n                              B $$\n                              (i mod dim_row B, j mod dim_col B)) \\<bullet>\n                         vec (dim_row C * dim_row D)\n                          (\\<lambda>i.\n                              C $$ (i div dim_row D, j div dim_col D) *\n                              D $$ (i mod dim_row D, j mod dim_col D)) =\n                         (A * C) $$ (i div dim_row B, j div dim_col D) *\n                         (B * D) $$ (i mod dim_row B, j mod dim_col D)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A * dim_row B;\n        j < dim_col C * dim_col D\\<rbrakk>\n       \\<Longrightarrow> vec (dim_col A * dim_col B)\n                          (\\<lambda>j.\n                              A $$ (i div dim_row B, j div dim_col B) *\n                              B $$\n                              (i mod dim_row B, j mod dim_col B)) \\<bullet>\n                         vec (dim_row C * dim_row D)\n                          (\\<lambda>i.\n                              C $$ (i div dim_row D, j div dim_col D) *\n                              D $$ (i mod dim_row D, j mod dim_col D)) =\n                         (A * C) $$ (i div dim_row B, j div dim_col D) *\n                         (B * D) $$ (i mod dim_row B, j mod dim_col D)", "assume ij: \"i < dim_row A * dim_row B\" \"j < dim_col C * dim_col D\""], ["proof (state)\nthis:\n  i < dim_row A * dim_row B\n  j < dim_col C * dim_col D\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A * dim_row B;\n        j < dim_col C * dim_col D\\<rbrakk>\n       \\<Longrightarrow> vec (dim_col A * dim_col B)\n                          (\\<lambda>j.\n                              A $$ (i div dim_row B, j div dim_col B) *\n                              B $$\n                              (i mod dim_row B, j mod dim_col B)) \\<bullet>\n                         vec (dim_row C * dim_row D)\n                          (\\<lambda>i.\n                              C $$ (i div dim_row D, j div dim_col D) *\n                              D $$ (i mod dim_row D, j mod dim_col D)) =\n                         (A * C) $$ (i div dim_row B, j div dim_col D) *\n                         (B * D) $$ (i mod dim_row B, j mod dim_col D)", "have 1: \"(A * C) $$ (i div dim_row B, j div dim_col D) =\n    row A (i div dim_row B) \\<bullet> col C (j div dim_col D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * C) $$ (i div dim_row B, j div dim_col D) =\n    row A (i div dim_row B) \\<bullet> col C (j div dim_col D)", "using ij less_mult_imp_div_less"], ["proof (prove)\nusing this:\n  i < dim_row A * dim_row B\n  j < dim_col C * dim_col D\n  ?m < ?i * ?n \\<Longrightarrow> ?m div ?n < ?i\n\ngoal (1 subgoal):\n 1. (A * C) $$ (i div dim_row B, j div dim_col D) =\n    row A (i div dim_row B) \\<bullet> col C (j div dim_col D)", "by (auto intro!: index_mult_mat)"], ["proof (state)\nthis:\n  (A * C) $$ (i div dim_row B, j div dim_col D) =\n  row A (i div dim_row B) \\<bullet> col C (j div dim_col D)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A * dim_row B;\n        j < dim_col C * dim_col D\\<rbrakk>\n       \\<Longrightarrow> vec (dim_col A * dim_col B)\n                          (\\<lambda>j.\n                              A $$ (i div dim_row B, j div dim_col B) *\n                              B $$\n                              (i mod dim_row B, j mod dim_col B)) \\<bullet>\n                         vec (dim_row C * dim_row D)\n                          (\\<lambda>i.\n                              C $$ (i div dim_row D, j div dim_col D) *\n                              D $$ (i mod dim_row D, j mod dim_col D)) =\n                         (A * C) $$ (i div dim_row B, j div dim_col D) *\n                         (B * D) $$ (i mod dim_row B, j mod dim_col D)", "have 2: \"(B * D) $$ (i mod dim_row B, j mod dim_col D) =\n    row B (i mod dim_row B) \\<bullet> col D (j mod dim_col D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B * D) $$ (i mod dim_row B, j mod dim_col D) =\n    row B (i mod dim_row B) \\<bullet> col D (j mod dim_col D)", "using ij"], ["proof (prove)\nusing this:\n  i < dim_row A * dim_row B\n  j < dim_col C * dim_col D\n\ngoal (1 subgoal):\n 1. (B * D) $$ (i mod dim_row B, j mod dim_col D) =\n    row B (i mod dim_row B) \\<bullet> col D (j mod dim_col D)", "apply (auto intro!: index_mult_mat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < dim_row A * dim_row B; j < dim_col C * dim_col D\\<rbrakk>\n    \\<Longrightarrow> i mod dim_row B < dim_row B\n 2. \\<lbrakk>i < dim_row A * dim_row B; j < dim_col C * dim_col D\\<rbrakk>\n    \\<Longrightarrow> j mod dim_col D < dim_col D", "using gr_implies_not0"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < dim_row A * dim_row B; j < dim_col C * dim_col D\\<rbrakk>\n    \\<Longrightarrow> i mod dim_row B < dim_row B\n 2. \\<lbrakk>i < dim_row A * dim_row B; j < dim_col C * dim_col D\\<rbrakk>\n    \\<Longrightarrow> j mod dim_col D < dim_col D", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A * dim_row B; j < dim_col C * dim_col D\\<rbrakk>\n    \\<Longrightarrow> j mod dim_col D < dim_col D", "using gr_implies_not0"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A * dim_row B; j < dim_col C * dim_col D\\<rbrakk>\n    \\<Longrightarrow> j mod dim_col D < dim_col D", "by fastforce"], ["proof (state)\nthis:\n  (B * D) $$ (i mod dim_row B, j mod dim_col D) =\n  row B (i mod dim_row B) \\<bullet> col D (j mod dim_col D)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A * dim_row B;\n        j < dim_col C * dim_col D\\<rbrakk>\n       \\<Longrightarrow> vec (dim_col A * dim_col B)\n                          (\\<lambda>j.\n                              A $$ (i div dim_row B, j div dim_col B) *\n                              B $$\n                              (i mod dim_row B, j mod dim_col B)) \\<bullet>\n                         vec (dim_row C * dim_row D)\n                          (\\<lambda>i.\n                              C $$ (i div dim_row D, j div dim_col D) *\n                              D $$ (i mod dim_row D, j mod dim_col D)) =\n                         (A * C) $$ (i div dim_row B, j div dim_col D) *\n                         (B * D) $$ (i mod dim_row B, j mod dim_col D)", "have 3: \"\\<And>x. x < dim_row C * dim_row D \\<Longrightarrow>\n         A $$ (i div dim_row B, x div dim_row D) *\n         B $$ (i mod dim_row B, x mod dim_row D) *\n         (C $$ (x div dim_row D, j div dim_col D) *\n          D $$ (x mod dim_row D, j mod dim_col D)) =\n         row A (i div dim_row B) $ (x div dim_row D) *\n         col C (j div dim_col D) $ (x div dim_row D) *\n         (row B (i mod dim_row B) $ (x mod dim_row D) *\n          col D (j mod dim_col D) $ (x mod dim_row D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < dim_row C * dim_row D \\<Longrightarrow>\n       A $$ (i div dim_row B, x div dim_row D) *\n       B $$ (i mod dim_row B, x mod dim_row D) *\n       (C $$ (x div dim_row D, j div dim_col D) *\n        D $$ (x mod dim_row D, j mod dim_col D)) =\n       row A (i div dim_row B) $ (x div dim_row D) *\n       col C (j div dim_col D) $ (x div dim_row D) *\n       (row B (i mod dim_row B) $ (x mod dim_row D) *\n        col D (j mod dim_col D) $ (x mod dim_row D))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < dim_row C * dim_row D \\<Longrightarrow>\n       A $$ (i div dim_row B, x div dim_row D) *\n       B $$ (i mod dim_row B, x mod dim_row D) *\n       (C $$ (x div dim_row D, j div dim_col D) *\n        D $$ (x mod dim_row D, j mod dim_col D)) =\n       row A (i div dim_row B) $ (x div dim_row D) *\n       col C (j div dim_col D) $ (x div dim_row D) *\n       (row B (i mod dim_row B) $ (x mod dim_row D) *\n        col D (j mod dim_col D) $ (x mod dim_row D))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < dim_row C * dim_row D \\<Longrightarrow>\n       A $$ (i div dim_row B, x div dim_row D) *\n       B $$ (i mod dim_row B, x mod dim_row D) *\n       (C $$ (x div dim_row D, j div dim_col D) *\n        D $$ (x mod dim_row D, j mod dim_col D)) =\n       row A (i div dim_row B) $ (x div dim_row D) *\n       col C (j div dim_col D) $ (x div dim_row D) *\n       (row B (i mod dim_row B) $ (x mod dim_row D) *\n        col D (j mod dim_col D) $ (x mod dim_row D))", "assume *:\"x < dim_row C * dim_row D\""], ["proof (state)\nthis:\n  x < dim_row C * dim_row D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < dim_row C * dim_row D \\<Longrightarrow>\n       A $$ (i div dim_row B, x div dim_row D) *\n       B $$ (i mod dim_row B, x mod dim_row D) *\n       (C $$ (x div dim_row D, j div dim_col D) *\n        D $$ (x mod dim_row D, j mod dim_col D)) =\n       row A (i div dim_row B) $ (x div dim_row D) *\n       col C (j div dim_col D) $ (x div dim_row D) *\n       (row B (i mod dim_row B) $ (x mod dim_row D) *\n        col D (j mod dim_col D) $ (x mod dim_row D))", "have 1: \"row A (i div dim_row B) $ (x div dim_row D) = A $$ (i div dim_row B, x div dim_row D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A (i div dim_row B) $ (x div dim_row D) =\n    A $$ (i div dim_row B, x div dim_row D)", "by (simp add: * assms(1) less_mult_imp_div_less row_def)"], ["proof (state)\nthis:\n  row A (i div dim_row B) $ (x div dim_row D) =\n  A $$ (i div dim_row B, x div dim_row D)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < dim_row C * dim_row D \\<Longrightarrow>\n       A $$ (i div dim_row B, x div dim_row D) *\n       B $$ (i mod dim_row B, x mod dim_row D) *\n       (C $$ (x div dim_row D, j div dim_col D) *\n        D $$ (x mod dim_row D, j mod dim_col D)) =\n       row A (i div dim_row B) $ (x div dim_row D) *\n       col C (j div dim_col D) $ (x div dim_row D) *\n       (row B (i mod dim_row B) $ (x mod dim_row D) *\n        col D (j mod dim_col D) $ (x mod dim_row D))", "have 2: \"row B (i mod dim_row B) $ (x mod dim_row D) = B $$ (i mod dim_row B, x mod dim_row D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row B (i mod dim_row B) $ (x mod dim_row D) =\n    B $$ (i mod dim_row B, x mod dim_row D)", "by (metis \"*\" assms(2) ij(1) index_row(1) mod_less_divisor nat_0_less_mult_iff neq0_conv not_less_zero)"], ["proof (state)\nthis:\n  row B (i mod dim_row B) $ (x mod dim_row D) =\n  B $$ (i mod dim_row B, x mod dim_row D)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < dim_row C * dim_row D \\<Longrightarrow>\n       A $$ (i div dim_row B, x div dim_row D) *\n       B $$ (i mod dim_row B, x mod dim_row D) *\n       (C $$ (x div dim_row D, j div dim_col D) *\n        D $$ (x mod dim_row D, j mod dim_col D)) =\n       row A (i div dim_row B) $ (x div dim_row D) *\n       col C (j div dim_col D) $ (x div dim_row D) *\n       (row B (i mod dim_row B) $ (x mod dim_row D) *\n        col D (j mod dim_col D) $ (x mod dim_row D))", "have 3: \"col C (j div dim_col D) $ (x div dim_row D) = C $$ (x div dim_row D, j div dim_col D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col C (j div dim_col D) $ (x div dim_row D) =\n    C $$ (x div dim_row D, j div dim_col D)", "by (simp add: \"*\" ij(2) less_mult_imp_div_less)"], ["proof (state)\nthis:\n  col C (j div dim_col D) $ (x div dim_row D) =\n  C $$ (x div dim_row D, j div dim_col D)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < dim_row C * dim_row D \\<Longrightarrow>\n       A $$ (i div dim_row B, x div dim_row D) *\n       B $$ (i mod dim_row B, x mod dim_row D) *\n       (C $$ (x div dim_row D, j div dim_col D) *\n        D $$ (x mod dim_row D, j mod dim_col D)) =\n       row A (i div dim_row B) $ (x div dim_row D) *\n       col C (j div dim_col D) $ (x div dim_row D) *\n       (row B (i mod dim_row B) $ (x mod dim_row D) *\n        col D (j mod dim_col D) $ (x mod dim_row D))", "have 4: \"col D (j mod dim_col D) $ (x mod dim_row D) = D $$ (x mod dim_row D, j mod dim_col D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col D (j mod dim_col D) $ (x mod dim_row D) =\n    D $$ (x mod dim_row D, j mod dim_col D)", "by (metis \"*\" Euclidean_Division.div_eq_0_iff gr_implies_not0 ij(2) index_col mod_div_trivial mult_not_zero)"], ["proof (state)\nthis:\n  col D (j mod dim_col D) $ (x mod dim_row D) =\n  D $$ (x mod dim_row D, j mod dim_col D)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < dim_row C * dim_row D \\<Longrightarrow>\n       A $$ (i div dim_row B, x div dim_row D) *\n       B $$ (i mod dim_row B, x mod dim_row D) *\n       (C $$ (x div dim_row D, j div dim_col D) *\n        D $$ (x mod dim_row D, j mod dim_col D)) =\n       row A (i div dim_row B) $ (x div dim_row D) *\n       col C (j div dim_col D) $ (x div dim_row D) *\n       (row B (i mod dim_row B) $ (x mod dim_row D) *\n        col D (j mod dim_col D) $ (x mod dim_row D))", "show \"A $$ (i div dim_row B, x div dim_row D) *\n         B $$ (i mod dim_row B, x mod dim_row D) *\n         (C $$ (x div dim_row D, j div dim_col D) *\n          D $$ (x mod dim_row D, j mod dim_col D)) =\n         row A (i div dim_row B) $ (x div dim_row D) *\n         col C (j div dim_col D) $ (x div dim_row D) *\n         (row B (i mod dim_row B) $ (x mod dim_row D) *\n          col D (j mod dim_col D) $ (x mod dim_row D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i div dim_row B, x div dim_row D) *\n    B $$ (i mod dim_row B, x mod dim_row D) *\n    (C $$ (x div dim_row D, j div dim_col D) *\n     D $$ (x mod dim_row D, j mod dim_col D)) =\n    row A (i div dim_row B) $ (x div dim_row D) *\n    col C (j div dim_col D) $ (x div dim_row D) *\n    (row B (i mod dim_row B) $ (x mod dim_row D) *\n     col D (j mod dim_col D) $ (x mod dim_row D))", "unfolding 1 2 3 4"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i div dim_row B, x div dim_row D) *\n    B $$ (i mod dim_row B, x mod dim_row D) *\n    (C $$ (x div dim_row D, j div dim_col D) *\n     D $$ (x mod dim_row D, j mod dim_col D)) =\n    A $$ (i div dim_row B, x div dim_row D) *\n    C $$ (x div dim_row D, j div dim_col D) *\n    (B $$ (i mod dim_row B, x mod dim_row D) *\n     D $$ (x mod dim_row D, j mod dim_col D))", "by (simp add: mult.assoc mult.left_commute)"], ["proof (state)\nthis:\n  A $$ (i div dim_row B, x div dim_row D) *\n  B $$ (i mod dim_row B, x mod dim_row D) *\n  (C $$ (x div dim_row D, j div dim_col D) *\n   D $$ (x mod dim_row D, j mod dim_col D)) =\n  row A (i div dim_row B) $ (x div dim_row D) *\n  col C (j div dim_col D) $ (x div dim_row D) *\n  (row B (i mod dim_row B) $ (x mod dim_row D) *\n   col D (j mod dim_col D) $ (x mod dim_row D))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x < dim_row C * dim_row D \\<Longrightarrow>\n  A $$ (i div dim_row B, ?x div dim_row D) *\n  B $$ (i mod dim_row B, ?x mod dim_row D) *\n  (C $$ (?x div dim_row D, j div dim_col D) *\n   D $$ (?x mod dim_row D, j mod dim_col D)) =\n  row A (i div dim_row B) $ (?x div dim_row D) *\n  col C (j div dim_col D) $ (?x div dim_row D) *\n  (row B (i mod dim_row B) $ (?x mod dim_row D) *\n   col D (j mod dim_col D) $ (?x mod dim_row D))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A * dim_row B;\n        j < dim_col C * dim_col D\\<rbrakk>\n       \\<Longrightarrow> vec (dim_col A * dim_col B)\n                          (\\<lambda>j.\n                              A $$ (i div dim_row B, j div dim_col B) *\n                              B $$\n                              (i mod dim_row B, j mod dim_col B)) \\<bullet>\n                         vec (dim_row C * dim_row D)\n                          (\\<lambda>i.\n                              C $$ (i div dim_row D, j div dim_col D) *\n                              D $$ (i mod dim_row D, j mod dim_col D)) =\n                         (A * C) $$ (i div dim_row B, j div dim_col D) *\n                         (B * D) $$ (i mod dim_row B, j mod dim_col D)", "have *: \"(A * C) $$ (i div dim_row B, j div dim_col D) *\n        (B * D) $$ (i mod dim_row B, j mod dim_col D) =\n    (\\<Sum>ia = 0..<dim_row C * dim_row D.\n               A $$ (i div dim_row B, ia div dim_row D) *\n               B $$ (i mod dim_row B, ia mod dim_row D) *\n               (C $$ (ia div dim_row D, j div dim_col D) *\n                D $$ (ia mod dim_row D, j mod dim_col D)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * C) $$ (i div dim_row B, j div dim_col D) *\n    (B * D) $$ (i mod dim_row B, j mod dim_col D) =\n    (\\<Sum>ia = 0..<dim_row C * dim_row D.\n        A $$ (i div dim_row B, ia div dim_row D) *\n        B $$ (i mod dim_row B, ia mod dim_row D) *\n        (C $$ (ia div dim_row D, j div dim_col D) *\n         D $$ (ia mod dim_row D, j mod dim_col D)))", "unfolding 1 2 scalar_prod_def sum_product sum_sum_mod_div"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec (col C (j div dim_col D)) *\n                    dim_vec (col D (j mod dim_col D)).\n        row A (i div dim_row B) $\n        (ia div dim_vec (col D (j mod dim_col D))) *\n        col C (j div dim_col D) $\n        (ia div dim_vec (col D (j mod dim_col D))) *\n        (row B (i mod dim_row B) $\n         (ia mod dim_vec (col D (j mod dim_col D))) *\n         col D (j mod dim_col D) $\n         (ia mod dim_vec (col D (j mod dim_col D))))) =\n    (\\<Sum>ia = 0..<dim_row C * dim_row D.\n        A $$ (i div dim_row B, ia div dim_row D) *\n        B $$ (i mod dim_row B, ia mod dim_row D) *\n        (C $$ (ia div dim_row D, j div dim_col D) *\n         D $$ (ia mod dim_row D, j mod dim_col D)))", "apply (auto simp add: sum_product sum_sum_mod_div intro!: sum.cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < dim_row C * dim_row D \\<Longrightarrow>\n       row A (i div dim_row B) $ (x div dim_row D) *\n       col C (j div dim_col D) $ (x div dim_row D) *\n       (row B (i mod dim_row B) $ (x mod dim_row D) *\n        col D (j mod dim_col D) $ (x mod dim_row D)) =\n       A $$ (i div dim_row B, x div dim_row D) *\n       B $$ (i mod dim_row B, x mod dim_row D) *\n       (C $$ (x div dim_row D, j div dim_col D) *\n        D $$ (x mod dim_row D, j mod dim_col D))", "using 3"], ["proof (prove)\nusing this:\n  ?x < dim_row C * dim_row D \\<Longrightarrow>\n  A $$ (i div dim_row B, ?x div dim_row D) *\n  B $$ (i mod dim_row B, ?x mod dim_row D) *\n  (C $$ (?x div dim_row D, j div dim_col D) *\n   D $$ (?x mod dim_row D, j mod dim_col D)) =\n  row A (i div dim_row B) $ (?x div dim_row D) *\n  col C (j div dim_col D) $ (?x div dim_row D) *\n  (row B (i mod dim_row B) $ (?x mod dim_row D) *\n   col D (j mod dim_col D) $ (?x mod dim_row D))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < dim_row C * dim_row D \\<Longrightarrow>\n       row A (i div dim_row B) $ (x div dim_row D) *\n       col C (j div dim_col D) $ (x div dim_row D) *\n       (row B (i mod dim_row B) $ (x mod dim_row D) *\n        col D (j mod dim_col D) $ (x mod dim_row D)) =\n       A $$ (i div dim_row B, x div dim_row D) *\n       B $$ (i mod dim_row B, x mod dim_row D) *\n       (C $$ (x div dim_row D, j div dim_col D) *\n        D $$ (x mod dim_row D, j mod dim_col D))", "by presburger"], ["proof (state)\nthis:\n  (A * C) $$ (i div dim_row B, j div dim_col D) *\n  (B * D) $$ (i mod dim_row B, j mod dim_col D) =\n  (\\<Sum>ia = 0..<dim_row C * dim_row D.\n      A $$ (i div dim_row B, ia div dim_row D) *\n      B $$ (i mod dim_row B, ia mod dim_row D) *\n      (C $$ (ia div dim_row D, j div dim_col D) *\n       D $$ (ia mod dim_row D, j mod dim_col D)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A * dim_row B;\n        j < dim_col C * dim_col D\\<rbrakk>\n       \\<Longrightarrow> vec (dim_col A * dim_col B)\n                          (\\<lambda>j.\n                              A $$ (i div dim_row B, j div dim_col B) *\n                              B $$\n                              (i mod dim_row B, j mod dim_col B)) \\<bullet>\n                         vec (dim_row C * dim_row D)\n                          (\\<lambda>i.\n                              C $$ (i div dim_row D, j div dim_col D) *\n                              D $$ (i mod dim_row D, j mod dim_col D)) =\n                         (A * C) $$ (i div dim_row B, j div dim_col D) *\n                         (B * D) $$ (i mod dim_row B, j mod dim_col D)", "show \"vec (dim_col A * dim_col B)\n          (\\<lambda>j. A $$ (i div dim_row B, j div dim_col B) *\n               B $$ (i mod dim_row B, j mod dim_col B)) \\<bullet>\n       vec (dim_row C * dim_row D)\n          (\\<lambda>i. C $$ (i div dim_row D, j div dim_col D) *\n               D $$ (i mod dim_row D, j mod dim_col D)) =\n        (A * C) $$ (i div dim_row B, j div dim_col D) *\n        (B * D) $$ (i mod dim_row B, j mod dim_col D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (dim_col A * dim_col B)\n     (\\<lambda>j.\n         A $$ (i div dim_row B, j div dim_col B) *\n         B $$ (i mod dim_row B, j mod dim_col B)) \\<bullet>\n    vec (dim_row C * dim_row D)\n     (\\<lambda>i.\n         C $$ (i div dim_row D, j div dim_col D) *\n         D $$ (i mod dim_row D, j mod dim_col D)) =\n    (A * C) $$ (i div dim_row B, j div dim_col D) *\n    (B * D) $$ (i mod dim_row B, j mod dim_col D)", "unfolding * scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec\n                     (vec (dim_row C * dim_row D)\n                       (\\<lambda>i.\n                           C $$ (i div dim_row D, j div dim_col D) *\n                           D $$ (i mod dim_row D, j mod dim_col D))).\n        vec (dim_col A * dim_col B)\n         (\\<lambda>j.\n             A $$ (i div dim_row B, j div dim_col B) *\n             B $$ (i mod dim_row B, j mod dim_col B)) $\n        ia *\n        vec (dim_row C * dim_row D)\n         (\\<lambda>i.\n             C $$ (i div dim_row D, j div dim_col D) *\n             D $$ (i mod dim_row D, j mod dim_col D)) $\n        ia) =\n    (\\<Sum>ia = 0..<dim_row C * dim_row D.\n        A $$ (i div dim_row B, ia div dim_row D) *\n        B $$ (i mod dim_row B, ia mod dim_row D) *\n        (C $$ (ia div dim_row D, j div dim_col D) *\n         D $$ (ia mod dim_row D, j mod dim_col D)))", "by (auto simp add: assms sum_product sum_sum_mod_div intro!: sum.cong)"], ["proof (state)\nthis:\n  vec (dim_col A * dim_col B)\n   (\\<lambda>j.\n       A $$ (i div dim_row B, j div dim_col B) *\n       B $$ (i mod dim_row B, j mod dim_col B)) \\<bullet>\n  vec (dim_row C * dim_row D)\n   (\\<lambda>i.\n       C $$ (i div dim_row D, j div dim_col D) *\n       D $$ (i mod dim_row D, j mod dim_col D)) =\n  (A * C) $$ (i div dim_row B, j div dim_col D) *\n  (B * D) $$ (i mod dim_row B, j mod dim_col D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverts_mat_length:\n  assumes \"square_mat A\" \"inverts_mat A B\" \"inverts_mat B A\"\n  shows \"dim_row B = dim_row A\" \"dim_col B = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row B = dim_row A &&& dim_col B = dim_col A", "apply (metis assms(1) assms(3) index_mult_mat(3) index_one_mat(3) inverts_mat_def square_mat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col B = dim_col A", "by (metis assms(1) assms(2) index_mult_mat(3) index_one_mat(3) inverts_mat_def square_mat.simps)"], ["", "lemma less_mult_imp_mod_less:\n  \"m mod i < i\" if \"m < n * i\" for m n i :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. m mod i < i", "using gr_implies_not_zero that"], ["proof (prove)\nusing this:\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> (0::?'a)\n  m < n * i\n\ngoal (1 subgoal):\n 1. m mod i < i", "by fastforce"], ["", "lemma kronecker_one:\n  shows \"kronecker_product ((1\\<^sub>m x)::'a :: ring_1 mat) (1\\<^sub>m y) = 1\\<^sub>m (x*y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kronecker_product (1\\<^sub>m x) (1\\<^sub>m y) = 1\\<^sub>m (x * y)", "unfolding kronecker_product_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row (1\\<^sub>m x) * dim_row (1\\<^sub>m y))\n     (dim_col (1\\<^sub>m x) * dim_col (1\\<^sub>m y))\n     (\\<lambda>(i, j).\n         1\\<^sub>m x $$\n         (i div dim_row (1\\<^sub>m y), j div dim_col (1\\<^sub>m y)) *\n         1\\<^sub>m y $$\n         (i mod dim_row (1\\<^sub>m y), j mod dim_col (1\\<^sub>m y))) =\n    1\\<^sub>m (x * y)", "apply  (auto simp add:mat_eq_iff less_mult_imp_div_less less_mult_imp_mod_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < x * y; i div y = j div y; i mod y = j mod y;\n        i \\<noteq> j; j < x * y\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis div_mult_mod_eq)"], ["", "lemma kronecker_invertible:\n  assumes \"invertible_mat (A :: 'a :: comm_ring_1 mat)\" \"invertible_mat B\"\n  shows \"invertible_mat (kronecker_product A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat (kronecker_product A B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invertible_mat (kronecker_product A B)", "obtain Ai where Ai: \"inverts_mat A Ai\" \"inverts_mat Ai A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ai.\n        \\<lbrakk>inverts_mat A Ai; inverts_mat Ai A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms invertible_mat_def"], ["proof (prove)\nusing this:\n  invertible_mat A\n  invertible_mat B\n  invertible_mat ?A \\<equiv>\n  square_mat ?A \\<and>\n  (\\<exists>B. inverts_mat ?A B \\<and> inverts_mat B ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>Ai.\n        \\<lbrakk>inverts_mat A Ai; inverts_mat Ai A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inverts_mat A Ai\n  inverts_mat Ai A\n\ngoal (1 subgoal):\n 1. invertible_mat (kronecker_product A B)", "obtain Bi where Bi: \"inverts_mat B Bi\" \"inverts_mat Bi B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Bi.\n        \\<lbrakk>inverts_mat B Bi; inverts_mat Bi B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms invertible_mat_def"], ["proof (prove)\nusing this:\n  invertible_mat A\n  invertible_mat B\n  invertible_mat ?A \\<equiv>\n  square_mat ?A \\<and>\n  (\\<exists>B. inverts_mat ?A B \\<and> inverts_mat B ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>Bi.\n        \\<lbrakk>inverts_mat B Bi; inverts_mat Bi B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inverts_mat B Bi\n  inverts_mat Bi B\n\ngoal (1 subgoal):\n 1. invertible_mat (kronecker_product A B)", "have \"square_mat (kronecker_product A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_mat (kronecker_product A B)", "by (metis (no_types, lifting) assms(1) assms(2) dim_col_mat(1) dim_row_mat(1) invertible_mat_def kronecker_product_def square_mat.simps)"], ["proof (state)\nthis:\n  square_mat (kronecker_product A B)\n\ngoal (1 subgoal):\n 1. invertible_mat (kronecker_product A B)", "moreover"], ["proof (state)\nthis:\n  square_mat (kronecker_product A B)\n\ngoal (1 subgoal):\n 1. invertible_mat (kronecker_product A B)", "have \"inverts_mat (kronecker_product A B) (kronecker_product Ai Bi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat (kronecker_product A B) (kronecker_product Ai Bi)", "using Ai Bi"], ["proof (prove)\nusing this:\n  inverts_mat A Ai\n  inverts_mat Ai A\n  inverts_mat B Bi\n  inverts_mat Bi B\n\ngoal (1 subgoal):\n 1. inverts_mat (kronecker_product A B) (kronecker_product Ai Bi)", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  A * Ai = 1\\<^sub>m (dim_row A)\n  Ai * A = 1\\<^sub>m (dim_row Ai)\n  B * Bi = 1\\<^sub>m (dim_row B)\n  Bi * B = 1\\<^sub>m (dim_row Bi)\n\ngoal (1 subgoal):\n 1. kronecker_product A B * kronecker_product Ai Bi =\n    1\\<^sub>m (dim_row (kronecker_product A B))", "by (metis (no_types, lifting) dim_kronecker(1) index_mult_mat(3) index_one_mat(3) kronecker_of_mult kronecker_one)"], ["proof (state)\nthis:\n  inverts_mat (kronecker_product A B) (kronecker_product Ai Bi)\n\ngoal (1 subgoal):\n 1. invertible_mat (kronecker_product A B)", "moreover"], ["proof (state)\nthis:\n  inverts_mat (kronecker_product A B) (kronecker_product Ai Bi)\n\ngoal (1 subgoal):\n 1. invertible_mat (kronecker_product A B)", "have \"inverts_mat (kronecker_product Ai Bi) (kronecker_product A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverts_mat (kronecker_product Ai Bi) (kronecker_product A B)", "using Ai Bi"], ["proof (prove)\nusing this:\n  inverts_mat A Ai\n  inverts_mat Ai A\n  inverts_mat B Bi\n  inverts_mat Bi B\n\ngoal (1 subgoal):\n 1. inverts_mat (kronecker_product Ai Bi) (kronecker_product A B)", "unfolding inverts_mat_def"], ["proof (prove)\nusing this:\n  A * Ai = 1\\<^sub>m (dim_row A)\n  Ai * A = 1\\<^sub>m (dim_row Ai)\n  B * Bi = 1\\<^sub>m (dim_row B)\n  Bi * B = 1\\<^sub>m (dim_row Bi)\n\ngoal (1 subgoal):\n 1. kronecker_product Ai Bi * kronecker_product A B =\n    1\\<^sub>m (dim_row (kronecker_product Ai Bi))", "by (metis (no_types, lifting) dim_kronecker(1) index_mult_mat(3) index_one_mat(3) kronecker_of_mult kronecker_one)"], ["proof (state)\nthis:\n  inverts_mat (kronecker_product Ai Bi) (kronecker_product A B)\n\ngoal (1 subgoal):\n 1. invertible_mat (kronecker_product A B)", "ultimately"], ["proof (chain)\npicking this:\n  square_mat (kronecker_product A B)\n  inverts_mat (kronecker_product A B) (kronecker_product Ai Bi)\n  inverts_mat (kronecker_product Ai Bi) (kronecker_product A B)", "show ?thesis"], ["proof (prove)\nusing this:\n  square_mat (kronecker_product A B)\n  inverts_mat (kronecker_product A B) (kronecker_product Ai Bi)\n  inverts_mat (kronecker_product Ai Bi) (kronecker_product A B)\n\ngoal (1 subgoal):\n 1. invertible_mat (kronecker_product A B)", "unfolding invertible_mat_def"], ["proof (prove)\nusing this:\n  square_mat (kronecker_product A B)\n  inverts_mat (kronecker_product A B) (kronecker_product Ai Bi)\n  inverts_mat (kronecker_product Ai Bi) (kronecker_product A B)\n\ngoal (1 subgoal):\n 1. square_mat (kronecker_product A B) \\<and>\n    (\\<exists>Ba.\n        inverts_mat (kronecker_product A B) Ba \\<and>\n        inverts_mat Ba (kronecker_product A B))", "by blast"], ["proof (state)\nthis:\n  invertible_mat (kronecker_product A B)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"More DL Rank\""], ["", "(* conjugate matrices *)"], ["", "instantiation mat :: (conjugate) conjugate\nbegin"], ["", "definition conjugate_mat :: \"'a :: conjugate mat \\<Rightarrow> 'a mat\"\n  where \"conjugate m = mat (dim_row m) (dim_col m) (\\<lambda>(i,j). conjugate (m $$ (i,j)))\""], ["", "lemma dim_row_conjugate[simp]: \"dim_row (conjugate m) = dim_row m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (conjugate m) = dim_row m", "unfolding conjugate_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (dim_row m) (dim_col m)\n       (\\<lambda>(i, j). conjugate (m $$ (i, j)))) =\n    dim_row m", "by auto"], ["", "lemma dim_col_conjugate[simp]: \"dim_col (conjugate m) = dim_col m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (conjugate m) = dim_col m", "unfolding conjugate_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (mat (dim_row m) (dim_col m)\n       (\\<lambda>(i, j). conjugate (m $$ (i, j)))) =\n    dim_col m", "by auto"], ["", "lemma carrier_vec_conjugate[simp]: \"m \\<in> carrier_mat nr nc \\<Longrightarrow> conjugate m \\<in> carrier_mat nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> carrier_mat nr nc \\<Longrightarrow>\n    conjugate m \\<in> carrier_mat nr nc", "by (auto)"], ["", "lemma mat_index_conjugate[simp]:\n  shows \"i < dim_row m \\<Longrightarrow> j < dim_col m \\<Longrightarrow> conjugate m  $$ (i,j) = conjugate (m $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row m; j < dim_col m\\<rbrakk>\n    \\<Longrightarrow> conjugate m $$ (i, j) = conjugate (m $$ (i, j))", "unfolding conjugate_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row m; j < dim_col m\\<rbrakk>\n    \\<Longrightarrow> mat (dim_row m) (dim_col m)\n                       (\\<lambda>(i, j). conjugate (m $$ (i, j))) $$\n                      (i, j) =\n                      conjugate (m $$ (i, j))", "by auto"], ["", "lemma row_conjugate[simp]: \"i < dim_row m \\<Longrightarrow> row (conjugate m) i = conjugate (row m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_row m \\<Longrightarrow>\n    row (conjugate m) i = conjugate (row m i)", "by (auto)"], ["", "lemma col_conjugate[simp]: \"i < dim_col m \\<Longrightarrow> col (conjugate m) i = conjugate (col m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_col m \\<Longrightarrow>\n    col (conjugate m) i = conjugate (col m i)", "by (auto)"], ["", "lemma rows_conjugate: \"rows (conjugate m) = map conjugate (rows m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rows (conjugate m) = map conjugate (rows m)", "by (simp add: list_eq_iff_nth_eq)"], ["", "lemma cols_conjugate: \"cols (conjugate m) = map conjugate (cols m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols (conjugate m) = map conjugate (cols m)", "by (simp add: list_eq_iff_nth_eq)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mat, conjugate_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. conjugate (conjugate a) = a\n 2. \\<And>a b. (conjugate a = conjugate b) = (a = b)", "fix a b :: \"'a mat\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. conjugate (conjugate a) = a\n 2. \\<And>a b. (conjugate a = conjugate b) = (a = b)", "show \"conjugate (conjugate a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (conjugate a) = a", "unfolding mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (conjugate (conjugate a)) = dim_row a \\<and>\n    dim_col (conjugate (conjugate a)) = dim_col a \\<and>\n    (\\<forall>i j.\n        i < dim_row a \\<longrightarrow>\n        j < dim_col a \\<longrightarrow>\n        conjugate (conjugate a) $$ (i, j) = a $$ (i, j))", "by auto"], ["proof (state)\nthis:\n  conjugate (conjugate a) = a\n\ngoal (1 subgoal):\n 1. \\<And>a b. (conjugate a = conjugate b) = (a = b)", "let ?a = \"conjugate a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (conjugate a = conjugate b) = (a = b)", "let ?b = \"conjugate b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (conjugate a = conjugate b) = (a = b)", "show \"conjugate a = conjugate b \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (conjugate a = conjugate b) = (a = b)", "by (metis dim_col_conjugate dim_row_conjugate mat_index_conjugate conjugate_cancel_iff mat_eq_iff)"], ["proof (state)\nthis:\n  (conjugate a = conjugate b) = (a = b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "abbreviation conjugate_transpose :: \"'a::conjugate mat  \\<Rightarrow> 'a mat\"\n  where \"conjugate_transpose A \\<equiv> conjugate (A\\<^sup>T)\""], ["", "notation conjugate_transpose (\"(_\\<^sup>H)\" [1000])"], ["", "lemma transpose_conjugate:\n  shows \"(conjugate A)\\<^sup>T = A\\<^sup>H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (conjugate A)\\<^sup>T = A\\<^sup>H", "unfolding conjugate_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (dim_row A) (dim_col A)\n      (\\<lambda>(i, j). conjugate (A $$ (i, j))))\\<^sup>T =\n    mat (dim_row A\\<^sup>T) (dim_col A\\<^sup>T)\n     (\\<lambda>(i, j). conjugate (A\\<^sup>T $$ (i, j)))", "by auto"], ["", "lemma vec_module_col_helper:\n  fixes A:: \"('a :: field) mat\"\n  shows \"(0\\<^sub>v (dim_row A) \\<in> LinearCombinations.module.span class_ring \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr> (set (cols A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_row A)\n    \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_row A)\n    \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))", "have \"\\<forall>v. (0::'a) \\<cdot>\\<^sub>v v + v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v. (0::'a) \\<cdot>\\<^sub>v v + v = v", "by auto"], ["proof (state)\nthis:\n  \\<forall>v. (0::'a) \\<cdot>\\<^sub>v v + v = v\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_row A)\n    \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))", "then"], ["proof (chain)\npicking this:\n  \\<forall>v. (0::'a) \\<cdot>\\<^sub>v v + v = v", "show \"0\\<^sub>v (dim_row A) \\<in> LinearCombinations.module.span class_ring \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr> (set (cols A))\""], ["proof (prove)\nusing this:\n  \\<forall>v. (0::'a) \\<cdot>\\<^sub>v v + v = v\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v (dim_row A)\n    \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))", "by (metis cols_dim module_vec_def right_zero_vec smult_carrier_vec vec_space.prod_in_span zero_carrier_vec)"], ["proof (state)\nthis:\n  0\\<^sub>v (dim_row A)\n  \\<in> LinearCombinations.module.span class_ring\n         \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n            one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n         (set (cols A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_module_col_helper2:\n  fixes A:: \"('a :: field) mat\"\n  shows \"\\<And>a x. x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined,\n                   zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n           (\\<And>a b v. (a + b) \\<cdot>\\<^sub>v v = a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v) \\<Longrightarrow>\n           a \\<cdot>\\<^sub>v x\n           \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined,\n                  zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v x\n                         \\<in> LinearCombinations.module.span class_ring\n                                \\<lparr>carrier = carrier_vec (dim_row A),\n                                   mult = undefined, one = undefined,\n                                   zero = 0\\<^sub>v (dim_row A), add = (+),\n                                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                                (set (cols A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v x\n                         \\<in> LinearCombinations.module.span class_ring\n                                \\<lparr>carrier = carrier_vec (dim_row A),\n                                   mult = undefined, one = undefined,\n                                   zero = 0\\<^sub>v (dim_row A), add = (+),\n                                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                                (set (cols A))", "fix a :: 'a and x :: \"'a vec\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v x\n                         \\<in> LinearCombinations.module.span class_ring\n                                \\<lparr>carrier = carrier_vec (dim_row A),\n                                   mult = undefined, one = undefined,\n                                   zero = 0\\<^sub>v (dim_row A), add = (+),\n                                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                                (set (cols A))", "assume \"x \\<in> LinearCombinations.module.span class_ring \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr> (set (cols A))\""], ["proof (state)\nthis:\n  x \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v x\n                         \\<in> LinearCombinations.module.span class_ring\n                                \\<lparr>carrier = carrier_vec (dim_row A),\n                                   mult = undefined, one = undefined,\n                                   zero = 0\\<^sub>v (dim_row A), add = (+),\n                                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                                (set (cols A))", "then"], ["proof (chain)\npicking this:\n  x \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))", "show \"a \\<cdot>\\<^sub>v x \\<in> LinearCombinations.module.span class_ring \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr> (set (cols A))\""], ["proof (prove)\nusing this:\n  x \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))\n\ngoal (1 subgoal):\n 1. a \\<cdot>\\<^sub>v x\n    \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))", "by (metis (full_types) cols_dim idom_vec.smult_in_span module_vec_def)"], ["proof (state)\nthis:\n  a \\<cdot>\\<^sub>v x\n  \\<in> LinearCombinations.module.span class_ring\n         \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n            one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n         (set (cols A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_module_col: \"module (class_ring :: 'a :: field ring)\n  (module_vec TYPE('a) \n    (dim_row A)\n      \\<lparr>carrier :=\n         LinearCombinations.module.span\n          class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module class_ring\n     (module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n                LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. module class_ring\n     (module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n                LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)", "interpret abelian_group \"module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n         LinearCombinations.module.span\n          class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_group\n     (module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n                LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)", "apply (unfold_locales)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier\n                         (add_monoid\n                           (module_vec TYPE('a) (dim_row A)\n                            \\<lparr>carrier :=\nLinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A))\n (set (cols A))\\<rparr>));\n        y \\<in> carrier\n                 (add_monoid\n                   (module_vec TYPE('a) (dim_row A)\n                    \\<lparr>carrier :=\n                              LinearCombinations.module.span class_ring\n                               (module_vec TYPE('a) (dim_row A))\n                               (set (cols A))\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub>\n                         y\n                         \\<in> carrier\n                                (add_monoid\n                                  (module_vec TYPE('a) (dim_row A)\n                                   \\<lparr>carrier :=\n       LinearCombinations.module.span class_ring\n        (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>))\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier\n                         (add_monoid\n                           (module_vec TYPE('a) (dim_row A)\n                            \\<lparr>carrier :=\nLinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A))\n (set (cols A))\\<rparr>));\n        y \\<in> carrier\n                 (add_monoid\n                   (module_vec TYPE('a) (dim_row A)\n                    \\<lparr>carrier :=\n                              LinearCombinations.module.span class_ring\n                               (module_vec TYPE('a) (dim_row A))\n                               (set (cols A))\\<rparr>));\n        z \\<in> carrier\n                 (add_monoid\n                   (module_vec TYPE('a) (dim_row A)\n                    \\<lparr>carrier :=\n                              LinearCombinations.module.span class_ring\n                               (module_vec TYPE('a) (dim_row A))\n                               (set (cols A))\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub>\n    \\<in> carrier\n           (add_monoid\n             (module_vec TYPE('a) (dim_row A)\n              \\<lparr>carrier :=\n                        LinearCombinations.module.span class_ring\n                         (module_vec TYPE('a) (dim_row A))\n                         (set (cols A))\\<rparr>))\n 4. \\<And>x.\n       x \\<in> carrier\n                (add_monoid\n                  (module_vec TYPE('a) (dim_row A)\n                   \\<lparr>carrier :=\n                             LinearCombinations.module.span class_ring\n                              (module_vec TYPE('a) (dim_row A))\n                              (set (cols A))\\<rparr>)) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub> \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier\n                (add_monoid\n                  (module_vec TYPE('a) (dim_row A)\n                   \\<lparr>carrier :=\n                             LinearCombinations.module.span class_ring\n                              (module_vec TYPE('a) (dim_row A))\n                              (set (cols A))\\<rparr>)) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub>\n       \\<one>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier\n                         (add_monoid\n                           (module_vec TYPE('a) (dim_row A)\n                            \\<lparr>carrier :=\nLinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A))\n (set (cols A))\\<rparr>));\n        y \\<in> carrier\n                 (add_monoid\n                   (module_vec TYPE('a) (dim_row A)\n                    \\<lparr>carrier :=\n                              LinearCombinations.module.span class_ring\n                               (module_vec TYPE('a) (dim_row A))\n                               (set (cols A))\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid (module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\\<^esub>\n                         x\n 7. carrier\n     (add_monoid\n       (module_vec TYPE('a) (dim_row A)\n        \\<lparr>carrier :=\n                  LinearCombinations.module.span class_ring\n                   (module_vec TYPE('a) (dim_row A))\n                   (set (cols A))\\<rparr>))\n    \\<subseteq> Units\n                 (add_monoid\n                   (module_vec TYPE('a) (dim_row A)\n                    \\<lparr>carrier :=\n                              LinearCombinations.module.span class_ring\n                               (module_vec TYPE('a) (dim_row A))\n                               (set (cols A))\\<rparr>))", "apply (auto simp add:module_vec_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + y\n                         \\<in> LinearCombinations.module.span class_ring\n                                \\<lparr>carrier = carrier_vec (dim_row A),\n                                   mult = undefined, one = undefined,\n                                   zero = 0\\<^sub>v (dim_row A), add = (+),\n                                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                                (set (cols A))\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A));\n        z \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + y + z = x + (y + z)\n 3. 0\\<^sub>v (dim_row A)\n    \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))\n 4. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       0\\<^sub>v (dim_row A) + x = x\n 5. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       x + 0\\<^sub>v (dim_row A) = x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x\n 7. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       x \\<in> Units\n                \\<lparr>carrier =\n                          LinearCombinations.module.span class_ring\n                           \\<lparr>carrier = carrier_vec (dim_row A),\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v (dim_row A), add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                           (set (cols A)),\n                   mult = (+), one = 0\\<^sub>v (dim_row A),\n                   \\<dots> = undefined\\<rparr>", "apply (metis cols_dim module_vec_def partial_object.select_convs(1) ring.simps(2) vec_vs vectorspace.span_add1)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A));\n        z \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + y + z = x + (y + z)\n 2. 0\\<^sub>v (dim_row A)\n    \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))\n 3. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       0\\<^sub>v (dim_row A) + x = x\n 4. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       x + 0\\<^sub>v (dim_row A) = x\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x\n 6. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       x \\<in> Units\n                \\<lparr>carrier =\n                          LinearCombinations.module.span class_ring\n                           \\<lparr>carrier = carrier_vec (dim_row A),\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v (dim_row A), add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                           (set (cols A)),\n                   mult = (+), one = 0\\<^sub>v (dim_row A),\n                   \\<dots> = undefined\\<rparr>", "apply (metis assoc_add_vec cols_dim module_vec_def vec_space.cV vec_vs vectorspace.span_closed)"], ["proof (prove)\ngoal (5 subgoals):\n 1. 0\\<^sub>v (dim_row A)\n    \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))\n 2. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       0\\<^sub>v (dim_row A) + x = x\n 3. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       x + 0\\<^sub>v (dim_row A) = x\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x\n 5. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       x \\<in> Units\n                \\<lparr>carrier =\n                          LinearCombinations.module.span class_ring\n                           \\<lparr>carrier = carrier_vec (dim_row A),\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v (dim_row A), add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                           (set (cols A)),\n                   mult = (+), one = 0\\<^sub>v (dim_row A),\n                   \\<dots> = undefined\\<rparr>", "using vec_module_col_helper[of A]"], ["proof (prove)\nusing this:\n  0\\<^sub>v (dim_row A)\n  \\<in> LinearCombinations.module.span class_ring\n         \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n            one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n         (set (cols A))\n\ngoal (5 subgoals):\n 1. 0\\<^sub>v (dim_row A)\n    \\<in> LinearCombinations.module.span class_ring\n           \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n              one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n           (set (cols A))\n 2. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       0\\<^sub>v (dim_row A) + x = x\n 3. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       x + 0\\<^sub>v (dim_row A) = x\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x\n 5. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)) \\<Longrightarrow>\n       x \\<in> Units\n                \\<lparr>carrier =\n                          LinearCombinations.module.span class_ring\n                           \\<lparr>carrier = carrier_vec (dim_row A),\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v (dim_row A), add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                           (set (cols A)),\n                   mult = (+), one = 0\\<^sub>v (dim_row A),\n                   \\<dots> = undefined\\<rparr>", "apply (auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>v (dim_row A) + x = x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + 0\\<^sub>v (dim_row A) = x\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x\n 4. \\<And>x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Units\n                                  \\<lparr>carrier =\n      LinearCombinations.module.span class_ring\n       \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n          one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n          smult = (\\<cdot>\\<^sub>v)\\<rparr>\n       (set (cols A)),\n                                     mult = (+),\n                                     one = 0\\<^sub>v (dim_row A),\n                                     \\<dots> = undefined\\<rparr>", "apply (metis cols_dim left_zero_vec module_vec_def partial_object.select_convs(1) vec_vs vectorspace.span_closed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + 0\\<^sub>v (dim_row A) = x\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Units\n                                  \\<lparr>carrier =\n      LinearCombinations.module.span class_ring\n       \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n          one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n          smult = (\\<cdot>\\<^sub>v)\\<rparr>\n       (set (cols A)),\n                                     mult = (+),\n                                     one = 0\\<^sub>v (dim_row A),\n                                     \\<dots> = undefined\\<rparr>", "apply (metis cols_dim module_vec_def partial_object.select_convs(1) right_zero_vec vec_vs vectorspace.span_closed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x + y = y + x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Units\n                                  \\<lparr>carrier =\n      LinearCombinations.module.span class_ring\n       \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n          one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n          smult = (\\<cdot>\\<^sub>v)\\<rparr>\n       (set (cols A)),\n                                     mult = (+),\n                                     one = 0\\<^sub>v (dim_row A),\n                                     \\<dots> = undefined\\<rparr>", "apply (metis cols_dim comm_add_vec module_vec_def vec_space.cV vec_vs vectorspace.span_closed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Units\n                                  \\<lparr>carrier =\n      LinearCombinations.module.span class_ring\n       \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n          one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n          smult = (\\<cdot>\\<^sub>v)\\<rparr>\n       (set (cols A)),\n                                     mult = (+),\n                                     one = 0\\<^sub>v (dim_row A),\n                                     \\<dots> = undefined\\<rparr>", "unfolding Units_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {y \\<in> carrier\n     \\<lparr>carrier =\n               LinearCombinations.module.span class_ring\n                \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                   one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                (set (cols A)),\n        mult = (+), one = 0\\<^sub>v (dim_row A),\n        \\<dots> = undefined\\<rparr>.\n                                  \\<exists>x\n     \\<in>carrier\n           \\<lparr>carrier =\n                     LinearCombinations.module.span class_ring\n                      \\<lparr>carrier = carrier_vec (dim_row A),\n                         mult = undefined, one = undefined,\n                         zero = 0\\<^sub>v (dim_row A), add = (+),\n                         smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                      (set (cols A)),\n              mult = (+), one = 0\\<^sub>v (dim_row A),\n              \\<dots> = undefined\\<rparr>.\n                                     x \\<otimes>\\<^bsub>\\<lparr>carrier = LinearCombinations.module.span class_ring \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr> (set (cols A)), mult = (+), one = 0\\<^sub>v (dim_row A), \\<dots> = undefined\\<rparr>\\<^esub>\n                                     y =\n                                     \\<one>\\<^bsub>\\<lparr>carrier = LinearCombinations.module.span class_ring \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr> (set (cols A)), mult = (+), one = 0\\<^sub>v (dim_row A), \\<dots> = undefined\\<rparr>\\<^esub> \\<and>\n                                     y \\<otimes>\\<^bsub>\\<lparr>carrier = LinearCombinations.module.span class_ring \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr> (set (cols A)), mult = (+), one = 0\\<^sub>v (dim_row A), \\<dots> = undefined\\<rparr>\\<^esub>\n                                     x =\n                                     \\<one>\\<^bsub>\\<lparr>carrier = LinearCombinations.module.span class_ring \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined, one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr> (set (cols A)), mult = (+), one = 0\\<^sub>v (dim_row A), \\<dots> = undefined\\<rparr>\\<^esub>}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        0\\<^sub>v (dim_row A)\n        \\<in> LinearCombinations.module.span class_ring\n               \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n                  one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n                  smult = (\\<cdot>\\<^sub>v)\\<rparr>\n               (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>LinearCombinations.module.span\n    class_ring\n    \\<lparr>carrier = carrier_vec (dim_row A), mult = undefined,\n       one = undefined, zero = 0\\<^sub>v (dim_row A), add = (+),\n       smult = (\\<cdot>\\<^sub>v)\\<rparr>\n    (set (cols A)).\n                            xa + x = 0\\<^sub>v (dim_row A) \\<and>\n                            x + xa = 0\\<^sub>v (dim_row A)", "by (smt cols_dim module_vec_def partial_object.select_convs(1) uminus_l_inv_vec uminus_r_inv_vec vec_space.vec_neg vec_vs vectorspace.span_closed vectorspace.span_neg)"], ["proof (state)\ngoal (1 subgoal):\n 1. module class_ring\n     (module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n                LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. module class_ring\n     (module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n                LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x.\n       \\<lbrakk>a \\<in> carrier class_ring;\n        x \\<in> carrier\n                 (module_vec TYPE('a) (dim_row A)\n                  \\<lparr>carrier :=\n                            LinearCombinations.module.span class_ring\n                             (module_vec TYPE('a) (dim_row A))\n                             (set (cols A))\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x\n                         \\<in> carrier\n                                (module_vec TYPE('a) (dim_row A)\n                                 \\<lparr>carrier :=\n     LinearCombinations.module.span class_ring\n      (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\n 2. \\<And>a b x.\n       \\<lbrakk>a \\<in> carrier class_ring; b \\<in> carrier class_ring;\n        x \\<in> carrier\n                 (module_vec TYPE('a) (dim_row A)\n                  \\<lparr>carrier :=\n                            LinearCombinations.module.span class_ring\n                             (module_vec TYPE('a) (dim_row A))\n                             (set (cols A))\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> (a \\<oplus>\\<^bsub>class_ring\\<^esub>\n                          b) \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x \\<oplus>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         b \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x\n 3. \\<And>a x y.\n       \\<lbrakk>a \\<in> carrier class_ring;\n        x \\<in> carrier\n                 (module_vec TYPE('a) (dim_row A)\n                  \\<lparr>carrier :=\n                            LinearCombinations.module.span class_ring\n                             (module_vec TYPE('a) (dim_row A))\n                             (set (cols A))\\<rparr>);\n        y \\<in> carrier\n                 (module_vec TYPE('a) (dim_row A)\n                  \\<lparr>carrier :=\n                            LinearCombinations.module.span class_ring\n                             (module_vec TYPE('a) (dim_row A))\n                             (set (cols A))\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         (x \\<oplus>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                          y) =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x \\<oplus>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         y\n 4. \\<And>a b x.\n       \\<lbrakk>a \\<in> carrier class_ring; b \\<in> carrier class_ring;\n        x \\<in> carrier\n                 (module_vec TYPE('a) (dim_row A)\n                  \\<lparr>carrier :=\n                            LinearCombinations.module.span class_ring\n                             (module_vec TYPE('a) (dim_row A))\n                             (set (cols A))\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> a \\<otimes>\\<^bsub>class_ring\\<^esub>\n                         b \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         (b \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                          x)\n 5. \\<And>x.\n       x \\<in> carrier\n                (module_vec TYPE('a) (dim_row A)\n                 \\<lparr>carrier :=\n                           LinearCombinations.module.span class_ring\n                            (module_vec TYPE('a) (dim_row A))\n                            (set (cols A))\\<rparr>) \\<Longrightarrow>\n       \\<one>\\<^bsub>class_ring\\<^esub> \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n       x =\n       x", "unfolding class_ring_simps"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x.\n       \\<lbrakk>a \\<in> UNIV;\n        x \\<in> carrier\n                 (module_vec TYPE('a) (dim_row A)\n                  \\<lparr>carrier :=\n                            LinearCombinations.module.span class_ring\n                             (module_vec TYPE('a) (dim_row A))\n                             (set (cols A))\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x\n                         \\<in> carrier\n                                (module_vec TYPE('a) (dim_row A)\n                                 \\<lparr>carrier :=\n     LinearCombinations.module.span class_ring\n      (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\n 2. \\<And>a b x.\n       \\<lbrakk>a \\<in> UNIV; b \\<in> UNIV;\n        x \\<in> carrier\n                 (module_vec TYPE('a) (dim_row A)\n                  \\<lparr>carrier :=\n                            LinearCombinations.module.span class_ring\n                             (module_vec TYPE('a) (dim_row A))\n                             (set (cols A))\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> (a +\n                          b) \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x \\<oplus>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         b \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x\n 3. \\<And>a x y.\n       \\<lbrakk>a \\<in> UNIV;\n        x \\<in> carrier\n                 (module_vec TYPE('a) (dim_row A)\n                  \\<lparr>carrier :=\n                            LinearCombinations.module.span class_ring\n                             (module_vec TYPE('a) (dim_row A))\n                             (set (cols A))\\<rparr>);\n        y \\<in> carrier\n                 (module_vec TYPE('a) (dim_row A)\n                  \\<lparr>carrier :=\n                            LinearCombinations.module.span class_ring\n                             (module_vec TYPE('a) (dim_row A))\n                             (set (cols A))\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         (x \\<oplus>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                          y) =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x \\<oplus>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         y\n 4. \\<And>a b x.\n       \\<lbrakk>a \\<in> UNIV; b \\<in> UNIV;\n        x \\<in> carrier\n                 (module_vec TYPE('a) (dim_row A)\n                  \\<lparr>carrier :=\n                            LinearCombinations.module.span class_ring\n                             (module_vec TYPE('a) (dim_row A))\n                             (set (cols A))\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> a *\n                         b \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         x =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                         (b \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n                          x)\n 5. \\<And>x.\n       x \\<in> carrier\n                (module_vec TYPE('a) (dim_row A)\n                 \\<lparr>carrier :=\n                           LinearCombinations.module.span class_ring\n                            (module_vec TYPE('a) (dim_row A))\n                            (set (cols A))\\<rparr>) \\<Longrightarrow>\n       (1::'a) \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<lparr>carrier := LinearCombinations.module.span class_ring (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>\\<^esub>\n       x =\n       x", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub> x\n       \\<in> LinearCombinations.module.span class_ring\n              (module_vec TYPE('a) (dim_row A)) (set (cols A))\n 2. \\<And>a b x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       (a + b) \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub> x =\n       a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub>\n       x \\<oplus>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub>\n       b \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub> x\n 3. \\<And>a x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         (module_vec TYPE('a) (dim_row A)) (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub>\n                         (x \\<oplus>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub>\n                          y) =\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub>\n                         x \\<oplus>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub>\n                         a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub>\n                         y\n 4. \\<And>a b x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       a * b \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub> x =\n       a \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub>\n       (b \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub> x)\n 5. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       (1::'a) \\<odot>\\<^bsub>module_vec TYPE('a) (dim_row A)\\<^esub> x = x", "unfolding module_vec_simps"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       a \\<cdot>\\<^sub>v x\n       \\<in> LinearCombinations.module.span class_ring\n              (module_vec TYPE('a) (dim_row A)) (set (cols A))\n 2. \\<And>a b x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       (a + b) \\<cdot>\\<^sub>v x = a \\<cdot>\\<^sub>v x + b \\<cdot>\\<^sub>v x\n 3. \\<And>a x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         (module_vec TYPE('a) (dim_row A)) (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v (x + y) =\n                         a \\<cdot>\\<^sub>v x + a \\<cdot>\\<^sub>v y\n 4. \\<And>a b x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       a * b \\<cdot>\\<^sub>v x = a \\<cdot>\\<^sub>v (b \\<cdot>\\<^sub>v x)\n 5. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       (1::'a) \\<cdot>\\<^sub>v x = x", "using add_smult_distrib_vec"], ["proof (prove)\nusing this:\n  (?a + ?b) \\<cdot>\\<^sub>v ?v =\n  ?a \\<cdot>\\<^sub>v ?v + ?b \\<cdot>\\<^sub>v ?v\n\ngoal (5 subgoals):\n 1. \\<And>a x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       a \\<cdot>\\<^sub>v x\n       \\<in> LinearCombinations.module.span class_ring\n              (module_vec TYPE('a) (dim_row A)) (set (cols A))\n 2. \\<And>a b x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       (a + b) \\<cdot>\\<^sub>v x = a \\<cdot>\\<^sub>v x + b \\<cdot>\\<^sub>v x\n 3. \\<And>a x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         (module_vec TYPE('a) (dim_row A)) (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v (x + y) =\n                         a \\<cdot>\\<^sub>v x + a \\<cdot>\\<^sub>v y\n 4. \\<And>a b x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       a * b \\<cdot>\\<^sub>v x = a \\<cdot>\\<^sub>v (b \\<cdot>\\<^sub>v x)\n 5. \\<And>x.\n       x \\<in> LinearCombinations.module.span class_ring\n                (module_vec TYPE('a) (dim_row A))\n                (set (cols A)) \\<Longrightarrow>\n       (1::'a) \\<cdot>\\<^sub>v x = x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         (module_vec TYPE('a) (dim_row A)) (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v x\n                         \\<in> LinearCombinations.module.span class_ring\n                                (module_vec TYPE('a) (dim_row A))\n                                (set (cols A))\n 2. \\<And>a x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         (module_vec TYPE('a) (dim_row A)) (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A)) (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v (x + y) =\n                         a \\<cdot>\\<^sub>v x + a \\<cdot>\\<^sub>v y", "apply (auto simp add:module_vec_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v x\n                         \\<in> LinearCombinations.module.span class_ring\n                                \\<lparr>carrier = carrier_vec (dim_row A),\n                                   mult = undefined, one = undefined,\n                                   zero = 0\\<^sub>v (dim_row A), add = (+),\n                                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                                (set (cols A))\n 2. \\<And>a x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v (x + y) =\n                         a \\<cdot>\\<^sub>v x + a \\<cdot>\\<^sub>v y", "using vec_module_col_helper2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> LinearCombinations.module.span class_ring\n                     \\<lparr>carrier = carrier_vec (dim_row ?A),\n                        mult = undefined, one = undefined,\n                        zero = 0\\<^sub>v (dim_row ?A), add = (+),\n                        smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                     (set (cols ?A));\n   \\<And>a b v.\n      (a + b) \\<cdot>\\<^sub>v v =\n      a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n  \\<Longrightarrow> ?a \\<cdot>\\<^sub>v ?x\n                    \\<in> LinearCombinations.module.span class_ring\n                           \\<lparr>carrier = carrier_vec (dim_row ?A),\n                              mult = undefined, one = undefined,\n                              zero = 0\\<^sub>v (dim_row ?A), add = (+),\n                              smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                           (set (cols ?A))\n\ngoal (2 subgoals):\n 1. \\<And>a x.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v x\n                         \\<in> LinearCombinations.module.span class_ring\n                                \\<lparr>carrier = carrier_vec (dim_row A),\n                                   mult = undefined, one = undefined,\n                                   zero = 0\\<^sub>v (dim_row A), add = (+),\n                                   smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                                (set (cols A))\n 2. \\<And>a x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v (x + y) =\n                         a \\<cdot>\\<^sub>v x + a \\<cdot>\\<^sub>v y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v (x + y) =\n                         a \\<cdot>\\<^sub>v x + a \\<cdot>\\<^sub>v y", "using cols_dim module_vec_def partial_object.select_convs(1) smult_add_distrib_vec vec_vs vectorspace.span_closed"], ["proof (prove)\nusing this:\n  set (cols ?A) \\<subseteq> carrier_vec (dim_row ?A)\n  module_vec ?ty ?n \\<equiv>\n  \\<lparr>carrier = carrier_vec ?n, mult = undefined, one = undefined,\n     zero = 0\\<^sub>v ?n, add = (+), smult = (\\<cdot>\\<^sub>v)\\<rparr>\n  carrier \\<lparr>carrier = ?carrier, \\<dots> = ?more\\<rparr> = ?carrier\n  \\<lbrakk>?v \\<in> carrier_vec ?n; ?w \\<in> carrier_vec ?n\\<rbrakk>\n  \\<Longrightarrow> ?a \\<cdot>\\<^sub>v (?v + ?w) =\n                    ?a \\<cdot>\\<^sub>v ?v + ?a \\<cdot>\\<^sub>v ?w\n  vectorspace class_ring (module_vec TYPE(?'a) ?n)\n  \\<lbrakk>vectorspace ?K ?V; ?U \\<subseteq> carrier ?V;\n   ?v \\<in> LinearCombinations.module.span ?K ?V ?U\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> carrier ?V\n\ngoal (1 subgoal):\n 1. \\<And>a x y.\n       \\<lbrakk>x \\<in> LinearCombinations.module.span class_ring\n                         \\<lparr>carrier = carrier_vec (dim_row A),\n                            mult = undefined, one = undefined,\n                            zero = 0\\<^sub>v (dim_row A), add = (+),\n                            smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                         (set (cols A));\n        y \\<in> LinearCombinations.module.span class_ring\n                 \\<lparr>carrier = carrier_vec (dim_row A),\n                    mult = undefined, one = undefined,\n                    zero = 0\\<^sub>v (dim_row A), add = (+),\n                    smult = (\\<cdot>\\<^sub>v)\\<rparr>\n                 (set (cols A));\n        \\<And>a b v.\n           (a + b) \\<cdot>\\<^sub>v v =\n           a \\<cdot>\\<^sub>v v + b \\<cdot>\\<^sub>v v\\<rbrakk>\n       \\<Longrightarrow> a \\<cdot>\\<^sub>v (x + y) =\n                         a \\<cdot>\\<^sub>v x + a \\<cdot>\\<^sub>v y", "by (smt (z3))"], ["proof (state)\nthis:\n  module class_ring\n   (module_vec TYPE('a) (dim_row A)\n    \\<lparr>carrier :=\n              LinearCombinations.module.span class_ring\n               (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* The columns of a matrix form a vectorspace *)"], ["", "lemma vec_vs_col: \"vectorspace (class_ring :: 'a :: field ring)\n  (module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n         LinearCombinations.module.span\n          class_ring\n          (module_vec TYPE('a)\n            (dim_row A))\n          (set (cols A))\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring\n     (module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n                LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A)) (set (cols A))\\<rparr>)", "unfolding vectorspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. module class_ring\n     (module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n                LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A))\n                 (set (cols A))\\<rparr>) \\<and>\n    field class_ring", "using vec_module_col class_field"], ["proof (prove)\nusing this:\n  module class_ring\n   (module_vec TYPE(?'a) (dim_row ?A)\n    \\<lparr>carrier :=\n              LinearCombinations.module.span class_ring\n               (module_vec TYPE(?'a) (dim_row ?A)) (set (cols ?A))\\<rparr>)\n  field class_ring\n\ngoal (1 subgoal):\n 1. module class_ring\n     (module_vec TYPE('a) (dim_row A)\n      \\<lparr>carrier :=\n                LinearCombinations.module.span class_ring\n                 (module_vec TYPE('a) (dim_row A))\n                 (set (cols A))\\<rparr>) \\<and>\n    field class_ring", "by (auto simp: class_field_def)"], ["", "lemma cols_mat_mul_map:\n  shows \"cols (A * B) = map ((*\\<^sub>v) A) (cols B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols (A * B) = map ((*\\<^sub>v) A) (cols B)", "unfolding list_eq_iff_nth_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (cols (A * B)) = length (map ((*\\<^sub>v) A) (cols B)) \\<and>\n    (\\<forall>i<length (cols (A * B)).\n        cols (A * B) ! i = map ((*\\<^sub>v) A) (cols B) ! i)", "by auto"], ["", "lemma cols_mat_mul:\n  shows \"set (cols (A * B)) = (*\\<^sub>v) A ` set (cols B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cols (A * B)) = (*\\<^sub>v) A ` set (cols B)", "by (simp add: cols_mat_mul_map)"], ["", "lemma set_obtain_sublist:\n  assumes \"S \\<subseteq> set ls\"\n  obtains ss where \"distinct ss\" \"S = set ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>distinct ss; S = set ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms finite_distinct_list infinite_super"], ["proof (prove)\nusing this:\n  S \\<subseteq> set ls\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A \\<and> distinct xs\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>distinct ss; S = set ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma mul_mat_of_cols:\n  assumes \"A \\<in> carrier_mat nr n\"\n  assumes \"\\<And>j. j < length cs \\<Longrightarrow> cs ! j \\<in> carrier_vec n\"\n  shows \"A * (mat_of_cols n cs) = mat_of_cols nr (map ((*\\<^sub>v) A) cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * mat_of_cols n cs = mat_of_cols nr (map ((*\\<^sub>v) A) cs)", "unfolding mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (A * mat_of_cols n cs) =\n    dim_row (mat_of_cols nr (map ((*\\<^sub>v) A) cs)) \\<and>\n    dim_col (A * mat_of_cols n cs) =\n    dim_col (mat_of_cols nr (map ((*\\<^sub>v) A) cs)) \\<and>\n    (\\<forall>i j.\n        i < dim_row\n             (mat_of_cols nr (map ((*\\<^sub>v) A) cs)) \\<longrightarrow>\n        j < dim_col\n             (mat_of_cols nr (map ((*\\<^sub>v) A) cs)) \\<longrightarrow>\n        (A * mat_of_cols n cs) $$ (i, j) =\n        mat_of_cols nr (map ((*\\<^sub>v) A) cs) $$ (i, j))", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr n\n  ?j < length cs \\<Longrightarrow> cs ! ?j \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_row (A * mat_of_cols n cs) =\n    dim_row (mat_of_cols nr (map ((*\\<^sub>v) A) cs)) \\<and>\n    dim_col (A * mat_of_cols n cs) =\n    dim_col (mat_of_cols nr (map ((*\\<^sub>v) A) cs)) \\<and>\n    (\\<forall>i j.\n        i < dim_row\n             (mat_of_cols nr (map ((*\\<^sub>v) A) cs)) \\<longrightarrow>\n        j < dim_col\n             (mat_of_cols nr (map ((*\\<^sub>v) A) cs)) \\<longrightarrow>\n        (A * mat_of_cols n cs) $$ (i, j) =\n        mat_of_cols nr (map ((*\\<^sub>v) A) cs) $$ (i, j))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>A \\<in> carrier_mat nr n;\n        \\<And>j. j < length cs \\<Longrightarrow> cs ! j \\<in> carrier_vec n;\n        i < nr; j < length cs\\<rbrakk>\n       \\<Longrightarrow> row A i \\<bullet> cs ! j =\n                         mat_of_cols nr (map ((*\\<^sub>v) A) cs) $$ (i, j)", "apply (subst mat_of_cols_index)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>A \\<in> carrier_mat nr n;\n        \\<And>j. j < length cs \\<Longrightarrow> cs ! j \\<in> carrier_vec n;\n        i < nr; j < length cs\\<rbrakk>\n       \\<Longrightarrow> i < nr\n 2. \\<And>i j.\n       \\<lbrakk>A \\<in> carrier_mat nr n;\n        \\<And>j. j < length cs \\<Longrightarrow> cs ! j \\<in> carrier_vec n;\n        i < nr; j < length cs\\<rbrakk>\n       \\<Longrightarrow> j < length (map ((*\\<^sub>v) A) cs)\n 3. \\<And>i j.\n       \\<lbrakk>A \\<in> carrier_mat nr n;\n        \\<And>j. j < length cs \\<Longrightarrow> cs ! j \\<in> carrier_vec n;\n        i < nr; j < length cs\\<rbrakk>\n       \\<Longrightarrow> row A i \\<bullet> cs ! j =\n                         map ((*\\<^sub>v) A) cs ! j $ i", "by auto"], ["", "lemma helper:\n  fixes x y z ::\"'a :: {conjugatable_ring, comm_ring}\"\n  shows \"x * (y * z) = y * x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y * z) = y * x * z", "by (simp add: mult.assoc mult.left_commute)"], ["", "lemma cscalar_prod_conjugate_transpose:\n  fixes x y ::\"'a :: {conjugatable_ring, comm_ring} vec\"\n  assumes \"A \\<in> carrier_mat nr nc\"\n  assumes \"x \\<in> carrier_vec nr\"\n  assumes \"y \\<in> carrier_vec nc\"\n  shows \"x \\<bullet>c (A *\\<^sub>v y) = (A\\<^sup>H *\\<^sub>v x) \\<bullet>c y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bullet>c (A *\\<^sub>v y) = (A\\<^sup>H *\\<^sub>v x) \\<bullet>c y", "unfolding mult_mat_vec_def scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec\n                    (conjugate\n                      (vec (dim_row A)\n                        (\\<lambda>i.\n                            \\<Sum>ia = 0..<dim_vec y.\n                               row A i $ ia * y $ ia))).\n        x $ i *\n        conjugate\n         (vec (dim_row A)\n           (\\<lambda>i. \\<Sum>ia = 0..<dim_vec y. row A i $ ia * y $ ia)) $\n        i) =\n    (\\<Sum>i = 0..<dim_vec (conjugate y).\n        vec (dim_row A\\<^sup>H)\n         (\\<lambda>i.\n             \\<Sum>ia = 0..<dim_vec x. row A\\<^sup>H i $ ia * x $ ia) $\n        i *\n        conjugate y $ i)", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  x \\<in> carrier_vec nr\n  y \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec\n                    (conjugate\n                      (vec (dim_row A)\n                        (\\<lambda>i.\n                            \\<Sum>ia = 0..<dim_vec y.\n                               row A i $ ia * y $ ia))).\n        x $ i *\n        conjugate\n         (vec (dim_row A)\n           (\\<lambda>i. \\<Sum>ia = 0..<dim_vec y. row A i $ ia * y $ ia)) $\n        i) =\n    (\\<Sum>i = 0..<dim_vec (conjugate y).\n        vec (dim_row A\\<^sup>H)\n         (\\<lambda>i.\n             \\<Sum>ia = 0..<dim_vec x. row A\\<^sup>H i $ ia * x $ ia) $\n        i *\n        conjugate y $ i)", "apply (auto simp add: sum_distrib_left sum_distrib_right sum_conjugate conjugate_dist_mul)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat nr nc; x \\<in> carrier_vec nr;\n     y \\<in> carrier_vec nc\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i = 0..<nr.\n                          \\<Sum>n = 0..<nc.\n                             x $ i *\n                             (conjugate (A $$ (i, n)) *\n                              conjugate (y $ n))) =\n                      (\\<Sum>i = 0..<nc.\n                          \\<Sum>n = 0..<nr.\n                             conjugate (A $$ (n, i)) * x $ n *\n                             conjugate (y $ i))", "apply (subst sum.swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat nr nc; x \\<in> carrier_vec nr;\n     y \\<in> carrier_vec nc\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>j = 0..<nc.\n                          \\<Sum>i = 0..<nr.\n                             x $ i *\n                             (conjugate (A $$ (i, j)) *\n                              conjugate (y $ j))) =\n                      (\\<Sum>i = 0..<nc.\n                          \\<Sum>n = 0..<nr.\n                             conjugate (A $$ (n, i)) * x $ n *\n                             conjugate (y $ i))", "by (meson helper mult.assoc mult.left_commute sum.cong)"], ["", "lemma mat_mul_conjugate_transpose_vec_eq_0:                        \n  fixes v ::\"'a :: {conjugatable_ordered_ring,semiring_no_zero_divisors,comm_ring} vec\"\n  assumes \"A \\<in> carrier_mat nr nc\"\n  assumes \"v \\<in> carrier_vec nr\"\n  assumes \"A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v) = 0\\<^sub>v nr\"\n  shows \"A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc", "have \"(A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) = (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) =\n    (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v", "by (metis (mono_tags, lifting) Matrix.carrier_vec_conjugate assms(1) assms(2) assms(3) carrier_matD(2) conjugate_zero_vec cscalar_prod_conjugate_transpose dim_row_conjugate index_transpose_mat(2) mult_mat_vec_def scalar_prod_left_zero scalar_prod_right_zero vec_carrier)"], ["proof (state)\nthis:\n  (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) =\n  (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v\n\ngoal (1 subgoal):\n 1. A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc", "also"], ["proof (state)\nthis:\n  (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) =\n  (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v\n\ngoal (1 subgoal):\n 1. A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v = (0::'a)", "by (simp add: assms(2) assms(3))"], ["proof (state)\nthis:\n  (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v = (0::'a)\n\ngoal (1 subgoal):\n 1. A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc", "(* this step requires real entries *)"], ["proof (state)\nthis:\n  (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v = (0::'a)\n\ngoal (1 subgoal):\n 1. A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc", "ultimately"], ["proof (chain)\npicking this:\n  (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) =\n  (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v\n  (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v = (0::'a)", "have \"(A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) = 0\""], ["proof (prove)\nusing this:\n  (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) =\n  (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v\n  (A *\\<^sub>v (A\\<^sup>H *\\<^sub>v v)) \\<bullet>c v = (0::'a)\n\ngoal (1 subgoal):\n 1. (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) = (0::'a)\n\ngoal (1 subgoal):\n 1. A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc", "thus ?thesis"], ["proof (prove)\nusing this:\n  (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) = (0::'a)\n\ngoal (1 subgoal):\n 1. A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc", "apply (subst conjugate_square_eq_0_vec[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) =\n    (0::'a) \\<Longrightarrow>\n    A\\<^sup>H *\\<^sub>v v \\<in> carrier_vec nc\n 2. (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) =\n    (0::'a) \\<Longrightarrow>\n    (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) = (0::'a)", "using assms(1) carrier_dim_vec"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  (?v \\<in> carrier_vec ?n) = (dim_vec ?v = ?n)\n\ngoal (2 subgoals):\n 1. (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) =\n    (0::'a) \\<Longrightarrow>\n    A\\<^sup>H *\\<^sub>v v \\<in> carrier_vec nc\n 2. (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) =\n    (0::'a) \\<Longrightarrow>\n    (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) = (0::'a)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) =\n    (0::'a) \\<Longrightarrow>\n    (A\\<^sup>H *\\<^sub>v v) \\<bullet>c (A\\<^sup>H *\\<^sub>v v) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A\\<^sup>H *\\<^sub>v v = 0\\<^sub>v nc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_mat_of_cols:\n  assumes \"i < nr\"\n  shows \"row (mat_of_cols nr ls) i = vec (length ls) (\\<lambda>j. (ls ! j) $i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_cols nr ls) i = vec (length ls) (\\<lambda>j. ls ! j $ i)", "by (smt assms dim_vec eq_vecI index_row(1) index_row(2) index_vec mat_of_cols_carrier(2) mat_of_cols_carrier(3) mat_of_cols_index)"], ["", "lemma mat_of_cols_cons_mat_vec:\n  fixes v ::\"'a::comm_ring vec\"\n  assumes \"v \\<in> carrier_vec (length ls)\"\n  assumes \"dim_vec a = nr\"\n  shows\n    \"mat_of_cols nr (a # ls) *\\<^sub>v (vCons m v) =\n   m \\<cdot>\\<^sub>v a + mat_of_cols nr ls *\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols nr (a # ls) *\\<^sub>v vCons m v =\n    m \\<cdot>\\<^sub>v a + mat_of_cols nr ls *\\<^sub>v v", "unfolding mult_mat_vec_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec (dim_row (mat_of_cols nr (a # ls)))\n       (\\<lambda>i. row (mat_of_cols nr (a # ls)) i \\<bullet> vCons m v)) =\n    dim_vec\n     (m \\<cdot>\\<^sub>v a +\n      vec (dim_row (mat_of_cols nr ls))\n       (\\<lambda>i. row (mat_of_cols nr ls) i \\<bullet> v)) \\<and>\n    (\\<forall>i<dim_vec\n                 (m \\<cdot>\\<^sub>v a +\n                  vec (dim_row (mat_of_cols nr ls))\n                   (\\<lambda>i. row (mat_of_cols nr ls) i \\<bullet> v)).\n        vec (dim_row (mat_of_cols nr (a # ls)))\n         (\\<lambda>i. row (mat_of_cols nr (a # ls)) i \\<bullet> vCons m v) $\n        i =\n        (m \\<cdot>\\<^sub>v a +\n         vec (dim_row (mat_of_cols nr ls))\n          (\\<lambda>i. row (mat_of_cols nr ls) i \\<bullet> v)) $\n        i)", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (length ls)\n  dim_vec a = nr\n\ngoal (1 subgoal):\n 1. dim_vec\n     (vec (dim_row (mat_of_cols nr (a # ls)))\n       (\\<lambda>i. row (mat_of_cols nr (a # ls)) i \\<bullet> vCons m v)) =\n    dim_vec\n     (m \\<cdot>\\<^sub>v a +\n      vec (dim_row (mat_of_cols nr ls))\n       (\\<lambda>i. row (mat_of_cols nr ls) i \\<bullet> v)) \\<and>\n    (\\<forall>i<dim_vec\n                 (m \\<cdot>\\<^sub>v a +\n                  vec (dim_row (mat_of_cols nr ls))\n                   (\\<lambda>i. row (mat_of_cols nr ls) i \\<bullet> v)).\n        vec (dim_row (mat_of_cols nr (a # ls)))\n         (\\<lambda>i. row (mat_of_cols nr (a # ls)) i \\<bullet> vCons m v) $\n        i =\n        (m \\<cdot>\\<^sub>v a +\n         vec (dim_row (mat_of_cols nr ls))\n          (\\<lambda>i. row (mat_of_cols nr ls) i \\<bullet> v)) $\n        i)", "by\n    (auto simp add: row_mat_of_cols vec_Suc o_def mult.commute)"], ["", "lemma smult_vec_zero:\n  fixes v ::\"'a::ring vec\"\n  shows \"0 \\<cdot>\\<^sub>v v = 0\\<^sub>v (dim_vec v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<cdot>\\<^sub>v v = 0\\<^sub>v (dim_vec v)", "unfolding smult_vec_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec (dim_vec v) (\\<lambda>i. (0::'a) * v $ i)) =\n    dim_vec (0\\<^sub>v (dim_vec v)) \\<and>\n    (\\<forall>i<dim_vec (0\\<^sub>v (dim_vec v)).\n        vec (dim_vec v) (\\<lambda>i. (0::'a) * v $ i) $ i =\n        0\\<^sub>v (dim_vec v) $ i)", "by (auto)"], ["", "lemma helper2:\n  fixes A ::\"'a::comm_ring mat\"\n  fixes v ::\"'a vec\"\n  assumes \"v \\<in> carrier_vec (length ss)\"\n  assumes \"\\<And>x. x \\<in> set ls \\<Longrightarrow> dim_vec x = nr\"\n  shows\n    \"mat_of_cols nr ss *\\<^sub>v v =\n   mat_of_cols nr (ls @ ss) *\\<^sub>v (0\\<^sub>v (length ls) @\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols nr ss *\\<^sub>v v =\n    mat_of_cols nr (ls @ ss) *\\<^sub>v (0\\<^sub>v (length ls) @\\<^sub>v v)", "using assms(2)"], ["proof (prove)\nusing this:\n  ?x \\<in> set ls \\<Longrightarrow> dim_vec ?x = nr\n\ngoal (1 subgoal):\n 1. mat_of_cols nr ss *\\<^sub>v v =\n    mat_of_cols nr (ls @ ss) *\\<^sub>v (0\\<^sub>v (length ls) @\\<^sub>v v)", "proof (induction ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow> dim_vec x = nr) \\<Longrightarrow>\n    mat_of_cols nr ss *\\<^sub>v v =\n    mat_of_cols nr ([] @ ss) *\\<^sub>v (0\\<^sub>v (length []) @\\<^sub>v v)\n 2. \\<And>a ls.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ls \\<Longrightarrow>\n                    dim_vec x = nr) \\<Longrightarrow>\n                mat_of_cols nr ss *\\<^sub>v v =\n                mat_of_cols nr (ls @ ss) *\\<^sub>v\n                (0\\<^sub>v (length ls) @\\<^sub>v v);\n        \\<And>x.\n           x \\<in> set (a # ls) \\<Longrightarrow> dim_vec x = nr\\<rbrakk>\n       \\<Longrightarrow> mat_of_cols nr ss *\\<^sub>v v =\n                         mat_of_cols nr ((a # ls) @ ss) *\\<^sub>v\n                         (0\\<^sub>v (length (a # ls)) @\\<^sub>v v)", "case Nil"], ["proof (state)\nthis:\n  ?x \\<in> set [] \\<Longrightarrow> dim_vec ?x = nr\n\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow> dim_vec x = nr) \\<Longrightarrow>\n    mat_of_cols nr ss *\\<^sub>v v =\n    mat_of_cols nr ([] @ ss) *\\<^sub>v (0\\<^sub>v (length []) @\\<^sub>v v)\n 2. \\<And>a ls.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ls \\<Longrightarrow>\n                    dim_vec x = nr) \\<Longrightarrow>\n                mat_of_cols nr ss *\\<^sub>v v =\n                mat_of_cols nr (ls @ ss) *\\<^sub>v\n                (0\\<^sub>v (length ls) @\\<^sub>v v);\n        \\<And>x.\n           x \\<in> set (a # ls) \\<Longrightarrow> dim_vec x = nr\\<rbrakk>\n       \\<Longrightarrow> mat_of_cols nr ss *\\<^sub>v v =\n                         mat_of_cols nr ((a # ls) @ ss) *\\<^sub>v\n                         (0\\<^sub>v (length (a # ls)) @\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> set [] \\<Longrightarrow> dim_vec ?x = nr", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> set [] \\<Longrightarrow> dim_vec ?x = nr\n\ngoal (1 subgoal):\n 1. mat_of_cols nr ss *\\<^sub>v v =\n    mat_of_cols nr ([] @ ss) *\\<^sub>v (0\\<^sub>v (length []) @\\<^sub>v v)", "by auto"], ["proof (state)\nthis:\n  mat_of_cols nr ss *\\<^sub>v v =\n  mat_of_cols nr ([] @ ss) *\\<^sub>v (0\\<^sub>v (length []) @\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ls \\<Longrightarrow>\n                    dim_vec x = nr) \\<Longrightarrow>\n                mat_of_cols nr ss *\\<^sub>v v =\n                mat_of_cols nr (ls @ ss) *\\<^sub>v\n                (0\\<^sub>v (length ls) @\\<^sub>v v);\n        \\<And>x.\n           x \\<in> set (a # ls) \\<Longrightarrow> dim_vec x = nr\\<rbrakk>\n       \\<Longrightarrow> mat_of_cols nr ss *\\<^sub>v v =\n                         mat_of_cols nr ((a # ls) @ ss) *\\<^sub>v\n                         (0\\<^sub>v (length (a # ls)) @\\<^sub>v v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ls \\<Longrightarrow>\n                    dim_vec x = nr) \\<Longrightarrow>\n                mat_of_cols nr ss *\\<^sub>v v =\n                mat_of_cols nr (ls @ ss) *\\<^sub>v\n                (0\\<^sub>v (length ls) @\\<^sub>v v);\n        \\<And>x.\n           x \\<in> set (a # ls) \\<Longrightarrow> dim_vec x = nr\\<rbrakk>\n       \\<Longrightarrow> mat_of_cols nr ss *\\<^sub>v v =\n                         mat_of_cols nr ((a # ls) @ ss) *\\<^sub>v\n                         (0\\<^sub>v (length (a # ls)) @\\<^sub>v v)", "case (Cons a ls)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> set ls \\<Longrightarrow> dim_vec x = nr) \\<Longrightarrow>\n  mat_of_cols nr ss *\\<^sub>v v =\n  mat_of_cols nr (ls @ ss) *\\<^sub>v (0\\<^sub>v (length ls) @\\<^sub>v v)\n  ?x \\<in> set (a # ls) \\<Longrightarrow> dim_vec ?x = nr\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set ls \\<Longrightarrow>\n                    dim_vec x = nr) \\<Longrightarrow>\n                mat_of_cols nr ss *\\<^sub>v v =\n                mat_of_cols nr (ls @ ss) *\\<^sub>v\n                (0\\<^sub>v (length ls) @\\<^sub>v v);\n        \\<And>x.\n           x \\<in> set (a # ls) \\<Longrightarrow> dim_vec x = nr\\<rbrakk>\n       \\<Longrightarrow> mat_of_cols nr ss *\\<^sub>v v =\n                         mat_of_cols nr ((a # ls) @ ss) *\\<^sub>v\n                         (0\\<^sub>v (length (a # ls)) @\\<^sub>v v)", "then"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> set ls \\<Longrightarrow> dim_vec x = nr) \\<Longrightarrow>\n  mat_of_cols nr ss *\\<^sub>v v =\n  mat_of_cols nr (ls @ ss) *\\<^sub>v (0\\<^sub>v (length ls) @\\<^sub>v v)\n  ?x \\<in> set (a # ls) \\<Longrightarrow> dim_vec ?x = nr", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set ls \\<Longrightarrow> dim_vec x = nr) \\<Longrightarrow>\n  mat_of_cols nr ss *\\<^sub>v v =\n  mat_of_cols nr (ls @ ss) *\\<^sub>v (0\\<^sub>v (length ls) @\\<^sub>v v)\n  ?x \\<in> set (a # ls) \\<Longrightarrow> dim_vec ?x = nr\n\ngoal (1 subgoal):\n 1. mat_of_cols nr ss *\\<^sub>v v =\n    mat_of_cols nr ((a # ls) @ ss) *\\<^sub>v\n    (0\\<^sub>v (length (a # ls)) @\\<^sub>v v)", "apply (auto simp add:zero_vec_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v =\n             mat_of_cols nr (ls @ ss) *\\<^sub>v\n             (0\\<^sub>v (length ls) @\\<^sub>v v);\n     \\<And>x.\n        x = a \\<or> x \\<in> set ls \\<Longrightarrow> dim_vec x = nr\\<rbrakk>\n    \\<Longrightarrow> mat_of_cols nr (ls @ ss) *\\<^sub>v\n                      (0\\<^sub>v (length ls) @\\<^sub>v v) =\n                      mat_of_cols nr (a # ls @ ss) *\\<^sub>v\n                      vCons (0::'a) (0\\<^sub>v (length ls) @\\<^sub>v v)", "apply (subst mat_of_cols_cons_mat_vec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v =\n             mat_of_cols nr (ls @ ss) *\\<^sub>v\n             (0\\<^sub>v (length ls) @\\<^sub>v v);\n     \\<And>x.\n        x = a \\<or> x \\<in> set ls \\<Longrightarrow> dim_vec x = nr\\<rbrakk>\n    \\<Longrightarrow> 0\\<^sub>v (length ls) @\\<^sub>v v\n                      \\<in> carrier_vec (length (ls @ ss))\n 2. \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v =\n             mat_of_cols nr (ls @ ss) *\\<^sub>v\n             (0\\<^sub>v (length ls) @\\<^sub>v v);\n     \\<And>x.\n        x = a \\<or> x \\<in> set ls \\<Longrightarrow> dim_vec x = nr\\<rbrakk>\n    \\<Longrightarrow> dim_vec a = nr\n 3. \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v =\n             mat_of_cols nr (ls @ ss) *\\<^sub>v\n             (0\\<^sub>v (length ls) @\\<^sub>v v);\n     \\<And>x.\n        x = a \\<or> x \\<in> set ls \\<Longrightarrow> dim_vec x = nr\\<rbrakk>\n    \\<Longrightarrow> mat_of_cols nr (ls @ ss) *\\<^sub>v\n                      (0\\<^sub>v (length ls) @\\<^sub>v v) =\n                      (0::'a) \\<cdot>\\<^sub>v a +\n                      mat_of_cols nr (ls @ ss) *\\<^sub>v\n                      (0\\<^sub>v (length ls) @\\<^sub>v v)", "by (auto simp add:assms smult_vec_zero)"], ["proof (state)\nthis:\n  mat_of_cols nr ss *\\<^sub>v v =\n  mat_of_cols nr ((a # ls) @ ss) *\\<^sub>v\n  (0\\<^sub>v (length (a # ls)) @\\<^sub>v v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_cols_mult_mat_vec_permute_list:\n  fixes v ::\"'a::comm_ring list\"\n  assumes \"f permutes {..<length ss}\"\n  assumes \"length ss = length v\"\n  shows\n    \"mat_of_cols nr (permute_list f ss) *\\<^sub>v vec_of_list (permute_list f v) =\n     mat_of_cols nr ss *\\<^sub>v vec_of_list v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols nr (permute_list f ss) *\\<^sub>v\n    vec_of_list (permute_list f v) =\n    mat_of_cols nr ss *\\<^sub>v vec_of_list v", "unfolding mat_of_cols_def mult_mat_vec_def vec_eq_iff scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec (dim_row\n            (mat nr (length (permute_list f ss))\n              (\\<lambda>(i, j). permute_list f ss ! j $ i)))\n       (\\<lambda>i.\n           \\<Sum>ia = 0..<dim_vec (vec_of_list (permute_list f v)).\n              row (mat nr (length (permute_list f ss))\n                    (\\<lambda>(i, j). permute_list f ss ! j $ i))\n               i $\n              ia *\n              vec_of_list (permute_list f v) $ ia)) =\n    dim_vec\n     (vec (dim_row (mat nr (length ss) (\\<lambda>(i, j). ss ! j $ i)))\n       (\\<lambda>i.\n           \\<Sum>ia = 0..<dim_vec (vec_of_list v).\n              row (mat nr (length ss) (\\<lambda>(i, j). ss ! j $ i)) i $\n              ia *\n              vec_of_list v $ ia)) \\<and>\n    (\\<forall>i<dim_vec\n                 (vec (dim_row\n                        (mat nr (length ss) (\\<lambda>(i, j). ss ! j $ i)))\n                   (\\<lambda>i.\n                       \\<Sum>ia = 0..<dim_vec (vec_of_list v).\n                          row (mat nr (length ss)\n                                (\\<lambda>(i, j). ss ! j $ i))\n                           i $\n                          ia *\n                          vec_of_list v $ ia)).\n        vec (dim_row\n              (mat nr (length (permute_list f ss))\n                (\\<lambda>(i, j). permute_list f ss ! j $ i)))\n         (\\<lambda>i.\n             \\<Sum>ia = 0..<dim_vec (vec_of_list (permute_list f v)).\n                row (mat nr (length (permute_list f ss))\n                      (\\<lambda>(i, j). permute_list f ss ! j $ i))\n                 i $\n                ia *\n                vec_of_list (permute_list f v) $ ia) $\n        i =\n        vec (dim_row (mat nr (length ss) (\\<lambda>(i, j). ss ! j $ i)))\n         (\\<lambda>i.\n             \\<Sum>ia = 0..<dim_vec (vec_of_list v).\n                row (mat nr (length ss) (\\<lambda>(i, j). ss ! j $ i)) i $\n                ia *\n                vec_of_list v $ ia) $\n        i)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n           vec_of_list (permute_list f v) $ ia) =\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia *\n           vec_of_list v $ ia)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n           vec_of_list (permute_list f v) $ ia) =\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia *\n           vec_of_list v $ ia)", "assume \"i < nr\""], ["proof (state)\nthis:\n  i < nr\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n           vec_of_list (permute_list f v) $ ia) =\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia *\n           vec_of_list v $ ia)", "from sum.permute[OF assms(1)]"], ["proof (chain)\npicking this:\n  sum ?g {..<length ss} = sum (?g \\<circ> f) {..<length ss}", "have \"(\\<Sum>ia<length ss. ss ! f ia $ i * v ! f ia) =\n  sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss}\""], ["proof (prove)\nusing this:\n  sum ?g {..<length ss} = sum (?g \\<circ> f) {..<length ss}\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia<length ss. ss ! f ia $ i * v ! f ia) =\n    sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss}", "."], ["proof (state)\nthis:\n  (\\<Sum>ia<length ss. ss ! f ia $ i * v ! f ia) =\n  sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n           vec_of_list (permute_list f v) $ ia) =\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia *\n           vec_of_list v $ ia)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ia<length ss. ss ! f ia $ i * v ! f ia) =\n  sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n           vec_of_list (permute_list f v) $ ia) =\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia *\n           vec_of_list v $ ia)", "have \"... = (\\<Sum>ia = 0..<length v. ss ! f ia $ i * v ! f ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss} =\n    (\\<Sum>ia = 0..<length v. ss ! f ia $ i * v ! f ia)", "using assms(2) calculation lessThan_atLeast0"], ["proof (prove)\nusing this:\n  length ss = length v\n  (\\<Sum>ia<length ss. ss ! f ia $ i * v ! f ia) =\n  sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss}\n  {..<?n} = {0..<?n}\n\ngoal (1 subgoal):\n 1. sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss} =\n    (\\<Sum>ia = 0..<length v. ss ! f ia $ i * v ! f ia)", "by auto"], ["proof (state)\nthis:\n  sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss} =\n  (\\<Sum>ia = 0..<length v. ss ! f ia $ i * v ! f ia)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n           vec_of_list (permute_list f v) $ ia) =\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia *\n           vec_of_list v $ ia)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>ia<length ss. ss ! f ia $ i * v ! f ia) =\n  sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss}\n  sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss} =\n  (\\<Sum>ia = 0..<length v. ss ! f ia $ i * v ! f ia)", "have *: \"(\\<Sum>ia = 0..<length v.\n             ss ! f ia $ i * v ! f ia) =\n         (\\<Sum>ia = 0..<length v.\n             ss ! ia $ i * v ! ia)\""], ["proof (prove)\nusing this:\n  (\\<Sum>ia<length ss. ss ! f ia $ i * v ! f ia) =\n  sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss}\n  sum ((\\<lambda>ia. ss ! f ia $ i * v ! f ia) \\<circ> f) {..<length ss} =\n  (\\<Sum>ia = 0..<length v. ss ! f ia $ i * v ! f ia)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<length v. ss ! f ia $ i * v ! f ia) =\n    (\\<Sum>ia = 0..<length v. ss ! ia $ i * v ! ia)", "by (metis (mono_tags, lifting) \\<open>\\<And>g. sum g {..<length ss} = sum (g \\<circ> f) {..<length ss}\\<close> assms(2) comp_apply lessThan_atLeast0 sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<length v. ss ! f ia $ i * v ! f ia) =\n  (\\<Sum>ia = 0..<length v. ss ! ia $ i * v ! ia)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n           vec_of_list (permute_list f v) $ ia) =\n       (\\<Sum>ia = 0..<length v.\n           vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia *\n           vec_of_list v $ ia)", "show \"(\\<Sum>ia = 0..<length v.\n         vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n         vec_of_list (permute_list f v) $ ia) =\n         (\\<Sum>ia = 0..<length v. vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia * vec_of_list v $ ia)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<length v.\n        vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n        vec_of_list (permute_list f v) $ ia) =\n    (\\<Sum>ia = 0..<length v.\n        vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia * vec_of_list v $ ia)", "using assms *"], ["proof (prove)\nusing this:\n  f permutes {..<length ss}\n  length ss = length v\n  (\\<Sum>ia = 0..<length v. ss ! f ia $ i * v ! f ia) =\n  (\\<Sum>ia = 0..<length v. ss ! ia $ i * v ! ia)\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<length v.\n        vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n        vec_of_list (permute_list f v) $ ia) =\n    (\\<Sum>ia = 0..<length v.\n        vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia * vec_of_list v $ ia)", "by (auto simp add: permute_list_nth vec_of_list_index)"], ["proof (state)\nthis:\n  (\\<Sum>ia = 0..<length v.\n      vec (length ss) (\\<lambda>j. permute_list f ss ! j $ i) $ ia *\n      vec_of_list (permute_list f v) $ ia) =\n  (\\<Sum>ia = 0..<length v.\n      vec (length ss) (\\<lambda>j. ss ! j $ i) $ ia * vec_of_list v $ ia)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* permute everything in a subset of the indices to the back *)"], ["", "lemma subindex_permutation:\n  assumes \"distinct ss\" \"set ss \\<subseteq> {..<length ls}\"\n  obtains f where \"f permutes {..<length ls}\"\n    \"permute_list f ls = map ((!) ls) (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @ map ((!) ls) ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f permutes {..<length ls};\n         permute_list f ls =\n         map ((!) ls)\n          (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @\n         map ((!) ls) ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f permutes {..<length ls};\n         permute_list f ls =\n         map ((!) ls)\n          (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @\n         map ((!) ls) ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"set [0..<length ls] = set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)", "using assms"], ["proof (prove)\nusing this:\n  distinct ss\n  set ss \\<subseteq> {..<length ls}\n\ngoal (1 subgoal):\n 1. set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)", "unfolding multiset_eq_iff"], ["proof (prove)\nusing this:\n  distinct ss\n  set ss \\<subseteq> {..<length ls}\n\ngoal (1 subgoal):\n 1. set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)", "by auto"], ["proof (state)\nthis:\n  set [0..<length ls] =\n  set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f permutes {..<length ls};\n         permute_list f ls =\n         map ((!) ls)\n          (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @\n         map ((!) ls) ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  set [0..<length ls] =\n  set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)", "have \"mset [0..<length ls] = mset (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)\""], ["proof (prove)\nusing this:\n  set [0..<length ls] =\n  set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)\n\ngoal (1 subgoal):\n 1. mset [0..<length ls] =\n    mset (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)", "apply (subst set_eq_iff_mset_eq_distinct[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @\n         ss) \\<Longrightarrow>\n    distinct [0..<length ls]\n 2. set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @\n         ss) \\<Longrightarrow>\n    distinct (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)\n 3. set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @\n         ss) \\<Longrightarrow>\n    set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)", "using assms"], ["proof (prove)\nusing this:\n  distinct ss\n  set ss \\<subseteq> {..<length ls}\n\ngoal (3 subgoals):\n 1. set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @\n         ss) \\<Longrightarrow>\n    distinct [0..<length ls]\n 2. set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @\n         ss) \\<Longrightarrow>\n    distinct (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)\n 3. set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @\n         ss) \\<Longrightarrow>\n    set [0..<length ls] =\n    set (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)", "by auto"], ["proof (state)\nthis:\n  mset [0..<length ls] =\n  mset (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f permutes {..<length ls};\n         permute_list f ls =\n         map ((!) ls)\n          (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @\n         map ((!) ls) ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  mset [0..<length ls] =\n  mset (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)", "have \"mset ls = mset (map ((!) ls)\n           (filter (\\<lambda>i. i \\<notin> set ss)\n             [0..<length ls]) @ map ((!) ls) ss)\""], ["proof (prove)\nusing this:\n  mset [0..<length ls] =\n  mset (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls] @ ss)\n\ngoal (1 subgoal):\n 1. mset ls =\n    mset\n     (map ((!) ls)\n       (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @\n      map ((!) ls) ss)", "by (smt length_map map_append map_nth mset_eq_permutation mset_permute_list permute_list_map)"], ["proof (state)\nthis:\n  mset ls =\n  mset\n   (map ((!) ls) (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @\n    map ((!) ls) ss)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f permutes {..<length ls};\n         permute_list f ls =\n         map ((!) ls)\n          (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @\n         map ((!) ls) ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  mset ls =\n  mset\n   (map ((!) ls) (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @\n    map ((!) ls) ss)\n\ngoal (1 subgoal):\n 1. thesis", "by (metis mset_eq_permutation that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subindex_permutation2:\n  assumes \"distinct ss\" \"set ss \\<subseteq> {..<length ls}\"\n  obtains f where \"f permutes {..<length ls}\"\n    \"ls = permute_list f (map ((!) ls) (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @ map ((!) ls) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f permutes {..<length ls};\n         ls =\n         permute_list f\n          (map ((!) ls)\n            (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @\n           map ((!) ls) ss)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subindex_permutation"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?ss; set ?ss \\<subseteq> {..<length ?ls};\n   \\<And>f.\n      \\<lbrakk>f permutes {..<length ?ls};\n       permute_list f ?ls =\n       map ((!) ?ls)\n        (filter (\\<lambda>i. i \\<notin> set ?ss) [0..<length ?ls]) @\n       map ((!) ?ls) ?ss\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f permutes {..<length ls};\n         ls =\n         permute_list f\n          (map ((!) ls)\n            (filter (\\<lambda>i. i \\<notin> set ss) [0..<length ls]) @\n           map ((!) ls) ss)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(1) assms(2) length_permute_list mset_eq_permutation mset_permute_list)"], ["", "lemma distinct_list_subset_nths:\n  assumes \"distinct ss\" \"set ss \\<subseteq> set ls\"\n  obtains ids where \"distinct ids\" \"set ids \\<subseteq> {..<length ls}\" \"ss = map ((!) ls) ids\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length ls};\n         ss = map ((!) ls) ids\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length ls};\n         ss = map ((!) ls) ids\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?ids = \"map (\\<lambda>i. @j. j < length ls \\<and> ls!j = i ) ss\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length ls};\n         ss = map ((!) ls) ids\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"distinct ?ids\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)", "unfolding distinct_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ss \\<and>\n    inj_on (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) (set ss)", "using assms"], ["proof (prove)\nusing this:\n  distinct ss\n  set ss \\<subseteq> set ls\n\ngoal (1 subgoal):\n 1. distinct ss \\<and>\n    inj_on (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) (set ss)", "apply (auto simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>distinct ss; set ss \\<subseteq> set ls; x \\<in> set ss;\n        y \\<in> set ss;\n        (SOME j. j < length ls \\<and> ls ! j = x) =\n        (SOME j. j < length ls \\<and> ls ! j = y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "by (smt in_mono in_set_conv_nth tfl_some)"], ["proof (state)\nthis:\n  distinct (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)\n\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length ls};\n         ss = map ((!) ls) ids\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 2: \"set ?ids \\<subseteq> {..<length ls}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)\n    \\<subseteq> {..<length ls}", "using assms"], ["proof (prove)\nusing this:\n  distinct ss\n  set ss \\<subseteq> set ls\n\ngoal (1 subgoal):\n 1. set (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)\n    \\<subseteq> {..<length ls}", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>distinct ss; set ss \\<subseteq> set ls;\n        i \\<in> set ss\\<rbrakk>\n       \\<Longrightarrow> (SOME j. j < length ls \\<and> ls ! j = i)\n                         < length ls", "by (metis (mono_tags, lifting) in_mono in_set_conv_nth tfl_some)"], ["proof (state)\nthis:\n  set (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)\n  \\<subseteq> {..<length ls}\n\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length ls};\n         ss = map ((!) ls) ids\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 3: \"ss = map ((!) ls) ?ids\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss =\n    map ((!) ls)\n     (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)", "using assms"], ["proof (prove)\nusing this:\n  distinct ss\n  set ss \\<subseteq> set ls\n\ngoal (1 subgoal):\n 1. ss =\n    map ((!) ls)\n     (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)", "apply (auto simp add: list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>distinct ss; set ss \\<subseteq> set ls;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> ss ! i =\n                         ls ! (SOME j. j < length ls \\<and> ls ! j = ss ! i)", "by (smt imageI in_set_conv_nth subset_iff tfl_some)"], ["proof (state)\nthis:\n  ss =\n  map ((!) ls)\n   (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)\n\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length ls};\n         ss = map ((!) ls) ids\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show \"(\\<And>ids. distinct ids \\<Longrightarrow>\n            set ids \\<subseteq> {..<length ls} \\<Longrightarrow>\n            ss = map ((!) ls) ids \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length ls};\n         ss = map ((!) ls) ids\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1 2 3"], ["proof (prove)\nusing this:\n  distinct (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)\n  set (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)\n  \\<subseteq> {..<length ls}\n  ss =\n  map ((!) ls)\n   (map (\\<lambda>i. SOME j. j < length ls \\<and> ls ! j = i) ss)\n\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length ls};\n         ss = map ((!) ls) ids\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<And>ids.\n      \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length ls};\n       ss = map ((!) ls) ids\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma helper3: \n  fixes A ::\"'a::comm_ring mat\"\n  assumes A: \"A \\<in> carrier_mat nr nc\"\n  assumes ss:\"distinct ss\" \"set ss \\<subseteq> set (cols A)\"\n  assumes \"v \\<in> carrier_vec (length ss)\"\n  obtains c where \"mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c\" \"dim_vec c = nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from distinct_list_subset_nths[OF ss]"], ["proof (chain)\npicking this:\n  (\\<And>ids.\n      \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length (cols A)};\n       ss = map ((!) (cols A)) ids\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain ids where ids: \"distinct ids\" \"set ids \\<subseteq> {..<length (cols A)}\"\n    and ss: \"ss = map ((!) (cols A)) ids\""], ["proof (prove)\nusing this:\n  (\\<And>ids.\n      \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length (cols A)};\n       ss = map ((!) (cols A)) ids\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ids.\n        \\<lbrakk>distinct ids; set ids \\<subseteq> {..<length (cols A)};\n         ss = map ((!) (cols A)) ids\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct ids\n  set ids \\<subseteq> {..<length (cols A)}\n  ss = map ((!) (cols A)) ids\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?ls = \" map ((!) (cols A)) (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)])\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from subindex_permutation2[OF ids]"], ["proof (chain)\npicking this:\n  (\\<And>f.\n      \\<lbrakk>f permutes {..<length (cols A)};\n       cols A =\n       permute_list f\n        (map ((!) (cols A))\n          (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n         map ((!) (cols A)) ids)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain f where\n    f: \"f permutes {..<length (cols A)}\"\n    \"cols A = permute_list f (?ls @ ss)\""], ["proof (prove)\nusing this:\n  (\\<And>f.\n      \\<lbrakk>f permutes {..<length (cols A)};\n       cols A =\n       permute_list f\n        (map ((!) (cols A))\n          (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n         map ((!) (cols A)) ids)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f permutes {..<length (cols A)};\n         cols A =\n         permute_list f\n          (map ((!) (cols A))\n            (filter (\\<lambda>i. i \\<notin> set ids)\n              [0..<length (cols A)]) @\n           ss)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ss"], ["proof (prove)\nusing this:\n  (\\<And>f.\n      \\<lbrakk>f permutes {..<length (cols A)};\n       cols A =\n       permute_list f\n        (map ((!) (cols A))\n          (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n         map ((!) (cols A)) ids)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  ss = map ((!) (cols A)) ids\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f permutes {..<length (cols A)};\n         cols A =\n         permute_list f\n          (map ((!) (cols A))\n            (filter (\\<lambda>i. i \\<notin> set ids)\n              [0..<length (cols A)]) @\n           ss)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f permutes {..<length (cols A)}\n  cols A =\n  permute_list f\n   (map ((!) (cols A))\n     (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n    ss)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have *: \"\\<And>x. x \\<in> set ?ls \\<Longrightarrow> dim_vec x = nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map ((!) (cols A))\n                     (filter (\\<lambda>i. i \\<notin> set ids)\n                       [0..<length (cols A)])) \\<Longrightarrow>\n       dim_vec x = nr", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map ((!) (cols A))\n                     (filter (\\<lambda>i. i \\<notin> set ids)\n                       [0..<length (cols A)])) \\<Longrightarrow>\n       dim_vec x = nr", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> set (map ((!) (cols A))\n                 (filter (\\<lambda>i. i \\<notin> set ids)\n                   [0..<length (cols A)])) \\<Longrightarrow>\n  dim_vec ?x = nr\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?cs1 = \"(list_of_vec (0\\<^sub>v (length ?ls) @\\<^sub>v v))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from helper2[OF assms(4) ]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> set ?ls \\<Longrightarrow> dim_vec x = ?nr) \\<Longrightarrow>\n  mat_of_cols ?nr ss *\\<^sub>v v =\n  mat_of_cols ?nr (?ls @ ss) *\\<^sub>v (0\\<^sub>v (length ?ls) @\\<^sub>v v)", "have \"mat_of_cols nr ss *\\<^sub>v v = mat_of_cols nr (?ls @ ss) *\\<^sub>v vec_of_list (?cs1)\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set ?ls \\<Longrightarrow> dim_vec x = ?nr) \\<Longrightarrow>\n  mat_of_cols ?nr ss *\\<^sub>v v =\n  mat_of_cols ?nr (?ls @ ss) *\\<^sub>v (0\\<^sub>v (length ?ls) @\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. mat_of_cols nr ss *\\<^sub>v v =\n    mat_of_cols nr\n     (map ((!) (cols A))\n       (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n      ss) *\\<^sub>v\n    vec_of_list\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v))", "using *"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set ?ls \\<Longrightarrow> dim_vec x = ?nr) \\<Longrightarrow>\n  mat_of_cols ?nr ss *\\<^sub>v v =\n  mat_of_cols ?nr (?ls @ ss) *\\<^sub>v (0\\<^sub>v (length ?ls) @\\<^sub>v v)\n  ?x \\<in> set (map ((!) (cols A))\n                 (filter (\\<lambda>i. i \\<notin> set ids)\n                   [0..<length (cols A)])) \\<Longrightarrow>\n  dim_vec ?x = nr\n\ngoal (1 subgoal):\n 1. mat_of_cols nr ss *\\<^sub>v v =\n    mat_of_cols nr\n     (map ((!) (cols A))\n       (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n      ss) *\\<^sub>v\n    vec_of_list\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v))", "by (metis vec_list)"], ["proof (state)\nthis:\n  mat_of_cols nr ss *\\<^sub>v v =\n  mat_of_cols nr\n   (map ((!) (cols A))\n     (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n    ss) *\\<^sub>v\n  vec_of_list\n   (list_of_vec\n     (0\\<^sub>v\n       (length\n         (map ((!) (cols A))\n           (filter (\\<lambda>i. i \\<notin> set ids)\n             [0..<length (cols A)]))) @\\<^sub>v\n      v))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  mat_of_cols nr ss *\\<^sub>v v =\n  mat_of_cols nr\n   (map ((!) (cols A))\n     (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n    ss) *\\<^sub>v\n  vec_of_list\n   (list_of_vec\n     (0\\<^sub>v\n       (length\n         (map ((!) (cols A))\n           (filter (\\<lambda>i. i \\<notin> set ids)\n             [0..<length (cols A)]))) @\\<^sub>v\n      v))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"... = mat_of_cols nr (permute_list f (?ls @ ss)) *\\<^sub>v vec_of_list (permute_list f ?cs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols nr\n     (map ((!) (cols A))\n       (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n      ss) *\\<^sub>v\n    vec_of_list\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v)) =\n    mat_of_cols nr\n     (permute_list f\n       (map ((!) (cols A))\n         (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n        ss)) *\\<^sub>v\n    vec_of_list\n     (permute_list f\n       (list_of_vec\n         (0\\<^sub>v\n           (length\n             (map ((!) (cols A))\n               (filter (\\<lambda>i. i \\<notin> set ids)\n                 [0..<length (cols A)]))) @\\<^sub>v\n          v)))", "apply (auto intro!: mat_of_cols_mult_mat_vec_permute_list[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. f permutes\n    {..<length (filter (\\<lambda>i. i \\<notin> set ids) [0..<dim_col A]) +\n        length ss}\n 2. length ss = dim_vec v", "apply (metis cols_length f(1) f(2) length_append length_map length_permute_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length ss = dim_vec v", "using assms(4)"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (length ss)\n\ngoal (1 subgoal):\n 1. length ss = dim_vec v", "by auto"], ["proof (state)\nthis:\n  mat_of_cols nr\n   (map ((!) (cols A))\n     (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n    ss) *\\<^sub>v\n  vec_of_list\n   (list_of_vec\n     (0\\<^sub>v\n       (length\n         (map ((!) (cols A))\n           (filter (\\<lambda>i. i \\<notin> set ids)\n             [0..<length (cols A)]))) @\\<^sub>v\n      v)) =\n  mat_of_cols nr\n   (permute_list f\n     (map ((!) (cols A))\n       (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n      ss)) *\\<^sub>v\n  vec_of_list\n   (permute_list f\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v)))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  mat_of_cols nr\n   (map ((!) (cols A))\n     (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n    ss) *\\<^sub>v\n  vec_of_list\n   (list_of_vec\n     (0\\<^sub>v\n       (length\n         (map ((!) (cols A))\n           (filter (\\<lambda>i. i \\<notin> set ids)\n             [0..<length (cols A)]))) @\\<^sub>v\n      v)) =\n  mat_of_cols nr\n   (permute_list f\n     (map ((!) (cols A))\n       (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n      ss)) *\\<^sub>v\n  vec_of_list\n   (permute_list f\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v)))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"... =  A *\\<^sub>v vec_of_list (permute_list f ?cs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols nr\n     (permute_list f\n       (map ((!) (cols A))\n         (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n        ss)) *\\<^sub>v\n    vec_of_list\n     (permute_list f\n       (list_of_vec\n         (0\\<^sub>v\n           (length\n             (map ((!) (cols A))\n               (filter (\\<lambda>i. i \\<notin> set ids)\n                 [0..<length (cols A)]))) @\\<^sub>v\n          v))) =\n    A *\\<^sub>v\n    vec_of_list\n     (permute_list f\n       (list_of_vec\n         (0\\<^sub>v\n           (length\n             (map ((!) (cols A))\n               (filter (\\<lambda>i. i \\<notin> set ids)\n                 [0..<length (cols A)]))) @\\<^sub>v\n          v)))", "using f(2) assms"], ["proof (prove)\nusing this:\n  cols A =\n  permute_list f\n   (map ((!) (cols A))\n     (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n    ss)\n  A \\<in> carrier_mat nr nc\n  distinct ss\n  set ss \\<subseteq> set (cols A)\n  v \\<in> carrier_vec (length ss)\n\ngoal (1 subgoal):\n 1. mat_of_cols nr\n     (permute_list f\n       (map ((!) (cols A))\n         (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n        ss)) *\\<^sub>v\n    vec_of_list\n     (permute_list f\n       (list_of_vec\n         (0\\<^sub>v\n           (length\n             (map ((!) (cols A))\n               (filter (\\<lambda>i. i \\<notin> set ids)\n                 [0..<length (cols A)]))) @\\<^sub>v\n          v))) =\n    A *\\<^sub>v\n    vec_of_list\n     (permute_list f\n       (list_of_vec\n         (0\\<^sub>v\n           (length\n             (map ((!) (cols A))\n               (filter (\\<lambda>i. i \\<notin> set ids)\n                 [0..<length (cols A)]))) @\\<^sub>v\n          v)))", "by auto"], ["proof (state)\nthis:\n  mat_of_cols nr\n   (permute_list f\n     (map ((!) (cols A))\n       (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n      ss)) *\\<^sub>v\n  vec_of_list\n   (permute_list f\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v))) =\n  A *\\<^sub>v\n  vec_of_list\n   (permute_list f\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v)))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  mat_of_cols nr ss *\\<^sub>v v =\n  mat_of_cols nr\n   (permute_list f\n     (map ((!) (cols A))\n       (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n      ss)) *\\<^sub>v\n  vec_of_list\n   (permute_list f\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v)))\n  mat_of_cols nr\n   (permute_list f\n     (map ((!) (cols A))\n       (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n      ss)) *\\<^sub>v\n  vec_of_list\n   (permute_list f\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v))) =\n  A *\\<^sub>v\n  vec_of_list\n   (permute_list f\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v)))", "show\n    \"(\\<And>c. mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c \\<Longrightarrow> dim_vec c = nc \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\""], ["proof (prove)\nusing this:\n  mat_of_cols nr ss *\\<^sub>v v =\n  mat_of_cols nr\n   (permute_list f\n     (map ((!) (cols A))\n       (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n      ss)) *\\<^sub>v\n  vec_of_list\n   (permute_list f\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v)))\n  mat_of_cols nr\n   (permute_list f\n     (map ((!) (cols A))\n       (filter (\\<lambda>i. i \\<notin> set ids) [0..<length (cols A)]) @\n      ss)) *\\<^sub>v\n  vec_of_list\n   (permute_list f\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v))) =\n  A *\\<^sub>v\n  vec_of_list\n   (permute_list f\n     (list_of_vec\n       (0\\<^sub>v\n         (length\n           (map ((!) (cols A))\n             (filter (\\<lambda>i. i \\<notin> set ids)\n               [0..<length (cols A)]))) @\\<^sub>v\n        v)))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n         dim_vec c = nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis A assms(4) carrier_matD(2) carrier_vecD cols_length dim_vec_of_list f(2) index_append_vec(2) index_zero_vec(2) length_append length_list_of_vec length_permute_list)"], ["proof (state)\nthis:\n  (\\<And>c.\n      \\<lbrakk>mat_of_cols nr ss *\\<^sub>v v = A *\\<^sub>v c;\n       dim_vec c = nc\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_mul_conjugate_transpose_sub_vec_eq_0:                        \n  fixes A ::\"'a :: {conjugatable_ordered_ring,semiring_no_zero_divisors,comm_ring} mat\"\n  assumes \"A \\<in> carrier_mat nr nc\"\n  assumes \"distinct ss\" \"set ss \\<subseteq> set (cols (A\\<^sup>H))\"\n  assumes \"v \\<in> carrier_vec (length ss)\"\n  assumes \"A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v v) = 0\\<^sub>v nr\"\n  shows \"(mat_of_cols nc ss *\\<^sub>v v) = 0\\<^sub>v nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc", "have \"A\\<^sup>H \\<in> carrier_mat nc nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>H \\<in> carrier_mat nc nr", "using assms(1)"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. A\\<^sup>H \\<in> carrier_mat nc nr", "by auto"], ["proof (state)\nthis:\n  A\\<^sup>H \\<in> carrier_mat nc nr\n\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc", "from  helper3[OF this assms(2-4)]"], ["proof (chain)\npicking this:\n  (\\<And>c.\n      \\<lbrakk>mat_of_cols nc ss *\\<^sub>v v = A\\<^sup>H *\\<^sub>v c;\n       dim_vec c = nr\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain c where c: \"mat_of_cols nc ss *\\<^sub>v v = A\\<^sup>H *\\<^sub>v c\" \"dim_vec c = nr\""], ["proof (prove)\nusing this:\n  (\\<And>c.\n      \\<lbrakk>mat_of_cols nc ss *\\<^sub>v v = A\\<^sup>H *\\<^sub>v c;\n       dim_vec c = nr\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>mat_of_cols nc ss *\\<^sub>v v = A\\<^sup>H *\\<^sub>v c;\n         dim_vec c = nr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  mat_of_cols nc ss *\\<^sub>v v = A\\<^sup>H *\\<^sub>v c\n  dim_vec c = nr\n\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc", "have 1: \"c \\<in> carrier_vec nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> carrier_vec nr", "using c carrier_vec_dim_vec"], ["proof (prove)\nusing this:\n  mat_of_cols nc ss *\\<^sub>v v = A\\<^sup>H *\\<^sub>v c\n  dim_vec c = nr\n  ?v \\<in> carrier_vec (dim_vec ?v)\n\ngoal (1 subgoal):\n 1. c \\<in> carrier_vec nr", "by blast"], ["proof (state)\nthis:\n  c \\<in> carrier_vec nr\n\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc", "have 2: \"A *\\<^sub>v (A\\<^sup>H *\\<^sub>v c) = 0\\<^sub>v nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v (A\\<^sup>H *\\<^sub>v c) = 0\\<^sub>v nr", "using c assms(5)"], ["proof (prove)\nusing this:\n  mat_of_cols nc ss *\\<^sub>v v = A\\<^sup>H *\\<^sub>v c\n  dim_vec c = nr\n  A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v v) = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v (A\\<^sup>H *\\<^sub>v c) = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v (A\\<^sup>H *\\<^sub>v c) = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc", "from mat_mul_conjugate_transpose_vec_eq_0[OF assms(1) 1 2]"], ["proof (chain)\npicking this:\n  A\\<^sup>H *\\<^sub>v c = 0\\<^sub>v nc", "have \"A\\<^sup>H *\\<^sub>v c = 0\\<^sub>v nc\""], ["proof (prove)\nusing this:\n  A\\<^sup>H *\\<^sub>v c = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. A\\<^sup>H *\\<^sub>v c = 0\\<^sub>v nc", "."], ["proof (state)\nthis:\n  A\\<^sup>H *\\<^sub>v c = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc", "thus ?thesis"], ["proof (prove)\nusing this:\n  A\\<^sup>H *\\<^sub>v c = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc", "unfolding c(1)[symmetric]"], ["proof (prove)\nusing this:\n  mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc", "."], ["proof (state)\nthis:\n  mat_of_cols nc ss *\\<^sub>v v = 0\\<^sub>v nc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Units_invertible:\n  fixes A:: \"'a::semiring_1 mat\"\n  assumes \"A \\<in> Units (ring_mat TYPE('a) n b)\"\n  shows \"invertible_mat A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat A", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. invertible_mat A", "unfolding Units_def invertible_mat_def"], ["proof (prove)\nusing this:\n  A \\<in> {y \\<in> carrier (ring_mat TYPE('a) n b).\n           \\<exists>x\\<in>carrier (ring_mat TYPE('a) n b).\n              x \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> y =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> x =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub>}\n\ngoal (1 subgoal):\n 1. square_mat A \\<and> (\\<exists>B. inverts_mat A B \\<and> inverts_mat B A)", "apply (auto simp add: ring_mat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<in> carrier_mat n n; x \\<in> carrier_mat n n;\n        x * A = 1\\<^sub>m n; A * x = 1\\<^sub>m n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. inverts_mat A B \\<and> inverts_mat B A", "using inverts_mat_def"], ["proof (prove)\nusing this:\n  inverts_mat ?A ?B \\<equiv> ?A * ?B = 1\\<^sub>m (dim_row ?A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<in> carrier_mat n n; x \\<in> carrier_mat n n;\n        x * A = 1\\<^sub>m n; A * x = 1\\<^sub>m n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. inverts_mat A B \\<and> inverts_mat B A", "by blast"], ["", "lemma invertible_Units:\n  fixes A:: \"'a::semiring_1 mat\"\n  assumes \"invertible_mat A\"\n  shows \"A \\<in> Units (ring_mat TYPE('a) (dim_row A) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> Units (ring_mat TYPE('a) (dim_row A) b)", "using assms"], ["proof (prove)\nusing this:\n  invertible_mat A\n\ngoal (1 subgoal):\n 1. A \\<in> Units (ring_mat TYPE('a) (dim_row A) b)", "unfolding Units_def invertible_mat_def"], ["proof (prove)\nusing this:\n  square_mat A \\<and> (\\<exists>B. inverts_mat A B \\<and> inverts_mat B A)\n\ngoal (1 subgoal):\n 1. A \\<in> {y \\<in> carrier (ring_mat TYPE('a) (dim_row A) b).\n             \\<exists>x\\<in>carrier (ring_mat TYPE('a) (dim_row A) b).\n                x \\<otimes>\\<^bsub>ring_mat TYPE('a) (dim_row A) b\\<^esub>\n                y =\n                \\<one>\\<^bsub>ring_mat TYPE('a) (dim_row A) b\\<^esub> \\<and>\n                y \\<otimes>\\<^bsub>ring_mat TYPE('a) (dim_row A) b\\<^esub>\n                x =\n                \\<one>\\<^bsub>ring_mat TYPE('a) (dim_row A) b\\<^esub>}", "apply (auto simp add: ring_mat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>dim_col A = dim_row A; inverts_mat A B;\n        inverts_mat B A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>carrier_mat (dim_row A) (dim_row A).\n                            x * A = 1\\<^sub>m (dim_row A) \\<and>\n                            A * x = 1\\<^sub>m (dim_row A)", "by (metis assms carrier_mat_triv invertible_mat_def inverts_mat_def inverts_mat_length(1) inverts_mat_length(2))"], ["", "lemma invertible_det:\n  fixes A:: \"'a::field mat\"\n  assumes \"A \\<in> carrier_mat n n\"\n  shows \"invertible_mat A \\<longleftrightarrow> det A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat A = (det A \\<noteq> (0::'a))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invertible_mat A; det A = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow> invertible_mat A", "using invertible_Units unit_imp_det_non_zero"], ["proof (prove)\nusing this:\n  invertible_mat ?A \\<Longrightarrow>\n  ?A \\<in> Units (ring_mat TYPE(?'a) (dim_row ?A) ?b)\n  ?A \\<in> Units (ring_mat TYPE(?'a) ?n ?b) \\<Longrightarrow>\n  det ?A \\<noteq> (0::?'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invertible_mat A; det A = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. det A \\<noteq> (0::'a) \\<Longrightarrow> invertible_mat A", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A \\<noteq> (0::'a) \\<Longrightarrow> invertible_mat A", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det A \\<noteq> (0::'a) \\<Longrightarrow> invertible_mat A", "by (auto intro!: Units_invertible det_non_zero_imp_unit)"], ["", "context vec_space begin"], ["", "lemma find_indices_distinct:\n  assumes \"distinct ss\"\n  assumes \"i < length ss\"\n  shows \"find_indices (ss ! i) ss = [i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_indices (ss ! i) ss = [i]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. find_indices (ss ! i) ss = [i]", "have \"set (find_indices (ss ! i) ss) = {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_indices (ss ! i) ss) = {i}", "using assms"], ["proof (prove)\nusing this:\n  distinct ss\n  i < length ss\n\ngoal (1 subgoal):\n 1. set (find_indices (ss ! i) ss) = {i}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distinct ss; i < length ss; x < length ss;\n        ss ! x = ss ! i\\<rbrakk>\n       \\<Longrightarrow> x = i", "by (simp add: assms(1) assms(2) nth_eq_iff_index_eq)"], ["proof (state)\nthis:\n  set (find_indices (ss ! i) ss) = {i}\n\ngoal (1 subgoal):\n 1. find_indices (ss ! i) ss = [i]", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (find_indices (ss ! i) ss) = {i}\n\ngoal (1 subgoal):\n 1. find_indices (ss ! i) ss = [i]", "by (metis distinct.simps(2) distinct_find_indices empty_iff empty_set insert_iff list.exhaust list.simps(15))"], ["proof (state)\nthis:\n  find_indices (ss ! i) ss = [i]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lin_indpt_lin_comb_list:\n  assumes \"distinct ss\"\n  assumes \"lin_indpt (set ss)\"\n  assumes \"set ss \\<subseteq> carrier_vec n\"\n  assumes \"lincomb_list f ss = 0\\<^sub>v n\"\n  assumes \"i < length ss\"\n  shows \"f i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f i = (0::'a)", "from lincomb_list_as_lincomb[OF assms(3)]"], ["proof (chain)\npicking this:\n  lincomb_list ?c ss = lincomb (mk_coeff ss ?c) (set ss)", "have \"lincomb_list f ss = lincomb (mk_coeff ss f) (set ss)\""], ["proof (prove)\nusing this:\n  lincomb_list ?c ss = lincomb (mk_coeff ss ?c) (set ss)\n\ngoal (1 subgoal):\n 1. lincomb_list f ss = lincomb (mk_coeff ss f) (set ss)", "."], ["proof (state)\nthis:\n  lincomb_list f ss = lincomb (mk_coeff ss f) (set ss)\n\ngoal (1 subgoal):\n 1. f i = (0::'a)", "also"], ["proof (state)\nthis:\n  lincomb_list f ss = lincomb (mk_coeff ss f) (set ss)\n\ngoal (1 subgoal):\n 1. f i = (0::'a)", "have \"... = lincomb  (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (mk_coeff ss f) (set ss) =\n    lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)", "unfolding mk_coeff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>v. R.sumlist (map f (find_indices v ss))) (set ss) =\n    lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)", "apply (subst R.sumlist_map_as_finsum)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v. True\n 2. \\<And>v. distinct (find_indices v ss)\n 3. lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss) =\n    lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)", "by (auto simp add: distinct_find_indices)"], ["proof (state)\nthis:\n  lincomb (mk_coeff ss f) (set ss) =\n  lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)\n\ngoal (1 subgoal):\n 1. f i = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  lincomb_list f ss = lincomb (mk_coeff ss f) (set ss)\n  lincomb (mk_coeff ss f) (set ss) =\n  lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)", "have \"lincomb_list f ss = lincomb  (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)\""], ["proof (prove)\nusing this:\n  lincomb_list f ss = lincomb (mk_coeff ss f) (set ss)\n  lincomb (mk_coeff ss f) (set ss) =\n  lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)\n\ngoal (1 subgoal):\n 1. lincomb_list f ss =\n    lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)", "by auto"], ["proof (state)\nthis:\n  lincomb_list f ss =\n  lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)\n\ngoal (1 subgoal):\n 1. f i = (0::'a)", "then"], ["proof (chain)\npicking this:\n  lincomb_list f ss =\n  lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)", "have *:\"lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss) = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  lincomb_list f ss =\n  lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)\n\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss) =\n    0\\<^sub>v n", "using assms(4)"], ["proof (prove)\nusing this:\n  lincomb_list f ss =\n  lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss)\n  lincomb_list f ss = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss) =\n    0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  lincomb (\\<lambda>v. sum f (set (find_indices v ss))) (set ss) =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. f i = (0::'a)", "have \"finite (set ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set ss)", "by simp"], ["proof (state)\nthis:\n  finite (set ss)\n\ngoal (1 subgoal):\n 1. f i = (0::'a)", "from not_lindepD[OF assms(2) this _ _ *]"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ss \\<subseteq> set ss;\n   (\\<lambda>v. sum f (set (find_indices v ss)))\n   \\<in> set ss \\<rightarrow> UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>v. sum f (set (find_indices v ss)))\n                    \\<in> set ss \\<rightarrow> {0::'a}", "have \"(\\<lambda>v. sum f (set (find_indices v ss))) \\<in> set ss \\<rightarrow> {0}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set ss \\<subseteq> set ss;\n   (\\<lambda>v. sum f (set (find_indices v ss)))\n   \\<in> set ss \\<rightarrow> UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>v. sum f (set (find_indices v ss)))\n                    \\<in> set ss \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. sum f (set (find_indices v ss)))\n    \\<in> set ss \\<rightarrow> {0::'a}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>v. sum f (set (find_indices v ss)))\n  \\<in> set ss \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. f i = (0::'a)", "from funcset_mem[OF this]"], ["proof (chain)\npicking this:\n  ?x \\<in> set ss \\<Longrightarrow>\n  sum f (set (find_indices ?x ss)) \\<in> {0::'a}", "have \"sum f (set (find_indices (nth ss i) ss)) \\<in> {0}\""], ["proof (prove)\nusing this:\n  ?x \\<in> set ss \\<Longrightarrow>\n  sum f (set (find_indices ?x ss)) \\<in> {0::'a}\n\ngoal (1 subgoal):\n 1. sum f (set (find_indices (ss ! i) ss)) \\<in> {0::'a}", "using assms(5)"], ["proof (prove)\nusing this:\n  ?x \\<in> set ss \\<Longrightarrow>\n  sum f (set (find_indices ?x ss)) \\<in> {0::'a}\n  i < length ss\n\ngoal (1 subgoal):\n 1. sum f (set (find_indices (ss ! i) ss)) \\<in> {0::'a}", "by auto"], ["proof (state)\nthis:\n  sum f (set (find_indices (ss ! i) ss)) \\<in> {0::'a}\n\ngoal (1 subgoal):\n 1. f i = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum f (set (find_indices (ss ! i) ss)) \\<in> {0::'a}\n\ngoal (1 subgoal):\n 1. f i = (0::'a)", "unfolding find_indices_distinct[OF assms(1) assms(5)]"], ["proof (prove)\nusing this:\n  sum f (set [i]) \\<in> {0::'a}\n\ngoal (1 subgoal):\n 1. f i = (0::'a)", "by auto"], ["proof (state)\nthis:\n  f i = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Note: in this locale dim_row A = n, e.g.:\nlemma foo:\n  assumes \"dim_row A = n\"\n  shows \"rank A = vec_space.rank (dim_row A) A\"\n  by (simp add: assms) *)"], ["", "lemma span_mat_mul_subset:\n  assumes \"A \\<in> carrier_mat n d\"\n  assumes \"B \\<in> carrier_mat d nc\"\n  shows \"span (set (cols (A * B))) \\<subseteq> span (set (cols A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set (cols (A * B))) \\<subseteq> local.span (set (cols A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.span (set (cols (A * B))) \\<subseteq> local.span (set (cols A))", "have *: \"\\<And>v. \\<exists>ca. lincomb_list v (cols (A * B)) =\n              lincomb_list ca  (cols A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)", "have \"lincomb_list v (cols (A * B)) = (A * B) *\\<^sub>v vec nc v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list v (cols (A * B)) = A * B *\\<^sub>v vec nc v", "apply (subst lincomb_list_as_mat_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>w\\<in>set (cols (A * B)). dim_vec w = n\n 2. mat_of_cols n (cols (A * B)) *\\<^sub>v vec (length (cols (A * B))) v =\n    A * B *\\<^sub>v vec nc v", "apply (metis assms(1) carrier_dim_vec carrier_matD(1) cols_dim index_mult_mat(2) subset_code(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols n (cols (A * B)) *\\<^sub>v vec (length (cols (A * B))) v =\n    A * B *\\<^sub>v vec nc v", "by (metis assms(1) assms(2) carrier_matD(1) carrier_matD(2) cols_length index_mult_mat(2) index_mult_mat(3) mat_of_cols_cols)"], ["proof (state)\nthis:\n  lincomb_list v (cols (A * B)) = A * B *\\<^sub>v vec nc v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)", "also"], ["proof (state)\nthis:\n  lincomb_list v (cols (A * B)) = A * B *\\<^sub>v vec nc v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)", "have \"... = A *\\<^sub>v (B *\\<^sub>v vec nc v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B *\\<^sub>v vec nc v = A *\\<^sub>v (B *\\<^sub>v vec nc v)", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n d\n  B \\<in> carrier_mat d nc\n\ngoal (1 subgoal):\n 1. A * B *\\<^sub>v vec nc v = A *\\<^sub>v (B *\\<^sub>v vec nc v)", "by auto"], ["proof (state)\nthis:\n  A * B *\\<^sub>v vec nc v = A *\\<^sub>v (B *\\<^sub>v vec nc v)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)", "also"], ["proof (state)\nthis:\n  A * B *\\<^sub>v vec nc v = A *\\<^sub>v (B *\\<^sub>v vec nc v)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)", "have \"... = lincomb_list (\\<lambda>i. (B *\\<^sub>v vec nc v) $ i) (cols A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v (B *\\<^sub>v vec nc v) =\n    lincomb_list (($) (B *\\<^sub>v vec nc v)) (cols A)", "apply (subst lincomb_list_as_mat_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>w\\<in>set (cols A). dim_vec w = n\n 2. A *\\<^sub>v (B *\\<^sub>v vec nc v) =\n    mat_of_cols n (cols A) *\\<^sub>v\n    vec (length (cols A)) (($) (B *\\<^sub>v vec nc v))", "using assms(1) carrier_dim_vec cols_dim"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n d\n  (?v \\<in> carrier_vec ?n) = (dim_vec ?v = ?n)\n  set (cols ?A) \\<subseteq> carrier_vec (dim_row ?A)\n\ngoal (2 subgoals):\n 1. \\<forall>w\\<in>set (cols A). dim_vec w = n\n 2. A *\\<^sub>v (B *\\<^sub>v vec nc v) =\n    mat_of_cols n (cols A) *\\<^sub>v\n    vec (length (cols A)) (($) (B *\\<^sub>v vec nc v))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v (B *\\<^sub>v vec nc v) =\n    mat_of_cols n (cols A) *\\<^sub>v\n    vec (length (cols A)) (($) (B *\\<^sub>v vec nc v))", "by (metis assms(1) assms(2) carrier_matD(1) carrier_matD(2) cols_length dim_mult_mat_vec dim_vec eq_vecI index_vec mat_of_cols_cols)"], ["proof (state)\nthis:\n  A *\\<^sub>v (B *\\<^sub>v vec nc v) =\n  lincomb_list (($) (B *\\<^sub>v vec nc v)) (cols A)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)", "ultimately"], ["proof (chain)\npicking this:\n  lincomb_list v (cols (A * B)) = A *\\<^sub>v (B *\\<^sub>v vec nc v)\n  A *\\<^sub>v (B *\\<^sub>v vec nc v) =\n  lincomb_list (($) (B *\\<^sub>v vec nc v)) (cols A)", "have \"lincomb_list v (cols (A * B)) =\n              lincomb_list (\\<lambda>i. (B *\\<^sub>v vec nc v) $ i) (cols A)\""], ["proof (prove)\nusing this:\n  lincomb_list v (cols (A * B)) = A *\\<^sub>v (B *\\<^sub>v vec nc v)\n  A *\\<^sub>v (B *\\<^sub>v vec nc v) =\n  lincomb_list (($) (B *\\<^sub>v vec nc v)) (cols A)\n\ngoal (1 subgoal):\n 1. lincomb_list v (cols (A * B)) =\n    lincomb_list (($) (B *\\<^sub>v vec nc v)) (cols A)", "by auto"], ["proof (state)\nthis:\n  lincomb_list v (cols (A * B)) =\n  lincomb_list (($) (B *\\<^sub>v vec nc v)) (cols A)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)", "thus \"\\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)\""], ["proof (prove)\nusing this:\n  lincomb_list v (cols (A * B)) =\n  lincomb_list (($) (B *\\<^sub>v vec nc v)) (cols A)\n\ngoal (1 subgoal):\n 1. \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ca. lincomb_list v (cols (A * B)) = lincomb_list ca (cols A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ca. lincomb_list ?v1 (cols (A * B)) = lincomb_list ca (cols A)\n\ngoal (1 subgoal):\n 1. local.span (set (cols (A * B))) \\<subseteq> local.span (set (cols A))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.span (set (cols (A * B))) \\<subseteq> local.span (set (cols A))", "apply (subst span_list_as_span[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (cols (A * B)) \\<subseteq> carrier_vec n\n 2. span_list (cols (A * B)) \\<subseteq> local.span (set (cols A))", "apply (metis assms(1) carrier_matD(1) cols_dim index_mult_mat(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. span_list (cols (A * B)) \\<subseteq> local.span (set (cols A))", "apply (subst span_list_as_span[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (cols A) \\<subseteq> carrier_vec n\n 2. span_list (cols (A * B)) \\<subseteq> span_list (cols A)", "using assms(1) cols_dim"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n d\n  set (cols ?A) \\<subseteq> carrier_vec (dim_row ?A)\n\ngoal (2 subgoals):\n 1. set (cols A) \\<subseteq> carrier_vec n\n 2. span_list (cols (A * B)) \\<subseteq> span_list (cols A)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. span_list (cols (A * B)) \\<subseteq> span_list (cols A)", "by (auto simp add:span_list_def *)"], ["proof (state)\nthis:\n  local.span (set (cols (A * B))) \\<subseteq> local.span (set (cols A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_mat_mul_right:\n  assumes \"A \\<in> carrier_mat n d\"\n  assumes \"B \\<in> carrier_mat d nc\"\n  shows \"rank (A * B) \\<le> rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (A * B) \\<le> rank A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank (A * B) \\<le> rank A", "have \"subspace class_ring (local.span (set (cols (A*B))))\n        (vs (local.span (set (cols A))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace class_ring (local.span (set (cols (A * B))))\n     (vs (local.span (set (cols A))))", "unfolding subspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace class_ring (vs (local.span (set (cols A)))) \\<and>\n    LinearCombinations.submodule class_ring\n     (local.span (set (cols (A * B)))) (vs (local.span (set (cols A))))", "by (metis assms(1) assms(2) carrier_matD(1) cols_dim index_mult_mat(2) nested_submodules span_is_submodule vec_space.span_mat_mul_subset vec_vs_col)"], ["proof (state)\nthis:\n  subspace class_ring (local.span (set (cols (A * B))))\n   (vs (local.span (set (cols A))))\n\ngoal (1 subgoal):\n 1. rank (A * B) \\<le> rank A", "from vectorspace.subspace_dim[OF _ this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>vectorspace class_ring (vs (local.span (set (cols A))));\n   vectorspace.fin_dim class_ring (vs (local.span (set (cols A))));\n   vectorspace.fin_dim class_ring\n    (vs (local.span (set (cols A)))\n     \\<lparr>carrier := local.span (set (cols (A * B)))\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> vectorspace.dim class_ring\n                     (vs (local.span (set (cols A)))\n                      \\<lparr>carrier :=\n                                local.span (set (cols (A * B)))\\<rparr>)\n                    \\<le> vectorspace.dim class_ring\n                           (vs (local.span (set (cols A))))", "have \"vectorspace.dim class_ring\n   (vs (local.span (set (cols A)))\n    \\<lparr>carrier := local.span (set (cols (A * B)))\\<rparr>) \\<le>\n  vectorspace.dim class_ring\n      (vs (local.span (set (cols A))))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>vectorspace class_ring (vs (local.span (set (cols A))));\n   vectorspace.fin_dim class_ring (vs (local.span (set (cols A))));\n   vectorspace.fin_dim class_ring\n    (vs (local.span (set (cols A)))\n     \\<lparr>carrier := local.span (set (cols (A * B)))\\<rparr>)\\<rbrakk>\n  \\<Longrightarrow> vectorspace.dim class_ring\n                     (vs (local.span (set (cols A)))\n                      \\<lparr>carrier :=\n                                local.span (set (cols (A * B)))\\<rparr>)\n                    \\<le> vectorspace.dim class_ring\n                           (vs (local.span (set (cols A))))\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (vs (local.span (set (cols A)))\n      \\<lparr>carrier := local.span (set (cols (A * B)))\\<rparr>)\n    \\<le> vectorspace.dim class_ring (vs (local.span (set (cols A))))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>vectorspace class_ring (vs (local.span (set (cols A))));\n      vectorspace.fin_dim class_ring (vs (local.span (set (cols A))));\n      vectorspace.fin_dim class_ring\n       (vs (local.span (set (cols (A * B)))))\\<rbrakk>\n     \\<Longrightarrow> vectorspace.dim class_ring\n                        (vs (local.span (set (cols (A * B)))))\n                       \\<le> vectorspace.dim class_ring\n                              (vs (local.span\n                                    (set (cols A))))) \\<Longrightarrow>\n    vectorspace.dim class_ring (vs (local.span (set (cols (A * B)))))\n    \\<le> vectorspace.dim class_ring (vs (local.span (set (cols A))))", "by (metis (no_types) assms(1) carrier_matD(1) fin_dim_span_cols index_mult_mat(2) mat_of_cols_carrier(1) mat_of_cols_cols vec_vs_col)"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (vs (local.span (set (cols A)))\n    \\<lparr>carrier := local.span (set (cols (A * B)))\\<rparr>)\n  \\<le> vectorspace.dim class_ring (vs (local.span (set (cols A))))\n\ngoal (1 subgoal):\n 1. rank (A * B) \\<le> rank A", "thus ?thesis"], ["proof (prove)\nusing this:\n  vectorspace.dim class_ring\n   (vs (local.span (set (cols A)))\n    \\<lparr>carrier := local.span (set (cols (A * B)))\\<rparr>)\n  \\<le> vectorspace.dim class_ring (vs (local.span (set (cols A))))\n\ngoal (1 subgoal):\n 1. rank (A * B) \\<le> rank A", "unfolding rank_def"], ["proof (prove)\nusing this:\n  vectorspace.dim class_ring\n   (vs (local.span (set (cols A)))\n    \\<lparr>carrier := local.span (set (cols (A * B)))\\<rparr>)\n  \\<le> vectorspace.dim class_ring (vs (local.span (set (cols A))))\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring (vs (local.span (set (cols (A * B)))))\n    \\<le> vectorspace.dim class_ring (vs (local.span (set (cols A))))", "by auto"], ["proof (state)\nthis:\n  rank (A * B) \\<le> rank A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sumlist_drop:\n  assumes \"\\<And>v. v \\<in> set ls \\<Longrightarrow> dim_vec v = n\"\n  shows \"sumlist ls = sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist ls =\n    M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls)", "using assms"], ["proof (prove)\nusing this:\n  ?v1 \\<in> set ls \\<Longrightarrow> dim_vec ?v1 = n\n\ngoal (1 subgoal):\n 1. M.sumlist ls =\n    M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls)", "proof (induction ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow> dim_vec v = n) \\<Longrightarrow>\n    M.sumlist [] =\n    M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) [])\n 2. \\<And>a ls.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set ls \\<Longrightarrow>\n                    dim_vec v = n) \\<Longrightarrow>\n                M.sumlist ls =\n                M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls);\n        \\<And>v.\n           v \\<in> set (a # ls) \\<Longrightarrow> dim_vec v = n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # ls) =\n                         M.sumlist\n                          (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n)\n                            (a # ls))", "case Nil"], ["proof (state)\nthis:\n  ?v1 \\<in> set [] \\<Longrightarrow> dim_vec ?v1 = n\n\ngoal (2 subgoals):\n 1. (\\<And>v.\n        v \\<in> set [] \\<Longrightarrow> dim_vec v = n) \\<Longrightarrow>\n    M.sumlist [] =\n    M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) [])\n 2. \\<And>a ls.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set ls \\<Longrightarrow>\n                    dim_vec v = n) \\<Longrightarrow>\n                M.sumlist ls =\n                M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls);\n        \\<And>v.\n           v \\<in> set (a # ls) \\<Longrightarrow> dim_vec v = n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # ls) =\n                         M.sumlist\n                          (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n)\n                            (a # ls))", "then"], ["proof (chain)\npicking this:\n  ?v1 \\<in> set [] \\<Longrightarrow> dim_vec ?v1 = n", "show ?case"], ["proof (prove)\nusing this:\n  ?v1 \\<in> set [] \\<Longrightarrow> dim_vec ?v1 = n\n\ngoal (1 subgoal):\n 1. M.sumlist [] =\n    M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) [])", "by auto"], ["proof (state)\nthis:\n  M.sumlist [] = M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) [])\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set ls \\<Longrightarrow>\n                    dim_vec v = n) \\<Longrightarrow>\n                M.sumlist ls =\n                M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls);\n        \\<And>v.\n           v \\<in> set (a # ls) \\<Longrightarrow> dim_vec v = n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # ls) =\n                         M.sumlist\n                          (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n)\n                            (a # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set ls \\<Longrightarrow>\n                    dim_vec v = n) \\<Longrightarrow>\n                M.sumlist ls =\n                M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls);\n        \\<And>v.\n           v \\<in> set (a # ls) \\<Longrightarrow> dim_vec v = n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # ls) =\n                         M.sumlist\n                          (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n)\n                            (a # ls))", "case (Cons a ls)"], ["proof (state)\nthis:\n  (\\<And>v.\n      v \\<in> set ls \\<Longrightarrow> dim_vec v = n) \\<Longrightarrow>\n  M.sumlist ls = M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls)\n  ?v1 \\<in> set (a # ls) \\<Longrightarrow> dim_vec ?v1 = n\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>(\\<And>v.\n                    v \\<in> set ls \\<Longrightarrow>\n                    dim_vec v = n) \\<Longrightarrow>\n                M.sumlist ls =\n                M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls);\n        \\<And>v.\n           v \\<in> set (a # ls) \\<Longrightarrow> dim_vec v = n\\<rbrakk>\n       \\<Longrightarrow> M.sumlist (a # ls) =\n                         M.sumlist\n                          (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n)\n                            (a # ls))", "then"], ["proof (chain)\npicking this:\n  (\\<And>v.\n      v \\<in> set ls \\<Longrightarrow> dim_vec v = n) \\<Longrightarrow>\n  M.sumlist ls = M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls)\n  ?v1 \\<in> set (a # ls) \\<Longrightarrow> dim_vec ?v1 = n", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>v.\n      v \\<in> set ls \\<Longrightarrow> dim_vec v = n) \\<Longrightarrow>\n  M.sumlist ls = M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls)\n  ?v1 \\<in> set (a # ls) \\<Longrightarrow> dim_vec ?v1 = n\n\ngoal (1 subgoal):\n 1. M.sumlist (a # ls) =\n    M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) (a # ls))", "using dim_sumlist"], ["proof (prove)\nusing this:\n  (\\<And>v.\n      v \\<in> set ls \\<Longrightarrow> dim_vec v = n) \\<Longrightarrow>\n  M.sumlist ls = M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) ls)\n  ?v1 \\<in> set (a # ls) \\<Longrightarrow> dim_vec ?v1 = n\n  \\<forall>x\\<in>set ?xs. dim_vec x = n \\<Longrightarrow>\n  dim_vec (M.sumlist ?xs) = n\n\ngoal (1 subgoal):\n 1. M.sumlist (a # ls) =\n    M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) (a # ls))", "by auto"], ["proof (state)\nthis:\n  M.sumlist (a # ls) =\n  M.sumlist (filter (\\<lambda>v. v \\<noteq> 0\\<^sub>v n) (a # ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lincomb_list_alt:\n  shows \"lincomb_list c s =\n    sumlist (map2 (\\<lambda>i j. i \\<cdot>\\<^sub>v s ! j) (map (\\<lambda>i. c i) [0..<length s]) [0..<length s])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list c s =\n    M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c [0..<length s])\n       [0..<length s])", "unfolding lincomb_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map (\\<lambda>i. c i \\<cdot>\\<^sub>v s ! i) [0..<length s]) =\n    M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c [0..<length s])\n       [0..<length s])", "by (smt length_map map2_map_map map_nth nth_equalityI nth_map)"], ["", "lemma lincomb_list_alt2:\n  assumes \"\\<And>v. v \\<in> set s \\<Longrightarrow> dim_vec v = n\"\n  assumes \"\\<And>i. i \\<in> set ls \\<Longrightarrow> i < length s\"\n  shows \"\n    sumlist (map2 (\\<lambda>i j. i \\<cdot>\\<^sub>v s ! j) (map (\\<lambda>i. c i) ls) ls) =\n    sumlist (map2 (\\<lambda>i j. i \\<cdot>\\<^sub>v s ! j) (map (\\<lambda>i. c i) (filter (\\<lambda>i. c i \\<noteq> 0) ls)) (filter (\\<lambda>i. c i \\<noteq> 0) ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c ls) ls) =\n    M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n       (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls))\n       (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls))", "using assms(2)"], ["proof (prove)\nusing this:\n  ?i1 \\<in> set ls \\<Longrightarrow> ?i1 < length s\n\ngoal (1 subgoal):\n 1. M.sumlist (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c ls) ls) =\n    M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n       (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls))\n       (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls))", "proof (induction ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i \\<in> set [] \\<Longrightarrow> i < length s) \\<Longrightarrow>\n    M.sumlist (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c []) []) =\n    M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n       (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) []))\n       (filter (\\<lambda>i. c i \\<noteq> (0::'a)) []))\n 2. \\<And>a ls.\n       \\<lbrakk>(\\<And>i.\n                    i \\<in> set ls \\<Longrightarrow>\n                    i < length s) \\<Longrightarrow>\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c ls)\n                   ls) =\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                   (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls))\n                   (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls));\n        \\<And>i.\n           i \\<in> set (a # ls) \\<Longrightarrow> i < length s\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c (a # ls)) (a # ls)) =\n                         M.sumlist\n                          (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c\n                              (filter (\\<lambda>i. c i \\<noteq> (0::'a))\n                                (a # ls)))\n                            (filter (\\<lambda>i. c i \\<noteq> (0::'a))\n                              (a # ls)))", "case Nil"], ["proof (state)\nthis:\n  ?i1 \\<in> set [] \\<Longrightarrow> ?i1 < length s\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i \\<in> set [] \\<Longrightarrow> i < length s) \\<Longrightarrow>\n    M.sumlist (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c []) []) =\n    M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n       (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) []))\n       (filter (\\<lambda>i. c i \\<noteq> (0::'a)) []))\n 2. \\<And>a ls.\n       \\<lbrakk>(\\<And>i.\n                    i \\<in> set ls \\<Longrightarrow>\n                    i < length s) \\<Longrightarrow>\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c ls)\n                   ls) =\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                   (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls))\n                   (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls));\n        \\<And>i.\n           i \\<in> set (a # ls) \\<Longrightarrow> i < length s\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c (a # ls)) (a # ls)) =\n                         M.sumlist\n                          (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c\n                              (filter (\\<lambda>i. c i \\<noteq> (0::'a))\n                                (a # ls)))\n                            (filter (\\<lambda>i. c i \\<noteq> (0::'a))\n                              (a # ls)))", "then"], ["proof (chain)\npicking this:\n  ?i1 \\<in> set [] \\<Longrightarrow> ?i1 < length s", "show ?case"], ["proof (prove)\nusing this:\n  ?i1 \\<in> set [] \\<Longrightarrow> ?i1 < length s\n\ngoal (1 subgoal):\n 1. M.sumlist (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c []) []) =\n    M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n       (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) []))\n       (filter (\\<lambda>i. c i \\<noteq> (0::'a)) []))", "by auto"], ["proof (state)\nthis:\n  M.sumlist (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c []) []) =\n  M.sumlist\n   (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n     (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) []))\n     (filter (\\<lambda>i. c i \\<noteq> (0::'a)) []))\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>(\\<And>i.\n                    i \\<in> set ls \\<Longrightarrow>\n                    i < length s) \\<Longrightarrow>\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c ls)\n                   ls) =\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                   (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls))\n                   (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls));\n        \\<And>i.\n           i \\<in> set (a # ls) \\<Longrightarrow> i < length s\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c (a # ls)) (a # ls)) =\n                         M.sumlist\n                          (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c\n                              (filter (\\<lambda>i. c i \\<noteq> (0::'a))\n                                (a # ls)))\n                            (filter (\\<lambda>i. c i \\<noteq> (0::'a))\n                              (a # ls)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>(\\<And>i.\n                    i \\<in> set ls \\<Longrightarrow>\n                    i < length s) \\<Longrightarrow>\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c ls)\n                   ls) =\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                   (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls))\n                   (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls));\n        \\<And>i.\n           i \\<in> set (a # ls) \\<Longrightarrow> i < length s\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c (a # ls)) (a # ls)) =\n                         M.sumlist\n                          (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c\n                              (filter (\\<lambda>i. c i \\<noteq> (0::'a))\n                                (a # ls)))\n                            (filter (\\<lambda>i. c i \\<noteq> (0::'a))\n                              (a # ls)))", "case (Cons a s)"], ["proof (state)\nthis:\n  (\\<And>i. i \\<in> set s \\<Longrightarrow> i < length s) \\<Longrightarrow>\n  M.sumlist (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n  M.sumlist\n   (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n     (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n     (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n  ?i1 \\<in> set (a # s) \\<Longrightarrow> ?i1 < length s\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>(\\<And>i.\n                    i \\<in> set ls \\<Longrightarrow>\n                    i < length s) \\<Longrightarrow>\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c ls)\n                   ls) =\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                   (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls))\n                   (filter (\\<lambda>i. c i \\<noteq> (0::'a)) ls));\n        \\<And>i.\n           i \\<in> set (a # ls) \\<Longrightarrow> i < length s\\<rbrakk>\n       \\<Longrightarrow> M.sumlist\n                          (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c (a # ls)) (a # ls)) =\n                         M.sumlist\n                          (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c\n                              (filter (\\<lambda>i. c i \\<noteq> (0::'a))\n                                (a # ls)))\n                            (filter (\\<lambda>i. c i \\<noteq> (0::'a))\n                              (a # ls)))", "then"], ["proof (chain)\npicking this:\n  (\\<And>i. i \\<in> set s \\<Longrightarrow> i < length s) \\<Longrightarrow>\n  M.sumlist (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n  M.sumlist\n   (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n     (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n     (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n  ?i1 \\<in> set (a # s) \\<Longrightarrow> ?i1 < length s", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>i. i \\<in> set s \\<Longrightarrow> i < length s) \\<Longrightarrow>\n  M.sumlist (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n  M.sumlist\n   (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n     (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n     (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n  ?i1 \\<in> set (a # s) \\<Longrightarrow> ?i1 < length s\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c (a # s))\n       (a # s)) =\n    M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n       (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) (a # s)))\n       (filter (\\<lambda>i. c i \\<noteq> (0::'a)) (a # s)))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n             M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s));\n     \\<And>i. i = a \\<or> i \\<in> set s \\<Longrightarrow> i < length s;\n     c a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (0::'a) \\<cdot>\\<^sub>v s ! a +\n                      M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s)) =\n                      M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))", "apply (subst smult_l_null)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n             M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s));\n     \\<And>i. i = a \\<or> i \\<in> set s \\<Longrightarrow> i < length s;\n     c a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> s ! a \\<in> carrier_vec n\n 2. \\<lbrakk>M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n             M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s));\n     \\<And>i. i = a \\<or> i \\<in> set s \\<Longrightarrow> i < length s;\n     c a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> 0\\<^sub>v n +\n                      M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s)) =\n                      M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))", "apply (simp add: assms(1) carrier_vecI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n             M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s));\n     \\<And>i. i = a \\<or> i \\<in> set s \\<Longrightarrow> i < length s;\n     c a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> 0\\<^sub>v n +\n                      M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s)) =\n                      M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))", "apply (subst left_zero_vec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n             M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s));\n     \\<And>i. i = a \\<or> i \\<in> set s \\<Longrightarrow> i < length s;\n     c a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                      \\<in> carrier_vec n\n 2. \\<lbrakk>M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n             M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s));\n     \\<And>i. i = a \\<or> i \\<in> set s \\<Longrightarrow> i < length s;\n     c a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s)) =\n                      M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))", "apply (subst sumlist_carrier)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n             M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s));\n     \\<And>i. i = a \\<or> i \\<in> set s \\<Longrightarrow> i < length s;\n     c a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> set (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                            (map c\n                              (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                            (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                      \\<subseteq> carrier_vec n\n 2. \\<lbrakk>M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n             M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s));\n     \\<And>i. i = a \\<or> i \\<in> set s \\<Longrightarrow> i < length s;\n     c a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> True\n 3. \\<lbrakk>M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s) s) =\n             M.sumlist\n              (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s));\n     \\<And>i. i = a \\<or> i \\<in> set s \\<Longrightarrow> i < length s;\n     c a = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s)) =\n                      M.sumlist\n                       (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                         (map c\n                           (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                         (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c s)\n                   s) =\n                M.sumlist\n                 (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n                   (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                   (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s));\n        \\<And>i. i = a \\<or> i \\<in> set s \\<Longrightarrow> i < length s;\n        c a = (0::'a);\n        (aa, b)\n        \\<in> set (zip (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\n                    (filter (\\<lambda>i. c i \\<noteq> (0::'a)) s))\\<rbrakk>\n       \\<Longrightarrow> s ! b \\<in> carrier_vec n", "by (metis (no_types, lifting) assms(1) carrier_dim_vec mem_Collect_eq nth_mem set_filter set_zip_rightD)"], ["proof (state)\nthis:\n  M.sumlist\n   (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y) (map c (a # s)) (a # s)) =\n  M.sumlist\n   (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v s ! y)\n     (map c (filter (\\<lambda>i. c i \\<noteq> (0::'a)) (a # s)))\n     (filter (\\<lambda>i. c i \\<noteq> (0::'a)) (a # s)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma two_set:\n  assumes \"distinct ls\"\n  assumes \"set ls = set [a,b]\"\n  assumes \"a \\<noteq> b\"\n  shows \"ls = [a,b] \\<or> ls = [b,a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls = [a, b] \\<or> ls = [b, a]", "apply (cases ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ls = [] \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]\n 2. \\<And>aa list.\n       ls = aa # list \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]", "using assms(2)"], ["proof (prove)\nusing this:\n  set ls = set [a, b]\n\ngoal (2 subgoals):\n 1. ls = [] \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]\n 2. \\<And>aa list.\n       ls = aa # list \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       ls = aa # list \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       ls = aa # list \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       ls = aa # list \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]", "assume ls:\"ls = x # xs\""], ["proof (state)\nthis:\n  ls = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       ls = aa # list \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]", "obtain y ys where xs:\"xs = y # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y ys. xs = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types) \\<open>ls = x # xs\\<close> assms(2) assms(3) list.set_cases list.set_intros(1) list.set_intros(2) set_ConsD)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       ls = aa # list \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]", "have 1:\"x = a \\<or> x = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = a \\<or> x = b", "using \\<open>ls = x # xs\\<close> assms(2)"], ["proof (prove)\nusing this:\n  ls = x # xs\n  set ls = set [a, b]\n\ngoal (1 subgoal):\n 1. x = a \\<or> x = b", "by auto"], ["proof (state)\nthis:\n  x = a \\<or> x = b\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       ls = aa # list \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]", "have 2:\"y = a \\<or> y = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = a \\<or> y = b", "using \\<open>ls = x # xs\\<close> \\<open>xs = y # ys\\<close> assms(2)"], ["proof (prove)\nusing this:\n  ls = x # xs\n  xs = y # ys\n  set ls = set [a, b]\n\ngoal (1 subgoal):\n 1. y = a \\<or> y = b", "by auto"], ["proof (state)\nthis:\n  y = a \\<or> y = b\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       ls = aa # list \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]", "have 3:\"ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = []", "by (metis (no_types) \\<open>ls = x # xs\\<close> \\<open>xs = y # ys\\<close> assms(1) assms(2) distinct.simps(2) distinct_length_2_or_more in_set_member member_rec(2) neq_Nil_conv set_ConsD)"], ["proof (state)\nthis:\n  ys = []\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       ls = aa # list \\<Longrightarrow> ls = [a, b] \\<or> ls = [b, a]", "show \"ls = [a, b] \\<or> ls = [b, a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls = [a, b] \\<or> ls = [b, a]", "using ls xs 1 2 3 assms"], ["proof (prove)\nusing this:\n  ls = x # xs\n  xs = y # ys\n  x = a \\<or> x = b\n  y = a \\<or> y = b\n  ys = []\n  distinct ls\n  set ls = set [a, b]\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. ls = [a, b] \\<or> ls = [b, a]", "by auto"], ["proof (state)\nthis:\n  ls = [a, b] \\<or> ls = [b, a]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_disj_inds:\n  assumes \"i < length ls\" \"j < length ls\" \"i \\<noteq> j\"\n  shows \"filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i) [0..<length ls] = [i, j] \\<or>\n  filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i) [0..<length ls] = [j,i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [i, j] \\<or>\n    filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [j, i]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [i, j] \\<or>\n    filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [j, i]", "have 1: \"distinct (filter (\\<lambda>ia. ia = i \\<or> ia = j) [0..<length ls])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>ia. ia = i \\<or> ia = j) [0..<length ls])", "using distinct_filter distinct_upt"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow> distinct (filter ?P ?xs)\n  distinct [?i..<?j]\n\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>ia. ia = i \\<or> ia = j) [0..<length ls])", "by blast"], ["proof (state)\nthis:\n  distinct (filter (\\<lambda>ia. ia = i \\<or> ia = j) [0..<length ls])\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [i, j] \\<or>\n    filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [j, i]", "have 2:\"set (filter (\\<lambda>ia. ia = i \\<or> ia = j) [0..<length ls]) = {i, j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>ia. ia = i \\<or> ia = j) [0..<length ls]) = {i, j}", "using assms"], ["proof (prove)\nusing this:\n  i < length ls\n  j < length ls\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>ia. ia = i \\<or> ia = j) [0..<length ls]) = {i, j}", "by auto"], ["proof (state)\nthis:\n  set (filter (\\<lambda>ia. ia = i \\<or> ia = j) [0..<length ls]) = {i, j}\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [i, j] \\<or>\n    filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [j, i]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [i, j] \\<or>\n    filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [j, i]", "using two_set[OF 1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set (filter (\\<lambda>ia. ia = i \\<or> ia = j) [0..<length ls]) =\n           set [?a, ?b];\n   ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>ia. ia = i \\<or> ia = j)\n                     [0..<length ls] =\n                    [?a, ?b] \\<or>\n                    filter (\\<lambda>ia. ia = i \\<or> ia = j)\n                     [0..<length ls] =\n                    [?b, ?a]\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [i, j] \\<or>\n    filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [j, i]", "using assms(3) empty_set filter_cong list.simps(15)"], ["proof (prove)\nusing this:\n  \\<lbrakk>set (filter (\\<lambda>ia. ia = i \\<or> ia = j) [0..<length ls]) =\n           set [?a, ?b];\n   ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>ia. ia = i \\<or> ia = j)\n                     [0..<length ls] =\n                    [?a, ?b] \\<or>\n                    filter (\\<lambda>ia. ia = i \\<or> ia = j)\n                     [0..<length ls] =\n                    [?b, ?a]\n  i \\<noteq> j\n  {} = set []\n  \\<lbrakk>?xs = ?ys;\n   \\<And>x. x \\<in> set ?ys \\<Longrightarrow> ?P x = ?Q x\\<rbrakk>\n  \\<Longrightarrow> filter ?P ?xs = filter ?Q ?ys\n  set (?x21.0 # ?x22.0) = insert ?x21.0 (set ?x22.0)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [i, j] \\<or>\n    filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n     [0..<length ls] =\n    [j, i]", "by (smt \"2\" assms(3) empty_set filter_cong list.simps(15))"], ["proof (state)\nthis:\n  filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n   [0..<length ls] =\n  [i, j] \\<or>\n  filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n   [0..<length ls] =\n  [j, i]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lincomb_list_indpt_distinct:\n  assumes \"\\<And>v. v \\<in> set ls \\<Longrightarrow> dim_vec v = n\"\n  assumes\n    \"\\<And>c. lincomb_list c ls = 0\\<^sub>v n \\<Longrightarrow> (\\<forall>i. i < (length ls) \\<longrightarrow> c i = 0)\"\n  shows \"distinct ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ls", "unfolding distinct_conv_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length ls.\n       \\<forall>j<length ls.\n          i \\<noteq> j \\<longrightarrow> ls ! i \\<noteq> ls ! j", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length ls; j < length ls; i \\<noteq> j;\n        ls ! i = ls ! j\\<rbrakk>\n       \\<Longrightarrow> False", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length ls; j < length ls; i \\<noteq> j;\n        ls ! i = ls ! j\\<rbrakk>\n       \\<Longrightarrow> False", "assume ij: \"i < length ls\" \"j < length ls\" \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i < length ls\n  j < length ls\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length ls; j < length ls; i \\<noteq> j;\n        ls ! i = ls ! j\\<rbrakk>\n       \\<Longrightarrow> False", "assume lsij: \"ls ! i = ls ! j\""], ["proof (state)\nthis:\n  ls ! i = ls ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length ls; j < length ls; i \\<noteq> j;\n        ls ! i = ls ! j\\<rbrakk>\n       \\<Longrightarrow> False", "have \"lincomb_list (\\<lambda>k. if k = i then 1 else if k = j then -1 else 0) ls =\n     (ls ! i) - (ls ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>k.\n         if k = i then 1::'a else if k = j then - (1::'a) else (0::'a))\n     ls =\n    ls ! i - ls ! j", "unfolding lincomb_list_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v ls ! y)\n       (map (\\<lambda>k.\n                if k = i then 1::'a\n                else if k = j then - (1::'a) else (0::'a))\n         [0..<length ls])\n       [0..<length ls]) =\n    ls ! i - ls ! j", "apply (subst lincomb_list_alt2[OF assms(1)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v. v \\<in> set ls \\<Longrightarrow> v \\<in> set ls\n 2. \\<And>i. i \\<in> set [0..<length ls] \\<Longrightarrow> i < length ls\n 3. M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v ls ! y)\n       (map (\\<lambda>ia.\n                if ia = i then 1::'a\n                else if ia = j then - (1::'a) else (0::'a))\n         (filter\n           (\\<lambda>ia.\n               (if ia = i then 1::'a\n                else if ia = j then - (1::'a) else (0::'a)) \\<noteq>\n               (0::'a))\n           [0..<length ls]))\n       (filter\n         (\\<lambda>ia.\n             (if ia = i then 1::'a\n              else if ia = j then - (1::'a) else (0::'a)) \\<noteq>\n             (0::'a))\n         [0..<length ls])) =\n    ls ! i - ls ! j", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v ls ! y)\n       (map (\\<lambda>ia.\n                if ia = i then 1::'a\n                else if ia = j then - (1::'a) else (0::'a))\n         (filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n           [0..<length ls]))\n       (filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n         [0..<length ls])) =\n    ls ! i - ls ! j", "using  filter_disj_inds[OF ij]"], ["proof (prove)\nusing this:\n  filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n   [0..<length ls] =\n  [i, j] \\<or>\n  filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n   [0..<length ls] =\n  [j, i]\n\ngoal (1 subgoal):\n 1. M.sumlist\n     (map2 (\\<lambda>x y. x \\<cdot>\\<^sub>v ls ! y)\n       (map (\\<lambda>ia.\n                if ia = i then 1::'a\n                else if ia = j then - (1::'a) else (0::'a))\n         (filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n           [0..<length ls]))\n       (filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n         [0..<length ls])) =\n    ls ! i - ls ! j", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>ia. ia = i) [0..<length ls] = [i, i];\n     j = i\\<rbrakk>\n    \\<Longrightarrow> ls ! i + (ls ! i + 0\\<^sub>v n) = ls ! i - ls ! i\n 2. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [i, j];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> ls ! i +\n                      (- (1::'a) \\<cdot>\\<^sub>v ls ! j + 0\\<^sub>v n) =\n                      ls ! i - ls ! j\n 3. \\<lbrakk>filter (\\<lambda>ia. ia = i) [0..<length ls] = [i, i];\n     j = i\\<rbrakk>\n    \\<Longrightarrow> ls ! i + (ls ! i + 0\\<^sub>v n) = ls ! i - ls ! i\n 4. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [j, i];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> - (1::'a) \\<cdot>\\<^sub>v ls ! j +\n                      (ls ! i + 0\\<^sub>v n) =\n                      ls ! i - ls ! j", "using ij(3)"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (4 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>ia. ia = i) [0..<length ls] = [i, i];\n     j = i\\<rbrakk>\n    \\<Longrightarrow> ls ! i + (ls ! i + 0\\<^sub>v n) = ls ! i - ls ! i\n 2. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [i, j];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> ls ! i +\n                      (- (1::'a) \\<cdot>\\<^sub>v ls ! j + 0\\<^sub>v n) =\n                      ls ! i - ls ! j\n 3. \\<lbrakk>filter (\\<lambda>ia. ia = i) [0..<length ls] = [i, i];\n     j = i\\<rbrakk>\n    \\<Longrightarrow> ls ! i + (ls ! i + 0\\<^sub>v n) = ls ! i - ls ! i\n 4. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [j, i];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> - (1::'a) \\<cdot>\\<^sub>v ls ! j +\n                      (ls ! i + 0\\<^sub>v n) =\n                      ls ! i - ls ! j", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [i, j];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> ls ! i +\n                      (- (1::'a) \\<cdot>\\<^sub>v ls ! j + 0\\<^sub>v n) =\n                      ls ! i - ls ! j\n 2. \\<lbrakk>filter (\\<lambda>ia. ia = i) [0..<length ls] = [i, i];\n     j = i\\<rbrakk>\n    \\<Longrightarrow> ls ! i + (ls ! i + 0\\<^sub>v n) = ls ! i - ls ! i\n 3. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [j, i];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> - (1::'a) \\<cdot>\\<^sub>v ls ! j +\n                      (ls ! i + 0\\<^sub>v n) =\n                      ls ! i - ls ! j", "using assms(1) ij(2)"], ["proof (prove)\nusing this:\n  ?v1 \\<in> set ls \\<Longrightarrow> dim_vec ?v1 = n\n  j < length ls\n\ngoal (3 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [i, j];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> ls ! i +\n                      (- (1::'a) \\<cdot>\\<^sub>v ls ! j + 0\\<^sub>v n) =\n                      ls ! i - ls ! j\n 2. \\<lbrakk>filter (\\<lambda>ia. ia = i) [0..<length ls] = [i, i];\n     j = i\\<rbrakk>\n    \\<Longrightarrow> ls ! i + (ls ! i + 0\\<^sub>v n) = ls ! i - ls ! i\n 3. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [j, i];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> - (1::'a) \\<cdot>\\<^sub>v ls ! j +\n                      (ls ! i + 0\\<^sub>v n) =\n                      ls ! i - ls ! j", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>ia. ia = i) [0..<length ls] = [i, i];\n     j = i\\<rbrakk>\n    \\<Longrightarrow> ls ! i + (ls ! i + 0\\<^sub>v n) = ls ! i - ls ! i\n 2. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [j, i];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> - (1::'a) \\<cdot>\\<^sub>v ls ! j +\n                      (ls ! i + 0\\<^sub>v n) =\n                      ls ! i - ls ! j", "using ij(3)"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>filter (\\<lambda>ia. ia = i) [0..<length ls] = [i, i];\n     j = i\\<rbrakk>\n    \\<Longrightarrow> ls ! i + (ls ! i + 0\\<^sub>v n) = ls ! i - ls ! i\n 2. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [j, i];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> - (1::'a) \\<cdot>\\<^sub>v ls ! j +\n                      (ls ! i + 0\\<^sub>v n) =\n                      ls ! i - ls ! j", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [j, i];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> - (1::'a) \\<cdot>\\<^sub>v ls ! j +\n                      (ls ! i + 0\\<^sub>v n) =\n                      ls ! i - ls ! j", "using assms(1) ij(2)"], ["proof (prove)\nusing this:\n  ?v1 \\<in> set ls \\<Longrightarrow> dim_vec ?v1 = n\n  j < length ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>filter (\\<lambda>ia. ia \\<noteq> j \\<longrightarrow> ia = i)\n              [0..<length ls] =\n             [j, i];\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> - (1::'a) \\<cdot>\\<^sub>v ls ! j +\n                      (ls ! i + 0\\<^sub>v n) =\n                      ls ! i - ls ! j", "by auto"], ["proof (state)\nthis:\n  lincomb_list\n   (\\<lambda>k.\n       if k = i then 1::'a else if k = j then - (1::'a) else (0::'a))\n   ls =\n  ls ! i - ls ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length ls; j < length ls; i \\<noteq> j;\n        ls ! i = ls ! j\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lincomb_list\n   (\\<lambda>k.\n       if k = i then 1::'a else if k = j then - (1::'a) else (0::'a))\n   ls =\n  ls ! i - ls ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length ls; j < length ls; i \\<noteq> j;\n        ls ! i = ls ! j\\<rbrakk>\n       \\<Longrightarrow> False", "have \"...  = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls ! i - ls ! j = 0\\<^sub>v n", "unfolding lsij"], ["proof (prove)\ngoal (1 subgoal):\n 1. ls ! j - ls ! j = 0\\<^sub>v n", "apply (rule minus_cancel_vec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ls ! j \\<in> carrier_vec n", "using \\<open>j < length ls\\<close> assms(1)"], ["proof (prove)\nusing this:\n  j < length ls\n  ?v1 \\<in> set ls \\<Longrightarrow> dim_vec ?v1 = n\n\ngoal (1 subgoal):\n 1. ls ! j \\<in> carrier_vec n", "using carrier_vec_dim_vec nth_mem"], ["proof (prove)\nusing this:\n  j < length ls\n  ?v1 \\<in> set ls \\<Longrightarrow> dim_vec ?v1 = n\n  ?v \\<in> carrier_vec (dim_vec ?v)\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. ls ! j \\<in> carrier_vec n", "by blast"], ["proof (state)\nthis:\n  ls ! i - ls ! j = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length ls; j < length ls; i \\<noteq> j;\n        ls ! i = ls ! j\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  lincomb_list\n   (\\<lambda>k.\n       if k = i then 1::'a else if k = j then - (1::'a) else (0::'a))\n   ls =\n  ls ! i - ls ! j\n  ls ! i - ls ! j = 0\\<^sub>v n", "have \"lincomb_list (\\<lambda>k. if k = i then 1 else if k = j then -1 else 0) ls = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  lincomb_list\n   (\\<lambda>k.\n       if k = i then 1::'a else if k = j then - (1::'a) else (0::'a))\n   ls =\n  ls ! i - ls ! j\n  ls ! i - ls ! j = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb_list\n     (\\<lambda>k.\n         if k = i then 1::'a else if k = j then - (1::'a) else (0::'a))\n     ls =\n    0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  lincomb_list\n   (\\<lambda>k.\n       if k = i then 1::'a else if k = j then - (1::'a) else (0::'a))\n   ls =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length ls; j < length ls; i \\<noteq> j;\n        ls ! i = ls ! j\\<rbrakk>\n       \\<Longrightarrow> False", "from assms(2)[OF this]"], ["proof (chain)\npicking this:\n  \\<forall>ia<length ls.\n     (if ia = i then 1::'a else if ia = j then - (1::'a) else (0::'a)) =\n     (0::'a)", "show False"], ["proof (prove)\nusing this:\n  \\<forall>ia<length ls.\n     (if ia = i then 1::'a else if ia = j then - (1::'a) else (0::'a)) =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>i < length ls\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>ia<length ls.\n     (if ia = i then 1::'a else if ia = j then - (1::'a) else (0::'a)) =\n     (0::'a)\n  i < length ls\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale conjugatable_vec_space = vec_space f_ty n for\n  f_ty::\"'a::conjugatable_ordered_field itself\"\n  and n\nbegin"], ["", "lemma transpose_rank_mul_conjugate_transpose:\n  fixes A :: \"'a mat\"\n  assumes \"A \\<in> carrier_mat n nc\"\n  shows \"vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have 1: \"A\\<^sup>H \\<in> carrier_mat nc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>H \\<in> carrier_mat nc n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. A\\<^sup>H \\<in> carrier_mat nc n", "by auto"], ["proof (state)\nthis:\n  A\\<^sup>H \\<in> carrier_mat nc n\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have 2: \"A * A\\<^sup>H \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * A\\<^sup>H \\<in> carrier_mat n n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. A * A\\<^sup>H \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A * A\\<^sup>H \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "(* S is a maximal linearly independent set of rows A (or cols A\\<^sup>T) *)"], ["proof (state)\nthis:\n  A * A\\<^sup>H \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "let ?P = \"(\\<lambda>T. T \\<subseteq> set (cols A\\<^sup>H) \\<and> module.lin_indpt class_ring (module_vec TYPE('a) nc) T)\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have *:\"\\<And>A. ?P A \\<Longrightarrow> finite A \\<and> card A \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       Aa \\<subseteq> set (cols A\\<^sup>H) \\<and>\n       \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n               Aa \\<Longrightarrow>\n       finite Aa \\<and> card Aa \\<le> n", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>Aa \\<subseteq> set (cols A\\<^sup>H);\n        \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                Aa\\<rbrakk>\n       \\<Longrightarrow> finite Aa \\<and> card Aa \\<le> n", "fix S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>Aa \\<subseteq> set (cols A\\<^sup>H);\n        \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                Aa\\<rbrakk>\n       \\<Longrightarrow> finite Aa \\<and> card Aa \\<le> n", "assume S: \"S \\<subseteq> set (cols A\\<^sup>H)\""], ["proof (state)\nthis:\n  S \\<subseteq> set (cols A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>Aa \\<subseteq> set (cols A\\<^sup>H);\n        \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                Aa\\<rbrakk>\n       \\<Longrightarrow> finite Aa \\<and> card Aa \\<le> n", "have \"card S \\<le> card (set (cols A\\<^sup>H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card S \\<le> card (set (cols A\\<^sup>H))", "using S"], ["proof (prove)\nusing this:\n  S \\<subseteq> set (cols A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. card S \\<le> card (set (cols A\\<^sup>H))", "using card_mono"], ["proof (prove)\nusing this:\n  S \\<subseteq> set (cols A\\<^sup>H)\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> card ?B\n\ngoal (1 subgoal):\n 1. card S \\<le> card (set (cols A\\<^sup>H))", "by blast"], ["proof (state)\nthis:\n  card S \\<le> card (set (cols A\\<^sup>H))\n\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>Aa \\<subseteq> set (cols A\\<^sup>H);\n        \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                Aa\\<rbrakk>\n       \\<Longrightarrow> finite Aa \\<and> card Aa \\<le> n", "also"], ["proof (state)\nthis:\n  card S \\<le> card (set (cols A\\<^sup>H))\n\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>Aa \\<subseteq> set (cols A\\<^sup>H);\n        \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                Aa\\<rbrakk>\n       \\<Longrightarrow> finite Aa \\<and> card Aa \\<le> n", "have \"... \\<le> length (cols A\\<^sup>H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (cols A\\<^sup>H)) \\<le> length (cols A\\<^sup>H)", "using card_length"], ["proof (prove)\nusing this:\n  card (set ?xs) \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. card (set (cols A\\<^sup>H)) \\<le> length (cols A\\<^sup>H)", "by blast"], ["proof (state)\nthis:\n  card (set (cols A\\<^sup>H)) \\<le> length (cols A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>Aa \\<subseteq> set (cols A\\<^sup>H);\n        \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                Aa\\<rbrakk>\n       \\<Longrightarrow> finite Aa \\<and> card Aa \\<le> n", "also"], ["proof (state)\nthis:\n  card (set (cols A\\<^sup>H)) \\<le> length (cols A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>Aa \\<subseteq> set (cols A\\<^sup>H);\n        \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                Aa\\<rbrakk>\n       \\<Longrightarrow> finite Aa \\<and> card Aa \\<le> n", "have \"... \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (cols A\\<^sup>H) \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. length (cols A\\<^sup>H) \\<le> n", "by auto"], ["proof (state)\nthis:\n  length (cols A\\<^sup>H) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>Aa \\<subseteq> set (cols A\\<^sup>H);\n        \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                Aa\\<rbrakk>\n       \\<Longrightarrow> finite Aa \\<and> card Aa \\<le> n", "ultimately"], ["proof (chain)\npicking this:\n  card S \\<le> length (cols A\\<^sup>H)\n  length (cols A\\<^sup>H) \\<le> n", "show \"finite S \\<and> card S \\<le> n\""], ["proof (prove)\nusing this:\n  card S \\<le> length (cols A\\<^sup>H)\n  length (cols A\\<^sup>H) \\<le> n\n\ngoal (1 subgoal):\n 1. finite S \\<and> card S \\<le> n", "by (meson List.finite_set S dual_order.trans finite_subset)"], ["proof (state)\nthis:\n  finite S \\<and> card S \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?A1 \\<subseteq> set (cols A\\<^sup>H) \\<and>\n  \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n          ?A1 \\<Longrightarrow>\n  finite ?A1 \\<and> card ?A1 \\<le> n\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have **:\"?P {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> set (cols A\\<^sup>H) \\<and>\n    \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) {}", "apply (subst module.lin_dep_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. module class_ring (module_vec TYPE('a) nc)\n 2. {} \\<subseteq> set (cols A\\<^sup>H) \\<and>\n    (\\<nexists>A a v.\n        finite A \\<and>\n        A \\<subseteq> {} \\<and>\n        a \\<in> A \\<rightarrow> carrier class_ring \\<and>\n        module.lincomb (module_vec TYPE('a) nc) a A =\n        \\<zero>\\<^bsub>module_vec TYPE('a) nc\\<^esub> \\<and>\n        v \\<in> A \\<and> a v \\<noteq> \\<zero>\\<^bsub>class_ring\\<^esub>)", "by (auto simp add: vec_module)"], ["proof (state)\nthis:\n  {} \\<subseteq> set (cols A\\<^sup>H) \\<and>\n  \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) {}\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "from maximal_exists[OF *]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>Aa.\n              ?P Aa \\<Longrightarrow>\n              Aa \\<subseteq> set (cols A\\<^sup>H) \\<and>\n              \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) Aa;\n   ?P ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A. finite A \\<and> maximal A ?P", "obtain S where S: \"maximal S ?P\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>Aa.\n              ?P Aa \\<Longrightarrow>\n              Aa \\<subseteq> set (cols A\\<^sup>H) \\<and>\n              \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) Aa;\n   ?P ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A. finite A \\<and> maximal A ?P\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        maximal S\n         (\\<lambda>T.\n             T \\<subseteq> set (cols A\\<^sup>H) \\<and>\n             \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                     T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using **"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>Aa.\n              ?P Aa \\<Longrightarrow>\n              Aa \\<subseteq> set (cols A\\<^sup>H) \\<and>\n              \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) Aa;\n   ?P ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A. finite A \\<and> maximal A ?P\n  {} \\<subseteq> set (cols A\\<^sup>H) \\<and>\n  \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) {}\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        maximal S\n         (\\<lambda>T.\n             T \\<subseteq> set (cols A\\<^sup>H) \\<and>\n             \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                     T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  maximal S\n   (\\<lambda>T.\n       T \\<subseteq> set (cols A\\<^sup>H) \\<and>\n       \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) T)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "(* Some properties of S *)"], ["proof (state)\nthis:\n  maximal S\n   (\\<lambda>T.\n       T \\<subseteq> set (cols A\\<^sup>H) \\<and>\n       \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) T)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "from vec_space.rank_card_indpt[OF 1 S]"], ["proof (chain)\npicking this:\n  vec_space.rank nc A\\<^sup>H = card S", "have rankeq: \"vec_space.rank nc A\\<^sup>H = card S\""], ["proof (prove)\nusing this:\n  vec_space.rank nc A\\<^sup>H = card S\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H = card S", "."], ["proof (state)\nthis:\n  vec_space.rank nc A\\<^sup>H = card S\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have s_hyp: \"S \\<subseteq> set (cols A\\<^sup>H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> set (cols A\\<^sup>H)", "using S"], ["proof (prove)\nusing this:\n  maximal S\n   (\\<lambda>T.\n       T \\<subseteq> set (cols A\\<^sup>H) \\<and>\n       \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) T)\n\ngoal (1 subgoal):\n 1. S \\<subseteq> set (cols A\\<^sup>H)", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  (S \\<subseteq> set (cols A\\<^sup>H) \\<and>\n   \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) S) \\<and>\n  (\\<forall>B.\n      S \\<subseteq> B \\<and>\n      B \\<subseteq> set (cols A\\<^sup>H) \\<and>\n      \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n              B \\<longrightarrow>\n      B = S)\n\ngoal (1 subgoal):\n 1. S \\<subseteq> set (cols A\\<^sup>H)", "by simp"], ["proof (state)\nthis:\n  S \\<subseteq> set (cols A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have modhyp: \"module.lin_indpt class_ring (module_vec TYPE('a) nc) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) S", "using S"], ["proof (prove)\nusing this:\n  maximal S\n   (\\<lambda>T.\n       T \\<subseteq> set (cols A\\<^sup>H) \\<and>\n       \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) T)\n\ngoal (1 subgoal):\n 1. \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) S", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  (S \\<subseteq> set (cols A\\<^sup>H) \\<and>\n   \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) S) \\<and>\n  (\\<forall>B.\n      S \\<subseteq> B \\<and>\n      B \\<subseteq> set (cols A\\<^sup>H) \\<and>\n      \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n              B \\<longrightarrow>\n      B = S)\n\ngoal (1 subgoal):\n 1. \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) S", "by simp"], ["proof (state)\nthis:\n  \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) S\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "(* switch to a list representation *)"], ["proof (state)\nthis:\n  \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) S\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "obtain ss where ss: \"set ss = S\" \"distinct ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>set ss = S; distinct ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags) S maximal_def set_obtain_sublist)"], ["proof (state)\nthis:\n  set ss = S\n  distinct ss\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have ss2: \"set (map ((*\\<^sub>v) A) ss) = (*\\<^sub>v) A ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map ((*\\<^sub>v) A) ss) = (*\\<^sub>v) A ` S", "by (simp add: ss(1))"], ["proof (state)\nthis:\n  set (map ((*\\<^sub>v) A) ss) = (*\\<^sub>v) A ` S\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have rw_hyp: \"cols (mat_of_cols n (map ((*\\<^sub>v) A) ss)) = cols  (A * mat_of_cols nc ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols (mat_of_cols n (map ((*\\<^sub>v) A) ss)) =\n    cols (A * mat_of_cols nc ss)", "unfolding cols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (col (mat_of_cols n (map ((*\\<^sub>v) A) ss)))\n     [0..<dim_col (mat_of_cols n (map ((*\\<^sub>v) A) ss))] =\n    map (col (A * mat_of_cols nc ss)) [0..<dim_col (A * mat_of_cols nc ss)]", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length ss \\<Longrightarrow>\n       col (mat_of_cols n (map ((*\\<^sub>v) A) ss)) x =\n       col (A * mat_of_cols nc ss) x", "using mat_vec_as_mat_mat_mult[of A n nc]"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<in> carrier_mat n nc; ?v \\<in> carrier_vec nc\\<rbrakk>\n  \\<Longrightarrow> A *\\<^sub>v ?v = col (A * mat_of_cols nc [?v]) 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < length ss \\<Longrightarrow>\n       col (mat_of_cols n (map ((*\\<^sub>v) A) ss)) x =\n       col (A * mat_of_cols nc ss) x", "by (metis (no_types, lifting) \"1\" assms carrier_matD(1) cols_dim mul_mat_of_cols nth_mem s_hyp ss(1) subset_code(1))"], ["proof (state)\nthis:\n  cols (mat_of_cols n (map ((*\\<^sub>v) A) ss)) =\n  cols (A * mat_of_cols nc ss)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "then"], ["proof (chain)\npicking this:\n  cols (mat_of_cols n (map ((*\\<^sub>v) A) ss)) =\n  cols (A * mat_of_cols nc ss)", "have rw: \"mat_of_cols n (map ((*\\<^sub>v) A) ss) = A * mat_of_cols nc ss\""], ["proof (prove)\nusing this:\n  cols (mat_of_cols n (map ((*\\<^sub>v) A) ss)) =\n  cols (A * mat_of_cols nc ss)\n\ngoal (1 subgoal):\n 1. mat_of_cols n (map ((*\\<^sub>v) A) ss) = A * mat_of_cols nc ss", "by (metis assms carrier_matD(1) index_mult_mat(2) mat_of_cols_carrier(2) mat_of_cols_cols)"], ["proof (state)\nthis:\n  mat_of_cols n (map ((*\\<^sub>v) A) ss) = A * mat_of_cols nc ss\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have indpt: \"\\<And>c. lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n \\<Longrightarrow>\n      \\<forall>i. (i < (length ss) \\<longrightarrow> c i = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       lincomb_list c (map ((*\\<^sub>v) A) ss) =\n       0\\<^sub>v n \\<Longrightarrow>\n       \\<forall>i<length ss. c i = (0::'a)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "fix c i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "assume *: \"lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n\""], ["proof (state)\nthis:\n  lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "assume i: \"i < length ss\""], ["proof (state)\nthis:\n  i < length ss\n\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "have \"\\<forall>w\\<in>set (map ((*\\<^sub>v) A) ss). dim_vec w = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (map ((*\\<^sub>v) A) ss). dim_vec w = n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (map ((*\\<^sub>v) A) ss). dim_vec w = n", "by auto"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set (map ((*\\<^sub>v) A) ss). dim_vec w = n\n\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "from lincomb_list_as_mat_mult[OF this]"], ["proof (chain)\npicking this:\n  lincomb_list ?c (map ((*\\<^sub>v) A) ss) =\n  mat_of_cols n (map ((*\\<^sub>v) A) ss) *\\<^sub>v\n  vec (length (map ((*\\<^sub>v) A) ss)) ?c", "have \"A * mat_of_cols nc ss *\\<^sub>v  vec (length ss) c = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  lincomb_list ?c (map ((*\\<^sub>v) A) ss) =\n  mat_of_cols n (map ((*\\<^sub>v) A) ss) *\\<^sub>v\n  vec (length (map ((*\\<^sub>v) A) ss)) ?c\n\ngoal (1 subgoal):\n 1. A * mat_of_cols nc ss *\\<^sub>v vec (length ss) c = 0\\<^sub>v n", "using * rw"], ["proof (prove)\nusing this:\n  lincomb_list ?c (map ((*\\<^sub>v) A) ss) =\n  mat_of_cols n (map ((*\\<^sub>v) A) ss) *\\<^sub>v\n  vec (length (map ((*\\<^sub>v) A) ss)) ?c\n  lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n\n  mat_of_cols n (map ((*\\<^sub>v) A) ss) = A * mat_of_cols nc ss\n\ngoal (1 subgoal):\n 1. A * mat_of_cols nc ss *\\<^sub>v vec (length ss) c = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  A * mat_of_cols nc ss *\\<^sub>v vec (length ss) c = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "then"], ["proof (chain)\npicking this:\n  A * mat_of_cols nc ss *\\<^sub>v vec (length ss) c = 0\\<^sub>v n", "have hq: \"A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =  0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  A * mat_of_cols nc ss *\\<^sub>v vec (length ss) c = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n", "by (metis assms assoc_mult_mat_vec mat_of_cols_carrier(1) vec_carrier)"], ["proof (state)\nthis:\n  A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "then"], ["proof (chain)\npicking this:\n  A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) = 0\\<^sub>v n", "have eq1: \"(mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =  0\\<^sub>v nc\""], ["proof (prove)\nusing this:\n  A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v vec (length ss) c = 0\\<^sub>v nc", "apply (intro mat_mul_conjugate_transpose_sub_vec_eq_0)"], ["proof (prove)\ngoal (5 subgoals):\n 1. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n \\<Longrightarrow>\n    ?A1 \\<in> carrier_mat ?nr1 nc\n 2. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n \\<Longrightarrow>\n    distinct ss\n 3. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n \\<Longrightarrow>\n    set ss \\<subseteq> set (cols ?A1\\<^sup>H)\n 4. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n \\<Longrightarrow>\n    vec (length ss) c \\<in> carrier_vec (length ss)\n 5. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n \\<Longrightarrow>\n    ?A1 *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v ?nr1", "using assms ss s_hyp"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n nc\n  set ss = S\n  distinct ss\n  S \\<subseteq> set (cols A\\<^sup>H)\n\ngoal (5 subgoals):\n 1. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n \\<Longrightarrow>\n    ?A1 \\<in> carrier_mat ?nr1 nc\n 2. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n \\<Longrightarrow>\n    distinct ss\n 3. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n \\<Longrightarrow>\n    set ss \\<subseteq> set (cols ?A1\\<^sup>H)\n 4. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n \\<Longrightarrow>\n    vec (length ss) c \\<in> carrier_vec (length ss)\n 5. A *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v n \\<Longrightarrow>\n    ?A1 *\\<^sub>v (mat_of_cols nc ss *\\<^sub>v vec (length ss) c) =\n    0\\<^sub>v ?nr1", "by auto"], ["proof (state)\nthis:\n  mat_of_cols nc ss *\\<^sub>v vec (length ss) c = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "(* Rewrite the inner vector back to a lincomb_list *)"], ["proof (state)\nthis:\n  mat_of_cols nc ss *\\<^sub>v vec (length ss) c = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "have dim_hyp2: \"\\<forall>w\\<in>set ss. dim_vec w = nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set ss. dim_vec w = nc", "using ss(1) s_hyp"], ["proof (prove)\nusing this:\n  set ss = S\n  S \\<subseteq> set (cols A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set ss. dim_vec w = nc", "by (metis \"1\" carrier_matD(1) carrier_vecD cols_dim subsetD)"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set ss. dim_vec w = nc\n\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "from vec_module.lincomb_list_as_mat_mult[OF this, symmetric]"], ["proof (chain)\npicking this:\n  mat_of_cols nc ss *\\<^sub>v vec (length ss) ?c =\n  module.lincomb_list (module_vec TYPE('a) nc) ?c ss", "have \"mat_of_cols nc ss *\\<^sub>v vec (length ss) c = module.lincomb_list (module_vec TYPE('a) nc) c ss\""], ["proof (prove)\nusing this:\n  mat_of_cols nc ss *\\<^sub>v vec (length ss) ?c =\n  module.lincomb_list (module_vec TYPE('a) nc) ?c ss\n\ngoal (1 subgoal):\n 1. mat_of_cols nc ss *\\<^sub>v vec (length ss) c =\n    module.lincomb_list (module_vec TYPE('a) nc) c ss", "."], ["proof (state)\nthis:\n  mat_of_cols nc ss *\\<^sub>v vec (length ss) c =\n  module.lincomb_list (module_vec TYPE('a) nc) c ss\n\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "then"], ["proof (chain)\npicking this:\n  mat_of_cols nc ss *\\<^sub>v vec (length ss) c =\n  module.lincomb_list (module_vec TYPE('a) nc) c ss", "have \"module.lincomb_list (module_vec TYPE('a) nc) c ss = 0\\<^sub>v nc\""], ["proof (prove)\nusing this:\n  mat_of_cols nc ss *\\<^sub>v vec (length ss) c =\n  module.lincomb_list (module_vec TYPE('a) nc) c ss\n\ngoal (1 subgoal):\n 1. module.lincomb_list (module_vec TYPE('a) nc) c ss = 0\\<^sub>v nc", "using eq1"], ["proof (prove)\nusing this:\n  mat_of_cols nc ss *\\<^sub>v vec (length ss) c =\n  module.lincomb_list (module_vec TYPE('a) nc) c ss\n  mat_of_cols nc ss *\\<^sub>v vec (length ss) c = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. module.lincomb_list (module_vec TYPE('a) nc) c ss = 0\\<^sub>v nc", "by auto"], ["proof (state)\nthis:\n  module.lincomb_list (module_vec TYPE('a) nc) c ss = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. \\<And>c i.\n       \\<lbrakk>lincomb_list c (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n;\n        i < length ss\\<rbrakk>\n       \\<Longrightarrow> c i = (0::'a)", "from vec_space.lin_indpt_lin_comb_list[OF ss(2) _ _ this i]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                   (set ss);\n   set ss \\<subseteq> carrier_vec nc\\<rbrakk>\n  \\<Longrightarrow> c i = (0::'a)", "show \"c i = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                   (set ss);\n   set ss \\<subseteq> carrier_vec nc\\<rbrakk>\n  \\<Longrightarrow> c i = (0::'a)\n\ngoal (1 subgoal):\n 1. c i = (0::'a)", "using modhyp ss s_hyp"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                   (set ss);\n   set ss \\<subseteq> carrier_vec nc\\<rbrakk>\n  \\<Longrightarrow> c i = (0::'a)\n  \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) S\n  set ss = S\n  distinct ss\n  S \\<subseteq> set (cols A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. c i = (0::'a)", "using \"1\" cols_dim"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> module.lin_dep class_ring (module_vec TYPE('a) nc)\n                   (set ss);\n   set ss \\<subseteq> carrier_vec nc\\<rbrakk>\n  \\<Longrightarrow> c i = (0::'a)\n  \\<not> module.lin_dep class_ring (module_vec TYPE('a) nc) S\n  set ss = S\n  distinct ss\n  S \\<subseteq> set (cols A\\<^sup>H)\n  A\\<^sup>H \\<in> carrier_mat nc n\n  set (cols ?A) \\<subseteq> carrier_vec (dim_row ?A)\n\ngoal (1 subgoal):\n 1. c i = (0::'a)", "by blast"], ["proof (state)\nthis:\n  c i = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lincomb_list ?c1 (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n \\<Longrightarrow>\n  \\<forall>i<length ss. ?c1 i = (0::'a)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have distinct: \"distinct (map ((*\\<^sub>v) A) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map ((*\\<^sub>v) A) ss)", "by (metis (no_types, lifting) assms carrier_matD(1) dim_mult_mat_vec imageE indpt length_map lincomb_list_indpt_distinct ss2)"], ["proof (state)\nthis:\n  distinct (map ((*\\<^sub>v) A) ss)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "then"], ["proof (chain)\npicking this:\n  distinct (map ((*\\<^sub>v) A) ss)", "have 3: \"card S = card ((*\\<^sub>v) A ` S)\""], ["proof (prove)\nusing this:\n  distinct (map ((*\\<^sub>v) A) ss)\n\ngoal (1 subgoal):\n 1. card S = card ((*\\<^sub>v) A ` S)", "by (metis ss distinct_card image_set length_map)"], ["proof (state)\nthis:\n  card S = card ((*\\<^sub>v) A ` S)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "then"], ["proof (chain)\npicking this:\n  card S = card ((*\\<^sub>v) A ` S)", "have 4: \"(*\\<^sub>v) A ` S \\<subseteq> set (cols (A * A\\<^sup>H))\""], ["proof (prove)\nusing this:\n  card S = card ((*\\<^sub>v) A ` S)\n\ngoal (1 subgoal):\n 1. (*\\<^sub>v) A ` S \\<subseteq> set (cols (A * A\\<^sup>H))", "using cols_mat_mul \\<open>S \\<subseteq> set (cols A\\<^sup>H)\\<close>"], ["proof (prove)\nusing this:\n  card S = card ((*\\<^sub>v) A ` S)\n  set (cols (?A * ?B)) = (*\\<^sub>v) ?A ` set (cols ?B)\n  S \\<subseteq> set (cols A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. (*\\<^sub>v) A ` S \\<subseteq> set (cols (A * A\\<^sup>H))", "by blast"], ["proof (state)\nthis:\n  (*\\<^sub>v) A ` S \\<subseteq> set (cols (A * A\\<^sup>H))\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "have 5: \"lin_indpt ((*\\<^sub>v) A ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt ((*\\<^sub>v) A ` S)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. lin_dep ((*\\<^sub>v) A ` S) \\<Longrightarrow> False", "assume ld:\"lin_dep ((*\\<^sub>v) A ` S)\""], ["proof (state)\nthis:\n  lin_dep ((*\\<^sub>v) A ` S)\n\ngoal (1 subgoal):\n 1. lin_dep ((*\\<^sub>v) A ` S) \\<Longrightarrow> False", "have *: \"finite ((*\\<^sub>v) A ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((*\\<^sub>v) A ` S)", "by (metis List.finite_set ss2)"], ["proof (state)\nthis:\n  finite ((*\\<^sub>v) A ` S)\n\ngoal (1 subgoal):\n 1. lin_dep ((*\\<^sub>v) A ` S) \\<Longrightarrow> False", "have **: \"(*\\<^sub>v) A ` S \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>v) A ` S \\<subseteq> carrier_vec n", "using \"2\" \"4\" cols_dim"], ["proof (prove)\nusing this:\n  A * A\\<^sup>H \\<in> carrier_mat n n\n  (*\\<^sub>v) A ` S \\<subseteq> set (cols (A * A\\<^sup>H))\n  set (cols ?A) \\<subseteq> carrier_vec (dim_row ?A)\n\ngoal (1 subgoal):\n 1. (*\\<^sub>v) A ` S \\<subseteq> carrier_vec n", "by blast"], ["proof (state)\nthis:\n  (*\\<^sub>v) A ` S \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lin_dep ((*\\<^sub>v) A ` S) \\<Longrightarrow> False", "from finite_lin_dep[OF * ld **]"], ["proof (chain)\npicking this:\n  \\<exists>a v.\n     True \\<and>\n     lincomb a ((*\\<^sub>v) A ` S) = 0\\<^sub>v n \\<and>\n     v \\<in> (*\\<^sub>v) A ` S \\<and> a v \\<noteq> (0::'a)", "obtain a v where\n      a: \"lincomb a ((*\\<^sub>v) A ` S) = 0\\<^sub>v n\" and\n      v: \"v \\<in> (*\\<^sub>v) A ` S\" \"a v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>a v.\n     True \\<and>\n     lincomb a ((*\\<^sub>v) A ` S) = 0\\<^sub>v n \\<and>\n     v \\<in> (*\\<^sub>v) A ` S \\<and> a v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>a v.\n        \\<lbrakk>lincomb a ((*\\<^sub>v) A ` S) = 0\\<^sub>v n;\n         v \\<in> (*\\<^sub>v) A ` S; a v \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lincomb a ((*\\<^sub>v) A ` S) = 0\\<^sub>v n\n  v \\<in> (*\\<^sub>v) A ` S\n  a v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lin_dep ((*\\<^sub>v) A ` S) \\<Longrightarrow> False", "obtain i where i:\"v = map ((*\\<^sub>v) A) ss ! i\" \"i < length ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>v = map ((*\\<^sub>v) A) ss ! i; i < length ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using v"], ["proof (prove)\nusing this:\n  v \\<in> (*\\<^sub>v) A ` S\n  a v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>v = map ((*\\<^sub>v) A) ss ! i; i < length ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ss2[symmetric]"], ["proof (prove)\nusing this:\n  v \\<in> set (map ((*\\<^sub>v) A) ss)\n  a v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>v = map ((*\\<^sub>v) A) ss ! i; i < length ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using find_first_le nth_find_first"], ["proof (prove)\nusing this:\n  v \\<in> set (map ((*\\<^sub>v) A) ss)\n  a v \\<noteq> (0::'a)\n  ?a \\<in> set ?xs \\<Longrightarrow> find_first ?a ?xs < length ?xs\n  ?a \\<in> set ?xs \\<Longrightarrow> ?xs ! find_first ?a ?xs = ?a\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>v = map ((*\\<^sub>v) A) ss ! i; i < length ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  v = map ((*\\<^sub>v) A) ss ! i\n  i < length ss\n\ngoal (1 subgoal):\n 1. lin_dep ((*\\<^sub>v) A ` S) \\<Longrightarrow> False", "from ss2[symmetric]"], ["proof (chain)\npicking this:\n  (*\\<^sub>v) A ` S = set (map ((*\\<^sub>v) A) ss)", "have \"set (map ((*\\<^sub>v) A) ss)\\<subseteq> carrier_vec n\""], ["proof (prove)\nusing this:\n  (*\\<^sub>v) A ` S = set (map ((*\\<^sub>v) A) ss)\n\ngoal (1 subgoal):\n 1. set (map ((*\\<^sub>v) A) ss) \\<subseteq> carrier_vec n", "using ** ss2"], ["proof (prove)\nusing this:\n  (*\\<^sub>v) A ` S = set (map ((*\\<^sub>v) A) ss)\n  (*\\<^sub>v) A ` S \\<subseteq> carrier_vec n\n  set (map ((*\\<^sub>v) A) ss) = (*\\<^sub>v) A ` S\n\ngoal (1 subgoal):\n 1. set (map ((*\\<^sub>v) A) ss) \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set (map ((*\\<^sub>v) A) ss) \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. lin_dep ((*\\<^sub>v) A ` S) \\<Longrightarrow> False", "from lincomb_as_lincomb_list_distinct[OF this distinct]"], ["proof (chain)\npicking this:\n  lincomb ?f (set (map ((*\\<^sub>v) A) ss)) =\n  lincomb_list (\\<lambda>i. ?f (map ((*\\<^sub>v) A) ss ! i))\n   (map ((*\\<^sub>v) A) ss)", "have\n      \"lincomb_list\n     (\\<lambda>i. a (map ((*\\<^sub>v) A) ss ! i))  (map ((*\\<^sub>v) A) ss) = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  lincomb ?f (set (map ((*\\<^sub>v) A) ss)) =\n  lincomb_list (\\<lambda>i. ?f (map ((*\\<^sub>v) A) ss ! i))\n   (map ((*\\<^sub>v) A) ss)\n\ngoal (1 subgoal):\n 1. lincomb_list (\\<lambda>i. a (map ((*\\<^sub>v) A) ss ! i))\n     (map ((*\\<^sub>v) A) ss) =\n    0\\<^sub>v n", "using a ss2"], ["proof (prove)\nusing this:\n  lincomb ?f (set (map ((*\\<^sub>v) A) ss)) =\n  lincomb_list (\\<lambda>i. ?f (map ((*\\<^sub>v) A) ss ! i))\n   (map ((*\\<^sub>v) A) ss)\n  lincomb a ((*\\<^sub>v) A ` S) = 0\\<^sub>v n\n  set (map ((*\\<^sub>v) A) ss) = (*\\<^sub>v) A ` S\n\ngoal (1 subgoal):\n 1. lincomb_list (\\<lambda>i. a (map ((*\\<^sub>v) A) ss ! i))\n     (map ((*\\<^sub>v) A) ss) =\n    0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  lincomb_list (\\<lambda>i. a (map ((*\\<^sub>v) A) ss ! i))\n   (map ((*\\<^sub>v) A) ss) =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lin_dep ((*\\<^sub>v) A ` S) \\<Longrightarrow> False", "from indpt[OF this]"], ["proof (chain)\npicking this:\n  \\<forall>i<length ss. a (map ((*\\<^sub>v) A) ss ! i) = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  \\<forall>i<length ss. a (map ((*\\<^sub>v) A) ss ! i) = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using v i"], ["proof (prove)\nusing this:\n  \\<forall>i<length ss. a (map ((*\\<^sub>v) A) ss ! i) = (0::'a)\n  v \\<in> (*\\<^sub>v) A ` S\n  a v \\<noteq> (0::'a)\n  v = map ((*\\<^sub>v) A) ss ! i\n  i < length ss\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lin_indpt ((*\\<^sub>v) A ` S)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "from rank_ge_card_indpt[OF 2 4 5]"], ["proof (chain)\npicking this:\n  card ((*\\<^sub>v) A ` S) \\<le> rank (A * A\\<^sup>H)", "have \"card ((*\\<^sub>v) A ` S) \\<le> rank (A * A\\<^sup>H)\""], ["proof (prove)\nusing this:\n  card ((*\\<^sub>v) A ` S) \\<le> rank (A * A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. card ((*\\<^sub>v) A ` S) \\<le> rank (A * A\\<^sup>H)", "."], ["proof (state)\nthis:\n  card ((*\\<^sub>v) A ` S) \\<le> rank (A * A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "thus ?thesis"], ["proof (prove)\nusing this:\n  card ((*\\<^sub>v) A ` S) \\<le> rank (A * A\\<^sup>H)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "using rankeq 3"], ["proof (prove)\nusing this:\n  card ((*\\<^sub>v) A ` S) \\<le> rank (A * A\\<^sup>H)\n  vec_space.rank nc A\\<^sup>H = card S\n  card S = card ((*\\<^sub>v) A ` S)\n\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)", "by linarith"], ["proof (state)\nthis:\n  vec_space.rank nc A\\<^sup>H \\<le> rank (A * A\\<^sup>H)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conjugate_transpose_rank_le:\n  assumes \"A \\<in> carrier_mat n nc\"\n  shows \"vec_space.rank nc (A\\<^sup>H) \\<le> rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank nc A\\<^sup>H \\<le> rank A", "by (metis assms carrier_matD(2) carrier_mat_triv dim_row_conjugate dual_order.trans index_transpose_mat(2) rank_mat_mul_right transpose_rank_mul_conjugate_transpose)"], ["", "lemma conjugate_finsum:\n  assumes f: \"f : U \\<rightarrow> carrier_vec n\"\n  shows \"conjugate (finsum V f U) = finsum V (conjugate \\<circ> f) U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (finsum V f U) = finsum V (conjugate \\<circ> f) U", "using f"], ["proof (prove)\nusing this:\n  f \\<in> U \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate (finsum V f U) = finsum V (conjugate \\<circ> f) U", "proof (induct U rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f A) =\n                         finsum V (conjugate \\<circ> f) A\n 2. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    conjugate (finsum V f {}) = finsum V (conjugate \\<circ> f) {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        conjugate (finsum V f F) = finsum V (conjugate \\<circ> f) F;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f (insert x F)) =\n                         finsum V (conjugate \\<circ> f) (insert x F)", "case (infinite A)"], ["proof (state)\nthis:\n  infinite A\n  f \\<in> A \\<rightarrow> carrier_vec n\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A; f \\<in> A \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f A) =\n                         finsum V (conjugate \\<circ> f) A\n 2. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    conjugate (finsum V f {}) = finsum V (conjugate \\<circ> f) {}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        conjugate (finsum V f F) = finsum V (conjugate \\<circ> f) F;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f (insert x F)) =\n                         finsum V (conjugate \\<circ> f) (insert x F)", "then"], ["proof (chain)\npicking this:\n  infinite A\n  f \\<in> A \\<rightarrow> carrier_vec n", "show ?case"], ["proof (prove)\nusing this:\n  infinite A\n  f \\<in> A \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate (finsum V f A) = finsum V (conjugate \\<circ> f) A", "by auto"], ["proof (state)\nthis:\n  conjugate (finsum V f A) = finsum V (conjugate \\<circ> f) A\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    conjugate (finsum V f {}) = finsum V (conjugate \\<circ> f) {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        conjugate (finsum V f F) = finsum V (conjugate \\<circ> f) F;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f (insert x F)) =\n                         finsum V (conjugate \\<circ> f) (insert x F)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    conjugate (finsum V f {}) = finsum V (conjugate \\<circ> f) {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        conjugate (finsum V f F) = finsum V (conjugate \\<circ> f) F;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f (insert x F)) =\n                         finsum V (conjugate \\<circ> f) (insert x F)", "case empty"], ["proof (state)\nthis:\n  f \\<in> {} \\<rightarrow> carrier_vec n\n\ngoal (2 subgoals):\n 1. f \\<in> {} \\<rightarrow> carrier_vec n \\<Longrightarrow>\n    conjugate (finsum V f {}) = finsum V (conjugate \\<circ> f) {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        conjugate (finsum V f F) = finsum V (conjugate \\<circ> f) F;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f (insert x F)) =\n                         finsum V (conjugate \\<circ> f) (insert x F)", "then"], ["proof (chain)\npicking this:\n  f \\<in> {} \\<rightarrow> carrier_vec n", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> {} \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate (finsum V f {}) = finsum V (conjugate \\<circ> f) {}", "by auto"], ["proof (state)\nthis:\n  conjugate (finsum V f {}) = finsum V (conjugate \\<circ> f) {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        conjugate (finsum V f F) = finsum V (conjugate \\<circ> f) F;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f (insert x F)) =\n                         finsum V (conjugate \\<circ> f) (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        conjugate (finsum V f F) = finsum V (conjugate \\<circ> f) F;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f (insert x F)) =\n                         finsum V (conjugate \\<circ> f) (insert x F)", "case (insert u U)"], ["proof (state)\nthis:\n  finite U\n  u \\<notin> U\n  f \\<in> U \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  conjugate (finsum V f U) = finsum V (conjugate \\<circ> f) U\n  f \\<in> insert u U \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        conjugate (finsum V f F) = finsum V (conjugate \\<circ> f) F;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f (insert x F)) =\n                         finsum V (conjugate \\<circ> f) (insert x F)", "hence f: \"f : U \\<rightarrow> carrier_vec n\" \"f u : carrier_vec n\""], ["proof (prove)\nusing this:\n  finite U\n  u \\<notin> U\n  f \\<in> U \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  conjugate (finsum V f U) = finsum V (conjugate \\<circ> f) U\n  f \\<in> insert u U \\<rightarrow> carrier_vec n\n\ngoal (1 subgoal):\n 1. f \\<in> U \\<rightarrow> carrier_vec n &&& f u \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  f \\<in> U \\<rightarrow> carrier_vec n\n  f u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        conjugate (finsum V f F) = finsum V (conjugate \\<circ> f) F;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f (insert x F)) =\n                         finsum V (conjugate \\<circ> f) (insert x F)", "then"], ["proof (chain)\npicking this:\n  f \\<in> U \\<rightarrow> carrier_vec n\n  f u \\<in> carrier_vec n", "have cf: \"conjugate \\<circ> f : U \\<rightarrow> carrier_vec n\"\n    \"(conjugate \\<circ> f) u : carrier_vec n\""], ["proof (prove)\nusing this:\n  f \\<in> U \\<rightarrow> carrier_vec n\n  f u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n &&&\n    (conjugate \\<circ> f) u \\<in> carrier_vec n", "apply (simp add: Pi_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (conjugate \\<circ> f) u \\<in> carrier_vec n", "by (simp add: f(2))"], ["proof (state)\nthis:\n  conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n\n  (conjugate \\<circ> f) u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        f \\<in> F \\<rightarrow> carrier_vec n \\<Longrightarrow>\n        conjugate (finsum V f F) = finsum V (conjugate \\<circ> f) F;\n        f \\<in> insert x F \\<rightarrow> carrier_vec n\\<rbrakk>\n       \\<Longrightarrow> conjugate (finsum V f (insert x F)) =\n                         finsum V (conjugate \\<circ> f) (insert x F)", "then"], ["proof (chain)\npicking this:\n  conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n\n  (conjugate \\<circ> f) u \\<in> carrier_vec n", "show ?case"], ["proof (prove)\nusing this:\n  conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n\n  (conjugate \\<circ> f) u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate (finsum V f (insert u U)) =\n    finsum V (conjugate \\<circ> f) (insert u U)", "unfolding finsum_insert[OF insert(1) insert(2) f]"], ["proof (prove)\nusing this:\n  conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n\n  (conjugate \\<circ> f) u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate (f u + finsum V f U) =\n    finsum V (conjugate \\<circ> f) (insert u U)", "unfolding finsum_insert[OF insert(1) insert(2) cf ]"], ["proof (prove)\nusing this:\n  conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n\n  (conjugate \\<circ> f) u \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. conjugate (f u + finsum V f U) =\n    (conjugate \\<circ> f) u + finsum V (conjugate \\<circ> f) U", "apply (subst conjugate_add_vec[of _ n])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> f u \\<in> carrier_vec n\n 2. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> finsum V f U \\<in> carrier_vec n\n 3. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> conjugate (f u) + conjugate (finsum V f U) =\n                      (conjugate \\<circ> f) u +\n                      finsum V (conjugate \\<circ> f) U", "using f(2)"], ["proof (prove)\nusing this:\n  f u \\<in> carrier_vec n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> f u \\<in> carrier_vec n\n 2. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> finsum V f U \\<in> carrier_vec n\n 3. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> conjugate (f u) + conjugate (finsum V f U) =\n                      (conjugate \\<circ> f) u +\n                      finsum V (conjugate \\<circ> f) U", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> finsum V f U \\<in> carrier_vec n\n 2. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> conjugate (f u) + conjugate (finsum V f U) =\n                      (conjugate \\<circ> f) u +\n                      finsum V (conjugate \\<circ> f) U", "using M.finsum_closed f(1)"], ["proof (prove)\nusing this:\n  ?f \\<in> ?A \\<rightarrow> carrier_vec n \\<Longrightarrow>\n  finsum V ?f ?A \\<in> carrier_vec n\n  f \\<in> U \\<rightarrow> carrier_vec n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> finsum V f U \\<in> carrier_vec n\n 2. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> conjugate (f u) + conjugate (finsum V f U) =\n                      (conjugate \\<circ> f) u +\n                      finsum V (conjugate \\<circ> f) U", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>conjugate \\<circ> f \\<in> U \\<rightarrow> carrier_vec n;\n     (conjugate \\<circ> f) u \\<in> carrier_vec n\\<rbrakk>\n    \\<Longrightarrow> conjugate (f u) + conjugate (finsum V f U) =\n                      (conjugate \\<circ> f) u +\n                      finsum V (conjugate \\<circ> f) U", "by (simp add: comp_def f(1) insert.hyps(3))"], ["proof (state)\nthis:\n  conjugate (finsum V f (insert u U)) =\n  finsum V (conjugate \\<circ> f) (insert u U)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_conjugate_le:\n  assumes A:\"A \\<in> carrier_mat n d\"\n  shows \"rank (conjugate (A)) \\<le> rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "(* S is a maximal linearly independent set of (conjugate A) *)"], ["proof (state)\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "let ?P = \"(\\<lambda>T. T \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt T)\""], ["proof (state)\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "have *:\"\\<And>A. ?P A \\<Longrightarrow> finite A \\<and> card A \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       Aa \\<subseteq> set (cols (conjugate A)) \\<and>\n       lin_indpt Aa \\<Longrightarrow>\n       finite Aa \\<and> card Aa \\<le> d", "by (metis List.finite_set assms card_length card_mono carrier_matD(2) cols_length dim_col_conjugate dual_order.trans rev_finite_subset)"], ["proof (state)\nthis:\n  ?A1 \\<subseteq> set (cols (conjugate A)) \\<and>\n  lin_indpt ?A1 \\<Longrightarrow>\n  finite ?A1 \\<and> card ?A1 \\<le> d\n\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "have **:\"?P {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt {}", "by (simp add: finite_lin_indpt2)"], ["proof (state)\nthis:\n  {} \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt {}\n\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "from maximal_exists[OF *]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>Aa.\n              ?P Aa \\<Longrightarrow>\n              Aa \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt Aa;\n   ?P ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A. finite A \\<and> maximal A ?P", "obtain S where S: \"maximal S ?P\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>Aa.\n              ?P Aa \\<Longrightarrow>\n              Aa \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt Aa;\n   ?P ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A. finite A \\<and> maximal A ?P\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        maximal S\n         (\\<lambda>T.\n             T \\<subseteq> set (cols (conjugate A)) \\<and>\n             lin_indpt T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using **"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>Aa.\n              ?P Aa \\<Longrightarrow>\n              Aa \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt Aa;\n   ?P ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A. finite A \\<and> maximal A ?P\n  {} \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt {}\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        maximal S\n         (\\<lambda>T.\n             T \\<subseteq> set (cols (conjugate A)) \\<and>\n             lin_indpt T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  maximal S\n   (\\<lambda>T. T \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt T)\n\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "have s_hyp: \"S \\<subseteq> set (cols (conjugate A))\" \"lin_indpt S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> set (cols (conjugate A)) &&& lin_indpt S", "using S"], ["proof (prove)\nusing this:\n  maximal S\n   (\\<lambda>T. T \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt T)\n\ngoal (1 subgoal):\n 1. S \\<subseteq> set (cols (conjugate A)) &&& lin_indpt S", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  (S \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt S) \\<and>\n  (\\<forall>B.\n      S \\<subseteq> B \\<and>\n      B \\<subseteq> set (cols (conjugate A)) \\<and>\n      lin_indpt B \\<longrightarrow>\n      B = S)\n\ngoal (1 subgoal):\n 1. S \\<subseteq> set (cols (conjugate A)) &&& lin_indpt S", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt S", "by (metis (no_types, lifting) S maximal_def)"], ["proof (state)\nthis:\n  S \\<subseteq> set (cols (conjugate A))\n  lin_indpt S\n\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "from rank_card_indpt[OF _ S, of d]"], ["proof (chain)\npicking this:\n  conjugate A \\<in> carrier_mat n d \\<Longrightarrow>\n  rank (conjugate A) = card S", "have rankeq: \"rank (conjugate A) = card S\""], ["proof (prove)\nusing this:\n  conjugate A \\<in> carrier_mat n d \\<Longrightarrow>\n  rank (conjugate A) = card S\n\ngoal (1 subgoal):\n 1. rank (conjugate A) = card S", "using assms"], ["proof (prove)\nusing this:\n  conjugate A \\<in> carrier_mat n d \\<Longrightarrow>\n  rank (conjugate A) = card S\n  A \\<in> carrier_mat n d\n\ngoal (1 subgoal):\n 1. rank (conjugate A) = card S", "by auto"], ["proof (state)\nthis:\n  rank (conjugate A) = card S\n\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "have 1:\"conjugate ` S \\<subseteq> set (cols A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate ` S \\<subseteq> set (cols A)", "using S"], ["proof (prove)\nusing this:\n  maximal S\n   (\\<lambda>T. T \\<subseteq> set (cols (conjugate A)) \\<and> lin_indpt T)\n\ngoal (1 subgoal):\n 1. conjugate ` S \\<subseteq> set (cols A)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>maximal S\n                 (\\<lambda>T.\n                     T \\<subseteq> set (cols (conjugate A)) \\<and>\n                     lin_indpt T);\n        xa \\<in> S\\<rbrakk>\n       \\<Longrightarrow> conjugate xa \\<in> set (cols A)", "by (metis (no_types, lifting) cols_conjugate conjugate_id image_eqI in_mono list.set_map s_hyp(1))"], ["proof (state)\nthis:\n  conjugate ` S \\<subseteq> set (cols A)\n\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "have 2: \"lin_indpt (conjugate ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt (conjugate ` S)", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lin_indpt (conjugate ` S) \\<Longrightarrow> False", "apply (auto simp add: lin_dep_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "fix T c v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "assume T: \"T \\<subseteq> conjugate ` S\" \"finite T\" and\n      lc:\"lincomb c T = 0\\<^sub>v n\" and \"v \\<in> T\"  \"c v \\<noteq> 0\""], ["proof (state)\nthis:\n  T \\<subseteq> conjugate ` S\n  finite T\n  lincomb c T = 0\\<^sub>v n\n  v \\<in> T\n  c v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "let ?T = \"conjugate ` T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "let ?c = \"conjugate \\<circ> c \\<circ> conjugate\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "have 1: \"finite ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (conjugate ` T)", "using T"], ["proof (prove)\nusing this:\n  T \\<subseteq> conjugate ` S\n  finite T\n\ngoal (1 subgoal):\n 1. finite (conjugate ` T)", "by auto"], ["proof (state)\nthis:\n  finite (conjugate ` T)\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "have 2: \"?T \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate ` T \\<subseteq> S", "using T"], ["proof (prove)\nusing this:\n  T \\<subseteq> conjugate ` S\n  finite T\n\ngoal (1 subgoal):\n 1. conjugate ` T \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  conjugate ` T \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "have 3: \"?c \\<in> ?T \\<rightarrow> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate \\<circ> c \\<circ> conjugate\n    \\<in> conjugate ` T \\<rightarrow> UNIV", "by auto"], ["proof (state)\nthis:\n  conjugate \\<circ> c \\<circ> conjugate\n  \\<in> conjugate ` T \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"lincomb ?c ?T = (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x) \\<cdot>\\<^sub>v conjugate x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x) \\<cdot>\\<^sub>v\n conjugate x)", "unfolding lincomb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>conjugate `\n                                    T. (conjugate \\<circ> c \\<circ>\n  conjugate)\n  v \\<cdot>\\<^sub>v\n v) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x) \\<cdot>\\<^sub>v\n conjugate x)", "apply (subst finsum_reindex)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>v.\n        (conjugate \\<circ> c \\<circ> conjugate) v \\<cdot>\\<^sub>v v)\n    \\<in> conjugate ` T \\<rightarrow> carrier_vec n\n 2. inj_on conjugate T\n 3. (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. (conjugate \\<circ> c \\<circ>\n  conjugate)\n  (conjugate x) \\<cdot>\\<^sub>v\n conjugate x) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x) \\<cdot>\\<^sub>v\n conjugate x)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> T \\<Longrightarrow> conjugate xa \\<in> carrier_vec n\n 2. inj_on conjugate T", "apply (metis \"2\" carrier_vec_conjugate assms carrier_matD(1) cols_dim image_eqI s_hyp(1) subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on conjugate T", "by (meson conjugate_cancel_iff inj_onI)"], ["proof (state)\nthis:\n  lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x) \\<cdot>\\<^sub>v\n                                     conjugate x)\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x) \\<cdot>\\<^sub>v\n                                     conjugate x)\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"... = (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x \\<cdot>\\<^sub>v x)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x) \\<cdot>\\<^sub>v\n conjugate x) =\n    (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x \\<cdot>\\<^sub>v x))", "by (simp add: conjugate_smult_vec)"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x) \\<cdot>\\<^sub>v\n                                     conjugate x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x \\<cdot>\\<^sub>v x))\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x) \\<cdot>\\<^sub>v\n                                     conjugate x) =\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x \\<cdot>\\<^sub>v x))\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"... = conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. (c x \\<cdot>\\<^sub>v x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x \\<cdot>\\<^sub>v x)) =\n    conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. c x \\<cdot>\\<^sub>v x)", "apply(subst conjugate_finsum[of \"\\<lambda>x.(c x \\<cdot>\\<^sub>v x)\" T])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. c x \\<cdot>\\<^sub>v x) \\<in> T \\<rightarrow> carrier_vec n\n 2. (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x \\<cdot>\\<^sub>v x)) =\n    finsum V (conjugate \\<circ> (\\<lambda>x. c x \\<cdot>\\<^sub>v x)) T", "apply (auto simp add:o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<in> carrier_vec n", "by (smt Matrix.carrier_vec_conjugate Pi_I' T(1) assms carrier_matD(1) cols_dim dim_row_conjugate imageE s_hyp(1) smult_carrier_vec subset_eq)"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x \\<cdot>\\<^sub>v x)) =\n  conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. c x \\<cdot>\\<^sub>v x)\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. conjugate (c x \\<cdot>\\<^sub>v x)) =\n  conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. c x \\<cdot>\\<^sub>v x)\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"... = conjugate (lincomb c T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. c x \\<cdot>\\<^sub>v x) =\n    conjugate (lincomb c T)", "using lincomb_def"], ["proof (prove)\nusing this:\n  lincomb ?a ?A =\n  (\\<Oplus>\\<^bsub>V\\<^esub>v\\<in>?A. ?a v \\<cdot>\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. c x \\<cdot>\\<^sub>v x) =\n    conjugate (lincomb c T)", "by presburger"], ["proof (state)\nthis:\n  conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. c x \\<cdot>\\<^sub>v x) =\n  conjugate (lincomb c T)\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n  conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. c x \\<cdot>\\<^sub>v x)\n  conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. c x \\<cdot>\\<^sub>v x) =\n  conjugate (lincomb c T)", "have \"lincomb ?c ?T = conjugate (lincomb c T)\""], ["proof (prove)\nusing this:\n  lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n  conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. c x \\<cdot>\\<^sub>v x)\n  conjugate (\\<Oplus>\\<^bsub>V\\<^esub>x\\<in>T. c x \\<cdot>\\<^sub>v x) =\n  conjugate (lincomb c T)\n\ngoal (1 subgoal):\n 1. lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n    conjugate (lincomb c T)", "by auto"], ["proof (state)\nthis:\n  lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n  conjugate (lincomb c T)\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n  conjugate (lincomb c T)", "have 4:\"lincomb ?c ?T = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n  conjugate (lincomb c T)\n\ngoal (1 subgoal):\n 1. lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n    0\\<^sub>v n", "using lc"], ["proof (prove)\nusing this:\n  lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n  conjugate (lincomb c T)\n  lincomb c T = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n    0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  lincomb (conjugate \\<circ> c \\<circ> conjugate) (conjugate ` T) =\n  0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "from not_lindepD[OF s_hyp(2) 1 2 3 4]"], ["proof (chain)\npicking this:\n  conjugate \\<circ> c \\<circ> conjugate\n  \\<in> conjugate ` T \\<rightarrow> {0::'a}", "have \"conjugate \\<circ> c \\<circ> conjugate \\<in> conjugate ` T \\<rightarrow> {0}\""], ["proof (prove)\nusing this:\n  conjugate \\<circ> c \\<circ> conjugate\n  \\<in> conjugate ` T \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. conjugate \\<circ> c \\<circ> conjugate\n    \\<in> conjugate ` T \\<rightarrow> {0::'a}", "."], ["proof (state)\nthis:\n  conjugate \\<circ> c \\<circ> conjugate\n  \\<in> conjugate ` T \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  conjugate \\<circ> c \\<circ> conjugate\n  \\<in> conjugate ` T \\<rightarrow> {0::'a}", "have \"c v = 0\""], ["proof (prove)\nusing this:\n  conjugate \\<circ> c \\<circ> conjugate\n  \\<in> conjugate ` T \\<rightarrow> {0::'a}\n\ngoal (1 subgoal):\n 1. c v = (0::'a)", "by (simp add: Pi_iff \\<open>v \\<in> T\\<close>)"], ["proof (state)\nthis:\n  c v = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>A a v.\n       \\<lbrakk>A \\<subseteq> conjugate ` S; finite A;\n        lincomb a A = 0\\<^sub>v n; v \\<in> A; a v \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  c v = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>c v \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  c v = (0::'a)\n  c v \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lin_indpt (conjugate ` S)\n\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "from rank_ge_card_indpt[OF A 1 2]"], ["proof (chain)\npicking this:\n  card (conjugate ` S) \\<le> rank A", "have 3:\"card (conjugate ` S) \\<le> rank A\""], ["proof (prove)\nusing this:\n  card (conjugate ` S) \\<le> rank A\n\ngoal (1 subgoal):\n 1. card (conjugate ` S) \\<le> rank A", "."], ["proof (state)\nthis:\n  card (conjugate ` S) \\<le> rank A\n\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "have 4: \"card (conjugate ` S) = card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (conjugate ` S) = card S", "apply (auto intro!: card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on conjugate S", "by (meson conjugate_cancel_iff inj_onI)"], ["proof (state)\nthis:\n  card (conjugate ` S) = card S\n\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "using rankeq 3 4"], ["proof (prove)\nusing this:\n  rank (conjugate A) = card S\n  card (conjugate ` S) \\<le> rank A\n  card (conjugate ` S) = card S\n\ngoal (1 subgoal):\n 1. rank (conjugate A) \\<le> rank A", "by auto"], ["proof (state)\nthis:\n  rank (conjugate A) \\<le> rank A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_conjugate:\n  assumes \"A \\<in> carrier_mat n d\"\n  shows \"rank (conjugate A) = rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (conjugate A) = rank A", "using  rank_conjugate_le"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat n ?d \\<Longrightarrow>\n  rank (conjugate ?A) \\<le> rank ?A\n\ngoal (1 subgoal):\n 1. rank (conjugate A) = rank A", "by (metis carrier_vec_conjugate assms conjugate_id dual_order.antisym)"], ["", "end"], ["", "(* exit the context *)"], ["", "lemma conjugate_transpose_rank:\n  fixes A::\"'a::{conjugatable_ordered_field} mat\"\n  shows \"vec_space.rank (dim_row A) A = vec_space.rank (dim_col A) (A\\<^sup>H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank (dim_row A) A = vec_space.rank (dim_col A) A\\<^sup>H", "using  conjugatable_vec_space.conjugate_transpose_rank_le"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?n ?nc \\<Longrightarrow>\n  vec_space.rank ?nc ?A\\<^sup>H \\<le> vec_space.rank ?n ?A\n\ngoal (1 subgoal):\n 1. vec_space.rank (dim_row A) A = vec_space.rank (dim_col A) A\\<^sup>H", "by (metis (no_types, lifting) Matrix.transpose_transpose carrier_matI conjugate_id dim_col_conjugate dual_order.antisym index_transpose_mat(2) transpose_conjugate)"], ["", "lemma transpose_rank:\n  fixes A::\"'a::{conjugatable_ordered_field} mat\"\n  shows \"vec_space.rank (dim_row A) A = vec_space.rank (dim_col A) (A\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank (dim_row A) A = vec_space.rank (dim_col A) A\\<^sup>T", "by (metis carrier_mat_triv conjugatable_vec_space.rank_conjugate conjugate_transpose_rank index_transpose_mat(2))"], ["", "lemma rank_mat_mul_left:\n  fixes A::\"'a::{conjugatable_ordered_field} mat\"\n  assumes \"A \\<in> carrier_mat n d\"\n  assumes \"B \\<in> carrier_mat d nc\"\n  shows \"vec_space.rank n (A * B) \\<le> vec_space.rank d B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_space.rank n (A * B) \\<le> vec_space.rank d B", "by (metis (no_types, lifting) Matrix.transpose_transpose assms(1) assms(2) carrier_matD(1) carrier_matD(2) carrier_mat_triv conjugatable_vec_space.rank_conjugate conjugate_transpose_rank index_mult_mat(3) index_transpose_mat(3) transpose_mult vec_space.rank_mat_mul_right)"], ["", "section \"Results on Invertibility\""], ["", "(* Extract specific columns of a matrix  *)"], ["", "definition take_cols :: \"'a mat \\<Rightarrow> nat list \\<Rightarrow> 'a mat\"\n  where \"take_cols A inds = mat_of_cols (dim_row A) (map ((!) (cols A)) (filter ((>) (dim_col A)) inds))\""], ["", "definition take_cols_var :: \"'a mat \\<Rightarrow> nat list \\<Rightarrow> 'a mat\"\n  where \"take_cols_var A inds = mat_of_cols (dim_row A) (map ((!) (cols A)) (inds))\""], ["", "definition take_rows :: \"'a mat \\<Rightarrow> nat list \\<Rightarrow> 'a mat\"\n  where \"take_rows A inds = mat_of_rows (dim_col A) (map ((!) (rows A)) (filter ((>) (dim_row A)) inds))\""], ["", "lemma cong1:\n  \"x = y \\<Longrightarrow>  mat_of_cols n x = mat_of_cols n y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> mat_of_cols n x = mat_of_cols n y", "by auto"], ["", "lemma nth_filter:\n  assumes \"j < length (filter P ls)\"\n  shows \"P  ((filter P ls) ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (filter P ls ! j)", "by (simp add: assms list_ball_nth)"], ["", "lemma take_cols_mat_mul:\n  assumes \"A \\<in> carrier_mat nr n\"\n  assumes \"B \\<in> carrier_mat n nc\"\n  shows \"A * take_cols B inds = take_cols (A * B) inds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * take_cols B inds = take_cols (A * B) inds", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A * take_cols B inds = take_cols (A * B) inds", "have \"\\<And>j. j < length (map ((!) (cols B)) (filter ((>) nc) inds)) \\<Longrightarrow>\n      (map ((!) (cols B)) (filter ((>) nc) inds)) ! j \\<in> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length\n            (map ((!) (cols B))\n              (filter (\\<lambda>y. y < nc) inds)) \\<Longrightarrow>\n       map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds) ! j\n       \\<in> carrier_vec n", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr n\n  B \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length\n            (map ((!) (cols B))\n              (filter (\\<lambda>y. y < nc) inds)) \\<Longrightarrow>\n       map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds) ! j\n       \\<in> carrier_vec n", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < length (filter (\\<lambda>y. y < nc) inds);\n        A \\<in> carrier_mat nr n; B \\<in> carrier_mat n nc\\<rbrakk>\n       \\<Longrightarrow> cols B ! (filter (\\<lambda>y. y < nc) inds ! j)\n                         \\<in> carrier_vec n", "apply (subst cols_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < length (filter (\\<lambda>y. y < nc) inds);\n        A \\<in> carrier_mat nr n; B \\<in> carrier_mat n nc\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. y < nc) inds ! j < dim_col B\n 2. \\<And>j.\n       \\<lbrakk>j < length (filter (\\<lambda>y. y < nc) inds);\n        A \\<in> carrier_mat nr n; B \\<in> carrier_mat n nc\\<rbrakk>\n       \\<Longrightarrow> col B (filter (\\<lambda>y. y < nc) inds ! j)\n                         \\<in> carrier_vec n", "using nth_filter"], ["proof (prove)\nusing this:\n  ?j < length (filter ?P ?ls) \\<Longrightarrow> ?P (filter ?P ?ls ! ?j)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j < length (filter (\\<lambda>y. y < nc) inds);\n        A \\<in> carrier_mat nr n; B \\<in> carrier_mat n nc\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. y < nc) inds ! j < dim_col B\n 2. \\<And>j.\n       \\<lbrakk>j < length (filter (\\<lambda>y. y < nc) inds);\n        A \\<in> carrier_mat nr n; B \\<in> carrier_mat n nc\\<rbrakk>\n       \\<Longrightarrow> col B (filter (\\<lambda>y. y < nc) inds ! j)\n                         \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  ?j < length\n        (map ((!) (cols B))\n          (filter (\\<lambda>y. y < nc) inds)) \\<Longrightarrow>\n  map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds) ! ?j\n  \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. A * take_cols B inds = take_cols (A * B) inds", "from mul_mat_of_cols[OF assms(1) this]"], ["proof (chain)\npicking this:\n  (\\<And>j.\n      j < length\n           (map ((!) (cols B))\n             (filter (\\<lambda>y. y < nc) inds)) \\<Longrightarrow>\n      j < length\n           (map ((!) (cols B))\n             (filter (\\<lambda>y. y < nc) inds))) \\<Longrightarrow>\n  A *\n  mat_of_cols n (map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds)) =\n  mat_of_cols nr\n   (map ((*\\<^sub>v) A)\n     (map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds)))", "have \"A *  take_cols B inds = mat_of_cols nr (map (\\<lambda>x. A *\\<^sub>v cols B ! x) (filter ((>) (dim_col B)) inds))\""], ["proof (prove)\nusing this:\n  (\\<And>j.\n      j < length\n           (map ((!) (cols B))\n             (filter (\\<lambda>y. y < nc) inds)) \\<Longrightarrow>\n      j < length\n           (map ((!) (cols B))\n             (filter (\\<lambda>y. y < nc) inds))) \\<Longrightarrow>\n  A *\n  mat_of_cols n (map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds)) =\n  mat_of_cols nr\n   (map ((*\\<^sub>v) A)\n     (map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds)))\n\ngoal (1 subgoal):\n 1. A * take_cols B inds =\n    mat_of_cols nr\n     (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n       (filter (\\<lambda>y. y < dim_col B) inds))", "unfolding take_cols_def"], ["proof (prove)\nusing this:\n  (\\<And>j.\n      j < length\n           (map ((!) (cols B))\n             (filter (\\<lambda>y. y < nc) inds)) \\<Longrightarrow>\n      j < length\n           (map ((!) (cols B))\n             (filter (\\<lambda>y. y < nc) inds))) \\<Longrightarrow>\n  A *\n  mat_of_cols n (map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds)) =\n  mat_of_cols nr\n   (map ((*\\<^sub>v) A)\n     (map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds)))\n\ngoal (1 subgoal):\n 1. A *\n    mat_of_cols (dim_row B)\n     (map ((!) (cols B)) (filter (\\<lambda>y. y < dim_col B) inds)) =\n    mat_of_cols nr\n     (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n       (filter (\\<lambda>y. y < dim_col B) inds))", "using assms"], ["proof (prove)\nusing this:\n  (\\<And>j.\n      j < length\n           (map ((!) (cols B))\n             (filter (\\<lambda>y. y < nc) inds)) \\<Longrightarrow>\n      j < length\n           (map ((!) (cols B))\n             (filter (\\<lambda>y. y < nc) inds))) \\<Longrightarrow>\n  A *\n  mat_of_cols n (map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds)) =\n  mat_of_cols nr\n   (map ((*\\<^sub>v) A)\n     (map ((!) (cols B)) (filter (\\<lambda>y. y < nc) inds)))\n  A \\<in> carrier_mat nr n\n  B \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. A *\n    mat_of_cols (dim_row B)\n     (map ((!) (cols B)) (filter (\\<lambda>y. y < dim_col B) inds)) =\n    mat_of_cols nr\n     (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n       (filter (\\<lambda>y. y < dim_col B) inds))", "by (auto simp add: o_def)"], ["proof (state)\nthis:\n  A * take_cols B inds =\n  mat_of_cols nr\n   (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n     (filter (\\<lambda>y. y < dim_col B) inds))\n\ngoal (1 subgoal):\n 1. A * take_cols B inds = take_cols (A * B) inds", "also"], ["proof (state)\nthis:\n  A * take_cols B inds =\n  mat_of_cols nr\n   (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n     (filter (\\<lambda>y. y < dim_col B) inds))\n\ngoal (1 subgoal):\n 1. A * take_cols B inds = take_cols (A * B) inds", "have \"... = take_cols (A * B) inds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols nr\n     (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n       (filter (\\<lambda>y. y < dim_col B) inds)) =\n    take_cols (A * B) inds", "unfolding take_cols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols nr\n     (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n       (filter (\\<lambda>y. y < dim_col B) inds)) =\n    mat_of_cols (dim_row (A * B))\n     (map ((!) (cols (A * B)))\n       (filter (\\<lambda>y. y < dim_col (A * B)) inds))", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr n\n  B \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. mat_of_cols nr\n     (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n       (filter (\\<lambda>y. y < dim_col B) inds)) =\n    mat_of_cols (dim_row (A * B))\n     (map ((!) (cols (A * B)))\n       (filter (\\<lambda>y. y < dim_col (A * B)) inds))", "apply (auto intro!: cong1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A \\<in> carrier_mat nr n; B \\<in> carrier_mat n nc;\n        x \\<in> set inds; x < nc\\<rbrakk>\n       \\<Longrightarrow> A *\\<^sub>v col B x =\n                         vec nr (\\<lambda>i. row A i \\<bullet> col B x)", "by (simp add: mult_mat_vec_def)"], ["proof (state)\nthis:\n  mat_of_cols nr\n   (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n     (filter (\\<lambda>y. y < dim_col B) inds)) =\n  take_cols (A * B) inds\n\ngoal (1 subgoal):\n 1. A * take_cols B inds = take_cols (A * B) inds", "ultimately"], ["proof (chain)\npicking this:\n  A * take_cols B inds =\n  mat_of_cols nr\n   (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n     (filter (\\<lambda>y. y < dim_col B) inds))\n  mat_of_cols nr\n   (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n     (filter (\\<lambda>y. y < dim_col B) inds)) =\n  take_cols (A * B) inds", "show ?thesis"], ["proof (prove)\nusing this:\n  A * take_cols B inds =\n  mat_of_cols nr\n   (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n     (filter (\\<lambda>y. y < dim_col B) inds))\n  mat_of_cols nr\n   (map (\\<lambda>x. A *\\<^sub>v cols B ! x)\n     (filter (\\<lambda>y. y < dim_col B) inds)) =\n  take_cols (A * B) inds\n\ngoal (1 subgoal):\n 1. A * take_cols B inds = take_cols (A * B) inds", "by auto"], ["proof (state)\nthis:\n  A * take_cols B inds = take_cols (A * B) inds\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma take_cols_carrier_mat:\n  assumes \"A \\<in> carrier_mat nr nc\"\n  obtains n where \"take_cols A inds \\<in> carrier_mat nr n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        take_cols A inds \\<in> carrier_mat nr n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding take_cols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        mat_of_cols (dim_row A)\n         (map ((!) (cols A)) (filter (\\<lambda>y. y < dim_col A) inds))\n        \\<in> carrier_mat nr n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        mat_of_cols (dim_row A)\n         (map ((!) (cols A)) (filter (\\<lambda>y. y < dim_col A) inds))\n        \\<in> carrier_mat nr n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["", "lemma take_cols_carrier_mat_strict:\n  assumes \"A \\<in> carrier_mat nr nc\"\n  assumes \"\\<And>i. i \\<in> set inds \\<Longrightarrow> i < nc\"\n  shows \"take_cols A inds \\<in> carrier_mat nr (length inds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_cols A inds \\<in> carrier_mat nr (length inds)", "unfolding take_cols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (filter (\\<lambda>y. y < dim_col A) inds))\n    \\<in> carrier_mat nr (length inds)", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  ?i \\<in> set inds \\<Longrightarrow> ?i < nc\n\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (filter (\\<lambda>y. y < dim_col A) inds))\n    \\<in> carrier_mat nr (length inds)", "by auto"], ["", "lemma gauss_jordan_take_cols:  \n  assumes \"gauss_jordan A (take_cols A inds) = (C,D)\"\n  shows \"D = take_cols C inds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = take_cols C inds", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D = take_cols C inds", "obtain nr nc where A: \"A  \\<in> carrier_mat nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nr nc.\n        A \\<in> carrier_mat nr nc \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. D = take_cols C inds", "from take_cols_carrier_mat[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>n.\n      take_cols A ?inds \\<in> carrier_mat nr n \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain n where B: \"take_cols A inds \\<in> carrier_mat nr n\""], ["proof (prove)\nusing this:\n  (\\<And>n.\n      take_cols A ?inds \\<in> carrier_mat nr n \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        take_cols A inds \\<in> carrier_mat nr n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  take_cols A inds \\<in> carrier_mat nr n\n\ngoal (1 subgoal):\n 1. D = take_cols C inds", "from gauss_jordan_transform[OF A B assms, of undefined]"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr undefined).\n     C = P * A \\<and> D = P * take_cols A inds", "obtain P where PP:\"P\\<in>Units (ring_mat TYPE('a) nr undefined)\" and\n    CD: \"C = P * A\" \"D = P * take_cols A inds\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr undefined).\n     C = P * A \\<and> D = P * take_cols A inds\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) nr undefined); C = P * A;\n         D = P * take_cols A inds\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) nr undefined)\n  C = P * A\n  D = P * take_cols A inds\n\ngoal (1 subgoal):\n 1. D = take_cols C inds", "have P: \"P \\<in> carrier_mat nr nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "by (metis (no_types, lifting) Units_def PP mem_Collect_eq partial_object.select_convs(1) ring_mat_def)"], ["proof (state)\nthis:\n  P \\<in> carrier_mat nr nr\n\ngoal (1 subgoal):\n 1. D = take_cols C inds", "from take_cols_mat_mul[OF P A]"], ["proof (chain)\npicking this:\n  P * take_cols A ?inds = take_cols (P * A) ?inds", "have \"P * take_cols A inds = take_cols (P * A) inds\""], ["proof (prove)\nusing this:\n  P * take_cols A ?inds = take_cols (P * A) ?inds\n\ngoal (1 subgoal):\n 1. P * take_cols A inds = take_cols (P * A) inds", "."], ["proof (state)\nthis:\n  P * take_cols A inds = take_cols (P * A) inds\n\ngoal (1 subgoal):\n 1. D = take_cols C inds", "thus ?thesis"], ["proof (prove)\nusing this:\n  P * take_cols A inds = take_cols (P * A) inds\n\ngoal (1 subgoal):\n 1. D = take_cols C inds", "using CD"], ["proof (prove)\nusing this:\n  P * take_cols A inds = take_cols (P * A) inds\n  C = P * A\n  D = P * take_cols A inds\n\ngoal (1 subgoal):\n 1. D = take_cols C inds", "by blast"], ["proof (state)\nthis:\n  D = take_cols C inds\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_col_take_cols:\n  assumes \"\\<And>j. j \\<in> set inds \\<Longrightarrow> j < dim_col A\"\n  shows \"dim_col (take_cols A inds) = length inds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (take_cols A inds) = length inds", "unfolding take_cols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (mat_of_cols (dim_row A)\n       (map ((!) (cols A)) (filter (\\<lambda>y. y < dim_col A) inds))) =\n    length inds", "using assms"], ["proof (prove)\nusing this:\n  ?j \\<in> set inds \\<Longrightarrow> ?j < dim_col A\n\ngoal (1 subgoal):\n 1. dim_col\n     (mat_of_cols (dim_row A)\n       (map ((!) (cols A)) (filter (\\<lambda>y. y < dim_col A) inds))) =\n    length inds", "by auto"], ["", "lemma dim_col_take_rows[simp]:\n  shows \"dim_col (take_rows A inds) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (take_rows A inds) = dim_col A", "unfolding take_rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (mat_of_rows (dim_col A)\n       (map ((!) (rows A)) (filter (\\<lambda>y. y < dim_row A) inds))) =\n    dim_col A", "by auto"], ["", "lemma cols_take_cols_subset:\n  shows \"set (cols (take_cols A inds)) \\<subseteq> set (cols A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cols (take_cols A inds)) \\<subseteq> set (cols A)", "unfolding take_cols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cols\n          (mat_of_cols (dim_row A)\n            (map ((!) (cols A)) (filter (\\<lambda>y. y < dim_col A) inds))))\n    \\<subseteq> set (cols A)", "apply (subst cols_mat_of_cols)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (map ((!) (cols A)) (filter (\\<lambda>y. y < dim_col A) inds))\n    \\<subseteq> carrier_vec (dim_row A)\n 2. set (map ((!) (cols A)) (filter (\\<lambda>y. y < dim_col A) inds))\n    \\<subseteq> set (cols A)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> set inds; xa < dim_col A\\<rbrakk>\n       \\<Longrightarrow> col A xa \\<in> set (cols A)", "using in_set_conv_nth"], ["proof (prove)\nusing this:\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> set inds; xa < dim_col A\\<rbrakk>\n       \\<Longrightarrow> col A xa \\<in> set (cols A)", "by fastforce"], ["", "lemma dim_row_take_cols[simp]:\n  shows \"dim_row (take_cols A ls) = dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (take_cols A ls) = dim_row A", "by (simp add: take_cols_def)"], ["", "lemma dim_row_append_rows[simp]:\n  shows \"dim_row (A @\\<^sub>r B) = dim_row A + dim_row B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (A @\\<^sub>r B) = dim_row A + dim_row B", "by (simp add: append_rows_def)"], ["", "lemma rows_inj:\n  assumes \"dim_col A = dim_col B\"\n  assumes \"rows A = rows B\"\n  shows \"A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "unfolding mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A = dim_row B \\<and>\n    dim_col A = dim_col B \\<and>\n    (\\<forall>i j.\n        i < dim_row B \\<longrightarrow>\n        j < dim_col B \\<longrightarrow> A $$ (i, j) = B $$ (i, j))", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. dim_row A = dim_row B\n 2. dim_col A = dim_col B\n 3. \\<And>i j.\n       \\<lbrakk>i < dim_row B; j < dim_col B\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = B $$ (i, j)", "apply (metis assms(2) length_rows)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_col A = dim_col B\n 2. \\<And>i j.\n       \\<lbrakk>i < dim_row B; j < dim_col B\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = B $$ (i, j)", "using assms(1)"], ["proof (prove)\nusing this:\n  dim_col A = dim_col B\n\ngoal (2 subgoals):\n 1. dim_col A = dim_col B\n 2. \\<And>i j.\n       \\<lbrakk>i < dim_row B; j < dim_col B\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = B $$ (i, j)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row B; j < dim_col B\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = B $$ (i, j)", "by (metis assms(1) assms(2) mat_of_rows_rows)"], ["", "lemma append_rows_index:\n  assumes \"dim_col A = dim_col B\"\n  assumes \"i < dim_row A + dim_row B\"\n  assumes \"j < dim_col A\"\n  shows \"(A @\\<^sub>r B) $$ (i,j) = (if i < dim_row A then A $$ (i,j) else B $$ (i-dim_row A,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A @\\<^sub>r B) $$ (i, j) =\n    (if i < dim_row A then A $$ (i, j) else B $$ (i - dim_row A, j))", "unfolding append_rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat A (0\\<^sub>m (dim_row A) 0) B\n     (0\\<^sub>m (dim_row B) 0) $$\n    (i, j) =\n    (if i < dim_row A then A $$ (i, j) else B $$ (i - dim_row A, j))", "apply (subst index_mat_four_block)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < dim_row A + dim_row (0\\<^sub>m (dim_row B) 0)\n 2. j < dim_col A + dim_col (0\\<^sub>m (dim_row B) 0)\n 3. (if i < dim_row A\n     then if j < dim_col A then A $$ (i, j)\n          else 0\\<^sub>m (dim_row A) 0 $$ (i, j - dim_col A)\n     else if j < dim_col A then B $$ (i - dim_row A, j)\n          else 0\\<^sub>m (dim_row B) 0 $$ (i - dim_row A, j - dim_col A)) =\n    (if i < dim_row A then A $$ (i, j) else B $$ (i - dim_row A, j))", "using assms"], ["proof (prove)\nusing this:\n  dim_col A = dim_col B\n  i < dim_row A + dim_row B\n  j < dim_col A\n\ngoal (3 subgoals):\n 1. i < dim_row A + dim_row (0\\<^sub>m (dim_row B) 0)\n 2. j < dim_col A + dim_col (0\\<^sub>m (dim_row B) 0)\n 3. (if i < dim_row A\n     then if j < dim_col A then A $$ (i, j)\n          else 0\\<^sub>m (dim_row A) 0 $$ (i, j - dim_col A)\n     else if j < dim_col A then B $$ (i - dim_row A, j)\n          else 0\\<^sub>m (dim_row B) 0 $$ (i - dim_row A, j - dim_col A)) =\n    (if i < dim_row A then A $$ (i, j) else B $$ (i - dim_row A, j))", "by auto"], ["", "lemma row_append_rows:\n  assumes \"dim_col A = dim_col B\"\n  assumes \"i < dim_row A + dim_row B\"\n  shows \"row (A @\\<^sub>r B) i = (if i < dim_row A then row A i else row B (i-dim_row A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (A @\\<^sub>r B) i =\n    (if i < dim_row A then row A i else row B (i - dim_row A))", "unfolding vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (row (A @\\<^sub>r B) i) =\n    dim_vec\n     (if i < dim_row A then row A i else row B (i - dim_row A)) \\<and>\n    (\\<forall>ia<dim_vec\n                  (if i < dim_row A then row A i\n                   else row B (i - dim_row A)).\n        row (A @\\<^sub>r B) i $ ia =\n        (if i < dim_row A then row A i else row B (i - dim_row A)) $ ia)", "using assms"], ["proof (prove)\nusing this:\n  dim_col A = dim_col B\n  i < dim_row A + dim_row B\n\ngoal (1 subgoal):\n 1. dim_vec (row (A @\\<^sub>r B) i) =\n    dim_vec\n     (if i < dim_row A then row A i else row B (i - dim_row A)) \\<and>\n    (\\<forall>ia<dim_vec\n                  (if i < dim_row A then row A i\n                   else row B (i - dim_row A)).\n        row (A @\\<^sub>r B) i $ ia =\n        (if i < dim_row A then row A i else row B (i - dim_row A)) $ ia)", "by (auto simp add: append_rows_def)"], ["", "lemma append_rows_mat_mul:\n  assumes \"dim_col A = dim_col B\"\n  shows \"(A @\\<^sub>r B) * C = A * C @\\<^sub>r B * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A @\\<^sub>r B) * C = A * C @\\<^sub>r B * C", "unfolding mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row ((A @\\<^sub>r B) * C) = dim_row (A * C @\\<^sub>r B * C) \\<and>\n    dim_col ((A @\\<^sub>r B) * C) = dim_col (A * C @\\<^sub>r B * C) \\<and>\n    (\\<forall>i j.\n        i < dim_row (A * C @\\<^sub>r B * C) \\<longrightarrow>\n        j < dim_col (A * C @\\<^sub>r B * C) \\<longrightarrow>\n        ((A @\\<^sub>r B) * C) $$ (i, j) = (A * C @\\<^sub>r B * C) $$ (i, j))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_col C = dim_col (A * C @\\<^sub>r B * C)\n 2. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> ((A @\\<^sub>r B) * C) $$ (i, j) =\n                         (A * C @\\<^sub>r B * C) $$ (i, j)", "apply (simp add: append_rows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> ((A @\\<^sub>r B) * C) $$ (i, j) =\n                         (A * C @\\<^sub>r B * C) $$ (i, j)", "apply (subst index_mult_mat)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> i < dim_row (A @\\<^sub>r B)\n 2. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> j < dim_col C\n 3. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> row (A @\\<^sub>r B) i \\<bullet> col C j =\n                         (A * C @\\<^sub>r B * C) $$ (i, j)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> j < dim_col C\n 2. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> row (A @\\<^sub>r B) i \\<bullet> col C j =\n                         (A * C @\\<^sub>r B * C) $$ (i, j)", "apply (simp add: append_rows_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> row (A @\\<^sub>r B) i \\<bullet> col C j =\n                         (A * C @\\<^sub>r B * C) $$ (i, j)", "apply (subst  append_rows_index)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> dim_col (A * C) = dim_col (B * C)\n 2. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> i < dim_row (A * C) + dim_row (B * C)\n 3. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> j < dim_col (A * C)\n 4. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> row (A @\\<^sub>r B) i \\<bullet> col C j =\n                         (if i < dim_row (A * C) then (A * C) $$ (i, j)\n                          else (B * C) $$ (i - dim_row (A * C), j))", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C)\\<rbrakk>\n       \\<Longrightarrow> j < dim_col C\n 2. \\<And>i j.\n       \\<lbrakk>j < dim_col (A * C @\\<^sub>r B * C); i < dim_row A\\<rbrakk>\n       \\<Longrightarrow> row (A @\\<^sub>r B) i \\<bullet> col C j =\n                         (A * C) $$ (i, j)\n 3. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C); \\<not> i < dim_row A\\<rbrakk>\n       \\<Longrightarrow> row (A @\\<^sub>r B) i \\<bullet> col C j =\n                         (B * C) $$ (i - dim_row A, j)", "apply (simp add: append_rows_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>j < dim_col (A * C @\\<^sub>r B * C); i < dim_row A\\<rbrakk>\n       \\<Longrightarrow> row (A @\\<^sub>r B) i \\<bullet> col C j =\n                         (A * C) $$ (i, j)\n 2. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C); \\<not> i < dim_row A\\<rbrakk>\n       \\<Longrightarrow> row (A @\\<^sub>r B) i \\<bullet> col C j =\n                         (B * C) $$ (i - dim_row A, j)", "apply (metis add.right_neutral append_rows_def assms index_mat_four_block(3) index_mult_mat(1) index_mult_mat(3) index_zero_mat(3) row_append_rows trans_less_add1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A + dim_row B;\n        j < dim_col (A * C @\\<^sub>r B * C); \\<not> i < dim_row A\\<rbrakk>\n       \\<Longrightarrow> row (A @\\<^sub>r B) i \\<bullet> col C j =\n                         (B * C) $$ (i - dim_row A, j)", "by (metis add_cancel_right_right add_diff_inverse_nat append_rows_def assms index_mat_four_block(3) index_mult_mat(1) index_mult_mat(3) index_zero_mat(3) nat_add_left_cancel_less row_append_rows)"], ["", "lemma cardlt:\n  shows \"card  {i. i < (n::nat)} \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {i. i < n} \\<le> n", "by simp"], ["", "lemma row_echelon_form_zero_rows:\n  assumes row_ech: \"row_echelon_form A\"\n  assumes dim_asm: \"dim_col A \\<ge> dim_row A\"\n  shows \"take_rows A [0..<length (pivot_positions A)] @\\<^sub>r  0\\<^sub>m (dim_row A - length (pivot_positions A))  (dim_col A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "have ex_pivot_fun: \"\\<exists> f. pivot_fun A f (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "using row_ech"], ["proof (prove)\nusing this:\n  row_echelon_form A\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "unfolding row_echelon_form_def"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "by auto"], ["proof (state)\nthis:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "have len_help: \"length (pivot_positions A) = card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "using ex_pivot_fun pivot_positions[where A = \"A\",where nr = \"dim_row A\", where nc = \"dim_col A\"]"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A ?f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions A) =\n                    {(i, ?f i) |i.\n                     i < dim_row A \\<and> ?f i \\<noteq> dim_col A}\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A ?f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (pivot_positions A))\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A ?f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (pivot_positions A))\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A ?f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> length (pivot_positions A) =\n                    card\n                     {i. i < dim_row A \\<and>\n                         row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "by auto"], ["proof (state)\nthis:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "then"], ["proof (chain)\npicking this:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "have len_help2: \"length (pivot_positions A) \\<le> dim_row A\""], ["proof (prove)\nusing this:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "by (metis (no_types, lifting) card_mono cardlt finite_Collect_less_nat le_trans mem_Collect_eq subsetI)"], ["proof (state)\nthis:\n  length (pivot_positions A) \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "have fileq: \"filter (\\<lambda>y. y < dim_row A) [0..< length (pivot_positions A)] = [0..<length (pivot_positions A)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. y < dim_row A) [0..<length (pivot_positions A)] =\n    [0..<length (pivot_positions A)]", "apply (rule filter_True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set [0..<length (pivot_positions A)]. x < dim_row A", "using len_help2"], ["proof (prove)\nusing this:\n  length (pivot_positions A) \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set [0..<length (pivot_positions A)]. x < dim_row A", "by auto"], ["proof (state)\nthis:\n  filter (\\<lambda>y. y < dim_row A) [0..<length (pivot_positions A)] =\n  [0..<length (pivot_positions A)]\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "have \"\\<forall>n. card {i. i < n  \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n", "have h: \"\\<forall>x. x \\<in> {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<longrightarrow> x\\<in>{..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> {i. i < n \\<and>\n                   row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<longrightarrow>\n       x \\<in> {..<n}", "by simp"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> {i. i < n \\<and>\n                 row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<longrightarrow>\n     x \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in> {i. i < n \\<and>\n                 row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<longrightarrow>\n     x \\<in> {..<n}", "have h1: \"{i. i < n  \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<subseteq> {..<n}\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> {i. i < n \\<and>\n                 row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<longrightarrow>\n     x \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<subseteq> {..<n}", "by blast"], ["proof (state)\nthis:\n  {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<subseteq> {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n", "then"], ["proof (chain)\npicking this:\n  {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<subseteq> {..<n}", "have h2: \"(card {i. i < n  \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}::nat) \\<le> (card {..<n}::nat)\""], ["proof (prove)\nusing this:\n  {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<subseteq> {..<n}\n\ngoal (1 subgoal):\n 1. card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<le> card {..<n}", "using card_mono"], ["proof (prove)\nusing this:\n  {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<subseteq> {..<n}\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> card ?B\n\ngoal (1 subgoal):\n 1. card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<le> card {..<n}", "by blast"], ["proof (state)\nthis:\n  card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> card {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n", "then"], ["proof (chain)\npicking this:\n  card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> card {..<n}", "show \"(card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}::nat) \\<le> (n::nat)\""], ["proof (prove)\nusing this:\n  card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> card {..<n}\n\ngoal (1 subgoal):\n 1. card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n", "using h2 card_lessThan[of n]"], ["proof (prove)\nusing this:\n  card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> card {..<n}\n  card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> card {..<n}\n  card {..<n} = n\n\ngoal (1 subgoal):\n 1. card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n", "by auto"], ["proof (state)\nthis:\n  card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n.\n     card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "then"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n", "have pivot_len: \"length (pivot_positions A) \\<le> dim_row A \""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "using len_help"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)} \\<le> n\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "by simp"], ["proof (state)\nthis:\n  length (pivot_positions A) \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "have alt_char: \"mat_of_rows (dim_col A)\n         (map ((!) (rows A)) (filter (\\<lambda>y. y < dim_col A) [0..<length (pivot_positions A)])) = \n      mat_of_rows (dim_col A) (map ((!) (rows A))  [0..<length (pivot_positions A)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows (dim_col A)\n     (map ((!) (rows A))\n       (filter (\\<lambda>y. y < dim_col A)\n         [0..<length (pivot_positions A)])) =\n    mat_of_rows (dim_col A)\n     (map ((!) (rows A)) [0..<length (pivot_positions A)])", "using pivot_len dim_asm"], ["proof (prove)\nusing this:\n  length (pivot_positions A) \\<le> dim_row A\n  dim_row A \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. mat_of_rows (dim_col A)\n     (map ((!) (rows A))\n       (filter (\\<lambda>y. y < dim_col A)\n         [0..<length (pivot_positions A)])) =\n    mat_of_rows (dim_col A)\n     (map ((!) (rows A)) [0..<length (pivot_positions A)])", "by auto"], ["proof (state)\nthis:\n  mat_of_rows (dim_col A)\n   (map ((!) (rows A))\n     (filter (\\<lambda>y. y < dim_col A)\n       [0..<length (pivot_positions A)])) =\n  mat_of_rows (dim_col A)\n   (map ((!) (rows A)) [0..<length (pivot_positions A)])\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "have h1: \"\\<And>i j. i < dim_row A \\<Longrightarrow>\n           j < dim_col A \\<Longrightarrow>\n           i < dim_row (take_rows A [0..<length (pivot_positions A)]) \\<Longrightarrow>\n           take_rows A [0..<length (pivot_positions A)] $$ (i, j) = A $$ (i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                         (i, j) =\n                         A $$ (i, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                         (i, j) =\n                         A $$ (i, j)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                         (i, j) =\n                         A $$ (i, j)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                         (i, j) =\n                         A $$ (i, j)", "assume \"i < dim_row A\""], ["proof (state)\nthis:\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                         (i, j) =\n                         A $$ (i, j)", "assume j_lt: \"j < dim_col A\""], ["proof (state)\nthis:\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                         (i, j) =\n                         A $$ (i, j)", "assume i_lt: \"i < dim_row (take_rows A [0..<length (pivot_positions A)])\""], ["proof (state)\nthis:\n  i < dim_row (take_rows A [0..<length (pivot_positions A)])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                         (i, j) =\n                         A $$ (i, j)", "have lt: \"length (pivot_positions A) \\<le> dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "using pivot_len"], ["proof (prove)\nusing this:\n  length (pivot_positions A) \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "by auto"], ["proof (state)\nthis:\n  length (pivot_positions A) \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                         (i, j) =\n                         A $$ (i, j)", "have h1: \"take_rows A [0..<length (pivot_positions A)] $$ (i, j) = (row (take_rows A [0..<length (pivot_positions A)]) i)$j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] $$ (i, j) =\n    row (take_rows A [0..<length (pivot_positions A)]) i $ j", "by (simp add: i_lt j_lt)"], ["proof (state)\nthis:\n  take_rows A [0..<length (pivot_positions A)] $$ (i, j) =\n  row (take_rows A [0..<length (pivot_positions A)]) i $ j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                         (i, j) =\n                         A $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  take_rows A [0..<length (pivot_positions A)] $$ (i, j) =\n  row (take_rows A [0..<length (pivot_positions A)]) i $ j", "have h2: \"(row (take_rows A [0..<length (pivot_positions A)]) i)$j = (row A i)$j\""], ["proof (prove)\nusing this:\n  take_rows A [0..<length (pivot_positions A)] $$ (i, j) =\n  row (take_rows A [0..<length (pivot_positions A)]) i $ j\n\ngoal (1 subgoal):\n 1. row (take_rows A [0..<length (pivot_positions A)]) i $ j = row A i $ j", "using lt alt_char i_lt"], ["proof (prove)\nusing this:\n  take_rows A [0..<length (pivot_positions A)] $$ (i, j) =\n  row (take_rows A [0..<length (pivot_positions A)]) i $ j\n  length (pivot_positions A) \\<le> dim_row A\n  mat_of_rows (dim_col A)\n   (map ((!) (rows A))\n     (filter (\\<lambda>y. y < dim_col A)\n       [0..<length (pivot_positions A)])) =\n  mat_of_rows (dim_col A)\n   (map ((!) (rows A)) [0..<length (pivot_positions A)])\n  i < dim_row (take_rows A [0..<length (pivot_positions A)])\n\ngoal (1 subgoal):\n 1. row (take_rows A [0..<length (pivot_positions A)]) i $ j = row A i $ j", "unfolding take_rows_def"], ["proof (prove)\nusing this:\n  mat_of_rows (dim_col A)\n   (map ((!) (rows A))\n     (filter (\\<lambda>y. y < dim_row A)\n       [0..<length (pivot_positions A)])) $$\n  (i, j) =\n  row (mat_of_rows (dim_col A)\n        (map ((!) (rows A))\n          (filter (\\<lambda>y. y < dim_row A)\n            [0..<length (pivot_positions A)])))\n   i $\n  j\n  length (pivot_positions A) \\<le> dim_row A\n  mat_of_rows (dim_col A)\n   (map ((!) (rows A))\n     (filter (\\<lambda>y. y < dim_col A)\n       [0..<length (pivot_positions A)])) =\n  mat_of_rows (dim_col A)\n   (map ((!) (rows A)) [0..<length (pivot_positions A)])\n  i < dim_row\n       (mat_of_rows (dim_col A)\n         (map ((!) (rows A))\n           (filter (\\<lambda>y. y < dim_row A)\n             [0..<length (pivot_positions A)])))\n\ngoal (1 subgoal):\n 1. row (mat_of_rows (dim_col A)\n          (map ((!) (rows A))\n            (filter (\\<lambda>y. y < dim_row A)\n              [0..<length (pivot_positions A)])))\n     i $\n    j =\n    row A i $ j", "by auto"], ["proof (state)\nthis:\n  row (take_rows A [0..<length (pivot_positions A)]) i $ j = row A i $ j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                         (i, j) =\n                         A $$ (i, j)", "show \"take_rows A [0..<length (pivot_positions A)] $$ (i, j) = A $$ (i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] $$ (i, j) = A $$ (i, j)", "using h1 h2"], ["proof (prove)\nusing this:\n  take_rows A [0..<length (pivot_positions A)] $$ (i, j) =\n  row (take_rows A [0..<length (pivot_positions A)]) i $ j\n  row (take_rows A [0..<length (pivot_positions A)]) i $ j = row A i $ j\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] $$ (i, j) = A $$ (i, j)", "by (simp add: \\<open>i < dim_row A\\<close> j_lt)"], ["proof (state)\nthis:\n  take_rows A [0..<length (pivot_positions A)] $$ (i, j) = A $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < dim_row A; ?j < dim_col A;\n   ?i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n  \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                    (?i, ?j) =\n                    A $$ (?i, ?j)\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "let ?nc = \"dim_col A\""], ["proof (state)\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "let ?nr = \"dim_row A\""], ["proof (state)\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "have h2: \"\\<And>i j. i < dim_row A \\<Longrightarrow>\n           j < dim_col A \\<Longrightarrow>\n           \\<not> i < dim_row (take_rows A [0..<length (pivot_positions A)]) \\<Longrightarrow>\n           0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n           (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n           A $$ (i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "assume lt_i: \"i < dim_row A\""], ["proof (state)\nthis:\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "assume lt_j: \"j < dim_col A\""], ["proof (state)\nthis:\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "assume not_lt: \"\\<not> i < dim_row (take_rows A [0..<length (pivot_positions A)])\""], ["proof (state)\nthis:\n  \\<not> i < dim_row (take_rows A [0..<length (pivot_positions A)])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "let ?ip = \"i+1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "have h0: \"\\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = ?nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A", "have half1: \"\\<exists>f. pivot_fun A f (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "using assms"], ["proof (prove)\nusing this:\n  row_echelon_form A\n  dim_row A \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "unfolding row_echelon_form_def"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n  dim_row A \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A", "have half2: \"\\<forall>f. pivot_fun A f (dim_col A) \\<longrightarrow> f i = ?nc \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f. pivot_fun A f (dim_col A) \\<longrightarrow> f i = dim_col A", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "assume is_piv: \"pivot_fun A f (dim_col A)\""], ["proof (state)\nthis:\n  pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "have len_pp: \"length (pivot_positions A) = card {i. i < ?nr \\<and> row A i \\<noteq> 0\\<^sub>v ?nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "using is_piv pivot_positions[of A ?nr ?nc f]"], ["proof (prove)\nusing this:\n  pivot_fun A f (dim_col A)\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions A) =\n                    {(i, f i) |i.\n                     i < dim_row A \\<and> f i \\<noteq> dim_col A}\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (pivot_positions A))\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (pivot_positions A))\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> length (pivot_positions A) =\n                    card\n                     {i. i < dim_row A \\<and>\n                         row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "by auto"], ["proof (state)\nthis:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "have  \"\\<forall>i. (i < ?nr \\<and> row A i \\<noteq> 0\\<^sub>v ?nc) \\<longleftrightarrow>  (i < ?nr \\<and> f i \\<noteq> ?nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)) =\n       (i < dim_row A \\<and> f i \\<noteq> dim_col A)", "using is_piv pivot_fun_zero_row_iff[of A f ?nc ?nr]"], ["proof (prove)\nusing this:\n  pivot_fun A f (dim_col A)\n  \\<lbrakk>pivot_fun A f (dim_col A);\n   A \\<in> carrier_mat (dim_row A) (dim_col A); ?i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> (f ?i = dim_col A) = (row A ?i = 0\\<^sub>v (dim_col A))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)) =\n       (i < dim_row A \\<and> f i \\<noteq> dim_col A)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i.\n     (i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)) =\n     (i < dim_row A \\<and> f i \\<noteq> dim_col A)\n\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "then"], ["proof (chain)\npicking this:\n  \\<forall>i.\n     (i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)) =\n     (i < dim_row A \\<and> f i \\<noteq> dim_col A)", "have len_pp_var: \"length (pivot_positions A) = card {i. i < ?nr \\<and> f i \\<noteq> ?nc}\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)) =\n     (i < dim_row A \\<and> f i \\<noteq> dim_col A)\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}", "using len_pp"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)) =\n     (i < dim_row A \\<and> f i \\<noteq> dim_col A)\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}", "by auto"], ["proof (state)\nthis:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "have allj_hyp: \"\\<forall>j < ?nr. f j = ?nc \\<longrightarrow> ((Suc j) < ?nr \\<longrightarrow> f (Suc j) = ?nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<dim_row A.\n       f j = dim_col A \\<longrightarrow>\n       Suc j < dim_row A \\<longrightarrow> f (Suc j) = dim_col A", "using is_piv"], ["proof (prove)\nusing this:\n  pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<forall>j<dim_row A.\n       f j = dim_col A \\<longrightarrow>\n       Suc j < dim_row A \\<longrightarrow> f (Suc j) = dim_col A", "unfolding pivot_fun_def"], ["proof (prove)\nusing this:\n  let nr = dim_row A\n  in \\<forall>i<nr.\n        f i \\<le> dim_col A \\<and>\n        (f i < dim_col A \\<longrightarrow>\n         A $$ (i, f i) = (1::'a) \\<and>\n         (\\<forall>i'<nr.\n             i' \\<noteq> i \\<longrightarrow>\n             A $$ (i', f i) = (0::'a))) \\<and>\n        (\\<forall>j<f i. A $$ (i, j) = (0::'a)) \\<and>\n        (Suc i < nr \\<longrightarrow>\n         f i < f (Suc i) \\<or> f (Suc i) = dim_col A)\n\ngoal (1 subgoal):\n 1. \\<forall>j<dim_row A.\n       f j = dim_col A \\<longrightarrow>\n       Suc j < dim_row A \\<longrightarrow> f (Suc j) = dim_col A", "using lt_i"], ["proof (prove)\nusing this:\n  let nr = dim_row A\n  in \\<forall>i<nr.\n        f i \\<le> dim_col A \\<and>\n        (f i < dim_col A \\<longrightarrow>\n         A $$ (i, f i) = (1::'a) \\<and>\n         (\\<forall>i'<nr.\n             i' \\<noteq> i \\<longrightarrow>\n             A $$ (i', f i) = (0::'a))) \\<and>\n        (\\<forall>j<f i. A $$ (i, j) = (0::'a)) \\<and>\n        (Suc i < nr \\<longrightarrow>\n         f i < f (Suc i) \\<or> f (Suc i) = dim_col A)\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. \\<forall>j<dim_row A.\n       f j = dim_col A \\<longrightarrow>\n       Suc j < dim_row A \\<longrightarrow> f (Suc j) = dim_col A", "by (metis le_antisym le_less)"], ["proof (state)\nthis:\n  \\<forall>j<dim_row A.\n     f j = dim_col A \\<longrightarrow>\n     Suc j < dim_row A \\<longrightarrow> f (Suc j) = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "have if_then_bad: \"f i \\<noteq> ?nc \\<longrightarrow> (\\<forall>j. j \\<le> i \\<longrightarrow> f j \\<noteq> ?nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<noteq> dim_col A \\<longrightarrow>\n    (\\<forall>j\\<le>i. f j \\<noteq> dim_col A)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>f i \\<noteq> dim_col A; j \\<le> i; f j = dim_col A\\<rbrakk>\n       \\<Longrightarrow> False", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>f i \\<noteq> dim_col A; j \\<le> i; f j = dim_col A\\<rbrakk>\n       \\<Longrightarrow> False", "assume not_i: \"f i \\<noteq> ?nc\""], ["proof (state)\nthis:\n  f i \\<noteq> dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>f i \\<noteq> dim_col A; j \\<le> i; f j = dim_col A\\<rbrakk>\n       \\<Longrightarrow> False", "assume j_leq: \"j \\<le> i\""], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>f i \\<noteq> dim_col A; j \\<le> i; f j = dim_col A\\<rbrakk>\n       \\<Longrightarrow> False", "assume bad_asm: \"f j = ?nc\""], ["proof (state)\nthis:\n  f j = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>f i \\<noteq> dim_col A; j \\<le> i; f j = dim_col A\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<And>k. k \\<ge> j \\<Longrightarrow>  k < ?nr \\<Longrightarrow> f k = ?nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "fix k :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "assume a1: \"j \\<le> k\""], ["proof (state)\nthis:\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "assume a2: \"k < dim_row A\""], ["proof (state)\nthis:\n  k < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "have f3: \"\\<And>n. \\<not> n < dim_row A \\<or> f n \\<noteq> f j \\<or> \\<not> Suc n < dim_row A \\<or> f (Suc n) = f j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> n < dim_row A \\<or>\n       f n \\<noteq> f j \\<or> \\<not> Suc n < dim_row A \\<or> f (Suc n) = f j", "using allj_hyp bad_asm"], ["proof (prove)\nusing this:\n  \\<forall>j<dim_row A.\n     f j = dim_col A \\<longrightarrow>\n     Suc j < dim_row A \\<longrightarrow> f (Suc j) = dim_col A\n  f j = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> n < dim_row A \\<or>\n       f n \\<noteq> f j \\<or> \\<not> Suc n < dim_row A \\<or> f (Suc n) = f j", "by presburger"], ["proof (state)\nthis:\n  \\<not> ?n < dim_row A \\<or>\n  f ?n \\<noteq> f j \\<or> \\<not> Suc ?n < dim_row A \\<or> f (Suc ?n) = f j\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "obtain nn :: \"nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<Rightarrow> bool) \\<Rightarrow> nat\" where\n              f4: \"\\<And>n na p nb nc. (\\<not> n \\<le> na \\<or> Suc n \\<le> Suc na) \\<and> (\\<not> p nb \\<or> \\<not> nc \\<le> nb \\<or> \\<not> p (nn nc nb p) \\<or> p nc) \\<and> (\\<not> p nb \\<or> \\<not> nc \\<le> nb \\<or> p nc \\<or> p (Suc (nn nc nb p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        (\\<And>n na p nb nc.\n            (\\<not> n \\<le> na \\<or> Suc n \\<le> Suc na) \\<and>\n            (\\<not> p nb \\<or>\n             \\<not> nc \\<le> nb \\<or>\n             \\<not> p (nn nc nb p) \\<or> p nc) \\<and>\n            (\\<not> p nb \\<or>\n             \\<not> nc \\<le> nb \\<or>\n             p nc \\<or> p (Suc (nn nc nb p)))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inc_induct order_refl"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?j; ?P ?j;\n   \\<And>n.\n      \\<lbrakk>?i \\<le> n; n < ?j; ?P (Suc n)\\<rbrakk>\n      \\<Longrightarrow> ?P n\\<rbrakk>\n  \\<Longrightarrow> ?P ?i\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        (\\<And>n na p nb nc.\n            (\\<not> n \\<le> na \\<or> Suc n \\<le> Suc na) \\<and>\n            (\\<not> p nb \\<or>\n             \\<not> nc \\<le> nb \\<or>\n             \\<not> p (nn nc nb p) \\<or> p nc) \\<and>\n            (\\<not> p nb \\<or>\n             \\<not> nc \\<le> nb \\<or>\n             p nc \\<or> p (Suc (nn nc nb p)))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  (\\<not> ?n \\<le> ?na \\<or> Suc ?n \\<le> Suc ?na) \\<and>\n  (\\<not> ?p ?nb \\<or>\n   \\<not> ?nc \\<le> ?nb \\<or> \\<not> ?p (nn ?nc ?nb ?p) \\<or> ?p ?nc) \\<and>\n  (\\<not> ?p ?nb \\<or>\n   \\<not> ?nc \\<le> ?nb \\<or> ?p ?nc \\<or> ?p (Suc (nn ?nc ?nb ?p)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "then"], ["proof (chain)\npicking this:\n  (\\<not> ?n \\<le> ?na \\<or> Suc ?n \\<le> Suc ?na) \\<and>\n  (\\<not> ?p ?nb \\<or>\n   \\<not> ?nc \\<le> ?nb \\<or> \\<not> ?p (nn ?nc ?nb ?p) \\<or> ?p ?nc) \\<and>\n  (\\<not> ?p ?nb \\<or>\n   \\<not> ?nc \\<le> ?nb \\<or> ?p ?nc \\<or> ?p (Suc (nn ?nc ?nb ?p)))", "have f5: \"\\<And>p. \\<not> p k \\<or> p j \\<or> p (Suc (nn j k p))\""], ["proof (prove)\nusing this:\n  (\\<not> ?n \\<le> ?na \\<or> Suc ?n \\<le> Suc ?na) \\<and>\n  (\\<not> ?p ?nb \\<or>\n   \\<not> ?nc \\<le> ?nb \\<or> \\<not> ?p (nn ?nc ?nb ?p) \\<or> ?p ?nc) \\<and>\n  (\\<not> ?p ?nb \\<or>\n   \\<not> ?nc \\<le> ?nb \\<or> ?p ?nc \\<or> ?p (Suc (nn ?nc ?nb ?p)))\n\ngoal (1 subgoal):\n 1. \\<And>p. \\<not> p k \\<or> p j \\<or> p (Suc (nn j k p))", "using a1"], ["proof (prove)\nusing this:\n  (\\<not> ?n \\<le> ?na \\<or> Suc ?n \\<le> Suc ?na) \\<and>\n  (\\<not> ?p ?nb \\<or>\n   \\<not> ?nc \\<le> ?nb \\<or> \\<not> ?p (nn ?nc ?nb ?p) \\<or> ?p ?nc) \\<and>\n  (\\<not> ?p ?nb \\<or>\n   \\<not> ?nc \\<le> ?nb \\<or> ?p ?nc \\<or> ?p (Suc (nn ?nc ?nb ?p)))\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>p. \\<not> p k \\<or> p j \\<or> p (Suc (nn j k p))", "by presburger"], ["proof (state)\nthis:\n  \\<not> ?p k \\<or> ?p j \\<or> ?p (Suc (nn j k ?p))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "have f6: \"\\<And>p. \\<not> p k \\<or> \\<not> p (nn j k p) \\<or> p j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. \\<not> p k \\<or> \\<not> p (nn j k p) \\<or> p j", "using f4 a1"], ["proof (prove)\nusing this:\n  (\\<not> ?n \\<le> ?na \\<or> Suc ?n \\<le> Suc ?na) \\<and>\n  (\\<not> ?p ?nb \\<or>\n   \\<not> ?nc \\<le> ?nb \\<or> \\<not> ?p (nn ?nc ?nb ?p) \\<or> ?p ?nc) \\<and>\n  (\\<not> ?p ?nb \\<or>\n   \\<not> ?nc \\<le> ?nb \\<or> ?p ?nc \\<or> ?p (Suc (nn ?nc ?nb ?p)))\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>p. \\<not> p k \\<or> \\<not> p (nn j k p) \\<or> p j", "by meson"], ["proof (state)\nthis:\n  \\<not> ?p k \\<or> \\<not> ?p (nn j k ?p) \\<or> ?p j\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "{"], ["proof (state)\nthis:\n  \\<not> ?p k \\<or> \\<not> ?p (nn j k ?p) \\<or> ?p j\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "assume \"nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A) < dim_row A \\<and> f (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq> dim_col A\""], ["proof (state)\nthis:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "moreover"], ["proof (state)\nthis:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "{"], ["proof (state)\nthis:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "assume \"(nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A) < dim_row A \\<and> f (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq> dim_col A) \\<and> (\\<not> j < dim_row A \\<or> f j = dim_col A)\""], ["proof (state)\nthis:\n  (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n   < dim_row A \\<and>\n   f (nn j k\n       (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n   dim_col A) \\<and>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "then"], ["proof (chain)\npicking this:\n  (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n   < dim_row A \\<and>\n   f (nn j k\n       (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n   dim_col A) \\<and>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A)", "have \"\\<not> k < dim_row A \\<or> f k = dim_col A\""], ["proof (prove)\nusing this:\n  (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n   < dim_row A \\<and>\n   f (nn j k\n       (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n   dim_col A) \\<and>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A)\n\ngoal (1 subgoal):\n 1. \\<not> k < dim_row A \\<or> f k = dim_col A", "using f6"], ["proof (prove)\nusing this:\n  (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n   < dim_row A \\<and>\n   f (nn j k\n       (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n   dim_col A) \\<and>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A)\n  \\<not> ?p k \\<or> \\<not> ?p (nn j k ?p) \\<or> ?p j\n\ngoal (1 subgoal):\n 1. \\<not> k < dim_row A \\<or> f k = dim_col A", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "}"], ["proof (state)\nthis:\n  (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n   < dim_row A \\<and>\n   f (nn j k\n       (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n   dim_col A) \\<and>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<Longrightarrow>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "ultimately"], ["proof (chain)\npicking this:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A\n  (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n   < dim_row A \\<and>\n   f (nn j k\n       (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n   dim_col A) \\<and>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<Longrightarrow>\n  \\<not> k < dim_row A \\<or> f k = dim_col A", "have \"(\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and> (\\<not> Suc (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) < dim_row A \\<or> f (Suc (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) = dim_col A) \\<or> \\<not> k < dim_row A \\<or> f k = dim_col A\""], ["proof (prove)\nusing this:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A\n  (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n   < dim_row A \\<and>\n   f (nn j k\n       (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n   dim_col A) \\<and>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<Longrightarrow>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal (1 subgoal):\n 1. (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n    (\\<not> Suc (nn j k\n                  (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n            < dim_row A \\<or>\n     f (Suc (nn j k\n              (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n     dim_col A) \\<or>\n    \\<not> k < dim_row A \\<or> f k = dim_col A", "using bad_asm"], ["proof (prove)\nusing this:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A\n  (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n   < dim_row A \\<and>\n   f (nn j k\n       (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n   dim_col A) \\<and>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<Longrightarrow>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n  f j = dim_col A\n\ngoal (1 subgoal):\n 1. (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n    (\\<not> Suc (nn j k\n                  (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n            < dim_row A \\<or>\n     f (Suc (nn j k\n              (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n     dim_col A) \\<or>\n    \\<not> k < dim_row A \\<or> f k = dim_col A", "by blast"], ["proof (state)\nthis:\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<or>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "}"], ["proof (state)\nthis:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A \\<Longrightarrow>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<or>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "moreover"], ["proof (state)\nthis:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A \\<Longrightarrow>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<or>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "{"], ["proof (state)\nthis:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A \\<Longrightarrow>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<or>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "assume \"(\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and> (\\<not> Suc (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) < dim_row A \\<or> f (Suc (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) = dim_col A)\""], ["proof (state)\nthis:\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "then"], ["proof (chain)\npicking this:\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A)", "have \"\\<not> k < dim_row A \\<or> f k = dim_col A\""], ["proof (prove)\nusing this:\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A)\n\ngoal (1 subgoal):\n 1. \\<not> k < dim_row A \\<or> f k = dim_col A", "using f5"], ["proof (prove)\nusing this:\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A)\n  \\<not> ?p k \\<or> ?p j \\<or> ?p (Suc (nn j k ?p))\n\ngoal (1 subgoal):\n 1. \\<not> k < dim_row A \\<or> f k = dim_col A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n             (\\<not> Suc (nn j k\n                           (\\<lambda>n.\n                               n < dim_row A \\<and> f n \\<noteq> dim_col A))\n                     < dim_row A \\<or>\n              f (Suc (nn j k\n                       (\\<lambda>n.\n                           n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n              dim_col A);\n     \\<And>p. \\<not> p k \\<or> p j \\<or> p (Suc (nn j k p))\\<rbrakk>\n    \\<Longrightarrow> \\<not> k < dim_row A \\<or> f k = dim_col A", "have \"\\<not> (Suc (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) < dim_row A \\<and> f (Suc (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) \\<noteq> dim_col A) \\<and> \\<not> (j < dim_row A \\<and> f j \\<noteq> dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (Suc (nn j k\n                  (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n            < dim_row A \\<and>\n            f (Suc (nn j k\n                     (\\<lambda>n.\n                         n < dim_row A \\<and>\n                         f n \\<noteq> dim_col A))) \\<noteq>\n            dim_col A) \\<and>\n    \\<not> (j < dim_row A \\<and> f j \\<noteq> dim_col A)", "using \\<open>(\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and> (\\<not> Suc (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) < dim_row A \\<or> f (Suc (nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) = dim_col A)\\<close>"], ["proof (prove)\nusing this:\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A)\n\ngoal (1 subgoal):\n 1. \\<not> (Suc (nn j k\n                  (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n            < dim_row A \\<and>\n            f (Suc (nn j k\n                     (\\<lambda>n.\n                         n < dim_row A \\<and>\n                         f n \\<noteq> dim_col A))) \\<noteq>\n            dim_col A) \\<and>\n    \\<not> (j < dim_row A \\<and> f j \\<noteq> dim_col A)", "by linarith"], ["proof (state)\nthis:\n  \\<not> (Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<and>\n          f (Suc (nn j k\n                   (\\<lambda>n.\n                       n < dim_row A \\<and>\n                       f n \\<noteq> dim_col A))) \\<noteq>\n          dim_col A) \\<and>\n  \\<not> (j < dim_row A \\<and> f j \\<noteq> dim_col A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n             (\\<not> Suc (nn j k\n                           (\\<lambda>n.\n                               n < dim_row A \\<and> f n \\<noteq> dim_col A))\n                     < dim_row A \\<or>\n              f (Suc (nn j k\n                       (\\<lambda>n.\n                           n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n              dim_col A);\n     \\<And>p. \\<not> p k \\<or> p j \\<or> p (Suc (nn j k p))\\<rbrakk>\n    \\<Longrightarrow> \\<not> k < dim_row A \\<or> f k = dim_col A", "then"], ["proof (chain)\npicking this:\n  \\<not> (Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<and>\n          f (Suc (nn j k\n                   (\\<lambda>n.\n                       n < dim_row A \\<and>\n                       f n \\<noteq> dim_col A))) \\<noteq>\n          dim_col A) \\<and>\n  \\<not> (j < dim_row A \\<and> f j \\<noteq> dim_col A)", "have \"\\<not> (k < dim_row A \\<and> f k \\<noteq> dim_col A)\""], ["proof (prove)\nusing this:\n  \\<not> (Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<and>\n          f (Suc (nn j k\n                   (\\<lambda>n.\n                       n < dim_row A \\<and>\n                       f n \\<noteq> dim_col A))) \\<noteq>\n          dim_col A) \\<and>\n  \\<not> (j < dim_row A \\<and> f j \\<noteq> dim_col A)\n\ngoal (1 subgoal):\n 1. \\<not> (k < dim_row A \\<and> f k \\<noteq> dim_col A)", "by (metis (mono_tags, lifting) a2 bad_asm f5 le_less)"], ["proof (state)\nthis:\n  \\<not> (k < dim_row A \\<and> f k \\<noteq> dim_col A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n             (\\<not> Suc (nn j k\n                           (\\<lambda>n.\n                               n < dim_row A \\<and> f n \\<noteq> dim_col A))\n                     < dim_row A \\<or>\n              f (Suc (nn j k\n                       (\\<lambda>n.\n                           n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n              dim_col A);\n     \\<And>p. \\<not> p k \\<or> p j \\<or> p (Suc (nn j k p))\\<rbrakk>\n    \\<Longrightarrow> \\<not> k < dim_row A \\<or> f k = dim_col A", "then"], ["proof (chain)\npicking this:\n  \\<not> (k < dim_row A \\<and> f k \\<noteq> dim_col A)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (k < dim_row A \\<and> f k \\<noteq> dim_col A)\n\ngoal (1 subgoal):\n 1. \\<not> k < dim_row A \\<or> f k = dim_col A", "by meson"], ["proof (state)\nthis:\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "}"], ["proof (state)\nthis:\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<Longrightarrow>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>j \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "ultimately"], ["proof (chain)\npicking this:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A \\<Longrightarrow>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<or>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<Longrightarrow>\n  \\<not> k < dim_row A \\<or> f k = dim_col A", "show \"f k = dim_col A\""], ["proof (prove)\nusing this:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A \\<Longrightarrow>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<or>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<Longrightarrow>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n\ngoal (1 subgoal):\n 1. f k = dim_col A", "using f3 a2"], ["proof (prove)\nusing this:\n  nn j k (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)\n  < dim_row A \\<and>\n  f (nn j k\n      (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A)) \\<noteq>\n  dim_col A \\<Longrightarrow>\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<or>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n  (\\<not> j < dim_row A \\<or> f j = dim_col A) \\<and>\n  (\\<not> Suc (nn j k\n                (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))\n          < dim_row A \\<or>\n   f (Suc (nn j k\n            (\\<lambda>n. n < dim_row A \\<and> f n \\<noteq> dim_col A))) =\n   dim_col A) \\<Longrightarrow>\n  \\<not> k < dim_row A \\<or> f k = dim_col A\n  \\<not> ?n < dim_row A \\<or>\n  f ?n \\<noteq> f j \\<or> \\<not> Suc ?n < dim_row A \\<or> f (Suc ?n) = f j\n  k < dim_row A\n\ngoal (1 subgoal):\n 1. f k = dim_col A", "by (metis (lifting) Suc_lessD bad_asm)"], ["proof (state)\nthis:\n  f k = dim_col A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>j \\<le> ?k; ?k < dim_row A\\<rbrakk>\n  \\<Longrightarrow> f ?k = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>f i \\<noteq> dim_col A; j \\<le> i; f j = dim_col A\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>j \\<le> ?k; ?k < dim_row A\\<rbrakk>\n  \\<Longrightarrow> f ?k = dim_col A", "show \"False\""], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<le> ?k; ?k < dim_row A\\<rbrakk>\n  \\<Longrightarrow> f ?k = dim_col A\n\ngoal (1 subgoal):\n 1. False", "using lt_i not_i"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<le> ?k; ?k < dim_row A\\<rbrakk>\n  \\<Longrightarrow> f ?k = dim_col A\n  i < dim_row A\n  f i \\<noteq> dim_col A\n\ngoal (1 subgoal):\n 1. False", "using j_leq"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<le> ?k; ?k < dim_row A\\<rbrakk>\n  \\<Longrightarrow> f ?k = dim_col A\n  i < dim_row A\n  f i \\<noteq> dim_col A\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  (\\<forall>j\\<le>i. f j \\<noteq> dim_col A)\n\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "have \"f i \\<noteq> ?nc \\<longrightarrow> ({0..<?ip} \\<subseteq> {y. y < ?nr \\<and> f y \\<noteq> dim_col A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<noteq> dim_col A \\<longrightarrow>\n    {0..<i + 1} \\<subseteq> {y. y < dim_row A \\<and> f y \\<noteq> dim_col A}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f i \\<noteq> dim_col A \\<longrightarrow>\n    {0..<i + 1} \\<subseteq> {y. y < dim_row A \\<and> f y \\<noteq> dim_col A}", "have h1: \"f i \\<noteq> dim_col A \\<longrightarrow> (\\<forall>j\\<le>i. j < ?nr \\<and> f j \\<noteq> dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<noteq> dim_col A \\<longrightarrow>\n    (\\<forall>j\\<le>i. j < dim_row A \\<and> f j \\<noteq> dim_col A)", "using if_then_bad lt_i"], ["proof (prove)\nusing this:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  (\\<forall>j\\<le>i. f j \\<noteq> dim_col A)\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. f i \\<noteq> dim_col A \\<longrightarrow>\n    (\\<forall>j\\<le>i. j < dim_row A \\<and> f j \\<noteq> dim_col A)", "by auto"], ["proof (state)\nthis:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  (\\<forall>j\\<le>i. j < dim_row A \\<and> f j \\<noteq> dim_col A)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> dim_col A \\<longrightarrow>\n    {0..<i + 1} \\<subseteq> {y. y < dim_row A \\<and> f y \\<noteq> dim_col A}", "then"], ["proof (chain)\npicking this:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  (\\<forall>j\\<le>i. j < dim_row A \\<and> f j \\<noteq> dim_col A)", "show ?thesis"], ["proof (prove)\nusing this:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  (\\<forall>j\\<le>i. j < dim_row A \\<and> f j \\<noteq> dim_col A)\n\ngoal (1 subgoal):\n 1. f i \\<noteq> dim_col A \\<longrightarrow>\n    {0..<i + 1} \\<subseteq> {y. y < dim_row A \\<and> f y \\<noteq> dim_col A}", "by auto"], ["proof (state)\nthis:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  {0..<i + 1} \\<subseteq> {y. y < dim_row A \\<and> f y \\<noteq> dim_col A}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  {0..<i + 1} \\<subseteq> {y. y < dim_row A \\<and> f y \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "then"], ["proof (chain)\npicking this:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  {0..<i + 1} \\<subseteq> {y. y < dim_row A \\<and> f y \\<noteq> dim_col A}", "have gteq: \"f i \\<noteq> ?nc \\<longrightarrow> (card {i. i < ?nr \\<and> f i \\<noteq> dim_col A} \\<ge> (i+1))\""], ["proof (prove)\nusing this:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  {0..<i + 1} \\<subseteq> {y. y < dim_row A \\<and> f y \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. f i \\<noteq> dim_col A \\<longrightarrow>\n    i + 1 \\<le> card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}", "using card_lessThan[of ?ip] card_mono[where B = \"{i. i < ?nr \\<and> f i \\<noteq> dim_col A} \", where A = \"{0..<?ip}\"]"], ["proof (prove)\nusing this:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  {0..<i + 1} \\<subseteq> {y. y < dim_row A \\<and> f y \\<noteq> dim_col A}\n  card {..<i + 1} = i + 1\n  \\<lbrakk>finite {i. i < dim_row A \\<and> f i \\<noteq> dim_col A};\n   {0..<i + 1}\n   \\<subseteq> {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\\<rbrakk>\n  \\<Longrightarrow> card {0..<i + 1}\n                    \\<le> card\n                           {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. f i \\<noteq> dim_col A \\<longrightarrow>\n    i + 1 \\<le> card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}", "by auto"], ["proof (state)\nthis:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  i + 1 \\<le> card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "then"], ["proof (chain)\npicking this:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  i + 1 \\<le> card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}", "have clear: \"dim_row (take_rows A [0..<length (pivot_positions A)]) = length (pivot_positions A)\""], ["proof (prove)\nusing this:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  i + 1 \\<le> card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. dim_row (take_rows A [0..<length (pivot_positions A)]) =\n    length (pivot_positions A)", "unfolding take_rows_def"], ["proof (prove)\nusing this:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  i + 1 \\<le> card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. dim_row\n     (mat_of_rows (dim_col A)\n       (map ((!) (rows A))\n         (filter (\\<lambda>y. y < dim_row A)\n           [0..<length (pivot_positions A)]))) =\n    length (pivot_positions A)", "using dim_asm fileq"], ["proof (prove)\nusing this:\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  i + 1 \\<le> card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n  dim_row A \\<le> dim_col A\n  filter (\\<lambda>y. y < dim_row A) [0..<length (pivot_positions A)] =\n  [0..<length (pivot_positions A)]\n\ngoal (1 subgoal):\n 1. dim_row\n     (mat_of_rows (dim_col A)\n       (map ((!) (rows A))\n         (filter (\\<lambda>y. y < dim_row A)\n           [0..<length (pivot_positions A)]))) =\n    length (pivot_positions A)", "by (auto)"], ["proof (state)\nthis:\n  dim_row (take_rows A [0..<length (pivot_positions A)]) =\n  length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "have \"i + 1 > length (pivot_positions A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pivot_positions A) < i + 1", "using not_lt clear"], ["proof (prove)\nusing this:\n  \\<not> i < dim_row (take_rows A [0..<length (pivot_positions A)])\n  dim_row (take_rows A [0..<length (pivot_positions A)]) =\n  length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) < i + 1", "by auto"], ["proof (state)\nthis:\n  length (pivot_positions A) < i + 1\n\ngoal (1 subgoal):\n 1. \\<And>f. pivot_fun A f (dim_col A) \\<Longrightarrow> f i = dim_col A", "then"], ["proof (chain)\npicking this:\n  length (pivot_positions A) < i + 1", "show \"f i = ?nc\""], ["proof (prove)\nusing this:\n  length (pivot_positions A) < i + 1\n\ngoal (1 subgoal):\n 1. f i = dim_col A", "using gteq len_pp_var"], ["proof (prove)\nusing this:\n  length (pivot_positions A) < i + 1\n  f i \\<noteq> dim_col A \\<longrightarrow>\n  i + 1 \\<le> card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. f i = dim_col A", "by auto"], ["proof (state)\nthis:\n  f i = dim_col A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f. pivot_fun A f (dim_col A) \\<longrightarrow> f i = dim_col A\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A", "using half1 half2"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n  \\<forall>f. pivot_fun A f (dim_col A) \\<longrightarrow> f i = dim_col A\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A", "have h1a: \"row A i =  0\\<^sub>v (dim_col A)\""], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A\n\ngoal (1 subgoal):\n 1. row A i = 0\\<^sub>v (dim_col A)", "using pivot_fun_zero_row_iff[of A _ ?nc ?nr]"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A\n  \\<lbrakk>pivot_fun A ?f (dim_col A);\n   A \\<in> carrier_mat (dim_row A) (dim_col A); ?i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> (?f ?i = dim_col A) = (row A ?i = 0\\<^sub>v (dim_col A))\n\ngoal (1 subgoal):\n 1. row A i = 0\\<^sub>v (dim_col A)", "using lt_i"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A) \\<and> f i = dim_col A\n  \\<lbrakk>pivot_fun A ?f (dim_col A);\n   A \\<in> carrier_mat (dim_row A) (dim_col A); ?i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> (?f ?i = dim_col A) = (row A ?i = 0\\<^sub>v (dim_col A))\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. row A i = 0\\<^sub>v (dim_col A)", "by blast"], ["proof (state)\nthis:\n  row A i = 0\\<^sub>v (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  row A i = 0\\<^sub>v (dim_col A)", "have h1: \"A $$ (i, j) = 0\""], ["proof (prove)\nusing this:\n  row A i = 0\\<^sub>v (dim_col A)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a)", "using index_row(1) lt_i lt_j"], ["proof (prove)\nusing this:\n  row A i = 0\\<^sub>v (dim_col A)\n  \\<lbrakk>?i < dim_row ?A; ?j < dim_col ?A\\<rbrakk>\n  \\<Longrightarrow> row ?A ?i $ ?j = ?A $$ (?i, ?j)\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "have h2a: \"i - dim_row (take_rows A [0..<length (pivot_positions A)]) < dim_row A - length (pivot_positions A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - dim_row (take_rows A [0..<length (pivot_positions A)])\n    < dim_row A - length (pivot_positions A)", "using pivot_len lt_i not_lt"], ["proof (prove)\nusing this:\n  length (pivot_positions A) \\<le> dim_row A\n  i < dim_row A\n  \\<not> i < dim_row (take_rows A [0..<length (pivot_positions A)])\n\ngoal (1 subgoal):\n 1. i - dim_row (take_rows A [0..<length (pivot_positions A)])\n    < dim_row A - length (pivot_positions A)", "by (simp add: take_rows_def)"], ["proof (state)\nthis:\n  i - dim_row (take_rows A [0..<length (pivot_positions A)])\n  < dim_row A - length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  i - dim_row (take_rows A [0..<length (pivot_positions A)])\n  < dim_row A - length (pivot_positions A)", "have h2: \"0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n           (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) = 0 \""], ["proof (prove)\nusing this:\n  i - dim_row (take_rows A [0..<length (pivot_positions A)])\n  < dim_row A - length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n    (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n    (0::'b)", "unfolding zero_mat_def"], ["proof (prove)\nusing this:\n  i - dim_row (take_rows A [0..<length (pivot_positions A)])\n  < dim_row A - length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. mat (dim_row A - length (pivot_positions A)) (dim_col A)\n     (\\<lambda>ij. 0::'b) $$\n    (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n    (0::'b)", "using pivot_len lt_i lt_j"], ["proof (prove)\nusing this:\n  i - dim_row (take_rows A [0..<length (pivot_positions A)])\n  < dim_row A - length (pivot_positions A)\n  length (pivot_positions A) \\<le> dim_row A\n  i < dim_row A\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. mat (dim_row A - length (pivot_positions A)) (dim_col A)\n     (\\<lambda>ij. 0::'b) $$\n    (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n    (0::'b)", "using index_mat(1)"], ["proof (prove)\nusing this:\n  i - dim_row (take_rows A [0..<length (pivot_positions A)])\n  < dim_row A - length (pivot_positions A)\n  length (pivot_positions A) \\<le> dim_row A\n  i < dim_row A\n  j < dim_col A\n  \\<lbrakk>?i < ?nr; ?j < ?nc\\<rbrakk>\n  \\<Longrightarrow> mat ?nr ?nc ?f $$ (?i, ?j) = ?f (?i, ?j)\n\ngoal (1 subgoal):\n 1. mat (dim_row A - length (pivot_positions A)) (dim_col A)\n     (\\<lambda>ij. 0::'b) $$\n    (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n    (0::'b)", "by blast"], ["proof (state)\nthis:\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n  (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n  (0::?'b1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A;\n        \\<not> i < dim_row\n                    (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n       \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                          (dim_col A) $$\n                         (i -\n                          dim_row\n                           (take_rows A [0..<length (pivot_positions A)]),\n                          j) =\n                         A $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n  (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n  (0::?'b1)", "show \"0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n           (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n           A $$ (i, j)\""], ["proof (prove)\nusing this:\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n  (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n  (0::?'b1)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n    (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n    A $$ (i, j)", "using h1 h2"], ["proof (prove)\nusing this:\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n  (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n  (0::?'b1)\n  A $$ (i, j) = (0::'a)\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n  (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n  (0::?'b1)\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n    (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n    A $$ (i, j)", "by simp"], ["proof (state)\nthis:\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) $$\n  (i - dim_row (take_rows A [0..<length (pivot_positions A)]), j) =\n  A $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < dim_row A; ?j < dim_col A;\n   \\<not> ?i < dim_row\n                (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n  \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                     (dim_col A) $$\n                    (?i -\n                     dim_row (take_rows A [0..<length (pivot_positions A)]),\n                     ?j) =\n                    A $$ (?i, ?j)\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "have h3: \"(dim_row (take_rows A [0..<length (pivot_positions A)])::nat) + ((dim_row A::nat) - (length (pivot_positions A)::nat)) =\n    dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (take_rows A [0..<length (pivot_positions A)]) +\n    (dim_row A - length (pivot_positions A)) =\n    dim_row A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dim_row (take_rows A [0..<length (pivot_positions A)]) +\n    (dim_row A - length (pivot_positions A)) =\n    dim_row A", "have h0: \"dim_row (take_rows A [0..<length (pivot_positions A)]) = (length (pivot_positions A)::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (take_rows A [0..<length (pivot_positions A)]) =\n    length (pivot_positions A)", "by (simp add: take_rows_def fileq)"], ["proof (state)\nthis:\n  dim_row (take_rows A [0..<length (pivot_positions A)]) =\n  length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. dim_row (take_rows A [0..<length (pivot_positions A)]) +\n    (dim_row A - length (pivot_positions A)) =\n    dim_row A", "then"], ["proof (chain)\npicking this:\n  dim_row (take_rows A [0..<length (pivot_positions A)]) =\n  length (pivot_positions A)", "show ?thesis"], ["proof (prove)\nusing this:\n  dim_row (take_rows A [0..<length (pivot_positions A)]) =\n  length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. dim_row (take_rows A [0..<length (pivot_positions A)]) +\n    (dim_row A - length (pivot_positions A)) =\n    dim_row A", "using add_diff_inverse_nat  pivot_len"], ["proof (prove)\nusing this:\n  dim_row (take_rows A [0..<length (pivot_positions A)]) =\n  length (pivot_positions A)\n  \\<not> ?m < ?n \\<Longrightarrow> ?n + (?m - ?n) = ?m\n  length (pivot_positions A) \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. dim_row (take_rows A [0..<length (pivot_positions A)]) +\n    (dim_row A - length (pivot_positions A)) =\n    dim_row A", "by linarith"], ["proof (state)\nthis:\n  dim_row (take_rows A [0..<length (pivot_positions A)]) +\n  (dim_row A - length (pivot_positions A)) =\n  dim_row A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dim_row (take_rows A [0..<length (pivot_positions A)]) +\n  (dim_row A - length (pivot_positions A)) =\n  dim_row A\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "have h4: \" \\<And>i j. i < dim_row A \\<Longrightarrow>\n           j < dim_col A \\<Longrightarrow>\n           i < dim_row (take_rows A [0..<length (pivot_positions A)]) +\n               (dim_row A - length (pivot_positions A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> i < dim_row\n                              (take_rows A\n                                [0..<length (pivot_positions A)]) +\n                             (dim_row A - length (pivot_positions A))", "using pivot_len"], ["proof (prove)\nusing this:\n  length (pivot_positions A) \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> i < dim_row\n                              (take_rows A\n                                [0..<length (pivot_positions A)]) +\n                             (dim_row A - length (pivot_positions A))", "by (simp add: h3)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < dim_row A; ?j < dim_col A\\<rbrakk>\n  \\<Longrightarrow> ?i < dim_row\n                          (take_rows A [0..<length (pivot_positions A)]) +\n                         (dim_row A - length (pivot_positions A))\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < dim_row A; ?j < dim_col A\\<rbrakk>\n  \\<Longrightarrow> ?i < dim_row\n                          (take_rows A [0..<length (pivot_positions A)]) +\n                         (dim_row A - length (pivot_positions A))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < dim_row A; ?j < dim_col A\\<rbrakk>\n  \\<Longrightarrow> ?i < dim_row\n                          (take_rows A [0..<length (pivot_positions A)]) +\n                         (dim_row A - length (pivot_positions A))\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "apply (subst mat_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n        \\<Longrightarrow> i < dim_row\n                               (take_rows A\n                                 [0..<length (pivot_positions A)]) +\n                              (dim_row A -\n                               length\n                                (pivot_positions A))) \\<Longrightarrow>\n    dim_row\n     (take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)) =\n    dim_row A \\<and>\n    dim_col\n     (take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)) =\n    dim_col A \\<and>\n    (\\<forall>i j.\n        i < dim_row A \\<longrightarrow>\n        j < dim_col A \\<longrightarrow>\n        (take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n         0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)) $$\n        (i, j) =\n        A $$ (i, j))", "using h1 h2 h3 h4"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < dim_row A; ?j < dim_col A;\n   ?i < dim_row (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n  \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] $$\n                    (?i, ?j) =\n                    A $$ (?i, ?j)\n  \\<lbrakk>?i < dim_row A; ?j < dim_col A;\n   \\<not> ?i < dim_row\n                (take_rows A [0..<length (pivot_positions A)])\\<rbrakk>\n  \\<Longrightarrow> 0\\<^sub>m (dim_row A - length (pivot_positions A))\n                     (dim_col A) $$\n                    (?i -\n                     dim_row (take_rows A [0..<length (pivot_positions A)]),\n                     ?j) =\n                    A $$ (?i, ?j)\n  dim_row (take_rows A [0..<length (pivot_positions A)]) +\n  (dim_row A - length (pivot_positions A)) =\n  dim_row A\n  \\<lbrakk>?i < dim_row A; ?j < dim_col A\\<rbrakk>\n  \\<Longrightarrow> ?i < dim_row\n                          (take_rows A [0..<length (pivot_positions A)]) +\n                         (dim_row A - length (pivot_positions A))\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n        \\<Longrightarrow> i < dim_row\n                               (take_rows A\n                                 [0..<length (pivot_positions A)]) +\n                              (dim_row A -\n                               length\n                                (pivot_positions A))) \\<Longrightarrow>\n    dim_row\n     (take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)) =\n    dim_row A \\<and>\n    dim_col\n     (take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)) =\n    dim_col A \\<and>\n    (\\<forall>i j.\n        i < dim_row A \\<longrightarrow>\n        j < dim_col A \\<longrightarrow>\n        (take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n         0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)) $$\n        (i, j) =\n        A $$ (i, j))", "by (auto simp add: append_rows_def)"], ["proof (state)\nthis:\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n  A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_pivot_positions_dim_row:\n  assumes \"row_echelon_form A\"\n  shows \"length (pivot_positions A) \\<le> dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "have 1: \"A \\<in> carrier_mat (dim_row A) (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat (dim_row A) (dim_col A)", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat (dim_row A) (dim_col A)\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "obtain f where 2: \"pivot_fun A f (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        pivot_fun A f (dim_col A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms row_echelon_form_def"], ["proof (prove)\nusing this:\n  row_echelon_form A\n  row_echelon_form ?A \\<equiv> \\<exists>f. pivot_fun ?A f (dim_col ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        pivot_fun A f (dim_col A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "from pivot_positions(4)[OF 1 2]"], ["proof (chain)\npicking this:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "have\n    \"length (pivot_positions A) = card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\""], ["proof (prove)\nusing this:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "."], ["proof (state)\nthis:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "also"], ["proof (state)\nthis:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "have \"... \\<le> card {i. i < dim_row A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<le> card {i. i < dim_row A}", "apply (rule card_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {i. i < dim_row A}\n 2. {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<subseteq> {i. i < dim_row A}", "by auto"], ["proof (state)\nthis:\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> card {i. i < dim_row A}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "ultimately"], ["proof (chain)\npicking this:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> card {i. i < dim_row A}", "show ?thesis"], ["proof (prove)\nusing this:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> card {i. i < dim_row A}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A", "by auto"], ["proof (state)\nthis:\n  length (pivot_positions A) \\<le> dim_row A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rref_pivot_positions:\n  assumes \"row_echelon_form R\"\n  assumes R: \"R \\<in> carrier_mat nr nc\"\n  shows \"\\<And>i j. (i,j) \\<in> set (pivot_positions R) \\<Longrightarrow> i < nr \\<and> j < nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (i, j) \\<in> set (pivot_positions R) \\<Longrightarrow>\n       i < nr \\<and> j < nc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (i, j) \\<in> set (pivot_positions R) \\<Longrightarrow>\n       i < nr \\<and> j < nc", "obtain f where f: \"pivot_fun R f nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. pivot_fun R f nc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) assms(2) row_echelon_form_def"], ["proof (prove)\nusing this:\n  row_echelon_form R\n  R \\<in> carrier_mat nr nc\n  row_echelon_form ?A \\<equiv> \\<exists>f. pivot_fun ?A f (dim_col ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>f. pivot_fun R f nc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pivot_fun R f nc\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (i, j) \\<in> set (pivot_positions R) \\<Longrightarrow>\n       i < nr \\<and> j < nc", "have *: \"\\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc", "using f"], ["proof (prove)\nusing this:\n  pivot_fun R f nc\n\ngoal (1 subgoal):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc", "using R pivot_funD(1)"], ["proof (prove)\nusing this:\n  pivot_fun R f nc\n  R \\<in> carrier_mat nr nc\n  \\<lbrakk>dim_row ?A = ?nr; pivot_fun ?A ?f ?nc; ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> ?f ?i \\<le> ?nc\n\ngoal (1 subgoal):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc", "by blast"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> nc\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (i, j) \\<in> set (pivot_positions R) \\<Longrightarrow>\n       i < nr \\<and> j < nc", "from pivot_positions[OF R f]"], ["proof (chain)\npicking this:\n  set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}\n  distinct (map fst (pivot_positions R))\n  distinct (map snd (pivot_positions R))\n  length (pivot_positions R) =\n  card {i. i < nr \\<and> row R i \\<noteq> 0\\<^sub>v nc}", "have \"set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}\""], ["proof (prove)\nusing this:\n  set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}\n  distinct (map fst (pivot_positions R))\n  distinct (map snd (pivot_positions R))\n  length (pivot_positions R) =\n  card {i. i < nr \\<and> row R i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}", "by auto"], ["proof (state)\nthis:\n  set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (i, j) \\<in> set (pivot_positions R) \\<Longrightarrow>\n       i < nr \\<and> j < nc", "then"], ["proof (chain)\npicking this:\n  set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}", "have **: \"set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i < nc}\""], ["proof (prove)\nusing this:\n  set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}\n\ngoal (1 subgoal):\n 1. set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i < nc}", "using *"], ["proof (prove)\nusing this:\n  set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}\n  ?i < nr \\<Longrightarrow> f ?i \\<le> nc\n\ngoal (1 subgoal):\n 1. set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i < nc}", "by fastforce"], ["proof (state)\nthis:\n  set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i < nc}\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (i, j) \\<in> set (pivot_positions R) \\<Longrightarrow>\n       i < nr \\<and> j < nc", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (i, j) \\<in> set (pivot_positions R) \\<Longrightarrow>\n       i < nr \\<and> j < nc", "assume \"(i, j) \\<in> set (pivot_positions R)\""], ["proof (state)\nthis:\n  (i, j) \\<in> set (pivot_positions R)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (i, j) \\<in> set (pivot_positions R) \\<Longrightarrow>\n       i < nr \\<and> j < nc", "thus \"i < nr \\<and> j < nc\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> set (pivot_positions R)\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc", "using **"], ["proof (prove)\nusing this:\n  (i, j) \\<in> set (pivot_positions R)\n  set (pivot_positions R) = {(i, f i) |i. i < nr \\<and> f i < nc}\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc", "by simp"], ["proof (state)\nthis:\n  i < nr \\<and> j < nc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pivot_fun_monoton: \n  assumes pf: \"pivot_fun A f (dim_col A)\"\n  assumes dr: \"dim_row A = nr\"\n  shows \"\\<And> i. i < nr \\<Longrightarrow> (\\<And> k. ((k < nr \\<and> i < k) \\<longrightarrow> f i \\<le> f k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<And>k. k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<And>k. k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<And>k. k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k)", "assume \"i < nr\""], ["proof (state)\nthis:\n  i < nr\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (\\<And>k. k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k)", "show \"(\\<And> k. ((k < nr \\<and> i < k) \\<longrightarrow> f i \\<le> f k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k", "show \"((k < nr \\<and> i < k) \\<longrightarrow> f i \\<le> f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < nr \\<and> i < 0 \\<longrightarrow> f i \\<le> f 0\n 2. \\<And>k.\n       k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k \\<Longrightarrow>\n       Suc k < nr \\<and> i < Suc k \\<longrightarrow> f i \\<le> f (Suc k)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 < nr \\<and> i < 0 \\<longrightarrow> f i \\<le> f 0\n 2. \\<And>k.\n       k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k \\<Longrightarrow>\n       Suc k < nr \\<and> i < Suc k \\<longrightarrow> f i \\<le> f (Suc k)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < nr \\<and> i < 0 \\<longrightarrow> f i \\<le> f 0", "by blast"], ["proof (state)\nthis:\n  0 < nr \\<and> i < 0 \\<longrightarrow> f i \\<le> f 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k \\<Longrightarrow>\n       Suc k < nr \\<and> i < Suc k \\<longrightarrow> f i \\<le> f (Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k \\<Longrightarrow>\n       Suc k < nr \\<and> i < Suc k \\<longrightarrow> f i \\<le> f (Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k \\<Longrightarrow>\n       Suc k < nr \\<and> i < Suc k \\<longrightarrow> f i \\<le> f (Suc k)", "then"], ["proof (chain)\npicking this:\n  k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k", "show ?case"], ["proof (prove)\nusing this:\n  k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k\n\ngoal (1 subgoal):\n 1. Suc k < nr \\<and> i < Suc k \\<longrightarrow> f i \\<le> f (Suc k)", "by (smt dr le_less_trans less_Suc_eq less_imp_le_nat pf pivot_funD(1) pivot_funD(3))"], ["proof (state)\nthis:\n  Suc k < nr \\<and> i < Suc k \\<longrightarrow> f i \\<le> f (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k < nr \\<and> i < k \\<longrightarrow> f i \\<le> f k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k < nr \\<and> i < ?k \\<longrightarrow> f i \\<le> f ?k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pivot_positions_contains:\n  assumes row_ech: \"row_echelon_form A\"\n  assumes dim_h: \"dim_col A \\<ge> dim_row A\"\n  assumes \"pivot_fun A f (dim_col A)\"\n  shows \"\\<forall>i < (length (pivot_positions A)). (i, f i) \\<in> set (pivot_positions A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "let ?nr = \"dim_row A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "let ?nc = \"dim_col A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "let ?pp = \"pivot_positions A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "have i_nr: \"\\<forall>i < (length ?pp). i < ?nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A). i < dim_row A", "using rref_pivot_positions assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>row_echelon_form ?R; ?R \\<in> carrier_mat ?nr ?nc;\n   (?i, ?j) \\<in> set (pivot_positions ?R)\\<rbrakk>\n  \\<Longrightarrow> ?i < ?nr \\<and> ?j < ?nc\n  row_echelon_form A\n  dim_row A \\<le> dim_col A\n  pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A). i < dim_row A", "using length_pivot_positions_dim_row less_le_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>row_echelon_form ?R; ?R \\<in> carrier_mat ?nr ?nc;\n   (?i, ?j) \\<in> set (pivot_positions ?R)\\<rbrakk>\n  \\<Longrightarrow> ?i < ?nr \\<and> ?j < ?nc\n  row_echelon_form A\n  dim_row A \\<le> dim_col A\n  pivot_fun A f (dim_col A)\n  row_echelon_form ?A \\<Longrightarrow>\n  length (pivot_positions ?A) \\<le> dim_row ?A\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A). i < dim_row A", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<length (pivot_positions A). i < dim_row A\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "have i_nc: \"\\<forall>i < (length ?pp). f i < ?nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A). f i < dim_col A", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow> f i < dim_col A", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow> f i < dim_col A", "assume i_lt: \"i < length ?pp\""], ["proof (state)\nthis:\n  i < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow> f i < dim_col A", "have fis_nc: \"f i = ?nc \\<Longrightarrow> (\\<forall> k > i. k < ?nr \\<longrightarrow> f k = ?nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i = dim_col A \\<Longrightarrow>\n    \\<forall>k>i. k < dim_row A \\<longrightarrow> f k = dim_col A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f i = dim_col A \\<Longrightarrow>\n    \\<forall>k>i. k < dim_row A \\<longrightarrow> f k = dim_col A", "assume is_nc: \"f i = ?nc\""], ["proof (state)\nthis:\n  f i = dim_col A\n\ngoal (1 subgoal):\n 1. f i = dim_col A \\<Longrightarrow>\n    \\<forall>k>i. k < dim_row A \\<longrightarrow> f k = dim_col A", "show \"(\\<forall> k > i. k < ?nr \\<longrightarrow> f k = ?nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k>i. k < dim_row A \\<longrightarrow> f k = dim_col A", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i < k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i < k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "assume k_gt: \"k > i\""], ["proof (state)\nthis:\n  i < k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i < k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "assume k_lt: \"k < ?nr\""], ["proof (state)\nthis:\n  k < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i < k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "have fk_lt: \"f k \\<le> ?nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k \\<le> dim_col A", "using pivot_funD(1)[of A ?nr f ?nc k] k_lt"], ["proof (prove)\nusing this:\n  \\<lbrakk>dim_row A = dim_row A; pivot_fun A f (dim_col A);\n   k < dim_row A\\<rbrakk>\n  \\<Longrightarrow> f k \\<le> dim_col A\n  k < dim_row A\n\ngoal (1 subgoal):\n 1. f k \\<le> dim_col A", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pivot_fun A f (dim_col A) \\<Longrightarrow>\n             f k \\<le> dim_col A;\n     k < dim_row A\\<rbrakk>\n    \\<Longrightarrow> f k \\<le> dim_col A", "using \\<open>pivot_fun A f (dim_col A)\\<close>"], ["proof (prove)\nusing this:\n  pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pivot_fun A f (dim_col A) \\<Longrightarrow>\n             f k \\<le> dim_col A;\n     k < dim_row A\\<rbrakk>\n    \\<Longrightarrow> f k \\<le> dim_col A", "by blast"], ["proof (state)\nthis:\n  f k \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i < k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> f k = dim_col A", "show \"f k = ?nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k = dim_col A", "using fk_lt is_nc k_gt k_lt assms pivot_fun_monoton[of A f ?nr i k]"], ["proof (prove)\nusing this:\n  f k \\<le> dim_col A\n  f i = dim_col A\n  i < k\n  k < dim_row A\n  row_echelon_form A\n  dim_row A \\<le> dim_col A\n  pivot_fun A f (dim_col A)\n  \\<lbrakk>pivot_fun A f (dim_col A); dim_row A = dim_row A;\n   i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> k < dim_row A \\<and> i < k \\<longrightarrow>\n                    f i \\<le> f k\n\ngoal (1 subgoal):\n 1. f k = dim_col A", "using \\<open>pivot_fun A f (dim_col A)\\<close>"], ["proof (prove)\nusing this:\n  f k \\<le> dim_col A\n  f i = dim_col A\n  i < k\n  k < dim_row A\n  row_echelon_form A\n  dim_row A \\<le> dim_col A\n  pivot_fun A f (dim_col A)\n  \\<lbrakk>pivot_fun A f (dim_col A); dim_row A = dim_row A;\n   i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> k < dim_row A \\<and> i < k \\<longrightarrow>\n                    f i \\<le> f k\n  pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. f k = dim_col A", "by auto"], ["proof (state)\nthis:\n  f k = dim_col A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k>i. k < dim_row A \\<longrightarrow> f k = dim_col A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i = dim_col A \\<Longrightarrow>\n  \\<forall>k>i. k < dim_row A \\<longrightarrow> f k = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow> f i < dim_col A", "have ncimp: \"f i = ?nc \\<Longrightarrow> (\\<forall> k \\<ge>i. k \\<notin> { i. i < ?nr \\<and> row A i \\<noteq> 0\\<^sub>v ?nc})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i = dim_col A \\<Longrightarrow>\n    \\<forall>k\\<ge>i.\n       k \\<notin> {i. i < dim_row A \\<and>\n                      row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f i = dim_col A \\<Longrightarrow>\n    \\<forall>k\\<ge>i.\n       k \\<notin> {i. i < dim_row A \\<and>\n                      row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "assume nchyp: \"f i = ?nc\""], ["proof (state)\nthis:\n  f i = dim_col A\n\ngoal (1 subgoal):\n 1. f i = dim_col A \\<Longrightarrow>\n    \\<forall>k\\<ge>i.\n       k \\<notin> {i. i < dim_row A \\<and>\n                      row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "show \"(\\<forall> k \\<ge>i. k \\<notin> { i. i < ?nr \\<and> row A i \\<noteq> 0\\<^sub>v ?nc})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<ge>i.\n       k \\<notin> {i. i < dim_row A \\<and>\n                      row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> row A k = 0\\<^sub>v (dim_col A)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> row A k = 0\\<^sub>v (dim_col A)", "assume i_lt: \"i \\<le> k\""], ["proof (state)\nthis:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> row A k = 0\\<^sub>v (dim_col A)", "assume k_lt: \"k < dim_row A\""], ["proof (state)\nthis:\n  k < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i \\<le> k; k < dim_row A\\<rbrakk>\n       \\<Longrightarrow> row A k = 0\\<^sub>v (dim_col A)", "show \"row A k = 0\\<^sub>v (dim_col A) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A k = 0\\<^sub>v (dim_col A)", "using i_lt k_lt fis_nc"], ["proof (prove)\nusing this:\n  i \\<le> k\n  k < dim_row A\n  f i = dim_col A \\<Longrightarrow>\n  \\<forall>k>i. k < dim_row A \\<longrightarrow> f k = dim_col A\n\ngoal (1 subgoal):\n 1. row A k = 0\\<^sub>v (dim_col A)", "using pivot_fun_zero_row_iff[of A f ?nc ?nr]"], ["proof (prove)\nusing this:\n  i \\<le> k\n  k < dim_row A\n  f i = dim_col A \\<Longrightarrow>\n  \\<forall>k>i. k < dim_row A \\<longrightarrow> f k = dim_col A\n  \\<lbrakk>pivot_fun A f (dim_col A);\n   A \\<in> carrier_mat (dim_row A) (dim_col A); ?i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> (f ?i = dim_col A) = (row A ?i = 0\\<^sub>v (dim_col A))\n\ngoal (1 subgoal):\n 1. row A k = 0\\<^sub>v (dim_col A)", "using \\<open>pivot_fun A f (dim_col A)\\<close> le_neq_implies_less nchyp"], ["proof (prove)\nusing this:\n  i \\<le> k\n  k < dim_row A\n  f i = dim_col A \\<Longrightarrow>\n  \\<forall>k>i. k < dim_row A \\<longrightarrow> f k = dim_col A\n  \\<lbrakk>pivot_fun A f (dim_col A);\n   A \\<in> carrier_mat (dim_row A) (dim_col A); ?i < dim_row A\\<rbrakk>\n  \\<Longrightarrow> (f ?i = dim_col A) = (row A ?i = 0\\<^sub>v (dim_col A))\n  pivot_fun A f (dim_col A)\n  \\<lbrakk>?m \\<le> ?n; ?m \\<noteq> ?n\\<rbrakk> \\<Longrightarrow> ?m < ?n\n  f i = dim_col A\n\ngoal (1 subgoal):\n 1. row A k = 0\\<^sub>v (dim_col A)", "by blast"], ["proof (state)\nthis:\n  row A k = 0\\<^sub>v (dim_col A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k\\<ge>i.\n     k \\<notin> {i. i < dim_row A \\<and>\n                    row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i = dim_col A \\<Longrightarrow>\n  \\<forall>k\\<ge>i.\n     k \\<notin> {i. i < dim_row A \\<and>\n                    row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow> f i < dim_col A", "then"], ["proof (chain)\npicking this:\n  f i = dim_col A \\<Longrightarrow>\n  \\<forall>k\\<ge>i.\n     k \\<notin> {i. i < dim_row A \\<and>\n                    row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "have \"f i = ?nc \\<Longrightarrow> card { i. i < ?nr \\<and> row A i \\<noteq> 0\\<^sub>v ?nc} \\<le> i\""], ["proof (prove)\nusing this:\n  f i = dim_col A \\<Longrightarrow>\n  \\<forall>k\\<ge>i.\n     k \\<notin> {i. i < dim_row A \\<and>\n                    row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. f i = dim_col A \\<Longrightarrow>\n    card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<le> i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f i = dim_col A;\n     f i = dim_col A \\<Longrightarrow>\n     \\<forall>k\\<ge>i.\n        k \\<notin> {i. i < dim_row A \\<and>\n                       row A i \\<noteq> 0\\<^sub>v (dim_col A)}\\<rbrakk>\n    \\<Longrightarrow> card\n                       {i. i < dim_row A \\<and>\n                           row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n                      \\<le> i", "assume nchyp: \"f i = ?nc\""], ["proof (state)\nthis:\n  f i = dim_col A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f i = dim_col A;\n     f i = dim_col A \\<Longrightarrow>\n     \\<forall>k\\<ge>i.\n        k \\<notin> {i. i < dim_row A \\<and>\n                       row A i \\<noteq> 0\\<^sub>v (dim_col A)}\\<rbrakk>\n    \\<Longrightarrow> card\n                       {i. i < dim_row A \\<and>\n                           row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n                      \\<le> i", "have h: \"{ i. i < ?nr \\<and> row A i \\<noteq> 0\\<^sub>v ?nc} \\<subseteq> {0..<i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<subseteq> {0..<i}", "using atLeast0LessThan le_less_linear nchyp ncimp"], ["proof (prove)\nusing this:\n  {0..<?n} = {..<?n}\n  ?x \\<le> ?y \\<or> ?y < ?x\n  f i = dim_col A\n  f i = dim_col A \\<Longrightarrow>\n  \\<forall>k\\<ge>i.\n     k \\<notin> {i. i < dim_row A \\<and>\n                    row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<subseteq> {0..<i}", "by blast"], ["proof (state)\nthis:\n  {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<subseteq> {0..<i}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f i = dim_col A;\n     f i = dim_col A \\<Longrightarrow>\n     \\<forall>k\\<ge>i.\n        k \\<notin> {i. i < dim_row A \\<and>\n                       row A i \\<noteq> 0\\<^sub>v (dim_col A)}\\<rbrakk>\n    \\<Longrightarrow> card\n                       {i. i < dim_row A \\<and>\n                           row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n                      \\<le> i", "then"], ["proof (chain)\npicking this:\n  {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<subseteq> {0..<i}", "show \" card { i. i < ?nr \\<and> row A i \\<noteq> 0\\<^sub>v ?nc} \\<le> i\""], ["proof (prove)\nusing this:\n  {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<subseteq> {0..<i}\n\ngoal (1 subgoal):\n 1. card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<le> i", "using card_lessThan"], ["proof (prove)\nusing this:\n  {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<subseteq> {0..<i}\n  card {..<?u} = ?u\n\ngoal (1 subgoal):\n 1. card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<le> i", "using subset_eq_atLeast0_lessThan_card"], ["proof (prove)\nusing this:\n  {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<subseteq> {0..<i}\n  card {..<?u} = ?u\n  ?N \\<subseteq> {0..<?n} \\<Longrightarrow> card ?N \\<le> ?n\n\ngoal (1 subgoal):\n 1. card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n    \\<le> i", "by blast"], ["proof (state)\nthis:\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i = dim_col A \\<Longrightarrow>\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow> f i < dim_col A", "then"], ["proof (chain)\npicking this:\n  f i = dim_col A \\<Longrightarrow>\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> i", "show \"f i < ?nc\""], ["proof (prove)\nusing this:\n  f i = dim_col A \\<Longrightarrow>\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> i\n\ngoal (1 subgoal):\n 1. f i < dim_col A", "using i_lt pivot_positions(4)[of A ?nr ?nc f]"], ["proof (prove)\nusing this:\n  f i = dim_col A \\<Longrightarrow>\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  \\<le> i\n  i < length (pivot_positions A)\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> length (pivot_positions A) =\n                    card\n                     {i. i < dim_row A \\<and>\n                         row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. f i < dim_col A", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f i = dim_col A \\<Longrightarrow>\n             card\n              {i. i < dim_row A \\<and>\n                  row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n             \\<le> i;\n     i < length (pivot_positions A);\n     pivot_fun A f (dim_col A) \\<Longrightarrow>\n     length (pivot_positions A) =\n     card\n      {i. i < dim_row A \\<and>\n          row A i \\<noteq> 0\\<^sub>v (dim_col A)}\\<rbrakk>\n    \\<Longrightarrow> f i < dim_col A", "by (metis \\<open>pivot_fun A f (dim_col A)\\<close> i_nr le_neq_implies_less not_less pivot_funD(1))"], ["proof (state)\nthis:\n  f i < dim_col A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length (pivot_positions A). f i < dim_col A\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length (pivot_positions A). f i < dim_col A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length (pivot_positions A). f i < dim_col A\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "using pivot_positions(1)"], ["proof (prove)\nusing this:\n  \\<forall>i<length (pivot_positions A). f i < dim_col A\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions ?A) =\n                    {(i, ?f i) |i. i < ?nr \\<and> ?f i \\<noteq> ?nc}\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "by (smt \\<open>pivot_fun A f (dim_col A)\\<close> carrier_matI i_nr less_not_refl mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<forall>i<length (pivot_positions A).\n     (i, f i) \\<in> set (pivot_positions A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pivot_positions_form_helper_1:\n  shows \"(a, b) \\<in> set (pivot_positions_main_gen z A nr nc i j) \\<Longrightarrow> i \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (pivot_positions_main_gen z A nr nc i j) \\<Longrightarrow>\n    i \\<le> a", "proof  (induct i j rule: pivot_positions_main_gen.induct[of nr nc A z])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = z;\n                 (a, b)\n                 \\<in> set (pivot_positions_main_gen z A nr nc i\n                             (Suc j))\\<rbrakk>\n                \\<Longrightarrow> i \\<le> a;\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z;\n         (a, b)\n         \\<in> set (pivot_positions_main_gen z A nr nc (Suc i)\n                     (Suc j))\\<rbrakk>\n        \\<Longrightarrow> Suc i \\<le> a;\n        (a, b) \\<in> set (pivot_positions_main_gen z A nr nc i j)\\<rbrakk>\n       \\<Longrightarrow> i \\<le> a", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = z;\n   (a, b) \\<in> set (pivot_positions_main_gen z A nr nc i (Suc j))\\<rbrakk>\n  \\<Longrightarrow> i \\<le> a\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z;\n   (a, b)\n   \\<in> set (pivot_positions_main_gen z A nr nc (Suc i) (Suc j))\\<rbrakk>\n  \\<Longrightarrow> Suc i \\<le> a\n  (a, b) \\<in> set (pivot_positions_main_gen z A nr nc i j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = z;\n                 (a, b)\n                 \\<in> set (pivot_positions_main_gen z A nr nc i\n                             (Suc j))\\<rbrakk>\n                \\<Longrightarrow> i \\<le> a;\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z;\n         (a, b)\n         \\<in> set (pivot_positions_main_gen z A nr nc (Suc i)\n                     (Suc j))\\<rbrakk>\n        \\<Longrightarrow> Suc i \\<le> a;\n        (a, b) \\<in> set (pivot_positions_main_gen z A nr nc i j)\\<rbrakk>\n       \\<Longrightarrow> i \\<le> a", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = z;\n   (a, b) \\<in> set (pivot_positions_main_gen z A nr nc i (Suc j))\\<rbrakk>\n  \\<Longrightarrow> i \\<le> a\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z;\n   (a, b)\n   \\<in> set (pivot_positions_main_gen z A nr nc (Suc i) (Suc j))\\<rbrakk>\n  \\<Longrightarrow> Suc i \\<le> a\n  (a, b) \\<in> set (pivot_positions_main_gen z A nr nc i j)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = z;\n   (a, b) \\<in> set (pivot_positions_main_gen z A nr nc i (Suc j))\\<rbrakk>\n  \\<Longrightarrow> i \\<le> a\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z;\n   (a, b)\n   \\<in> set (pivot_positions_main_gen z A nr nc (Suc i) (Suc j))\\<rbrakk>\n  \\<Longrightarrow> Suc i \\<le> a\n  (a, b) \\<in> set (pivot_positions_main_gen z A nr nc i j)\n\ngoal (1 subgoal):\n 1. i \\<le> a", "using  pivot_positions_main_gen.simps[of z A nr nc i j]"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = z;\n   (a, b) \\<in> set (pivot_positions_main_gen z A nr nc i (Suc j))\\<rbrakk>\n  \\<Longrightarrow> i \\<le> a\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z;\n   (a, b)\n   \\<in> set (pivot_positions_main_gen z A nr nc (Suc i) (Suc j))\\<rbrakk>\n  \\<Longrightarrow> Suc i \\<le> a\n  (a, b) \\<in> set (pivot_positions_main_gen z A nr nc i j)\n  pivot_positions_main_gen z A nr nc i j =\n  (if i < nr\n   then if j < nc\n        then if A $$ (i, j) = z\n             then pivot_positions_main_gen z A nr nc i (Suc j)\n             else (i, j) #\n                  pivot_positions_main_gen z A nr nc (Suc i) (Suc j)\n        else []\n   else [])\n\ngoal (1 subgoal):\n 1. i \\<le> a", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>A $$ (i, j) = z;\n              (a, b)\n              \\<in> set (pivot_positions_main_gen z A nr nc i\n                          (Suc j))\\<rbrakk>\n             \\<Longrightarrow> i \\<le> a;\n     \\<lbrakk>A $$ (i, j) \\<noteq> z;\n      (a, b)\n      \\<in> set (pivot_positions_main_gen z A nr nc (Suc i)\n                  (Suc j))\\<rbrakk>\n     \\<Longrightarrow> Suc i \\<le> a;\n     pivot_positions_main_gen z A nr nc i j =\n     (if A $$ (i, j) = z then pivot_positions_main_gen z A nr nc i (Suc j)\n      else (i, j) # pivot_positions_main_gen z A nr nc (Suc i) (Suc j));\n     i < nr; j < nc;\n     (a, b)\n     \\<in> set (if A $$ (i, j) = z\n                then pivot_positions_main_gen z A nr nc i (Suc j)\n                else (i, j) #\n                     pivot_positions_main_gen z A nr nc (Suc i)\n                      (Suc j))\\<rbrakk>\n    \\<Longrightarrow> i \\<le> a", "by (smt Suc_leD le_refl old.prod.inject set_ConsD)"], ["proof (state)\nthis:\n  i \\<le> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pivot_positions_form_helper_2:\n  shows \"strict_sorted (map fst (pivot_positions_main_gen z A nr nc i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (map fst (pivot_positions_main_gen z A nr nc i j))", "proof  (induct i j rule: pivot_positions_main_gen.induct[of nr nc A z])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = z\\<rbrakk>\n                \\<Longrightarrow> strict_sorted\n                                   (map fst\n                                     (pivot_positions_main_gen z A nr nc i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z\\<rbrakk>\n        \\<Longrightarrow> strict_sorted\n                           (map fst\n                             (pivot_positions_main_gen z A nr nc (Suc i)\n                               (Suc j)))\\<rbrakk>\n       \\<Longrightarrow> strict_sorted\n                          (map fst (pivot_positions_main_gen z A nr nc i j))", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = z\\<rbrakk>\n  \\<Longrightarrow> strict_sorted\n                     (map fst\n                       (pivot_positions_main_gen z A nr nc i (Suc j)))\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z\\<rbrakk>\n  \\<Longrightarrow> strict_sorted\n                     (map fst\n                       (pivot_positions_main_gen z A nr nc (Suc i) (Suc j)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = z\\<rbrakk>\n                \\<Longrightarrow> strict_sorted\n                                   (map fst\n                                     (pivot_positions_main_gen z A nr nc i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z\\<rbrakk>\n        \\<Longrightarrow> strict_sorted\n                           (map fst\n                             (pivot_positions_main_gen z A nr nc (Suc i)\n                               (Suc j)))\\<rbrakk>\n       \\<Longrightarrow> strict_sorted\n                          (map fst (pivot_positions_main_gen z A nr nc i j))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = z\\<rbrakk>\n  \\<Longrightarrow> strict_sorted\n                     (map fst\n                       (pivot_positions_main_gen z A nr nc i (Suc j)))\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z\\<rbrakk>\n  \\<Longrightarrow> strict_sorted\n                     (map fst\n                       (pivot_positions_main_gen z A nr nc (Suc i) (Suc j)))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = z\\<rbrakk>\n  \\<Longrightarrow> strict_sorted\n                     (map fst\n                       (pivot_positions_main_gen z A nr nc i (Suc j)))\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z\\<rbrakk>\n  \\<Longrightarrow> strict_sorted\n                     (map fst\n                       (pivot_positions_main_gen z A nr nc (Suc i) (Suc j)))\n\ngoal (1 subgoal):\n 1. strict_sorted (map fst (pivot_positions_main_gen z A nr nc i j))", "using  pivot_positions_main_gen.simps[of z A nr nc i j]"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = z\\<rbrakk>\n  \\<Longrightarrow> strict_sorted\n                     (map fst\n                       (pivot_positions_main_gen z A nr nc i (Suc j)))\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> z\\<rbrakk>\n  \\<Longrightarrow> strict_sorted\n                     (map fst\n                       (pivot_positions_main_gen z A nr nc (Suc i) (Suc j)))\n  pivot_positions_main_gen z A nr nc i j =\n  (if i < nr\n   then if j < nc\n        then if A $$ (i, j) = z\n             then pivot_positions_main_gen z A nr nc i (Suc j)\n             else (i, j) #\n                  pivot_positions_main_gen z A nr nc (Suc i) (Suc j)\n        else []\n   else [])\n\ngoal (1 subgoal):\n 1. strict_sorted (map fst (pivot_positions_main_gen z A nr nc i j))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>strict_sorted\n                 (map fst\n                   (pivot_positions_main_gen z A nr nc (Suc i) (Suc j)));\n        pivot_positions_main_gen z A nr nc i j =\n        (i, j) # pivot_positions_main_gen z A nr nc (Suc i) (Suc j);\n        A $$ (i, j) \\<noteq> z; j < nc; i < nr;\n        (a, b)\n        \\<in> set (pivot_positions_main_gen z A nr nc (Suc i)\n                    (Suc j))\\<rbrakk>\n       \\<Longrightarrow> i < a", "using pivot_positions_form_helper_1"], ["proof (prove)\nusing this:\n  (?a, ?b)\n  \\<in> set (pivot_positions_main_gen ?z ?A ?nr ?nc ?i ?j) \\<Longrightarrow>\n  ?i \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>strict_sorted\n                 (map fst\n                   (pivot_positions_main_gen z A nr nc (Suc i) (Suc j)));\n        pivot_positions_main_gen z A nr nc i j =\n        (i, j) # pivot_positions_main_gen z A nr nc (Suc i) (Suc j);\n        A $$ (i, j) \\<noteq> z; j < nc; i < nr;\n        (a, b)\n        \\<in> set (pivot_positions_main_gen z A nr nc (Suc i)\n                    (Suc j))\\<rbrakk>\n       \\<Longrightarrow> i < a", "by (simp add: pivot_positions_form_helper_1 Suc_le_lessD)"], ["proof (state)\nthis:\n  strict_sorted (map fst (pivot_positions_main_gen z A nr nc i j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_pivot_positions:\n  shows \"strict_sorted (map fst (pivot_positions A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted (map fst (pivot_positions A))", "using pivot_positions_form_helper_2"], ["proof (prove)\nusing this:\n  strict_sorted (map fst (pivot_positions_main_gen ?z ?A ?nr ?nc ?i ?j))\n\ngoal (1 subgoal):\n 1. strict_sorted (map fst (pivot_positions A))", "by (simp add: pivot_positions_form_helper_2 pivot_positions_gen_def)"], ["", "lemma pivot_positions_form:\n  assumes row_ech: \"row_echelon_form A\"\n  assumes dim_h: \"dim_col A \\<ge> dim_row A\"\n  shows \"\\<forall> i < (length (pivot_positions A)). fst ((pivot_positions A) ! i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A). fst (pivot_positions A ! i) = i", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "let ?nr = \"dim_row A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "let ?nc = \"dim_col A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "let ?pp = \"pivot_positions A :: (nat \\<times> nat) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "assume i_lt: \"i < length (pivot_positions A)\""], ["proof (state)\nthis:\n  i < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "have \"\\<exists>f. pivot_fun A f ?nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "using row_ech"], ["proof (prove)\nusing this:\n  row_echelon_form A\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "unfolding row_echelon_form_def"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. pivot_fun A f (dim_col A)", "obtain f where pf:\"pivot_fun A f ?nc\""], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        pivot_fun A f (dim_col A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "have all_f_in: \"\\<forall>i < (length ?pp). (i, f i) \\<in> set ?pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "using pivot_positions_contains pf\n      assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>row_echelon_form ?A; dim_row ?A \\<le> dim_col ?A;\n   pivot_fun ?A ?f (dim_col ?A)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i<length (pivot_positions ?A).\n                       (i, ?f i) \\<in> set (pivot_positions ?A)\n  pivot_fun A f (dim_col A)\n  row_echelon_form A\n  dim_row A \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (pivot_positions A).\n       (i, f i) \\<in> set (pivot_positions A)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<length (pivot_positions A).\n     (i, f i) \\<in> set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "have sorted_hyp: \"\\<And> (p::nat) (q::nat). p < (length ?pp) \\<Longrightarrow> q < (length ?pp) \\<Longrightarrow> p < q \\<Longrightarrow> (fst (?pp ! p) < fst (?pp ! q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p < length (pivot_positions A);\n        q < length (pivot_positions A); p < q\\<rbrakk>\n       \\<Longrightarrow> fst (pivot_positions A ! p)\n                         < fst (pivot_positions A ! q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p < length (pivot_positions A);\n        q < length (pivot_positions A); p < q\\<rbrakk>\n       \\<Longrightarrow> fst (pivot_positions A ! p)\n                         < fst (pivot_positions A ! q)", "fix p::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p < length (pivot_positions A);\n        q < length (pivot_positions A); p < q\\<rbrakk>\n       \\<Longrightarrow> fst (pivot_positions A ! p)\n                         < fst (pivot_positions A ! q)", "fix q::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p < length (pivot_positions A);\n        q < length (pivot_positions A); p < q\\<rbrakk>\n       \\<Longrightarrow> fst (pivot_positions A ! p)\n                         < fst (pivot_positions A ! q)", "assume p_lt: \"p < q\""], ["proof (state)\nthis:\n  p < q\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p < length (pivot_positions A);\n        q < length (pivot_positions A); p < q\\<rbrakk>\n       \\<Longrightarrow> fst (pivot_positions A ! p)\n                         < fst (pivot_positions A ! q)", "assume p_welldef: \"p < (length ?pp)\""], ["proof (state)\nthis:\n  p < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p < length (pivot_positions A);\n        q < length (pivot_positions A); p < q\\<rbrakk>\n       \\<Longrightarrow> fst (pivot_positions A ! p)\n                         < fst (pivot_positions A ! q)", "assume q_welldef: \"q < (length ?pp)\""], ["proof (state)\nthis:\n  q < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p < length (pivot_positions A);\n        q < length (pivot_positions A); p < q\\<rbrakk>\n       \\<Longrightarrow> fst (pivot_positions A ! p)\n                         < fst (pivot_positions A ! q)", "show \"fst (?pp ! p) < fst (?pp ! q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! p) < fst (pivot_positions A ! q)", "using sorted_pivot_positions p_lt p_welldef q_welldef"], ["proof (prove)\nusing this:\n  strict_sorted (map fst (pivot_positions ?A))\n  p < q\n  p < length (pivot_positions A)\n  q < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! p) < fst (pivot_positions A ! q)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>A. strict_sorted (map fst (pivot_positions A)); p < q;\n     q < length (pivot_positions A)\\<rbrakk>\n    \\<Longrightarrow> fst (pivot_positions A ! p)\n                      < fst (pivot_positions A ! q)", "by (smt find_first_unique length_map nat_less_le nth_map p_welldef sorted_nth_mono sorted_pivot_positions strict_sorted_iff)"], ["proof (state)\nthis:\n  fst (pivot_positions A ! p) < fst (pivot_positions A ! q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?p < length (pivot_positions A); ?q < length (pivot_positions A);\n   ?p < ?q\\<rbrakk>\n  \\<Longrightarrow> fst (pivot_positions A ! ?p)\n                    < fst (pivot_positions A ! ?q)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "have h: \"i < (length ?pp) \\<longrightarrow> fst (pivot_positions A ! i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! i) = i", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! 0) = 0\n 2. \\<And>i.\n       i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! i) = i \\<Longrightarrow>\n       Suc i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! Suc i) = Suc i", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! 0) = 0\n 2. \\<And>i.\n       i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! i) = i \\<Longrightarrow>\n       Suc i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! Suc i) = Suc i", "have \"\\<exists>j. fst (pivot_positions A ! j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. fst (pivot_positions A ! j) = 0", "by (metis all_f_in fst_conv i_lt in_set_conv_nth length_greater_0_conv list.size(3) not_less0)"], ["proof (state)\nthis:\n  \\<exists>j. fst (pivot_positions A ! j) = 0\n\ngoal (2 subgoals):\n 1. 0 < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! 0) = 0\n 2. \\<And>i.\n       i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! i) = i \\<Longrightarrow>\n       Suc i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! Suc i) = Suc i", "then"], ["proof (chain)\npicking this:\n  \\<exists>j. fst (pivot_positions A ! j) = 0", "obtain j where jth:\" fst (pivot_positions A ! j) = 0\""], ["proof (prove)\nusing this:\n  \\<exists>j. fst (pivot_positions A ! j) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        fst (pivot_positions A ! j) = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fst (pivot_positions A ! j) = 0\n\ngoal (2 subgoals):\n 1. 0 < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! 0) = 0\n 2. \\<And>i.\n       i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! i) = i \\<Longrightarrow>\n       Suc i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! Suc i) = Suc i", "have \"j \\<noteq> 0 \\<longrightarrow> (fst (pivot_positions A ! 0) > 0 \\<longrightarrow> j \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<longrightarrow>\n    0 < fst (pivot_positions A ! 0) \\<longrightarrow> j \\<le> 0", "using sorted_hyp"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p < length (pivot_positions A); ?q < length (pivot_positions A);\n   ?p < ?q\\<rbrakk>\n  \\<Longrightarrow> fst (pivot_positions A ! ?p)\n                    < fst (pivot_positions A ! ?q)\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<longrightarrow>\n    0 < fst (pivot_positions A ! 0) \\<longrightarrow> j \\<le> 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p q.\n                \\<lbrakk>q < length (pivot_positions A); p < q\\<rbrakk>\n                \\<Longrightarrow> fst (pivot_positions A ! p)\n                                  < fst (pivot_positions A ! q);\n     0 < j\\<rbrakk>\n    \\<Longrightarrow> fst (pivot_positions A ! 0) = 0", "by (metis all_f_in fst_conv i_lt in_set_conv_nth length_greater_0_conv list.size(3) neq0_conv not_less0)"], ["proof (state)\nthis:\n  j \\<noteq> 0 \\<longrightarrow>\n  0 < fst (pivot_positions A ! 0) \\<longrightarrow> j \\<le> 0\n\ngoal (2 subgoals):\n 1. 0 < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! 0) = 0\n 2. \\<And>i.\n       i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! i) = i \\<Longrightarrow>\n       Suc i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! Suc i) = Suc i", "then"], ["proof (chain)\npicking this:\n  j \\<noteq> 0 \\<longrightarrow>\n  0 < fst (pivot_positions A ! 0) \\<longrightarrow> j \\<le> 0", "show ?case"], ["proof (prove)\nusing this:\n  j \\<noteq> 0 \\<longrightarrow>\n  0 < fst (pivot_positions A ! 0) \\<longrightarrow> j \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! 0) = 0", "using jth neq0_conv"], ["proof (prove)\nusing this:\n  j \\<noteq> 0 \\<longrightarrow>\n  0 < fst (pivot_positions A ! 0) \\<longrightarrow> j \\<le> 0\n  fst (pivot_positions A ! j) = 0\n  (?n \\<noteq> 0) = (0 < ?n)\n\ngoal (1 subgoal):\n 1. 0 < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! 0) = 0", "by blast"], ["proof (state)\nthis:\n  0 < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! 0) = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! i) = i \\<Longrightarrow>\n       Suc i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! Suc i) = Suc i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! i) = i \\<Longrightarrow>\n       Suc i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! Suc i) = Suc i", "case (Suc i)"], ["proof (state)\nthis:\n  i < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! i) = i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! i) = i \\<Longrightarrow>\n       Suc i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! Suc i) = Suc i", "have ind_h: \"i < length (pivot_positions A) \\<longrightarrow> fst (pivot_positions A ! i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! i) = i", "using Suc.hyps"], ["proof (prove)\nusing this:\n  i < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! i) = i\n\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! i) = i", "by blast"], ["proof (state)\nthis:\n  i < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! i) = i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! i) = i \\<Longrightarrow>\n       Suc i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! Suc i) = Suc i", "have thesis_h: \"(Suc i) < length (pivot_positions A) \\<Longrightarrow> fst (pivot_positions A ! (Suc i)) = (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < length (pivot_positions A) \\<Longrightarrow>\n    fst (pivot_positions A ! Suc i) = Suc i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc i < length (pivot_positions A) \\<Longrightarrow>\n    fst (pivot_positions A ! Suc i) = Suc i", "assume suc_i_lt: \"(Suc i) < length (pivot_positions A)\""], ["proof (state)\nthis:\n  Suc i < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. Suc i < length (pivot_positions A) \\<Longrightarrow>\n    fst (pivot_positions A ! Suc i) = Suc i", "have fst_i_is: \"fst (pivot_positions A ! i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! i) = i", "using suc_i_lt ind_h"], ["proof (prove)\nusing this:\n  Suc i < length (pivot_positions A)\n  i < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! i) = i\n\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! i) = i", "using Suc_lessD"], ["proof (prove)\nusing this:\n  Suc i < length (pivot_positions A)\n  i < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! i) = i\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! i) = i", "by blast"], ["proof (state)\nthis:\n  fst (pivot_positions A ! i) = i\n\ngoal (1 subgoal):\n 1. Suc i < length (pivot_positions A) \\<Longrightarrow>\n    fst (pivot_positions A ! Suc i) = Suc i", "have \"(\\<exists>j < (length ?pp). fst (pivot_positions A ! j) = (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j<length (pivot_positions A).\n       fst (pivot_positions A ! j) = Suc i", "by (metis suc_i_lt all_f_in fst_conv  in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>j<length (pivot_positions A). fst (pivot_positions A ! j) = Suc i\n\ngoal (1 subgoal):\n 1. Suc i < length (pivot_positions A) \\<Longrightarrow>\n    fst (pivot_positions A ! Suc i) = Suc i", "then"], ["proof (chain)\npicking this:\n  \\<exists>j<length (pivot_positions A). fst (pivot_positions A ! j) = Suc i", "obtain j where jth: \"j < (length ?pp) \\<and> fst (pivot_positions A ! j) = (Suc i)\""], ["proof (prove)\nusing this:\n  \\<exists>j<length (pivot_positions A). fst (pivot_positions A ! j) = Suc i\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j < length (pivot_positions A) \\<and>\n        fst (pivot_positions A ! j) = Suc i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j < length (pivot_positions A) \\<and> fst (pivot_positions A ! j) = Suc i\n\ngoal (1 subgoal):\n 1. Suc i < length (pivot_positions A) \\<Longrightarrow>\n    fst (pivot_positions A ! Suc i) = Suc i", "have \"j > i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "using sorted_hyp"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p < length (pivot_positions A); ?q < length (pivot_positions A);\n   ?p < ?q\\<rbrakk>\n  \\<Longrightarrow> fst (pivot_positions A ! ?p)\n                    < fst (pivot_positions A ! ?q)\n\ngoal (1 subgoal):\n 1. i < j", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>q < length (pivot_positions A); p < q\\<rbrakk>\n        \\<Longrightarrow> fst (pivot_positions A ! p)\n                          < fst (pivot_positions A ! q)) \\<Longrightarrow>\n    i < j", "by (metis Suc_lessD \\<open>fst (pivot_positions A ! i) = i\\<close> jth less_not_refl linorder_neqE_nat n_not_Suc_n suc_i_lt)"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. Suc i < length (pivot_positions A) \\<Longrightarrow>\n    fst (pivot_positions A ! Suc i) = Suc i", "have \"j > (Suc i) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < j \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc i < j \\<Longrightarrow> False", "assume j_gt: \"j > (Suc i)\""], ["proof (state)\nthis:\n  Suc i < j\n\ngoal (1 subgoal):\n 1. Suc i < j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Suc i < j", "have h1: \"fst (pivot_positions A ! (Suc i)) > i\""], ["proof (prove)\nusing this:\n  Suc i < j\n\ngoal (1 subgoal):\n 1. i < fst (pivot_positions A ! Suc i)", "using fst_i_is sorted_pivot_positions"], ["proof (prove)\nusing this:\n  Suc i < j\n  fst (pivot_positions A ! i) = i\n  strict_sorted (map fst (pivot_positions ?A))\n\ngoal (1 subgoal):\n 1. i < fst (pivot_positions A ! Suc i)", "using sorted_hyp suc_i_lt"], ["proof (prove)\nusing this:\n  Suc i < j\n  fst (pivot_positions A ! i) = i\n  strict_sorted (map fst (pivot_positions ?A))\n  \\<lbrakk>?p < length (pivot_positions A); ?q < length (pivot_positions A);\n   ?p < ?q\\<rbrakk>\n  \\<Longrightarrow> fst (pivot_positions A ! ?p)\n                    < fst (pivot_positions A ! ?q)\n  Suc i < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. i < fst (pivot_positions A ! Suc i)", "by force"], ["proof (state)\nthis:\n  i < fst (pivot_positions A ! Suc i)\n\ngoal (1 subgoal):\n 1. Suc i < j \\<Longrightarrow> False", "have \"fst (pivot_positions A ! j) > fst (pivot_positions A ! (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! Suc i) < fst (pivot_positions A ! j)", "using jth j_gt sorted_hyp"], ["proof (prove)\nusing this:\n  j < length (pivot_positions A) \\<and> fst (pivot_positions A ! j) = Suc i\n  Suc i < j\n  \\<lbrakk>?p < length (pivot_positions A); ?q < length (pivot_positions A);\n   ?p < ?q\\<rbrakk>\n  \\<Longrightarrow> fst (pivot_positions A ! ?p)\n                    < fst (pivot_positions A ! ?q)\n\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! Suc i) < fst (pivot_positions A ! j)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc i < j;\n     \\<And>p q.\n        \\<lbrakk>q < length (pivot_positions A); p < q\\<rbrakk>\n        \\<Longrightarrow> fst (pivot_positions A ! p)\n                          < fst (pivot_positions A ! q);\n     j < length (pivot_positions A);\n     fst (pivot_positions A ! j) = Suc i\\<rbrakk>\n    \\<Longrightarrow> fst (pivot_positions A ! Suc i) < Suc i", "by fastforce"], ["proof (state)\nthis:\n  fst (pivot_positions A ! Suc i) < fst (pivot_positions A ! j)\n\ngoal (1 subgoal):\n 1. Suc i < j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fst (pivot_positions A ! Suc i) < fst (pivot_positions A ! j)", "have h2: \"fst (pivot_positions A ! (Suc i)) < (Suc i)\""], ["proof (prove)\nusing this:\n  fst (pivot_positions A ! Suc i) < fst (pivot_positions A ! j)\n\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! Suc i) < Suc i", "using jth"], ["proof (prove)\nusing this:\n  fst (pivot_positions A ! Suc i) < fst (pivot_positions A ! j)\n  j < length (pivot_positions A) \\<and> fst (pivot_positions A ! j) = Suc i\n\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! Suc i) < Suc i", "by simp"], ["proof (state)\nthis:\n  fst (pivot_positions A ! Suc i) < Suc i\n\ngoal (1 subgoal):\n 1. Suc i < j \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using h1 h2"], ["proof (prove)\nusing this:\n  i < fst (pivot_positions A ! Suc i)\n  fst (pivot_positions A ! Suc i) < Suc i\n\ngoal (1 subgoal):\n 1. False", "using not_less_eq"], ["proof (prove)\nusing this:\n  i < fst (pivot_positions A ! Suc i)\n  fst (pivot_positions A ! Suc i) < Suc i\n  (\\<not> ?m < ?n) = (?n < Suc ?m)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc i < j \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Suc i < length (pivot_positions A) \\<Longrightarrow>\n    fst (pivot_positions A ! Suc i) = Suc i", "show \"fst (pivot_positions A ! (Suc i)) = (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! Suc i) = Suc i", "using Suc_lessI \\<open>Suc i < j \\<Longrightarrow> False\\<close> \\<open>i < j\\<close> jth"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m < ?n; Suc ?m \\<noteq> ?n\\<rbrakk>\n  \\<Longrightarrow> Suc ?m < ?n\n  Suc i < j \\<Longrightarrow> False\n  i < j\n  j < length (pivot_positions A) \\<and> fst (pivot_positions A ! j) = Suc i\n\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! Suc i) = Suc i", "by blast"], ["proof (state)\nthis:\n  fst (pivot_positions A ! Suc i) = Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc i < length (pivot_positions A) \\<Longrightarrow>\n  fst (pivot_positions A ! Suc i) = Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! i) = i \\<Longrightarrow>\n       Suc i < length (pivot_positions A) \\<longrightarrow>\n       fst (pivot_positions A ! Suc i) = Suc i", "then"], ["proof (chain)\npicking this:\n  Suc i < length (pivot_positions A) \\<Longrightarrow>\n  fst (pivot_positions A ! Suc i) = Suc i", "show ?case"], ["proof (prove)\nusing this:\n  Suc i < length (pivot_positions A) \\<Longrightarrow>\n  fst (pivot_positions A ! Suc i) = Suc i\n\ngoal (1 subgoal):\n 1. Suc i < length (pivot_positions A) \\<longrightarrow>\n    fst (pivot_positions A ! Suc i) = Suc i", "by blast"], ["proof (state)\nthis:\n  Suc i < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! Suc i) = Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! i) = i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (pivot_positions A) \\<Longrightarrow>\n       fst (pivot_positions A ! i) = i", "then"], ["proof (chain)\npicking this:\n  i < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! i) = i", "show \"fst (pivot_positions A ! i) = i\""], ["proof (prove)\nusing this:\n  i < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! i) = i\n\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! i) = i", "using i_lt"], ["proof (prove)\nusing this:\n  i < length (pivot_positions A) \\<longrightarrow>\n  fst (pivot_positions A ! i) = i\n  i < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. fst (pivot_positions A ! i) = i", "by auto"], ["proof (state)\nthis:\n  fst (pivot_positions A ! i) = i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma take_cols_pivot_eq:\n  assumes row_ech: \"row_echelon_form A\"\n  assumes dim_h: \"dim_col A \\<ge> dim_row A\"\n  shows \"take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (length (pivot_positions A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "let ?nr = \"dim_row A\""], ["proof (state)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "let ?nc = \"dim_col A\""], ["proof (state)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "have h1: \" dim_col\n     (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A)) (length (pivot_positions A))) = (length (pivot_positions A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A))\n       (length (pivot_positions A))) =\n    length (pivot_positions A)", "by (simp add: append_rows_def)"], ["proof (state)\nthis:\n  dim_col\n   (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))) =\n  length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "have len_pivot: \"length (pivot_positions A) = card {i. i < ?nr \\<and> row A i \\<noteq> 0\\<^sub>v ?nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "using row_ech pivot_positions(4) row_echelon_form_def"], ["proof (prove)\nusing this:\n  row_echelon_form A\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> length (pivot_positions ?A) =\n                    card {i. i < ?nr \\<and> row ?A i \\<noteq> 0\\<^sub>v ?nc}\n  row_echelon_form ?A \\<equiv> \\<exists>f. pivot_fun ?A f (dim_col ?A)\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "by blast"], ["proof (state)\nthis:\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "have pp_leq_nc: \"\\<forall>f. pivot_fun A f ?nc \\<longrightarrow> (\\<forall>i < ?nr. f i \\<le> ?nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       pivot_fun A f (dim_col A) \\<longrightarrow>\n       (\\<forall>i<dim_row A. f i \\<le> dim_col A)", "unfolding pivot_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       (let nr = dim_row A\n        in \\<forall>i<nr.\n              f i \\<le> dim_col A \\<and>\n              (f i < dim_col A \\<longrightarrow>\n               A $$ (i, f i) = (1::'a) \\<and>\n               (\\<forall>i'<nr.\n                   i' \\<noteq> i \\<longrightarrow>\n                   A $$ (i', f i) = (0::'a))) \\<and>\n              (\\<forall>j<f i. A $$ (i, j) = (0::'a)) \\<and>\n              (Suc i < nr \\<longrightarrow>\n               f i < f (Suc i) \\<or>\n               f (Suc i) = dim_col A)) \\<longrightarrow>\n       (\\<forall>i<dim_row A. f i \\<le> dim_col A)", "by meson"], ["proof (state)\nthis:\n  \\<forall>f.\n     pivot_fun A f (dim_col A) \\<longrightarrow>\n     (\\<forall>i<dim_row A. f i \\<le> dim_col A)\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "have pivot_set: \"\\<exists>f. pivot_fun A f ?nc \\<and> set (pivot_positions A) = {(i, f i) | i. i < ?nr \\<and> f i \\<noteq> ?nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       pivot_fun A f (dim_col A) \\<and>\n       set (pivot_positions A) =\n       {(i, f i) |i. i < dim_row A \\<and> f i \\<noteq> dim_col A}", "using row_ech row_echelon_form_def pivot_positions(1)"], ["proof (prove)\nusing this:\n  row_echelon_form A\n  row_echelon_form ?A \\<equiv> \\<exists>f. pivot_fun ?A f (dim_col ?A)\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions ?A) =\n                    {(i, ?f i) |i. i < ?nr \\<and> ?f i \\<noteq> ?nc}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       pivot_fun A f (dim_col A) \\<and>\n       set (pivot_positions A) =\n       {(i, f i) |i. i < dim_row A \\<and> f i \\<noteq> dim_col A}", "by (smt (verit) Collect_cong carrier_matI)"], ["proof (state)\nthis:\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i. i < dim_row A \\<and> f i \\<noteq> dim_col A}", "have pivot_set_alt: \"\\<exists>f. pivot_fun A f ?nc \\<and> set (pivot_positions A) = {(i, f i) | i. i < ?nr \\<and> row A i \\<noteq> 0\\<^sub>v ?nc}\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       pivot_fun A f (dim_col A) \\<and>\n       set (pivot_positions A) =\n       {(i, f i) |i.\n        i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "using pivot_positions pivot_fun_zero_row_iff Collect_cong carrier_mat_triv"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions ?A) =\n                    {(i, ?f i) |i. i < ?nr \\<and> ?f i \\<noteq> ?nc}\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (pivot_positions ?A))\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (pivot_positions ?A))\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> length (pivot_positions ?A) =\n                    card {i. i < ?nr \\<and> row ?A i \\<noteq> 0\\<^sub>v ?nc}\n  \\<lbrakk>pivot_fun ?A ?f ?nc; ?A \\<in> carrier_mat ?nr ?nc;\n   ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> (?f ?i = ?nc) = (row ?A ?i = 0\\<^sub>v ?nc)\n  (\\<And>x. ?P x = ?Q x) \\<Longrightarrow> {x. ?P x} = {x. ?Q x}\n  ?m \\<in> carrier_mat (dim_row ?m) (dim_col ?m)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       pivot_fun A f (dim_col A) \\<and>\n       set (pivot_positions A) =\n       {(i, f i) |i.\n        i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "by (smt (verit, best))"], ["proof (state)\nthis:\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i.\n      i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "have \"\\<exists>f. pivot_fun A f ?nc \\<and> set (pivot_positions A) = {(i, f i) | i. f i \\<le> ?nc \\<and> i < ?nr \\<and> f i \\<noteq> ?nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       pivot_fun A f (dim_col A) \\<and>\n       set (pivot_positions A) =\n       {(i, f i) |i.\n        f i \\<le> dim_col A \\<and>\n        i < dim_row A \\<and> f i \\<noteq> dim_col A}", "using pivot_set pp_leq_nc"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\n  \\<forall>f.\n     pivot_fun A f (dim_col A) \\<longrightarrow>\n     (\\<forall>i<dim_row A. f i \\<le> dim_col A)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       pivot_fun A f (dim_col A) \\<and>\n       set (pivot_positions A) =\n       {(i, f i) |i.\n        f i \\<le> dim_col A \\<and>\n        i < dim_row A \\<and> f i \\<noteq> dim_col A}", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i.\n      f i \\<le> dim_col A \\<and>\n      i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i.\n      f i \\<le> dim_col A \\<and>\n      i < dim_row A \\<and> f i \\<noteq> dim_col A}", "have pivot_set_var: \"\\<exists>f. pivot_fun A f ?nc \\<and> set (pivot_positions A) = {(i, f i) | i. i < ?nr \\<and> f i < ?nc}\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i.\n      f i \\<le> dim_col A \\<and>\n      i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       pivot_fun A f (dim_col A) \\<and>\n       set (pivot_positions A) =\n       {(i, f i) |i. i < dim_row A \\<and> f i < dim_col A}", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i. i < dim_row A \\<and> f i < dim_col A}\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "have \"length (map snd (pivot_positions A)) = card (set (map snd (pivot_positions A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map snd (pivot_positions A)) =\n    card (set (map snd (pivot_positions A)))", "using row_ech row_echelon_form_def pivot_positions(3) distinct_card[where xs = \"map snd (pivot_positions A)\"]"], ["proof (prove)\nusing this:\n  row_echelon_form A\n  row_echelon_form ?A \\<equiv> \\<exists>f. pivot_fun ?A f (dim_col ?A)\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc; pivot_fun ?A ?f ?nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (pivot_positions ?A))\n  distinct (map snd (pivot_positions A)) \\<Longrightarrow>\n  card (set (map snd (pivot_positions A))) =\n  length (map snd (pivot_positions A))\n\ngoal (1 subgoal):\n 1. length (map snd (pivot_positions A)) =\n    card (set (map snd (pivot_positions A)))", "by (metis carrier_mat_triv)"], ["proof (state)\nthis:\n  length (map snd (pivot_positions A)) =\n  card (set (map snd (pivot_positions A)))\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "then"], ["proof (chain)\npicking this:\n  length (map snd (pivot_positions A)) =\n  card (set (map snd (pivot_positions A)))", "have \"length (map snd (pivot_positions A)) = card (set (pivot_positions A))\""], ["proof (prove)\nusing this:\n  length (map snd (pivot_positions A)) =\n  card (set (map snd (pivot_positions A)))\n\ngoal (1 subgoal):\n 1. length (map snd (pivot_positions A)) = card (set (pivot_positions A))", "by (metis card_distinct distinct_card distinct_map length_map)"], ["proof (state)\nthis:\n  length (map snd (pivot_positions A)) = card (set (pivot_positions A))\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "then"], ["proof (chain)\npicking this:\n  length (map snd (pivot_positions A)) = card (set (pivot_positions A))", "have \"length (map snd (pivot_positions A)) = card {i. i < ?nr \\<and> row A i \\<noteq> 0\\<^sub>v ?nc}\""], ["proof (prove)\nusing this:\n  length (map snd (pivot_positions A)) = card (set (pivot_positions A))\n\ngoal (1 subgoal):\n 1. length (map snd (pivot_positions A)) =\n    card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "using pivot_set_alt"], ["proof (prove)\nusing this:\n  length (map snd (pivot_positions A)) = card (set (pivot_positions A))\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i.\n      i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (map snd (pivot_positions A)) =\n    card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "by (simp add: len_pivot)"], ["proof (state)\nthis:\n  length (map snd (pivot_positions A)) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "then"], ["proof (chain)\npicking this:\n  length (map snd (pivot_positions A)) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}", "have length_asm: \"length (map snd (pivot_positions A)) = length (pivot_positions A)\""], ["proof (prove)\nusing this:\n  length (map snd (pivot_positions A)) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (map snd (pivot_positions A)) = length (pivot_positions A)", "using len_pivot"], ["proof (prove)\nusing this:\n  length (map snd (pivot_positions A)) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n  length (pivot_positions A) =\n  card {i. i < dim_row A \\<and> row A i \\<noteq> 0\\<^sub>v (dim_col A)}\n\ngoal (1 subgoal):\n 1. length (map snd (pivot_positions A)) = length (pivot_positions A)", "by linarith"], ["proof (state)\nthis:\n  length (map snd (pivot_positions A)) = length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "then"], ["proof (chain)\npicking this:\n  length (map snd (pivot_positions A)) = length (pivot_positions A)", "have \"\\<forall>a. List.member (map snd (pivot_positions A)) a \\<longrightarrow> a < dim_col A\""], ["proof (prove)\nusing this:\n  length (map snd (pivot_positions A)) = length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       List.member (map snd (pivot_positions A)) a \\<longrightarrow>\n       a < dim_col A", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.member (map snd (pivot_positions A)) a \\<Longrightarrow>\n       a < dim_col A", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.member (map snd (pivot_positions A)) a \\<Longrightarrow>\n       a < dim_col A", "assume a_in: \"List.member (map snd (pivot_positions A)) a\""], ["proof (state)\nthis:\n  List.member (map snd (pivot_positions A)) a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.member (map snd (pivot_positions A)) a \\<Longrightarrow>\n       a < dim_col A", "have \"\\<exists>v \\<in> set (pivot_positions A). a = snd v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (pivot_positions A). a = snd v", "using a_in in_set_member[where xs = \"(pivot_positions A)\"]"], ["proof (prove)\nusing this:\n  List.member (map snd (pivot_positions A)) a\n  (?x \\<in> set (pivot_positions A)) = List.member (pivot_positions A) ?x\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>set (pivot_positions A). a = snd v", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member (map snd (pivot_positions A)) a;\n     \\<And>a b.\n        ((a, b) \\<in> set (pivot_positions A)) =\n        List.member (pivot_positions A) (a, b)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<in>set (pivot_positions A). a = snd v", "by (metis in_set_impl_in_set_zip2 in_set_member length_map snd_conv zip_map_fst_snd)"], ["proof (state)\nthis:\n  \\<exists>v\\<in>set (pivot_positions A). a = snd v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       List.member (map snd (pivot_positions A)) a \\<Longrightarrow>\n       a < dim_col A", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>set (pivot_positions A). a = snd v", "show \"a < dim_col A\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>set (pivot_positions A). a = snd v\n\ngoal (1 subgoal):\n 1. a < dim_col A", "using pivot_set_var in_set_member"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>set (pivot_positions A). a = snd v\n  \\<exists>f.\n     pivot_fun A f (dim_col A) \\<and>\n     set (pivot_positions A) =\n     {(i, f i) |i. i < dim_row A \\<and> f i < dim_col A}\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. a < dim_col A", "by auto"], ["proof (state)\nthis:\n  a < dim_col A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a.\n     List.member (map snd (pivot_positions A)) a \\<longrightarrow>\n     a < dim_col A\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "then"], ["proof (chain)\npicking this:\n  \\<forall>a.\n     List.member (map snd (pivot_positions A)) a \\<longrightarrow>\n     a < dim_col A", "have h2b: \"(filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A))) =  (map snd (pivot_positions A))\""], ["proof (prove)\nusing this:\n  \\<forall>a.\n     List.member (map snd (pivot_positions A)) a \\<longrightarrow>\n     a < dim_col A\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)) =\n    map snd (pivot_positions A)", "by (meson filter_True in_set_member)"], ["proof (state)\nthis:\n  filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)) =\n  map snd (pivot_positions A)\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)) =\n  map snd (pivot_positions A)", "have h2a: \"length (map ((!) (cols A)) (filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)))) = length (pivot_positions A)\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)) =\n  map snd (pivot_positions A)\n\ngoal (1 subgoal):\n 1. length\n     (map ((!) (cols A))\n       (filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)))) =\n    length (pivot_positions A)", "using length_asm"], ["proof (prove)\nusing this:\n  filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)) =\n  map snd (pivot_positions A)\n  length (map snd (pivot_positions A)) = length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. length\n     (map ((!) (cols A))\n       (filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)))) =\n    length (pivot_positions A)", "by (simp add: h2b)"], ["proof (state)\nthis:\n  length\n   (map ((!) (cols A))\n     (filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)))) =\n  length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "then"], ["proof (chain)\npicking this:\n  length\n   (map ((!) (cols A))\n     (filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)))) =\n  length (pivot_positions A)", "have h2: \"length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n    dim_col (take_cols A (map snd (pivot_positions A))) = (length (pivot_positions A))\""], ["proof (prove)\nusing this:\n  length\n   (map ((!) (cols A))\n     (filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)))) =\n  length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n    dim_col (take_cols A (map snd (pivot_positions A))) =\n    length (pivot_positions A)", "unfolding take_cols_def"], ["proof (prove)\nusing this:\n  length\n   (map ((!) (cols A))\n     (filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)))) =\n  length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n    dim_col\n     (mat_of_cols (dim_row A)\n       (map ((!) (cols A))\n         (filter (\\<lambda>y. y < dim_col A)\n           (map snd (pivot_positions A))))) =\n    length (pivot_positions A)", "using mat_of_cols_carrier"], ["proof (prove)\nusing this:\n  length\n   (map ((!) (cols A))\n     (filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions A)))) =\n  length (pivot_positions A)\n  mat_of_cols ?n ?vs \\<in> carrier_mat ?n (length ?vs)\n  dim_row (mat_of_cols ?n ?vs) = ?n\n  dim_col (mat_of_cols ?n ?vs) = length ?vs\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n    dim_col\n     (mat_of_cols (dim_row A)\n       (map ((!) (cols A))\n         (filter (\\<lambda>y. y < dim_col A)\n           (map snd (pivot_positions A))))) =\n    length (pivot_positions A)", "by auto"], ["proof (state)\nthis:\n  length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n  dim_col (take_cols A (map snd (pivot_positions A))) =\n  length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "have h_len: \"length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n    dim_col (take_cols A (map snd (pivot_positions A))) =\n    dim_col\n     (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A)) (length (pivot_positions A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n    dim_col (take_cols A (map snd (pivot_positions A))) =\n    dim_col\n     (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A))\n       (length (pivot_positions A)))", "using h1 h2"], ["proof (prove)\nusing this:\n  dim_col\n   (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))) =\n  length (pivot_positions A)\n  length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n  dim_col (take_cols A (map snd (pivot_positions A))) =\n  length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n    dim_col (take_cols A (map snd (pivot_positions A))) =\n    dim_col\n     (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A))\n       (length (pivot_positions A)))", "by (simp add: h1 assms length_pivot_positions_dim_row)"], ["proof (state)\nthis:\n  length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n  dim_col (take_cols A (map snd (pivot_positions A))) =\n  dim_col\n   (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A)))\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "have h2: \"\\<And>i j. length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n           i < dim_row A \\<Longrightarrow>\n           j < dim_col\n                (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                 0\\<^sub>m (dim_row A - length (pivot_positions A)) (length (pivot_positions A))) \\<Longrightarrow>\n           take_cols A (map snd (pivot_positions A)) $$ (i, j) =\n           (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n            0\\<^sub>m (dim_row A - length (pivot_positions A)) (length (pivot_positions A))) $$\n           (i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "let ?pp = \"(pivot_positions A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "assume len_lt: \"length (pivot_positions A) \\<le> dim_row A\""], ["proof (state)\nthis:\n  length (pivot_positions A) \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "assume i_lt: \" i < dim_row A\""], ["proof (state)\nthis:\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "assume j_lt: \"j < dim_col\n                (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                 0\\<^sub>m (dim_row A - length (pivot_positions A)) (length (pivot_positions A)))\""], ["proof (state)\nthis:\n  j < dim_col\n       (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n        0\\<^sub>m (dim_row A - length (pivot_positions A))\n         (length (pivot_positions A)))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "let ?w = \"((map snd (pivot_positions A)) ! j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "have breaking_it_down: \"mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$ (i, j)  \n     =  ((cols A) ! ?w) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    cols A ! (map snd (pivot_positions A) ! j) $ i", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A) \\<circ> snd) (pivot_positions A)) $$\n    (i, j) =\n    cols A ! (map snd (pivot_positions A) ! j) $ i", "by (metis comp_apply h1 i_lt j_lt length_map mat_of_cols_index nth_map)"], ["proof (state)\nthis:\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  cols A ! (map snd (pivot_positions A) ! j) $ i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "have h1a: \"i < (length ?pp) \\<Longrightarrow> (mat_of_cols (dim_row A) (map ((!) (cols A)) (map snd (pivot_positions A))) $$ (i, j) \n        = (1\\<^sub>m (length (pivot_positions A))) $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "(* need to, using row_ech, rely heavily on pivot_fun_def, that num_cols \\<ge> num_rows, and row_echelon form*)"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "assume \"i < (length ?pp)\""], ["proof (state)\nthis:\n  i < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "have \"\\<exists>f. pivot_fun A f ?nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "using row_ech"], ["proof (prove)\nusing this:\n  row_echelon_form A\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "unfolding row_echelon_form_def"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f (dim_col A)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. pivot_fun A f (dim_col A)", "obtain f where \"pivot_fun A f ?nc\""], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        pivot_fun A f (dim_col A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "have j_nc: \"j < (length ?pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length (pivot_positions A)", "using j_lt"], ["proof (prove)\nusing this:\n  j < dim_col\n       (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n        0\\<^sub>m (dim_row A - length (pivot_positions A))\n         (length (pivot_positions A)))\n\ngoal (1 subgoal):\n 1. j < length (pivot_positions A)", "by (simp add: h1)"], ["proof (state)\nthis:\n  j < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  j < length (pivot_positions A)", "have j_lt_nr: \"j < ?nr\""], ["proof (prove)\nusing this:\n  j < length (pivot_positions A)\n\ngoal (1 subgoal):\n 1. j < dim_row A", "using dim_h"], ["proof (prove)\nusing this:\n  j < length (pivot_positions A)\n  dim_row A \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. j < dim_row A", "using len_lt"], ["proof (prove)\nusing this:\n  j < length (pivot_positions A)\n  dim_row A \\<le> dim_col A\n  length (pivot_positions A) \\<le> dim_row A\n\ngoal (1 subgoal):\n 1. j < dim_row A", "by linarith"], ["proof (state)\nthis:\n  j < dim_row A\n\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  j < dim_row A", "have is_this_true: \"(pivot_positions A) ! j = (j, f j)\""], ["proof (prove)\nusing this:\n  j < dim_row A\n\ngoal (1 subgoal):\n 1. pivot_positions A ! j = (j, f j)", "using pivot_positions_form pivot_positions(1)[of A ?nr ?nc f]"], ["proof (prove)\nusing this:\n  j < dim_row A\n  \\<lbrakk>row_echelon_form ?A; dim_row ?A \\<le> dim_col ?A\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i<length (pivot_positions ?A).\n                       fst (pivot_positions ?A ! i) = i\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions A) =\n                    {(i, f i) |i.\n                     i < dim_row A \\<and> f i \\<noteq> dim_col A}\n\ngoal (1 subgoal):\n 1. pivot_positions A ! j = (j, f j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < dim_row A;\n     \\<And>A.\n        \\<lbrakk>row_echelon_form A; dim_row A \\<le> dim_col A\\<rbrakk>\n        \\<Longrightarrow> \\<forall>i<length (pivot_positions A).\n                             fst (pivot_positions A ! i) = i;\n     \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n      pivot_fun A f (dim_col A)\\<rbrakk>\n     \\<Longrightarrow> set (pivot_positions A) =\n                       {(i, f i) |i.\n                        i < dim_row A \\<and>\n                        f i \\<noteq> dim_col A}\\<rbrakk>\n    \\<Longrightarrow> pivot_positions A ! j = (j, f j)", "have \"pivot_positions A ! j \\<in> set (pivot_positions A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_positions A ! j \\<in> set (pivot_positions A)", "using j_nc nth_mem"], ["proof (prove)\nusing this:\n  j < length (pivot_positions A)\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. pivot_positions A ! j \\<in> set (pivot_positions A)", "by blast"], ["proof (state)\nthis:\n  pivot_positions A ! j \\<in> set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < dim_row A;\n     \\<And>A.\n        \\<lbrakk>row_echelon_form A; dim_row A \\<le> dim_col A\\<rbrakk>\n        \\<Longrightarrow> \\<forall>i<length (pivot_positions A).\n                             fst (pivot_positions A ! i) = i;\n     \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n      pivot_fun A f (dim_col A)\\<rbrakk>\n     \\<Longrightarrow> set (pivot_positions A) =\n                       {(i, f i) |i.\n                        i < dim_row A \\<and>\n                        f i \\<noteq> dim_col A}\\<rbrakk>\n    \\<Longrightarrow> pivot_positions A ! j = (j, f j)", "then"], ["proof (chain)\npicking this:\n  pivot_positions A ! j \\<in> set (pivot_positions A)", "have \"\\<exists>n. pivot_positions A ! j = (n, f n) \\<and> n < dim_row A \\<and> f n \\<noteq> dim_col A\""], ["proof (prove)\nusing this:\n  pivot_positions A ! j \\<in> set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       pivot_positions A ! j = (n, f n) \\<and>\n       n < dim_row A \\<and> f n \\<noteq> dim_col A", "using \\<open>\\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A); pivot_fun A f (dim_col A)\\<rbrakk> \\<Longrightarrow> set (pivot_positions A) = {(i, f i) |i. i < dim_row A \\<and> f i \\<noteq> dim_col A}\\<close> \\<open>pivot_fun A f (dim_col A)\\<close>"], ["proof (prove)\nusing this:\n  pivot_positions A ! j \\<in> set (pivot_positions A)\n  \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n   pivot_fun A f (dim_col A)\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions A) =\n                    {(i, f i) |i.\n                     i < dim_row A \\<and> f i \\<noteq> dim_col A}\n  pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       pivot_positions A ! j = (n, f n) \\<and>\n       n < dim_row A \\<and> f n \\<noteq> dim_col A", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     pivot_positions A ! j = (n, f n) \\<and>\n     n < dim_row A \\<and> f n \\<noteq> dim_col A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < dim_row A;\n     \\<And>A.\n        \\<lbrakk>row_echelon_form A; dim_row A \\<le> dim_col A\\<rbrakk>\n        \\<Longrightarrow> \\<forall>i<length (pivot_positions A).\n                             fst (pivot_positions A ! i) = i;\n     \\<lbrakk>A \\<in> carrier_mat (dim_row A) (dim_col A);\n      pivot_fun A f (dim_col A)\\<rbrakk>\n     \\<Longrightarrow> set (pivot_positions A) =\n                       {(i, f i) |i.\n                        i < dim_row A \\<and>\n                        f i \\<noteq> dim_col A}\\<rbrakk>\n    \\<Longrightarrow> pivot_positions A ! j = (j, f j)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     pivot_positions A ! j = (n, f n) \\<and>\n     n < dim_row A \\<and> f n \\<noteq> dim_col A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     pivot_positions A ! j = (n, f n) \\<and>\n     n < dim_row A \\<and> f n \\<noteq> dim_col A\n\ngoal (1 subgoal):\n 1. pivot_positions A ! j = (j, f j)", "by (metis (no_types) \\<open>\\<And>A. \\<lbrakk>row_echelon_form A; dim_row A \\<le> dim_col A\\<rbrakk> \\<Longrightarrow> \\<forall>i<length (pivot_positions A). fst (pivot_positions A ! i) = i\\<close> dim_h fst_conv j_nc row_ech)"], ["proof (state)\nthis:\n  pivot_positions A ! j = (j, f j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_positions A ! j = (j, f j)\n\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  pivot_positions A ! j = (j, f j)", "have w_is: \"?w = f j\""], ["proof (prove)\nusing this:\n  pivot_positions A ! j = (j, f j)\n\ngoal (1 subgoal):\n 1. map snd (pivot_positions A) ! j = f j", "by (metis h1 j_lt nth_map snd_conv)"], ["proof (state)\nthis:\n  map snd (pivot_positions A) ! j = f j\n\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "have h0: \"i = j \\<longrightarrow> ((cols A) ! ?w) $ i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j \\<longrightarrow>\n    cols A ! (map snd (pivot_positions A) ! j) $ i = (1::'a)", "using w_is pivot_funD(4)[of A ?nr f ?nc i]"], ["proof (prove)\nusing this:\n  map snd (pivot_positions A) ! j = f j\n  \\<lbrakk>dim_row A = dim_row A; pivot_fun A f (dim_col A); i < dim_row A;\n   f i < dim_col A\\<rbrakk>\n  \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n\ngoal (1 subgoal):\n 1. i = j \\<longrightarrow>\n    cols A ! (map snd (pivot_positions A) ! j) $ i = (1::'a)", "by (metis \\<open>\\<forall>a. List.member (map snd (pivot_positions A)) a \\<longrightarrow> a < dim_col A\\<close> \\<open>i < length (pivot_positions A)\\<close> \\<open>pivot_fun A f (dim_col A)\\<close> cols_length i_lt in_set_member length_asm mat_of_cols_cols mat_of_cols_index nth_mem)"], ["proof (state)\nthis:\n  i = j \\<longrightarrow>\n  cols A ! (map snd (pivot_positions A) ! j) $ i = (1::'a)\n\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "have h1:  \"i \\<noteq> j \\<longrightarrow> ((cols A) ! ?w) $ i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<longrightarrow>\n    cols A ! (map snd (pivot_positions A) ! j) $ i = (0::'a)", "using w_is pivot_funD(5)"], ["proof (prove)\nusing this:\n  map snd (pivot_positions A) ! j = f j\n  \\<lbrakk>dim_row ?A = ?nr; pivot_fun ?A ?f ?nc; ?i < ?nr; ?f ?i < ?nc;\n   ?i' < ?nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> ?A $$ (?i', ?f ?i) = (0::?'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<longrightarrow>\n    cols A ! (map snd (pivot_positions A) ! j) $ i = (0::'a)", "by (metis \\<open>\\<forall>a. List.member (map snd (pivot_positions A)) a \\<longrightarrow> a < dim_col A\\<close> \\<open>pivot_fun A f (dim_col A)\\<close> cols_length h1 i_lt in_set_member j_lt len_lt length_asm less_le_trans mat_of_cols_cols mat_of_cols_index nth_mem)"], ["proof (state)\nthis:\n  i \\<noteq> j \\<longrightarrow>\n  cols A ! (map snd (pivot_positions A) ! j) $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. i < length (pivot_positions A) \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "show \"(mat_of_cols (dim_row A) (map ((!) (cols A)) (map snd (pivot_positions A))) $$ (i, j) \n        = (1\\<^sub>m (length (pivot_positions A))) $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "using h0 h1 breaking_it_down"], ["proof (prove)\nusing this:\n  i = j \\<longrightarrow>\n  cols A ! (map snd (pivot_positions A) ! j) $ i = (1::'a)\n  i \\<noteq> j \\<longrightarrow>\n  cols A ! (map snd (pivot_positions A) ! j) $ i = (0::'a)\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  cols A ! (map snd (pivot_positions A) ! j) $ i\n\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    1\\<^sub>m (length (pivot_positions A)) $$ (i, j)", "by (metis \\<open>i < length (pivot_positions A)\\<close> h2 h_len index_one_mat(1) j_lt len_lt)"], ["proof (state)\nthis:\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  1\\<^sub>m (length (pivot_positions A)) $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < length (pivot_positions A) \\<Longrightarrow>\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  1\\<^sub>m (length (pivot_positions A)) $$ (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "have h1b: \"i \\<ge> (length ?pp) \\<Longrightarrow> (mat_of_cols (dim_row A) (map ((!) (cols A)) (map snd (pivot_positions A))) $$ (i, j)  = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> i \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> i \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    (0::'a)", "assume i_gt: \"i \\<ge> (length ?pp)\""], ["proof (state)\nthis:\n  length (pivot_positions A) \\<le> i\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> i \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    (0::'a)", "have h0a: \"((cols A) ! ((map snd (pivot_positions A)) ! j)) $ i = (row A i) $ ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols A ! (map snd (pivot_positions A) ! j) $ i =\n    row A i $ (map snd (pivot_positions A) ! j)", "by (metis \\<open>\\<forall>a. List.member (map snd (pivot_positions A)) a \\<longrightarrow> a < dim_col A\\<close> cols_length h1 i_lt in_set_member index_row(1) j_lt length_asm mat_of_cols_cols mat_of_cols_index nth_mem)"], ["proof (state)\nthis:\n  cols A ! (map snd (pivot_positions A) ! j) $ i =\n  row A i $ (map snd (pivot_positions A) ! j)\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> i \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    (0::'a)", "have h0b: \n        \"take_rows A [0..<length (pivot_positions A)] @\\<^sub>r 0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "using assms row_echelon_form_zero_rows[of A]"], ["proof (prove)\nusing this:\n  row_echelon_form A\n  dim_row A \\<le> dim_col A\n  \\<lbrakk>row_echelon_form A; dim_row A \\<le> dim_col A\\<rbrakk>\n  \\<Longrightarrow> take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n                    0\\<^sub>m (dim_row A - length (pivot_positions A))\n                     (dim_col A) =\n                    A\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "by blast"], ["proof (state)\nthis:\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n  A\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> i \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    (0::'a)", "then"], ["proof (chain)\npicking this:\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n  A", "have h0c: \"(row A i) = 0\\<^sub>v (dim_col A)\""], ["proof (prove)\nusing this:\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n  A\n\ngoal (1 subgoal):\n 1. row A i = 0\\<^sub>v (dim_col A)", "using i_gt"], ["proof (prove)\nusing this:\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n  A\n  length (pivot_positions A) \\<le> i\n\ngoal (1 subgoal):\n 1. row A i = 0\\<^sub>v (dim_col A)", "using add_diff_cancel_right' add_less_cancel_left diff_is_0_eq' dim_col_take_rows dim_row_append_rows i_lt index_zero_mat(2) index_zero_mat(3) le_add_diff_inverse len_lt less_not_refl3 row_append_rows row_zero zero_less_diff"], ["proof (prove)\nusing this:\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n  A\n  length (pivot_positions A) \\<le> i\n  ?a + ?b - ?b = ?a\n  (?c + ?a < ?c + ?b) = (?a < ?b)\n  ?m \\<le> ?n \\<Longrightarrow> ?m - ?n = 0\n  dim_col (take_rows ?A ?inds) = dim_col ?A\n  dim_row (?A @\\<^sub>r ?B) = dim_row ?A + dim_row ?B\n  i < dim_row A\n  dim_row (0\\<^sub>m ?nr ?nc) = ?nr\n  dim_col (0\\<^sub>m ?nr ?nc) = ?nc\n  ?b \\<le> ?a \\<Longrightarrow> ?b + (?a - ?b) = ?a\n  length (pivot_positions A) \\<le> dim_row A\n  ?s < ?t \\<Longrightarrow> ?s \\<noteq> ?t\n  \\<lbrakk>dim_col ?A = dim_col ?B; ?i < dim_row ?A + dim_row ?B\\<rbrakk>\n  \\<Longrightarrow> row (?A @\\<^sub>r ?B) ?i =\n                    (if ?i < dim_row ?A then row ?A ?i\n                     else row ?B (?i - dim_row ?A))\n  ?i < ?nr \\<Longrightarrow> row (0\\<^sub>m ?nr ?nc) ?i = 0\\<^sub>v ?nc\n  (0 < ?n - ?m) = (?m < ?n)\n\ngoal (1 subgoal):\n 1. row A i = 0\\<^sub>v (dim_col A)", "by (smt add_diff_cancel_right' add_less_cancel_left diff_is_0_eq' dim_col_take_rows dim_row_append_rows i_lt index_zero_mat(2) index_zero_mat(3) le_add_diff_inverse len_lt less_not_refl3 row_append_rows row_zero zero_less_diff)"], ["proof (state)\nthis:\n  row A i = 0\\<^sub>v (dim_col A)\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) \\<le> i \\<Longrightarrow>\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    (0::'a)", "then"], ["proof (chain)\npicking this:\n  row A i = 0\\<^sub>v (dim_col A)", "show ?thesis"], ["proof (prove)\nusing this:\n  row A i = 0\\<^sub>v (dim_col A)\n\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    (0::'a)", "using h0a breaking_it_down"], ["proof (prove)\nusing this:\n  row A i = 0\\<^sub>v (dim_col A)\n  cols A ! (map snd (pivot_positions A) ! j) $ i =\n  row A i $ (map snd (pivot_positions A) ! j)\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  cols A ! (map snd (pivot_positions A) ! j) $ i\n\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    (0::'a)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>row A i = 0\\<^sub>v (dim_col A);\n     cols A ! (map snd (pivot_positions A) ! j) $ i =\n     0\\<^sub>v (dim_col A) $ (map snd (pivot_positions A) ! j);\n     mat_of_cols (dim_row A)\n      (map ((!) (cols A) \\<circ> snd) (pivot_positions A)) $$\n     (i, j) =\n     0\\<^sub>v (dim_col A) $ (map snd (pivot_positions A) ! j)\\<rbrakk>\n    \\<Longrightarrow> 0\\<^sub>v (dim_col A) $\n                      (map snd (pivot_positions A) ! j) =\n                      (0::'a)", "by (metis \\<open>\\<forall>a. List.member (map snd (pivot_positions A)) a \\<longrightarrow> a < dim_col A\\<close> h1 in_set_member index_zero_vec(1) j_lt length_asm nth_mem)"], ["proof (state)\nthis:\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (pivot_positions A) \\<le> i \\<Longrightarrow>\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "have h1: \" mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$ (i, j) =\n           (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n            0\\<^sub>m (dim_row A - length (pivot_positions A)) (length (pivot_positions A))) $$\n           (i, j) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n     0\\<^sub>m (dim_row A - length (pivot_positions A))\n      (length (pivot_positions A))) $$\n    (i, j)", "using h1a h1b"], ["proof (prove)\nusing this:\n  i < length (pivot_positions A) \\<Longrightarrow>\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  1\\<^sub>m (length (pivot_positions A)) $$ (i, j)\n  length (pivot_positions A) \\<le> i \\<Longrightarrow>\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n    (i, j) =\n    (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n     0\\<^sub>m (dim_row A - length (pivot_positions A))\n      (length (pivot_positions A))) $$\n    (i, j)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (pivot_positions A) \\<Longrightarrow>\n             mat_of_cols (dim_row A)\n              (map ((!) (cols A) \\<circ> snd) (pivot_positions A)) $$\n             (i, j) =\n             1\\<^sub>m (length (pivot_positions A)) $$ (i, j);\n     length (pivot_positions A) \\<le> i \\<Longrightarrow>\n     mat_of_cols (dim_row A)\n      (map ((!) (cols A) \\<circ> snd) (pivot_positions A)) $$\n     (i, j) =\n     (0::'a)\\<rbrakk>\n    \\<Longrightarrow> mat_of_cols (dim_row A)\n                       (map ((!) (cols A) \\<circ> snd)\n                         (pivot_positions A)) $$\n                      (i, j) =\n                      (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                       0\\<^sub>m (dim_row A - length (pivot_positions A))\n                        (length (pivot_positions A))) $$\n                      (i, j)", "by (smt add_diff_inverse_nat add_less_cancel_left append_rows_index h1 i_lt index_one_mat(2) index_one_mat(3) index_zero_mat(1) index_zero_mat(2) index_zero_mat(3) j_lt len_lt not_less)"], ["proof (state)\nthis:\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n   0\\<^sub>m (dim_row A - length (pivot_positions A))\n    (length (pivot_positions A))) $$\n  (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; i < dim_row A;\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A)))\\<rbrakk>\n       \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                         (i, j) =\n                         (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                          0\\<^sub>m (dim_row A - length (pivot_positions A))\n                           (length (pivot_positions A))) $$\n                         (i, j)", "then"], ["proof (chain)\npicking this:\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n   0\\<^sub>m (dim_row A - length (pivot_positions A))\n    (length (pivot_positions A))) $$\n  (i, j)", "show \"take_cols A (map snd (pivot_positions A)) $$ (i, j) =\n           (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n            0\\<^sub>m (dim_row A - length (pivot_positions A)) (length (pivot_positions A))) $$\n           (i, j)\""], ["proof (prove)\nusing this:\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n   0\\<^sub>m (dim_row A - length (pivot_positions A))\n    (length (pivot_positions A))) $$\n  (i, j)\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) $$ (i, j) =\n    (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n     0\\<^sub>m (dim_row A - length (pivot_positions A))\n      (length (pivot_positions A))) $$\n    (i, j)", "unfolding take_cols_def"], ["proof (prove)\nusing this:\n  mat_of_cols (dim_row A)\n   (map ((!) (cols A)) (map snd (pivot_positions A))) $$\n  (i, j) =\n  (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n   0\\<^sub>m (dim_row A - length (pivot_positions A))\n    (length (pivot_positions A))) $$\n  (i, j)\n\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A))\n       (filter (\\<lambda>y. y < dim_col A)\n         (map snd (pivot_positions A)))) $$\n    (i, j) =\n    (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n     0\\<^sub>m (dim_row A - length (pivot_positions A))\n      (length (pivot_positions A))) $$\n    (i, j)", "by (simp add: h2b)"], ["proof (state)\nthis:\n  take_cols A (map snd (pivot_positions A)) $$ (i, j) =\n  (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n   0\\<^sub>m (dim_row A - length (pivot_positions A))\n    (length (pivot_positions A))) $$\n  (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; ?i2 < dim_row A;\n   ?j2\n   < dim_col\n      (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n       0\\<^sub>m (dim_row A - length (pivot_positions A))\n        (length (pivot_positions A)))\\<rbrakk>\n  \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                    (?i2, ?j2) =\n                    (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                     0\\<^sub>m (dim_row A - length (pivot_positions A))\n                      (length (pivot_positions A))) $$\n                    (?i2, ?j2)\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "unfolding mat_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (take_cols A (map snd (pivot_positions A))) =\n    dim_row\n     (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A))\n       (length (pivot_positions A))) \\<and>\n    dim_col (take_cols A (map snd (pivot_positions A))) =\n    dim_col\n     (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A))\n       (length (pivot_positions A))) \\<and>\n    (\\<forall>i j.\n        i < dim_row\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A))) \\<longrightarrow>\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A))) \\<longrightarrow>\n        take_cols A (map snd (pivot_positions A)) $$ (i, j) =\n        (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n         0\\<^sub>m (dim_row A - length (pivot_positions A))\n          (length (pivot_positions A))) $$\n        (i, j))", "using length_pivot_positions_dim_row[OF assms(1)] h_len h2"], ["proof (prove)\nusing this:\n  length (pivot_positions A) \\<le> dim_row A\n  length (pivot_positions A) \\<le> dim_row A \\<Longrightarrow>\n  dim_col (take_cols A (map snd (pivot_positions A))) =\n  dim_col\n   (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A)))\n  \\<lbrakk>length (pivot_positions A) \\<le> dim_row A; ?i2 < dim_row A;\n   ?j2\n   < dim_col\n      (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n       0\\<^sub>m (dim_row A - length (pivot_positions A))\n        (length (pivot_positions A)))\\<rbrakk>\n  \\<Longrightarrow> take_cols A (map snd (pivot_positions A)) $$\n                    (?i2, ?j2) =\n                    (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n                     0\\<^sub>m (dim_row A - length (pivot_positions A))\n                      (length (pivot_positions A))) $$\n                    (?i2, ?j2)\n\ngoal (1 subgoal):\n 1. dim_row (take_cols A (map snd (pivot_positions A))) =\n    dim_row\n     (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A))\n       (length (pivot_positions A))) \\<and>\n    dim_col (take_cols A (map snd (pivot_positions A))) =\n    dim_col\n     (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n      0\\<^sub>m (dim_row A - length (pivot_positions A))\n       (length (pivot_positions A))) \\<and>\n    (\\<forall>i j.\n        i < dim_row\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A))) \\<longrightarrow>\n        j < dim_col\n             (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n              0\\<^sub>m (dim_row A - length (pivot_positions A))\n               (length (pivot_positions A))) \\<longrightarrow>\n        take_cols A (map snd (pivot_positions A)) $$ (i, j) =\n        (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n         0\\<^sub>m (dim_row A - length (pivot_positions A))\n          (length (pivot_positions A))) $$\n        (i, j))", "by auto"], ["proof (state)\nthis:\n  take_cols A (map snd (pivot_positions A)) =\n  1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A))\n   (length (pivot_positions A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rref_right_mul:\n  assumes \"row_echelon_form A\"\n  assumes \"dim_col A \\<ge> dim_row A\"\n  shows\n    \"take_cols A (map snd (pivot_positions A)) * take_rows A [0..<length (pivot_positions A)] = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) *\n    take_rows A [0..<length (pivot_positions A)] =\n    A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) *\n    take_rows A [0..<length (pivot_positions A)] =\n    A", "from take_cols_pivot_eq[OF assms]"], ["proof (chain)\npicking this:\n  take_cols A (map snd (pivot_positions A)) =\n  1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A))\n   (length (pivot_positions A))", "have\n    1: \"take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (length (pivot_positions A))\""], ["proof (prove)\nusing this:\n  take_cols A (map snd (pivot_positions A)) =\n  1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A))\n   (length (pivot_positions A))\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) =\n    1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A))", "."], ["proof (state)\nthis:\n  take_cols A (map snd (pivot_positions A)) =\n  1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A))\n   (length (pivot_positions A))\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) *\n    take_rows A [0..<length (pivot_positions A)] =\n    A", "have 2: \"take_cols A (map snd (pivot_positions A)) * take_rows A [0..<length (pivot_positions A)] =\n    take_rows A [0..<length (pivot_positions A)]  @\\<^sub>r 0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) *\n    take_rows A [0..<length (pivot_positions A)] =\n    take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>m (length (pivot_positions A)) @\\<^sub>r\n     0\\<^sub>m (dim_row A - length (pivot_positions A))\n      (length (pivot_positions A))) *\n    take_rows A [0..<length (pivot_positions A)] =\n    take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)", "apply (auto simp add: append_rows_mat_mul)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m (length (pivot_positions A)) *\n    take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A))\n     (length (pivot_positions A)) *\n    take_rows A [0..<length (pivot_positions A)] =\n    take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)", "by (smt add_diff_cancel_right' assms diff_diff_cancel dim_col_take_rows dim_row_append_rows index_zero_mat(2) left_mult_one_mat' left_mult_zero_mat' length_pivot_positions_dim_row row_echelon_form_zero_rows)"], ["proof (state)\nthis:\n  take_cols A (map snd (pivot_positions A)) *\n  take_rows A [0..<length (pivot_positions A)] =\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A)\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) *\n    take_rows A [0..<length (pivot_positions A)] =\n    A", "from row_echelon_form_zero_rows[OF assms]"], ["proof (chain)\npicking this:\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n  A", "have\n    \"... = A\""], ["proof (prove)\nusing this:\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n  A\n\ngoal (1 subgoal):\n 1. take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n    0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n    A", "."], ["proof (state)\nthis:\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n  A\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) *\n    take_rows A [0..<length (pivot_positions A)] =\n    A", "thus ?thesis"], ["proof (prove)\nusing this:\n  take_rows A [0..<length (pivot_positions A)] @\\<^sub>r\n  0\\<^sub>m (dim_row A - length (pivot_positions A)) (dim_col A) =\n  A\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions A)) *\n    take_rows A [0..<length (pivot_positions A)] =\n    A", "by (simp add: \"2\")"], ["proof (state)\nthis:\n  take_cols A (map snd (pivot_positions A)) *\n  take_rows A [0..<length (pivot_positions A)] =\n  A\n\ngoal:\nNo subgoals!", "qed"], ["", "context conjugatable_vec_space begin"], ["", "lemma lin_indpt_id:\n  shows \"lin_indpt (set (cols (1\\<^sub>m n)::'a vec list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (1\\<^sub>m n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (1\\<^sub>m n)))", "have *: \"set (cols (1\\<^sub>m n)) = set (rows (1\\<^sub>m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cols (1\\<^sub>m n)) = set (rows (1\\<^sub>m n))", "by (metis cols_transpose transpose_one)"], ["proof (state)\nthis:\n  set (cols (1\\<^sub>m n)) = set (rows (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (1\\<^sub>m n)))", "have \"det (1\\<^sub>m n) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (1\\<^sub>m n) \\<noteq> (0::'b)", "using det_one"], ["proof (prove)\nusing this:\n  det (1\\<^sub>m ?n) = (1::?'a)\n\ngoal (1 subgoal):\n 1. det (1\\<^sub>m n) \\<noteq> (0::'b)", "by auto"], ["proof (state)\nthis:\n  det (1\\<^sub>m n) \\<noteq> (0::?'b3)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (1\\<^sub>m n)))", "from det_not_0_imp_lin_indpt_rows[OF _ this]"], ["proof (chain)\npicking this:\n  1\\<^sub>m n \\<in> carrier_mat n n \\<Longrightarrow>\n  lin_indpt (set (rows (1\\<^sub>m n)))", "have \"lin_indpt (set (rows (1\\<^sub>m n)))\""], ["proof (prove)\nusing this:\n  1\\<^sub>m n \\<in> carrier_mat n n \\<Longrightarrow>\n  lin_indpt (set (rows (1\\<^sub>m n)))\n\ngoal (1 subgoal):\n 1. lin_indpt (set (rows (1\\<^sub>m n)))", "using one_carrier_mat"], ["proof (prove)\nusing this:\n  1\\<^sub>m n \\<in> carrier_mat n n \\<Longrightarrow>\n  lin_indpt (set (rows (1\\<^sub>m n)))\n  1\\<^sub>m ?n \\<in> carrier_mat ?n ?n\n\ngoal (1 subgoal):\n 1. lin_indpt (set (rows (1\\<^sub>m n)))", "by blast"], ["proof (state)\nthis:\n  lin_indpt (set (rows (1\\<^sub>m n)))\n\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (1\\<^sub>m n)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  lin_indpt (set (rows (1\\<^sub>m n)))\n\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (1\\<^sub>m n)))", "by (simp add: *)"], ["proof (state)\nthis:\n  lin_indpt (set (cols (1\\<^sub>m n)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lin_indpt_take_cols_id:\n  shows \"lin_indpt (set (cols (take_cols (1\\<^sub>m n) inds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (take_cols (1\\<^sub>m n) inds)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (take_cols (1\\<^sub>m n) inds)))", "have subset_h: \"set (cols (take_cols (1\\<^sub>m n) inds)) \\<subseteq> set (cols (1\\<^sub>m n)::'a vec list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (cols (take_cols (1\\<^sub>m n) inds))\n    \\<subseteq> set (cols (1\\<^sub>m n))", "using cols_take_cols_subset"], ["proof (prove)\nusing this:\n  set (cols (take_cols ?A ?inds)) \\<subseteq> set (cols ?A)\n\ngoal (1 subgoal):\n 1. set (cols (take_cols (1\\<^sub>m n) inds))\n    \\<subseteq> set (cols (1\\<^sub>m n))", "by blast"], ["proof (state)\nthis:\n  set (cols (take_cols (1\\<^sub>m n) inds))\n  \\<subseteq> set (cols (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (take_cols (1\\<^sub>m n) inds)))", "then"], ["proof (chain)\npicking this:\n  set (cols (take_cols (1\\<^sub>m n) inds))\n  \\<subseteq> set (cols (1\\<^sub>m n))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (cols (take_cols (1\\<^sub>m n) inds))\n  \\<subseteq> set (cols (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (take_cols (1\\<^sub>m n) inds)))", "using lin_indpt_id subset_li_is_li"], ["proof (prove)\nusing this:\n  set (cols (take_cols (1\\<^sub>m n) inds))\n  \\<subseteq> set (cols (1\\<^sub>m n))\n  lin_indpt (set (cols (1\\<^sub>m n)))\n  \\<lbrakk>lin_indpt ?A; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> lin_indpt ?B\n\ngoal (1 subgoal):\n 1. lin_indpt (set (cols (take_cols (1\\<^sub>m n) inds)))", "by auto"], ["proof (state)\nthis:\n  lin_indpt (set (cols (take_cols (1\\<^sub>m n) inds)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cols_id_unit_vecs:\n  shows \"cols (1\\<^sub>m d) = unit_vecs d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cols (1\\<^sub>m d) = unit_vecs d", "unfolding unit_vecs_def list_eq_iff_nth_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (cols (1\\<^sub>m d)) = length (map (unit_vec d) [0..<d]) \\<and>\n    (\\<forall>i<length (cols (1\\<^sub>m d)).\n        cols (1\\<^sub>m d) ! i = map (unit_vec d) [0..<d] ! i)", "by auto"], ["", "lemma distinct_cols_id:\n  shows \"distinct (cols (1\\<^sub>m d)::'a vec list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (cols (1\\<^sub>m d))", "by (simp add: conjugatable_vec_space.cols_id_unit_vecs vec_space.unit_vecs_distinct)"], ["", "lemma distinct_map_nth:\n  assumes \"distinct ls\"\n  assumes \"distinct inds\"\n  assumes \"\\<And>j. j \\<in> set inds \\<Longrightarrow> j < length ls\"\n  shows \"distinct (map ((!) ls) inds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map ((!) ls) inds)", "by (simp add: assms(1) assms(2) assms(3) distinct_map inj_on_nth)"], ["", "lemma distinct_take_cols_id:\n  assumes \"distinct inds\"\n  shows \"distinct (cols (take_cols (1\\<^sub>m n) inds) :: 'a vec list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (cols (take_cols (1\\<^sub>m n) inds))", "unfolding take_cols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (cols\n       (mat_of_cols (dim_row (1\\<^sub>m n))\n         (map ((!) (cols (1\\<^sub>m n)))\n           (filter (\\<lambda>y. y < dim_col (1\\<^sub>m n)) inds))))", "apply (subst cols_mat_of_cols)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (map ((!) (cols (1\\<^sub>m n)))\n          (filter (\\<lambda>y. y < dim_col (1\\<^sub>m n)) inds))\n    \\<subseteq> carrier_vec (dim_row (1\\<^sub>m n))\n 2. distinct\n     (map ((!) (cols (1\\<^sub>m n)))\n       (filter (\\<lambda>y. y < dim_col (1\\<^sub>m n)) inds))", "apply (auto intro!:  distinct_map_nth simp add: distinct_cols_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>y. y < n) inds)", "using assms distinct_filter"], ["proof (prove)\nusing this:\n  distinct inds\n  distinct ?xs \\<Longrightarrow> distinct (filter ?P ?xs)\n\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>y. y < n) inds)", "by blast"], ["", "lemma rank_take_cols:\n  assumes \"distinct inds\"\n  shows \"rank (take_cols (1\\<^sub>m n) inds) = length (filter ((>) n) inds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (take_cols (1\\<^sub>m n) inds) =\n    length (filter (\\<lambda>y. y < n) inds)", "apply (subst lin_indpt_full_rank[of _ \"length (filter ((>) n) inds)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. take_cols (1\\<^sub>m n) inds\n    \\<in> carrier_mat n (length (filter (\\<lambda>y. y < n) inds))\n 2. distinct (cols (take_cols (1\\<^sub>m n) inds))\n 3. lin_indpt (set (cols (take_cols (1\\<^sub>m n) inds)))\n 4. length (filter (\\<lambda>y. y < n) inds) =\n    length (filter (\\<lambda>y. y < n) inds)", "apply (auto simp add: lin_indpt_take_cols_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. take_cols (1\\<^sub>m n) inds\n    \\<in> carrier_mat n (length (filter (\\<lambda>y. y < n) inds))\n 2. distinct (cols (take_cols (1\\<^sub>m n) inds))", "apply (metis (full_types) index_one_mat(2) index_one_mat(3) length_map mat_of_cols_carrier(1) take_cols_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (cols (take_cols (1\\<^sub>m n) inds))", "by (simp add: assms distinct_take_cols_id)"], ["", "lemma rank_mul_left_invertible_mat:\n  fixes A::\"'a mat\"\n  assumes \"invertible_mat A\"\n  assumes \"A \\<in> carrier_mat n n\"\n  assumes \"B \\<in> carrier_mat n nc\"\n  shows \"rank (A * B) = rank B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "obtain C where C: \"inverts_mat A C\" \"inverts_mat C A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>inverts_mat A C; inverts_mat C A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms invertible_mat_def"], ["proof (prove)\nusing this:\n  invertible_mat A\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n nc\n  invertible_mat ?A \\<equiv>\n  square_mat ?A \\<and>\n  (\\<exists>B. inverts_mat ?A B \\<and> inverts_mat B ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>inverts_mat A C; inverts_mat C A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inverts_mat A C\n  inverts_mat C A\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "from C"], ["proof (chain)\npicking this:\n  inverts_mat A C\n  inverts_mat C A", "have ceq: \"C * A = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  inverts_mat A C\n  inverts_mat C A\n\ngoal (1 subgoal):\n 1. C * A = 1\\<^sub>m n", "by (metis assms(2) carrier_matD(2) index_mult_mat(3) index_one_mat(3) inverts_mat_def)"], ["proof (state)\nthis:\n  C * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "then"], ["proof (chain)\npicking this:\n  C * A = 1\\<^sub>m n", "have *:\"B = C*A*B\""], ["proof (prove)\nusing this:\n  C * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B = C * A * B", "using assms(3)"], ["proof (prove)\nusing this:\n  C * A = 1\\<^sub>m n\n  B \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. B = C * A * B", "by auto"], ["proof (state)\nthis:\n  B = C * A * B\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "from rank_mat_mul_left[OF assms(2-3)]"], ["proof (chain)\npicking this:\n  rank (A * B) \\<le> rank B", "have **: \"rank (A*B) \\<le> rank B\""], ["proof (prove)\nusing this:\n  rank (A * B) \\<le> rank B\n\ngoal (1 subgoal):\n 1. rank (A * B) \\<le> rank B", "."], ["proof (state)\nthis:\n  rank (A * B) \\<le> rank B\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "have 1: \"C \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> carrier_mat n n", "using C ceq"], ["proof (prove)\nusing this:\n  inverts_mat A C\n  inverts_mat C A\n  C * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. C \\<in> carrier_mat n n", "by (metis assms(2) carrier_matD(1) carrier_matI index_mult_mat(3) index_one_mat(3) inverts_mat_def)"], ["proof (state)\nthis:\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "have 2: \"A * B \\<in> carrier_mat n nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B \\<in> carrier_mat n nc", "using assms"], ["proof (prove)\nusing this:\n  invertible_mat A\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. A * B \\<in> carrier_mat n nc", "by auto"], ["proof (state)\nthis:\n  A * B \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "have \"rank B = rank (C* A * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank B = rank (C * A * B)", "using *"], ["proof (prove)\nusing this:\n  B = C * A * B\n\ngoal (1 subgoal):\n 1. rank B = rank (C * A * B)", "by auto"], ["proof (state)\nthis:\n  rank B = rank (C * A * B)\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "also"], ["proof (state)\nthis:\n  rank B = rank (C * A * B)\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "have \"... \\<le> rank (A*B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (C * A * B) \\<le> rank (A * B)", "using rank_mat_mul_left[OF 1 2]"], ["proof (prove)\nusing this:\n  rank (C * (A * B)) \\<le> rank (A * B)\n\ngoal (1 subgoal):\n 1. rank (C * A * B) \\<le> rank (A * B)", "using \"1\" assms(2) assms(3)"], ["proof (prove)\nusing this:\n  rank (C * (A * B)) \\<le> rank (A * B)\n  C \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. rank (C * A * B) \\<le> rank (A * B)", "by auto"], ["proof (state)\nthis:\n  rank (C * A * B) \\<le> rank (A * B)\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "ultimately"], ["proof (chain)\npicking this:\n  rank B = rank (C * A * B)\n  rank (C * A * B) \\<le> rank (A * B)", "show ?thesis"], ["proof (prove)\nusing this:\n  rank B = rank (C * A * B)\n  rank (C * A * B) \\<le> rank (A * B)\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "using **"], ["proof (prove)\nusing this:\n  rank B = rank (C * A * B)\n  rank (C * A * B) \\<le> rank (A * B)\n  rank (A * B) \\<le> rank B\n\ngoal (1 subgoal):\n 1. rank (A * B) = rank B", "by auto"], ["proof (state)\nthis:\n  rank (A * B) = rank B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_take_cols_rank:\n  fixes A::\"'a mat\"\n  assumes \"invertible_mat A\"\n  assumes \"A \\<in> carrier_mat n n\"\n  assumes \"distinct inds\"\n  shows \"rank (take_cols A inds) = length (filter ((>) n) inds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (take_cols A inds) = length (filter (\\<lambda>y. y < n) inds)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank (take_cols A inds) = length (filter (\\<lambda>y. y < n) inds)", "have \" A = A * 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A * 1\\<^sub>m n", "using assms(2)"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A = A * 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  A = A * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. rank (take_cols A inds) = length (filter (\\<lambda>y. y < n) inds)", "then"], ["proof (chain)\npicking this:\n  A = A * 1\\<^sub>m n", "have \"take_cols A inds = A * take_cols (1\\<^sub>m n) inds\""], ["proof (prove)\nusing this:\n  A = A * 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. take_cols A inds = A * take_cols (1\\<^sub>m n) inds", "by (metis assms(2) one_carrier_mat take_cols_mat_mul)"], ["proof (state)\nthis:\n  take_cols A inds = A * take_cols (1\\<^sub>m n) inds\n\ngoal (1 subgoal):\n 1. rank (take_cols A inds) = length (filter (\\<lambda>y. y < n) inds)", "then"], ["proof (chain)\npicking this:\n  take_cols A inds = A * take_cols (1\\<^sub>m n) inds", "have \"rank (take_cols A inds) = rank (take_cols (1\\<^sub>m n) inds)\""], ["proof (prove)\nusing this:\n  take_cols A inds = A * take_cols (1\\<^sub>m n) inds\n\ngoal (1 subgoal):\n 1. rank (take_cols A inds) = rank (take_cols (1\\<^sub>m n) inds)", "by (metis assms(1) assms(2) conjugatable_vec_space.rank_mul_left_invertible_mat one_carrier_mat take_cols_carrier_mat)"], ["proof (state)\nthis:\n  rank (take_cols A inds) = rank (take_cols (1\\<^sub>m n) inds)\n\ngoal (1 subgoal):\n 1. rank (take_cols A inds) = length (filter (\\<lambda>y. y < n) inds)", "thus ?thesis"], ["proof (prove)\nusing this:\n  rank (take_cols A inds) = rank (take_cols (1\\<^sub>m n) inds)\n\ngoal (1 subgoal):\n 1. rank (take_cols A inds) = length (filter (\\<lambda>y. y < n) inds)", "by (simp add: assms(3) conjugatable_vec_space.rank_take_cols)"], ["proof (state)\nthis:\n  rank (take_cols A inds) = length (filter (\\<lambda>y. y < n) inds)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_take_cols_leq:\n  assumes R:\"R \\<in> carrier_mat n nc\"\n  shows \"rank (take_cols R ls) \\<le> rank R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (take_cols R ls) \\<le> rank R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank (take_cols R ls) \\<le> rank R", "from take_cols_mat_mul[OF R]"], ["proof (chain)\npicking this:\n  ?B \\<in> carrier_mat nc ?nc \\<Longrightarrow>\n  R * take_cols ?B ?inds = take_cols (R * ?B) ?inds", "have \"take_cols R ls =  R * take_cols (1\\<^sub>m nc) ls\""], ["proof (prove)\nusing this:\n  ?B \\<in> carrier_mat nc ?nc \\<Longrightarrow>\n  R * take_cols ?B ?inds = take_cols (R * ?B) ?inds\n\ngoal (1 subgoal):\n 1. take_cols R ls = R * take_cols (1\\<^sub>m nc) ls", "by (metis assms one_carrier_mat right_mult_one_mat)"], ["proof (state)\nthis:\n  take_cols R ls = R * take_cols (1\\<^sub>m nc) ls\n\ngoal (1 subgoal):\n 1. rank (take_cols R ls) \\<le> rank R", "thus ?thesis"], ["proof (prove)\nusing this:\n  take_cols R ls = R * take_cols (1\\<^sub>m nc) ls\n\ngoal (1 subgoal):\n 1. rank (take_cols R ls) \\<le> rank R", "by (metis assms one_carrier_mat take_cols_carrier_mat vec_space.rank_mat_mul_right)"], ["proof (state)\nthis:\n  rank (take_cols R ls) \\<le> rank R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_take_cols_geq:\n  assumes R:\"R \\<in> carrier_mat n nc\"\n  assumes t:\"take_cols R ls \\<in> carrier_mat n r\"\n  assumes B:\"B \\<in> carrier_mat r nc\"\n  assumes \"R = (take_cols R ls) * B\"\n  shows \"rank (take_cols R ls) \\<ge> rank R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank R \\<le> rank (take_cols R ls)", "by (metis B assms(4) t vec_space.rank_mat_mul_right)"], ["", "lemma rref_drop_pivots:\n  assumes row_ech: \"row_echelon_form R\"\n  assumes dims: \"R \\<in> carrier_mat n nc\"\n  assumes order: \"nc \\<ge> n\"\n  shows \"rank (take_cols R (map snd (pivot_positions R))) = rank R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (take_cols R (map snd (pivot_positions R))) = rank R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank (take_cols R (map snd (pivot_positions R))) = rank R", "let ?B = \"take_rows R [0..<length (pivot_positions R)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. rank (take_cols R (map snd (pivot_positions R))) = rank R", "have equa: \"R = take_cols R (map snd (pivot_positions R)) * ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R =\n    take_cols R (map snd (pivot_positions R)) *\n    take_rows R [0..<length (pivot_positions R)]", "using assms rref_right_mul"], ["proof (prove)\nusing this:\n  row_echelon_form R\n  R \\<in> carrier_mat n nc\n  n \\<le> nc\n  \\<lbrakk>row_echelon_form ?A; dim_row ?A \\<le> dim_col ?A\\<rbrakk>\n  \\<Longrightarrow> take_cols ?A (map snd (pivot_positions ?A)) *\n                    take_rows ?A [0..<length (pivot_positions ?A)] =\n                    ?A\n\ngoal (1 subgoal):\n 1. R =\n    take_cols R (map snd (pivot_positions R)) *\n    take_rows R [0..<length (pivot_positions R)]", "by (metis carrier_matD(1) carrier_matD(2))"], ["proof (state)\nthis:\n  R =\n  take_cols R (map snd (pivot_positions R)) *\n  take_rows R [0..<length (pivot_positions R)]\n\ngoal (1 subgoal):\n 1. rank (take_cols R (map snd (pivot_positions R))) = rank R", "have ex_r: \"\\<exists>r. take_cols R (map snd (pivot_positions R)) \\<in> carrier_mat n r \\<and> ?B \\<in> carrier_mat r nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       take_cols R (map snd (pivot_positions R))\n       \\<in> carrier_mat n r \\<and>\n       take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       take_cols R (map snd (pivot_positions R))\n       \\<in> carrier_mat n r \\<and>\n       take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc", "have h1:\n      \"take_cols R (map snd (pivot_positions R)) \\<in> carrier_mat n (length (pivot_positions R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_cols R (map snd (pivot_positions R))\n    \\<in> carrier_mat n (length (pivot_positions R))", "using assms"], ["proof (prove)\nusing this:\n  row_echelon_form R\n  R \\<in> carrier_mat n nc\n  n \\<le> nc\n\ngoal (1 subgoal):\n 1. take_cols R (map snd (pivot_positions R))\n    \\<in> carrier_mat n (length (pivot_positions R))", "by (metis in_set_impl_in_set_zip2 length_map rref_pivot_positions take_cols_carrier_mat_strict zip_map_fst_snd)"], ["proof (state)\nthis:\n  take_cols R (map snd (pivot_positions R))\n  \\<in> carrier_mat n (length (pivot_positions R))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       take_cols R (map snd (pivot_positions R))\n       \\<in> carrier_mat n r \\<and>\n       take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc", "have \"\\<exists> f. pivot_fun R f nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun R f nc", "using row_ech"], ["proof (prove)\nusing this:\n  row_echelon_form R\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun R f nc", "unfolding row_echelon_form_def"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun R f (dim_col R)\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun R f nc", "using dims"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun R f (dim_col R)\n  R \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun R f nc", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. pivot_fun R f nc\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       take_cols R (map snd (pivot_positions R))\n       \\<in> carrier_mat n r \\<and>\n       take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. pivot_fun R f nc", "have \"length (pivot_positions R) = card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}\""], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun R f nc\n\ngoal (1 subgoal):\n 1. length (pivot_positions R) =\n    card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}", "using pivot_positions[of R n nc]"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun R f nc\n  \\<lbrakk>R \\<in> carrier_mat n nc; pivot_fun R ?f nc\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions R) =\n                    {(i, ?f i) |i. i < n \\<and> ?f i \\<noteq> nc}\n  \\<lbrakk>R \\<in> carrier_mat n nc; pivot_fun R ?f nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (pivot_positions R))\n  \\<lbrakk>R \\<in> carrier_mat n nc; pivot_fun R ?f nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (pivot_positions R))\n  \\<lbrakk>R \\<in> carrier_mat n nc; pivot_fun R ?f nc\\<rbrakk>\n  \\<Longrightarrow> length (pivot_positions R) =\n                    card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. length (pivot_positions R) =\n    card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}", "using dims"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun R f nc\n  \\<lbrakk>R \\<in> carrier_mat n nc; pivot_fun R ?f nc\\<rbrakk>\n  \\<Longrightarrow> set (pivot_positions R) =\n                    {(i, ?f i) |i. i < n \\<and> ?f i \\<noteq> nc}\n  \\<lbrakk>R \\<in> carrier_mat n nc; pivot_fun R ?f nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (pivot_positions R))\n  \\<lbrakk>R \\<in> carrier_mat n nc; pivot_fun R ?f nc\\<rbrakk>\n  \\<Longrightarrow> distinct (map snd (pivot_positions R))\n  \\<lbrakk>R \\<in> carrier_mat n nc; pivot_fun R ?f nc\\<rbrakk>\n  \\<Longrightarrow> length (pivot_positions R) =\n                    card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}\n  R \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. length (pivot_positions R) =\n    card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}", "by auto"], ["proof (state)\nthis:\n  length (pivot_positions R) =\n  card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       take_cols R (map snd (pivot_positions R))\n       \\<in> carrier_mat n r \\<and>\n       take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc", "then"], ["proof (chain)\npicking this:\n  length (pivot_positions R) =\n  card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}", "have \"nc \\<ge> length (pivot_positions R)\""], ["proof (prove)\nusing this:\n  length (pivot_positions R) =\n  card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. length (pivot_positions R) \\<le> nc", "using order"], ["proof (prove)\nusing this:\n  length (pivot_positions R) =\n  card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}\n  n \\<le> nc\n\ngoal (1 subgoal):\n 1. length (pivot_positions R) \\<le> nc", "using carrier_matD(1) dims dual_order.trans length_pivot_positions_dim_row row_ech"], ["proof (prove)\nusing this:\n  length (pivot_positions R) =\n  card {i. i < n \\<and> row R i \\<noteq> 0\\<^sub>v nc}\n  n \\<le> nc\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> dim_row ?A = ?nr\n  R \\<in> carrier_mat n nc\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  row_echelon_form ?A \\<Longrightarrow>\n  length (pivot_positions ?A) \\<le> dim_row ?A\n  row_echelon_form R\n\ngoal (1 subgoal):\n 1. length (pivot_positions R) \\<le> nc", "by blast"], ["proof (state)\nthis:\n  length (pivot_positions R) \\<le> nc\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       take_cols R (map snd (pivot_positions R))\n       \\<in> carrier_mat n r \\<and>\n       take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc", "then"], ["proof (chain)\npicking this:\n  length (pivot_positions R) \\<le> nc", "have \"dim_col R \\<ge> length (pivot_positions R)\""], ["proof (prove)\nusing this:\n  length (pivot_positions R) \\<le> nc\n\ngoal (1 subgoal):\n 1. length (pivot_positions R) \\<le> dim_col R", "using dims"], ["proof (prove)\nusing this:\n  length (pivot_positions R) \\<le> nc\n  R \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. length (pivot_positions R) \\<le> dim_col R", "by auto"], ["proof (state)\nthis:\n  length (pivot_positions R) \\<le> dim_col R\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       take_cols R (map snd (pivot_positions R))\n       \\<in> carrier_mat n r \\<and>\n       take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc", "then"], ["proof (chain)\npicking this:\n  length (pivot_positions R) \\<le> dim_col R", "have h2: \"?B \\<in> carrier_mat (length (pivot_positions R)) nc\""], ["proof (prove)\nusing this:\n  length (pivot_positions R) \\<le> dim_col R\n\ngoal (1 subgoal):\n 1. take_rows R [0..<length (pivot_positions R)]\n    \\<in> carrier_mat (length (pivot_positions R)) nc", "unfolding take_rows_def"], ["proof (prove)\nusing this:\n  length (pivot_positions R) \\<le> dim_col R\n\ngoal (1 subgoal):\n 1. mat_of_rows (dim_col R)\n     (map ((!) (rows R))\n       (filter (\\<lambda>y. y < dim_row R)\n         [0..<length (pivot_positions R)]))\n    \\<in> carrier_mat (length (pivot_positions R)) nc", "using dims"], ["proof (prove)\nusing this:\n  length (pivot_positions R) \\<le> dim_col R\n  R \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. mat_of_rows (dim_col R)\n     (map ((!) (rows R))\n       (filter (\\<lambda>y. y < dim_row R)\n         [0..<length (pivot_positions R)]))\n    \\<in> carrier_mat (length (pivot_positions R)) nc", "by (smt atLeastLessThan_iff carrier_matD(2) filter_True le_eq_less_or_eq length_map length_pivot_positions_dim_row less_trans map_nth mat_of_cols_carrier(1) row_ech set_upt transpose_carrier_mat transpose_mat_of_rows)"], ["proof (state)\nthis:\n  take_rows R [0..<length (pivot_positions R)]\n  \\<in> carrier_mat (length (pivot_positions R)) nc\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       take_cols R (map snd (pivot_positions R))\n       \\<in> carrier_mat n r \\<and>\n       take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       take_cols R (map snd (pivot_positions R))\n       \\<in> carrier_mat n r \\<and>\n       take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc", "using h1 h2"], ["proof (prove)\nusing this:\n  take_cols R (map snd (pivot_positions R))\n  \\<in> carrier_mat n (length (pivot_positions R))\n  take_rows R [0..<length (pivot_positions R)]\n  \\<in> carrier_mat (length (pivot_positions R)) nc\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       take_cols R (map snd (pivot_positions R))\n       \\<in> carrier_mat n r \\<and>\n       take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc", "by blast"], ["proof (state)\nthis:\n  \\<exists>r.\n     take_cols R (map snd (pivot_positions R)) \\<in> carrier_mat n r \\<and>\n     take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r.\n     take_cols R (map snd (pivot_positions R)) \\<in> carrier_mat n r \\<and>\n     take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc\n\ngoal (1 subgoal):\n 1. rank (take_cols R (map snd (pivot_positions R))) = rank R", "(* prove the other two dimensionality assumptions *)"], ["proof (state)\nthis:\n  \\<exists>r.\n     take_cols R (map snd (pivot_positions R)) \\<in> carrier_mat n r \\<and>\n     take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc\n\ngoal (1 subgoal):\n 1. rank (take_cols R (map snd (pivot_positions R))) = rank R", "have \"rank R  \\<le> rank (take_cols R (map snd (pivot_positions R)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank R \\<le> rank (take_cols R (map snd (pivot_positions R)))", "using dims ex_r rank_take_cols_geq[where R = \"R\", where B = \"?B\", where ls = \"(map snd (pivot_positions R))\", where nc = \"nc\"]"], ["proof (prove)\nusing this:\n  R \\<in> carrier_mat n nc\n  \\<exists>r.\n     take_cols R (map snd (pivot_positions R)) \\<in> carrier_mat n r \\<and>\n     take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc\n  \\<lbrakk>R \\<in> carrier_mat n nc;\n   take_cols R (map snd (pivot_positions R)) \\<in> carrier_mat n ?r;\n   take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat ?r nc;\n   R =\n   take_cols R (map snd (pivot_positions R)) *\n   take_rows R [0..<length (pivot_positions R)]\\<rbrakk>\n  \\<Longrightarrow> rank R\n                    \\<le> rank (take_cols R (map snd (pivot_positions R)))\n\ngoal (1 subgoal):\n 1. rank R \\<le> rank (take_cols R (map snd (pivot_positions R)))", "using equa"], ["proof (prove)\nusing this:\n  R \\<in> carrier_mat n nc\n  \\<exists>r.\n     take_cols R (map snd (pivot_positions R)) \\<in> carrier_mat n r \\<and>\n     take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat r nc\n  \\<lbrakk>R \\<in> carrier_mat n nc;\n   take_cols R (map snd (pivot_positions R)) \\<in> carrier_mat n ?r;\n   take_rows R [0..<length (pivot_positions R)] \\<in> carrier_mat ?r nc;\n   R =\n   take_cols R (map snd (pivot_positions R)) *\n   take_rows R [0..<length (pivot_positions R)]\\<rbrakk>\n  \\<Longrightarrow> rank R\n                    \\<le> rank (take_cols R (map snd (pivot_positions R)))\n  R =\n  take_cols R (map snd (pivot_positions R)) *\n  take_rows R [0..<length (pivot_positions R)]\n\ngoal (1 subgoal):\n 1. rank R \\<le> rank (take_cols R (map snd (pivot_positions R)))", "by blast"], ["proof (state)\nthis:\n  rank R \\<le> rank (take_cols R (map snd (pivot_positions R)))\n\ngoal (1 subgoal):\n 1. rank (take_cols R (map snd (pivot_positions R))) = rank R", "thus ?thesis"], ["proof (prove)\nusing this:\n  rank R \\<le> rank (take_cols R (map snd (pivot_positions R)))\n\ngoal (1 subgoal):\n 1. rank (take_cols R (map snd (pivot_positions R))) = rank R", "using assms(2) conjugatable_vec_space.rank_take_cols_leq le_antisym"], ["proof (prove)\nusing this:\n  rank R \\<le> rank (take_cols R (map snd (pivot_positions R)))\n  R \\<in> carrier_mat n nc\n  ?R \\<in> carrier_mat ?n ?nc \\<Longrightarrow>\n  vec_space.rank ?n (take_cols ?R ?ls) \\<le> vec_space.rank ?n ?R\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. rank (take_cols R (map snd (pivot_positions R))) = rank R", "by blast"], ["proof (state)\nthis:\n  rank (take_cols R (map snd (pivot_positions R))) = rank R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gjs_and_take_cols_var:\n  fixes A::\"'a mat\"\n  assumes A:\"A \\<in> carrier_mat n nc\"\n  assumes order: \"nc \\<ge> n\"\n  shows \"(take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) = \n  (take_cols_var A (map snd (pivot_positions (gauss_jordan_single A))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions (gauss_jordan_single A))) =\n    take_cols_var A (map snd (pivot_positions (gauss_jordan_single A)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions (gauss_jordan_single A))) =\n    take_cols_var A (map snd (pivot_positions (gauss_jordan_single A)))", "let ?gjs = \"(gauss_jordan_single A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions (gauss_jordan_single A))) =\n    take_cols_var A (map snd (pivot_positions (gauss_jordan_single A)))", "have \"\\<forall>x. List.member (map snd (pivot_positions (gauss_jordan_single A))) x \\<longrightarrow> x \\<le> dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member (map snd (pivot_positions (gauss_jordan_single A)))\n        x \\<longrightarrow>\n       x \\<le> dim_col A", "using rref_pivot_positions gauss_jordan_single(3) carrier_matD(2) gauss_jordan_single(2) in_set_impl_in_set_zip2 in_set_member length_map less_irrefl less_trans not_le_imp_less zip_map_fst_snd"], ["proof (prove)\nusing this:\n  \\<lbrakk>row_echelon_form ?R; ?R \\<in> carrier_mat ?nr ?nc;\n   (?i, ?j) \\<in> set (pivot_positions ?R)\\<rbrakk>\n  \\<Longrightarrow> ?i < ?nr \\<and> ?j < ?nc\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc;\n   gauss_jordan_single ?A = ?C\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form ?C\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> dim_col ?A = ?nc\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc;\n   gauss_jordan_single ?A = ?C\\<rbrakk>\n  \\<Longrightarrow> ?C \\<in> carrier_mat ?nr ?nc\n  \\<lbrakk>length ?xs = length ?ys; ?y \\<in> set ?ys;\n   \\<And>x.\n      (x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  length (map ?f ?xs) = length ?xs\n  \\<not> ?x < ?x\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<not> ?y \\<le> ?x \\<Longrightarrow> ?x < ?y\n  zip (map fst ?zs) (map snd ?zs) = ?zs\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       List.member (map snd (pivot_positions (gauss_jordan_single A)))\n        x \\<longrightarrow>\n       x \\<le> dim_col A", "by (smt A carrier_matD(2) gauss_jordan_single(2) in_set_impl_in_set_zip2 in_set_member length_map less_irrefl less_trans not_le_imp_less zip_map_fst_snd)"], ["proof (state)\nthis:\n  \\<forall>x.\n     List.member (map snd (pivot_positions (gauss_jordan_single A)))\n      x \\<longrightarrow>\n     x \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions (gauss_jordan_single A))) =\n    take_cols_var A (map snd (pivot_positions (gauss_jordan_single A)))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     List.member (map snd (pivot_positions (gauss_jordan_single A)))\n      x \\<longrightarrow>\n     x \\<le> dim_col A", "have \"(filter (\\<lambda>y. y < dim_col A) (map snd (pivot_positions (gauss_jordan_single A)))) = \n    (map snd (pivot_positions (gauss_jordan_single A)))\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     List.member (map snd (pivot_positions (gauss_jordan_single A)))\n      x \\<longrightarrow>\n     x \\<le> dim_col A\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. y < dim_col A)\n     (map snd (pivot_positions (gauss_jordan_single A))) =\n    map snd (pivot_positions (gauss_jordan_single A))", "by (metis (no_types, lifting) A carrier_matD(2) filter_True gauss_jordan_single(2) gauss_jordan_single(3) in_set_impl_in_set_zip2 length_map rref_pivot_positions zip_map_fst_snd)"], ["proof (state)\nthis:\n  filter (\\<lambda>y. y < dim_col A)\n   (map snd (pivot_positions (gauss_jordan_single A))) =\n  map snd (pivot_positions (gauss_jordan_single A))\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions (gauss_jordan_single A))) =\n    take_cols_var A (map snd (pivot_positions (gauss_jordan_single A)))", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>y. y < dim_col A)\n   (map snd (pivot_positions (gauss_jordan_single A))) =\n  map snd (pivot_positions (gauss_jordan_single A))", "show ?thesis"], ["proof (prove)\nusing this:\n  filter (\\<lambda>y. y < dim_col A)\n   (map snd (pivot_positions (gauss_jordan_single A))) =\n  map snd (pivot_positions (gauss_jordan_single A))\n\ngoal (1 subgoal):\n 1. take_cols A (map snd (pivot_positions (gauss_jordan_single A))) =\n    take_cols_var A (map snd (pivot_positions (gauss_jordan_single A)))", "unfolding take_cols_def take_cols_var_def"], ["proof (prove)\nusing this:\n  filter (\\<lambda>y. y < dim_col A)\n   (map snd (pivot_positions (gauss_jordan_single A))) =\n  map snd (pivot_positions (gauss_jordan_single A))\n\ngoal (1 subgoal):\n 1. mat_of_cols (dim_row A)\n     (map ((!) (cols A))\n       (filter (\\<lambda>y. y < dim_col A)\n         (map snd (pivot_positions (gauss_jordan_single A))))) =\n    mat_of_cols (dim_row A)\n     (map ((!) (cols A))\n       (map snd (pivot_positions (gauss_jordan_single A))))", "by simp"], ["proof (state)\nthis:\n  take_cols A (map snd (pivot_positions (gauss_jordan_single A))) =\n  take_cols_var A (map snd (pivot_positions (gauss_jordan_single A)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_jordan_single_rank:\n  fixes A::\"'a mat\"\n  assumes A:\"A \\<in> carrier_mat n nc\"\n  assumes order: \"nc \\<ge> n\"\n  shows \"rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) = rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "let ?R = \"gauss_jordan_single A\""], ["proof (state)\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "obtain P where P:\"P\\<in>Units (ring_mat TYPE('a) n undefined)\" and\n    i: \"?R = P * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) n undefined);\n         gauss_jordan_single A = P * A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gauss_jordan_transform[OF A]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?B \\<in> carrier_mat n ?nc';\n   gauss_jordan A ?B = (?A', ?B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) n ?b).\n                       ?A' = P * A \\<and> ?B' = P * ?B\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) n undefined);\n         gauss_jordan_single A = P * A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using A assms det_mult det_non_zero_imp_unit det_one gauss_jordan_single(4) mult_not_zero one_neq_zero"], ["proof (prove)\nusing this:\n  \\<lbrakk>?B \\<in> carrier_mat n ?nc';\n   gauss_jordan A ?B = (?A', ?B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) n ?b).\n                       ?A' = P * A \\<and> ?B' = P * ?B\n  A \\<in> carrier_mat n nc\n  A \\<in> carrier_mat n nc\n  n \\<le> nc\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; ?B \\<in> carrier_mat ?n ?n\\<rbrakk>\n  \\<Longrightarrow> det (?A * ?B) = det ?A * det ?B\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n; det ?A \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?A \\<in> Units (ring_mat TYPE(?'a) ?n ?b)\n  det (1\\<^sub>m ?n) = (1::?'a)\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc;\n   gauss_jordan_single ?A = ?C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P Q.\n                       ?C = P * ?A \\<and>\n                       P \\<in> carrier_mat ?nr ?nr \\<and>\n                       Q \\<in> carrier_mat ?nr ?nr \\<and>\n                       P * Q = 1\\<^sub>m ?nr \\<and> Q * P = 1\\<^sub>m ?nr\n  ?a * ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  ?a \\<noteq> (0::?'a) \\<and> ?b \\<noteq> (0::?'a)\n  (1::?'a) \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) n undefined);\n         gauss_jordan_single A = P * A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (smt A assms det_mult det_non_zero_imp_unit det_one gauss_jordan_single(4) mult_not_zero one_neq_zero)"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) n undefined)\n  gauss_jordan_single A = P * A\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "have pcarrier: \"P \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "using P"], ["proof (prove)\nusing this:\n  P \\<in> Units (ring_mat TYPE('a) n undefined)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "unfolding Units_def"], ["proof (prove)\nusing this:\n  P \\<in> {y \\<in> carrier (ring_mat TYPE('a) n undefined).\n           \\<exists>x\\<in>carrier (ring_mat TYPE('a) n undefined).\n              x \\<otimes>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> y =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> x =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub>}\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "by (auto simp add: ring_mat_def)"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "have \"invertible_mat P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_mat P", "using P"], ["proof (prove)\nusing this:\n  P \\<in> Units (ring_mat TYPE('a) n undefined)\n\ngoal (1 subgoal):\n 1. invertible_mat P", "unfolding invertible_mat_def Units_def inverts_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> {y \\<in> carrier (ring_mat TYPE('a) n undefined).\n           \\<exists>x\\<in>carrier (ring_mat TYPE('a) n undefined).\n              x \\<otimes>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> y =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> x =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub>}\n\ngoal (1 subgoal):\n 1. square_mat P \\<and>\n    (\\<exists>B.\n        P * B = 1\\<^sub>m (dim_row P) \\<and> B * P = 1\\<^sub>m (dim_row B))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>P \\<in> carrier (ring_mat TYPE('a) n undefined);\n        x \\<in> carrier (ring_mat TYPE('a) n undefined);\n        x \\<otimes>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> P =\n        \\<one>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub>;\n        P \\<otimes>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> x =\n        \\<one>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> dim_col P = dim_row P\n 2. \\<And>x.\n       \\<lbrakk>P \\<in> carrier (ring_mat TYPE('a) n undefined);\n        x \\<in> carrier (ring_mat TYPE('a) n undefined);\n        x \\<otimes>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> P =\n        \\<one>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub>;\n        P \\<otimes>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> x =\n        \\<one>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            P * B = 1\\<^sub>m (dim_row P) \\<and>\n                            B * P = 1\\<^sub>m (dim_row B)", "apply (simp add: ring_mat_simps(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P \\<in> carrier (ring_mat TYPE('a) n undefined);\n        x \\<in> carrier (ring_mat TYPE('a) n undefined);\n        x \\<otimes>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> P =\n        \\<one>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub>;\n        P \\<otimes>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub> x =\n        \\<one>\\<^bsub>ring_mat TYPE('a) n undefined\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            P * B = 1\\<^sub>m (dim_row P) \\<and>\n                            B * P = 1\\<^sub>m (dim_row B)", "by (metis index_mult_mat(2) index_one_mat(2) ring_mat_simps(1) ring_mat_simps(3))"], ["proof (state)\nthis:\n  invertible_mat P\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "then"], ["proof (chain)\npicking this:\n  invertible_mat P", "obtain Pi where Pi: \"invertible_mat Pi\" \"Pi * P = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  invertible_mat P\n\ngoal (1 subgoal):\n 1. (\\<And>Pi.\n        \\<lbrakk>invertible_mat Pi; Pi * P = 1\\<^sub>m n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Pi.\n                \\<lbrakk>invertible_mat Pi; Pi * P = 1\\<^sub>m n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     invertible_mat P\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume a1: \"\\<And>Pi. \\<lbrakk>invertible_mat Pi; Pi * P = 1\\<^sub>m n\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>invertible_mat ?Pi2; ?Pi2 * P = 1\\<^sub>m n\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Pi.\n                \\<lbrakk>invertible_mat Pi; Pi * P = 1\\<^sub>m n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     invertible_mat P\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"dim_row P = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row P = n", "by (metis (no_types) A assms(1) carrier_matD(1) gauss_jordan_single(2) i index_mult_mat(2))"], ["proof (state)\nthis:\n  dim_row P = n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Pi.\n                \\<lbrakk>invertible_mat Pi; Pi * P = 1\\<^sub>m n\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     invertible_mat P\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  dim_row P = n", "show ?thesis"], ["proof (prove)\nusing this:\n  dim_row P = n\n\ngoal (1 subgoal):\n 1. thesis", "using a1"], ["proof (prove)\nusing this:\n  dim_row P = n\n  \\<lbrakk>invertible_mat ?Pi2; ?Pi2 * P = 1\\<^sub>m n\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (metis (no_types) \\<open>invertible_mat P\\<close> index_mult_mat(3) index_one_mat(3) invertible_mat_def inverts_mat_def square_mat.simps)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invertible_mat Pi\n  Pi * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "then"], ["proof (chain)\npicking this:\n  invertible_mat Pi\n  Pi * P = 1\\<^sub>m n", "have pi_carrier:\"Pi \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  invertible_mat Pi\n  Pi * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. Pi \\<in> carrier_mat n n", "by (metis carrier_mat_triv index_mult_mat(2) index_one_mat(2) invertible_mat_def square_mat.simps)"], ["proof (state)\nthis:\n  Pi \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "have R1:\"row_echelon_form ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form (gauss_jordan_single A)", "using assms(2) gauss_jordan_single(3)"], ["proof (prove)\nusing this:\n  n \\<le> nc\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc;\n   gauss_jordan_single ?A = ?C\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form ?C\n\ngoal (1 subgoal):\n 1. row_echelon_form (gauss_jordan_single A)", "by blast"], ["proof (state)\nthis:\n  row_echelon_form (gauss_jordan_single A)\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "have R2: \"?R \\<in> carrier_mat n nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_single A \\<in> carrier_mat n nc", "using A assms(2) gauss_jordan_single(2)"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n nc\n  n \\<le> nc\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc;\n   gauss_jordan_single ?A = ?C\\<rbrakk>\n  \\<Longrightarrow> ?C \\<in> carrier_mat ?nr ?nc\n\ngoal (1 subgoal):\n 1. gauss_jordan_single A \\<in> carrier_mat n nc", "by auto"], ["proof (state)\nthis:\n  gauss_jordan_single A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "have Rcm: \"take_cols ?R (map snd (pivot_positions ?R))\n    \\<in> carrier_mat n (length (map snd (pivot_positions ?R)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A)))\n    \\<in> carrier_mat n\n           (length (map snd (pivot_positions (gauss_jordan_single A))))", "apply (rule take_cols_carrier_mat_strict[OF R2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set (map snd\n                     (pivot_positions\n                       (gauss_jordan_single A))) \\<Longrightarrow>\n       i < nc", "using rref_pivot_positions[OF R1 R2]"], ["proof (prove)\nusing this:\n  (?i, ?j)\n  \\<in> set (pivot_positions (gauss_jordan_single A)) \\<Longrightarrow>\n  ?i < n \\<and> ?j < nc\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set (map snd\n                     (pivot_positions\n                       (gauss_jordan_single A))) \\<Longrightarrow>\n       i < nc", "by auto"], ["proof (state)\nthis:\n  take_cols (gauss_jordan_single A)\n   (map snd (pivot_positions (gauss_jordan_single A)))\n  \\<in> carrier_mat n\n         (length (map snd (pivot_positions (gauss_jordan_single A))))\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "have \"Pi * ?R = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi * gauss_jordan_single A = A", "using i Pi"], ["proof (prove)\nusing this:\n  gauss_jordan_single A = P * A\n  invertible_mat Pi\n  Pi * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. Pi * gauss_jordan_single A = A", "by (smt A \\<open>invertible_mat P\\<close> assoc_mult_mat carrier_mat_triv index_mult_mat(2) index_mult_mat(3) index_one_mat(3) invertible_mat_def left_mult_one_mat square_mat.simps)"], ["proof (state)\nthis:\n  Pi * gauss_jordan_single A = A\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "then"], ["proof (chain)\npicking this:\n  Pi * gauss_jordan_single A = A", "have \"rank (take_cols A (map snd (pivot_positions ?R))) = rank (take_cols (Pi * ?R) (map snd (pivot_positions ?R)))\""], ["proof (prove)\nusing this:\n  Pi * gauss_jordan_single A = A\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank\n     (take_cols (Pi * gauss_jordan_single A)\n       (map snd (pivot_positions (gauss_jordan_single A))))", "by auto"], ["proof (state)\nthis:\n  rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank\n   (take_cols (Pi * gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A))))\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "also"], ["proof (state)\nthis:\n  rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank\n   (take_cols (Pi * gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A))))\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "have \"... = rank ( Pi * take_cols ?R (map snd (pivot_positions ?R)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank\n     (take_cols (Pi * gauss_jordan_single A)\n       (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank\n     (Pi *\n      take_cols (gauss_jordan_single A)\n       (map snd (pivot_positions (gauss_jordan_single A))))", "by (metis A gauss_jordan_single(2) pi_carrier take_cols_mat_mul)"], ["proof (state)\nthis:\n  rank\n   (take_cols (Pi * gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank\n   (Pi *\n    take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A))))\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "also"], ["proof (state)\nthis:\n  rank\n   (take_cols (Pi * gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank\n   (Pi *\n    take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A))))\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "have \"... = rank (take_cols ?R (map snd (pivot_positions ?R)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank\n     (Pi *\n      take_cols (gauss_jordan_single A)\n       (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank\n     (take_cols (gauss_jordan_single A)\n       (map snd (pivot_positions (gauss_jordan_single A))))", "by (intro rank_mul_left_invertible_mat[OF Pi(1) pi_carrier Rcm])"], ["proof (state)\nthis:\n  rank\n   (Pi *\n    take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank\n   (take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A))))\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "also"], ["proof (state)\nthis:\n  rank\n   (Pi *\n    take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank\n   (take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A))))\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "have \"... = rank ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank\n     (take_cols (gauss_jordan_single A)\n       (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank (gauss_jordan_single A)", "using assms(2) conjugatable_vec_space.rref_drop_pivots gauss_jordan_single(3)"], ["proof (prove)\nusing this:\n  n \\<le> nc\n  \\<lbrakk>row_echelon_form ?R; ?R \\<in> carrier_mat ?n ?nc;\n   ?n \\<le> ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_space.rank ?n\n                     (take_cols ?R (map snd (pivot_positions ?R))) =\n                    vec_space.rank ?n ?R\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc;\n   gauss_jordan_single ?A = ?C\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form ?C\n\ngoal (1 subgoal):\n 1. rank\n     (take_cols (gauss_jordan_single A)\n       (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank (gauss_jordan_single A)", "using R1 R2"], ["proof (prove)\nusing this:\n  n \\<le> nc\n  \\<lbrakk>row_echelon_form ?R; ?R \\<in> carrier_mat ?n ?nc;\n   ?n \\<le> ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_space.rank ?n\n                     (take_cols ?R (map snd (pivot_positions ?R))) =\n                    vec_space.rank ?n ?R\n  \\<lbrakk>?A \\<in> carrier_mat ?nr ?nc;\n   gauss_jordan_single ?A = ?C\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form ?C\n  row_echelon_form (gauss_jordan_single A)\n  gauss_jordan_single A \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. rank\n     (take_cols (gauss_jordan_single A)\n       (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank (gauss_jordan_single A)", "by blast"], ["proof (state)\nthis:\n  rank\n   (take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank (gauss_jordan_single A)\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "ultimately"], ["proof (chain)\npicking this:\n  rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank\n   (take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A))))\n  rank\n   (take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank (gauss_jordan_single A)", "show ?thesis"], ["proof (prove)\nusing this:\n  rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank\n   (take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A))))\n  rank\n   (take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank (gauss_jordan_single A)\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "using A \\<open>P \\<in> carrier_mat n n\\<close> \\<open>invertible_mat P\\<close> conjugatable_vec_space.rank_mul_left_invertible_mat i"], ["proof (prove)\nusing this:\n  rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank\n   (take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A))))\n  rank\n   (take_cols (gauss_jordan_single A)\n     (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank (gauss_jordan_single A)\n  A \\<in> carrier_mat n nc\n  P \\<in> carrier_mat n n\n  invertible_mat P\n  \\<lbrakk>invertible_mat ?A; ?A \\<in> carrier_mat ?n ?n;\n   ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_space.rank ?n (?A * ?B) = vec_space.rank ?n ?B\n  gauss_jordan_single A = P * A\n\ngoal (1 subgoal):\n 1. rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n    rank A", "by auto"], ["proof (state)\nthis:\n  rank (take_cols A (map snd (pivot_positions (gauss_jordan_single A)))) =\n  rank A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lin_indpt_subset_cols:\n  fixes A:: \"'a mat\"\n  fixes B:: \"'a vec set\"\n  assumes \"A \\<in> carrier_mat n n\"\n  assumes inv: \"invertible_mat A\"\n  assumes \"B \\<subseteq> set (cols A)\"\n  shows \"lin_indpt B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lin_indpt B", "have \"det A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A \\<noteq> (0::'a)", "using assms(1) inv invertible_det"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  invertible_mat A\n  ?A \\<in> carrier_mat ?n ?n \\<Longrightarrow>\n  invertible_mat ?A = (det ?A \\<noteq> (0::?'a))\n\ngoal (1 subgoal):\n 1. det A \\<noteq> (0::'a)", "by blast"], ["proof (state)\nthis:\n  det A \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lin_indpt B", "then"], ["proof (chain)\npicking this:\n  det A \\<noteq> (0::'a)", "have \"lin_indpt (set (rows A\\<^sup>T))\""], ["proof (prove)\nusing this:\n  det A \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (rows A\\<^sup>T))", "using assms(1) idom_vec.lin_dep_cols_imp_det_0"], ["proof (prove)\nusing this:\n  det A \\<noteq> (0::'a)\n  A \\<in> carrier_mat n n\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?n;\n   module.lin_dep class_ring (module_vec TYPE(?'a) ?n)\n    (set (cols ?A))\\<rbrakk>\n  \\<Longrightarrow> det ?A = (0::?'a)\n\ngoal (1 subgoal):\n 1. lin_indpt (set (rows A\\<^sup>T))", "by auto"], ["proof (state)\nthis:\n  lin_indpt (set (rows A\\<^sup>T))\n\ngoal (1 subgoal):\n 1. lin_indpt B", "thus ?thesis"], ["proof (prove)\nusing this:\n  lin_indpt (set (rows A\\<^sup>T))\n\ngoal (1 subgoal):\n 1. lin_indpt B", "using subset_li_is_li assms(3)"], ["proof (prove)\nusing this:\n  lin_indpt (set (rows A\\<^sup>T))\n  \\<lbrakk>lin_indpt ?A; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> lin_indpt ?B\n  B \\<subseteq> set (cols A)\n\ngoal (1 subgoal):\n 1. lin_indpt B", "by auto"], ["proof (state)\nthis:\n  lin_indpt B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_invertible_subset_cols:\n  fixes A:: \"'a mat\"\n  fixes B:: \"'a vec list\"\n  assumes inv: \"invertible_mat A\"\n  assumes A_square: \"A \\<in> carrier_mat n n\"\n  assumes set_sub: \"set (B) \\<subseteq> set (cols A)\"\n  assumes dist_B: \"distinct B\"\n  shows \"rank (mat_of_cols n B) = length B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "let ?B_mat = \"(mat_of_cols n B)\""], ["proof (state)\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "have h1: \"lin_indpt (set(B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lin_indpt (set B)", "using assms lin_indpt_subset_cols[of A]"], ["proof (prove)\nusing this:\n  invertible_mat A\n  A \\<in> carrier_mat n n\n  set B \\<subseteq> set (cols A)\n  distinct B\n  \\<lbrakk>A \\<in> carrier_mat n n; invertible_mat A;\n   ?B \\<subseteq> set (cols A)\\<rbrakk>\n  \\<Longrightarrow> lin_indpt ?B\n\ngoal (1 subgoal):\n 1. lin_indpt (set B)", "by auto"], ["proof (state)\nthis:\n  lin_indpt (set B)\n\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "have \"set B \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set B \\<subseteq> carrier_vec n", "using set_sub A_square cols_dim[of A]"], ["proof (prove)\nusing this:\n  set B \\<subseteq> set (cols A)\n  A \\<in> carrier_mat n n\n  set (cols A) \\<subseteq> carrier_vec (dim_row A)\n\ngoal (1 subgoal):\n 1. set B \\<subseteq> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  set B \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "then"], ["proof (chain)\npicking this:\n  set B \\<subseteq> carrier_vec n", "have cols_B: \"cols (mat_of_cols n B) = B\""], ["proof (prove)\nusing this:\n  set B \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. cols (mat_of_cols n B) = B", "using cols_mat_of_cols"], ["proof (prove)\nusing this:\n  set B \\<subseteq> carrier_vec n\n  set ?vs \\<subseteq> carrier_vec ?n \\<Longrightarrow>\n  cols (mat_of_cols ?n ?vs) = ?vs\n\ngoal (1 subgoal):\n 1. cols (mat_of_cols n B) = B", "by auto"], ["proof (state)\nthis:\n  cols (mat_of_cols n B) = B\n\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "then"], ["proof (chain)\npicking this:\n  cols (mat_of_cols n B) = B", "have \"maximal (set B) (\\<lambda>T. T \\<subseteq> set (B) \\<and> lin_indpt T)\""], ["proof (prove)\nusing this:\n  cols (mat_of_cols n B) = B\n\ngoal (1 subgoal):\n 1. maximal (set B) (\\<lambda>T. T \\<subseteq> set B \\<and> lin_indpt T)", "using h1"], ["proof (prove)\nusing this:\n  cols (mat_of_cols n B) = B\n  lin_indpt (set B)\n\ngoal (1 subgoal):\n 1. maximal (set B) (\\<lambda>T. T \\<subseteq> set B \\<and> lin_indpt T)", "by (simp add: maximal_def subset_antisym)"], ["proof (state)\nthis:\n  maximal (set B) (\\<lambda>T. T \\<subseteq> set B \\<and> lin_indpt T)\n\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "then"], ["proof (chain)\npicking this:\n  maximal (set B) (\\<lambda>T. T \\<subseteq> set B \\<and> lin_indpt T)", "have h2: \"maximal (set B) (\\<lambda>T. T \\<subseteq> set (cols (mat_of_cols n B)) \\<and> lin_indpt T)\""], ["proof (prove)\nusing this:\n  maximal (set B) (\\<lambda>T. T \\<subseteq> set B \\<and> lin_indpt T)\n\ngoal (1 subgoal):\n 1. maximal (set B)\n     (\\<lambda>T.\n         T \\<subseteq> set (cols (mat_of_cols n B)) \\<and> lin_indpt T)", "using cols_B"], ["proof (prove)\nusing this:\n  maximal (set B) (\\<lambda>T. T \\<subseteq> set B \\<and> lin_indpt T)\n  cols (mat_of_cols n B) = B\n\ngoal (1 subgoal):\n 1. maximal (set B)\n     (\\<lambda>T.\n         T \\<subseteq> set (cols (mat_of_cols n B)) \\<and> lin_indpt T)", "by auto"], ["proof (state)\nthis:\n  maximal (set B)\n   (\\<lambda>T.\n       T \\<subseteq> set (cols (mat_of_cols n B)) \\<and> lin_indpt T)\n\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "have h3: \"rank (mat_of_cols n B) = card (set B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = card (set B)", "using h1 h2 rank_card_indpt[of ?B_mat]"], ["proof (prove)\nusing this:\n  lin_indpt (set B)\n  maximal (set B)\n   (\\<lambda>T.\n       T \\<subseteq> set (cols (mat_of_cols n B)) \\<and> lin_indpt T)\n  \\<lbrakk>mat_of_cols n B \\<in> carrier_mat n ?nc;\n   maximal ?S\n    (\\<lambda>T.\n        T \\<subseteq> set (cols (mat_of_cols n B)) \\<and>\n        lin_indpt T)\\<rbrakk>\n  \\<Longrightarrow> rank (mat_of_cols n B) = card ?S\n\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = card (set B)", "using mat_of_cols_carrier(1)"], ["proof (prove)\nusing this:\n  lin_indpt (set B)\n  maximal (set B)\n   (\\<lambda>T.\n       T \\<subseteq> set (cols (mat_of_cols n B)) \\<and> lin_indpt T)\n  \\<lbrakk>mat_of_cols n B \\<in> carrier_mat n ?nc;\n   maximal ?S\n    (\\<lambda>T.\n        T \\<subseteq> set (cols (mat_of_cols n B)) \\<and>\n        lin_indpt T)\\<rbrakk>\n  \\<Longrightarrow> rank (mat_of_cols n B) = card ?S\n  mat_of_cols ?n ?vs \\<in> carrier_mat ?n (length ?vs)\n\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = card (set B)", "by blast"], ["proof (state)\nthis:\n  rank (mat_of_cols n B) = card (set B)\n\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "then"], ["proof (chain)\npicking this:\n  rank (mat_of_cols n B) = card (set B)", "show ?thesis"], ["proof (prove)\nusing this:\n  rank (mat_of_cols n B) = card (set B)\n\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "using assms distinct_card"], ["proof (prove)\nusing this:\n  rank (mat_of_cols n B) = card (set B)\n  invertible_mat A\n  A \\<in> carrier_mat n n\n  set B \\<subseteq> set (cols A)\n  distinct B\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. rank (mat_of_cols n B) = length B", "by auto"], ["proof (state)\nthis:\n  rank (mat_of_cols n B) = length B\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}