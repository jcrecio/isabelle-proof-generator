{"file_name": "/home/qj213/afp-2021-10-22/thys/BenOr_Kozen_Reif/BKR_Decision.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BenOr_Kozen_Reif", "problem_names": ["lemma poly_list_set_fml:\n  shows \"set (poly_list fml) = set_fml fml\"", "lemma convert_semantics_lem:\n  assumes \"\\<And>p. p \\<in> set (poly_list fml) \\<Longrightarrow>\n    ls ! (index_of ps p) = rpoly p x\"\n  shows \"fml_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls\"", "lemma index_of_aux_more:\n  shows \"index_of_aux ls p n \\<ge> n\"", "lemma index_of_aux_lookup:\n  assumes \"p \\<in> set ls\"\n  shows \"(index_of_aux ls p n) - n < length ls\"\n    \"ls ! ((index_of_aux ls p n) - n) = p\"", "lemma index_of_lookup:\n  assumes \"p \\<in> set ls\"\n  shows \"index_of ls p < length ls\"\n    \"ls ! (index_of ls p) = p\"", "lemma convert_semantics:\n  shows \"fml_sem fml x = lookup_sem (fst (convert fml)) (map (\\<lambda>p. rpoly p x) (snd (convert fml)))\"", "lemma convert_closed:\n  shows \"\\<And>i. i \\<in> set_fml (fst (convert fml)) \\<Longrightarrow> i < length (snd (convert fml))\"", "lemma sign_vec_semantics:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length ls\"\n  shows \"lookup_sem fml (map (\\<lambda>p. rpoly p x) ls) = lookup_sem fml (sign_vec ls x)\"", "lemma universal_lookup_sem:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length qs\"\n  assumes \"set signs = consistent_sign_vectors qs UNIV\"\n  shows \"(\\<forall>x::real. lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) \\<longleftrightarrow>\n    list_all (lookup_sem fml) signs\"", "lemma existential_lookup_sem:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length qs\"\n  assumes \"set signs = consistent_sign_vectors qs UNIV\"\n  shows \"(\\<exists>x::real. lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) \\<longleftrightarrow>\n    find (lookup_sem fml) signs \\<noteq> None\"", "lemma finite_prod_map_of_rat_poly_hom:\n  shows \"poly (real_of_rat_poly (\\<Prod>(a,b)\\<in>s. f a b)) y = (\\<Prod>(a,b)\\<in>s. poly (real_of_rat_poly (f a b)) y)\"", "lemma sign_vec_index_of:\n  assumes \"f \\<in> set ftrs\"\n  shows \"sign_vec ftrs x ! (index_of ftrs f) = squash (rpoly f x)\"", "lemma squash_idem:\n  shows \"squash (squash x) = squash x\"", "lemma squash_mult:\n  shows \"squash ((a::real) * b) = squash a * squash b\"", "lemma squash_prod_list:\n  shows \"squash (prod_list (ls::real list)) = prod_list (map squash ls)\"", "lemma squash_pow:\n  shows \"squash ((x::real) ^ (y::nat)) = (squash x) ^ y\"", "lemma squash_real_of_rat[simp]:\n  shows \"squash (real_of_rat x) = squash x\"", "lemma factorize_rat_poly_monic_irreducible_monic:\n  assumes \"factorize_rat_poly_monic f = (c,fs)\"\n  assumes \"(fi,i) \\<in> set fs\"\n  shows \"irreducible fi \\<and> monic fi\"", "lemma square_free_normalize:\n  assumes \"square_free p\"\n  shows \"square_free (normalize p)\"", "lemma coprime_normalize:\n  assumes \"coprime a b\"\n  shows \"coprime (normalize a) b\"", "lemma undo_normalize:\n  shows \"a = Polynomial.smult (unit_factor (lead_coeff a)) (normalize a)\"", "lemma finite_smult_distr:\n  assumes \"distinct fs\"\n  shows \"(\\<Prod>(x,y)\\<in>set fs. Polynomial.smult ((f x y)::rat) (g x y)) = \n    Polynomial.smult (\\<Prod>(x,y)\\<in>set fs. f x y) (\\<Prod>(x,y)\\<in>set fs. g x y)\"", "lemma normalize_coprime_degree:\n  assumes \"normalize (f::rat poly) = normalize g\"\n  assumes \"coprime f g\"\n  shows \"degree f = 0\"", "lemma factorize_rat_poly_monic_square_free_factorization:\n  assumes res: \"factorize_rat_poly_monic f = (c,fs)\"\n  shows \"square_free_factorization f (c,fs)\"", "lemma undo_factorize_correct:\n  assumes \"factorize_rat_poly_monic p = (c,fs)\"\n  assumes \"\\<And>f p. (f,p) \\<in> set fs \\<Longrightarrow> f \\<in> set ftrs\"\n  shows \"undo_factorize (c,map (\\<lambda>(f,pow). (index_of ftrs f, pow)) fs) (sign_vec ftrs x) = squash (rpoly p x)\"", "lemma length_sign_vec[simp]:\n  shows \"length (sign_vec ps x) = length ps\"", "lemma factorize_polys_has_factors:\n  assumes \"factorize_polys ps = (ftrs,data)\"\n  assumes \"p \\<in> set ps\"\n  assumes \"factorize_rat_poly_monic p = (c,fs)\"\n  shows \"set (map fst fs) \\<subseteq> set ftrs\"", "lemma factorize_polys_undo_factorize_polys:\n  assumes \"factorize_polys ps = (ftrs,data)\"\n  shows \"undo_factorize_polys data (sign_vec ftrs x) = sign_vec ps x\"", "lemma factorize_polys_irreducible_monic:\n  assumes \"factorize_polys ps = (fs,data)\"\n  shows \"distinct fs\" \"\\<And>f. f \\<in> set fs \\<Longrightarrow> irreducible f \\<and> monic f\"", "lemma factorize_polys_square_free:\n  assumes \"factorize_polys ps = (fs,data)\"\n  shows \"\\<And>f. f \\<in> set fs \\<Longrightarrow> square_free f\"", "lemma irreducible_monic_coprime:\n  assumes f: \"monic f\" \"irreducible (f::rat poly)\" \n  assumes g: \"monic g\" \"irreducible (g::rat poly)\"\n  assumes \"f \\<noteq> g\"\n  shows \"coprime f g\"", "lemma factorize_polys_coprime:\n  assumes \"factorize_polys ps = (fs,data)\"\n  shows \"\\<And>f g. f \\<in> set fs \\<Longrightarrow> g \\<in> set fs \\<Longrightarrow> f \\<noteq> g \\<Longrightarrow> coprime f g\"", "lemma coprime_rat_poly_real_poly:\n  assumes \"coprime p (q::rat poly)\"\n  shows \"coprime (real_of_rat_poly p) ((real_of_rat_poly q)::real poly)\"", "lemma coprime_rat_poly_iff_coprimereal_poly:\n  shows \"coprime p (q::rat poly) \\<longleftrightarrow> coprime (real_of_rat_poly p) ((real_of_rat_poly q)::real poly)\"", "lemma factorize_polys_map_distinct:\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss =  map real_of_rat_poly fs\"\n  shows \"distinct fss\"", "lemma factorize_polys_map_square_free:\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss =  map real_of_rat_poly fs\"\n  shows \"\\<And>f. f \\<in> set fss \\<Longrightarrow> square_free f\"", "lemma factorize_polys_map_coprime:\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss =  map real_of_rat_poly fs\"\n  shows \"\\<And>f g. f \\<in> set fss \\<Longrightarrow> g \\<in> set fss \\<Longrightarrow> f \\<noteq> g \\<Longrightarrow> coprime f g\"", "lemma coprime_prod_list:\n  assumes \"\\<And>p. p \\<in> set ps \\<Longrightarrow> p \\<noteq> 0\"\n  assumes \"coprime (prod_list ps) (q::real poly)\"  \n  shows \"\\<And>p. p \\<in> set ps \\<Longrightarrow> coprime p q\"", "lemma factorize_polys_square_free_prod_list:\n  assumes \"factorize_polys ps = (fs,data)\"\n  shows \"square_free (prod_list fs)\"", "lemma factorize_polys_map_square_free_prod_list:\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss =  map real_of_rat_poly fs\"\n  shows \"square_free (prod_list fss)\"", "lemma factorize_polys_map_coprime_pderiv:\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss = map real_of_rat_poly fs\"\n  shows \"\\<And>f. f \\<in> set fss \\<Longrightarrow> coprime f (pderiv (prod_list fss))\"", "lemma coprime_factorize:\n  fixes qs:: \"rat poly list\"\n  shows \"pairwise_coprime_list (fst(factorize_polys qs))\"", "lemma squarefree_factorization_degree:\n  assumes \"square_free_factorization p (c,fs)\"\n  shows \"degree p = sum_list (map (\\<lambda>(f,c). (c+1) * degree f) fs)\"", "lemma crb_lem_pos: \n  fixes x:: \"real\"\n  fixes p:: \"real poly\"\n  assumes x: \"poly p x = 0\" \n  assumes p: \"p \\<noteq> 0\" \n  shows \"x < crb p\"", "lemma crb_lem_neg: \n  fixes x:: \"real\"\n  fixes p:: \"real poly\"\n  assumes x: \"poly p x = 0\" \n  assumes p: \"p \\<noteq> 0\" \n  shows \"x > -crb p\"", "lemma prod_zero:\n  shows \"\\<forall>x . poly (prod_list (qs:: rat poly list)) x = 0 \\<longleftrightarrow> (\\<exists>q \\<in> set (qs). poly q x = 0)\"", "lemma coprime_r_zero1: \"poly (coprime_r qs) (crb (prod_list qs)) = 0\"", "lemma coprime_r_zero2: \"poly (coprime_r qs) (-crb (prod_list qs)) = 0\"", "lemma coprime_mult:\n  fixes a:: \"real poly\"\n  fixes b:: \"real poly\"\n  fixes c:: \"real poly\"\n  assumes \"algebraic_semidom_class.coprime a b\"\n  assumes \"algebraic_semidom_class.coprime a c\"\n  shows \"algebraic_semidom_class.coprime a (b*c)\"", "lemma coprime_r_coprime_prop:\n  fixes ps:: \"rat poly list\"\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss = map real_of_rat_poly fs\"\n  shows \"\\<And>f. f \\<in> set fss \\<Longrightarrow> coprime f (coprime_r fss)\"", "lemma coprime_r_nonzero:\n  fixes ps:: \"rat poly list\"\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes nonempty_fs: \"fs \\<noteq> []\"\n  assumes fss_is: \"fss = map real_of_rat_poly fs\"\n  shows \"(coprime_r fss) \\<noteq> 0\"", "lemma Rolle_pderiv:\n  fixes q:: \"real poly\"\n  fixes x1 x2:: \"real\"\n  shows \"(x1 < x2 \\<and> poly q x1 = 0 \\<and> poly q x2 = 0) \\<longrightarrow> (\\<exists>w. x1 < w \\<and> w < x2 \\<and> poly (pderiv q) w = 0)\"", "lemma coprime_r_roots_prop: \n  fixes qs:: \"real poly list\"\n  assumes pairwise_rel_prime: \"\\<forall>q1 q2. (q1 \\<noteq> q2 \\<and> (List.member qs q1) \\<and> (List.member qs q2))\\<longrightarrow> coprime q1 q2\"\n  shows \"\\<forall>x1. \\<forall>x2. ((x1 < x2 \\<and> (\\<exists>q1 \\<in> set (qs). (poly q1 x1) = 0) \\<and> (\\<exists>q2\\<in> set(qs). (poly q2 x2) = 0)) \\<longrightarrow> (\\<exists>q. x1 < q \\<and> q < x2 \\<and> poly (coprime_r qs) q = 0))\"", "lemma hnz_prop: \"has_no_zeros l \\<longleftrightarrow> \\<not>(\\<exists>k < length l. l ! k = 0)\"", "lemma consistent_sign_vectors_consistent_sign_vectors_r:\n  shows\"consistent_sign_vectors_r (cast_rat_list qs) S = consistent_sign_vectors qs S\"", "lemma coprime_over_reals_coprime_over_rats:\n  fixes qs:: \"rat poly list\"\n  assumes csa_in: \"csa \\<in> (consistent_sign_vectors qs UNIV)\"\n  assumes p1p2: \"p1\\<noteq>p2 \\<and> p1 < length csa \\<and> p2 < length csa \\<and> csa ! p1 = 0 \\<and> csa ! p2 = 0\"\n  shows \"\\<not> algebraic_semidom_class.coprime (nth qs p1) (nth qs p2) \"", "lemma zero_above: \n  fixes qs:: \"rat poly list\"\n  fixes x1:: \"real\"\n  assumes hnz: \"has_no_zeros (sign_vec qs x1)\"\n  shows \"(\\<forall> x2 > x1. ((sign_vec qs x1) \\<noteq> (sign_vec qs x2)) \\<longrightarrow> \n  (\\<exists>(r::real) > x1. (r \\<le> x2 \\<and> (\\<exists> q \\<in> set(qs). rpoly q r = 0))))\"", "lemma zero_below: \n  fixes qs:: \"rat poly list\"\n  fixes x1:: \"real\"\n  assumes hnz: \"has_no_zeros (sign_vec qs x1)\"\n  shows \"\\<forall>x2 < x1. ((sign_vec qs x1) \\<noteq> (sign_vec qs x2)) \\<longrightarrow> \n  (\\<exists>(r::real) < x1. (r \\<ge> x2 \\<and> (\\<exists> q \\<in> set(qs). rpoly q r = 0)))\"", "lemma sorted_list_lemma:\n  fixes l:: \"real list\"\n  fixes a b:: \"real\"\n  fixes n:: \"nat\"\n  assumes \"a < b\"\n  assumes \"(n + 1) < length l\"\n  assumes strict_sort: \"strict_sorted l\"\n  assumes lt_a: \"(l ! n) < a\"\n  assumes b_lt: \"b < (l ! (n+1))\"\n  shows \"\\<not>(\\<exists>(x::real). (List.member l x \\<and> a \\<le> x \\<and> x \\<le> b))\"", "lemma roots_of_coprime_r_location_property: \n  fixes qs:: \"rat poly list\"\n  fixes sga:: \"rat list\"\n  fixes zer_list\n  assumes pairwise_rel_prime: \"pairwise_coprime_list qs\"\n  assumes all_squarefree: \"\\<And>q. q \\<in> set qs \\<Longrightarrow> rsquarefree q\"\n  assumes x1_prop: \"sga = sign_vec qs x1\"\n  assumes hnz: \"has_no_zeros sga\"\n  assumes zer_list_prop: \"zer_list = sorted_list_of_set {(x::real). (\\<exists>q \\<in> set(qs). (rpoly q x = 0))}\"\n  shows \"zer_list \\<noteq> [] \\<longrightarrow> ((x1 < (zer_list ! 0)) \\<or> (x1 > (zer_list ! (length zer_list - 1)) \\<or>\n    (\\<exists> n < (length zer_list - 1). x1 > (zer_list ! n) \\<and> x1 < (zer_list ! (n+1)))))\"", "lemma roots_of_coprime_r_capture_sgas_without_zeros: \n  fixes qs:: \"rat poly list\"\n  fixes sga:: \"rat list\"\n  assumes pairwise_rel_prime: \"pairwise_coprime_list qs\"\n  assumes all_squarefree: \"\\<And>q. q \\<in> set qs \\<Longrightarrow> rsquarefree q\"\n  assumes ex_x1: \"sga = sign_vec qs x1\"\n  assumes hnz: \"has_no_zeros sga\"\n  shows \"(\\<exists>w \\<in> (roots_of_coprime_r (cast_rat_list qs)). sga = (sign_vec qs w))\"", "lemma find_csas_lemma_nozeros:\n  fixes qs:: \"rat poly list\"\n  assumes fs: \"factorize_polys qs = (fs,data)\"\n  assumes \"fs \\<noteq> []\"\n  shows \"(csa \\<in> (consistent_sign_vectors fs UNIV) \\<and> has_no_zeros csa) \\<longleftrightarrow> \n    csa \\<in> set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))  (cast_rat_list fs))\"", "lemma range_eq: \n  fixes a\n  fixes b\n  shows \"a = b \\<longrightarrow> range a = range b\"", "lemma removeAt_distinct:\n  shows \"distinct fss \\<Longrightarrow> distinct (removeAt i fss)\"", "lemma consistent_signs_atw:\n  assumes \"\\<And>p. p \\<in> set fs \\<Longrightarrow> poly p x \\<noteq> 0\"\n  shows \"consistent_sign_vec_copr fs x = signs_at fs x\"", "lemma characterize_consistent_signs_at_roots_rw:\n  assumes \"p \\<noteq> 0\"\n  assumes copr: \"\\<And>q. q \\<in> set fs \\<Longrightarrow> coprime p q\"\n  shows \"set (characterize_consistent_signs_at_roots p fs) =\n    consistent_sign_vectors_r fs ({x. poly p x = 0})\"", "lemma signs_at_insert:\n  assumes \"i \\<le> length qs\"\n  shows \"insertAt i (squash (poly p x)) (signs_at qs x) =\n    signs_at (insertAt i p qs) x\"", "lemma length_removeAt:\n  assumes \"i < length ls\"\n  shows \"length (removeAt i ls) = length ls - 1\"", "lemma insertAt_removeAt:\n  assumes \"i < length ls\"\n  shows \"insertAt i (ls!i) (removeAt i ls) = ls\"", "lemma insertAt_nth:\n  assumes \"i \\<le> length ls\"\n  shows \"insertAt i n ls ! i = n\"", "lemma length_signs_at[simp]:\n  shows \"length (signs_at qs x) = length qs\"", "lemma find_csa_at_index:\n  assumes \"i < length fss\"\n  assumes \"\\<And>p q. p \\<in> set fss \\<Longrightarrow> q \\<in> set fss \\<Longrightarrow> p \\<noteq> q \\<Longrightarrow> coprime p q\"\n  assumes \"\\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0\"\n  assumes \"distinct fss\"\n  shows \"\n  set (map (\\<lambda>v. insertAt i 0 v) (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\"", "lemma in_set_concat_map:\n  assumes \"i < length ls\"\n  assumes \"x \\<in> set (f (ls ! i))\"\n  shows \"x \\<in> set (concat (map f ls))\"", "lemma find_csas_lemma_onezero_gen:\n  fixes qs:: \"rat poly list\"\n  assumes fs: \"factorize_polys qs = (fs,data)\"\n  assumes fss: \"fss = cast_rat_list fs\"\n  shows \"(csa \\<in> (consistent_sign_vectors_r fss UNIV) \\<and> \\<not>(has_no_zeros csa))\n    \\<longleftrightarrow>  csa \\<in> set (find_sgas_aux fss)\"", "lemma mem_append: \"List.member (l1@l2) m \\<longleftrightarrow> (List.member l1 m \\<or> List.member l2 m)\"", "lemma same_sign_cond_rationals_reals:\n  fixes qs:: \"rat poly list\"\n  assumes lenh: \"length (fst(factorize_polys qs)) > 0\"\n  shows \"set(find_sgas (map (map_poly of_rat) (fst(factorize_polys qs)))) = consistent_sign_vectors (fst(factorize_polys qs)) UNIV\"", "lemma factorize_polys_undo_factorize_polys_set:\n  assumes \"factorize_polys ps = (ftrs,data)\"\n  assumes \"sgas =  find_sgas (map (map_poly of_rat) ftrs)\"\n  assumes sgas_set: \"set (sgas) = consistent_sign_vectors ftrs UNIV\"\n  shows \"set (map (undo_factorize_polys data) sgas) = consistent_sign_vectors ps UNIV\"", "lemma main_step_aux1:\n  fixes qs:: \"rat poly list\"\n  assumes empty: \"(fst(factorize_polys qs)) = []\"\n  shows \"set (find_consistent_signs qs) =  consistent_sign_vectors qs UNIV\"", "lemma main_step_aux2:\n  fixes qs:: \"rat poly list\"\n  assumes lenh: \"length (fst(factorize_polys qs)) > 0\"\n  shows \"set (find_consistent_signs qs) =  consistent_sign_vectors qs UNIV\"", "lemma main_step:\n  fixes qs:: \"rat poly list\"\n  shows \"set (find_consistent_signs qs) =  consistent_sign_vectors qs UNIV\"", "lemma decide_univ_lem_helper:\n  assumes \"(fml_struct,polys) = convert fml\"\n  shows \"(\\<forall>x::real. lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) \\<longleftrightarrow>\n    (decide_universal fml)\"", "lemma decide_exis_lem_helper:\n  assumes \"(fml_struct,polys) = convert fml\"\n  shows \"(\\<exists>x::real. lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) \\<longleftrightarrow>\n    (decide_existential fml)\"", "theorem decision_procedure:\n  shows \"(\\<forall>x::real. fml_sem fml x) \\<longleftrightarrow> (decide_universal fml)\"\n    \"\\<exists>x::real. fml_sem fml x \\<longleftrightarrow> (decide_existential fml)\""], "translations": [["", "lemma poly_list_set_fml:\n  shows \"set (poly_list fml) = set_fml fml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (poly_list fml) = set_fml fml", "apply (induction)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>set (poly_list x1) = set_fml x1;\n        set (poly_list x2) = set_fml x2\\<rbrakk>\n       \\<Longrightarrow> set (poly_list (And x1 x2)) = set_fml (And x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>set (poly_list x1) = set_fml x1;\n        set (poly_list x2) = set_fml x2\\<rbrakk>\n       \\<Longrightarrow> set (poly_list (Or x1 x2)) = set_fml (Or x1 x2)\n 3. \\<And>x. set (poly_list (fml.Gt x)) = set_fml (fml.Gt x)\n 4. \\<And>x. set (poly_list (Geq x)) = set_fml (Geq x)\n 5. \\<And>x. set (poly_list (fml.Lt x)) = set_fml (fml.Lt x)\n 6. \\<And>x. set (poly_list (Leq x)) = set_fml (Leq x)\n 7. \\<And>x. set (poly_list (fml.Eq x)) = set_fml (fml.Eq x)\n 8. \\<And>x. set (poly_list (Neq x)) = set_fml (Neq x)", "by auto"], ["", "lemma convert_semantics_lem:\n  assumes \"\\<And>p. p \\<in> set (poly_list fml) \\<Longrightarrow>\n    ls ! (index_of ps p) = rpoly p x\"\n  shows \"fml_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls", "using assms"], ["proof (prove)\nusing this:\n  ?p \\<in> set (poly_list fml) \\<Longrightarrow>\n  ls ! index_of ps ?p = rpoly ?p x\n\ngoal (1 subgoal):\n 1. fml_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls", "apply (induct fml)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>fml1 fml2.\n       \\<lbrakk>(\\<And>p.\n                    p \\<in> set (poly_list fml1) \\<Longrightarrow>\n                    ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n                fml_sem fml1 x = lookup_sem (map_fml (index_of ps) fml1) ls;\n        (\\<And>p.\n            p \\<in> set (poly_list fml2) \\<Longrightarrow>\n            ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n        fml_sem fml2 x = lookup_sem (map_fml (index_of ps) fml2) ls;\n        \\<And>p.\n           p \\<in> set (poly_list (And fml1 fml2)) \\<Longrightarrow>\n           ls ! index_of ps p = rpoly p x\\<rbrakk>\n       \\<Longrightarrow> fml_sem (And fml1 fml2) x =\n                         lookup_sem (map_fml (index_of ps) (And fml1 fml2))\n                          ls\n 2. \\<And>fml1 fml2.\n       \\<lbrakk>(\\<And>p.\n                    p \\<in> set (poly_list fml1) \\<Longrightarrow>\n                    ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n                fml_sem fml1 x = lookup_sem (map_fml (index_of ps) fml1) ls;\n        (\\<And>p.\n            p \\<in> set (poly_list fml2) \\<Longrightarrow>\n            ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n        fml_sem fml2 x = lookup_sem (map_fml (index_of ps) fml2) ls;\n        \\<And>p.\n           p \\<in> set (poly_list (Or fml1 fml2)) \\<Longrightarrow>\n           ls ! index_of ps p = rpoly p x\\<rbrakk>\n       \\<Longrightarrow> fml_sem (Or fml1 fml2) x =\n                         lookup_sem (map_fml (index_of ps) (Or fml1 fml2))\n                          ls\n 3. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (fml.Gt xa)) \\<Longrightarrow>\n           ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n       fml_sem (fml.Gt xa) x =\n       lookup_sem (map_fml (index_of ps) (fml.Gt xa)) ls\n 4. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (Geq xa)) \\<Longrightarrow>\n           ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n       fml_sem (Geq xa) x = lookup_sem (map_fml (index_of ps) (Geq xa)) ls\n 5. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (fml.Lt xa)) \\<Longrightarrow>\n           ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n       fml_sem (fml.Lt xa) x =\n       lookup_sem (map_fml (index_of ps) (fml.Lt xa)) ls\n 6. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (Leq xa)) \\<Longrightarrow>\n           ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n       fml_sem (Leq xa) x = lookup_sem (map_fml (index_of ps) (Leq xa)) ls\n 7. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (fml.Eq xa)) \\<Longrightarrow>\n           ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n       fml_sem (fml.Eq xa) x =\n       lookup_sem (map_fml (index_of ps) (fml.Eq xa)) ls\n 8. \\<And>xa.\n       (\\<And>p.\n           p \\<in> set (poly_list (Neq xa)) \\<Longrightarrow>\n           ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n       fml_sem (Neq xa) x = lookup_sem (map_fml (index_of ps) (Neq xa)) ls", "by auto"], ["", "lemma index_of_aux_more:\n  shows \"index_of_aux ls p n \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> index_of_aux ls p n", "apply (induct ls arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. n \\<le> index_of_aux [] p n\n 2. \\<And>a ls n.\n       (\\<And>n. n \\<le> index_of_aux ls p n) \\<Longrightarrow>\n       n \\<le> index_of_aux (a # ls) p n", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ls n.\n       \\<lbrakk>\\<And>n. n \\<le> index_of_aux ls p n; a \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> n \\<le> index_of_aux ls p (Suc n)", "using Suc_leD"], ["proof (prove)\nusing this:\n  Suc ?m \\<le> ?n \\<Longrightarrow> ?m \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<And>a ls n.\n       \\<lbrakk>\\<And>n. n \\<le> index_of_aux ls p n; a \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> n \\<le> index_of_aux ls p (Suc n)", "by blast"], ["", "lemma index_of_aux_lookup:\n  assumes \"p \\<in> set ls\"\n  shows \"(index_of_aux ls p n) - n < length ls\"\n    \"ls ! ((index_of_aux ls p n) - n) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of_aux ls p n - n < length ls &&&\n    ls ! (index_of_aux ls p n - n) = p", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> set ls\n\ngoal (1 subgoal):\n 1. index_of_aux ls p n - n < length ls &&&\n    ls ! (index_of_aux ls p n - n) = p", "apply (induct ls arbitrary: n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n.\n       p \\<in> set [] \\<Longrightarrow> index_of_aux [] p n - n < length []\n 2. \\<And>n.\n       p \\<in> set [] \\<Longrightarrow> [] ! (index_of_aux [] p n - n) = p\n 3. \\<And>a ls n.\n       \\<lbrakk>\\<And>n.\n                   p \\<in> set ls \\<Longrightarrow>\n                   index_of_aux ls p n - n < length ls;\n        \\<And>n.\n           p \\<in> set ls \\<Longrightarrow>\n           ls ! (index_of_aux ls p n - n) = p;\n        p \\<in> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> index_of_aux (a # ls) p n - n < length (a # ls)\n 4. \\<And>a ls n.\n       \\<lbrakk>\\<And>n.\n                   p \\<in> set ls \\<Longrightarrow>\n                   index_of_aux ls p n - n < length ls;\n        \\<And>n.\n           p \\<in> set ls \\<Longrightarrow>\n           ls ! (index_of_aux ls p n - n) = p;\n        p \\<in> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> (a # ls) ! (index_of_aux (a # ls) p n - n) = p", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ls n.\n       \\<lbrakk>\\<And>n. index_of_aux ls p n - n < length ls;\n        \\<And>n. ls ! (index_of_aux ls p n - n) = p; a \\<noteq> p;\n        p \\<in> set ls\\<rbrakk>\n       \\<Longrightarrow> index_of_aux ls p (Suc n) - n < Suc (length ls)\n 2. \\<And>a ls n.\n       \\<lbrakk>\\<And>n. index_of_aux ls p n - n < length ls;\n        \\<And>n. ls ! (index_of_aux ls p n - n) = p; a \\<noteq> p;\n        p \\<in> set ls\\<rbrakk>\n       \\<Longrightarrow> (a # ls) ! (index_of_aux ls p (Suc n) - n) = p", "apply (metis Suc_diff_Suc index_of_aux_more lessI less_Suc_eq_0_disj less_le_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ls n.\n       \\<lbrakk>\\<And>n. index_of_aux ls p n - n < length ls;\n        \\<And>n. ls ! (index_of_aux ls p n - n) = p; a \\<noteq> p;\n        p \\<in> set ls\\<rbrakk>\n       \\<Longrightarrow> (a # ls) ! (index_of_aux ls p (Suc n) - n) = p", "by (metis Suc_diff_Suc index_of_aux_more lessI less_le_trans nth_Cons_Suc)"], ["", "lemma index_of_lookup:\n  assumes \"p \\<in> set ls\"\n  shows \"index_of ls p < length ls\"\n    \"ls ! (index_of ls p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of ls p < length ls &&& ls ! index_of ls p = p", "apply (metis assms index_of_aux_lookup(1) index_of_def minus_nat.diff_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ls ! index_of ls p = p", "by (metis assms index_of_aux_lookup(2) index_of_def minus_nat.diff_0)"], ["", "lemma convert_semantics:\n  shows \"fml_sem fml x = lookup_sem (fst (convert fml)) (map (\\<lambda>p. rpoly p x) (snd (convert fml)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem fml x =\n    lookup_sem (fst (convert fml))\n     (map (\\<lambda>p. rpoly p x) (snd (convert fml)))", "unfolding convert_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem fml x =\n    lookup_sem\n     (fst (map_fml (index_of (remdups (poly_list fml))) fml,\n           remdups (poly_list fml)))\n     (map (\\<lambda>p. rpoly p x)\n       (snd (map_fml (index_of (remdups (poly_list fml))) fml,\n             remdups (poly_list fml))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fml_sem fml x =\n    lookup_sem (map_fml (index_of (remdups (poly_list fml))) fml)\n     (map (\\<lambda>p. rpoly p x) (remdups (poly_list fml)))", "apply (intro convert_semantics_lem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> set (poly_list fml) \\<Longrightarrow>\n       map (\\<lambda>p. rpoly p x) (remdups (poly_list fml)) !\n       index_of (remdups (poly_list fml)) p =\n       rpoly p x", "by (simp add: index_of_lookup(1) index_of_lookup(2))"], ["", "lemma convert_closed:\n  shows \"\\<And>i. i \\<in> set_fml (fst (convert fml)) \\<Longrightarrow> i < length (snd (convert fml))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set_fml (fst (convert fml)) \\<Longrightarrow>\n       i < length (snd (convert fml))", "unfolding convert_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set_fml\n                (fst (map_fml (index_of (remdups (poly_list fml))) fml,\n                      remdups (poly_list fml))) \\<Longrightarrow>\n       i < length\n            (snd (map_fml (index_of (remdups (poly_list fml))) fml,\n                  remdups (poly_list fml)))", "apply (auto simp add: fml.set_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_fml fml \\<Longrightarrow>\n       index_of (remdups (poly_list fml)) x\n       < length (remdups (poly_list fml))", "by (simp add: index_of_lookup(1) poly_list_set_fml)"], ["", "(* Rational sign vector of polynomials qs with rational coefficients at x *)"], ["", "definition sign_vec::\"rat poly list \\<Rightarrow> real \\<Rightarrow> rat list\"\n  where \"sign_vec qs x \\<equiv>\n    map (squash \\<circ> (\\<lambda>p. rpoly p x)) qs\""], ["", "(* The set of all rational sign vectors for qs wrt the set S\n  When S = UNIV, then this quantifies over all reals *)"], ["", "definition consistent_sign_vectors::\"rat poly list \\<Rightarrow> real set \\<Rightarrow> rat list set\"\n  where \"consistent_sign_vectors qs S = (sign_vec qs) ` S\""], ["", "lemma sign_vec_semantics:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length ls\"\n  shows \"lookup_sem fml (map (\\<lambda>p. rpoly p x) ls) = lookup_sem fml (sign_vec ls x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_sem fml (map (\\<lambda>p. rpoly p x) ls) =\n    lookup_sem fml (sign_vec ls x)", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> set_fml fml \\<Longrightarrow> ?i < length ls\n\ngoal (1 subgoal):\n 1. lookup_sem fml (map (\\<lambda>p. rpoly p x) ls) =\n    lookup_sem fml (sign_vec ls x)", "apply (induction)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(\\<And>i.\n                    i \\<in> set_fml x1 \\<Longrightarrow>\n                    i < length ls) \\<Longrightarrow>\n                lookup_sem x1 (map (\\<lambda>p. rpoly p x) ls) =\n                lookup_sem x1 (sign_vec ls x);\n        (\\<And>i.\n            i \\<in> set_fml x2 \\<Longrightarrow>\n            i < length ls) \\<Longrightarrow>\n        lookup_sem x2 (map (\\<lambda>p. rpoly p x) ls) =\n        lookup_sem x2 (sign_vec ls x);\n        \\<And>i.\n           i \\<in> set_fml (And x1 x2) \\<Longrightarrow>\n           i < length ls\\<rbrakk>\n       \\<Longrightarrow> lookup_sem (And x1 x2)\n                          (map (\\<lambda>p. rpoly p x) ls) =\n                         lookup_sem (And x1 x2) (sign_vec ls x)\n 2. \\<And>x1 x2.\n       \\<lbrakk>(\\<And>i.\n                    i \\<in> set_fml x1 \\<Longrightarrow>\n                    i < length ls) \\<Longrightarrow>\n                lookup_sem x1 (map (\\<lambda>p. rpoly p x) ls) =\n                lookup_sem x1 (sign_vec ls x);\n        (\\<And>i.\n            i \\<in> set_fml x2 \\<Longrightarrow>\n            i < length ls) \\<Longrightarrow>\n        lookup_sem x2 (map (\\<lambda>p. rpoly p x) ls) =\n        lookup_sem x2 (sign_vec ls x);\n        \\<And>i.\n           i \\<in> set_fml (Or x1 x2) \\<Longrightarrow>\n           i < length ls\\<rbrakk>\n       \\<Longrightarrow> lookup_sem (Or x1 x2)\n                          (map (\\<lambda>p. rpoly p x) ls) =\n                         lookup_sem (Or x1 x2) (sign_vec ls x)\n 3. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (fml.Gt xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (fml.Gt xa) (map (\\<lambda>p. rpoly p x) ls) =\n       lookup_sem (fml.Gt xa) (sign_vec ls x)\n 4. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (Geq xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (Geq xa) (map (\\<lambda>p. rpoly p x) ls) =\n       lookup_sem (Geq xa) (sign_vec ls x)\n 5. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (fml.Lt xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (fml.Lt xa) (map (\\<lambda>p. rpoly p x) ls) =\n       lookup_sem (fml.Lt xa) (sign_vec ls x)\n 6. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (Leq xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (Leq xa) (map (\\<lambda>p. rpoly p x) ls) =\n       lookup_sem (Leq xa) (sign_vec ls x)\n 7. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (fml.Eq xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (fml.Eq xa) (map (\\<lambda>p. rpoly p x) ls) =\n       lookup_sem (fml.Eq xa) (sign_vec ls x)\n 8. \\<And>xa.\n       (\\<And>i.\n           i \\<in> set_fml (Neq xa) \\<Longrightarrow>\n           i < length ls) \\<Longrightarrow>\n       lookup_sem (Neq xa) (map (\\<lambda>p. rpoly p x) ls) =\n       lookup_sem (Neq xa) (sign_vec ls x)", "by (auto simp add: sign_vec_def squash_def)"], ["", "(* The universal and existential decision procedure is easy if we know the consistent sign vectors *)"], ["", "lemma universal_lookup_sem:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length qs\"\n  assumes \"set signs = consistent_sign_vectors qs UNIV\"\n  shows \"(\\<forall>x::real. lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) \\<longleftrightarrow>\n    list_all (lookup_sem fml) signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n    list_all (lookup_sem fml) signs", "using assms(2)"], ["proof (prove)\nusing this:\n  set signs = consistent_sign_vectors qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<forall>x. lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n    list_all (lookup_sem fml) signs", "unfolding consistent_sign_vectors_def list_all_iff"], ["proof (prove)\nusing this:\n  set signs = range (sign_vec qs)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n    Ball (set signs) (lookup_sem fml)", "by (simp add: assms(1) sign_vec_semantics)"], ["", "lemma existential_lookup_sem:\n  assumes \"\\<And>i. i \\<in> set_fml fml \\<Longrightarrow> i < length qs\"\n  assumes \"set signs = consistent_sign_vectors qs UNIV\"\n  shows \"(\\<exists>x::real. lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) \\<longleftrightarrow>\n    find (lookup_sem fml) signs \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n    (find (lookup_sem fml) signs \\<noteq> None)", "using assms(2)"], ["proof (prove)\nusing this:\n  set signs = consistent_sign_vectors qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<exists>x. lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n    (find (lookup_sem fml) signs \\<noteq> None)", "unfolding consistent_sign_vectors_def find_None_iff"], ["proof (prove)\nusing this:\n  set signs = range (sign_vec qs)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n    (\\<not> (\\<nexists>x. x \\<in> set signs \\<and> lookup_sem fml x))", "by (simp add: assms(1) sign_vec_semantics)"], ["", "subsection \"Factoring Lemmas\""], ["", "(*definition real_factorize_list:: \"rat poly list \\<Rightarrow> real poly list\"\nwhere \"real_factorize_list qs = map (map_poly of_rat) (fst(factorize_polys qs))\"\n*)"], ["", "interpretation of_rat_poly_hom: map_poly_comm_semiring_hom of_rat"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_semiring_hom of_rat", ".."], ["", "interpretation of_rat_poly_hom: map_poly_comm_ring_hom of_rat"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_ring_hom of_rat", ".."], ["", "interpretation of_rat_poly_hom: map_poly_idom_hom of_rat"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_idom_hom of_rat", ".."], ["", "lemma finite_prod_map_of_rat_poly_hom:\n  shows \"poly (real_of_rat_poly (\\<Prod>(a,b)\\<in>s. f a b)) y = (\\<Prod>(a,b)\\<in>s. poly (real_of_rat_poly (f a b)) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpoly (\\<Prod>(a, b)\\<in>s. f a b) y =\n    (\\<Prod>(a, b)\\<in>s. rpoly (f a b) y)", "apply (simp add: of_rat_poly_hom.hom_prod poly_prod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>s. rpoly (case x of (x, xa) \\<Rightarrow> f x xa) y) =\n    (\\<Prod>x\\<in>s. case x of (a, b) \\<Rightarrow> rpoly (f a b) y)", "by (simp add: case_prod_app prod.case_distrib)"], ["", "lemma sign_vec_index_of:\n  assumes \"f \\<in> set ftrs\"\n  shows \"sign_vec ftrs x ! (index_of ftrs f) = squash (rpoly f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_vec ftrs x ! index_of ftrs f = squash (rpoly f x)", "by (simp add: assms index_of_lookup(1) index_of_lookup(2) sign_vec_def)"], ["", "lemma squash_idem:\n  shows \"squash (squash x) = squash x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (squash x) = squash x", "unfolding squash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 < (if (0::'a) < x then 1 else if x < (0::'a) then - 1 else 0)\n     then 1\n     else if (if (0::'a) < x then 1 else if x < (0::'a) then - 1 else 0) < 0\n          then - 1 else 0) =\n    (if (0::'a) < x then 1 else if x < (0::'a) then - 1 else 0)", "by auto"], ["", "lemma squash_mult:\n  shows \"squash ((a::real) * b) = squash a * squash b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (a * b) = squash a * squash b", "unfolding squash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 < a * b then 1 else if a * b < 0 then - 1 else 0) =\n    (if 0 < a then 1 else if a < 0 then - 1 else 0) *\n    (if 0 < b then 1 else if b < 0 then - 1 else 0)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b < 0; a < 0; a * b < 0\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>a < 0; 0 < b\\<rbrakk> \\<Longrightarrow> a * b < 0", "using less_not_sym mult_neg_neg"], ["proof (prove)\nusing this:\n  ?x < ?y \\<Longrightarrow> \\<not> ?y < ?x\n  \\<lbrakk>?a < (0::?'a); ?b < (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?a * ?b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b < 0; a < 0; a * b < 0\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>a < 0; 0 < b\\<rbrakk> \\<Longrightarrow> a * b < 0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 0; 0 < b\\<rbrakk> \\<Longrightarrow> a * b < 0", "using mult_less_0_iff"], ["proof (prove)\nusing this:\n  (?a * ?b < (0::?'a)) =\n  ((0::?'a) < ?a \\<and> ?b < (0::?'a) \\<or>\n   ?a < (0::?'a) \\<and> (0::?'a) < ?b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a < 0; 0 < b\\<rbrakk> \\<Longrightarrow> a * b < 0", "by blast"], ["", "lemma squash_prod_list:\n  shows \"squash (prod_list (ls::real list)) = prod_list (map squash ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (prod_list ls) = prod_list (map squash ls)", "apply (induction ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. squash (prod_list []) = prod_list (map squash [])\n 2. \\<And>a ls.\n       squash (prod_list ls) = prod_list (map squash ls) \\<Longrightarrow>\n       squash (prod_list (a # ls)) = prod_list (map squash (a # ls))", "unfolding squash_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. (if 0 < prod_list [] then 1 else if prod_list [] < 0 then - 1 else 0) =\n    (\\<Prod>a\\<leftarrow>[]. if 0 < a then 1 else if a < 0 then - 1 else 0)\n 2. \\<And>a ls.\n       (if 0 < prod_list ls then 1\n        else if prod_list ls < 0 then - 1 else 0) =\n       (\\<Prod>a\\<leftarrow>ls. if 0 < a then 1\n                                else if a < 0 then - 1\n                                     else 0) \\<Longrightarrow>\n       (if 0 < prod_list (a # ls) then 1\n        else if prod_list (a # ls) < 0 then - 1 else 0) =\n       (\\<Prod>a\\<leftarrow>a #\n                            ls. if 0 < a then 1\n                                else if a < 0 then - 1 else 0)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ls.\n       \\<lbrakk>(if 0 < prod_list ls then 1\n                 else if prod_list ls < 0 then - 1 else 0) =\n                (\\<Prod>a\\<leftarrow>ls. if 0 < a then 1\n   else if a < 0 then - 1 else 0);\n        a < 0; a * prod_list ls < 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>a\\<leftarrow>ls. if 0 < a then 1\n            else if a < 0 then - 1 else 0) =\n                         1\n 2. \\<And>a ls.\n       \\<lbrakk>(if 0 < prod_list ls then 1\n                 else if prod_list ls < 0 then - 1 else 0) =\n                (\\<Prod>a\\<leftarrow>ls. if 0 < a then 1\n   else if a < 0 then - 1 else 0);\n        a < 0; 0 < a * prod_list ls\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>a\\<leftarrow>ls. if 0 < a then 1\n            else if a < 0 then - 1 else 0) =\n                         - 1", "apply (simp add: mult_less_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>(if 0 < prod_list ls then 1\n                 else if prod_list ls < 0 then - 1 else 0) =\n                (\\<Prod>a\\<leftarrow>ls. if 0 < a then 1\n   else if a < 0 then - 1 else 0);\n        a < 0; 0 < a * prod_list ls\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>a\\<leftarrow>ls. if 0 < a then 1\n            else if a < 0 then - 1 else 0) =\n                         - 1", "by (simp add: zero_less_mult_iff)"], ["", "lemma squash_pow:\n  shows \"squash ((x::real) ^ (y::nat)) = (squash x) ^ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (x ^ y) = squash x ^ y", "unfolding squash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 < x ^ y then 1 else if x ^ y < 0 then - 1 else 0) =\n    (if 0 < x then 1 else if x < 0 then - 1 else 0) ^ y", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>x < 0; odd y; 0 < x ^ y\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>x < 0; even y\\<rbrakk> \\<Longrightarrow> 0 < x ^ y\n 3. \\<lbrakk>x = 0; even y; 0 < 0 ^ y\\<rbrakk> \\<Longrightarrow> 0 ^ y = 1\n 4. \\<lbrakk>x = 0; even y; \\<not> 0 < 0 ^ y\\<rbrakk>\n    \\<Longrightarrow> 0 < y\n 5. \\<lbrakk>x = 0; 0 < 0 ^ y\\<rbrakk> \\<Longrightarrow> 0 ^ y = 1\n 6. \\<lbrakk>x = 0; \\<not> 0 < 0 ^ y\\<rbrakk> \\<Longrightarrow> 0 < y", "by (auto simp add: zero_less_power_eq)"], ["", "lemma squash_real_of_rat[simp]:\n  shows \"squash (real_of_rat x) = squash x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (real_of_rat x) = squash x", "unfolding squash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 < real_of_rat x then 1\n     else if real_of_rat x < 0 then - 1 else 0) =\n    (if 0 < x then 1 else if x < 0 then - 1 else 0)", "by auto"], ["", "lemma factorize_rat_poly_monic_irreducible_monic:\n  assumes \"factorize_rat_poly_monic f = (c,fs)\"\n  assumes \"(fi,i) \\<in> set fs\"\n  shows \"irreducible fi \\<and> monic fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible fi \\<and> monic fi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. irreducible fi \\<and> monic fi", "obtain c' fs' where cfs: \"factorize_rat_poly f = (c',fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c' fs'.\n        factorize_rat_poly f = (c', fs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  factorize_rat_poly f = (c', fs')\n\ngoal (1 subgoal):\n 1. irreducible fi \\<and> monic fi", "then"], ["proof (chain)\npicking this:\n  factorize_rat_poly f = (c', fs')", "have fs: \"fs = map (\\<lambda>(f,i). (normalize f, i)) fs'\""], ["proof (prove)\nusing this:\n  factorize_rat_poly f = (c', fs')\n\ngoal (1 subgoal):\n 1. fs = map (\\<lambda>(f, i). (normalize f, i)) fs'", "using factorize_rat_poly_monic_def assms"], ["proof (prove)\nusing this:\n  factorize_rat_poly f = (c', fs')\n  factorize_rat_poly_monic ?p =\n  (let (c, fs) = factorize_rat_poly ?p;\n       lcs = \\<Prod>(f, i)\\<leftarrow>fs. lead_coeff f ^ Suc i\n   in Let (map (\\<lambda>(f, i). (normalize f, i)) fs) (Pair (c * lcs)))\n  factorize_rat_poly_monic f = (c, fs)\n  (fi, i) \\<in> set fs\n\ngoal (1 subgoal):\n 1. fs = map (\\<lambda>(f, i). (normalize f, i)) fs'", "by auto"], ["proof (state)\nthis:\n  fs = map (\\<lambda>(f, i). (normalize f, i)) fs'\n\ngoal (1 subgoal):\n 1. irreducible fi \\<and> monic fi", "obtain \"fi'\" where \"(fi',i) \\<in> set fs'\" \"fi = normalize fi'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fi'.\n        \\<lbrakk>(fi', i) \\<in> set fs'; fi = normalize fi'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  (fi, i) \\<in> set fs\n\ngoal (1 subgoal):\n 1. (\\<And>fi'.\n        \\<lbrakk>(fi', i) \\<in> set fs'; fi = normalize fi'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fs"], ["proof (prove)\nusing this:\n  (fi, i) \\<in> set (map (\\<lambda>(f, y). (normalize f, y)) fs')\n\ngoal (1 subgoal):\n 1. (\\<And>fi'.\n        \\<lbrakk>(fi', i) \\<in> set fs'; fi = normalize fi'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (fi', i) \\<in> set fs'\n  fi = normalize fi'\n\ngoal (1 subgoal):\n 1. irreducible fi \\<and> monic fi", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fi', i) \\<in> set fs'\n  fi = normalize fi'\n\ngoal (1 subgoal):\n 1. irreducible fi \\<and> monic fi", "using factorize_rat_poly irreducible_normalize_iff"], ["proof (prove)\nusing this:\n  (fi', i) \\<in> set fs'\n  fi = normalize fi'\n  factorize_rat_poly_generic ?alg ?f = (?c, ?fs) \\<Longrightarrow>\n  square_free_factorization ?f (?c, ?fs)\n  \\<lbrakk>factorize_rat_poly_generic ?alg ?f = (?c, ?fs);\n   (?fi, ?i) \\<in> set ?fs\\<rbrakk>\n  \\<Longrightarrow> irreducible ?fi\n  irreducible (normalize ?x) = irreducible ?x\n\ngoal (1 subgoal):\n 1. irreducible fi \\<and> monic fi", "by (metis cfs monic_normalize not_irreducible_zero)"], ["proof (state)\nthis:\n  irreducible fi \\<and> monic fi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_free_normalize:\n  assumes \"square_free p\"\n  shows \"square_free (normalize p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (normalize p)", "by (metis assms square_free_multD(3) unit_factor_mult_normalize)"], ["", "lemma coprime_normalize:\n  assumes \"coprime a b\"\n  shows \"coprime (normalize a) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (normalize a) b", "using assms"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime a b\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (normalize a) b", "by auto"], ["", "lemma undo_normalize:\n  shows \"a = Polynomial.smult (unit_factor (lead_coeff a)) (normalize a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = Polynomial.smult (unit_factor (lead_coeff a)) (normalize a)", "by (metis add.right_neutral mult_pCons_right mult_zero_right normalize_mult_unit_factor pCons_0_hom.hom_zero unit_factor_poly_def)"], ["", "lemma finite_smult_distr:\n  assumes \"distinct fs\"\n  shows \"(\\<Prod>(x,y)\\<in>set fs. Polynomial.smult ((f x y)::rat) (g x y)) = \n    Polynomial.smult (\\<Prod>(x,y)\\<in>set fs. f x y) (\\<Prod>(x,y)\\<in>set fs. g x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x, y)\\<in>set fs. Polynomial.smult (f x y) (g x y)) =\n    Polynomial.smult (\\<Prod>(x, y)\\<in>set fs. f x y)\n     (\\<Prod>(x, y)\\<in>set fs. g x y)", "using assms"], ["proof (prove)\nusing this:\n  distinct fs\n\ngoal (1 subgoal):\n 1. (\\<Prod>(x, y)\\<in>set fs. Polynomial.smult (f x y) (g x y)) =\n    Polynomial.smult (\\<Prod>(x, y)\\<in>set fs. f x y)\n     (\\<Prod>(x, y)\\<in>set fs. g x y)", "proof (induction fs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<Prod>(x, y)\\<in>set []. Polynomial.smult (f x y) (g x y)) =\n    Polynomial.smult (\\<Prod>(x, y)\\<in>set []. f x y)\n     (\\<Prod>(x, y)\\<in>set []. g x y)\n 2. \\<And>a fs.\n       \\<lbrakk>distinct fs \\<Longrightarrow>\n                (\\<Prod>(x, y)\\<in>set fs.\n                   Polynomial.smult (f x y) (g x y)) =\n                Polynomial.smult (\\<Prod>(x, y)\\<in>set fs. f x y)\n                 (\\<Prod>(x, y)\\<in>set fs. g x y);\n        distinct (a # fs)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(x, y)\\<in>set (a # fs).\n                            Polynomial.smult (f x y) (g x y)) =\n                         Polynomial.smult\n                          (\\<Prod>(x, y)\\<in>set (a # fs). f x y)\n                          (\\<Prod>(x, y)\\<in>set (a # fs). g x y)", "case Nil"], ["proof (state)\nthis:\n  distinct []\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (\\<Prod>(x, y)\\<in>set []. Polynomial.smult (f x y) (g x y)) =\n    Polynomial.smult (\\<Prod>(x, y)\\<in>set []. f x y)\n     (\\<Prod>(x, y)\\<in>set []. g x y)\n 2. \\<And>a fs.\n       \\<lbrakk>distinct fs \\<Longrightarrow>\n                (\\<Prod>(x, y)\\<in>set fs.\n                   Polynomial.smult (f x y) (g x y)) =\n                Polynomial.smult (\\<Prod>(x, y)\\<in>set fs. f x y)\n                 (\\<Prod>(x, y)\\<in>set fs. g x y);\n        distinct (a # fs)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(x, y)\\<in>set (a # fs).\n                            Polynomial.smult (f x y) (g x y)) =\n                         Polynomial.smult\n                          (\\<Prod>(x, y)\\<in>set (a # fs). f x y)\n                          (\\<Prod>(x, y)\\<in>set (a # fs). g x y)", "then"], ["proof (chain)\npicking this:\n  distinct []", "show ?case"], ["proof (prove)\nusing this:\n  distinct []\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>set [].\n       case a of (x, y) \\<Rightarrow> Polynomial.smult (f x y) (g x y)) =\n    Polynomial.smult\n     (\\<Prod>a\\<in>set []. case a of (a, b) \\<Rightarrow> f a b)\n     (\\<Prod>a\\<in>set []. case a of (a, b) \\<Rightarrow> g a b)", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>set [].\n     case a of (x, y) \\<Rightarrow> Polynomial.smult (f x y) (g x y)) =\n  Polynomial.smult\n   (\\<Prod>a\\<in>set []. case a of (a, b) \\<Rightarrow> f a b)\n   (\\<Prod>a\\<in>set []. case a of (a, b) \\<Rightarrow> g a b)\n\ngoal (1 subgoal):\n 1. \\<And>a fs.\n       \\<lbrakk>distinct fs \\<Longrightarrow>\n                (\\<Prod>(x, y)\\<in>set fs.\n                   Polynomial.smult (f x y) (g x y)) =\n                Polynomial.smult (\\<Prod>(x, y)\\<in>set fs. f x y)\n                 (\\<Prod>(x, y)\\<in>set fs. g x y);\n        distinct (a # fs)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(x, y)\\<in>set (a # fs).\n                            Polynomial.smult (f x y) (g x y)) =\n                         Polynomial.smult\n                          (\\<Prod>(x, y)\\<in>set (a # fs). f x y)\n                          (\\<Prod>(x, y)\\<in>set (a # fs). g x y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a fs.\n       \\<lbrakk>distinct fs \\<Longrightarrow>\n                (\\<Prod>(x, y)\\<in>set fs.\n                   Polynomial.smult (f x y) (g x y)) =\n                Polynomial.smult (\\<Prod>(x, y)\\<in>set fs. f x y)\n                 (\\<Prod>(x, y)\\<in>set fs. g x y);\n        distinct (a # fs)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(x, y)\\<in>set (a # fs).\n                            Polynomial.smult (f x y) (g x y)) =\n                         Polynomial.smult\n                          (\\<Prod>(x, y)\\<in>set (a # fs). f x y)\n                          (\\<Prod>(x, y)\\<in>set (a # fs). g x y)", "case (Cons a fs)"], ["proof (state)\nthis:\n  distinct fs \\<Longrightarrow>\n  (\\<Prod>a\\<in>set fs.\n     case a of (x, y) \\<Rightarrow> Polynomial.smult (f x y) (g x y)) =\n  Polynomial.smult\n   (\\<Prod>a\\<in>set fs. case a of (a, b) \\<Rightarrow> f a b)\n   (\\<Prod>a\\<in>set fs. case a of (a, b) \\<Rightarrow> g a b)\n  distinct (a # fs)\n\ngoal (1 subgoal):\n 1. \\<And>a fs.\n       \\<lbrakk>distinct fs \\<Longrightarrow>\n                (\\<Prod>(x, y)\\<in>set fs.\n                   Polynomial.smult (f x y) (g x y)) =\n                Polynomial.smult (\\<Prod>(x, y)\\<in>set fs. f x y)\n                 (\\<Prod>(x, y)\\<in>set fs. g x y);\n        distinct (a # fs)\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(x, y)\\<in>set (a # fs).\n                            Polynomial.smult (f x y) (g x y)) =\n                         Polynomial.smult\n                          (\\<Prod>(x, y)\\<in>set (a # fs). f x y)\n                          (\\<Prod>(x, y)\\<in>set (a # fs). g x y)", "then"], ["proof (chain)\npicking this:\n  distinct fs \\<Longrightarrow>\n  (\\<Prod>a\\<in>set fs.\n     case a of (x, y) \\<Rightarrow> Polynomial.smult (f x y) (g x y)) =\n  Polynomial.smult\n   (\\<Prod>a\\<in>set fs. case a of (a, b) \\<Rightarrow> f a b)\n   (\\<Prod>a\\<in>set fs. case a of (a, b) \\<Rightarrow> g a b)\n  distinct (a # fs)", "show ?case"], ["proof (prove)\nusing this:\n  distinct fs \\<Longrightarrow>\n  (\\<Prod>a\\<in>set fs.\n     case a of (x, y) \\<Rightarrow> Polynomial.smult (f x y) (g x y)) =\n  Polynomial.smult\n   (\\<Prod>a\\<in>set fs. case a of (a, b) \\<Rightarrow> f a b)\n   (\\<Prod>a\\<in>set fs. case a of (a, b) \\<Rightarrow> g a b)\n  distinct (a # fs)\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>set (a # fs).\n       case a of (x, y) \\<Rightarrow> Polynomial.smult (f x y) (g x y)) =\n    Polynomial.smult\n     (\\<Prod>a\\<in>set (a # fs). case a of (a, b) \\<Rightarrow> f a b)\n     (\\<Prod>a\\<in>set (a # fs). case a of (a, b) \\<Rightarrow> g a b)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Prod>x\\<in>set fs.\n                case x of\n                (x, y) \\<Rightarrow> Polynomial.smult (f x y) (g x y)) =\n             Polynomial.smult\n              (\\<Prod>x\\<in>set fs. case x of (x, xa) \\<Rightarrow> f x xa)\n              (\\<Prod>x\\<in>set fs. case x of (x, xa) \\<Rightarrow> g x xa);\n     a \\<notin> set fs; distinct fs\\<rbrakk>\n    \\<Longrightarrow> Polynomial.smult\n                       (\\<Prod>x\\<in>set fs.\n                          case x of (x, xa) \\<Rightarrow> f x xa)\n                       ((case a of\n                         (x, y) \\<Rightarrow>\n                           Polynomial.smult (f x y) (g x y)) *\n                        (\\<Prod>x\\<in>set fs.\n                           case x of (x, xa) \\<Rightarrow> g x xa)) =\n                      Polynomial.smult\n                       ((case a of (x, xa) \\<Rightarrow> f x xa) *\n                        (\\<Prod>x\\<in>set fs.\n                           case x of (x, xa) \\<Rightarrow> f x xa))\n                       ((case a of (x, xa) \\<Rightarrow> g x xa) *\n                        (\\<Prod>x\\<in>set fs.\n                           case x of (x, xa) \\<Rightarrow> g x xa))", "using mult.commute mult_smult_right prod.case_distrib smult_smult split_cong split_conv"], ["proof (prove)\nusing this:\n  ?a * ?b = ?b * ?a\n  ?p * Polynomial.smult ?a ?q = Polynomial.smult ?a (?p * ?q)\n  ?h (case ?prod of (x, xa) \\<Rightarrow> ?f x xa) =\n  (case ?prod of (x1, x2) \\<Rightarrow> ?h (?f x1 x2))\n  Polynomial.smult ?a (Polynomial.smult ?b ?p) =\n  Polynomial.smult (?a * ?b) ?p\n  \\<lbrakk>\\<And>x y. (x, y) = ?q \\<Longrightarrow> ?f x y = ?g x y;\n   ?p = ?q\\<rbrakk>\n  \\<Longrightarrow> (case ?p of (x, xa) \\<Rightarrow> ?f x xa) =\n                    (case ?q of (x, xa) \\<Rightarrow> ?g x xa)\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Prod>x\\<in>set fs.\n                case x of\n                (x, y) \\<Rightarrow> Polynomial.smult (f x y) (g x y)) =\n             Polynomial.smult\n              (\\<Prod>x\\<in>set fs. case x of (x, xa) \\<Rightarrow> f x xa)\n              (\\<Prod>x\\<in>set fs. case x of (x, xa) \\<Rightarrow> g x xa);\n     a \\<notin> set fs; distinct fs\\<rbrakk>\n    \\<Longrightarrow> Polynomial.smult\n                       (\\<Prod>x\\<in>set fs.\n                          case x of (x, xa) \\<Rightarrow> f x xa)\n                       ((case a of\n                         (x, y) \\<Rightarrow>\n                           Polynomial.smult (f x y) (g x y)) *\n                        (\\<Prod>x\\<in>set fs.\n                           case x of (x, xa) \\<Rightarrow> g x xa)) =\n                      Polynomial.smult\n                       ((case a of (x, xa) \\<Rightarrow> f x xa) *\n                        (\\<Prod>x\\<in>set fs.\n                           case x of (x, xa) \\<Rightarrow> f x xa))\n                       ((case a of (x, xa) \\<Rightarrow> g x xa) *\n                        (\\<Prod>x\\<in>set fs.\n                           case x of (x, xa) \\<Rightarrow> g x xa))", "by (simp add: Groups.mult_ac(2) split_beta)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>set (a # fs).\n     case a of (x, y) \\<Rightarrow> Polynomial.smult (f x y) (g x y)) =\n  Polynomial.smult\n   (\\<Prod>a\\<in>set (a # fs). case a of (a, b) \\<Rightarrow> f a b)\n   (\\<Prod>a\\<in>set (a # fs). case a of (a, b) \\<Rightarrow> g a b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_coprime_degree:\n  assumes \"normalize (f::rat poly) = normalize g\"\n  assumes \"coprime f g\"\n  shows \"degree f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree f = 0", "have \"f dvd g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f dvd g", "by (simp add: assms(1) associatedD2)"], ["proof (state)\nthis:\n  f dvd g\n\ngoal (1 subgoal):\n 1. degree f = 0", "then"], ["proof (chain)\npicking this:\n  f dvd g", "have \"f dvd 1\""], ["proof (prove)\nusing this:\n  f dvd g\n\ngoal (1 subgoal):\n 1. is_unit f", "using assms(2) associatedD1"], ["proof (prove)\nusing this:\n  f dvd g\n  comm_monoid_mult_class.coprime f g\n  normalize ?a = normalize ?b \\<Longrightarrow> ?a dvd ?b\n\ngoal (1 subgoal):\n 1. is_unit f", "by auto"], ["proof (state)\nthis:\n  is_unit f\n\ngoal (1 subgoal):\n 1. degree f = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_unit f\n\ngoal (1 subgoal):\n 1. degree f = 0", "using Missing_Polynomial_Factorial.is_unit_field_poly"], ["proof (prove)\nusing this:\n  is_unit f\n  is_unit ?p = (?p \\<noteq> 0 \\<and> degree ?p = 0)\n\ngoal (1 subgoal):\n 1. degree f = 0", "by blast"], ["proof (state)\nthis:\n  degree f = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorize_rat_poly_monic_square_free_factorization:\n  assumes res: \"factorize_rat_poly_monic f = (c,fs)\"\n  shows \"square_free_factorization f (c,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization f (c, fs)", "proof (unfold square_free_factorization_def split, intro conjI impI allI)"], ["proof (state)\ngoal (7 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. f = 0 \\<Longrightarrow> c = 0\n 3. f = 0 \\<Longrightarrow> fs = []\n 4. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 5. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 6. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b\n 7. distinct fs", "obtain c' fs' where cfs: \"factorize_rat_poly f = (c',fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c' fs'.\n        factorize_rat_poly f = (c', fs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  factorize_rat_poly f = (c', fs')\n\ngoal (7 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. f = 0 \\<Longrightarrow> c = 0\n 3. f = 0 \\<Longrightarrow> fs = []\n 4. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 5. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 6. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b\n 7. distinct fs", "then"], ["proof (chain)\npicking this:\n  factorize_rat_poly f = (c', fs')", "have fs: \"fs = map (\\<lambda>(f,i). (normalize f, i)) fs'\""], ["proof (prove)\nusing this:\n  factorize_rat_poly f = (c', fs')\n\ngoal (1 subgoal):\n 1. fs = map (\\<lambda>(f, i). (normalize f, i)) fs'", "using factorize_rat_poly_monic_def assms"], ["proof (prove)\nusing this:\n  factorize_rat_poly f = (c', fs')\n  factorize_rat_poly_monic ?p =\n  (let (c, fs) = factorize_rat_poly ?p;\n       lcs = \\<Prod>(f, i)\\<leftarrow>fs. lead_coeff f ^ Suc i\n   in Let (map (\\<lambda>(f, i). (normalize f, i)) fs) (Pair (c * lcs)))\n  factorize_rat_poly_monic f = (c, fs)\n\ngoal (1 subgoal):\n 1. fs = map (\\<lambda>(f, i). (normalize f, i)) fs'", "by auto"], ["proof (state)\nthis:\n  fs = map (\\<lambda>(f, i). (normalize f, i)) fs'\n\ngoal (7 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. f = 0 \\<Longrightarrow> c = 0\n 3. f = 0 \\<Longrightarrow> fs = []\n 4. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 5. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 6. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b\n 7. distinct fs", "have sq: \"square_free_factorization f (c',fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization f (c', fs')", "using cfs factorize_rat_poly(1)"], ["proof (prove)\nusing this:\n  factorize_rat_poly f = (c', fs')\n  factorize_rat_poly_generic ?alg ?f = (?c, ?fs) \\<Longrightarrow>\n  square_free_factorization ?f (?c, ?fs)\n\ngoal (1 subgoal):\n 1. square_free_factorization f (c', fs')", "by blast"], ["proof (state)\nthis:\n  square_free_factorization f (c', fs')\n\ngoal (7 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. f = 0 \\<Longrightarrow> c = 0\n 3. f = 0 \\<Longrightarrow> fs = []\n 4. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 5. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 6. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b\n 7. distinct fs", "obtain lcs where lcs: \"lcs = prod_list (map (\\<lambda>(f,i). lead_coeff f ^ Suc i) fs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lcs.\n        lcs =\n        (\\<Prod>(f,\n            i)\\<leftarrow>fs'. lead_coeff f ^ Suc i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  lcs = (\\<Prod>(f, i)\\<leftarrow>fs'. lead_coeff f ^ Suc i)\n\ngoal (7 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. f = 0 \\<Longrightarrow> c = 0\n 3. f = 0 \\<Longrightarrow> fs = []\n 4. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 5. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 6. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b\n 7. distinct fs", "have c: \"c = c' * lcs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = c' * lcs", "using assms"], ["proof (prove)\nusing this:\n  factorize_rat_poly_monic f = (c, fs)\n\ngoal (1 subgoal):\n 1. c = c' * lcs", "unfolding factorize_rat_poly_monic_def cfs Let_def lcs"], ["proof (prove)\nusing this:\n  (case (c', fs') of\n   (c, fs) \\<Rightarrow>\n     (c * (\\<Prod>(f, i)\\<leftarrow>fs. lead_coeff f ^ Suc i),\n      map (\\<lambda>(f, y). (normalize f, y)) fs)) =\n  (c, fs)\n\ngoal (1 subgoal):\n 1. c = c' * (\\<Prod>(f, i)\\<leftarrow>fs'. lead_coeff f ^ Suc i)", "by auto"], ["proof (state)\nthis:\n  c = c' * lcs\n\ngoal (7 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. f = 0 \\<Longrightarrow> c = 0\n 3. f = 0 \\<Longrightarrow> fs = []\n 4. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 5. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 6. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b\n 7. distinct fs", "show \"f = 0 \\<Longrightarrow> c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> c = 0", "using c cfs"], ["proof (prove)\nusing this:\n  c = c' * lcs\n  factorize_rat_poly f = (c', fs')\n\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> c = 0", "by auto"], ["proof (state)\nthis:\n  f = 0 \\<Longrightarrow> c = 0\n\ngoal (6 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. f = 0 \\<Longrightarrow> fs = []\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 4. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 5. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b\n 6. distinct fs", "show \"f = 0 \\<Longrightarrow> fs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> fs = []", "using fs cfs"], ["proof (prove)\nusing this:\n  fs = map (\\<lambda>(f, i). (normalize f, i)) fs'\n  factorize_rat_poly f = (c', fs')\n\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> fs = []", "by auto"], ["proof (state)\nthis:\n  f = 0 \\<Longrightarrow> fs = []\n\ngoal (5 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b\n 5. distinct fs", "have dist: \"distinct fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct fs'", "using sq square_free_factorizationD(5)"], ["proof (prove)\nusing this:\n  square_free_factorization f (c', fs')\n  square_free_factorization ?p (?c, ?bs) \\<Longrightarrow> distinct ?bs\n\ngoal (1 subgoal):\n 1. distinct fs'", "by blast"], ["proof (state)\nthis:\n  distinct fs'\n\ngoal (5 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b\n 5. distinct fs", "show dist2: \"distinct fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct fs", "unfolding fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>(f, y). (normalize f, y)) fs')", "unfolding distinct_conv_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (map (\\<lambda>(f, y). (normalize f, y)) fs').\n       \\<forall>j<length (map (\\<lambda>(f, y). (normalize f, y)) fs').\n          i \\<noteq> j \\<longrightarrow>\n          map (\\<lambda>(f, y). (normalize f, y)) fs' ! i \\<noteq>\n          map (\\<lambda>(f, y). (normalize f, y)) fs' ! j", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs'; j < length fs'; i \\<noteq> j;\n        (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n        (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\\<rbrakk>\n       \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs'; j < length fs'; i \\<noteq> j;\n        (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n        (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\\<rbrakk>\n       \\<Longrightarrow> False", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs'; j < length fs'; i \\<noteq> j;\n        (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n        (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\\<rbrakk>\n       \\<Longrightarrow> False", "assume ij: \"i < length fs'\" \"j < length fs'\" \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i < length fs'\n  j < length fs'\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs'; j < length fs'; i \\<noteq> j;\n        (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n        (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\\<rbrakk>\n       \\<Longrightarrow> False", "assume eq: \"(case fs' ! i of\n            (f, x) \\<Rightarrow> (normalize f, x)) =\n           (case fs' ! j of\n            (f, x) \\<Rightarrow> (normalize f, x))\""], ["proof (state)\nthis:\n  (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n  (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs'; j < length fs'; i \\<noteq> j;\n        (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n        (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\\<rbrakk>\n       \\<Longrightarrow> False", "obtain f a where fa: \"fs' ! i = (f,a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f a. fs' ! i = (f, a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fs' ! i = (f, a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs'; j < length fs'; i \\<noteq> j;\n        (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n        (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\\<rbrakk>\n       \\<Longrightarrow> False", "obtain g where g: \"fs' ! j = (g,a)\" \"normalize f = normalize g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>fs' ! j = (g, a); normalize f = normalize g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eq fa"], ["proof (prove)\nusing this:\n  (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n  (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\n  fs' ! i = (f, a)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>fs' ! j = (g, a); normalize f = normalize g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>g.\n                \\<lbrakk>fs' ! j = (g, a);\n                 normalize f = normalize g\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (normalize f, a) =\n     (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x));\n     fs' ! i = (f, a)\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis case_prod_conv prod.collapse prod.inject)"], ["proof (state)\nthis:\n  fs' ! j = (g, a)\n  normalize f = normalize g\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs'; j < length fs'; i \\<noteq> j;\n        (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n        (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\\<rbrakk>\n       \\<Longrightarrow> False", "have \"f \\<noteq> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<noteq> g", "using dist ij fa g"], ["proof (prove)\nusing this:\n  distinct fs'\n  i < length fs'\n  j < length fs'\n  i \\<noteq> j\n  fs' ! i = (f, a)\n  fs' ! j = (g, a)\n  normalize f = normalize g\n\ngoal (1 subgoal):\n 1. f \\<noteq> g", "using nth_eq_iff_index_eq"], ["proof (prove)\nusing this:\n  distinct fs'\n  i < length fs'\n  j < length fs'\n  i \\<noteq> j\n  fs' ! i = (f, a)\n  fs' ! j = (g, a)\n  normalize f = normalize g\n  \\<lbrakk>distinct ?xs; ?i < length ?xs; ?j < length ?xs\\<rbrakk>\n  \\<Longrightarrow> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)\n\ngoal (1 subgoal):\n 1. f \\<noteq> g", "by fastforce"], ["proof (state)\nthis:\n  f \\<noteq> g\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs'; j < length fs'; i \\<noteq> j;\n        (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n        (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  f \\<noteq> g", "have \"coprime f g\""], ["proof (prove)\nusing this:\n  f \\<noteq> g\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "using square_free_factorizationD(3)[OF sq, of f a g a] fa g ij"], ["proof (prove)\nusing this:\n  f \\<noteq> g\n  \\<lbrakk>(f, a) \\<in> set fs'; (g, a) \\<in> set fs';\n   (f, a) \\<noteq> (g, a)\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime f g\n  fs' ! i = (f, a)\n  fs' ! j = (g, a)\n  normalize f = normalize g\n  i < length fs'\n  j < length fs'\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g;\n     \\<lbrakk>(f, a) \\<in> set fs'; (g, a) \\<in> set fs'\\<rbrakk>\n     \\<Longrightarrow> algebraic_semidom_class.coprime f g;\n     fs' ! i = (f, a); fs' ! j = (g, a); normalize f = normalize g;\n     i < length fs'; j < length fs'; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> algebraic_semidom_class.coprime f g", "using nth_mem"], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<noteq> g;\n     \\<lbrakk>(f, a) \\<in> set fs'; (g, a) \\<in> set fs'\\<rbrakk>\n     \\<Longrightarrow> algebraic_semidom_class.coprime f g;\n     fs' ! i = (f, a); fs' ! j = (g, a); normalize f = normalize g;\n     i < length fs'; j < length fs'; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> algebraic_semidom_class.coprime f g", "by force"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs'; j < length fs'; i \\<noteq> j;\n        (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n        (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  comm_monoid_mult_class.coprime f g", "have \"degree f = 0\""], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime f g\n\ngoal (1 subgoal):\n 1. degree f = 0", "by (simp add: g(2) normalize_coprime_degree)"], ["proof (state)\nthis:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length fs'; j < length fs'; i \\<noteq> j;\n        (case fs' ! i of (f, x) \\<Rightarrow> (normalize f, x)) =\n        (case fs' ! j of (f, x) \\<Rightarrow> (normalize f, x))\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. False", "using fa ij(1) nth_mem sq square_free_factorizationD'(3)"], ["proof (prove)\nusing this:\n  degree f = 0\n  fs' ! i = (f, a)\n  i < length fs'\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  square_free_factorization f (c', fs')\n  \\<lbrakk>square_free_factorization ?p (?c, ?bs);\n   (?b, ?i) \\<in> set ?bs\\<rbrakk>\n  \\<Longrightarrow> degree ?b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct fs\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "have ceq: \"c = c' * (\\<Prod>(a, i)\\<in>set fs'. (lead_coeff a) ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)", "using c lcs"], ["proof (prove)\nusing this:\n  c = c' * lcs\n  lcs = (\\<Prod>(f, i)\\<leftarrow>fs'. lead_coeff f ^ Suc i)\n\ngoal (1 subgoal):\n 1. c = c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)", "by (simp add: dist prod.distinct_set_conv_list)"], ["proof (state)\nthis:\n  c = c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "have fseq: \" (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) =  (\\<Prod>(a, i)\\<in>set fs'. (normalize a) ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) =\n    (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)", "apply (subst prod.distinct_set_conv_list[OF dist])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) =\n    (\\<Prod>(a, i)\\<leftarrow>fs'. normalize a ^ Suc i)", "apply (subst prod.distinct_set_conv_list[OF dist2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>fs. a ^ Suc i) =\n    (\\<Prod>(a, i)\\<leftarrow>fs'. normalize a ^ Suc i)", "unfolding fs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a,\n        i)\\<leftarrow>map (\\<lambda>(f, y). (normalize f, y))\n                       fs'. a ^ Suc i) =\n    (\\<Prod>(a, i)\\<leftarrow>fs'. normalize a ^ Suc i)", "apply (auto simp add: o_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>fs'. case case x of\n                                   (f, x) \\<Rightarrow> (normalize f, x) of\n                              (a, i) \\<Rightarrow> a * a ^ i) =\n    (\\<Prod>(a, i)\\<leftarrow>fs'. normalize a * normalize a ^ i)", "by (metis (no_types, lifting) case_prod_conv old.prod.exhaust)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) =\n  (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "have \"f = Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i)", "using sq square_free_factorizationD(1)"], ["proof (prove)\nusing this:\n  square_free_factorization f (c', fs')\n  square_free_factorization ?p (?c, ?bs) \\<Longrightarrow>\n  ?p = Polynomial.smult ?c (\\<Prod>(a, i)\\<in>set ?bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. f = Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i)", "by blast"], ["proof (state)\nthis:\n  f = Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i)\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "moreover"], ["proof (state)\nthis:\n  f = Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i)\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "have \"... =  Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. (Polynomial.smult ((unit_factor (lead_coeff a))) (normalize a)) ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i) =\n    Polynomial.smult c'\n     (\\<Prod>(a, i)\\<in>set fs'.\n        Polynomial.smult (unit_factor (lead_coeff a)) (normalize a) ^ Suc i)", "apply (subst undo_normalize[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i) =\n    Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i)", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i) =\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (unit_factor (lead_coeff a)) (normalize a) ^ Suc i)\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "moreover"], ["proof (state)\nthis:\n  Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i) =\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (unit_factor (lead_coeff a)) (normalize a) ^ Suc i)\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "have \"... =  Polynomial.smult c'\n    (\\<Prod>(a, i)\\<in>set fs'. (Polynomial.smult ((lead_coeff a) ^ Suc i) ((normalize a) ^ Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult c'\n     (\\<Prod>(a, i)\\<in>set fs'.\n        Polynomial.smult (unit_factor (lead_coeff a)) (normalize a) ^\n        Suc i) =\n    Polynomial.smult c'\n     (\\<Prod>(a, i)\\<in>set fs'.\n        Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i))", "apply (subst smult_power)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult c'\n     (\\<Prod>(a, i)\\<in>set fs'.\n        Polynomial.smult (unit_factor (lead_coeff a) ^ Suc i)\n         (normalize a ^ Suc i)) =\n    Polynomial.smult c'\n     (\\<Prod>(a, i)\\<in>set fs'.\n        Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i))", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (unit_factor (lead_coeff a)) (normalize a) ^ Suc i) =\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i))\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "moreover"], ["proof (state)\nthis:\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (unit_factor (lead_coeff a)) (normalize a) ^ Suc i) =\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i))\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "have \"... =  Polynomial.smult c'\n    (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. ((lead_coeff a) ^ Suc i))\n        (\\<Prod>(a, i)\\<in>set fs'. (normalize a) ^ Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult c'\n     (\\<Prod>(a, i)\\<in>set fs'.\n        Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i)) =\n    Polynomial.smult c'\n     (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n       (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i))", "apply (subst finite_smult_distr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct fs'\n 2. Polynomial.smult c'\n     (Polynomial.smult (\\<Prod>(x, y)\\<in>set fs'. lead_coeff x ^ Suc y)\n       (\\<Prod>(x, y)\\<in>set fs'. normalize x ^ Suc y)) =\n    Polynomial.smult c'\n     (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n       (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i))", "by (auto simp add: dist)"], ["proof (state)\nthis:\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i)) =\n  Polynomial.smult c'\n   (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i))\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "moreover"], ["proof (state)\nthis:\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i)) =\n  Polynomial.smult c'\n   (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i))\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "have \"... =  Polynomial.smult (c' * (\\<Prod>(a, i)\\<in>set fs'. (lead_coeff a) ^ Suc i))\n        (\\<Prod>(a, i)\\<in>set fs'. (normalize a) ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult c'\n     (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n       (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)) =\n    Polynomial.smult\n     (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)", "using smult_smult"], ["proof (prove)\nusing this:\n  Polynomial.smult ?a (Polynomial.smult ?b ?p) =\n  Polynomial.smult (?a * ?b) ?p\n\ngoal (1 subgoal):\n 1. Polynomial.smult c'\n     (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n       (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)) =\n    Polynomial.smult\n     (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)", "by blast"], ["proof (state)\nthis:\n  Polynomial.smult c'\n   (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)) =\n  Polynomial.smult (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n   (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "moreover"], ["proof (state)\nthis:\n  Polynomial.smult c'\n   (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)) =\n  Polynomial.smult (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n   (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "have \"... = Polynomial.smult c  (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i) =\n    Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "unfolding ceq fseq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult\n     (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i) =\n    Polynomial.smult\n     (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n   (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i) =\n  Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n\ngoal (4 subgoals):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 3. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 4. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "ultimately"], ["proof (chain)\npicking this:\n  f = Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i)\n  Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i) =\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (unit_factor (lead_coeff a)) (normalize a) ^ Suc i)\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (unit_factor (lead_coeff a)) (normalize a) ^ Suc i) =\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i))\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i)) =\n  Polynomial.smult c'\n   (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i))\n  Polynomial.smult c'\n   (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)) =\n  Polynomial.smult (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n   (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)\n  Polynomial.smult (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n   (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i) =\n  Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "show \"f =  Polynomial.smult c  (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\""], ["proof (prove)\nusing this:\n  f = Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i)\n  Polynomial.smult c' (\\<Prod>(a, i)\\<in>set fs'. a ^ Suc i) =\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (unit_factor (lead_coeff a)) (normalize a) ^ Suc i)\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (unit_factor (lead_coeff a)) (normalize a) ^ Suc i) =\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i))\n  Polynomial.smult c'\n   (\\<Prod>(a, i)\\<in>set fs'.\n      Polynomial.smult (lead_coeff a ^ Suc i) (normalize a ^ Suc i)) =\n  Polynomial.smult c'\n   (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i))\n  Polynomial.smult c'\n   (Polynomial.smult (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i)\n     (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)) =\n  Polynomial.smult (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n   (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i)\n  Polynomial.smult (c' * (\\<Prod>(a, i)\\<in>set fs'. lead_coeff a ^ Suc i))\n   (\\<Prod>(a, i)\\<in>set fs'. normalize a ^ Suc i) =\n  Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "by auto"], ["proof (state)\nthis:\n  f = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n\ngoal (3 subgoals):\n 1. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 3. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "fix a i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 3. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "assume ai: \"(a,i) \\<in> set fs\""], ["proof (state)\nthis:\n  (a, i) \\<in> set fs\n\ngoal (3 subgoals):\n 1. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 3. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "obtain a' where a': \"(a',i) \\<in> set fs'\" \"a = normalize a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a', i) \\<in> set fs'; a = normalize a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ai"], ["proof (prove)\nusing this:\n  (a, i) \\<in> set fs\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a', i) \\<in> set fs'; a = normalize a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fs"], ["proof (prove)\nusing this:\n  (a, i) \\<in> set (map (\\<lambda>(f, y). (normalize f, y)) fs')\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a', i) \\<in> set fs'; a = normalize a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a', i) \\<in> set fs'\n  a = normalize a'\n\ngoal (3 subgoals):\n 1. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> square_free a\n 2. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 3. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "show \"square_free a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free a", "using square_free_normalize a'"], ["proof (prove)\nusing this:\n  square_free ?p \\<Longrightarrow> square_free (normalize ?p)\n  (a', i) \\<in> set fs'\n  a = normalize a'\n\ngoal (1 subgoal):\n 1. square_free a", "using sq square_free_factorizationD(2)"], ["proof (prove)\nusing this:\n  square_free ?p \\<Longrightarrow> square_free (normalize ?p)\n  (a', i) \\<in> set fs'\n  a = normalize a'\n  square_free_factorization f (c', fs')\n  \\<lbrakk>square_free_factorization ?p (?c, ?bs);\n   (?a, ?i) \\<in> set ?bs\\<rbrakk>\n  \\<Longrightarrow> square_free ?a \\<and> degree ?a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. square_free a", "by blast"], ["proof (state)\nthis:\n  square_free a\n\ngoal (2 subgoals):\n 1. \\<And>a i. (a, i) \\<in> set fs \\<Longrightarrow> 0 < degree a\n 2. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "show \"0 < degree a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree a", "using degree_normalize a'"], ["proof (prove)\nusing this:\n  degree (normalize ?f) = degree ?f\n  (a', i) \\<in> set fs'\n  a = normalize a'\n\ngoal (1 subgoal):\n 1. 0 < degree a", "using sq square_free_factorizationD'(3)"], ["proof (prove)\nusing this:\n  degree (normalize ?f) = degree ?f\n  (a', i) \\<in> set fs'\n  a = normalize a'\n  square_free_factorization f (c', fs')\n  \\<lbrakk>square_free_factorization ?p (?c, ?bs);\n   (?b, ?i) \\<in> set ?bs\\<rbrakk>\n  \\<Longrightarrow> degree ?b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree a", "by fastforce"], ["proof (state)\nthis:\n  0 < degree a\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "fix  b j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "assume bj: \"(b,j) \\<in> set fs\" \"(a,i) \\<noteq> (b,j)\""], ["proof (state)\nthis:\n  (b, j) \\<in> set fs\n  (a, i) \\<noteq> (b, j)\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "obtain b' where b': \"(b',j) \\<in> set fs'\" \"b = normalize b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>(b', j) \\<in> set fs'; b = normalize b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using bj"], ["proof (prove)\nusing this:\n  (b, j) \\<in> set fs\n  (a, i) \\<noteq> (b, j)\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>(b', j) \\<in> set fs'; b = normalize b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fs"], ["proof (prove)\nusing this:\n  (b, j) \\<in> set (map (\\<lambda>(f, y). (normalize f, y)) fs')\n  (a, i) \\<noteq> (b, j)\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>(b', j) \\<in> set fs'; b = normalize b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (b', j) \\<in> set fs'\n  b = normalize b'\n\ngoal (1 subgoal):\n 1. \\<And>a i b j.\n       \\<lbrakk>(a, i) \\<in> set fs; (b, j) \\<in> set fs;\n        (a, i) \\<noteq> (b, j)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime a b", "show \"algebraic_semidom_class.coprime a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime a b", "using a' b'"], ["proof (prove)\nusing this:\n  (a', i) \\<in> set fs'\n  a = normalize a'\n  (b', j) \\<in> set fs'\n  b = normalize b'\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime a b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a', i) \\<in> set fs'; a = normalize a'; (b', j) \\<in> set fs';\n     b = normalize b'\\<rbrakk>\n    \\<Longrightarrow> algebraic_semidom_class.coprime a' b'", "using bj(2) sq square_free_factorizationD(3)"], ["proof (prove)\nusing this:\n  (a, i) \\<noteq> (b, j)\n  square_free_factorization f (c', fs')\n  \\<lbrakk>square_free_factorization ?p (?c, ?bs); (?a, ?i) \\<in> set ?bs;\n   (?b, ?j) \\<in> set ?bs; (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime ?a ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a', i) \\<in> set fs'; a = normalize a'; (b', j) \\<in> set fs';\n     b = normalize b'\\<rbrakk>\n    \\<Longrightarrow> algebraic_semidom_class.coprime a' b'", "by fastforce"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma undo_factorize_correct:\n  assumes \"factorize_rat_poly_monic p = (c,fs)\"\n  assumes \"\\<And>f p. (f,p) \\<in> set fs \\<Longrightarrow> f \\<in> set ftrs\"\n  shows \"undo_factorize (c,map (\\<lambda>(f,pow). (index_of ftrs f, pow)) fs) (sign_vec ftrs x) = squash (rpoly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "have p: \"p = smult c (\\<Prod>(a, i)\\<in> set fs. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "using assms(1) factorize_rat_poly_monic_square_free_factorization square_free_factorizationD(1)"], ["proof (prove)\nusing this:\n  factorize_rat_poly_monic p = (c, fs)\n  factorize_rat_poly_monic ?f = (?c, ?fs) \\<Longrightarrow>\n  square_free_factorization ?f (?c, ?fs)\n  square_free_factorization ?p (?c, ?bs) \\<Longrightarrow>\n  ?p = Polynomial.smult ?c (\\<Prod>(a, i)\\<in>set ?bs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "by blast"], ["proof (state)\nthis:\n  p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "have fs: \"distinct fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct fs", "using assms(1) factorize_rat_poly_monic_square_free_factorization square_free_factorizationD(5)"], ["proof (prove)\nusing this:\n  factorize_rat_poly_monic p = (c, fs)\n  factorize_rat_poly_monic ?f = (?c, ?fs) \\<Longrightarrow>\n  square_free_factorization ?f (?c, ?fs)\n  square_free_factorization ?p (?c, ?bs) \\<Longrightarrow> distinct ?bs\n\ngoal (1 subgoal):\n 1. distinct fs", "by blast"], ["proof (state)\nthis:\n  distinct fs\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "have \"rpoly p x = ((real_of_rat c) * rpoly (\\<Prod>(a, i)\\<in> set fs. a ^ Suc i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpoly p x =\n    real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x", "using p"], ["proof (prove)\nusing this:\n  p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. rpoly p x =\n    real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x", "by (simp add: of_rat_hom.map_poly_hom_smult)"], ["proof (state)\nthis:\n  rpoly p x = real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "moreover"], ["proof (state)\nthis:\n  rpoly p x = real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "have \"... = ((real_of_rat c) * rpoly (\\<Prod>ai\\<in> set fs. case ai of (a,i) \\<Rightarrow> a ^ Suc i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x =\n    real_of_rat c *\n    rpoly (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> a ^ Suc i)\n     x", "by blast"], ["proof (state)\nthis:\n  real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x =\n  real_of_rat c *\n  rpoly (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> a ^ Suc i) x\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "moreover"], ["proof (state)\nthis:\n  real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x =\n  real_of_rat c *\n  rpoly (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> a ^ Suc i) x\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "have \"... = ((real_of_rat c) * (\\<Prod>ai\\<in> set fs. case ai of (a,i) \\<Rightarrow> rpoly (a ^ Suc i) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat c *\n    rpoly (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> a ^ Suc i)\n     x =\n    real_of_rat c *\n    (\\<Prod>ai\\<in>set fs.\n       case ai of (a, i) \\<Rightarrow> rpoly (a ^ Suc i) x)", "by (simp add: finite_prod_map_of_rat_poly_hom)"], ["proof (state)\nthis:\n  real_of_rat c *\n  rpoly (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> a ^ Suc i)\n   x =\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly (a ^ Suc i) x)\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "moreover"], ["proof (state)\nthis:\n  real_of_rat c *\n  rpoly (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> a ^ Suc i)\n   x =\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly (a ^ Suc i) x)\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "have \"... = ((real_of_rat c) * (\\<Prod>ai\\<in> set fs. case ai of (a,i) \\<Rightarrow> (rpoly a x) ^ Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat c *\n    (\\<Prod>ai\\<in>set fs.\n       case ai of (a, i) \\<Rightarrow> rpoly (a ^ Suc i) x) =\n    real_of_rat c *\n    (\\<Prod>ai\\<in>set fs.\n       case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)", "by (metis (mono_tags, lifting) of_rat_poly_hom.hom_power poly_hom.hom_power split_cong)"], ["proof (state)\nthis:\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly (a ^ Suc i) x) =\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "moreover"], ["proof (state)\nthis:\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly (a ^ Suc i) x) =\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "have \"...  = ((real_of_rat c) * (prod_list (map (\\<lambda>ai. case ai of (a,i) \\<Rightarrow> (rpoly a x) ^ Suc i) fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat c *\n    (\\<Prod>ai\\<in>set fs.\n       case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i) =\n    real_of_rat c *\n    (\\<Prod>ai\\<leftarrow>fs. case ai of\n                              (a, i) \\<Rightarrow> rpoly a x ^ Suc i)", "by (simp add: fs prod.distinct_set_conv_list)"], ["proof (state)\nthis:\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i) =\n  real_of_rat c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "ultimately"], ["proof (chain)\npicking this:\n  rpoly p x = real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x\n  real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x =\n  real_of_rat c *\n  rpoly (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> a ^ Suc i) x\n  real_of_rat c *\n  rpoly (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> a ^ Suc i)\n   x =\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly (a ^ Suc i) x)\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly (a ^ Suc i) x) =\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i) =\n  real_of_rat c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> rpoly a x ^ Suc i)", "have \"rpoly p x = ((real_of_rat c) * (prod_list (map (\\<lambda>ai. case ai of (a,i) \\<Rightarrow> (rpoly a x) ^ Suc i) fs)))\""], ["proof (prove)\nusing this:\n  rpoly p x = real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x\n  real_of_rat c * rpoly (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) x =\n  real_of_rat c *\n  rpoly (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> a ^ Suc i) x\n  real_of_rat c *\n  rpoly (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> a ^ Suc i)\n   x =\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly (a ^ Suc i) x)\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly (a ^ Suc i) x) =\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n  real_of_rat c *\n  (\\<Prod>ai\\<in>set fs.\n     case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i) =\n  real_of_rat c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n\ngoal (1 subgoal):\n 1. rpoly p x =\n    real_of_rat c *\n    (\\<Prod>ai\\<leftarrow>fs. case ai of\n                              (a, i) \\<Rightarrow> rpoly a x ^ Suc i)", "by auto"], ["proof (state)\nthis:\n  rpoly p x =\n  real_of_rat c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "then"], ["proof (chain)\npicking this:\n  rpoly p x =\n  real_of_rat c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> rpoly a x ^ Suc i)", "have \"squash (rpoly p x) = squash c * prod_list (map squash (map (\\<lambda>ai. case ai of (a,i) \\<Rightarrow> (rpoly a x) ^ Suc i) fs))\""], ["proof (prove)\nusing this:\n  rpoly p x =\n  real_of_rat c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n\ngoal (1 subgoal):\n 1. squash (rpoly p x) =\n    squash c *\n    prod_list\n     (map squash\n       (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n         fs))", "by (auto simp add: squash_mult squash_prod_list o_def)"], ["proof (state)\nthis:\n  squash (rpoly p x) =\n  squash c *\n  prod_list\n   (map squash\n     (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n       fs))\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "moreover"], ["proof (state)\nthis:\n  squash (rpoly p x) =\n  squash c *\n  prod_list\n   (map squash\n     (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n       fs))\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "have \"... = squash c * prod_list (map (\\<lambda>ai. case ai of (a,i) \\<Rightarrow> squash ((rpoly a x) ^ Suc i)) fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash c *\n    prod_list\n     (map squash\n       (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n         fs)) =\n    squash c *\n    (\\<Prod>ai\\<leftarrow>fs. case ai of\n                              (a, i) \\<Rightarrow>\n                                squash (rpoly a x ^ Suc i))", "apply (simp add: o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. squash c = 0 \\<or>\n    (\\<Prod>xa\\<leftarrow>fs. squash\n                               (case xa of\n                                (a, i) \\<Rightarrow>\n                                  rpoly a x * rpoly a x ^ i)) =\n    (\\<Prod>(a, i)\\<leftarrow>fs. squash (rpoly a x * rpoly a x ^ i))", "by (simp add: prod.case_distrib)"], ["proof (state)\nthis:\n  squash c *\n  prod_list\n   (map squash\n     (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n       fs)) =\n  squash c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> squash (rpoly a x ^ Suc i))\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "ultimately"], ["proof (chain)\npicking this:\n  squash (rpoly p x) =\n  squash c *\n  prod_list\n   (map squash\n     (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n       fs))\n  squash c *\n  prod_list\n   (map squash\n     (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n       fs)) =\n  squash c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> squash (rpoly a x ^ Suc i))", "have rp:\"squash(rpoly p x) = squash c * prod_list (map (\\<lambda>ai. case ai of (a,i) \\<Rightarrow> squash (rpoly a x) ^ Suc i) fs)\""], ["proof (prove)\nusing this:\n  squash (rpoly p x) =\n  squash c *\n  prod_list\n   (map squash\n     (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n       fs))\n  squash c *\n  prod_list\n   (map squash\n     (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n       fs)) =\n  squash c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> squash (rpoly a x ^ Suc i))\n\ngoal (1 subgoal):\n 1. squash (rpoly p x) =\n    squash c *\n    (\\<Prod>ai\\<leftarrow>fs. case ai of\n                              (a, i) \\<Rightarrow>\n                                squash (rpoly a x) ^ Suc i)", "using squash_pow"], ["proof (prove)\nusing this:\n  squash (rpoly p x) =\n  squash c *\n  prod_list\n   (map squash\n     (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n       fs))\n  squash c *\n  prod_list\n   (map squash\n     (map (\\<lambda>ai. case ai of (a, i) \\<Rightarrow> rpoly a x ^ Suc i)\n       fs)) =\n  squash c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> squash (rpoly a x ^ Suc i))\n  squash (?x ^ ?y) = squash ?x ^ ?y\n\ngoal (1 subgoal):\n 1. squash (rpoly p x) =\n    squash c *\n    (\\<Prod>ai\\<leftarrow>fs. case ai of\n                              (a, i) \\<Rightarrow>\n                                squash (rpoly a x) ^ Suc i)", "by presburger"], ["proof (state)\nthis:\n  squash (rpoly p x) =\n  squash c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> squash (rpoly a x) ^ Suc i)\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "have \"undo_factorize\n     (c, map (\\<lambda>(f, pow).(index_of ftrs f, pow)) fs) (sign_vec ftrs x) =\n    squash\n     (c * (\\<Prod>xa\\<leftarrow>fs. case xa of (f, y) \\<Rightarrow> sign_vec ftrs x ! index_of ftrs f ^ Suc y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash\n     (c *\n      (\\<Prod>xa\\<leftarrow>fs. case xa of\n                                (f, y) \\<Rightarrow>\n                                  sign_vec ftrs x ! index_of ftrs f ^\n                                  Suc y))", "unfolding undo_factorize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. squash\n     (case (c, map (\\<lambda>(f, y). (index_of ftrs f, y)) fs) of\n      (c, fs) \\<Rightarrow>\n        c *\n        (\\<Prod>(f, pow)\\<leftarrow>fs. sign_vec ftrs x ! f ^ Suc pow)) =\n    squash\n     (c *\n      (\\<Prod>xa\\<leftarrow>fs. case xa of\n                                (f, y) \\<Rightarrow>\n                                  sign_vec ftrs x ! index_of ftrs f ^\n                                  Suc y))", "apply (auto simp add: o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. squash\n     (c *\n      (\\<Prod>xa\\<leftarrow>fs. case case xa of\n                                     (f, x) \\<Rightarrow>\n (index_of ftrs f, x) of\n                                (f, pow) \\<Rightarrow>\n                                  sign_vec ftrs x ! f *\n                                  sign_vec ftrs x ! f ^ pow)) =\n    squash\n     (c *\n      (\\<Prod>xa\\<leftarrow>fs. case xa of\n                                (f, y) \\<Rightarrow>\n                                  sign_vec ftrs x ! index_of ftrs f *\n                                  sign_vec ftrs x ! index_of ftrs f ^ y))", "by (metis (mono_tags, lifting) case_prod_conv old.prod.exhaust)"], ["proof (state)\nthis:\n  undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n   (sign_vec ftrs x) =\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                sign_vec ftrs x ! index_of ftrs f ^ Suc y))\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "moreover"], ["proof (state)\nthis:\n  undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n   (sign_vec ftrs x) =\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                sign_vec ftrs x ! index_of ftrs f ^ Suc y))\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "have \"... =  squash\n     (c * (\\<Prod>xa\\<leftarrow>fs. case xa of (f, y) \\<Rightarrow> (squash (rpoly f x)) ^ Suc y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash\n     (c *\n      (\\<Prod>xa\\<leftarrow>fs. case xa of\n                                (f, y) \\<Rightarrow>\n                                  sign_vec ftrs x ! index_of ftrs f ^\n                                  Suc y)) =\n    squash\n     (c *\n      (\\<Prod>xa\\<leftarrow>fs. case xa of\n                                (f, y) \\<Rightarrow>\n                                  squash (rpoly f x) ^ Suc y))", "using assms(2) sign_vec_index_of\n      map_eq_conv split_cong"], ["proof (prove)\nusing this:\n  (?f, ?p) \\<in> set fs \\<Longrightarrow> ?f \\<in> set ftrs\n  ?f \\<in> set ?ftrs \\<Longrightarrow>\n  sign_vec ?ftrs ?x ! index_of ?ftrs ?f = squash (rpoly ?f ?x)\n  (map ?f ?xs = map ?g ?xs) = (\\<forall>x\\<in>set ?xs. ?f x = ?g x)\n  \\<lbrakk>\\<And>x y. (x, y) = ?q \\<Longrightarrow> ?f x y = ?g x y;\n   ?p = ?q\\<rbrakk>\n  \\<Longrightarrow> (case ?p of (x, xa) \\<Rightarrow> ?f x xa) =\n                    (case ?q of (x, xa) \\<Rightarrow> ?g x xa)\n\ngoal (1 subgoal):\n 1. squash\n     (c *\n      (\\<Prod>xa\\<leftarrow>fs. case xa of\n                                (f, y) \\<Rightarrow>\n                                  sign_vec ftrs x ! index_of ftrs f ^\n                                  Suc y)) =\n    squash\n     (c *\n      (\\<Prod>xa\\<leftarrow>fs. case xa of\n                                (f, y) \\<Rightarrow>\n                                  squash (rpoly f x) ^ Suc y))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f p.\n                (f, p) \\<in> set fs \\<Longrightarrow> f \\<in> set ftrs;\n     \\<And>f ftrs x.\n        f \\<in> set ftrs \\<Longrightarrow>\n        sign_vec ftrs x ! index_of ftrs f = squash (rpoly f x);\n     \\<And>b f g a ba.\n        \\<lbrakk>\\<And>x y.\n                    x = a \\<and> y = b \\<Longrightarrow> f x y = g x y;\n         ba = b\\<rbrakk>\n        \\<Longrightarrow> f a ba = g a b\\<rbrakk>\n    \\<Longrightarrow> squash\n                       (c *\n                        (\\<Prod>(f,\n                            y)\\<leftarrow>fs. sign_vec ftrs x !\n        index_of ftrs f *\n        sign_vec ftrs x ! index_of ftrs f ^ y)) =\n                      squash\n                       (c *\n                        (\\<Prod>(f,\n                            y)\\<leftarrow>fs. squash (rpoly f x) *\n        squash (rpoly f x) ^ y))", "by (smt map_eq_conv split_cong)"], ["proof (state)\nthis:\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                sign_vec ftrs x ! index_of ftrs f ^\n                                Suc y)) =\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                squash (rpoly f x) ^ Suc y))\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "ultimately"], ["proof (chain)\npicking this:\n  undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n   (sign_vec ftrs x) =\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                sign_vec ftrs x ! index_of ftrs f ^ Suc y))\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                sign_vec ftrs x ! index_of ftrs f ^\n                                Suc y)) =\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                squash (rpoly f x) ^ Suc y))", "show ?thesis"], ["proof (prove)\nusing this:\n  undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n   (sign_vec ftrs x) =\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                sign_vec ftrs x ! index_of ftrs f ^ Suc y))\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                sign_vec ftrs x ! index_of ftrs f ^\n                                Suc y)) =\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                squash (rpoly f x) ^ Suc y))\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "using rp"], ["proof (prove)\nusing this:\n  undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n   (sign_vec ftrs x) =\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                sign_vec ftrs x ! index_of ftrs f ^ Suc y))\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                sign_vec ftrs x ! index_of ftrs f ^\n                                Suc y)) =\n  squash\n   (c *\n    (\\<Prod>xa\\<leftarrow>fs. case xa of\n                              (f, y) \\<Rightarrow>\n                                squash (rpoly f x) ^ Suc y))\n  squash (rpoly p x) =\n  squash c *\n  (\\<Prod>ai\\<leftarrow>fs. case ai of\n                            (a, i) \\<Rightarrow> squash (rpoly a x) ^ Suc i)\n\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly p x)", "by (metis (mono_tags, lifting) of_rat_hom.hom_mult squash_idem squash_mult squash_real_of_rat)"], ["proof (state)\nthis:\n  undo_factorize (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n   (sign_vec ftrs x) =\n  squash (rpoly p x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_sign_vec[simp]:\n  shows \"length (sign_vec ps x) = length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sign_vec ps x) = length ps", "unfolding sign_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (squash \\<circ> (\\<lambda>p. rpoly p x)) ps) = length ps", "by auto"], ["", "lemma factorize_polys_has_factors:\n  assumes \"factorize_polys ps = (ftrs,data)\"\n  assumes \"p \\<in> set ps\"\n  assumes \"factorize_rat_poly_monic p = (c,fs)\"\n  shows \"set (map fst fs) \\<subseteq> set ftrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst fs) \\<subseteq> set ftrs", "using assms"], ["proof (prove)\nusing this:\n  factorize_polys ps = (ftrs, data)\n  p \\<in> set ps\n  factorize_rat_poly_monic p = (c, fs)\n\ngoal (1 subgoal):\n 1. set (map fst fs) \\<subseteq> set ftrs", "unfolding factorize_polys_def Let_def"], ["proof (prove)\nusing this:\n  (remdups (map fst (concat (map snd (map factorize_rat_poly_monic ps)))),\n   map (\\<lambda>(c, fs).\n           (c, map (\\<lambda>(f, y).\n                       (index_of\n                         (remdups\n                           (map fst\n                             (concat\n                               (map snd\n                                 (map factorize_rat_poly_monic ps)))))\n                         f,\n                        y))\n                fs))\n    (map factorize_rat_poly_monic ps)) =\n  (ftrs, data)\n  p \\<in> set ps\n  factorize_rat_poly_monic p = (c, fs)\n\ngoal (1 subgoal):\n 1. set (map fst fs) \\<subseteq> set ftrs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>p \\<in> set ps; factorize_rat_poly_monic p = (c, fs);\n        (a, b) \\<in> set fs;\n        ftrs =\n        remdups\n         (map fst (concat (map (snd \\<circ> factorize_rat_poly_monic) ps)));\n        data =\n        map ((\\<lambda>(c, fs).\n                 (c, map (\\<lambda>(f, y).\n                             (index_of\n                               (remdups\n                                 (map fst\n                                   (concat\n                                     (map\n (snd \\<circ> factorize_rat_poly_monic) ps))))\n                               f,\n                              y))\n                      fs)) \\<circ>\n             factorize_rat_poly_monic)\n         ps\\<rbrakk>\n       \\<Longrightarrow> a \\<in> fst `\n                                 (\\<Union>x\\<in>set ps.\n                                     set (snd (factorize_rat_poly_monic x)))", "by (metis UN_iff fst_conv image_eqI snd_conv)"], ["", "lemma factorize_polys_undo_factorize_polys:\n  assumes \"factorize_polys ps = (ftrs,data)\"\n  shows \"undo_factorize_polys data (sign_vec ftrs x) = sign_vec ps x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undo_factorize_polys data (sign_vec ftrs x) = sign_vec ps x", "unfolding list_eq_iff_nth_eq undo_factorize_polys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>l. undo_factorize l (sign_vec ftrs x)) data) =\n    length (sign_vec ps x) \\<and>\n    (\\<forall>i<length\n                 (map (\\<lambda>l. undo_factorize l (sign_vec ftrs x))\n                   data).\n        map (\\<lambda>l. undo_factorize l (sign_vec ftrs x)) data ! i =\n        sign_vec ps x ! i)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. length data = length ps\n 2. \\<And>i.\n       i < length data \\<Longrightarrow>\n       undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. length data = length ps\n 2. \\<And>i.\n       i < length data \\<Longrightarrow>\n       undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "show leq:\"length data = length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length data = length ps", "using assms"], ["proof (prove)\nusing this:\n  factorize_polys ps = (ftrs, data)\n\ngoal (1 subgoal):\n 1. length data = length ps", "unfolding factorize_polys_def"], ["proof (prove)\nusing this:\n  (let fact_ps = map factorize_rat_poly_monic ps;\n       factors = remdups (map fst (concat (map snd fact_ps)))\n   in Let (map (\\<lambda>(c, fs).\n                   (c, map (\\<lambda>(f, y). (index_of factors f, y)) fs))\n            fact_ps)\n       (Pair factors)) =\n  (ftrs, data)\n\ngoal (1 subgoal):\n 1. length data = length ps", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  length data = length ps\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length data \\<Longrightarrow>\n       undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length data \\<Longrightarrow>\n       undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "assume il:\"i < length data\""], ["proof (state)\nthis:\n  i < length data\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length data \\<Longrightarrow>\n       undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "obtain c fs where cfs: \"factorize_rat_poly_monic (ps ! i) = (c,fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c fs.\n        factorize_rat_poly_monic (ps ! i) = (c, fs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  factorize_rat_poly_monic (ps ! i) = (c, fs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length data \\<Longrightarrow>\n       undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "then"], ["proof (chain)\npicking this:\n  factorize_rat_poly_monic (ps ! i) = (c, fs)", "have fsts:\"set (map fst fs) \\<subseteq> set ftrs\""], ["proof (prove)\nusing this:\n  factorize_rat_poly_monic (ps ! i) = (c, fs)\n\ngoal (1 subgoal):\n 1. set (map fst fs) \\<subseteq> set ftrs", "using assms factorize_polys_has_factors il leq nth_mem"], ["proof (prove)\nusing this:\n  factorize_rat_poly_monic (ps ! i) = (c, fs)\n  factorize_polys ps = (ftrs, data)\n  \\<lbrakk>factorize_polys ?ps = (?ftrs, ?data); ?p \\<in> set ?ps;\n   factorize_rat_poly_monic ?p = (?c, ?fs)\\<rbrakk>\n  \\<Longrightarrow> set (map fst ?fs) \\<subseteq> set ?ftrs\n  i < length data\n  length data = length ps\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. set (map fst fs) \\<subseteq> set ftrs", "by fastforce"], ["proof (state)\nthis:\n  set (map fst fs) \\<subseteq> set ftrs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length data \\<Longrightarrow>\n       undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "have *:\"data ! i = (c,map (\\<lambda>(f,pow). (index_of ftrs f, pow)) fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. data ! i = (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)", "using assms"], ["proof (prove)\nusing this:\n  factorize_polys ps = (ftrs, data)\n\ngoal (1 subgoal):\n 1. data ! i = (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)", "unfolding factorize_polys_def"], ["proof (prove)\nusing this:\n  (let fact_ps = map factorize_rat_poly_monic ps;\n       factors = remdups (map fst (concat (map snd fact_ps)))\n   in Let (map (\\<lambda>(c, fs).\n                   (c, map (\\<lambda>(f, y). (index_of factors f, y)) fs))\n            fact_ps)\n       (Pair factors)) =\n  (ftrs, data)\n\ngoal (1 subgoal):\n 1. data ! i = (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)", "using cfs il"], ["proof (prove)\nusing this:\n  (let fact_ps = map factorize_rat_poly_monic ps;\n       factors = remdups (map fst (concat (map snd fact_ps)))\n   in Let (map (\\<lambda>(c, fs).\n                   (c, map (\\<lambda>(f, y). (index_of factors f, y)) fs))\n            fact_ps)\n       (Pair factors)) =\n  (ftrs, data)\n  factorize_rat_poly_monic (ps ! i) = (c, fs)\n  i < length data\n\ngoal (1 subgoal):\n 1. data ! i = (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)", "by (auto simp add: Let_def cfs)"], ["proof (state)\nthis:\n  data ! i = (c, map (\\<lambda>(f, pow). (index_of ftrs f, pow)) fs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length data \\<Longrightarrow>\n       undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "have \"undo_factorize (data ! i) (sign_vec ftrs x) = squash (rpoly (ps ! i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undo_factorize (data ! i) (sign_vec ftrs x) = squash (rpoly (ps ! i) x)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. undo_factorize (c, map (\\<lambda>(f, y). (index_of ftrs f, y)) fs)\n     (sign_vec ftrs x) =\n    squash (rpoly (ps ! i) x)", "apply (subst  undo_factorize_correct[of \"ps ! i\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. factorize_rat_poly_monic (ps ! i) = (c, fs)\n 2. \\<And>f p. (f, p) \\<in> set fs \\<Longrightarrow> f \\<in> set ftrs\n 3. squash (rpoly (ps ! i) x) = squash (rpoly (ps ! i) x)", "apply (auto simp add: cfs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f p. (f, p) \\<in> set fs \\<Longrightarrow> f \\<in> set ftrs", "using fsts"], ["proof (prove)\nusing this:\n  set (map fst fs) \\<subseteq> set ftrs\n\ngoal (1 subgoal):\n 1. \\<And>f p. (f, p) \\<in> set fs \\<Longrightarrow> f \\<in> set ftrs", "by auto"], ["proof (state)\nthis:\n  undo_factorize (data ! i) (sign_vec ftrs x) = squash (rpoly (ps ! i) x)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length data \\<Longrightarrow>\n       undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "thus \"undo_factorize (data ! i) (sign_vec ftrs x) =  sign_vec ps x ! i\""], ["proof (prove)\nusing this:\n  undo_factorize (data ! i) (sign_vec ftrs x) = squash (rpoly (ps ! i) x)\n\ngoal (1 subgoal):\n 1. undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "using leq il sign_vec_def"], ["proof (prove)\nusing this:\n  undo_factorize (data ! i) (sign_vec ftrs x) = squash (rpoly (ps ! i) x)\n  length data = length ps\n  i < length data\n  sign_vec ?qs ?x \\<equiv> map (squash \\<circ> (\\<lambda>p. rpoly p ?x)) ?qs\n\ngoal (1 subgoal):\n 1. undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i", "by auto"], ["proof (state)\nthis:\n  undo_factorize (data ! i) (sign_vec ftrs x) = sign_vec ps x ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorize_polys_irreducible_monic:\n  assumes \"factorize_polys ps = (fs,data)\"\n  shows \"distinct fs\" \"\\<And>f. f \\<in> set fs \\<Longrightarrow> irreducible f \\<and> monic f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct fs &&&\n    (\\<And>f. f \\<in> set fs \\<Longrightarrow> irreducible f \\<and> monic f)", "using assms"], ["proof (prove)\nusing this:\n  factorize_polys ps = (fs, data)\n\ngoal (1 subgoal):\n 1. distinct fs &&&\n    (\\<And>f. f \\<in> set fs \\<Longrightarrow> irreducible f \\<and> monic f)", "unfolding factorize_polys_def Let_def"], ["proof (prove)\nusing this:\n  (remdups (map fst (concat (map snd (map factorize_rat_poly_monic ps)))),\n   map (\\<lambda>(c, fs).\n           (c, map (\\<lambda>(f, y).\n                       (index_of\n                         (remdups\n                           (map fst\n                             (concat\n                               (map snd\n                                 (map factorize_rat_poly_monic ps)))))\n                         f,\n                        y))\n                fs))\n    (map factorize_rat_poly_monic ps)) =\n  (fs, data)\n\ngoal (1 subgoal):\n 1. distinct fs &&&\n    (\\<And>f. f \\<in> set fs \\<Longrightarrow> irreducible f \\<and> monic f)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>fs =\n                remdups\n                 (map fst\n                   (concat\n                     (map (snd \\<circ> factorize_rat_poly_monic) ps)));\n        data =\n        map ((\\<lambda>(c, fs).\n                 (c, map (\\<lambda>(f, y).\n                             (index_of\n                               (remdups\n                                 (map fst\n                                   (concat\n                                     (map\n (snd \\<circ> factorize_rat_poly_monic) ps))))\n                               f,\n                              y))\n                      fs)) \\<circ>\n             factorize_rat_poly_monic)\n         ps;\n        x \\<in> set ps;\n        (a, b) \\<in> set (snd (factorize_rat_poly_monic x))\\<rbrakk>\n       \\<Longrightarrow> irreducible a\n 2. \\<And>a b x.\n       \\<lbrakk>fs =\n                remdups\n                 (map fst\n                   (concat\n                     (map (snd \\<circ> factorize_rat_poly_monic) ps)));\n        data =\n        map ((\\<lambda>(c, fs).\n                 (c, map (\\<lambda>(f, y).\n                             (index_of\n                               (remdups\n                                 (map fst\n                                   (concat\n                                     (map\n (snd \\<circ> factorize_rat_poly_monic) ps))))\n                               f,\n                              y))\n                      fs)) \\<circ>\n             factorize_rat_poly_monic)\n         ps;\n        x \\<in> set ps;\n        (a, b) \\<in> set (snd (factorize_rat_poly_monic x))\\<rbrakk>\n       \\<Longrightarrow> monic a", "using factorize_rat_poly_monic_irreducible_monic"], ["proof (prove)\nusing this:\n  \\<lbrakk>factorize_rat_poly_monic ?f = (?c, ?fs);\n   (?fi, ?i) \\<in> set ?fs\\<rbrakk>\n  \\<Longrightarrow> irreducible ?fi \\<and> monic ?fi\n\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>fs =\n                remdups\n                 (map fst\n                   (concat\n                     (map (snd \\<circ> factorize_rat_poly_monic) ps)));\n        data =\n        map ((\\<lambda>(c, fs).\n                 (c, map (\\<lambda>(f, y).\n                             (index_of\n                               (remdups\n                                 (map fst\n                                   (concat\n                                     (map\n (snd \\<circ> factorize_rat_poly_monic) ps))))\n                               f,\n                              y))\n                      fs)) \\<circ>\n             factorize_rat_poly_monic)\n         ps;\n        x \\<in> set ps;\n        (a, b) \\<in> set (snd (factorize_rat_poly_monic x))\\<rbrakk>\n       \\<Longrightarrow> irreducible a\n 2. \\<And>a b x.\n       \\<lbrakk>fs =\n                remdups\n                 (map fst\n                   (concat\n                     (map (snd \\<circ> factorize_rat_poly_monic) ps)));\n        data =\n        map ((\\<lambda>(c, fs).\n                 (c, map (\\<lambda>(f, y).\n                             (index_of\n                               (remdups\n                                 (map fst\n                                   (concat\n                                     (map\n (snd \\<circ> factorize_rat_poly_monic) ps))))\n                               f,\n                              y))\n                      fs)) \\<circ>\n             factorize_rat_poly_monic)\n         ps;\n        x \\<in> set ps;\n        (a, b) \\<in> set (snd (factorize_rat_poly_monic x))\\<rbrakk>\n       \\<Longrightarrow> monic a", "apply (metis prod.collapse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>fs =\n                remdups\n                 (map fst\n                   (concat\n                     (map (snd \\<circ> factorize_rat_poly_monic) ps)));\n        data =\n        map ((\\<lambda>(c, fs).\n                 (c, map (\\<lambda>(f, y).\n                             (index_of\n                               (remdups\n                                 (map fst\n                                   (concat\n                                     (map\n (snd \\<circ> factorize_rat_poly_monic) ps))))\n                               f,\n                              y))\n                      fs)) \\<circ>\n             factorize_rat_poly_monic)\n         ps;\n        x \\<in> set ps;\n        (a, b) \\<in> set (snd (factorize_rat_poly_monic x))\\<rbrakk>\n       \\<Longrightarrow> monic a", "using factorize_rat_poly_monic_irreducible_monic"], ["proof (prove)\nusing this:\n  \\<lbrakk>factorize_rat_poly_monic ?f = (?c, ?fs);\n   (?fi, ?i) \\<in> set ?fs\\<rbrakk>\n  \\<Longrightarrow> irreducible ?fi \\<and> monic ?fi\n\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>fs =\n                remdups\n                 (map fst\n                   (concat\n                     (map (snd \\<circ> factorize_rat_poly_monic) ps)));\n        data =\n        map ((\\<lambda>(c, fs).\n                 (c, map (\\<lambda>(f, y).\n                             (index_of\n                               (remdups\n                                 (map fst\n                                   (concat\n                                     (map\n (snd \\<circ> factorize_rat_poly_monic) ps))))\n                               f,\n                              y))\n                      fs)) \\<circ>\n             factorize_rat_poly_monic)\n         ps;\n        x \\<in> set ps;\n        (a, b) \\<in> set (snd (factorize_rat_poly_monic x))\\<rbrakk>\n       \\<Longrightarrow> monic a", "by (metis prod.collapse)"], ["", "lemma factorize_polys_square_free:\n  assumes \"factorize_polys ps = (fs,data)\"\n  shows \"\\<And>f. f \\<in> set fs \\<Longrightarrow> square_free f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> set fs \\<Longrightarrow> square_free f", "using assms factorize_polys_irreducible_monic(2) irreducible_imp_square_free"], ["proof (prove)\nusing this:\n  factorize_polys ps = (fs, data)\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data); ?f \\<in> set ?fs\\<rbrakk>\n  \\<Longrightarrow> irreducible ?f \\<and> monic ?f\n  irreducible ?p \\<Longrightarrow> square_free ?p\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> set fs \\<Longrightarrow> square_free f", "by blast"], ["", "lemma irreducible_monic_coprime:\n  assumes f: \"monic f\" \"irreducible (f::rat poly)\" \n  assumes g: \"monic g\" \"irreducible (g::rat poly)\"\n  assumes \"f \\<noteq> g\"\n  shows \"coprime f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "by (metis (no_types, lifting) assms(5) coprime_0(2) coprime_def' f(1) f(2) g(1) g(2) irreducible_normalized_divisors normalize_dvd_iff normalize_idem normalize_monic)"], ["", "lemma factorize_polys_coprime:\n  assumes \"factorize_polys ps = (fs,data)\"\n  shows \"\\<And>f g. f \\<in> set fs \\<Longrightarrow> g \\<in> set fs \\<Longrightarrow> f \\<noteq> g \\<Longrightarrow> coprime f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> set fs; g \\<in> set fs; f \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "using assms factorize_polys_irreducible_monic(2) irreducible_monic_coprime"], ["proof (prove)\nusing this:\n  factorize_polys ps = (fs, data)\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data); ?f \\<in> set ?fs\\<rbrakk>\n  \\<Longrightarrow> irreducible ?f \\<and> monic ?f\n  \\<lbrakk>monic ?f; irreducible ?f; monic ?g; irreducible ?g;\n   ?f \\<noteq> ?g\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?f ?g\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> set fs; g \\<in> set fs; f \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "by auto"], ["", "lemma coprime_rat_poly_real_poly:\n  assumes \"coprime p (q::rat poly)\"\n  shows \"coprime (real_of_rat_poly p) ((real_of_rat_poly q)::real poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)", "by (metis assms gcd_dvd_1 of_rat_hom.map_poly_gcd of_rat_poly_hom.hom_dvd_1)"], ["", "lemma coprime_rat_poly_iff_coprimereal_poly:\n  shows \"coprime p (q::rat poly) \\<longleftrightarrow> coprime (real_of_rat_poly p) ((real_of_rat_poly q)::real poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q =\n    comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q =\n    comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)", "have forward: \"coprime p (q::rat poly) \\<longrightarrow> coprime (real_of_rat_poly p) ((real_of_rat_poly q)::real poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q \\<longrightarrow>\n    comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)", "using coprime_rat_poly_real_poly"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime ?p ?q \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (real_of_rat_poly ?p) (real_of_rat_poly ?q)\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q \\<longrightarrow>\n    comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime p q \\<longrightarrow>\n  comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q =\n    comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)", "have backward: \"coprime (real_of_rat_poly p) ((real_of_rat_poly q)::real poly) \\<Longrightarrow> coprime p (q::rat poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (real_of_rat_poly p)\n     (real_of_rat_poly q) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (real_of_rat_poly p)\n     (real_of_rat_poly q) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime p q", "assume copr_real: \"comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)\""], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (real_of_rat_poly p)\n     (real_of_rat_poly q) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime p q", "have \"degree (gcd p (q::rat poly)) > 0 \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree (gcd p q) \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < degree (gcd p q) \\<Longrightarrow> False", "assume deg: \"degree (gcd p (q::rat poly)) > 0\""], ["proof (state)\nthis:\n  0 < degree (gcd p q)\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd p q) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < degree (gcd p q)", "have \"\\<exists>y. y dvd p \\<and> y dvd q \\<and> degree y > 0\""], ["proof (prove)\nusing this:\n  0 < degree (gcd p q)\n\ngoal (1 subgoal):\n 1. \\<exists>y. y dvd p \\<and> y dvd q \\<and> 0 < degree y", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. y dvd p \\<and> y dvd q \\<and> 0 < degree y\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd p q) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. y dvd p \\<and> y dvd q \\<and> 0 < degree y", "obtain y where yprop: \"y dvd p \\<and> y dvd q \\<and> degree y > 0\""], ["proof (prove)\nusing this:\n  \\<exists>y. y dvd p \\<and> y dvd q \\<and> 0 < degree y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y dvd p \\<and> y dvd q \\<and> 0 < degree y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y dvd p \\<and> y dvd q \\<and> 0 < degree y\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd p q) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y dvd p \\<and> y dvd q \\<and> 0 < degree y", "have \"(real_of_rat_poly y) dvd (real_of_rat_poly p) \\<and>\n        (real_of_rat_poly y ) dvd (real_of_rat_poly q) \\<and> degree y > 0\""], ["proof (prove)\nusing this:\n  y dvd p \\<and> y dvd q \\<and> 0 < degree y\n\ngoal (1 subgoal):\n 1. real_of_rat_poly y dvd real_of_rat_poly p \\<and>\n    real_of_rat_poly y dvd real_of_rat_poly q \\<and> 0 < degree y", "by simp"], ["proof (state)\nthis:\n  real_of_rat_poly y dvd real_of_rat_poly p \\<and>\n  real_of_rat_poly y dvd real_of_rat_poly q \\<and> 0 < degree y\n\ngoal (1 subgoal):\n 1. 0 < degree (gcd p q) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  real_of_rat_poly y dvd real_of_rat_poly p \\<and>\n  real_of_rat_poly y dvd real_of_rat_poly q \\<and> 0 < degree y", "show \"False\""], ["proof (prove)\nusing this:\n  real_of_rat_poly y dvd real_of_rat_poly p \\<and>\n  real_of_rat_poly y dvd real_of_rat_poly q \\<and> 0 < degree y\n\ngoal (1 subgoal):\n 1. False", "using copr_real"], ["proof (prove)\nusing this:\n  real_of_rat_poly y dvd real_of_rat_poly p \\<and>\n  real_of_rat_poly y dvd real_of_rat_poly q \\<and> 0 < degree y\n  comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)\n\ngoal (1 subgoal):\n 1. False", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>algebraic_semidom_class.coprime (real_of_rat_poly p)\n              (real_of_rat_poly q);\n     real_of_rat_poly y dvd real_of_rat_poly p;\n     real_of_rat_poly y dvd real_of_rat_poly q; 0 < degree y\\<rbrakk>\n    \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < degree (gcd p q) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (real_of_rat_poly p)\n     (real_of_rat_poly q) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime p q", "then"], ["proof (chain)\npicking this:\n  0 < degree (gcd p q) \\<Longrightarrow> False", "show \"comm_monoid_mult_class.coprime p (q::rat poly)\""], ["proof (prove)\nusing this:\n  0 < degree (gcd p q) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q", "using comm_monoid_gcd_class.gcd_dvd_1"], ["proof (prove)\nusing this:\n  0 < degree (gcd p q) \\<Longrightarrow> False\n  (gcd ?a ?b dvd (1::?'a)) = comm_monoid_mult_class.coprime ?a ?b\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q", "by (metis Missing_Polynomial_Factorial.is_unit_field_poly copr_real gcd_zero_iff' neq0_conv of_rat_poly_hom.hom_zero)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (real_of_rat_poly p)\n   (real_of_rat_poly q) \\<Longrightarrow>\n  comm_monoid_mult_class.coprime p q\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q =\n    comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q =\n    comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)", "using forward backward"], ["proof (prove)\nusing this:\n  comm_monoid_mult_class.coprime p q \\<longrightarrow>\n  comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)\n  comm_monoid_mult_class.coprime (real_of_rat_poly p)\n   (real_of_rat_poly q) \\<Longrightarrow>\n  comm_monoid_mult_class.coprime p q\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q =\n    comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime p q =\n  comm_monoid_mult_class.coprime (real_of_rat_poly p) (real_of_rat_poly q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorize_polys_map_distinct:\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss =  map real_of_rat_poly fs\"\n  shows \"distinct fss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct fss", "using factorize_polys_irreducible_monic[OF assms(1)]"], ["proof (prove)\nusing this:\n  distinct fs\n  ?f \\<in> set fs \\<Longrightarrow> irreducible ?f \\<and> monic ?f\n\ngoal (1 subgoal):\n 1. distinct fss", "unfolding assms(2)"], ["proof (prove)\nusing this:\n  distinct fs\n  ?f \\<in> set fs \\<Longrightarrow> irreducible ?f \\<and> monic ?f\n\ngoal (1 subgoal):\n 1. distinct (map real_of_rat_poly fs)", "apply (simp add: distinct_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<length fs.\n                \\<forall>j<length fs.\n                   i \\<noteq> j \\<longrightarrow> fs ! i \\<noteq> fs ! j;\n     \\<And>f.\n        f \\<in> set fs \\<Longrightarrow>\n        irreducible f \\<and> monic f\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length fs.\n                         \\<forall>j<length fs.\n                            i \\<noteq> j \\<longrightarrow>\n                            real_of_rat_poly (fs ! i) \\<noteq>\n                            real_of_rat_poly (fs ! j)", "by (metis of_rat_eq_iff of_rat_hom.coeff_map_poly_hom poly_eqI)"], ["", "lemma factorize_polys_map_square_free:\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss =  map real_of_rat_poly fs\"\n  shows \"\\<And>f. f \\<in> set fss \\<Longrightarrow> square_free f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> set fss \\<Longrightarrow> square_free f", "using factorize_polys_square_free[OF assms(1)]"], ["proof (prove)\nusing this:\n  ?f \\<in> set fs \\<Longrightarrow> square_free ?f\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> set fss \\<Longrightarrow> square_free f", "using assms(2) field_hom_0'.square_free_map_poly of_rat_hom.field_hom_0'_axioms"], ["proof (prove)\nusing this:\n  ?f \\<in> set fs \\<Longrightarrow> square_free ?f\n  fss = map real_of_rat_poly fs\n  field_hom_0' ?hom \\<Longrightarrow>\n  square_free (map_poly ?hom ?f) = square_free ?f\n  field_hom_0' of_rat\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> set fss \\<Longrightarrow> square_free f", "by auto"], ["", "lemma factorize_polys_map_coprime:\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss =  map real_of_rat_poly fs\"\n  shows \"\\<And>f g. f \\<in> set fss \\<Longrightarrow> g \\<in> set fss \\<Longrightarrow> f \\<noteq> g \\<Longrightarrow> coprime f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> set fss; g \\<in> set fss; f \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "using factorize_polys_coprime[OF assms(1)] coprime_rat_poly_real_poly"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set fs; ?g \\<in> set fs; ?f \\<noteq> ?g\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?f ?g\n  comm_monoid_mult_class.coprime ?p ?q \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (real_of_rat_poly ?p) (real_of_rat_poly ?q)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> set fss; g \\<in> set fss; f \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "unfolding assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set fs; ?g \\<in> set fs; ?f \\<noteq> ?g\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?f ?g\n  comm_monoid_mult_class.coprime ?p ?q \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (real_of_rat_poly ?p) (real_of_rat_poly ?q)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> set (map real_of_rat_poly fs);\n        g \\<in> set (map real_of_rat_poly fs); f \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "by auto"], ["", "lemma coprime_prod_list:\n  assumes \"\\<And>p. p \\<in> set ps \\<Longrightarrow> p \\<noteq> 0\"\n  assumes \"coprime (prod_list ps) (q::real poly)\"  \n  shows \"\\<And>p. p \\<in> set ps \\<Longrightarrow> coprime p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> set ps \\<Longrightarrow> comm_monoid_mult_class.coprime p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> set ps \\<Longrightarrow> comm_monoid_mult_class.coprime p q", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> set ps \\<Longrightarrow> comm_monoid_mult_class.coprime p q", "assume \"p \\<in> set ps\""], ["proof (state)\nthis:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> set ps \\<Longrightarrow> comm_monoid_mult_class.coprime p q", "then"], ["proof (chain)\npicking this:\n  p \\<in> set ps", "obtain r where r: \"prod_list ps = r * p\""], ["proof (prove)\nusing this:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        prod_list ps = r * p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using remove1_retains_prod"], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  ?a \\<in> set ?xs \\<longrightarrow>\n  prod_list ?xs = prod_list (remove1 ?a ?xs) * ?a\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        prod_list ps = r * p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prod_list ps = r * p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> set ps \\<Longrightarrow> comm_monoid_mult_class.coprime p q", "show \"coprime p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime p q", "apply (rule coprime_prod[of r 1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. r \\<noteq> 0\n 2. 1 \\<noteq> 0\n 3. comm_monoid_mult_class.coprime (r * p) (1 * q)", "using assms r"], ["proof (prove)\nusing this:\n  ?p \\<in> set ps \\<Longrightarrow> ?p \\<noteq> 0\n  comm_monoid_mult_class.coprime (prod_list ps) q\n  prod_list ps = r * p\n\ngoal (3 subgoals):\n 1. r \\<noteq> 0\n 2. 1 \\<noteq> 0\n 3. comm_monoid_mult_class.coprime (r * p) (1 * q)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p. p \\<in> set ps \\<Longrightarrow> p \\<noteq> 0;\n     0 \\<in> set ps; algebraic_semidom_class.coprime p q; r = 0;\n     q \\<noteq> 0; degree q = 0\\<rbrakk>\n    \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime p q\n\ngoal:\nNo subgoals!", "qed"], ["", "(* basically copied from square_free_factorizationD' *)"], ["", "lemma factorize_polys_square_free_prod_list:\n  assumes \"factorize_polys ps = (fs,data)\"\n  shows \"square_free (prod_list fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (prod_list fs)", "proof (rule square_freeI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False\n 2. prod_list fs \\<noteq> 0", "from factorize_polys_coprime[OF assms]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?f \\<in> set fs; ?g \\<in> set fs; ?f \\<noteq> ?g\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?f ?g", "have coprime: \"\\<And>p q. p \\<in> set fs \\<Longrightarrow> q \\<in> set fs \\<Longrightarrow> p \\<noteq> q \\<Longrightarrow> coprime p q\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> set fs; ?g \\<in> set fs; ?f \\<noteq> ?g\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?f ?g\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> set fs; q \\<in> set fs; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime p q", "."], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<in> set fs; ?q \\<in> set fs; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?p ?q\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False\n 2. prod_list fs \\<noteq> 0", "from factorize_polys_square_free[OF assms]"], ["proof (chain)\npicking this:\n  ?f \\<in> set fs \\<Longrightarrow> square_free ?f", "have sq: \"\\<And>p. p \\<in> set fs \\<Longrightarrow> square_free p\""], ["proof (prove)\nusing this:\n  ?f \\<in> set fs \\<Longrightarrow> square_free ?f\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> set fs \\<Longrightarrow> square_free p", "."], ["proof (state)\nthis:\n  ?p \\<in> set fs \\<Longrightarrow> square_free ?p\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False\n 2. prod_list fs \\<noteq> 0", "thus \"prod_list fs \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> square_free ?p\n\ngoal (1 subgoal):\n 1. prod_list fs \\<noteq> 0", "unfolding prod_list_zero_iff"], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> square_free ?p\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set fs", "using square_free_def"], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> square_free ?p\n  square_free ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd ?p))\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set fs", "by blast"], ["proof (state)\nthis:\n  prod_list fs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"degree q > 0\" \"q * q dvd prod_list fs\""], ["proof (state)\nthis:\n  0 < degree q\n  q * q dvd prod_list fs\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducible\\<^sub>d_factor[OF this(1)] this(2)"], ["proof (chain)\npicking this:\n  \\<exists>qa r.\n     irreducible\\<^sub>d qa \\<and> q = qa * r \\<and> degree r < degree q\n  q * q dvd prod_list fs", "obtain q where \n    irr: \"irreducible q\" and dvd: \"q * q dvd prod_list fs\""], ["proof (prove)\nusing this:\n  \\<exists>qa r.\n     irreducible\\<^sub>d qa \\<and> q = qa * r \\<and> degree r < degree q\n  q * q dvd prod_list fs\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>irreducible q; q * q dvd prod_list fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>qa r.\n     irreducible\\<^sub>d qa \\<and> q = qa * r \\<and> degree r < degree q\n  \\<exists>k. prod_list fs = q * q * k\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>irreducible q;\n         \\<exists>k. prod_list fs = q * q * k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  irreducible q\n  q * q dvd prod_list fs\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "hence dvd': \"q dvd prod_list fs\""], ["proof (prove)\nusing this:\n  irreducible q\n  q * q dvd prod_list fs\n\ngoal (1 subgoal):\n 1. q dvd prod_list fs", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  irreducible q\n  \\<exists>k. prod_list fs = q * q * k\n\ngoal (1 subgoal):\n 1. \\<exists>k. prod_list fs = q * k", "by auto"], ["proof (state)\nthis:\n  q dvd prod_list fs\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducible_dvd_prod_list[OF irr dvd']"], ["proof (chain)\npicking this:\n  Bex (set fs) ((dvd) q)", "obtain b where \n    mem: \"b \\<in> set fs\" and dvd1: \"q dvd b\""], ["proof (prove)\nusing this:\n  Bex (set fs) ((dvd) q)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> set fs; q dvd b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b \\<in> set fs\n  q dvd b\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "from dvd1"], ["proof (chain)\npicking this:\n  q dvd b", "obtain k where b: \"b = q * k\""], ["proof (prove)\nusing this:\n  q dvd b\n\ngoal (1 subgoal):\n 1. (\\<And>k. b = q * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. b = q * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. b = q * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  b = q * k\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "from split_list[OF mem] b"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. fs = ys @ b # zs\n  b = q * k", "obtain bs1 bs2 where bs: \"fs = bs1 @ b # bs2\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. fs = ys @ b # zs\n  b = q * k\n\ngoal (1 subgoal):\n 1. (\\<And>bs1 bs2.\n        fs = bs1 @ b # bs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fs = bs1 @ b # bs2\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "from irr"], ["proof (chain)\npicking this:\n  irreducible q", "have q0: \"q \\<noteq> 0\" and dq: \"degree q > 0\""], ["proof (prove)\nusing this:\n  irreducible q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& 0 < degree q", "unfolding irreducible\\<^sub>d_def"], ["proof (prove)\nusing this:\n  irreducible q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& 0 < degree q", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "have \"square_free (q * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (q * k)", "using sq b mem"], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> square_free ?p\n  b = q * k\n  b \\<in> set fs\n\ngoal (1 subgoal):\n 1. square_free (q * k)", "by auto"], ["proof (state)\nthis:\n  square_free (q * k)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "from this[unfolded square_free_def, THEN conjunct2, rule_format, OF dq]"], ["proof (chain)\npicking this:\n  \\<not> q * q dvd q * k", "have qk: \"\\<not> q dvd k\""], ["proof (prove)\nusing this:\n  \\<not> q * q dvd q * k\n\ngoal (1 subgoal):\n 1. \\<not> q dvd k", "by simp"], ["proof (state)\nthis:\n  \\<not> q dvd k\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "from dvd[unfolded bs b]"], ["proof (chain)\npicking this:\n  q * q dvd prod_list (bs1 @ q * k # bs2)", "have \"q * q dvd q * (k * prod_list (bs1 @ bs2))\""], ["proof (prove)\nusing this:\n  q * q dvd prod_list (bs1 @ q * k # bs2)\n\ngoal (1 subgoal):\n 1. q * q dvd q * (k * prod_list (bs1 @ bs2))", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  q * q dvd q * (k * prod_list (bs1 @ bs2))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "with q0"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  q * q dvd q * (k * prod_list (bs1 @ bs2))", "have \"q dvd k * prod_list (bs1 @ bs2)\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  q * q dvd q * (k * prod_list (bs1 @ bs2))\n\ngoal (1 subgoal):\n 1. q dvd k * prod_list (bs1 @ bs2)", "by auto"], ["proof (state)\nthis:\n  q dvd k * prod_list (bs1 @ bs2)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "with irr qk"], ["proof (chain)\npicking this:\n  irreducible q\n  \\<not> q dvd k\n  q dvd k * prod_list (bs1 @ bs2)", "have \"q dvd prod_list (bs1 @ bs2)\""], ["proof (prove)\nusing this:\n  irreducible q\n  \\<not> q dvd k\n  q dvd k * prod_list (bs1 @ bs2)\n\ngoal (1 subgoal):\n 1. q dvd prod_list (bs1 @ bs2)", "by auto"], ["proof (state)\nthis:\n  q dvd prod_list (bs1 @ bs2)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducible_dvd_prod_list[OF irr this]"], ["proof (chain)\npicking this:\n  Bex (set (bs1 @ bs2)) ((dvd) q)", "obtain b' where \n    mem': \"b' \\<in> set (bs1 @ bs2)\" and dvd2: \"q dvd b'\""], ["proof (prove)\nusing this:\n  Bex (set (bs1 @ bs2)) ((dvd) q)\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' \\<in> set (bs1 @ bs2); q dvd b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  b' \\<in> set (bs1 @ bs2)\n  q dvd b'\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "from dvd1 dvd2"], ["proof (chain)\npicking this:\n  q dvd b\n  q dvd b'", "have \"q dvd gcd b b'\""], ["proof (prove)\nusing this:\n  q dvd b\n  q dvd b'\n\ngoal (1 subgoal):\n 1. q dvd gcd b b'", "by auto"], ["proof (state)\nthis:\n  q dvd gcd b b'\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "with dq is_unit_iff_degree[OF q0]"], ["proof (chain)\npicking this:\n  0 < degree q\n  is_unit q = (degree q = 0)\n  q dvd gcd b b'", "have cop: \"\\<not> coprime b b'\""], ["proof (prove)\nusing this:\n  0 < degree q\n  is_unit q = (degree q = 0)\n  q dvd gcd b b'\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime b b'", "by force"], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime b b'\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "from mem'"], ["proof (chain)\npicking this:\n  b' \\<in> set (bs1 @ bs2)", "have \"b' \\<in> set fs\""], ["proof (prove)\nusing this:\n  b' \\<in> set (bs1 @ bs2)\n\ngoal (1 subgoal):\n 1. b' \\<in> set fs", "unfolding bs"], ["proof (prove)\nusing this:\n  b' \\<in> set (bs1 @ bs2)\n\ngoal (1 subgoal):\n 1. b' \\<in> set (bs1 @ b # bs2)", "by auto"], ["proof (state)\nthis:\n  b' \\<in> set fs\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "have b': \"b' = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' = b", "using coprime"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> set fs; ?q \\<in> set fs; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?p ?q\n\ngoal (1 subgoal):\n 1. b' = b", "using \\<open>b' \\<in> set fs\\<close> cop mem"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> set fs; ?q \\<in> set fs; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?p ?q\n  b' \\<in> set fs\n  \\<not> comm_monoid_mult_class.coprime b b'\n  b \\<in> set fs\n\ngoal (1 subgoal):\n 1. b' = b", "by blast"], ["proof (state)\nthis:\n  b' = b\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>0 < degree q; q \\<noteq> 0; q * q dvd prod_list fs\\<rbrakk>\n       \\<Longrightarrow> False", "with mem' bs factorize_polys_irreducible_monic(1)[OF assms]"], ["proof (chain)\npicking this:\n  b' \\<in> set (bs1 @ bs2)\n  fs = bs1 @ b # bs2\n  distinct fs\n  b' = b", "show False"], ["proof (prove)\nusing this:\n  b' \\<in> set (bs1 @ bs2)\n  fs = bs1 @ b # bs2\n  distinct fs\n  b' = b\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorize_polys_map_square_free_prod_list:\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss =  map real_of_rat_poly fs\"\n  shows \"square_free (prod_list fss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (prod_list fss)", "using  factorize_polys_square_free_prod_list[OF assms(1)]"], ["proof (prove)\nusing this:\n  square_free (prod_list fs)\n\ngoal (1 subgoal):\n 1. square_free (prod_list fss)", "unfolding assms(2)"], ["proof (prove)\nusing this:\n  square_free (prod_list fs)\n\ngoal (1 subgoal):\n 1. square_free (prod_list (map real_of_rat_poly fs))", "by (simp add: of_rat_hom.square_free_map_poly)"], ["", "lemma factorize_polys_map_coprime_pderiv:\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss = map real_of_rat_poly fs\"\n  shows \"\\<And>f. f \\<in> set fss \\<Longrightarrow> coprime f (pderiv (prod_list fss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f (pderiv (prod_list fss))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f (pderiv (prod_list fss))", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f (pderiv (prod_list fss))", "assume f: \"f \\<in> set fss\""], ["proof (state)\nthis:\n  f \\<in> set fss\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f (pderiv (prod_list fss))", "from factorize_polys_map_square_free[OF assms]"], ["proof (chain)\npicking this:\n  ?f \\<in> set fss \\<Longrightarrow> square_free ?f", "have sq: \"\\<And>p. p \\<in> set fss \\<Longrightarrow> square_free p\""], ["proof (prove)\nusing this:\n  ?f \\<in> set fss \\<Longrightarrow> square_free ?f\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> set fss \\<Longrightarrow> square_free p", "."], ["proof (state)\nthis:\n  ?p \\<in> set fss \\<Longrightarrow> square_free ?p\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f (pderiv (prod_list fss))", "have z: \"\\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0", "using sq square_free_def"], ["proof (prove)\nusing this:\n  ?p \\<in> set fss \\<Longrightarrow> square_free ?p\n  square_free ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd ?p))\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  ?p \\<in> set fss \\<Longrightarrow> ?p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f (pderiv (prod_list fss))", "have c: \"coprime (prod_list fss) (pderiv (prod_list fss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (prod_list fss) (pderiv (prod_list fss))", "apply (simp add: separable_def[symmetric] square_free_iff_separable[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (prod_list fss)", "using factorize_polys_map_square_free_prod_list[OF assms]"], ["proof (prove)\nusing this:\n  square_free (prod_list fss)\n\ngoal (1 subgoal):\n 1. square_free (prod_list fss)", "."], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime (prod_list fss) (pderiv (prod_list fss))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f (pderiv (prod_list fss))", "from coprime_prod_list[OF z c f]"], ["proof (chain)\npicking this:\n  (\\<And>p.\n      p \\<in> set fss \\<Longrightarrow> p \\<in> set fss) \\<Longrightarrow>\n  comm_monoid_mult_class.coprime f (pderiv (prod_list fss))", "show \"coprime f (pderiv (prod_list fss))\""], ["proof (prove)\nusing this:\n  (\\<And>p.\n      p \\<in> set fss \\<Longrightarrow> p \\<in> set fss) \\<Longrightarrow>\n  comm_monoid_mult_class.coprime f (pderiv (prod_list fss))\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f (pderiv (prod_list fss))", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f (pderiv (prod_list fss))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition pairwise_coprime_list:: \"rat poly list \\<Rightarrow> bool\"\n  where \"pairwise_coprime_list qs = \n    (\\<forall>m < length qs. \\<forall> n < length qs.\n     m \\<noteq> n \\<longrightarrow> coprime (qs ! n) (qs ! m))\""], ["", "(* Restating factorize_polys_map_coprime to match later definitions *)"], ["", "lemma coprime_factorize:\n  fixes qs:: \"rat poly list\"\n  shows \"pairwise_coprime_list (fst(factorize_polys qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise_coprime_list (fst (factorize_polys qs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pairwise_coprime_list (fst (factorize_polys qs))", "let ?fs = \"fst(factorize_polys qs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. pairwise_coprime_list (fst (factorize_polys qs))", "have \"(\\<forall>m < length ?fs. \\<forall> n < length ?fs.\n     m \\<noteq> n \\<longrightarrow> coprime (?fs ! n) (?fs ! m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m<length (fst (factorize_polys qs)).\n       \\<forall>n<length (fst (factorize_polys qs)).\n          m \\<noteq> n \\<longrightarrow>\n          comm_monoid_mult_class.coprime (fst (factorize_polys qs) ! n)\n           (fst (factorize_polys qs) ! m)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>m < length (fst (factorize_polys qs));\n        n < length (fst (factorize_polys qs)); m \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (fst (factorize_polys qs) ! n)\n                          (fst (factorize_polys qs) ! m)", "fix m n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>m < length (fst (factorize_polys qs));\n        n < length (fst (factorize_polys qs)); m \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (fst (factorize_polys qs) ! n)\n                          (fst (factorize_polys qs) ! m)", "assume \"m < length (fst (factorize_polys qs))\""], ["proof (state)\nthis:\n  m < length (fst (factorize_polys qs))\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>m < length (fst (factorize_polys qs));\n        n < length (fst (factorize_polys qs)); m \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (fst (factorize_polys qs) ! n)\n                          (fst (factorize_polys qs) ! m)", "assume \"n < length (fst (factorize_polys qs))\""], ["proof (state)\nthis:\n  n < length (fst (factorize_polys qs))\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>m < length (fst (factorize_polys qs));\n        n < length (fst (factorize_polys qs)); m \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (fst (factorize_polys qs) ! n)\n                          (fst (factorize_polys qs) ! m)", "assume \"m \\<noteq> n\""], ["proof (state)\nthis:\n  m \\<noteq> n\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>m < length (fst (factorize_polys qs));\n        n < length (fst (factorize_polys qs)); m \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (fst (factorize_polys qs) ! n)\n                          (fst (factorize_polys qs) ! m)", "show \" algebraic_semidom_class.coprime (fst (factorize_polys qs) ! n)\n            (fst (factorize_polys qs) ! m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (fst (factorize_polys qs) ! n)\n     (fst (factorize_polys qs) ! m)", "by (metis \\<open>m < length (fst (factorize_polys qs))\\<close> \\<open>m \\<noteq> n\\<close> \\<open>n < length (fst (factorize_polys qs))\\<close> coprime_iff_coprime distinct_conv_nth factorize_polys_coprime factorize_polys_def factorize_polys_irreducible_monic(1) fstI nth_mem)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime (fst (factorize_polys qs) ! n)\n   (fst (factorize_polys qs) ! m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m<length (fst (factorize_polys qs)).\n     \\<forall>n<length (fst (factorize_polys qs)).\n        m \\<noteq> n \\<longrightarrow>\n        comm_monoid_mult_class.coprime (fst (factorize_polys qs) ! n)\n         (fst (factorize_polys qs) ! m)\n\ngoal (1 subgoal):\n 1. pairwise_coprime_list (fst (factorize_polys qs))", "then"], ["proof (chain)\npicking this:\n  \\<forall>m<length (fst (factorize_polys qs)).\n     \\<forall>n<length (fst (factorize_polys qs)).\n        m \\<noteq> n \\<longrightarrow>\n        comm_monoid_mult_class.coprime (fst (factorize_polys qs) ! n)\n         (fst (factorize_polys qs) ! m)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m<length (fst (factorize_polys qs)).\n     \\<forall>n<length (fst (factorize_polys qs)).\n        m \\<noteq> n \\<longrightarrow>\n        comm_monoid_mult_class.coprime (fst (factorize_polys qs) ! n)\n         (fst (factorize_polys qs) ! m)\n\ngoal (1 subgoal):\n 1. pairwise_coprime_list (fst (factorize_polys qs))", "unfolding pairwise_coprime_list_def"], ["proof (prove)\nusing this:\n  \\<forall>m<length (fst (factorize_polys qs)).\n     \\<forall>n<length (fst (factorize_polys qs)).\n        m \\<noteq> n \\<longrightarrow>\n        comm_monoid_mult_class.coprime (fst (factorize_polys qs) ! n)\n         (fst (factorize_polys qs) ! m)\n\ngoal (1 subgoal):\n 1. \\<forall>m<length (fst (factorize_polys qs)).\n       \\<forall>n<length (fst (factorize_polys qs)).\n          m \\<noteq> n \\<longrightarrow>\n          comm_monoid_mult_class.coprime (fst (factorize_polys qs) ! n)\n           (fst (factorize_polys qs) ! m)", "by auto"], ["proof (state)\nthis:\n  pairwise_coprime_list (fst (factorize_polys qs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma squarefree_factorization_degree:\n  assumes \"square_free_factorization p (c,fs)\"\n  shows \"degree p = sum_list (map (\\<lambda>(f,c). (c+1) * degree f) fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = (\\<Sum>(f, c)\\<leftarrow>fs. (c + 1) * degree f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p = (\\<Sum>(f, c)\\<leftarrow>fs. (c + 1) * degree f)", "have \"p =\n    Polynomial.smult c\n     (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "using assms"], ["proof (prove)\nusing this:\n  square_free_factorization p (c, fs)\n\ngoal (1 subgoal):\n 1. p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "unfolding square_free_factorization_def"], ["proof (prove)\nusing this:\n  case (c, fs) of\n  (c, bs) \\<Rightarrow>\n    p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set bs. a ^ Suc i) \\<and>\n    (p = 0 \\<longrightarrow> c = (0::'a) \\<and> bs = []) \\<and>\n    (\\<forall>a i.\n        (a, i) \\<in> set bs \\<longrightarrow>\n        square_free a \\<and> 0 < degree a) \\<and>\n    (\\<forall>a i b j.\n        (a, i) \\<in> set bs \\<longrightarrow>\n        (b, j) \\<in> set bs \\<longrightarrow>\n        (a, i) \\<noteq> (b, j) \\<longrightarrow>\n        algebraic_semidom_class.coprime a b) \\<and>\n    distinct bs\n\ngoal (1 subgoal):\n 1. p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "by blast"], ["proof (state)\nthis:\n  p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. degree p = (\\<Sum>(f, c)\\<leftarrow>fs. (c + 1) * degree f)", "then"], ["proof (chain)\npicking this:\n  p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "have \"degree p = degree (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\""], ["proof (prove)\nusing this:\n  p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. degree p = degree (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "using assms square_free_factorizationD(4)"], ["proof (prove)\nusing this:\n  p = Polynomial.smult c (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n  square_free_factorization p (c, fs)\n  \\<lbrakk>square_free_factorization ?p (?c, ?bs); ?p = 0\\<rbrakk>\n  \\<Longrightarrow> ?c = (0::?'a) \\<and> ?bs = []\n\ngoal (1 subgoal):\n 1. degree p = degree (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)", "by fastforce"], ["proof (state)\nthis:\n  degree p = degree (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. degree p = (\\<Sum>(f, c)\\<leftarrow>fs. (c + 1) * degree f)", "also"], ["proof (state)\nthis:\n  degree p = degree (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. degree p = (\\<Sum>(f, c)\\<leftarrow>fs. (c + 1) * degree f)", "have \"... = degree (prod_list (map (\\<lambda>(f,c). f ^ Suc c) fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) =\n    degree (\\<Prod>(f, c)\\<leftarrow>fs. f ^ Suc c)", "by (metis assms prod.distinct_set_conv_list square_free_factorizationD(5))"], ["proof (state)\nthis:\n  degree (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) =\n  degree (\\<Prod>(f, c)\\<leftarrow>fs. f ^ Suc c)\n\ngoal (1 subgoal):\n 1. degree p = (\\<Sum>(f, c)\\<leftarrow>fs. (c + 1) * degree f)", "also"], ["proof (state)\nthis:\n  degree (\\<Prod>(a, i)\\<in>set fs. a ^ Suc i) =\n  degree (\\<Prod>(f, c)\\<leftarrow>fs. f ^ Suc c)\n\ngoal (1 subgoal):\n 1. degree p = (\\<Sum>(f, c)\\<leftarrow>fs. (c + 1) * degree f)", "have \"... = (\\<Sum>(a, i)\\<leftarrow>fs. degree (a ^ Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>(f, c)\\<leftarrow>fs. f ^ Suc c) =\n    (\\<Sum>(a, i)\\<leftarrow>fs. degree (a ^ Suc i))", "apply (subst degree_prod_list_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       p \\<in> set (map (\\<lambda>(f, c). f ^ Suc c) fs) \\<Longrightarrow>\n       p \\<noteq> 0\n 2. sum_list (map degree (map (\\<lambda>(f, c). f ^ Suc c) fs)) =\n    (\\<Sum>(a, i)\\<leftarrow>fs. degree (a ^ Suc i))", "apply (auto simp add: o_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b. (0, b) \\<in> set fs \\<Longrightarrow> False\n 2. \\<And>b.\n       \\<lbrakk>(0, b) \\<in> set fs; 0 < b\\<rbrakk> \\<Longrightarrow> False\n 3. (\\<Sum>x\\<leftarrow>fs. degree\n                             (case x of (f, c) \\<Rightarrow> f * f ^ c)) =\n    (\\<Sum>(a, i)\\<leftarrow>fs. degree (a * a ^ i))", "using assms degree_0 square_free_factorizationD(2)"], ["proof (prove)\nusing this:\n  square_free_factorization p (c, fs)\n  degree 0 = 0\n  \\<lbrakk>square_free_factorization ?p (?c, ?bs);\n   (?a, ?i) \\<in> set ?bs\\<rbrakk>\n  \\<Longrightarrow> square_free ?a \\<and> degree ?a \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<And>b. (0, b) \\<in> set fs \\<Longrightarrow> False\n 2. \\<And>b.\n       \\<lbrakk>(0, b) \\<in> set fs; 0 < b\\<rbrakk> \\<Longrightarrow> False\n 3. (\\<Sum>x\\<leftarrow>fs. degree\n                             (case x of (f, c) \\<Rightarrow> f * f ^ c)) =\n    (\\<Sum>(a, i)\\<leftarrow>fs. degree (a * a ^ i))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>(0, b) \\<in> set fs; 0 < b\\<rbrakk> \\<Longrightarrow> False\n 2. (\\<Sum>x\\<leftarrow>fs. degree\n                             (case x of (f, c) \\<Rightarrow> f * f ^ c)) =\n    (\\<Sum>(a, i)\\<leftarrow>fs. degree (a * a ^ i))", "using assms degree_0 square_free_factorizationD(2)"], ["proof (prove)\nusing this:\n  square_free_factorization p (c, fs)\n  degree 0 = 0\n  \\<lbrakk>square_free_factorization ?p (?c, ?bs);\n   (?a, ?i) \\<in> set ?bs\\<rbrakk>\n  \\<Longrightarrow> square_free ?a \\<and> degree ?a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>(0, b) \\<in> set fs; 0 < b\\<rbrakk> \\<Longrightarrow> False\n 2. (\\<Sum>x\\<leftarrow>fs. degree\n                             (case x of (f, c) \\<Rightarrow> f * f ^ c)) =\n    (\\<Sum>(a, i)\\<leftarrow>fs. degree (a * a ^ i))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>fs. degree\n                             (case x of (f, c) \\<Rightarrow> f * f ^ c)) =\n    (\\<Sum>(a, i)\\<leftarrow>fs. degree (a * a ^ i))", "by (simp add: prod.case_distrib)"], ["proof (state)\nthis:\n  degree (\\<Prod>(f, c)\\<leftarrow>fs. f ^ Suc c) =\n  (\\<Sum>(a, i)\\<leftarrow>fs. degree (a ^ Suc i))\n\ngoal (1 subgoal):\n 1. degree p = (\\<Sum>(f, c)\\<leftarrow>fs. (c + 1) * degree f)", "ultimately"], ["proof (chain)\npicking this:\n  degree p = degree (\\<Prod>(f, c)\\<leftarrow>fs. f ^ Suc c)\n  degree (\\<Prod>(f, c)\\<leftarrow>fs. f ^ Suc c) =\n  (\\<Sum>(a, i)\\<leftarrow>fs. degree (a ^ Suc i))", "show ?thesis"], ["proof (prove)\nusing this:\n  degree p = degree (\\<Prod>(f, c)\\<leftarrow>fs. f ^ Suc c)\n  degree (\\<Prod>(f, c)\\<leftarrow>fs. f ^ Suc c) =\n  (\\<Sum>(a, i)\\<leftarrow>fs. degree (a ^ Suc i))\n\ngoal (1 subgoal):\n 1. degree p = (\\<Sum>(f, c)\\<leftarrow>fs. (c + 1) * degree f)", "by (smt Polynomial.degree_power_eq add.commute assms degree_0 map_eq_conv plus_1_eq_Suc split_cong square_free_factorizationD(2))"], ["proof (state)\nthis:\n  degree p = (\\<Sum>(f, c)\\<leftarrow>fs. (c + 1) * degree f)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Auxiliary Polynomial Lemmas\""], ["", "definition roots_of_coprime_r:: \"real poly list \\<Rightarrow> real set\"\n  where \"roots_of_coprime_r qs = {x. poly (coprime_r qs) x = 0}\""], ["", "lemma crb_lem_pos: \n  fixes x:: \"real\"\n  fixes p:: \"real poly\"\n  assumes x: \"poly p x = 0\" \n  assumes p: \"p \\<noteq> 0\" \n  shows \"x < crb p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < real_of_int (crb p)", "using cauchy_root_bound[of p x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>poly p x = 0; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> norm x\n                    \\<le> 1 +\n                          max_list_non_empty\n                           (map (\\<lambda>i. norm (coeff p i))\n                             [0..<degree p]) /\n                          norm (lead_coeff p)\n\ngoal (1 subgoal):\n 1. x < real_of_int (crb p)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>poly p x = 0; p \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> \\<bar>x\\<bar>\n                       \\<le> 1 +\n                             max_list_non_empty\n                              (map (\\<lambda>i. \\<bar>coeff p i\\<bar>)\n                                [0..<degree p]) /\n                             \\<bar>lead_coeff p\\<bar>) \\<Longrightarrow>\n    x < real_of_int (crb p)", "unfolding crb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>poly p x = 0; p \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> \\<bar>x\\<bar>\n                       \\<le> 1 +\n                             max_list_non_empty\n                              (map (\\<lambda>i. \\<bar>coeff p i\\<bar>)\n                                [0..<degree p]) /\n                             \\<bar>lead_coeff p\\<bar>) \\<Longrightarrow>\n    x < real_of_int\n         \\<lceil>2 +\n                 max_list_non_empty\n                  (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n                 norm (lead_coeff p)\\<rceil>", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>poly p x = 0; p \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> \\<bar>x\\<bar>\n                       \\<le> 1 +\n                             max_list_non_empty\n                              (map (\\<lambda>i. \\<bar>coeff p i\\<bar>)\n                                [0..<degree p]) /\n                             \\<bar>lead_coeff p\\<bar>) \\<Longrightarrow>\n    x < real_of_int\n         \\<lceil>2 +\n                 max_list_non_empty\n                  (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<degree p]) /\n                 \\<bar>lead_coeff p\\<bar>\\<rceil>", "using p x"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>poly p x = 0; p \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> \\<bar>x\\<bar>\n                       \\<le> 1 +\n                             max_list_non_empty\n                              (map (\\<lambda>i. \\<bar>coeff p i\\<bar>)\n                                [0..<degree p]) /\n                             \\<bar>lead_coeff p\\<bar>) \\<Longrightarrow>\n    x < real_of_int\n         \\<lceil>2 +\n                 max_list_non_empty\n                  (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<degree p]) /\n                 \\<bar>lead_coeff p\\<bar>\\<rceil>", "by linarith"], ["", "lemma crb_lem_neg: \n  fixes x:: \"real\"\n  fixes p:: \"real poly\"\n  assumes x: \"poly p x = 0\" \n  assumes p: \"p \\<noteq> 0\" \n  shows \"x > -crb p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (- crb p) < x", "using cauchy_root_bound[of p x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>poly p x = 0; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> norm x\n                    \\<le> 1 +\n                          max_list_non_empty\n                           (map (\\<lambda>i. norm (coeff p i))\n                             [0..<degree p]) /\n                          norm (lead_coeff p)\n\ngoal (1 subgoal):\n 1. real_of_int (- crb p) < x", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>poly p x = 0; p \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> \\<bar>x\\<bar>\n                       \\<le> 1 +\n                             max_list_non_empty\n                              (map (\\<lambda>i. \\<bar>coeff p i\\<bar>)\n                                [0..<degree p]) /\n                             \\<bar>lead_coeff p\\<bar>) \\<Longrightarrow>\n    - real_of_int (crb p) < x", "unfolding crb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>poly p x = 0; p \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> \\<bar>x\\<bar>\n                       \\<le> 1 +\n                             max_list_non_empty\n                              (map (\\<lambda>i. \\<bar>coeff p i\\<bar>)\n                                [0..<degree p]) /\n                             \\<bar>lead_coeff p\\<bar>) \\<Longrightarrow>\n    - real_of_int\n       \\<lceil>2 +\n               max_list_non_empty\n                (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n               norm (lead_coeff p)\\<rceil>\n    < x", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>poly p x = 0; p \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> \\<bar>x\\<bar>\n                       \\<le> 1 +\n                             max_list_non_empty\n                              (map (\\<lambda>i. \\<bar>coeff p i\\<bar>)\n                                [0..<degree p]) /\n                             \\<bar>lead_coeff p\\<bar>) \\<Longrightarrow>\n    - real_of_int\n       \\<lceil>2 +\n               max_list_non_empty\n                (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<degree p]) /\n               \\<bar>lead_coeff p\\<bar>\\<rceil>\n    < x", "using p x"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>poly p x = 0; p \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> \\<bar>x\\<bar>\n                       \\<le> 1 +\n                             max_list_non_empty\n                              (map (\\<lambda>i. \\<bar>coeff p i\\<bar>)\n                                [0..<degree p]) /\n                             \\<bar>lead_coeff p\\<bar>) \\<Longrightarrow>\n    - real_of_int\n       \\<lceil>2 +\n               max_list_non_empty\n                (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<degree p]) /\n               \\<bar>lead_coeff p\\<bar>\\<rceil>\n    < x", "by linarith"], ["", "(* Show that the product of the polynomial list is 0 at x iff there is a polynomial \n  in the list that is 0 at x *)"], ["", "lemma prod_zero:\n  shows \"\\<forall>x . poly (prod_list (qs:: rat poly list)) x = 0 \\<longleftrightarrow> (\\<exists>q \\<in> set (qs). poly q x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (poly (prod_list qs) x = 0) = (\\<exists>q\\<in>set qs. poly q x = 0)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (prod_list qs) x = 0 \\<Longrightarrow>\n       \\<exists>q\\<in>set qs. poly q x = 0\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (prod_list qs) x = 0", "using poly_prod_list_zero_iff"], ["proof (prove)\nusing this:\n  (poly (prod_list ?ps) ?x = (0::?'a)) =\n  (\\<exists>p\\<in>set ?ps. poly p ?x = (0::?'a))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       poly (prod_list qs) x = 0 \\<Longrightarrow>\n       \\<exists>q\\<in>set qs. poly q x = 0\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (prod_list qs) x = 0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (prod_list qs) x = 0", "using poly_prod_list_zero_iff"], ["proof (prove)\nusing this:\n  (poly (prod_list ?ps) ?x = (0::?'a)) =\n  (\\<exists>p\\<in>set ?ps. poly p ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; poly q x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (prod_list qs) x = 0", "by blast"], ["", "lemma coprime_r_zero1: \"poly (coprime_r qs) (crb (prod_list qs)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (coprime_r qs) (real_of_int (crb (prod_list qs))) = 0", "by (simp add: coprime_r_def)"], ["", "lemma coprime_r_zero2: \"poly (coprime_r qs) (-crb (prod_list qs)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (coprime_r qs) (real_of_int (- crb (prod_list qs))) = 0", "by (simp add: coprime_r_def)"], ["", "lemma coprime_mult:\n  fixes a:: \"real poly\"\n  fixes b:: \"real poly\"\n  fixes c:: \"real poly\"\n  assumes \"algebraic_semidom_class.coprime a b\"\n  assumes \"algebraic_semidom_class.coprime a c\"\n  shows \"algebraic_semidom_class.coprime a (b*c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime a (b * c)", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime a b\n  algebraic_semidom_class.coprime a c\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime a (b * c)", "by auto"], ["", "(* Will be needed when we call the BKR roots on coprime_r *)"], ["", "lemma coprime_r_coprime_prop:\n  fixes ps:: \"rat poly list\"\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes \"fss = map real_of_rat_poly fs\"\n  shows \"\\<And>f. f \\<in> set fss \\<Longrightarrow> coprime f (coprime_r fss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       comm_monoid_mult_class.coprime f (coprime_r fss)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "fix f:: \"real poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "assume f_in: \"f \\<in> set fss\""], ["proof (state)\nthis:\n  f \\<in> set fss\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "have nonz_prod: \"prod_list fss \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list fss \\<noteq> 0", "using factorize_polys_map_square_free"], ["proof (prove)\nusing this:\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data);\n   ?fss = map real_of_rat_poly ?fs; ?f \\<in> set ?fss\\<rbrakk>\n  \\<Longrightarrow> square_free ?f\n\ngoal (1 subgoal):\n 1. prod_list fss \\<noteq> 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ps fs data fss f.\n                \\<lbrakk>factorize_polys ps = (fs, data);\n                 fss = map real_of_rat_poly fs;\n                 f \\<in> real_of_rat_poly ` set fs\\<rbrakk>\n                \\<Longrightarrow> square_free f;\n     0 \\<in> set fss\\<rbrakk>\n    \\<Longrightarrow> False", "using assms(1) assms(2) square_free_def"], ["proof (prove)\nusing this:\n  factorize_polys ps = (fs, data)\n  fss = map real_of_rat_poly fs\n  square_free ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd ?p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ps fs data fss f.\n                \\<lbrakk>factorize_polys ps = (fs, data);\n                 fss = map real_of_rat_poly fs;\n                 f \\<in> real_of_rat_poly ` set fs\\<rbrakk>\n                \\<Longrightarrow> square_free f;\n     0 \\<in> set fss\\<rbrakk>\n    \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  prod_list fss \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "have nonz_f: \"f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "using f_in factorize_polys_map_square_free"], ["proof (prove)\nusing this:\n  f \\<in> set fss\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data);\n   ?fss = map real_of_rat_poly ?fs; ?f \\<in> set ?fss\\<rbrakk>\n  \\<Longrightarrow> square_free ?f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<in> set fss;\n     \\<And>ps fs data fss f.\n        \\<lbrakk>factorize_polys ps = (fs, data);\n         fss = map real_of_rat_poly fs;\n         f \\<in> real_of_rat_poly ` set fs\\<rbrakk>\n        \\<Longrightarrow> square_free f;\n     f = 0\\<rbrakk>\n    \\<Longrightarrow> False", "using assms(1) assms(2) square_free_def"], ["proof (prove)\nusing this:\n  factorize_polys ps = (fs, data)\n  fss = map real_of_rat_poly fs\n  square_free ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd ?p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<in> set fss;\n     \\<And>ps fs data fss f.\n        \\<lbrakk>factorize_polys ps = (fs, data);\n         fss = map real_of_rat_poly fs;\n         f \\<in> real_of_rat_poly ` set fs\\<rbrakk>\n        \\<Longrightarrow> square_free f;\n     f = 0\\<rbrakk>\n    \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "have copr_pderiv: \"algebraic_semidom_class.coprime f (pderiv (prod_list fss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f (pderiv (prod_list fss))", "using factorize_polys_map_coprime_pderiv"], ["proof (prove)\nusing this:\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data);\n   ?fss = map real_of_rat_poly ?fs; ?f \\<in> set ?fss\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?f\n                     (pderiv (prod_list ?fss))\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f (pderiv (prod_list fss))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps fs data fss f.\n        \\<lbrakk>factorize_polys ps = (fs, data);\n         fss = map real_of_rat_poly fs;\n         f \\<in> real_of_rat_poly ` set fs\\<rbrakk>\n        \\<Longrightarrow> algebraic_semidom_class.coprime f\n                           (pderiv\n                             (real_of_rat_poly\n                               (prod_list fs)))) \\<Longrightarrow>\n    algebraic_semidom_class.coprime f (pderiv (prod_list fss))", "using f_in assms(1) assms(2)"], ["proof (prove)\nusing this:\n  f \\<in> set fss\n  factorize_polys ps = (fs, data)\n  fss = map real_of_rat_poly fs\n\ngoal (1 subgoal):\n 1. (\\<And>ps fs data fss f.\n        \\<lbrakk>factorize_polys ps = (fs, data);\n         fss = map real_of_rat_poly fs;\n         f \\<in> real_of_rat_poly ` set fs\\<rbrakk>\n        \\<Longrightarrow> algebraic_semidom_class.coprime f\n                           (pderiv\n                             (real_of_rat_poly\n                               (prod_list fs)))) \\<Longrightarrow>\n    algebraic_semidom_class.coprime f (pderiv (prod_list fss))", "by auto"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime f (pderiv (prod_list fss))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "have z_iff: \"\\<forall>x. poly f x = 0 \\<longrightarrow> poly (prod_list fss) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. poly f x = 0 \\<longrightarrow> poly (prod_list fss) x = 0", "using f_in"], ["proof (prove)\nusing this:\n  f \\<in> set fss\n\ngoal (1 subgoal):\n 1. \\<forall>x. poly f x = 0 \\<longrightarrow> poly (prod_list fss) x = 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f \\<in> set fss; poly f x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (prod_list fss) x = 0", "using poly_prod_list_zero_iff"], ["proof (prove)\nusing this:\n  (poly (prod_list ?ps) ?x = (0::?'a)) =\n  (\\<exists>p\\<in>set ?ps. poly p ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f \\<in> set fss; poly f x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (prod_list fss) x = 0", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. poly f x = 0 \\<longrightarrow> poly (prod_list fss) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "let ?inf_p = \"[:-(crb (prod_list fss)),1:]::real poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "have copr_inf: \"algebraic_semidom_class.coprime f ([:-(crb (prod_list fss)),1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (- crb (prod_list fss)), 1:]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (- crb (prod_list fss)), 1:]", "have zero_prop: \"\\<forall>x. poly ?inf_p x = 0 \\<longleftrightarrow> x = crb (prod_list fss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (poly [:real_of_int (- crb (prod_list fss)), 1:] x = 0) =\n       (x = real_of_int (crb (prod_list fss)))", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     (poly [:real_of_int (- crb (prod_list fss)), 1:] x = 0) =\n     (x = real_of_int (crb (prod_list fss)))\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (- crb (prod_list fss)), 1:]", "have  \"poly (prod_list fss) (crb (prod_list fss)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list fss) (real_of_int (crb (prod_list fss))) \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (prod_list fss) (real_of_int (crb (prod_list fss))) \\<noteq> 0", "have h: \"\\<forall>x. poly (prod_list fss) x = 0 \\<longrightarrow> x < (crb (prod_list fss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       poly (prod_list fss) x = 0 \\<longrightarrow>\n       x < real_of_int (crb (prod_list fss))", "using nonz_prod crb_lem_pos[where p = \"prod_list fss\"]"], ["proof (prove)\nusing this:\n  prod_list fss \\<noteq> 0\n  \\<lbrakk>poly (prod_list fss) ?x = 0; prod_list fss \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?x < real_of_int (crb (prod_list fss))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       poly (prod_list fss) x = 0 \\<longrightarrow>\n       x < real_of_int (crb (prod_list fss))", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     poly (prod_list fss) x = 0 \\<longrightarrow>\n     x < real_of_int (crb (prod_list fss))\n\ngoal (1 subgoal):\n 1. poly (prod_list fss) (real_of_int (crb (prod_list fss))) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     poly (prod_list fss) x = 0 \\<longrightarrow>\n     x < real_of_int (crb (prod_list fss))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     poly (prod_list fss) x = 0 \\<longrightarrow>\n     x < real_of_int (crb (prod_list fss))\n\ngoal (1 subgoal):\n 1. poly (prod_list fss) (real_of_int (crb (prod_list fss))) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly (prod_list fss) (real_of_int (crb (prod_list fss))) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (prod_list fss) (real_of_int (crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (- crb (prod_list fss)), 1:]", "then"], ["proof (chain)\npicking this:\n  poly (prod_list fss) (real_of_int (crb (prod_list fss))) \\<noteq> 0", "have nonzero: \"poly f (crb (prod_list fss)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly (prod_list fss) (real_of_int (crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly f (real_of_int (crb (prod_list fss))) \\<noteq> 0", "using z_iff"], ["proof (prove)\nusing this:\n  poly (prod_list fss) (real_of_int (crb (prod_list fss))) \\<noteq> 0\n  \\<forall>x. poly f x = 0 \\<longrightarrow> poly (prod_list fss) x = 0\n\ngoal (1 subgoal):\n 1. poly f (real_of_int (crb (prod_list fss))) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly f (real_of_int (crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (- crb (prod_list fss)), 1:]", "then"], ["proof (chain)\npicking this:\n  poly f (real_of_int (crb (prod_list fss))) \\<noteq> 0", "have \"\\<not>(\\<exists>x. poly f x = 0 \\<and> poly ?inf_p x = 0)\""], ["proof (prove)\nusing this:\n  poly f (real_of_int (crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       poly f x = 0 \\<and>\n       poly [:real_of_int (- crb (prod_list fss)), 1:] x = 0", "by simp"], ["proof (state)\nthis:\n  \\<nexists>x.\n     poly f x = 0 \\<and>\n     poly [:real_of_int (- crb (prod_list fss)), 1:] x = 0\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (- crb (prod_list fss)), 1:]", "have is_unit_gcd: \"is_unit (gcd ?inf_p f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (gcd [:real_of_int (- crb (prod_list fss)), 1:] f)", "using prime_elem_imp_gcd_eq  prime_elem_iff_irreducible linear_irreducible_field"], ["proof (prove)\nusing this:\n  prime_elem ?x \\<Longrightarrow>\n  gcd ?x ?y = normalize ?x \\<or> gcd ?x ?y = (1::?'a)\n  prime_elem ?x = irreducible ?x\n  degree ?p = 1 \\<Longrightarrow> irreducible ?p\n\ngoal (1 subgoal):\n 1. is_unit (gcd [:real_of_int (- crb (prod_list fss)), 1:] f)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (- real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "using nonzero"], ["proof (prove)\nusing this:\n  poly f (real_of_int (crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (- real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p;\n     poly f (real_of_int (crb (prod_list fss))) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (- real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "have f1: \"\\<forall>x0. - (x0::real) = - 1 * x0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0. - x0 = - 1 * x0", "by simp"], ["proof (state)\nthis:\n  \\<forall>x0. - x0 = - 1 * x0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p;\n     poly f (real_of_int (crb (prod_list fss))) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (- real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "have \"(1::real) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p;\n     poly f (real_of_int (crb (prod_list fss))) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (- real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "then"], ["proof (chain)\npicking this:\n  1 \\<noteq> 0", "have \"is_unit (gcd (pCons (- 1 * real_of_int (crb (prod_list fss))) 1) f)\""], ["proof (prove)\nusing this:\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit (gcd (pCons (- 1 * real_of_int (crb (prod_list fss))) 1) f)", "using f1"], ["proof (prove)\nusing this:\n  1 \\<noteq> 0\n  \\<forall>x0. - x0 = - 1 * x0\n\ngoal (1 subgoal):\n 1. is_unit (gcd (pCons (- 1 * real_of_int (crb (prod_list fss))) 1) f)", "by (metis (no_types) is_unit_gcd nonzero one_poly_eq_simps(1) poly_eq_0_iff_dvd prime_elem_imp_coprime prime_elem_linear_field_poly)"], ["proof (state)\nthis:\n  is_unit (gcd (pCons (- 1 * real_of_int (crb (prod_list fss))) 1) f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p;\n     poly f (real_of_int (crb (prod_list fss))) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (- real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "then"], ["proof (chain)\npicking this:\n  is_unit (gcd (pCons (- 1 * real_of_int (crb (prod_list fss))) 1) f)", "show \"degree (gcd (pCons (- real_of_int (crb (prod_list fss))) 1) f) = 0\""], ["proof (prove)\nusing this:\n  is_unit (gcd (pCons (- 1 * real_of_int (crb (prod_list fss))) 1) f)\n\ngoal (1 subgoal):\n 1. degree (gcd (pCons (- real_of_int (crb (prod_list fss))) 1) f) = 0", "by simp"], ["proof (state)\nthis:\n  degree (gcd (pCons (- real_of_int (crb (prod_list fss))) 1) f) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_unit (gcd [:real_of_int (- crb (prod_list fss)), 1:] f)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (- crb (prod_list fss)), 1:]", "then"], ["proof (chain)\npicking this:\n  is_unit (gcd [:real_of_int (- crb (prod_list fss)), 1:] f)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_unit (gcd [:real_of_int (- crb (prod_list fss)), 1:] f)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (- crb (prod_list fss)), 1:]", "using is_unit_gcd"], ["proof (prove)\nusing this:\n  is_unit (gcd [:real_of_int (- crb (prod_list fss)), 1:] f)\n  is_unit (gcd [:real_of_int (- crb (prod_list fss)), 1:] f)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (- crb (prod_list fss)), 1:]", "by (metis gcd.commute gcd_eq_1_imp_coprime is_unit_gcd_iff)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime f\n   [:real_of_int (- crb (prod_list fss)), 1:]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime f\n   [:real_of_int (- crb (prod_list fss)), 1:]\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "let ?ninf_p = \"[:(crb (prod_list fss)),1:]::real poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "have copr_neg_inf: \"algebraic_semidom_class.coprime f ([:(crb (prod_list fss)),1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (crb (prod_list fss)), 1:]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (crb (prod_list fss)), 1:]", "have h: \"\\<forall>x. poly f x = 0 \\<longrightarrow> poly (prod_list fss) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. poly f x = 0 \\<longrightarrow> poly (prod_list fss) x = 0", "using f_in"], ["proof (prove)\nusing this:\n  f \\<in> set fss\n\ngoal (1 subgoal):\n 1. \\<forall>x. poly f x = 0 \\<longrightarrow> poly (prod_list fss) x = 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f \\<in> set fss; poly f x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (prod_list fss) x = 0", "using poly_prod_list_zero_iff"], ["proof (prove)\nusing this:\n  (poly (prod_list ?ps) ?x = (0::?'a)) =\n  (\\<exists>p\\<in>set ?ps. poly p ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f \\<in> set fss; poly f x = 0\\<rbrakk>\n       \\<Longrightarrow> poly (prod_list fss) x = 0", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. poly f x = 0 \\<longrightarrow> poly (prod_list fss) x = 0\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (crb (prod_list fss)), 1:]", "have zero_prop: \"\\<forall>x. poly ?ninf_p x = 0 \\<longleftrightarrow> x = -crb (prod_list fss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (poly [:real_of_int (crb (prod_list fss)), 1:] x = 0) =\n       (x = real_of_int (- crb (prod_list fss)))", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     (poly [:real_of_int (crb (prod_list fss)), 1:] x = 0) =\n     (x = real_of_int (- crb (prod_list fss)))\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (crb (prod_list fss)), 1:]", "have  \"poly (prod_list fss) (-crb (prod_list fss)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list fss) (real_of_int (- crb (prod_list fss))) \\<noteq> 0", "proof  -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (prod_list fss) (real_of_int (- crb (prod_list fss))) \\<noteq> 0", "have h: \"\\<forall>x. poly (prod_list fss) x = 0 \\<longrightarrow> x > (-crb (prod_list fss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       poly (prod_list fss) x = 0 \\<longrightarrow>\n       real_of_int (- crb (prod_list fss)) < x", "using nonz_prod crb_lem_neg[where p = \"prod_list fss\"]"], ["proof (prove)\nusing this:\n  prod_list fss \\<noteq> 0\n  \\<lbrakk>poly (prod_list fss) ?x = 0; prod_list fss \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> real_of_int (- crb (prod_list fss)) < ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       poly (prod_list fss) x = 0 \\<longrightarrow>\n       real_of_int (- crb (prod_list fss)) < x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     poly (prod_list fss) x = 0 \\<longrightarrow>\n     real_of_int (- crb (prod_list fss)) < x\n\ngoal (1 subgoal):\n 1. poly (prod_list fss) (real_of_int (- crb (prod_list fss))) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     poly (prod_list fss) x = 0 \\<longrightarrow>\n     real_of_int (- crb (prod_list fss)) < x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     poly (prod_list fss) x = 0 \\<longrightarrow>\n     real_of_int (- crb (prod_list fss)) < x\n\ngoal (1 subgoal):\n 1. poly (prod_list fss) (real_of_int (- crb (prod_list fss))) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly (prod_list fss) (real_of_int (- crb (prod_list fss))) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (prod_list fss) (real_of_int (- crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (crb (prod_list fss)), 1:]", "then"], ["proof (chain)\npicking this:\n  poly (prod_list fss) (real_of_int (- crb (prod_list fss))) \\<noteq> 0", "have nonzero: \"poly f (-crb (prod_list fss)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly (prod_list fss) (real_of_int (- crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0", "using z_iff"], ["proof (prove)\nusing this:\n  poly (prod_list fss) (real_of_int (- crb (prod_list fss))) \\<noteq> 0\n  \\<forall>x. poly f x = 0 \\<longrightarrow> poly (prod_list fss) x = 0\n\ngoal (1 subgoal):\n 1. poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (crb (prod_list fss)), 1:]", "then"], ["proof (chain)\npicking this:\n  poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0", "have \"\\<not>(\\<exists>x. poly f x = 0 \\<and> poly ?ninf_p x = 0)\""], ["proof (prove)\nusing this:\n  poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       poly f x = 0 \\<and>\n       poly [:real_of_int (crb (prod_list fss)), 1:] x = 0", "using zero_prop"], ["proof (prove)\nusing this:\n  poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0\n  \\<forall>x.\n     (poly [:real_of_int (crb (prod_list fss)), 1:] x = 0) =\n     (x = real_of_int (- crb (prod_list fss)))\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       poly f x = 0 \\<and>\n       poly [:real_of_int (crb (prod_list fss)), 1:] x = 0", "by auto"], ["proof (state)\nthis:\n  \\<nexists>x.\n     poly f x = 0 \\<and> poly [:real_of_int (crb (prod_list fss)), 1:] x = 0\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (crb (prod_list fss)), 1:]", "have is_unit_gcd: \"is_unit (gcd ?ninf_p f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (gcd [:real_of_int (crb (prod_list fss)), 1:] f)", "using prime_elem_imp_gcd_eq  prime_elem_iff_irreducible linear_irreducible_field"], ["proof (prove)\nusing this:\n  prime_elem ?x \\<Longrightarrow>\n  gcd ?x ?y = normalize ?x \\<or> gcd ?x ?y = (1::?'a)\n  prime_elem ?x = irreducible ?x\n  degree ?p = 1 \\<Longrightarrow> irreducible ?p\n\ngoal (1 subgoal):\n 1. is_unit (gcd [:real_of_int (crb (prod_list fss)), 1:] f)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "using nonzero"], ["proof (prove)\nusing this:\n  poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p;\n     poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "have f1: \"(1::real) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p;\n     poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "have \"\\<not> pCons (real_of_int (crb (prod_list fss))) 1 dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> pCons (real_of_int (crb (prod_list fss))) 1 dvd f", "using nonzero"], ["proof (prove)\nusing this:\n  poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> pCons (real_of_int (crb (prod_list fss))) 1 dvd f", "by auto"], ["proof (state)\nthis:\n  \\<not> pCons (real_of_int (crb (prod_list fss))) 1 dvd f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                prime_elem x \\<Longrightarrow>\n                gcd x y = normalize x \\<or> gcd x y = (1::?'a);\n     \\<And>p. degree p = Suc 0 \\<Longrightarrow> irreducible p;\n     poly f (real_of_int (- crb (prod_list fss))) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> degree\n                       (gcd (pCons (real_of_int (crb (prod_list fss))) 1)\n                         f) =\n                      0", "then"], ["proof (chain)\npicking this:\n  \\<not> pCons (real_of_int (crb (prod_list fss))) 1 dvd f", "show \"degree (gcd (pCons (real_of_int (crb (prod_list fss))) 1) f) = 0\""], ["proof (prove)\nusing this:\n  \\<not> pCons (real_of_int (crb (prod_list fss))) 1 dvd f\n\ngoal (1 subgoal):\n 1. degree (gcd (pCons (real_of_int (crb (prod_list fss))) 1) f) = 0", "using f1"], ["proof (prove)\nusing this:\n  \\<not> pCons (real_of_int (crb (prod_list fss))) 1 dvd f\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (gcd (pCons (real_of_int (crb (prod_list fss))) 1) f) = 0", "by (metis (no_types) Missing_Polynomial_Factorial.is_unit_field_poly coprime_imp_gcd_eq_1 is_unit_gcd_iff one_poly_eq_simps(1) prime_elem_imp_coprime prime_elem_linear_field_poly)"], ["proof (state)\nthis:\n  degree (gcd (pCons (real_of_int (crb (prod_list fss))) 1) f) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_unit (gcd [:real_of_int (crb (prod_list fss)), 1:] f)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (crb (prod_list fss)), 1:]", "then"], ["proof (chain)\npicking this:\n  is_unit (gcd [:real_of_int (crb (prod_list fss)), 1:] f)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_unit (gcd [:real_of_int (crb (prod_list fss)), 1:] f)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (crb (prod_list fss)), 1:]", "using is_unit_gcd"], ["proof (prove)\nusing this:\n  is_unit (gcd [:real_of_int (crb (prod_list fss)), 1:] f)\n  is_unit (gcd [:real_of_int (crb (prod_list fss)), 1:] f)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     [:real_of_int (crb (prod_list fss)), 1:]", "by (metis gcd.commute gcd_eq_1_imp_coprime is_unit_gcd_iff)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime f [:real_of_int (crb (prod_list fss)), 1:]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime f [:real_of_int (crb (prod_list fss)), 1:]\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set fss \\<Longrightarrow>\n       algebraic_semidom_class.coprime f (coprime_r fss)", "show \"algebraic_semidom_class.coprime f (coprime_r fss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f (coprime_r fss)", "using copr_pderiv coprime_mult"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime f (pderiv (prod_list fss))\n  \\<lbrakk>algebraic_semidom_class.coprime ?a ?b;\n   algebraic_semidom_class.coprime ?a ?c\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime ?a (?b * ?c)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f (coprime_r fss)", "unfolding coprime_r_def"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime f (pderiv (prod_list fss))\n  \\<lbrakk>algebraic_semidom_class.coprime ?a ?b;\n   algebraic_semidom_class.coprime ?a ?c\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime ?a (?b * ?c)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     (pderiv (prod_list fss) * [:real_of_int (- crb (prod_list fss)), 1:] *\n      [:real_of_int (crb (prod_list fss)), 1:])", "using copr_inf copr_neg_inf"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime f (pderiv (prod_list fss))\n  \\<lbrakk>algebraic_semidom_class.coprime ?a ?b;\n   algebraic_semidom_class.coprime ?a ?c\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime ?a (?b * ?c)\n  algebraic_semidom_class.coprime f\n   [:real_of_int (- crb (prod_list fss)), 1:]\n  algebraic_semidom_class.coprime f [:real_of_int (crb (prod_list fss)), 1:]\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime f\n     (pderiv (prod_list fss) * [:real_of_int (- crb (prod_list fss)), 1:] *\n      [:real_of_int (crb (prod_list fss)), 1:])", "by blast"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime f (coprime_r fss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_r_nonzero:\n  fixes ps:: \"rat poly list\"\n  assumes \"factorize_polys ps = (fs,data)\"\n  assumes nonempty_fs: \"fs \\<noteq> []\"\n  assumes fss_is: \"fss = map real_of_rat_poly fs\"\n  shows \"(coprime_r fss) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "have nonempty_fss: \"fss \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fss \\<noteq> []", "using nonempty_fs fss_is"], ["proof (prove)\nusing this:\n  fs \\<noteq> []\n  fss = map real_of_rat_poly fs\n\ngoal (1 subgoal):\n 1. fss \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  fss \\<noteq> []\n\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "have deg_f: \"\\<forall>f \\<in> set (fs). degree f > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set fs. 0 < degree f", "using factorize_polys_irreducible_monic"], ["proof (prove)\nusing this:\n  factorize_polys ?ps = (?fs, ?data) \\<Longrightarrow> distinct ?fs\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data); ?f \\<in> set ?fs\\<rbrakk>\n  \\<Longrightarrow> irreducible ?f \\<and> monic ?f\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set fs. 0 < degree f", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>ps fs data.\n                   factorize_polys ps = (fs, data) \\<Longrightarrow>\n                   distinct fs;\n        \\<And>ps fs data f.\n           \\<lbrakk>factorize_polys ps = (fs, data); f \\<in> set fs\\<rbrakk>\n           \\<Longrightarrow> irreducible f \\<and> monic f;\n        f \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> 0 < degree f", "using assms(1) irreducible_degree_field"], ["proof (prove)\nusing this:\n  factorize_polys ps = (fs, data)\n  irreducible ?p \\<Longrightarrow> 0 < degree ?p\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>ps fs data.\n                   factorize_polys ps = (fs, data) \\<Longrightarrow>\n                   distinct fs;\n        \\<And>ps fs data f.\n           \\<lbrakk>factorize_polys ps = (fs, data); f \\<in> set fs\\<rbrakk>\n           \\<Longrightarrow> irreducible f \\<and> monic f;\n        f \\<in> set fs\\<rbrakk>\n       \\<Longrightarrow> 0 < degree f", "by blast"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set fs. 0 < degree f\n\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>f\\<in>set fs. 0 < degree f", "have deg_fss: \"\\<forall>f \\<in> set (fss). degree f > 0\""], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set fs. 0 < degree f\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set fss. 0 < degree f", "using fss_is"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set fs. 0 < degree f\n  fss = map real_of_rat_poly fs\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set fss. 0 < degree f", "by simp"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set fss. 0 < degree f\n\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>f\\<in>set fss. 0 < degree f", "have fss_nonz: \"\\<forall>f \\<in> set (fss). f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>set fss. 0 < degree f\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>set fss. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>f\\<in>set fss. f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "have \"fss \\<noteq> [] \\<longrightarrow> ((\\<forall>f \\<in> set (fss). (degree f > 0 \\<and> f \\<noteq> 0)) \\<longrightarrow> degree (prod_list fss) > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fss \\<noteq> [] \\<longrightarrow>\n    (\\<forall>f\\<in>set fss.\n        0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n    0 < degree (prod_list fss)", "proof (induct fss)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>f\\<in>set [].\n        0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n    0 < degree (prod_list [])\n 2. \\<And>a fss.\n       fss \\<noteq> [] \\<longrightarrow>\n       (\\<forall>f\\<in>set fss.\n           0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n       0 < degree (prod_list fss) \\<Longrightarrow>\n       a # fss \\<noteq> [] \\<longrightarrow>\n       (\\<forall>f\\<in>set (a # fss).\n           0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n       0 < degree (prod_list (a # fss))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>f\\<in>set [].\n        0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n    0 < degree (prod_list [])\n 2. \\<And>a fss.\n       fss \\<noteq> [] \\<longrightarrow>\n       (\\<forall>f\\<in>set fss.\n           0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n       0 < degree (prod_list fss) \\<Longrightarrow>\n       a # fss \\<noteq> [] \\<longrightarrow>\n       (\\<forall>f\\<in>set (a # fss).\n           0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n       0 < degree (prod_list (a # fss))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>f\\<in>set [].\n        0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n    0 < degree (prod_list [])", "by blast"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  (\\<forall>f\\<in>set [].\n      0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n  0 < degree (prod_list [])\n\ngoal (1 subgoal):\n 1. \\<And>a fss.\n       fss \\<noteq> [] \\<longrightarrow>\n       (\\<forall>f\\<in>set fss.\n           0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n       0 < degree (prod_list fss) \\<Longrightarrow>\n       a # fss \\<noteq> [] \\<longrightarrow>\n       (\\<forall>f\\<in>set (a # fss).\n           0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n       0 < degree (prod_list (a # fss))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a fss.\n       fss \\<noteq> [] \\<longrightarrow>\n       (\\<forall>f\\<in>set fss.\n           0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n       0 < degree (prod_list fss) \\<Longrightarrow>\n       a # fss \\<noteq> [] \\<longrightarrow>\n       (\\<forall>f\\<in>set (a # fss).\n           0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n       0 < degree (prod_list (a # fss))", "case (Cons a fss)"], ["proof (state)\nthis:\n  fss \\<noteq> [] \\<longrightarrow>\n  (\\<forall>f\\<in>set fss.\n      0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n  0 < degree (prod_list fss)\n\ngoal (1 subgoal):\n 1. \\<And>a fss.\n       fss \\<noteq> [] \\<longrightarrow>\n       (\\<forall>f\\<in>set fss.\n           0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n       0 < degree (prod_list fss) \\<Longrightarrow>\n       a # fss \\<noteq> [] \\<longrightarrow>\n       (\\<forall>f\\<in>set (a # fss).\n           0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n       0 < degree (prod_list (a # fss))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # fss \\<noteq> [] \\<longrightarrow>\n    (\\<forall>f\\<in>set (a # fss).\n        0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n    0 < degree (prod_list (a # fss))", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree a; a \\<noteq> 0;\n     \\<forall>f\\<in>set fss. 0 < degree f \\<and> f \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < degree (a * prod_list fss)", "assume z_lt: \"0 < degree a\""], ["proof (state)\nthis:\n  0 < degree a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree a; a \\<noteq> 0;\n     \\<forall>f\\<in>set fss. 0 < degree f \\<and> f \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < degree (a * prod_list fss)", "assume anonz: \"a \\<noteq> 0\""], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree a; a \\<noteq> 0;\n     \\<forall>f\\<in>set fss. 0 < degree f \\<and> f \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < degree (a * prod_list fss)", "assume fnonz: \"\\<forall>f\\<in>set fss. 0 < degree f \\<and> f \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<forall>f\\<in>set fss. 0 < degree f \\<and> f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree a; a \\<noteq> 0;\n     \\<forall>f\\<in>set fss. 0 < degree f \\<and> f \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < degree (a * prod_list fss)", "have h: \"degree (a * prod_list fss) = degree a + degree (prod_list fss) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (a * prod_list fss) = degree a + degree (prod_list fss)", "using degree_mult_eq[where p = \"a\", where q = \"prod_list fss\"] anonz fnonz"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; prod_list fss \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> degree (a * prod_list fss) =\n                    degree a + degree (prod_list fss)\n  a \\<noteq> 0\n  \\<forall>f\\<in>set fss. 0 < degree f \\<and> f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (a * prod_list fss) = degree a + degree (prod_list fss)", "by auto"], ["proof (state)\nthis:\n  degree (a * prod_list fss) = degree a + degree (prod_list fss)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < degree a; a \\<noteq> 0;\n     \\<forall>f\\<in>set fss. 0 < degree f \\<and> f \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> 0 < degree (a * prod_list fss)", "then"], ["proof (chain)\npicking this:\n  degree (a * prod_list fss) = degree a + degree (prod_list fss)", "show \"0 < degree (a * prod_list fss)\""], ["proof (prove)\nusing this:\n  degree (a * prod_list fss) = degree a + degree (prod_list fss)\n\ngoal (1 subgoal):\n 1. 0 < degree (a * prod_list fss)", "using z_lt Cons.hyps"], ["proof (prove)\nusing this:\n  degree (a * prod_list fss) = degree a + degree (prod_list fss)\n  0 < degree a\n  fss \\<noteq> [] \\<longrightarrow>\n  (\\<forall>f\\<in>set fss.\n      0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n  0 < degree (prod_list fss)\n\ngoal (1 subgoal):\n 1. 0 < degree (a * prod_list fss)", "by auto"], ["proof (state)\nthis:\n  0 < degree (a * prod_list fss)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # fss \\<noteq> [] \\<longrightarrow>\n  (\\<forall>f\\<in>set (a # fss).\n      0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n  0 < degree (prod_list (a # fss))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fss \\<noteq> [] \\<longrightarrow>\n  (\\<forall>f\\<in>set fss.\n      0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n  0 < degree (prod_list fss)\n\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  fss \\<noteq> [] \\<longrightarrow>\n  (\\<forall>f\\<in>set fss.\n      0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n  0 < degree (prod_list fss)", "have \"degree (prod_list fss) > 0\""], ["proof (prove)\nusing this:\n  fss \\<noteq> [] \\<longrightarrow>\n  (\\<forall>f\\<in>set fss.\n      0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n  0 < degree (prod_list fss)\n\ngoal (1 subgoal):\n 1. 0 < degree (prod_list fss)", "using nonempty_fss deg_fss fss_nonz"], ["proof (prove)\nusing this:\n  fss \\<noteq> [] \\<longrightarrow>\n  (\\<forall>f\\<in>set fss.\n      0 < degree f \\<and> f \\<noteq> 0) \\<longrightarrow>\n  0 < degree (prod_list fss)\n  fss \\<noteq> []\n  \\<forall>f\\<in>set fss. 0 < degree f\n  \\<forall>f\\<in>set fss. f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree (prod_list fss)", "by auto"], ["proof (state)\nthis:\n  0 < degree (prod_list fss)\n\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  0 < degree (prod_list fss)", "have pderiv_nonzero: \"pderiv (prod_list fss) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree (prod_list fss)\n\ngoal (1 subgoal):\n 1. pderiv (prod_list fss) \\<noteq> 0", "by (simp add: pderiv_eq_0_iff)"], ["proof (state)\nthis:\n  pderiv (prod_list fss) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "have \"(([:-(crb (prod_list fss)),1:]) * ([:(crb (prod_list fss)),1:])) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- crb (prod_list fss), 1:] * [:crb (prod_list fss), 1:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  [:- crb (prod_list fss), 1:] * [:crb (prod_list fss), 1:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  [:- crb (prod_list fss), 1:] * [:crb (prod_list fss), 1:] \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  [:- crb (prod_list fss), 1:] * [:crb (prod_list fss), 1:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "using pderiv_nonzero"], ["proof (prove)\nusing this:\n  [:- crb (prod_list fss), 1:] * [:crb (prod_list fss), 1:] \\<noteq> 0\n  pderiv (prod_list fss) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime_r fss \\<noteq> 0", "unfolding coprime_r_def"], ["proof (prove)\nusing this:\n  [:- crb (prod_list fss), 1:] * [:crb (prod_list fss), 1:] \\<noteq> 0\n  pderiv (prod_list fss) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv (prod_list fss) * [:real_of_int (- crb (prod_list fss)), 1:] *\n    [:real_of_int (crb (prod_list fss)), 1:] \\<noteq>\n    0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pderiv (prod_list fss) \\<noteq> 0;\n     Polynomial.smult (real_of_int (crb (prod_list fss)))\n      (pCons 0 (pderiv (prod_list fss)) -\n       Polynomial.smult (real_of_int (crb (prod_list fss)))\n        (pderiv (prod_list fss))) +\n     pCons 0\n      (pCons 0 (pderiv (prod_list fss)) -\n       Polynomial.smult (real_of_int (crb (prod_list fss)))\n        (pderiv (prod_list fss))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis offset_poly_eq_0_lemma right_minus_eq synthetic_div_unique_lemma)"], ["proof (state)\nthis:\n  coprime_r fss \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Rolle_pderiv:\n  fixes q:: \"real poly\"\n  fixes x1 x2:: \"real\"\n  shows \"(x1 < x2 \\<and> poly q x1 = 0 \\<and> poly q x2 = 0) \\<longrightarrow> (\\<exists>w. x1 < w \\<and> w < x2 \\<and> poly (pderiv q) w = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 < x2 \\<and> poly q x1 = 0 \\<and> poly q x2 = 0 \\<longrightarrow>\n    (\\<exists>w>x1. w < x2 \\<and> poly (pderiv q) w = 0)", "using Rolle_deriv"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < ?b; ?f ?a = ?f ?b; continuous_on {?a..?b} ?f;\n   \\<And>x.\n      \\<lbrakk>?a < x; x < ?b\\<rbrakk>\n      \\<Longrightarrow> (?f has_derivative ?f' x) (at x)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z>?a. z < ?b \\<and> ?f' z = (\\<lambda>v. 0)\n\ngoal (1 subgoal):\n 1. x1 < x2 \\<and> poly q x1 = 0 \\<and> poly q x2 = 0 \\<longrightarrow>\n    (\\<exists>w>x1. w < x2 \\<and> poly (pderiv q) w = 0)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a b f f'.\n                \\<lbrakk>a < b; f a = f b; continuous_on {a..b} f;\n                 \\<And>x.\n                    \\<lbrakk>a < x; x < b\\<rbrakk>\n                    \\<Longrightarrow> (f has_derivative f' x)\n (at x)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>z>a.\n                                     z < b \\<and> f' z = (\\<lambda>v. 0);\n     x1 < x2; poly q x1 = 0; poly q x2 = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w>x1. w < x2 \\<and> poly (pderiv q) w = 0", "by (metis DERIV_unique Rolle continuous_at_imp_continuous_on poly_DERIV poly_differentiable poly_isCont)"], ["", "lemma coprime_r_roots_prop: \n  fixes qs:: \"real poly list\"\n  assumes pairwise_rel_prime: \"\\<forall>q1 q2. (q1 \\<noteq> q2 \\<and> (List.member qs q1) \\<and> (List.member qs q2))\\<longrightarrow> coprime q1 q2\"\n  shows \"\\<forall>x1. \\<forall>x2. ((x1 < x2 \\<and> (\\<exists>q1 \\<in> set (qs). (poly q1 x1) = 0) \\<and> (\\<exists>q2\\<in> set(qs). (poly q2 x2) = 0)) \\<longrightarrow> (\\<exists>q. x1 < q \\<and> q < x2 \\<and> poly (coprime_r qs) q = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x1 x2.\n       x1 < x2 \\<and>\n       (\\<exists>q1\\<in>set qs. poly q1 x1 = 0) \\<and>\n       (\\<exists>q2\\<in>set qs. poly q2 x2 = 0) \\<longrightarrow>\n       (\\<exists>q>x1. q < x2 \\<and> poly (coprime_r qs) q = 0)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "fix x1:: \"real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "fix x2:: \"real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "fix q1:: \"real poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "fix q2:: \"real poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "assume \"x1 < x2\""], ["proof (state)\nthis:\n  x1 < x2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "assume q1_in: \"q1 \\<in> set qs\""], ["proof (state)\nthis:\n  q1 \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "assume q1_0: \"poly q1 x1 = 0\""], ["proof (state)\nthis:\n  poly q1 x1 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "assume q2_in: \"q2 \\<in> set qs\""], ["proof (state)\nthis:\n  q2 \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "assume q2_0: \"poly q2 x2 = 0\""], ["proof (state)\nthis:\n  poly q2 x2 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "have prod_z_x1: \"poly (prod_list qs) x1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list qs) x1 = 0", "using q1_in q1_0"], ["proof (prove)\nusing this:\n  q1 \\<in> set qs\n  poly q1 x1 = 0\n\ngoal (1 subgoal):\n 1. poly (prod_list qs) x1 = 0", "using poly_prod_list_zero_iff"], ["proof (prove)\nusing this:\n  q1 \\<in> set qs\n  poly q1 x1 = 0\n  (poly (prod_list ?ps) ?x = (0::?'a)) =\n  (\\<exists>p\\<in>set ?ps. poly p ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. poly (prod_list qs) x1 = 0", "by blast"], ["proof (state)\nthis:\n  poly (prod_list qs) x1 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "have prod_z_x2: \"poly (prod_list qs) x2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (prod_list qs) x2 = 0", "using q2_in q2_0"], ["proof (prove)\nusing this:\n  q2 \\<in> set qs\n  poly q2 x2 = 0\n\ngoal (1 subgoal):\n 1. poly (prod_list qs) x2 = 0", "using poly_prod_list_zero_iff"], ["proof (prove)\nusing this:\n  q2 \\<in> set qs\n  poly q2 x2 = 0\n  (poly (prod_list ?ps) ?x = (0::?'a)) =\n  (\\<exists>p\\<in>set ?ps. poly p ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. poly (prod_list qs) x2 = 0", "by blast"], ["proof (state)\nthis:\n  poly (prod_list qs) x2 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "have \"\\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0", "using Rolle_pderiv[where q = \"prod_list qs\"] prod_z_x1 prod_z_x2"], ["proof (prove)\nusing this:\n  ?x1.0 < ?x2.0 \\<and>\n  poly (prod_list qs) ?x1.0 = 0 \\<and>\n  poly (prod_list qs) ?x2.0 = 0 \\<longrightarrow>\n  (\\<exists>w>?x1.0. w < ?x2.0 \\<and> poly (pderiv (prod_list qs)) w = 0)\n  poly (prod_list qs) x1 = 0\n  poly (prod_list qs) x2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0", "using \\<open>x1 < x2\\<close>"], ["proof (prove)\nusing this:\n  ?x1.0 < ?x2.0 \\<and>\n  poly (prod_list qs) ?x1.0 = 0 \\<and>\n  poly (prod_list qs) ?x2.0 = 0 \\<longrightarrow>\n  (\\<exists>w>?x1.0. w < ?x2.0 \\<and> poly (pderiv (prod_list qs)) w = 0)\n  poly (prod_list qs) x1 = 0\n  poly (prod_list qs) x2 = 0\n  x1 < x2\n\ngoal (1 subgoal):\n 1. \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0", "obtain w where w_def: \"w > x1 \\<and>w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0\""], ["proof (prove)\nusing this:\n  \\<exists>w>x1. w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        x1 < w \\<and>\n        w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "then"], ["proof (chain)\npicking this:\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0", "have \"poly (coprime_r qs) w = 0\""], ["proof (prove)\nusing this:\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0\n\ngoal (1 subgoal):\n 1. poly (coprime_r qs) w = 0", "unfolding coprime_r_def"], ["proof (prove)\nusing this:\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0\n\ngoal (1 subgoal):\n 1. poly\n     (pderiv (prod_list qs) * [:real_of_int (- crb (prod_list qs)), 1:] *\n      [:real_of_int (crb (prod_list qs)), 1:])\n     w =\n    0", "by simp"], ["proof (state)\nthis:\n  poly (coprime_r qs) w = 0\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 q2.\n       \\<lbrakk>x1 < x2; q1 \\<in> set qs; poly q1 x1 = 0; q2 \\<in> set qs;\n        poly q2 x2 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q>x1.\n                            q < x2 \\<and> poly (coprime_r qs) q = 0", "then"], ["proof (chain)\npicking this:\n  poly (coprime_r qs) w = 0", "show \"\\<exists>q>x1. q < x2 \\<and> poly (coprime_r qs) q = 0\""], ["proof (prove)\nusing this:\n  poly (coprime_r qs) w = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q>x1. q < x2 \\<and> poly (coprime_r qs) q = 0", "using w_def"], ["proof (prove)\nusing this:\n  poly (coprime_r qs) w = 0\n  x1 < w \\<and> w < x2 \\<and> poly (pderiv (prod_list qs)) w = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q>x1. q < x2 \\<and> poly (coprime_r qs) q = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>q>x1. q < x2 \\<and> poly (coprime_r qs) q = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Setting Up the Procedure: Lemmas\""], ["", "definition has_no_zeros::\"rat list \\<Rightarrow> bool\"\n  where \"has_no_zeros l = (0 \\<notin> set l)\""], ["", "lemma hnz_prop: \"has_no_zeros l \\<longleftrightarrow> \\<not>(\\<exists>k < length l. l ! k = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_no_zeros l = (\\<not> (\\<exists>k<length l. l ! k = 0))", "unfolding has_no_zeros_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<notin> set l) = (\\<not> (\\<exists>k<length l. l ! k = 0))", "by (simp add: in_set_conv_nth)"], ["", "definition cast_rat_list:: \"rat poly list \\<Rightarrow> real poly list\"\n  where \"cast_rat_list qs = map real_of_rat_poly qs\""], ["", "definition consistent_sign_vectors_r::\"real poly list \\<Rightarrow> real set \\<Rightarrow> rat list set\"\n  where \"consistent_sign_vectors_r qs S = (signs_at qs) ` S\""], ["", "lemma consistent_sign_vectors_consistent_sign_vectors_r:\n  shows\"consistent_sign_vectors_r (cast_rat_list qs) S = consistent_sign_vectors qs S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_sign_vectors_r (cast_rat_list qs) S =\n    consistent_sign_vectors qs S", "unfolding consistent_sign_vectors_r_def cast_rat_list_def consistent_sign_vectors_def\n    sign_vec_def signs_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        map (squash \\<circ> (\\<lambda>q. poly q x))\n         (map real_of_rat_poly qs)) `\n    S =\n    (\\<lambda>x. map (squash \\<circ> (\\<lambda>p. rpoly p x)) qs) ` S", "by auto"], ["", "(* Relies on coprime_rat_poly_real_poly *)"], ["", "lemma coprime_over_reals_coprime_over_rats:\n  fixes qs:: \"rat poly list\"\n  assumes csa_in: \"csa \\<in> (consistent_sign_vectors qs UNIV)\"\n  assumes p1p2: \"p1\\<noteq>p2 \\<and> p1 < length csa \\<and> p2 < length csa \\<and> csa ! p1 = 0 \\<and> csa ! p2 = 0\"\n  shows \"\\<not> algebraic_semidom_class.coprime (nth qs p1) (nth qs p2) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime (qs ! p1) (qs ! p2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime (qs ! p1) (qs ! p2)", "have isx: \"\\<exists>(x::real). csa = (sign_vec qs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. csa = sign_vec qs x", "using csa_in"], ["proof (prove)\nusing this:\n  csa \\<in> consistent_sign_vectors qs UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>x. csa = sign_vec qs x", "unfolding consistent_sign_vectors_def"], ["proof (prove)\nusing this:\n  csa \\<in> range (sign_vec qs)\n\ngoal (1 subgoal):\n 1. \\<exists>x. csa = sign_vec qs x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. csa = sign_vec qs x\n\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime (qs ! p1) (qs ! p2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. csa = sign_vec qs x", "obtain x where havex: \"csa = (sign_vec qs x)\""], ["proof (prove)\nusing this:\n  \\<exists>x. csa = sign_vec qs x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        csa = sign_vec qs x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  csa = sign_vec qs x\n\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime (qs ! p1) (qs ! p2)", "then"], ["proof (chain)\npicking this:\n  csa = sign_vec qs x", "have expolys: \"poly (real_of_rat_poly (nth qs p1)) x = 0 \\<and> poly (real_of_rat_poly (nth qs p2)) x = 0\""], ["proof (prove)\nusing this:\n  csa = sign_vec qs x\n\ngoal (1 subgoal):\n 1. rpoly (qs ! p1) x = 0 \\<and> rpoly (qs ! p2) x = 0", "using havex"], ["proof (prove)\nusing this:\n  csa = sign_vec qs x\n  csa = sign_vec qs x\n\ngoal (1 subgoal):\n 1. rpoly (qs ! p1) x = 0 \\<and> rpoly (qs ! p2) x = 0", "unfolding sign_vec_def squash_def"], ["proof (prove)\nusing this:\n  csa =\n  map ((\\<lambda>x. if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n       (\\<lambda>p. rpoly p x))\n   qs\n  csa =\n  map ((\\<lambda>x. if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n       (\\<lambda>p. rpoly p x))\n   qs\n\ngoal (1 subgoal):\n 1. rpoly (qs ! p1) x = 0 \\<and> rpoly (qs ! p2) x = 0", "by (smt class_field.neg_1_not_0 length_map map_map nth_map one_neq_zero p1p2)"], ["proof (state)\nthis:\n  rpoly (qs ! p1) x = 0 \\<and> rpoly (qs ! p2) x = 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime (qs ! p1) (qs ! p2)", "then"], ["proof (chain)\npicking this:\n  rpoly (qs ! p1) x = 0 \\<and> rpoly (qs ! p2) x = 0", "have \"\\<not> coprime (real_of_rat_poly (nth qs p1)) ((real_of_rat_poly (nth qs p2))::real poly)\""], ["proof (prove)\nusing this:\n  rpoly (qs ! p1) x = 0 \\<and> rpoly (qs ! p2) x = 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (real_of_rat_poly (qs ! p1))\n            (real_of_rat_poly (qs ! p2))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rpoly (qs ! p1) x = 0; rpoly (qs ! p2) x = 0;\n     algebraic_semidom_class.coprime (real_of_rat_poly (qs ! p1))\n      (real_of_rat_poly (qs ! p2))\\<rbrakk>\n    \\<Longrightarrow> False", "using coprime_poly_0"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rpoly (qs ! p1) x = 0; rpoly (qs ! p2) x = 0;\n     algebraic_semidom_class.coprime (real_of_rat_poly (qs ! p1))\n      (real_of_rat_poly (qs ! p2))\\<rbrakk>\n    \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime (real_of_rat_poly (qs ! p1))\n          (real_of_rat_poly (qs ! p2))\n\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime (qs ! p1) (qs ! p2)", "then"], ["proof (chain)\npicking this:\n  \\<not> comm_monoid_mult_class.coprime (real_of_rat_poly (qs ! p1))\n          (real_of_rat_poly (qs ! p2))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> comm_monoid_mult_class.coprime (real_of_rat_poly (qs ! p1))\n          (real_of_rat_poly (qs ! p2))\n\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime (qs ! p1) (qs ! p2)", "using coprime_rat_poly_real_poly"], ["proof (prove)\nusing this:\n  \\<not> comm_monoid_mult_class.coprime (real_of_rat_poly (qs ! p1))\n          (real_of_rat_poly (qs ! p2))\n  comm_monoid_mult_class.coprime ?p ?q \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (real_of_rat_poly ?p) (real_of_rat_poly ?q)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic_semidom_class.coprime (qs ! p1) (qs ! p2)", "by auto"], ["proof (state)\nthis:\n  \\<not> algebraic_semidom_class.coprime (qs ! p1) (qs ! p2)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* This and the following lemma are designed to show that if you have two sgas that aren't the same, \n   there's a 0 in between! The proof uses IVT. It hones in on the component that's changed sign \n   (either from 1 to {0, -1} or from -1 to {0, 1}) *)"], ["", "lemma zero_above: \n  fixes qs:: \"rat poly list\"\n  fixes x1:: \"real\"\n  assumes hnz: \"has_no_zeros (sign_vec qs x1)\"\n  shows \"(\\<forall> x2 > x1. ((sign_vec qs x1) \\<noteq> (sign_vec qs x2)) \\<longrightarrow> \n  (\\<exists>(r::real) > x1. (r \\<le> x2 \\<and> (\\<exists> q \\<in> set(qs). rpoly q r = 0))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x2>x1.\n       sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n       (\\<exists>r>x1.\n           r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "fix x2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "assume x1_lt: \"x1 < x2\""], ["proof (state)\nthis:\n  x1 < x2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "assume diff_sign_vec: \"sign_vec qs x1 \\<noteq> sign_vec qs x2\""], ["proof (state)\nthis:\n  sign_vec qs x1 \\<noteq> sign_vec qs x2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "then"], ["proof (chain)\npicking this:\n  sign_vec qs x1 \\<noteq> sign_vec qs x2", "have \"\\<exists>q \\<in> set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\""], ["proof (prove)\nusing this:\n  sign_vec qs x1 \\<noteq> sign_vec qs x2\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)", "unfolding sign_vec_def"], ["proof (prove)\nusing this:\n  map (squash \\<circ> (\\<lambda>p. rpoly p x1)) qs \\<noteq>\n  map (squash \\<circ> (\\<lambda>p. rpoly p x2)) qs\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)", "by simp"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "then"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)", "obtain q where q_prop: \"q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> set qs \\<and>\n        squash (rpoly q x1) \\<noteq> squash (rpoly q x2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "then"], ["proof (chain)\npicking this:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)", "have q_in: \"q \\<in> set qs\""], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. q \\<in> set qs", "by auto"], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have poss1: \"squash (rpoly q x1) = -1 \\<and> squash (rpoly q x2) = 1 \\<longrightarrow> (\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = - 1 \\<and>\n    squash (rpoly q x2) = 1 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using poly_IVT_pos[of x1 x2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x1 < x2; poly ?p x1 < 0; 0 < poly ?p x2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x1. x < x2 \\<and> poly ?p x = 0\n\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = - 1 \\<and>\n    squash (rpoly q x2) = 1 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using x1_lt"], ["proof (prove)\nusing this:\n  \\<lbrakk>x1 < x2; poly ?p x1 < 0; 0 < poly ?p x2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x1. x < x2 \\<and> poly ?p x = 0\n  x1 < x2\n\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = - 1 \\<and>\n    squash (rpoly q x2) = 1 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "unfolding squash_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>x1 < x2; poly ?p x1 < 0; 0 < poly ?p x2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x1. x < x2 \\<and> poly ?p x = 0\n  x1 < x2\n\ngoal (1 subgoal):\n 1. (if 0 < rpoly q x1 then 1 else if rpoly q x1 < 0 then - 1 else 0) =\n    - 1 \\<and>\n    (if 0 < rpoly q x2 then 1 else if rpoly q x2 < 0 then - 1 else 0) =\n    1 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                \\<lbrakk>poly p x1 < 0; 0 < poly p x2\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x>x1. x < x2 \\<and> poly p x = 0;\n     x1 < x2; rpoly q x1 < 0; 0 < rpoly q x2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r>x1.\n                         r \\<le> x2 \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "using q_prop"], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                \\<lbrakk>poly p x1 < 0; 0 < poly p x2\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x>x1. x < x2 \\<and> poly p x = 0;\n     x1 < x2; rpoly q x1 < 0; 0 < rpoly q x2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r>x1.\n                         r \\<le> x2 \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "by fastforce"], ["proof (state)\nthis:\n  squash (rpoly q x1) = - 1 \\<and> squash (rpoly q x2) = 1 \\<longrightarrow>\n  (\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have poss2: \"squash (rpoly q x1) = 1 \\<and> squash (rpoly q x2) = -1 \\<longrightarrow> (\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = 1 \\<and>\n    squash (rpoly q x2) = - 1 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using poly_IVT_neg[of x1 x2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x1 < x2; 0 < poly ?p x1; poly ?p x2 < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x1. x < x2 \\<and> poly ?p x = 0\n\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = 1 \\<and>\n    squash (rpoly q x2) = - 1 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using x1_lt"], ["proof (prove)\nusing this:\n  \\<lbrakk>x1 < x2; 0 < poly ?p x1; poly ?p x2 < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x1. x < x2 \\<and> poly ?p x = 0\n  x1 < x2\n\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = 1 \\<and>\n    squash (rpoly q x2) = - 1 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "unfolding squash_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>x1 < x2; 0 < poly ?p x1; poly ?p x2 < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x1. x < x2 \\<and> poly ?p x = 0\n  x1 < x2\n\ngoal (1 subgoal):\n 1. (if 0 < rpoly q x1 then 1 else if rpoly q x1 < 0 then - 1 else 0) =\n    1 \\<and>\n    (if 0 < rpoly q x2 then 1 else if rpoly q x2 < 0 then - 1 else 0) =\n    - 1 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                \\<lbrakk>0 < poly p x1; poly p x2 < 0\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x>x1. x < x2 \\<and> poly p x = 0;\n     x1 < x2; 0 < rpoly q x1; rpoly q x2 < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r>x1.\n                         r \\<le> x2 \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "using q_prop"], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                \\<lbrakk>0 < poly p x1; poly p x2 < 0\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x>x1. x < x2 \\<and> poly p x = 0;\n     x1 < x2; 0 < rpoly q x1; rpoly q x2 < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r>x1.\n                         r \\<le> x2 \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "by fastforce"], ["proof (state)\nthis:\n  squash (rpoly q x1) = 1 \\<and> squash (rpoly q x2) = - 1 \\<longrightarrow>\n  (\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have poss3: \"squash (rpoly q x2) = 0 \\<longrightarrow> (\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (rpoly q x2) = 0 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using x1_lt"], ["proof (prove)\nusing this:\n  x1 < x2\n\ngoal (1 subgoal):\n 1. squash (rpoly q x2) = 0 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "unfolding squash_def"], ["proof (prove)\nusing this:\n  x1 < x2\n\ngoal (1 subgoal):\n 1. (if 0 < rpoly q x2 then 1 else if rpoly q x2 < 0 then - 1 else 0) =\n    0 \\<longrightarrow>\n    (\\<exists>r>x1.\n        r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x1 < x2; rpoly q x2 = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r>x1.\n                         r \\<le> x2 \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "using q_prop"], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x1 < x2; rpoly q x2 = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r>x1.\n                         r \\<le> x2 \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "by blast"], ["proof (state)\nthis:\n  squash (rpoly q x2) = 0 \\<longrightarrow>\n  (\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have \"(q \\<in> set qs \\<and> rpoly q x1 = 0) \\<longrightarrow> \\<not>has_no_zeros (sign_vec qs x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set qs \\<and> rpoly q x1 = 0 \\<longrightarrow>\n    \\<not> has_no_zeros (sign_vec qs x1)", "unfolding has_no_zeros_def sign_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set qs \\<and> rpoly q x1 = 0 \\<longrightarrow>\n    \\<not> 0 \\<notin> set (map (squash \\<circ> (\\<lambda>p. rpoly p x1)) qs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> set qs; rpoly q x1 = 0\\<rbrakk>\n    \\<Longrightarrow> 0 \\<in> (\\<lambda>x. squash (rpoly x x1)) ` set qs", "by (smt image_iff squash_def)"], ["proof (state)\nthis:\n  q \\<in> set qs \\<and> rpoly q x1 = 0 \\<longrightarrow>\n  \\<not> has_no_zeros (sign_vec qs x1)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have not_poss4: \"squash (rpoly q x1) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (rpoly q x1) \\<noteq> 0", "using hnz q_in"], ["proof (prove)\nusing this:\n  has_no_zeros (sign_vec qs x1)\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. squash (rpoly q x1) \\<noteq> 0", "unfolding squash_def"], ["proof (prove)\nusing this:\n  has_no_zeros (sign_vec qs x1)\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. (if 0 < rpoly q x1 then 1\n     else if rpoly q x1 < 0 then - 1 else 0) \\<noteq>\n    0", "using \\<open>q \\<in> set qs \\<and> rpoly q x1 = 0 \\<longrightarrow> \\<not> has_no_zeros (sign_vec qs x1)\\<close>"], ["proof (prove)\nusing this:\n  has_no_zeros (sign_vec qs x1)\n  q \\<in> set qs\n  q \\<in> set qs \\<and> rpoly q x1 = 0 \\<longrightarrow>\n  \\<not> has_no_zeros (sign_vec qs x1)\n\ngoal (1 subgoal):\n 1. (if 0 < rpoly q x1 then 1\n     else if rpoly q x1 < 0 then - 1 else 0) \\<noteq>\n    0", "by auto"], ["proof (state)\nthis:\n  squash (rpoly q x1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x1 < x2; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r>x1.\n                            r \\<le> x2 \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "then"], ["proof (chain)\npicking this:\n  squash (rpoly q x1) \\<noteq> 0", "show \"\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\""], ["proof (prove)\nusing this:\n  squash (rpoly q x1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)", "using q_prop poss1 poss2 poss3 not_poss4"], ["proof (prove)\nusing this:\n  squash (rpoly q x1) \\<noteq> 0\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n  squash (rpoly q x1) = - 1 \\<and> squash (rpoly q x2) = 1 \\<longrightarrow>\n  (\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  squash (rpoly q x1) = 1 \\<and> squash (rpoly q x2) = - 1 \\<longrightarrow>\n  (\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  squash (rpoly q x2) = 0 \\<longrightarrow>\n  (\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  squash (rpoly q x1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)", "apply (auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<le>x2.\n        x1 < r \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x1) \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x1) = 1\n 2. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<le>x2.\n        x1 < r \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x1) \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1\n 3. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<le>x2.\n        x1 < r \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x1) = 1\n 4. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<le>x2.\n        x1 < r \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1", "apply (meson squash_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<le>x2.\n        x1 < r \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x1) \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1\n 2. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<le>x2.\n        x1 < r \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x1) = 1\n 3. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<le>x2.\n        x1 < r \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1", "apply (metis squash_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<le>x2.\n        x1 < r \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x1) = 1\n 2. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<le>x2.\n        x1 < r \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1", "apply (metis squash_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<le>x2.\n        x1 < r \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1", "by (meson squash_def)"], ["proof (state)\nthis:\n  \\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_below: \n  fixes qs:: \"rat poly list\"\n  fixes x1:: \"real\"\n  assumes hnz: \"has_no_zeros (sign_vec qs x1)\"\n  shows \"\\<forall>x2 < x1. ((sign_vec qs x1) \\<noteq> (sign_vec qs x2)) \\<longrightarrow> \n  (\\<exists>(r::real) < x1. (r \\<ge> x2 \\<and> (\\<exists> q \\<in> set(qs). rpoly q r = 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x2<x1.\n       sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n       (\\<exists>r<x1.\n           x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "fix x2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "assume x1_gt: \"x2 < x1\""], ["proof (state)\nthis:\n  x2 < x1\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "assume diff_sign_vec: \"sign_vec qs x1 \\<noteq> sign_vec qs x2\""], ["proof (state)\nthis:\n  sign_vec qs x1 \\<noteq> sign_vec qs x2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "then"], ["proof (chain)\npicking this:\n  sign_vec qs x1 \\<noteq> sign_vec qs x2", "have \"\\<exists>q \\<in> set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\""], ["proof (prove)\nusing this:\n  sign_vec qs x1 \\<noteq> sign_vec qs x2\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)", "unfolding sign_vec_def"], ["proof (prove)\nusing this:\n  map (squash \\<circ> (\\<lambda>p. rpoly p x1)) qs \\<noteq>\n  map (squash \\<circ> (\\<lambda>p. rpoly p x2)) qs\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)", "by simp"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "then"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)", "obtain q where q_prop: \"q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>set qs. squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> set qs \\<and>\n        squash (rpoly q x1) \\<noteq> squash (rpoly q x2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "then"], ["proof (chain)\npicking this:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)", "have q_in: \"q \\<in> set qs\""], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. q \\<in> set qs", "by auto"], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have poss1: \"squash (rpoly q x1) = -1 \\<and> squash (rpoly q x2) = 1 \\<longrightarrow> (\\<exists>r<x1. (r \\<ge> x2 \\<and> (\\<exists> q \\<in> set(qs). rpoly q r = 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = - 1 \\<and>\n    squash (rpoly q x2) = 1 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using poly_IVT_neg[of x2 x1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x2 < x1; 0 < poly ?p x2; poly ?p x1 < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x2. x < x1 \\<and> poly ?p x = 0\n\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = - 1 \\<and>\n    squash (rpoly q x2) = 1 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using x1_gt"], ["proof (prove)\nusing this:\n  \\<lbrakk>x2 < x1; 0 < poly ?p x2; poly ?p x1 < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x2. x < x1 \\<and> poly ?p x = 0\n  x2 < x1\n\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = - 1 \\<and>\n    squash (rpoly q x2) = 1 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "unfolding squash_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>x2 < x1; 0 < poly ?p x2; poly ?p x1 < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x2. x < x1 \\<and> poly ?p x = 0\n  x2 < x1\n\ngoal (1 subgoal):\n 1. (if 0 < rpoly q x1 then 1 else if rpoly q x1 < 0 then - 1 else 0) =\n    - 1 \\<and>\n    (if 0 < rpoly q x2 then 1 else if rpoly q x2 < 0 then - 1 else 0) =\n    1 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                \\<lbrakk>0 < poly p x2; poly p x1 < 0\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x>x2. x < x1 \\<and> poly p x = 0;\n     x2 < x1; rpoly q x1 < 0; 0 < rpoly q x2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r<x1.\n                         x2 \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "using q_prop"], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                \\<lbrakk>0 < poly p x2; poly p x1 < 0\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x>x2. x < x1 \\<and> poly p x = 0;\n     x2 < x1; rpoly q x1 < 0; 0 < rpoly q x2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r<x1.\n                         x2 \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "by fastforce"], ["proof (state)\nthis:\n  squash (rpoly q x1) = - 1 \\<and> squash (rpoly q x2) = 1 \\<longrightarrow>\n  (\\<exists>r<x1. x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have poss2: \"squash (rpoly q x1) = 1 \\<and> squash (rpoly q x2) = -1 \\<longrightarrow> (\\<exists>r<x1. (r \\<ge> x2 \\<and> (\\<exists> q \\<in> set(qs). rpoly q r = 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = 1 \\<and>\n    squash (rpoly q x2) = - 1 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using poly_IVT_pos[of x2 x1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x2 < x1; poly ?p x2 < 0; 0 < poly ?p x1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x2. x < x1 \\<and> poly ?p x = 0\n\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = 1 \\<and>\n    squash (rpoly q x2) = - 1 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using x1_gt"], ["proof (prove)\nusing this:\n  \\<lbrakk>x2 < x1; poly ?p x2 < 0; 0 < poly ?p x1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x2. x < x1 \\<and> poly ?p x = 0\n  x2 < x1\n\ngoal (1 subgoal):\n 1. squash (rpoly q x1) = 1 \\<and>\n    squash (rpoly q x2) = - 1 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "unfolding squash_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>x2 < x1; poly ?p x2 < 0; 0 < poly ?p x1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>x2. x < x1 \\<and> poly ?p x = 0\n  x2 < x1\n\ngoal (1 subgoal):\n 1. (if 0 < rpoly q x1 then 1 else if rpoly q x1 < 0 then - 1 else 0) =\n    1 \\<and>\n    (if 0 < rpoly q x2 then 1 else if rpoly q x2 < 0 then - 1 else 0) =\n    - 1 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                \\<lbrakk>poly p x2 < 0; 0 < poly p x1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x>x2. x < x1 \\<and> poly p x = 0;\n     x2 < x1; 0 < rpoly q x1; rpoly q x2 < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r<x1.\n                         x2 \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "using q_prop"], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                \\<lbrakk>poly p x2 < 0; 0 < poly p x1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x>x2. x < x1 \\<and> poly p x = 0;\n     x2 < x1; 0 < rpoly q x1; rpoly q x2 < 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r<x1.\n                         x2 \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "by fastforce"], ["proof (state)\nthis:\n  squash (rpoly q x1) = 1 \\<and> squash (rpoly q x2) = - 1 \\<longrightarrow>\n  (\\<exists>r<x1. x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have poss3: \"squash (rpoly q x2) = 0 \\<longrightarrow> (\\<exists>r<x1. (r \\<ge> x2 \\<and> (\\<exists> q \\<in> set(qs). rpoly q r = 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (rpoly q x2) = 0 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using x1_gt"], ["proof (prove)\nusing this:\n  x2 < x1\n\ngoal (1 subgoal):\n 1. squash (rpoly q x2) = 0 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "unfolding squash_def"], ["proof (prove)\nusing this:\n  x2 < x1\n\ngoal (1 subgoal):\n 1. (if 0 < rpoly q x2 then 1 else if rpoly q x2 < 0 then - 1 else 0) =\n    0 \\<longrightarrow>\n    (\\<exists>r<x1.\n        x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x2 < x1; rpoly q x2 = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r<x1.\n                         x2 \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "using q_prop"], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x2 < x1; rpoly q x2 = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r<x1.\n                         x2 \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "by blast"], ["proof (state)\nthis:\n  squash (rpoly q x2) = 0 \\<longrightarrow>\n  (\\<exists>r<x1. x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have \"(q \\<in> set qs \\<and> rpoly q x1 = 0) \\<longrightarrow> \\<not>has_no_zeros (sign_vec qs x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set qs \\<and> rpoly q x1 = 0 \\<longrightarrow>\n    \\<not> has_no_zeros (sign_vec qs x1)", "unfolding has_no_zeros_def sign_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set qs \\<and> rpoly q x1 = 0 \\<longrightarrow>\n    \\<not> 0 \\<notin> set (map (squash \\<circ> (\\<lambda>p. rpoly p x1)) qs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> set qs; rpoly q x1 = 0\\<rbrakk>\n    \\<Longrightarrow> 0 \\<in> (\\<lambda>x. squash (rpoly x x1)) ` set qs", "using image_iff squash_def"], ["proof (prove)\nusing this:\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  squash ?x =\n  (if (0::?'a) < ?x then 1 else if ?x < (0::?'a) then - 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> set qs; rpoly q x1 = 0\\<rbrakk>\n    \\<Longrightarrow> 0 \\<in> (\\<lambda>x. squash (rpoly x x1)) ` set qs", "by (smt image_iff squash_def)"], ["proof (state)\nthis:\n  q \\<in> set qs \\<and> rpoly q x1 = 0 \\<longrightarrow>\n  \\<not> has_no_zeros (sign_vec qs x1)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have not_poss4: \"squash (rpoly q x1) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squash (rpoly q x1) \\<noteq> 0", "using hnz q_in"], ["proof (prove)\nusing this:\n  has_no_zeros (sign_vec qs x1)\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. squash (rpoly q x1) \\<noteq> 0", "unfolding squash_def"], ["proof (prove)\nusing this:\n  has_no_zeros (sign_vec qs x1)\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. (if 0 < rpoly q x1 then 1\n     else if rpoly q x1 < 0 then - 1 else 0) \\<noteq>\n    0", "using \\<open>q \\<in> set qs \\<and> rpoly q x1 = 0 \\<longrightarrow> \\<not> has_no_zeros (sign_vec qs x1)\\<close>"], ["proof (prove)\nusing this:\n  has_no_zeros (sign_vec qs x1)\n  q \\<in> set qs\n  q \\<in> set qs \\<and> rpoly q x1 = 0 \\<longrightarrow>\n  \\<not> has_no_zeros (sign_vec qs x1)\n\ngoal (1 subgoal):\n 1. (if 0 < rpoly q x1 then 1\n     else if rpoly q x1 < 0 then - 1 else 0) \\<noteq>\n    0", "by auto"], ["proof (state)\nthis:\n  squash (rpoly q x1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>x2 < x1; sign_vec qs x1 \\<noteq> sign_vec qs x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r<x1.\n                            x2 \\<le> r \\<and>\n                            (\\<exists>q\\<in>set qs. rpoly q r = 0)", "then"], ["proof (chain)\npicking this:\n  squash (rpoly q x1) \\<noteq> 0", "show \"(\\<exists>r<x1. (r \\<ge> x2 \\<and> (\\<exists> q \\<in> set(qs). rpoly q r = 0)))\""], ["proof (prove)\nusing this:\n  squash (rpoly q x1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>r<x1. x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)", "using q_prop poss1 poss2 poss3 not_poss4"], ["proof (prove)\nusing this:\n  squash (rpoly q x1) \\<noteq> 0\n  q \\<in> set qs \\<and> squash (rpoly q x1) \\<noteq> squash (rpoly q x2)\n  squash (rpoly q x1) = - 1 \\<and> squash (rpoly q x2) = 1 \\<longrightarrow>\n  (\\<exists>r<x1. x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  squash (rpoly q x1) = 1 \\<and> squash (rpoly q x2) = - 1 \\<longrightarrow>\n  (\\<exists>r<x1. x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  squash (rpoly q x2) = 0 \\<longrightarrow>\n  (\\<exists>r<x1. x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  squash (rpoly q x1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>r<x1. x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)", "apply (auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<ge>x2.\n        r < x1 \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x1) \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x1) = 1\n 2. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<ge>x2.\n        r < x1 \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x1) \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1\n 3. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<ge>x2.\n        r < x1 \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x1) = 1\n 4. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<ge>x2.\n        r < x1 \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1", "apply (meson squash_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<ge>x2.\n        r < x1 \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x1) \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1\n 2. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<ge>x2.\n        r < x1 \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x1) = 1\n 3. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<ge>x2.\n        r < x1 \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1", "apply (metis squash_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<ge>x2.\n        r < x1 \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x1) = 1\n 2. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<ge>x2.\n        r < x1 \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1", "apply (metis squash_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>squash (rpoly q x1) \\<noteq> 0; q \\<in> set qs;\n     squash (rpoly q x1) \\<noteq> squash (rpoly q x2);\n     squash (rpoly q x2) \\<noteq> 0;\n     \\<forall>r\\<ge>x2.\n        r < x1 \\<longrightarrow>\n        (\\<forall>q\\<in>set qs. rpoly q r \\<noteq> 0);\n     squash (rpoly q x2) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> squash (rpoly q x2) = - 1", "by (meson squash_def)"], ["proof (state)\nthis:\n  \\<exists>r<x1. x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_list_lemma:\n  fixes l:: \"real list\"\n  fixes a b:: \"real\"\n  fixes n:: \"nat\"\n  assumes \"a < b\"\n  assumes \"(n + 1) < length l\"\n  assumes strict_sort: \"strict_sorted l\"\n  assumes lt_a: \"(l ! n) < a\"\n  assumes b_lt: \"b < (l ! (n+1))\"\n  shows \"\\<not>(\\<exists>(x::real). (List.member l x \\<and> a \\<le> x \\<and> x \\<le> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>x. List.member l x \\<and> a \\<le> x \\<and> x \\<le> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x. List.member l x \\<and> a \\<le> x \\<and> x \\<le> b", "have sorted_hyp_var: \"\\<forall>q1 < length l. \\<forall>q2 < length l. (q1 < q2 \\<longrightarrow>\n     (l ! q1) < (l ! q2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q1<length l.\n       \\<forall>q2<length l. q1 < q2 \\<longrightarrow> l ! q1 < l ! q2", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q1 q2.\n       \\<lbrakk>q2 < length l; q1 < q2\\<rbrakk>\n       \\<Longrightarrow> l ! q1 < l ! q2", "by (metis (no_types, lifting) strict_sort sorted_wrt_iff_nth_less strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  \\<forall>q1<length l.\n     \\<forall>q2<length l. q1 < q2 \\<longrightarrow> l ! q1 < l ! q2\n\ngoal (1 subgoal):\n 1. \\<nexists>x. List.member l x \\<and> a \\<le> x \\<and> x \\<le> b", "then"], ["proof (chain)\npicking this:\n  \\<forall>q1<length l.\n     \\<forall>q2<length l. q1 < q2 \\<longrightarrow> l ! q1 < l ! q2", "have sorted_hyp_var2:  \"\\<forall>q1 < length l. \\<forall>q2 < length l. ((l ! q1) < (l ! q2)) \\<longrightarrow> q1 < q2\""], ["proof (prove)\nusing this:\n  \\<forall>q1<length l.\n     \\<forall>q2<length l. q1 < q2 \\<longrightarrow> l ! q1 < l ! q2\n\ngoal (1 subgoal):\n 1. \\<forall>q1<length l.\n       \\<forall>q2<length l. l ! q1 < l ! q2 \\<longrightarrow> q1 < q2", "using linorder_neqE_nat"], ["proof (prove)\nusing this:\n  \\<forall>q1<length l.\n     \\<forall>q2<length l. q1 < q2 \\<longrightarrow> l ! q1 < l ! q2\n  \\<lbrakk>?x \\<noteq> ?y; ?x < ?y \\<Longrightarrow> ?R;\n   ?y < ?x \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. \\<forall>q1<length l.\n       \\<forall>q2<length l. l ! q1 < l ! q2 \\<longrightarrow> q1 < q2", "by (metis Groups.add_ac(2) add_mono_thms_linordered_field(5) less_irrefl)"], ["proof (state)\nthis:\n  \\<forall>q1<length l.\n     \\<forall>q2<length l. l ! q1 < l ! q2 \\<longrightarrow> q1 < q2\n\ngoal (1 subgoal):\n 1. \\<nexists>x. List.member l x \\<and> a \\<le> x \\<and> x \\<le> b", "have \"(\\<exists>(x::real). (List.member l x \\<and> a \\<le> x \\<and> x \\<le> b)) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "assume \"(\\<exists>(x::real). (List.member l x \\<and> a \\<le> x \\<and> x \\<le> b))\""], ["proof (state)\nthis:\n  \\<exists>x. List.member l x \\<and> a \\<le> x \\<and> x \\<le> b\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. List.member l x \\<and> a \\<le> x \\<and> x \\<le> b", "obtain x where x_prop: \"List.member l x \\<and> a \\<le> x \\<and> x \\<le> b\""], ["proof (prove)\nusing this:\n  \\<exists>x. List.member l x \\<and> a \\<le> x \\<and> x \\<le> b\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  List.member l x \\<and> a \\<le> x \\<and> x \\<le> b\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  List.member l x \\<and> a \\<le> x \\<and> x \\<le> b", "have l_prop: \"List.member l x \\<and> (l ! n) < x \\<and> x < (l ! (n+1))\""], ["proof (prove)\nusing this:\n  List.member l x \\<and> a \\<le> x \\<and> x \\<le> b\n\ngoal (1 subgoal):\n 1. List.member l x \\<and> l ! n < x \\<and> x < l ! (n + 1)", "using lt_a b_lt"], ["proof (prove)\nusing this:\n  List.member l x \\<and> a \\<le> x \\<and> x \\<le> b\n  l ! n < a\n  b < l ! (n + 1)\n\ngoal (1 subgoal):\n 1. List.member l x \\<and> l ! n < x \\<and> x < l ! (n + 1)", "by auto"], ["proof (state)\nthis:\n  List.member l x \\<and> l ! n < x \\<and> x < l ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "have nth_l: \"l ! n < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l ! n < x", "using l_prop"], ["proof (prove)\nusing this:\n  List.member l x \\<and> l ! n < x \\<and> x < l ! (n + 1)\n\ngoal (1 subgoal):\n 1. l ! n < x", "by auto"], ["proof (state)\nthis:\n  l ! n < x\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "have np1th_l: \"x < l ! (n+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < l ! (n + 1)", "using l_prop"], ["proof (prove)\nusing this:\n  List.member l x \\<and> l ! n < x \\<and> x < l ! (n + 1)\n\ngoal (1 subgoal):\n 1. x < l ! (n + 1)", "by auto"], ["proof (state)\nthis:\n  x < l ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "have \"\\<exists>k. k < length l \\<and> nth l k = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<length l. l ! k = x", "using l_prop"], ["proof (prove)\nusing this:\n  List.member l x \\<and> l ! n < x \\<and> x < l ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length l. l ! k = x", "by (meson in_set_member index_of_lookup(1) index_of_lookup(2))"], ["proof (state)\nthis:\n  \\<exists>k<length l. l ! k = x\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>k<length l. l ! k = x", "obtain k where k_prop: \"k < length l \\<and> nth l k = x\""], ["proof (prove)\nusing this:\n  \\<exists>k<length l. l ! k = x\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k < length l \\<and> l ! k = x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k < length l \\<and> l ! k = x\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "have n_lt: \"n < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < k", "using nth_l sorted_hyp_var k_prop add_lessD1 assms(2) linorder_neqE_nat nat_SN.gt_trans"], ["proof (prove)\nusing this:\n  l ! n < x\n  \\<forall>q1<length l.\n     \\<forall>q2<length l. q1 < q2 \\<longrightarrow> l ! q1 < l ! q2\n  k < length l \\<and> l ! k = x\n  ?i + ?j < ?k \\<Longrightarrow> ?i < ?k\n  n + 1 < length l\n  \\<lbrakk>?x \\<noteq> ?y; ?x < ?y \\<Longrightarrow> ?R;\n   ?y < ?x \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  \\<lbrakk>?y < ?x; ?z < ?y\\<rbrakk> \\<Longrightarrow> ?z < ?x\n\ngoal (1 subgoal):\n 1. n < k", "by (meson sorted_hyp_var2)"], ["proof (state)\nthis:\n  n < k\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "have k_gt: \"k < n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n + 1", "using sorted_hyp_var np1th_l k_prop"], ["proof (prove)\nusing this:\n  \\<forall>q1<length l.\n     \\<forall>q2<length l. q1 < q2 \\<longrightarrow> l ! q1 < l ! q2\n  x < l ! (n + 1)\n  k < length l \\<and> l ! k = x\n\ngoal (1 subgoal):\n 1. k < n + 1", "using assms(2) sorted_hyp_var2"], ["proof (prove)\nusing this:\n  \\<forall>q1<length l.\n     \\<forall>q2<length l. q1 < q2 \\<longrightarrow> l ! q1 < l ! q2\n  x < l ! (n + 1)\n  k < length l \\<and> l ! k = x\n  n + 1 < length l\n  \\<forall>q1<length l.\n     \\<forall>q2<length l. l ! q1 < l ! q2 \\<longrightarrow> q1 < q2\n\ngoal (1 subgoal):\n 1. k < n + 1", "by blast"], ["proof (state)\nthis:\n  k < n + 1\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using n_lt k_gt"], ["proof (prove)\nusing this:\n  n < k\n  k < n + 1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x.\n     List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>x. List.member l x \\<and> a \\<le> x \\<and> x \\<le> b", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     List.member l x \\<and> a \\<le> x \\<and> x \\<le> b \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<nexists>x. List.member l x \\<and> a \\<le> x \\<and> x \\<le> b", "by auto"], ["proof (state)\nthis:\n  \\<nexists>x. List.member l x \\<and> a \\<le> x \\<and> x \\<le> b\n\ngoal:\nNo subgoals!", "qed"], ["", "(* This lemma shows that any zero of coprime_r is either between two roots or it's smaller than the \nleast root (neg inf) or it's greater than the biggest root (pos inf). *)"], ["", "lemma roots_of_coprime_r_location_property: \n  fixes qs:: \"rat poly list\"\n  fixes sga:: \"rat list\"\n  fixes zer_list\n  assumes pairwise_rel_prime: \"pairwise_coprime_list qs\"\n  assumes all_squarefree: \"\\<And>q. q \\<in> set qs \\<Longrightarrow> rsquarefree q\"\n  assumes x1_prop: \"sga = sign_vec qs x1\"\n  assumes hnz: \"has_no_zeros sga\"\n  assumes zer_list_prop: \"zer_list = sorted_list_of_set {(x::real). (\\<exists>q \\<in> set(qs). (rpoly q x = 0))}\"\n  shows \"zer_list \\<noteq> [] \\<longrightarrow> ((x1 < (zer_list ! 0)) \\<or> (x1 > (zer_list ! (length zer_list - 1)) \\<or>\n    (\\<exists> n < (length zer_list - 1). x1 > (zer_list ! n) \\<and> x1 < (zer_list ! (n+1)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zer_list \\<noteq> [] \\<longrightarrow>\n    x1 < zer_list ! 0 \\<or>\n    zer_list ! (length zer_list - 1) < x1 \\<or>\n    (\\<exists>n<length zer_list - 1.\n        zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zer_list \\<noteq> [] \\<longrightarrow>\n    x1 < zer_list ! 0 \\<or>\n    zer_list ! (length zer_list - 1) < x1 \\<or>\n    (\\<exists>n<length zer_list - 1.\n        zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))", "let ?zer_list = \"sorted_list_of_set {(x::real). (\\<exists>q \\<in> set(qs). (rpoly q x = 0))} :: real list\""], ["proof (state)\ngoal (1 subgoal):\n 1. zer_list \\<noteq> [] \\<longrightarrow>\n    x1 < zer_list ! 0 \\<or>\n    zer_list ! (length zer_list - 1) < x1 \\<or>\n    (\\<exists>n<length zer_list - 1.\n        zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. zer_list \\<noteq> [] \\<longrightarrow>\n    x1 < zer_list ! 0 \\<or>\n    zer_list ! (length zer_list - 1) < x1 \\<or>\n    (\\<exists>n<length zer_list - 1.\n        zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zer_list \\<noteq> [] \\<longrightarrow>\n    x1 < zer_list ! 0 \\<or>\n    zer_list ! (length zer_list - 1) < x1 \\<or>\n    (\\<exists>n<length zer_list - 1.\n        zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))", "have \"((\\<forall>q. (List.member qs q) \\<longrightarrow> q \\<noteq> 0) \\<and> has_no_zeros (sign_vec qs x1)) \\<Longrightarrow> \\<not> List.member ?zer_list x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n    has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n    \\<not> List.member\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n            x1", "proof (induct qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>q. List.member [] q \\<longrightarrow> q \\<noteq> 0) \\<and>\n    has_no_zeros (sign_vec [] x1) \\<Longrightarrow>\n    \\<not> List.member\n            (sorted_list_of_set {x. \\<exists>q\\<in>set []. rpoly q x = 0})\n            x1\n 2. \\<And>a qs.\n       \\<lbrakk>(\\<forall>q.\n                    List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n                has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n                \\<not> List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                        x1;\n        (\\<forall>q.\n            List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0) \\<and>\n        has_no_zeros (sign_vec (a # qs) x1)\\<rbrakk>\n       \\<Longrightarrow> \\<not> List.member\n                                 (sorted_list_of_set\n                                   {x. \\<exists>q\\<in>set (a # qs).\n    rpoly q x = 0})\n                                 x1", "case Nil"], ["proof (state)\nthis:\n  (\\<forall>q. List.member [] q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec [] x1)\n\ngoal (2 subgoals):\n 1. (\\<forall>q. List.member [] q \\<longrightarrow> q \\<noteq> 0) \\<and>\n    has_no_zeros (sign_vec [] x1) \\<Longrightarrow>\n    \\<not> List.member\n            (sorted_list_of_set {x. \\<exists>q\\<in>set []. rpoly q x = 0})\n            x1\n 2. \\<And>a qs.\n       \\<lbrakk>(\\<forall>q.\n                    List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n                has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n                \\<not> List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                        x1;\n        (\\<forall>q.\n            List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0) \\<and>\n        has_no_zeros (sign_vec (a # qs) x1)\\<rbrakk>\n       \\<Longrightarrow> \\<not> List.member\n                                 (sorted_list_of_set\n                                   {x. \\<exists>q\\<in>set (a # qs).\n    rpoly q x = 0})\n                                 x1", "then"], ["proof (chain)\npicking this:\n  (\\<forall>q. List.member [] q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec [] x1)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>q. List.member [] q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec [] x1)\n\ngoal (1 subgoal):\n 1. \\<not> List.member\n            (sorted_list_of_set {x. \\<exists>q\\<in>set []. rpoly q x = 0})\n            x1", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q. List.member [] q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec [] x1); List.member [] x1\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: member_rec(2))"], ["proof (state)\nthis:\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set []. rpoly q x = 0}) x1\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>(\\<forall>q.\n                    List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n                has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n                \\<not> List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                        x1;\n        (\\<forall>q.\n            List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0) \\<and>\n        has_no_zeros (sign_vec (a # qs) x1)\\<rbrakk>\n       \\<Longrightarrow> \\<not> List.member\n                                 (sorted_list_of_set\n                                   {x. \\<exists>q\\<in>set (a # qs).\n    rpoly q x = 0})\n                                 x1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>(\\<forall>q.\n                    List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n                has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n                \\<not> List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                        x1;\n        (\\<forall>q.\n            List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0) \\<and>\n        has_no_zeros (sign_vec (a # qs) x1)\\<rbrakk>\n       \\<Longrightarrow> \\<not> List.member\n                                 (sorted_list_of_set\n                                   {x. \\<exists>q\\<in>set (a # qs).\n    rpoly q x = 0})\n                                 x1", "case (Cons a qs)"], ["proof (state)\nthis:\n  (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n  (\\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec (a # qs) x1)\n\ngoal (1 subgoal):\n 1. \\<And>a qs.\n       \\<lbrakk>(\\<forall>q.\n                    List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n                has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n                \\<not> List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                        x1;\n        (\\<forall>q.\n            List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0) \\<and>\n        has_no_zeros (sign_vec (a # qs) x1)\\<rbrakk>\n       \\<Longrightarrow> \\<not> List.member\n                                 (sorted_list_of_set\n                                   {x. \\<exists>q\\<in>set (a # qs).\n    rpoly q x = 0})\n                                 x1", "then"], ["proof (chain)\npicking this:\n  (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n  (\\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec (a # qs) x1)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n  (\\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec (a # qs) x1)\n\ngoal (1 subgoal):\n 1. \\<not> List.member\n            (sorted_list_of_set\n              {x. \\<exists>q\\<in>set (a # qs). rpoly q x = 0})\n            x1", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "assume imp: \"((\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n     has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n     \\<not> List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n         x1)\""], ["proof (state)\nthis:\n  (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "assume nonz: \"\\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "assume hnz: \" has_no_zeros (sign_vec (a # qs) x1)\""], ["proof (state)\nthis:\n  has_no_zeros (sign_vec (a # qs) x1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "assume mem_list: \"List.member\n     (sorted_list_of_set {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n     x1\""], ["proof (state)\nthis:\n  List.member\n   (sorted_list_of_set\n     {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n   x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "have \"has_no_zeros (sign_vec (a # qs) x1) \\<Longrightarrow> has_no_zeros (sign_vec qs x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_no_zeros (sign_vec (a # qs) x1) \\<Longrightarrow>\n    has_no_zeros (sign_vec qs x1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_no_zeros (sign_vec (a # qs) x1) \\<Longrightarrow>\n    has_no_zeros (sign_vec qs x1)", "assume hnz: \"has_no_zeros (sign_vec (a # qs) x1)\""], ["proof (state)\nthis:\n  has_no_zeros (sign_vec (a # qs) x1)\n\ngoal (1 subgoal):\n 1. has_no_zeros (sign_vec (a # qs) x1) \\<Longrightarrow>\n    has_no_zeros (sign_vec qs x1)", "have same_vec: \"sign_vec (a # qs) x1 = ((if rpoly a x1 > 0 then 1 else if rpoly a x1 = 0 then 0 else -1) # sign_vec (qs) x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_vec (a # qs) x1 =\n    (if 0 < rpoly a x1 then 1 else if rpoly a x1 = 0 then 0 else - 1) #\n    sign_vec qs x1", "unfolding sign_vec_def squash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>x. if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n         (\\<lambda>p. rpoly p x1))\n     (a # qs) =\n    (if 0 < rpoly a x1 then 1 else if rpoly a x1 = 0 then 0 else - 1) #\n    map ((\\<lambda>x. if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n         (\\<lambda>p. rpoly p x1))\n     qs", "by auto"], ["proof (state)\nthis:\n  sign_vec (a # qs) x1 =\n  (if 0 < rpoly a x1 then 1 else if rpoly a x1 = 0 then 0 else - 1) #\n  sign_vec qs x1\n\ngoal (1 subgoal):\n 1. has_no_zeros (sign_vec (a # qs) x1) \\<Longrightarrow>\n    has_no_zeros (sign_vec qs x1)", "have \"has_no_zeros ((if rpoly a x1 > 0 then 1 else if rpoly a x1 = 0 then 0 else -1) # sign_vec (qs) x1)\n            \\<Longrightarrow>  has_no_zeros (sign_vec (qs) x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_no_zeros\n     ((if 0 < rpoly a x1 then 1 else if rpoly a x1 = 0 then 0 else - 1) #\n      sign_vec qs x1) \\<Longrightarrow>\n    has_no_zeros (sign_vec qs x1)", "by (simp add: has_no_zeros_def)"], ["proof (state)\nthis:\n  has_no_zeros\n   ((if 0 < rpoly a x1 then 1 else if rpoly a x1 = 0 then 0 else - 1) #\n    sign_vec qs x1) \\<Longrightarrow>\n  has_no_zeros (sign_vec qs x1)\n\ngoal (1 subgoal):\n 1. has_no_zeros (sign_vec (a # qs) x1) \\<Longrightarrow>\n    has_no_zeros (sign_vec qs x1)", "then"], ["proof (chain)\npicking this:\n  has_no_zeros\n   ((if 0 < rpoly a x1 then 1 else if rpoly a x1 = 0 then 0 else - 1) #\n    sign_vec qs x1) \\<Longrightarrow>\n  has_no_zeros (sign_vec qs x1)", "show \"has_no_zeros (sign_vec qs x1)\""], ["proof (prove)\nusing this:\n  has_no_zeros\n   ((if 0 < rpoly a x1 then 1 else if rpoly a x1 = 0 then 0 else - 1) #\n    sign_vec qs x1) \\<Longrightarrow>\n  has_no_zeros (sign_vec qs x1)\n\ngoal (1 subgoal):\n 1. has_no_zeros (sign_vec qs x1)", "using hnz same_vec"], ["proof (prove)\nusing this:\n  has_no_zeros\n   ((if 0 < rpoly a x1 then 1 else if rpoly a x1 = 0 then 0 else - 1) #\n    sign_vec qs x1) \\<Longrightarrow>\n  has_no_zeros (sign_vec qs x1)\n  has_no_zeros (sign_vec (a # qs) x1)\n  sign_vec (a # qs) x1 =\n  (if 0 < rpoly a x1 then 1 else if rpoly a x1 = 0 then 0 else - 1) #\n  sign_vec qs x1\n\ngoal (1 subgoal):\n 1. has_no_zeros (sign_vec qs x1)", "by auto"], ["proof (state)\nthis:\n  has_no_zeros (sign_vec qs x1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_no_zeros (sign_vec (a # qs) x1) \\<Longrightarrow>\n  has_no_zeros (sign_vec qs x1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  has_no_zeros (sign_vec (a # qs) x1) \\<Longrightarrow>\n  has_no_zeros (sign_vec qs x1)", "have nmem: \"\\<not> List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\""], ["proof (prove)\nusing this:\n  has_no_zeros (sign_vec (a # qs) x1) \\<Longrightarrow>\n  has_no_zeros (sign_vec qs x1)\n\ngoal (1 subgoal):\n 1. \\<not> List.member\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n            x1", "using hnz nonz imp"], ["proof (prove)\nusing this:\n  has_no_zeros (sign_vec (a # qs) x1) \\<Longrightarrow>\n  has_no_zeros (sign_vec qs x1)\n  has_no_zeros (sign_vec (a # qs) x1)\n  \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0\n  (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n\ngoal (1 subgoal):\n 1. \\<not> List.member\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n            x1", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_no_zeros (sign_vec qs x1);\n     has_no_zeros (sign_vec (a # qs) x1);\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     \\<forall>q.\n        List.member qs q \\<longrightarrow> q \\<noteq> 0 \\<Longrightarrow>\n     False;\n     List.member\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: member_rec(1))"], ["proof (state)\nthis:\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<forall>q \\<in>set qs. q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. q \\<noteq> 0", "using nonz"], ["proof (prove)\nusing this:\n  \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. q \\<noteq> 0", "using in_set_member"], ["proof (prove)\nusing this:\n  \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. q \\<noteq> 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     \\<And>x xs. (x \\<in> set xs) = List.member xs x;\n     0 \\<in> set qs\\<rbrakk>\n    \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0", "have \"\\<forall>q \\<in>set qs. finite {x. rpoly q x = 0}\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. finite {x. rpoly q x = (0::'a)}", "by (simp add: poly_roots_finite)"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. finite {x. rpoly q x = (0::?'a1)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs. finite {x. rpoly q x = (0::?'a1)}", "have fin_set: \"finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. finite {x. rpoly q x = (0::?'a1)}\n\ngoal (1 subgoal):\n 1. finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a2)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "have not_in: \"x1 \\<notin> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<notin> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "using fin_set nmem set_sorted_list_of_set\n            all_squarefree"], ["proof (prove)\nusing this:\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a2)}\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  ?q \\<in> set qs \\<Longrightarrow> rsquarefree ?q\n\ngoal (1 subgoal):\n 1. x1 \\<notin> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>\\<forall>q\\<in>set qs. finite {x. rpoly q x = (0::?'a2)};\n        \\<not> List.member\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                x1;\n        \\<And>A. finite A \\<Longrightarrow> set (sorted_list_of_set A) = A;\n        \\<And>q. q \\<in> set qs \\<Longrightarrow> rsquarefree q;\n        q \\<in> set qs; rpoly q x1 = 0\\<rbrakk>\n       \\<Longrightarrow> False", "by (simp add: List.member_def \\<open>finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\\<close>)"], ["proof (state)\nthis:\n  x1 \\<notin> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "have x1_in: \"x1 \\<in> {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<in> {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)}", "using mem_list sorted_list_of_set"], ["proof (prove)\nusing this:\n  List.member\n   (sorted_list_of_set\n     {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n   x1\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  sorted (sorted_list_of_set ?A)\n  distinct (sorted_list_of_set ?A)\n\ngoal (1 subgoal):\n 1. x1 \\<in> {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member\n              (sorted_list_of_set\n                {x. rpoly a x = 0 \\<or>\n                    (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n              x1;\n     \\<And>A. finite A \\<Longrightarrow> set (sorted_list_of_set A) = A;\n     \\<And>A. sorted (sorted_list_of_set A);\n     \\<And>A. distinct (sorted_list_of_set A)\\<rbrakk>\n    \\<Longrightarrow> x1 \\<in> {x. rpoly a x = 0 \\<or>\n                                   (\\<exists>q\\<in>set qs. rpoly q x = 0)}", "have f1: \"\\<forall>r R. ((r::real) \\<in> R \\<or> \\<not> List.member (sorted_list_of_set R) r) \\<or> infinite R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r R.\n       (r \\<in> R \\<or> \\<not> List.member (sorted_list_of_set R) r) \\<or>\n       infinite R", "by (metis in_set_member set_sorted_list_of_set)"], ["proof (state)\nthis:\n  \\<forall>r R.\n     (r \\<in> R \\<or> \\<not> List.member (sorted_list_of_set R) r) \\<or>\n     infinite R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member\n              (sorted_list_of_set\n                {x. rpoly a x = 0 \\<or>\n                    (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n              x1;\n     \\<And>A. finite A \\<Longrightarrow> set (sorted_list_of_set A) = A;\n     \\<And>A. sorted (sorted_list_of_set A);\n     \\<And>A. distinct (sorted_list_of_set A)\\<rbrakk>\n    \\<Longrightarrow> x1 \\<in> {x. rpoly a x = 0 \\<or>\n                                   (\\<exists>q\\<in>set qs. rpoly q x = 0)}", "have \"finite {r. rpoly a (r::real) = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {r. rpoly a r = 0}", "by (metis (full_types) List.finite_set member_rec(1) nonz real_roots_of_rat_poly(1))"], ["proof (state)\nthis:\n  finite {r. rpoly a r = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>List.member\n              (sorted_list_of_set\n                {x. rpoly a x = 0 \\<or>\n                    (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n              x1;\n     \\<And>A. finite A \\<Longrightarrow> set (sorted_list_of_set A) = A;\n     \\<And>A. sorted (sorted_list_of_set A);\n     \\<And>A. distinct (sorted_list_of_set A)\\<rbrakk>\n    \\<Longrightarrow> x1 \\<in> {x. rpoly a x = 0 \\<or>\n                                   (\\<exists>q\\<in>set qs. rpoly q x = 0)}", "then"], ["proof (chain)\npicking this:\n  finite {r. rpoly a r = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {r. rpoly a r = 0}\n\ngoal (1 subgoal):\n 1. x1 \\<in> {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)}", "using f1 \\<open>finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\\<close> mem_list"], ["proof (prove)\nusing this:\n  finite {r. rpoly a r = 0}\n  \\<forall>r R.\n     (r \\<in> R \\<or> \\<not> List.member (sorted_list_of_set R) r) \\<or>\n     infinite R\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a)}\n  List.member\n   (sorted_list_of_set\n     {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n   x1\n\ngoal (1 subgoal):\n 1. x1 \\<in> {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)}", "by fastforce"], ["proof (state)\nthis:\n  x1 \\<in> {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x1 \\<in> {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "have \"rpoly a x1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpoly a x1 \\<noteq> 0", "using hnz"], ["proof (prove)\nusing this:\n  has_no_zeros (sign_vec (a # qs) x1)\n\ngoal (1 subgoal):\n 1. rpoly a x1 \\<noteq> 0", "unfolding has_no_zeros_def sign_vec_def squash_def"], ["proof (prove)\nusing this:\n  0 \\<notin> set (map ((\\<lambda>x.\n                           if 0 < x then 1\n                           else if x < 0 then - 1 else 0) \\<circ>\n                       (\\<lambda>p. rpoly p x1))\n                   (a # qs))\n\ngoal (1 subgoal):\n 1. rpoly a x1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  rpoly a x1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<not> List.member\n                     (sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                     x1;\n     \\<forall>q. List.member (a # qs) q \\<longrightarrow> q \\<noteq> 0;\n     has_no_zeros (sign_vec (a # qs) x1);\n     List.member\n      (sorted_list_of_set\n        {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  rpoly a x1 \\<noteq> 0", "show \"False\""], ["proof (prove)\nusing this:\n  rpoly a x1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using not_in x1_in"], ["proof (prove)\nusing this:\n  rpoly a x1 \\<noteq> 0\n  x1 \\<notin> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n  x1 \\<in> {x. rpoly a x = 0 \\<or> (\\<exists>q\\<in>set qs. rpoly q x = 0)}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> List.member\n          (sorted_list_of_set\n            {x. \\<exists>q\\<in>set (a # qs). rpoly q x = 0})\n          x1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n\ngoal (1 subgoal):\n 1. zer_list \\<noteq> [] \\<longrightarrow>\n    x1 < zer_list ! 0 \\<or>\n    zer_list ! (length zer_list - 1) < x1 \\<or>\n    (\\<exists>n<length zer_list - 1.\n        zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))", "then"], ["proof (chain)\npicking this:\n  (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1", "have non_mem: \"\\<not> List.member ?zer_list x1\""], ["proof (prove)\nusing this:\n  (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n\ngoal (1 subgoal):\n 1. \\<not> List.member\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n            x1", "using all_squarefree"], ["proof (prove)\nusing this:\n  (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n  ?q \\<in> set qs \\<Longrightarrow> rsquarefree ?q\n\ngoal (1 subgoal):\n 1. \\<not> List.member\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n            x1", "unfolding rsquarefree_def hnz"], ["proof (prove)\nusing this:\n  (\\<forall>q. List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n  ?q \\<in> set qs \\<Longrightarrow>\n  ?q \\<noteq> 0 \\<and>\n  (\\<forall>a. Polynomial.order a ?q = 0 \\<or> Polynomial.order a ?q = 1)\n\ngoal (1 subgoal):\n 1. \\<not> List.member\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n            x1", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             False;\n     \\<And>q.\n        q \\<in> set qs \\<Longrightarrow>\n        q \\<noteq> 0 \\<and>\n        (\\<forall>a.\n            Polynomial.order a q = 0 \\<or> Polynomial.order a q = Suc 0);\n     List.member\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "using hnz x1_prop"], ["proof (prove)\nusing this:\n  has_no_zeros sga\n  sga = sign_vec qs x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>q.\n                 List.member qs q \\<longrightarrow> q \\<noteq> 0) \\<and>\n             has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             False;\n     \\<And>q.\n        q \\<in> set qs \\<Longrightarrow>\n        q \\<noteq> 0 \\<and>\n        (\\<forall>a.\n            Polynomial.order a q = 0 \\<or> Polynomial.order a q = Suc 0);\n     List.member\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n      x1\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: in_set_member)"], ["proof (state)\nthis:\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n\ngoal (1 subgoal):\n 1. zer_list \\<noteq> [] \\<longrightarrow>\n    x1 < zer_list ! 0 \\<or>\n    zer_list ! (length zer_list - 1) < x1 \\<or>\n    (\\<exists>n<length zer_list - 1.\n        zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))", "have \"?zer_list \\<noteq> [] \\<Longrightarrow> ((x1 \\<ge> (?zer_list ! 0)) \\<and> (x1 \\<le> (?zer_list ! (length ?zer_list - 1))))\n\\<Longrightarrow> (\\<exists> n < (length ?zer_list - 1). x1 > (?zer_list ! n) \\<and> x1 < (?zer_list ! (n+1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> x1 \\<and>\n     x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n              (length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length\n                                  (sorted_list_of_set\n                                    {x. \\<exists>q\\<in>set qs.\n     rpoly q x = 0}) -\n                                 1.\n                         sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         n\n                         < x1 \\<and>\n                         x1 < sorted_list_of_set\n                               {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                              (n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> x1 \\<and>\n     x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n              (length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length\n                                  (sorted_list_of_set\n                                    {x. \\<exists>q\\<in>set qs.\n     rpoly q x = 0}) -\n                                 1.\n                         sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         n\n                         < x1 \\<and>\n                         x1 < sorted_list_of_set\n                               {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                              (n + 1)", "assume \"?zer_list \\<noteq> []\""], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> x1 \\<and>\n     x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n              (length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length\n                                  (sorted_list_of_set\n                                    {x. \\<exists>q\\<in>set qs.\n     rpoly q x = 0}) -\n                                 1.\n                         sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         n\n                         < x1 \\<and>\n                         x1 < sorted_list_of_set\n                               {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                              (n + 1)", "assume x1_asm: \"(x1 \\<ge> (?zer_list ! 0)) \\<and> (x1 \\<le> (?zer_list ! (length ?zer_list - 1)))\""], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<le> x1 \\<and>\n  x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> x1 \\<and>\n     x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n              (length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length\n                                  (sorted_list_of_set\n                                    {x. \\<exists>q\\<in>set qs.\n     rpoly q x = 0}) -\n                                 1.\n                         sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         n\n                         < x1 \\<and>\n                         x1 < sorted_list_of_set\n                               {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                              (n + 1)", "have nm1: \"x1 \\<noteq> ?zer_list ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0", "using non_mem"], ["proof (prove)\nusing this:\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n\ngoal (1 subgoal):\n 1. x1 \\<noteq>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0", "using \\<open>sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> []\\<close> in_set_member"], ["proof (prove)\nusing this:\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> []\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. x1 \\<noteq>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0", "by (metis (no_types, lifting) in_set_conv_nth length_greater_0_conv)"], ["proof (state)\nthis:\n  x1 \\<noteq>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> x1 \\<and>\n     x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n              (length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length\n                                  (sorted_list_of_set\n                                    {x. \\<exists>q\\<in>set qs.\n     rpoly q x = 0}) -\n                                 1.\n                         sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         n\n                         < x1 \\<and>\n                         x1 < sorted_list_of_set\n                               {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                              (n + 1)", "have nm2: \"x1 \\<noteq> ?zer_list ! (length ?zer_list -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<noteq>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)", "using non_mem"], ["proof (prove)\nusing this:\n  \\<not> List.member\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) x1\n\ngoal (1 subgoal):\n 1. x1 \\<noteq>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)", "by (metis (no_types, lifting) One_nat_def \\<open>sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> []\\<close> diff_Suc_less in_set_member length_greater_0_conv nth_mem)"], ["proof (state)\nthis:\n  x1 \\<noteq>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> x1 \\<and>\n     x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n              (length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length\n                                  (sorted_list_of_set\n                                    {x. \\<exists>q\\<in>set qs.\n     rpoly q x = 0}) -\n                                 1.\n                         sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         n\n                         < x1 \\<and>\n                         x1 < sorted_list_of_set\n                               {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                              (n + 1)", "then"], ["proof (chain)\npicking this:\n  x1 \\<noteq>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)", "have x_asm_var: \"x1 > (?zer_list ! 0) \\<and> x1 < ?zer_list ! (length ?zer_list -1)\""], ["proof (prove)\nusing this:\n  x1 \\<noteq>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    < x1 \\<and>\n    x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (length\n           (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n          1)", "using x1_asm nm1 nm2"], ["proof (prove)\nusing this:\n  x1 \\<noteq>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<le> x1 \\<and>\n  x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1)\n  x1 \\<noteq>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  x1 \\<noteq>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    < x1 \\<and>\n    x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (length\n           (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n          1)", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n        1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> x1 \\<and>\n     x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n              (length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length\n                                  (sorted_list_of_set\n                                    {x. \\<exists>q\\<in>set qs.\n     rpoly q x = 0}) -\n                                 1.\n                         sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         n\n                         < x1 \\<and>\n                         x1 < sorted_list_of_set\n                               {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                              (n + 1)", "have \"(\\<forall>n. (n < (length ?zer_list - 1) \\<and>  x1 \\<ge> (?zer_list ! n) \\<longrightarrow> x1 \\<ge> (?zer_list ! (n+1)))) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<and>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n       \\<le> x1 \\<Longrightarrow>\n    False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<and>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n       \\<le> x1 \\<Longrightarrow>\n    False", "assume assump: \"(\\<forall>n. (n < (length ?zer_list - 1) \\<and>  x1 \\<ge> (?zer_list ! n) \\<longrightarrow> x1 \\<ge> (?zer_list ! (n+1))))\""], ["proof (state)\nthis:\n  \\<forall>n.\n     n < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<and>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     \\<le> x1 \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n     \\<le> x1\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<and>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n       \\<le> x1 \\<Longrightarrow>\n    False", "have zer_case: \"x1 \\<ge> ?zer_list ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    \\<le> x1", "using x_asm_var"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n        1)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    \\<le> x1", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0 \\<le> x1\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<and>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n       \\<le> x1 \\<Longrightarrow>\n    False", "have all_n: \"\\<And> n. (n < (length ?zer_list - 1) \\<longrightarrow> x1 \\<ge> ?zer_list ! n) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1", "show n_lt: \"(n < (length ?zer_list - 1) \\<longrightarrow> x1 \\<ge> ?zer_list ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n        1 \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n    \\<le> x1", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n        1 \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    \\<le> x1\n 2. \\<And>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<Longrightarrow>\n       Suc n\n       < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! Suc n\n       \\<le> x1", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 < length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n        1 \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    \\<le> x1\n 2. \\<And>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<Longrightarrow>\n       Suc n\n       < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! Suc n\n       \\<le> x1", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n        1 \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    \\<le> x1", "using zer_case"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0 \\<le> x1\n\ngoal (1 subgoal):\n 1. 0 < length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n        1 \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    \\<le> x1", "by blast"], ["proof (state)\nthis:\n  0 < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0 \\<le> x1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<Longrightarrow>\n       Suc n\n       < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! Suc n\n       \\<le> x1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<Longrightarrow>\n       Suc n\n       < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! Suc n\n       \\<le> x1", "case (Suc n)"], ["proof (state)\nthis:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n \\<le> x1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<Longrightarrow>\n       Suc n\n       < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! Suc n\n       \\<le> x1", "then"], ["proof (chain)\npicking this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n \\<le> x1", "show ?case"], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n \\<le> x1\n\ngoal (1 subgoal):\n 1. Suc n\n    < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! Suc n\n    \\<le> x1", "using assump"], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n \\<le> x1\n  \\<forall>n.\n     n < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<and>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     \\<le> x1 \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n     \\<le> x1\n\ngoal (1 subgoal):\n 1. Suc n\n    < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! Suc n\n    \\<le> x1", "using Suc_eq_plus1 Suc_lessD"], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n \\<le> x1\n  \\<forall>n.\n     n < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<and>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     \\<le> x1 \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n     \\<le> x1\n  Suc ?n = ?n + 1\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n\ngoal (1 subgoal):\n 1. Suc n\n    < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! Suc n\n    \\<le> x1", "by presburger"], ["proof (state)\nthis:\n  Suc n\n  < length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n    1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! Suc n\n  \\<le> x1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n \\<le> x1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?n < length\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n       1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! ?n \\<le> x1\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<and>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n       \\<le> x1 \\<Longrightarrow>\n    False", "have \"(length ?zer_list - 2) \\<le> length ?zer_list -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n    2\n    \\<le> length\n           (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n          1", "using diff_le_mono2 one_le_numeral"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow> ?l - ?n \\<le> ?l - ?m\n  (1::?'a) \\<le> numeral ?n\n\ngoal (1 subgoal):\n 1. length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n    2\n    \\<le> length\n           (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n          1", "by blast"], ["proof (state)\nthis:\n  length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) - 2\n  \\<le> length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n        1\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<and>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n       \\<le> x1 \\<Longrightarrow>\n    False", "have \"x1 \\<ge> ?zer_list ! (length ?zer_list - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<le> x1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<le> x1", "have h1: \"length ?zer_list = 1 \\<longrightarrow> x1 \\<ge> ?zer_list ! (length ?zer_list - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) =\n    1 \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<le> x1", "using assump zer_case"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     n < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<and>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     \\<le> x1 \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n     \\<le> x1\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0 \\<le> x1\n\ngoal (1 subgoal):\n 1. length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) =\n    1 \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<le> x1", "by auto"], ["proof (state)\nthis:\n  length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) =\n  1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<le> x1", "have h2: \"length ?zer_list > 1 \\<longrightarrow> x1 \\<ge> ?zer_list ! (length ?zer_list - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<le> x1", "using all_n assump"], ["proof (prove)\nusing this:\n  ?n < length\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n       1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! ?n \\<le> x1\n  \\<forall>n.\n     n < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<and>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     \\<le> x1 \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n     \\<le> x1\n\ngoal (1 subgoal):\n 1. 1 < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<le> x1", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                n < card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} -\n                    Suc 0 \\<longrightarrow>\n                sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                n\n                \\<le> x1;\n     \\<forall>n.\n        n < card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0 \\<and>\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n        \\<le> x1 \\<longrightarrow>\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! Suc n\n        \\<le> x1;\n     Suc 0 < card {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\\<rbrakk>\n    \\<Longrightarrow> sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                      (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} -\n                       Suc 0)\n                      \\<le> x1", "by (metis (mono_tags, lifting) Suc_diff_Suc lessI)"], ["proof (state)\nthis:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<le> x1", "then"], ["proof (chain)\npicking this:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<le> x1", "using h1 h2"], ["proof (prove)\nusing this:\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1\n  length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) =\n  1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1\n  1 < length\n       (sorted_list_of_set\n         {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<le> x1", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Suc 0 < card {x. \\<exists>q\\<in>set qs. rpoly q x = 0};\n     card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                      0\n                      \\<le> x1", "using zer_case"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0 \\<le> x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Suc 0 < card {x. \\<exists>q\\<in>set qs. rpoly q x = 0};\n     card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                      0\n                      \\<le> x1", "by blast"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n < length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1 \\<and>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       \\<le> x1 \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n       \\<le> x1 \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1", "show False"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1\n\ngoal (1 subgoal):\n 1. False", "using all_n x_asm_var"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<le> x1\n  ?n < length\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n       1 \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! ?n \\<le> x1\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n        1)\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n.\n     n < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<and>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     \\<le> x1 \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n     \\<le> x1 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> x1 \\<and>\n     x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n              (length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n<length\n                                  (sorted_list_of_set\n                                    {x. \\<exists>q\\<in>set qs.\n     rpoly q x = 0}) -\n                                 1.\n                         sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         n\n                         < x1 \\<and>\n                         x1 < sorted_list_of_set\n                               {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                              (n + 1)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     n < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<and>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     \\<le> x1 \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n     \\<le> x1 \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     n < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<and>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     \\<le> x1 \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n     \\<le> x1 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1)", "using x1_asm"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     n < length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1 \\<and>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     \\<le> x1 \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n     \\<le> x1 \\<Longrightarrow>\n  False\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<le> x1 \\<and>\n  x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1)", "by (smt One_nat_def Suc_pred \\<open>sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> []\\<close> in_set_member length_greater_0_conv less_SucI non_mem nth_mem)"], ["proof (state)\nthis:\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1.\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < x1 \\<and>\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n           [];\n   sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n   \\<le> x1 \\<and>\n   x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n<length\n                                (sorted_list_of_set\n                                  {x. \\<exists>q\\<in>set qs.\n   rpoly q x = 0}) -\n                               1.\n                       sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                       n\n                       < x1 \\<and>\n                       x1 < sorted_list_of_set\n                             {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                            (n + 1)\n\ngoal (1 subgoal):\n 1. zer_list \\<noteq> [] \\<longrightarrow>\n    x1 < zer_list ! 0 \\<or>\n    zer_list ! (length zer_list - 1) < x1 \\<or>\n    (\\<exists>n<length zer_list - 1.\n        zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n           [];\n   sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n   \\<le> x1 \\<and>\n   x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n<length\n                                (sorted_list_of_set\n                                  {x. \\<exists>q\\<in>set qs.\n   rpoly q x = 0}) -\n                               1.\n                       sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                       n\n                       < x1 \\<and>\n                       x1 < sorted_list_of_set\n                             {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                            (n + 1)", "have h1: \"(?zer_list \\<noteq> [] \\<and> (x1 \\<ge> (?zer_list ! 0)) \\<and> (x1 \\<le> (?zer_list ! (length ?zer_list - 1))) \\<Longrightarrow>\n      (\\<exists> n < (length ?zer_list - 1). x1 > (?zer_list ! n) \\<and> x1 < (?zer_list ! (n+1))))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n           [];\n   sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n   \\<le> x1 \\<and>\n   x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n<length\n                                (sorted_list_of_set\n                                  {x. \\<exists>q\\<in>set qs.\n   rpoly q x = 0}) -\n                               1.\n                       sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                       n\n                       < x1 \\<and>\n                       x1 < sorted_list_of_set\n                             {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                            (n + 1)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<and>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    \\<le> x1 \\<and>\n    x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             (length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n              1) \\<Longrightarrow>\n    \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1)", "by blast"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<le> x1 \\<and>\n  x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1) \\<Longrightarrow>\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1.\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < x1 \\<and>\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1)\n\ngoal (1 subgoal):\n 1. zer_list \\<noteq> [] \\<longrightarrow>\n    x1 < zer_list ! 0 \\<or>\n    zer_list ! (length zer_list - 1) < x1 \\<or>\n    (\\<exists>n<length zer_list - 1.\n        zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<le> x1 \\<and>\n  x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1) \\<Longrightarrow>\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1.\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < x1 \\<and>\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<le> x1 \\<and>\n  x1 \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1) \\<Longrightarrow>\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1.\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < x1 \\<and>\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1)\n\ngoal (1 subgoal):\n 1. zer_list \\<noteq> [] \\<longrightarrow>\n    x1 < zer_list ! 0 \\<or>\n    zer_list ! (length zer_list - 1) < x1 \\<or>\n    (\\<exists>n<length zer_list - 1.\n        zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [] \\<and>\n             sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             0\n             \\<le> x1 \\<and>\n             x1 \\<le> sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                      (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} -\n                       Suc 0) \\<Longrightarrow>\n             \\<exists>n<card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} -\n                        Suc 0.\n                sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                n\n                < x1 \\<and>\n                x1 < sorted_list_of_set\n                      {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                     Suc n;\n     zer_list \\<noteq> []; \\<not> x1 < zer_list ! 0;\n     \\<forall>n.\n        zer_list ! n < x1 \\<longrightarrow>\n        n < length zer_list - Suc 0 \\<longrightarrow>\n        \\<not> x1 < zer_list ! Suc n\\<rbrakk>\n    \\<Longrightarrow> zer_list ! (length zer_list - Suc 0) < x1", "using zer_list_prop not_less"], ["proof (prove)\nusing this:\n  zer_list = sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [] \\<and>\n             sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             0\n             \\<le> x1 \\<and>\n             x1 \\<le> sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                      (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} -\n                       Suc 0) \\<Longrightarrow>\n             \\<exists>n<card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} -\n                        Suc 0.\n                sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                n\n                < x1 \\<and>\n                x1 < sorted_list_of_set\n                      {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                     Suc n;\n     zer_list \\<noteq> []; \\<not> x1 < zer_list ! 0;\n     \\<forall>n.\n        zer_list ! n < x1 \\<longrightarrow>\n        n < length zer_list - Suc 0 \\<longrightarrow>\n        \\<not> x1 < zer_list ! Suc n\\<rbrakk>\n    \\<Longrightarrow> zer_list ! (length zer_list - Suc 0) < x1", "by auto"], ["proof (state)\nthis:\n  zer_list \\<noteq> [] \\<longrightarrow>\n  x1 < zer_list ! 0 \\<or>\n  zer_list ! (length zer_list - 1) < x1 \\<or>\n  (\\<exists>n<length zer_list - 1.\n      zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zer_list \\<noteq> [] \\<longrightarrow>\n  x1 < zer_list ! 0 \\<or>\n  zer_list ! (length zer_list - 1) < x1 \\<or>\n  (\\<exists>n<length zer_list - 1.\n      zer_list ! n < x1 \\<and> x1 < zer_list ! (n + 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* This lemma is essentially saying that the zeros of coprime_r capture all relevant sample points.\nFrom roots_of_coprime_r_location_property, we know that any zero of coprime_r is either between two \n  roots, or it's smaller than the least root (neg inf), or it's greater than the biggest root (pos inf).\nThen, since the polynomials have constant signs within those intervals, the zeros of coprime_r \n  capture all the relevant information.\n*)"], ["", "lemma roots_of_coprime_r_capture_sgas_without_zeros: \n  fixes qs:: \"rat poly list\"\n  fixes sga:: \"rat list\"\n  assumes pairwise_rel_prime: \"pairwise_coprime_list qs\"\n  assumes all_squarefree: \"\\<And>q. q \\<in> set qs \\<Longrightarrow> rsquarefree q\"\n  assumes ex_x1: \"sga = sign_vec qs x1\"\n  assumes hnz: \"has_no_zeros sga\"\n  shows \"(\\<exists>w \\<in> (roots_of_coprime_r (cast_rat_list qs)). sga = (sign_vec qs w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "obtain x1 where x1_prop: \"sga = (sign_vec qs x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        sga = sign_vec qs x1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_x1"], ["proof (prove)\nusing this:\n  sga = sign_vec qs x1\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        sga = sign_vec qs x1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  sga = sign_vec qs x1\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "let ?zer_list = \"sorted_list_of_set {(x::real). (\\<exists>q \\<in> set(qs). (rpoly q x = 0))} :: real list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have strict_sorted_h: \"strict_sorted ?zer_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_sorted\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})", "using sorted_sorted_list_of_set\n      strict_sorted_iff"], ["proof (prove)\nusing this:\n  sorted (sorted_list_of_set ?A)\n  strict_sorted ?l = (sorted ?l \\<and> distinct ?l)\n\ngoal (1 subgoal):\n 1. strict_sorted\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})", "by auto"], ["proof (state)\nthis:\n  strict_sorted\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  strict_sorted\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})", "have sorted_hyp: \"\\<forall>q < length ?zer_list. (q + 1 < length ?zer_list) \\<longrightarrow>\n     (?zer_list ! q) < (?zer_list ! (q +1))\""], ["proof (prove)\nusing this:\n  strict_sorted\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n\ngoal (1 subgoal):\n 1. \\<forall>q<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n       q + 1\n       < length\n          (sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q\n       < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (q + 1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       Suc q\n       < card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<Longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q\n       < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         Suc q", "using lessI sorted_wrt_iff_nth_less strict_sorted_sorted_wrt"], ["proof (prove)\nusing this:\n  ?n < Suc ?n\n  sorted_wrt ?P ?xs =\n  (\\<forall>i j.\n      i < j \\<longrightarrow>\n      j < length ?xs \\<longrightarrow> ?P (?xs ! i) (?xs ! j))\n  strict_sorted = sorted_wrt (<)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       Suc q\n       < card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<Longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q\n       < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         Suc q", "by (metis (no_types, lifting) length_sorted_list_of_set strict_sorted_h)"], ["proof (state)\nthis:\n  \\<forall>q<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     q + 1\n     < length\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q\n     < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (q + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  \\<forall>q<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     q + 1\n     < length\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q\n     < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (q + 1)", "have sorted_hyp_var: \"\\<forall>q1 < length ?zer_list. \\<forall>q2 < length ?zer_list. (q1 < q2 \\<longrightarrow>\n     (?zer_list ! q1) < (?zer_list ! q2))\""], ["proof (prove)\nusing this:\n  \\<forall>q<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     q + 1\n     < length\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q\n     < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (q + 1)\n\ngoal (1 subgoal):\n 1. \\<forall>q1<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n       \\<forall>q2<length\n                    (sorted_list_of_set\n                      {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n          q1 < q2 \\<longrightarrow>\n          sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n          < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            q2", "by (metis (no_types, lifting) sorted_wrt_iff_nth_less strict_sorted_h strict_sorted_sorted_wrt)"], ["proof (state)\nthis:\n  \\<forall>q1<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     \\<forall>q2<length\n                  (sorted_list_of_set\n                    {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n        q1 < q2 \\<longrightarrow>\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n        < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q2\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  \\<forall>q1<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     \\<forall>q2<length\n                  (sorted_list_of_set\n                    {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n        q1 < q2 \\<longrightarrow>\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n        < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q2", "have sorted_hyp_var2: \"\\<forall>q1 < length ?zer_list. ((?zer_list ! q1)::real) \\<le> (?zer_list ! (length ?zer_list - 1))\""], ["proof (prove)\nusing this:\n  \\<forall>q1<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     \\<forall>q2<length\n                  (sorted_list_of_set\n                    {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n        q1 < q2 \\<longrightarrow>\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n        < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q2\n\ngoal (1 subgoal):\n 1. \\<forall>q1<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n       \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             (length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n              1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q1.\n       \\<lbrakk>\\<forall>q1<card {x. \\<exists>q\\<in>set qs. rpoly q x = 0}.\n                   \\<forall>q2<card\n                                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}.\n                      q1 < q2 \\<longrightarrow>\n                      sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                      q1\n                      < sorted_list_of_set\n                         {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                        q2;\n        q1 < card {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         q1\n                         \\<le> sorted_list_of_set\n                                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                               (card\n                                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0} -\n                                Suc 0)", "by (smt (z3) Suc_pred diff_less gr_implies_not0 less_SucE zero_less_Suc)"], ["proof (state)\nthis:\n  \\<forall>q1<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n     \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1)\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have nonz_q: \"\\<forall>q \\<in>set qs. q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. q \\<noteq> 0", "using all_squarefree"], ["proof (prove)\nusing this:\n  ?q \\<in> set qs \\<Longrightarrow> rsquarefree ?q\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. q \\<noteq> 0", "unfolding rsquarefree_def"], ["proof (prove)\nusing this:\n  ?q \\<in> set qs \\<Longrightarrow>\n  ?q \\<noteq> 0 \\<and>\n  (\\<forall>a. Polynomial.order a ?q = 0 \\<or> Polynomial.order a ?q = 1)\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. q \\<noteq> 0", "using in_set_member"], ["proof (prove)\nusing this:\n  ?q \\<in> set qs \\<Longrightarrow>\n  ?q \\<noteq> 0 \\<and>\n  (\\<forall>a. Polynomial.order a ?q = 0 \\<or> Polynomial.order a ?q = 1)\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0", "have \"\\<forall>q \\<in>set qs. finite {x. rpoly q x = 0}\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. finite {x. rpoly q x = (0::'a)}", "by (simp add: poly_roots_finite)"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. finite {x. rpoly q x = (0::?'a1)}\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs. finite {x. rpoly q x = (0::?'a1)}", "have fin_set: \"finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. finite {x. rpoly q x = (0::?'a1)}\n\ngoal (1 subgoal):\n 1. finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a2)}\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have x1_and_roots: \"?zer_list \\<noteq> [] \\<longrightarrow> ((x1 < (?zer_list ! 0)) \\<or> (x1 > (?zer_list ! (length ?zer_list - 1)) \\<or>\n    (\\<exists> n < (length ?zer_list - 1). x1 > (?zer_list ! n) \\<and> x1 < (?zer_list ! (n+1)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         0 \\<or>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    < x1 \\<or>\n    (\\<exists>n<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1.\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n        < x1 \\<and>\n        x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             (n + 1))", "using roots_of_coprime_r_location_property x1_prop assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>pairwise_coprime_list ?qs;\n   \\<And>q. q \\<in> set ?qs \\<Longrightarrow> rsquarefree q;\n   ?sga = sign_vec ?qs ?x1.0; has_no_zeros ?sga;\n   ?zer_list =\n   sorted_list_of_set {x. \\<exists>q\\<in>set ?qs. rpoly q x = 0}\\<rbrakk>\n  \\<Longrightarrow> ?zer_list \\<noteq> [] \\<longrightarrow>\n                    ?x1.0 < ?zer_list ! 0 \\<or>\n                    ?zer_list ! (length ?zer_list - 1) < ?x1.0 \\<or>\n                    (\\<exists>n<length ?zer_list - 1.\n                        ?zer_list ! n < ?x1.0 \\<and>\n                        ?x1.0 < ?zer_list ! (n + 1))\n  sga = sign_vec qs x1\n  pairwise_coprime_list qs\n  ?q \\<in> set qs \\<Longrightarrow> rsquarefree ?q\n  sga = sign_vec qs x1\n  has_no_zeros sga\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         0 \\<or>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    < x1 \\<or>\n    (\\<exists>n<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1.\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n        < x1 \\<and>\n        x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             (n + 1))", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       0 \\<or>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  < x1 \\<or>\n  (\\<exists>n<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n              1.\n      sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n      < x1 \\<and>\n      x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (n + 1))\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have x2gt: \"\\<forall>x2>x1. sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow> (\\<exists>r>x1. r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x2>x1.\n       sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n       (\\<exists>r>x1.\n           r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using hnz x1_prop zero_above[of qs x1]"], ["proof (prove)\nusing this:\n  has_no_zeros sga\n  sga = sign_vec qs x1\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<forall>x2>x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r>x1.\n         r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<forall>x2>x1.\n       sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n       (\\<exists>r>x1.\n           r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "by auto"], ["proof (state)\nthis:\n  \\<forall>x2>x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r>x1.\n         r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have x2lt: \"\\<forall>x2<x1. sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow> (\\<exists>r<x1. x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x2<x1.\n       sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n       (\\<exists>r<x1.\n           x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using hnz x1_prop zero_below[of qs x1]"], ["proof (prove)\nusing this:\n  has_no_zeros sga\n  sga = sign_vec qs x1\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<forall>x2<x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r<x1.\n         x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<forall>x2<x1.\n       sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n       (\\<exists>r<x1.\n           x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "by (auto)"], ["proof (state)\nthis:\n  \\<forall>x2<x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r<x1.\n         x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have triv_neg_inf_h: \"?zer_list = [] \\<Longrightarrow>  sga = (sign_vec qs (-crb (prod_list (cast_rat_list qs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n    [] \\<Longrightarrow>\n    sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n    [] \\<Longrightarrow>\n    sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "assume empty_zer: \"(?zer_list:: real list) = []\""], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n    [] \\<Longrightarrow>\n    sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "let ?zer_set = \"{x. \\<exists>q\\<in>set qs. rpoly q x = 0}:: real set\""], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n    [] \\<Longrightarrow>\n    sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "have fin_zer: \"finite ?zer_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "using fin_set"], ["proof (prove)\nusing this:\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a2)}\n\ngoal (1 subgoal):\n 1. finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "by auto"], ["proof (state)\nthis:\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n    [] \\<Longrightarrow>\n    sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "have \"finite ?zer_set \\<Longrightarrow> (sorted_list_of_set ?zer_set = []) = (?zer_set = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<Longrightarrow>\n    (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n    ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})", "using fin_zer sorted_list_of_set_eq_Nil_iff[where A = \"?zer_set\"]"], ["proof (prove)\nusing this:\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<Longrightarrow>\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n  ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})\n\ngoal (1 subgoal):\n 1. finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<Longrightarrow>\n    (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n    ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})", "by auto"], ["proof (state)\nthis:\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<Longrightarrow>\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n  ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n    [] \\<Longrightarrow>\n    sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<Longrightarrow>\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n  ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})", "have \"(sorted_list_of_set ?zer_set = []) = (?zer_set = {})\""], ["proof (prove)\nusing this:\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<Longrightarrow>\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n  ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})\n\ngoal (1 subgoal):\n 1. (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n    ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})", "using fin_zer"], ["proof (prove)\nusing this:\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<Longrightarrow>\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n  ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n    ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})", "by auto"], ["proof (state)\nthis:\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n  ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n    [] \\<Longrightarrow>\n    sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n  ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})", "have nozers: \"?zer_set = {}\""], ["proof (prove)\nusing this:\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n  ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})\n\ngoal (1 subgoal):\n 1. {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {}", "using empty_zer"], ["proof (prove)\nusing this:\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []) =\n  ({x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {})\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = []\n\ngoal (1 subgoal):\n 1. {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {}", "by auto"], ["proof (state)\nthis:\n  {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {}\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n    [] \\<Longrightarrow>\n    sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {}", "have \"\\<not>(\\<exists>(r::real). (\\<exists>(q::rat poly)\\<in>set qs. rpoly q r = 0))\""], ["proof (prove)\nusing this:\n  {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {}\n\ngoal (1 subgoal):\n 1. \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0", "using nozers"], ["proof (prove)\nusing this:\n  {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {}\n  {x. \\<exists>q\\<in>set qs. rpoly q x = 0} = {}\n\ngoal (1 subgoal):\n 1. \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0", "by auto"], ["proof (state)\nthis:\n  \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n    [] \\<Longrightarrow>\n    sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0", "have \"\\<forall>y. sign_vec qs x1 = sign_vec qs y\""], ["proof (prove)\nusing this:\n  \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0\n\ngoal (1 subgoal):\n 1. \\<forall>y. sign_vec qs x1 = sign_vec qs y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n    \\<forall>y. sign_vec qs x1 = sign_vec qs y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n    \\<forall>y. sign_vec qs x1 = sign_vec qs y", "have gt_prop: \"x1 > y \\<longrightarrow> sign_vec qs x1 = sign_vec qs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs y", "using hnz x1_prop zero_below[of qs x1]"], ["proof (prove)\nusing this:\n  has_no_zeros sga\n  sga = sign_vec qs x1\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<forall>x2<x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r<x1.\n         x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. y < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs y", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_no_zeros (sign_vec qs x1); sga = sign_vec qs x1;\n     \\<forall>x2<x1.\n        sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n        (\\<exists>r<x1.\n            x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     y < x1\\<rbrakk>\n    \\<Longrightarrow> sign_vec qs x1 = sign_vec qs y", "using \\<open>\\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_no_zeros (sign_vec qs x1); sga = sign_vec qs x1;\n     \\<forall>x2<x1.\n        sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n        (\\<exists>r<x1.\n            x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     y < x1\\<rbrakk>\n    \\<Longrightarrow> sign_vec qs x1 = sign_vec qs y", "by blast"], ["proof (state)\nthis:\n  y < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n    \\<forall>y. sign_vec qs x1 = sign_vec qs y", "have lt_prop: \"x1 < y \\<longrightarrow> sign_vec qs x1 = sign_vec qs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 < y \\<longrightarrow> sign_vec qs x1 = sign_vec qs y", "using zero_above[of qs x1]"], ["proof (prove)\nusing this:\n  has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n  \\<forall>x2>x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r>x1.\n         r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. x1 < y \\<longrightarrow> sign_vec qs x1 = sign_vec qs y", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<forall>x2>x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r>x1.\n                    r \\<le> x2 \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     x1 < y\\<rbrakk>\n    \\<Longrightarrow> sign_vec qs x1 = sign_vec qs y", "using \\<open>\\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0\\<close> x2gt"], ["proof (prove)\nusing this:\n  \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0\n  \\<forall>x2>x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r>x1.\n         r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_no_zeros (sign_vec qs x1) \\<Longrightarrow>\n             \\<forall>x2>x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r>x1.\n                    r \\<le> x2 \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     x1 < y\\<rbrakk>\n    \\<Longrightarrow> sign_vec qs x1 = sign_vec qs y", "by blast"], ["proof (state)\nthis:\n  x1 < y \\<longrightarrow> sign_vec qs x1 = sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n    \\<forall>y. sign_vec qs x1 = sign_vec qs y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. sign_vec qs x1 = sign_vec qs y", "using gt_prop lt_prop"], ["proof (prove)\nusing this:\n  y < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs y\n  x1 < y \\<longrightarrow> sign_vec qs x1 = sign_vec qs y\n\ngoal (1 subgoal):\n 1. \\<forall>y. sign_vec qs x1 = sign_vec qs y", "apply (auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ya. y = x1 \\<Longrightarrow> sign_vec qs x1 = sign_vec qs ya\n 2. \\<And>ya.\n       \\<lbrakk>\\<not> y < x1; sign_vec qs x1 = sign_vec qs y\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya\n 3. \\<And>ya.\n       \\<lbrakk>sign_vec qs x1 = sign_vec qs y; \\<not> x1 < y\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya\n 4. \\<And>ya.\n       sign_vec qs x1 = sign_vec qs y \\<Longrightarrow>\n       sign_vec qs y = sign_vec qs ya", "apply (metis \\<open>\\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0\\<close> linorder_neqE_linordered_idom x2gt x2lt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ya.\n       \\<lbrakk>\\<not> y < x1; sign_vec qs x1 = sign_vec qs y\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya\n 2. \\<And>ya.\n       \\<lbrakk>sign_vec qs x1 = sign_vec qs y; \\<not> x1 < y\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya\n 3. \\<And>ya.\n       sign_vec qs x1 = sign_vec qs y \\<Longrightarrow>\n       sign_vec qs y = sign_vec qs ya", "using x2gt x2lt"], ["proof (prove)\nusing this:\n  \\<forall>x2>x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r>x1.\n         r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  \\<forall>x2<x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r<x1.\n         x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (3 subgoals):\n 1. \\<And>ya.\n       \\<lbrakk>\\<not> y < x1; sign_vec qs x1 = sign_vec qs y\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya\n 2. \\<And>ya.\n       \\<lbrakk>sign_vec qs x1 = sign_vec qs y; \\<not> x1 < y\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya\n 3. \\<And>ya.\n       sign_vec qs x1 = sign_vec qs y \\<Longrightarrow>\n       sign_vec qs y = sign_vec qs ya", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ya.\n       \\<lbrakk>\\<not> y < x1; sign_vec qs x1 = sign_vec qs y;\n        \\<forall>x2>x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r>x1.\n               r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0));\n        \\<forall>x2<x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r<x1.\n               x2 \\<le> r \\<and>\n               (\\<exists>q\\<in>set qs. rpoly q r = 0))\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya\n 2. \\<And>ya.\n       \\<lbrakk>sign_vec qs x1 = sign_vec qs y; \\<not> x1 < y;\n        \\<forall>x2>x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r>x1.\n               r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0));\n        \\<forall>x2<x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r<x1.\n               x2 \\<le> r \\<and>\n               (\\<exists>q\\<in>set qs. rpoly q r = 0))\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya\n 3. \\<And>ya.\n       \\<lbrakk>sign_vec qs x1 = sign_vec qs y;\n        \\<forall>x2>x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r>x1.\n               r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0));\n        \\<forall>x2<x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r<x1.\n               x2 \\<le> r \\<and>\n               (\\<exists>q\\<in>set qs. rpoly q r = 0))\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya", "apply (metis \\<open>\\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0\\<close> linorder_neqE_linordered_idom)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ya.\n       \\<lbrakk>sign_vec qs x1 = sign_vec qs y; \\<not> x1 < y;\n        \\<forall>x2>x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r>x1.\n               r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0));\n        \\<forall>x2<x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r<x1.\n               x2 \\<le> r \\<and>\n               (\\<exists>q\\<in>set qs. rpoly q r = 0))\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya\n 2. \\<And>ya.\n       \\<lbrakk>sign_vec qs x1 = sign_vec qs y;\n        \\<forall>x2>x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r>x1.\n               r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0));\n        \\<forall>x2<x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r<x1.\n               x2 \\<le> r \\<and>\n               (\\<exists>q\\<in>set qs. rpoly q r = 0))\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya", "apply (metis \\<open>\\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0\\<close> linorder_neqE_linordered_idom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>sign_vec qs x1 = sign_vec qs y;\n        \\<forall>x2>x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r>x1.\n               r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0));\n        \\<forall>x2<x1.\n           sign_vec qs y \\<noteq> sign_vec qs x2 \\<longrightarrow>\n           (\\<exists>r<x1.\n               x2 \\<le> r \\<and>\n               (\\<exists>q\\<in>set qs. rpoly q r = 0))\\<rbrakk>\n       \\<Longrightarrow> sign_vec qs y = sign_vec qs ya", "by (metis \\<open>\\<nexists>r. \\<exists>q\\<in>set qs. rpoly q r = 0\\<close> linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  \\<forall>y. sign_vec qs x1 = sign_vec qs y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y. sign_vec qs x1 = sign_vec qs y\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n    [] \\<Longrightarrow>\n    sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  \\<forall>y. sign_vec qs x1 = sign_vec qs y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y. sign_vec qs x1 = sign_vec qs y\n\ngoal (1 subgoal):\n 1. sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "by (simp add: x1_prop)"], ["proof (state)\nthis:\n  sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n  [] \\<Longrightarrow>\n  sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have neg_inf_h: \"?zer_list \\<noteq>[] \\<Longrightarrow> (x1 < (?zer_list ! 0) \\<Longrightarrow> sga = (sign_vec qs (-crb (prod_list (cast_rat_list qs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "let ?neg_crb = \"-crb (prod_list (cast_rat_list qs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "assume len_nontriv: \"?zer_list \\<noteq>[]\""], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "assume x1_lt: \"x1 < ?zer_list ! 0\""], ["proof (state)\nthis:\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "have r_gt: \"\\<forall>r. (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<longrightarrow> r \\<ge> (?zer_list ! 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r.\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<longrightarrow>\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n       \\<le> r", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r q.\n       \\<lbrakk>q \\<in> set qs; rpoly q r = 0\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         0\n                         \\<le> r", "fix q::\"rat poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r q.\n       \\<lbrakk>q \\<in> set qs; rpoly q r = 0\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         0\n                         \\<le> r", "fix r:: \"real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r q.\n       \\<lbrakk>q \\<in> set qs; rpoly q r = 0\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         0\n                         \\<le> r", "assume q_in: \"q \\<in> set qs\""], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>r q.\n       \\<lbrakk>q \\<in> set qs; rpoly q r = 0\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         0\n                         \\<le> r", "assume \"rpoly q r = 0\""], ["proof (state)\nthis:\n  rpoly q r = 0\n\ngoal (1 subgoal):\n 1. \\<And>r q.\n       \\<lbrakk>q \\<in> set qs; rpoly q r = 0\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         0\n                         \\<le> r", "then"], ["proof (chain)\npicking this:\n  rpoly q r = 0", "have \"r \\<in>  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\""], ["proof (prove)\nusing this:\n  rpoly q r = 0\n\ngoal (1 subgoal):\n 1. r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "using q_in"], ["proof (prove)\nusing this:\n  rpoly q r = 0\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "by auto"], ["proof (state)\nthis:\n  r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>r q.\n       \\<lbrakk>q \\<in> set qs; rpoly q r = 0\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         0\n                         \\<le> r", "then"], ["proof (chain)\npicking this:\n  r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "have \"List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) r\""], ["proof (prove)\nusing this:\n  r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) r", "using  in_set_member set_sorted_list_of_set fin_set"], ["proof (prove)\nusing this:\n  r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a2)}\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) r", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>\\<And>x xs. (x \\<in> set xs) = List.member xs x;\n        \\<And>A. finite A \\<Longrightarrow> set (sorted_list_of_set A) = A;\n        \\<forall>q\\<in>set qs. finite {x. rpoly q x = (0::?'a7)};\n        q \\<in> set qs; rpoly q r = 0\\<rbrakk>\n       \\<Longrightarrow> List.member\n                          (sorted_list_of_set\n                            {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                          r", "by (smt \\<open>r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\\<close> fin_set in_set_member set_sorted_list_of_set)"], ["proof (state)\nthis:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r\n\ngoal (1 subgoal):\n 1. \\<And>r q.\n       \\<lbrakk>q \\<in> set qs; rpoly q r = 0\\<rbrakk>\n       \\<Longrightarrow> sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                         0\n                         \\<le> r", "then"], ["proof (chain)\npicking this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r", "show \"sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0 \\<le> r\""], ["proof (prove)\nusing this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0 \\<le> r", "using sorted_hyp_var"], ["proof (prove)\nusing this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r\n  \\<forall>q1<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     \\<forall>q2<length\n                  (sorted_list_of_set\n                    {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n        q1 < q2 \\<longrightarrow>\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n        < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q2\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0 \\<le> r", "by (metis (no_types, lifting) gr_implies_not0 in_set_conv_nth in_set_member not_less sorted_iff_nth_mono sorted_sorted_list_of_set)"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0 \\<le> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>r.\n     (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "have prod_zer: \"\\<forall>x. (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow> (poly (prod_list (cast_rat_list qs)) x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow>\n       poly (prod_list (cast_rat_list qs)) x = 0", "using prod_list_zero_iff[where xs = \"(cast_rat_list qs)\"]"], ["proof (prove)\nusing this:\n  (prod_list (cast_rat_list qs) = 0) = (0 \\<in> set (cast_rat_list qs))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow>\n       poly (prod_list (cast_rat_list qs)) x = 0", "unfolding cast_rat_list_def"], ["proof (prove)\nusing this:\n  (prod_list (map real_of_rat_poly qs) = 0) =\n  (0 \\<in> set (map real_of_rat_poly qs))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow>\n       poly (prod_list (map real_of_rat_poly qs)) x = 0", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; rpoly q x = 0; 0 \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> rpoly (prod_list qs) x = 0\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; rpoly q x = 0; 0 \\<notin> set qs;\n        0 \\<notin> real_of_rat_poly ` set qs\\<rbrakk>\n       \\<Longrightarrow> rpoly (prod_list qs) x = 0", "using nonz_q"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; rpoly q x = 0; 0 \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> rpoly (prod_list qs) x = 0\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; rpoly q x = 0; 0 \\<notin> set qs;\n        0 \\<notin> real_of_rat_poly ` set qs\\<rbrakk>\n       \\<Longrightarrow> rpoly (prod_list qs) x = 0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; rpoly q x = 0; 0 \\<notin> set qs;\n        0 \\<notin> real_of_rat_poly ` set qs\\<rbrakk>\n       \\<Longrightarrow> rpoly (prod_list qs) x = 0", "by (metis (no_types, hide_lams) image_eqI list.set_map of_rat_poly_hom.prod_list_map_hom poly_prod_list_zero_iff)"], ["proof (state)\nthis:\n  \\<forall>x.\n     (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow>\n     poly (prod_list (cast_rat_list qs)) x = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "have \"?zer_list \\<noteq>[] \\<longrightarrow> List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n     (?zer_list ! 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0)", "using nth_Cons_0"], ["proof (prove)\nusing this:\n  (?x # ?xs) ! 0 = ?x\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<Longrightarrow>\n    List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0)", "by (meson gr0I in_set_member length_0_conv nth_mem)"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0)", "have \"?zer_list \\<noteq>[] \\<longrightarrow> (?zer_list ! 0)\n   \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\""], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "using in_set_member[where x = \"(sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0)\",\n          where xs = \"sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\"]\n          set_sorted_list_of_set fin_set"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0)\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a3)} ! 0\n   \\<in> set (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a3)})) =\n  List.member\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a3)})\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a3)} !\n    0)\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a2)}\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n    \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "by blast"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "have \"?zer_list \\<noteq>[] \\<longrightarrow> (\\<exists>q\\<in>set qs. rpoly q (?zer_list ! 0) = 0)\""], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    (\\<exists>q\\<in>set qs.\n        rpoly q\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0) =\n        0)", "by blast"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  (\\<exists>q\\<in>set qs.\n      rpoly q\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0) =\n      0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  (\\<exists>q\\<in>set qs.\n      rpoly q\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0) =\n      0)", "have poly_zer: \"?zer_list \\<noteq>[] \\<longrightarrow> (poly (prod_list (cast_rat_list qs)) (?zer_list ! 0)) = 0\""], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  (\\<exists>q\\<in>set qs.\n      rpoly q\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0) =\n      0)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    poly (prod_list (cast_rat_list qs))\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0) =\n    0", "using prod_zer"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  (\\<exists>q\\<in>set qs.\n      rpoly q\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0) =\n      0)\n  \\<forall>x.\n     (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow>\n     poly (prod_list (cast_rat_list qs)) x = 0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    poly (prod_list (cast_rat_list qs))\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  poly (prod_list (cast_rat_list qs))\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0) =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "have \"\\<forall>q. List.member (cast_rat_list qs) q \\<longrightarrow>q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0", "using nonz_q"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0", "unfolding cast_rat_list_def"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (map real_of_rat_poly qs) q \\<longrightarrow>\n       q \\<noteq> 0", "using in_set_member imageE image_set map_poly_zero of_rat_eq_0_iff"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  \\<lbrakk>?b \\<in> ?f ` ?A;\n   \\<And>x.\n      \\<lbrakk>?b = ?f x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?f ` set ?xs = set (map ?f ?xs)\n  \\<forall>c.\n     ?f c = (0::?'b) \\<longrightarrow> c = (0::?'a) \\<Longrightarrow>\n  (map_poly ?f ?p = 0) = (?p = 0)\n  (of_rat ?a = (0::?'a)) = (?a = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (map real_of_rat_poly qs) q \\<longrightarrow>\n       q \\<noteq> 0", "by smt"], ["proof (state)\nthis:\n  \\<forall>q.\n     List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  \\<forall>q.\n     List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0", "have \"(prod_list (cast_rat_list qs)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>q.\n     List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list (cast_rat_list qs) \\<noteq> 0", "using prod_list_zero_iff in_set_member"], ["proof (prove)\nusing this:\n  \\<forall>q.\n     List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0\n  (prod_list ?xs = (0::?'a)) = ((0::?'a) \\<in> set ?xs)\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. prod_list (cast_rat_list qs) \\<noteq> 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                List.member (cast_rat_list qs) q \\<longrightarrow>\n                q \\<noteq> 0;\n     \\<And>x xs. (x \\<in> set xs) = List.member xs x;\n     0 \\<in> set (cast_rat_list qs)\\<rbrakk>\n    \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  prod_list (cast_rat_list qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  prod_list (cast_rat_list qs) \\<noteq> 0", "have crb_lt: \"?zer_list \\<noteq>[] \\<longrightarrow> ?neg_crb < ?zer_list ! 0\""], ["proof (prove)\nusing this:\n  prod_list (cast_rat_list qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    real_of_int (- crb (prod_list (cast_rat_list qs)))\n    < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0", "using crb_lem_neg[where p = \"(prod_list (cast_rat_list qs))\", where x = \"sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\"]"], ["proof (prove)\nusing this:\n  prod_list (cast_rat_list qs) \\<noteq> 0\n  \\<lbrakk>poly (prod_list (cast_rat_list qs))\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             0) =\n           0;\n   prod_list (cast_rat_list qs) \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> real_of_int (- crb (prod_list (cast_rat_list qs)))\n                    < sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                      0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    real_of_int (- crb (prod_list (cast_rat_list qs)))\n    < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> set (cast_rat_list qs);\n     poly (prod_list (cast_rat_list qs))\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0) =\n     0 \\<Longrightarrow>\n     - real_of_int (crb (prod_list (cast_rat_list qs)))\n     < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0;\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n     []\\<rbrakk>\n    \\<Longrightarrow> - real_of_int (crb (prod_list (cast_rat_list qs)))\n                      < sorted_list_of_set\n                         {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                        0", "using poly_zer"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  poly (prod_list (cast_rat_list qs))\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0) =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> set (cast_rat_list qs);\n     poly (prod_list (cast_rat_list qs))\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0) =\n     0 \\<Longrightarrow>\n     - real_of_int (crb (prod_list (cast_rat_list qs)))\n     < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0;\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n     []\\<rbrakk>\n    \\<Longrightarrow> - real_of_int (crb (prod_list (cast_rat_list qs)))\n                      < sorted_list_of_set\n                         {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                        0", "by blast"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  real_of_int (- crb (prod_list (cast_rat_list qs)))\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "have crb_gt_x1: \"?zer_list \\<noteq>[] \\<longrightarrow> (?neg_crb > x1 \\<longrightarrow> (sga \\<noteq> (sign_vec qs ?neg_crb)) \\<longrightarrow> (\\<exists>r>x1. r \\<le> ?neg_crb \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    x1 < real_of_int\n          (- crb (prod_list (cast_rat_list qs))) \\<longrightarrow>\n    sga \\<noteq>\n    sign_vec qs\n     (real_of_int (- crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n    (\\<exists>r.\n        x1 < real_of_int r \\<and>\n        r \\<le> - crb (prod_list (cast_rat_list qs)) \\<and>\n        (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))", "using x2gt"], ["proof (prove)\nusing this:\n  \\<forall>x2>x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r>x1.\n         r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    x1 < real_of_int\n          (- crb (prod_list (cast_rat_list qs))) \\<longrightarrow>\n    sga \\<noteq>\n    sign_vec qs\n     (real_of_int (- crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n    (\\<exists>r.\n        x1 < real_of_int r \\<and>\n        r \\<le> - crb (prod_list (cast_rat_list qs)) \\<and>\n        (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x2>x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r>x1.\n                    r \\<le> x2 \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n     [];\n     x1 < - real_of_int (crb (prod_list (cast_rat_list qs)));\n     sga \\<noteq>\n     sign_vec qs\n      (- real_of_int (crb (prod_list (cast_rat_list qs))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         x1 < real_of_int r \\<and>\n                         r \\<le> - crb (prod_list (cast_rat_list qs)) \\<and>\n                         (\\<exists>q\\<in>set qs.\n                             rpoly q (real_of_int r) = 0)", "using crb_lt r_gt x1_prop"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  real_of_int (- crb (prod_list (cast_rat_list qs)))\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<forall>r.\n     (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> r\n  sga = sign_vec qs x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x2>x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r>x1.\n                    r \\<le> x2 \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n     [];\n     x1 < - real_of_int (crb (prod_list (cast_rat_list qs)));\n     sga \\<noteq>\n     sign_vec qs\n      (- real_of_int (crb (prod_list (cast_rat_list qs))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         x1 < real_of_int r \\<and>\n                         r \\<le> - crb (prod_list (cast_rat_list qs)) \\<and>\n                         (\\<exists>q\\<in>set qs.\n                             rpoly q (real_of_int r) = 0)", "by fastforce"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  x1 < real_of_int (- crb (prod_list (cast_rat_list qs))) \\<longrightarrow>\n  sga \\<noteq>\n  sign_vec qs\n   (real_of_int (- crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n  (\\<exists>r.\n      x1 < real_of_int r \\<and>\n      r \\<le> - crb (prod_list (cast_rat_list qs)) \\<and>\n      (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "have crb_lt_x1: \"?neg_crb < x1 \\<longrightarrow> (sga \\<noteq> (sign_vec qs ?neg_crb)) \\<longrightarrow> (\\<exists>r<x1. ?neg_crb \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (- crb (prod_list (cast_rat_list qs)))\n    < x1 \\<longrightarrow>\n    sga \\<noteq>\n    sign_vec qs\n     (real_of_int (- crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n    (\\<exists>r.\n        real_of_int r < x1 \\<and>\n        - crb (prod_list (cast_rat_list qs)) \\<le> r \\<and>\n        (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))", "using x2lt"], ["proof (prove)\nusing this:\n  \\<forall>x2<x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r<x1.\n         x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. real_of_int (- crb (prod_list (cast_rat_list qs)))\n    < x1 \\<longrightarrow>\n    sga \\<noteq>\n    sign_vec qs\n     (real_of_int (- crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n    (\\<exists>r.\n        real_of_int r < x1 \\<and>\n        - crb (prod_list (cast_rat_list qs)) \\<le> r \\<and>\n        (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x2<x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r<x1.\n                    x2 \\<le> r \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     - real_of_int (crb (prod_list (cast_rat_list qs))) < x1;\n     sga \\<noteq>\n     sign_vec qs\n      (- real_of_int (crb (prod_list (cast_rat_list qs))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         real_of_int r < x1 \\<and>\n                         - crb (prod_list (cast_rat_list qs)) \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs.\n                             rpoly q (real_of_int r) = 0)", "using x1_lt r_gt x1_prop"], ["proof (prove)\nusing this:\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<forall>r.\n     (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> r\n  sga = sign_vec qs x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x2<x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r<x1.\n                    x2 \\<le> r \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     - real_of_int (crb (prod_list (cast_rat_list qs))) < x1;\n     sga \\<noteq>\n     sign_vec qs\n      (- real_of_int (crb (prod_list (cast_rat_list qs))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         real_of_int r < x1 \\<and>\n                         - crb (prod_list (cast_rat_list qs)) \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs.\n                             rpoly q (real_of_int r) = 0)", "by fastforce"], ["proof (state)\nthis:\n  real_of_int (- crb (prod_list (cast_rat_list qs))) < x1 \\<longrightarrow>\n  sga \\<noteq>\n  sign_vec qs\n   (real_of_int (- crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n  (\\<exists>r.\n      real_of_int r < x1 \\<and>\n      - crb (prod_list (cast_rat_list qs)) \\<le> r \\<and>\n      (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          0\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (- crb (prod_list (cast_rat_list qs))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "using len_nontriv crb_gt_x1 crb_lt_x1  x1_lt crb_lt r_gt"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> []\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  x1 < real_of_int (- crb (prod_list (cast_rat_list qs))) \\<longrightarrow>\n  sga \\<noteq>\n  sign_vec qs\n   (real_of_int (- crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n  (\\<exists>r.\n      x1 < real_of_int r \\<and>\n      r \\<le> - crb (prod_list (cast_rat_list qs)) \\<and>\n      (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))\n  real_of_int (- crb (prod_list (cast_rat_list qs))) < x1 \\<longrightarrow>\n  sga \\<noteq>\n  sign_vec qs\n   (real_of_int (- crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n  (\\<exists>r.\n      real_of_int r < x1 \\<and>\n      - crb (prod_list (cast_rat_list qs)) \\<le> r \\<and>\n      (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  real_of_int (- crb (prod_list (cast_rat_list qs)))\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n  \\<forall>r.\n     (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n     \\<le> r\n\ngoal (1 subgoal):\n 1. sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     - real_of_int (crb (prod_list (cast_rat_list qs)))\n     < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0;\n     \\<forall>r.\n        (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<longrightarrow>\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n        \\<le> r;\n     x1 = - real_of_int (crb (prod_list (cast_rat_list qs)))\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (- real_of_int (crb (prod_list (cast_rat_list qs))))", "using x1_prop"], ["proof (prove)\nusing this:\n  sga = sign_vec qs x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     - real_of_int (crb (prod_list (cast_rat_list qs)))\n     < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0;\n     \\<forall>r.\n        (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<longrightarrow>\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! 0\n        \\<le> r;\n     x1 = - real_of_int (crb (prod_list (cast_rat_list qs)))\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (- real_of_int (crb (prod_list (cast_rat_list qs))))", "by blast"], ["proof (state)\nthis:\n  sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n           [];\n   x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        0\\<rbrakk>\n  \\<Longrightarrow> sga =\n                    sign_vec qs\n                     (real_of_int (- crb (prod_list (cast_rat_list qs))))\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have pos_inf_h: \"?zer_list \\<noteq> [] \\<Longrightarrow> (x1 > (?zer_list ! (length ?zer_list - 1)) \\<Longrightarrow> sga = (sign_vec qs (crb (prod_list (cast_rat_list qs)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "let ?pos_crb = \"crb (prod_list (cast_rat_list qs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "assume len_nontriv: \"?zer_list \\<noteq>[]\""], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "assume x1_lt: \"x1 > ?zer_list ! (length ?zer_list - 1)\""], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  < x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "have r_gt: \"\\<And>r. (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow> r \\<le> (?zer_list ! (length ?zer_list - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n       r \\<le> sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               (length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n       r \\<le> sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               (length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1)", "fix r:: \"real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n       r \\<le> sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               (length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1)", "assume q_in: \"(\\<exists>q\\<in>set qs. rpoly q r = 0)\""], ["proof (state)\nthis:\n  \\<exists>q\\<in>set qs. rpoly q r = 0\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n       r \\<le> sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               (length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1)", "then"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>set qs. rpoly q r = 0", "obtain q::\"rat poly\" where q_prop: \"q \\<in> set qs \\<and> rpoly q r = 0\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>set qs. rpoly q r = 0\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> set qs \\<and> rpoly q r = 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> set qs \\<and> rpoly q r = 0\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n       r \\<le> sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               (length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1)", "then"], ["proof (chain)\npicking this:\n  q \\<in> set qs \\<and> rpoly q r = 0", "have \"r \\<in>  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\""], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> rpoly q r = 0\n\ngoal (1 subgoal):\n 1. r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "using q_in"], ["proof (prove)\nusing this:\n  q \\<in> set qs \\<and> rpoly q r = 0\n  \\<exists>q\\<in>set qs. rpoly q r = 0\n\ngoal (1 subgoal):\n 1. r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "by auto"], ["proof (state)\nthis:\n  r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n       r \\<le> sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               (length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1)", "then"], ["proof (chain)\npicking this:\n  r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "have \"List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) r\""], ["proof (prove)\nusing this:\n  r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) r", "using in_set_member set_sorted_list_of_set fin_set"], ["proof (prove)\nusing this:\n  r \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a2)}\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) r", "by smt"], ["proof (state)\nthis:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n       r \\<le> sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               (length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1)", "then"], ["proof (chain)\npicking this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r", "have \"\\<exists>n < (length ?zer_list). r = ?zer_list ! n\""], ["proof (prove)\nusing this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n       r = sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n", "by (metis (no_types, lifting) in_set_conv_nth in_set_member)"], ["proof (state)\nthis:\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     r = sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n       r \\<le> sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               (length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     r = sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n", "obtain n where n_prop: \"n < length ?zer_list \\<and> r = ?zer_list ! n\""], ["proof (prove)\nusing this:\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     r = sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n < length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<and>\n        r =\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<and>\n  r = sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n       r \\<le> sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               (length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                1)", "then"], ["proof (chain)\npicking this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<and>\n  r = sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n", "show \"r \\<le> (?zer_list ! (length ?zer_list - 1))\""], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<and>\n  r = sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n\ngoal (1 subgoal):\n 1. r \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<and>\n    r =\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    n \\<Longrightarrow>\n    r \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1)", "have \"\\<forall>q1. q1 < length ?zer_list \\<longrightarrow> (?zer_list ! q1) \\<le> (?zer_list ! (length ?zer_list - 1:: nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q1<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n       \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             (length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n              1)", "using sorted_hyp_var2"], ["proof (prove)\nusing this:\n  \\<forall>q1<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n     \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1)\n\ngoal (1 subgoal):\n 1. \\<forall>q1<length\n                 (sorted_list_of_set\n                   {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n       \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             (length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n              1)", "by auto"], ["proof (state)\nthis:\n  \\<forall>q1<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n     \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1)\n\ngoal (1 subgoal):\n 1. n < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<and>\n    r =\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    n \\<Longrightarrow>\n    r \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1)", "then"], ["proof (chain)\npicking this:\n  \\<forall>q1<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n     \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1)", "have \"(?zer_list ! n) \\<le> (?zer_list ! (length ?zer_list - 1))\""], ["proof (prove)\nusing this:\n  \\<forall>q1<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n     \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n    \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1)", "using n_prop"], ["proof (prove)\nusing this:\n  \\<forall>q1<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q1\n     \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1)\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<and>\n  r = sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n    \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1)", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)\n\ngoal (1 subgoal):\n 1. n < length\n         (sorted_list_of_set\n           {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<and>\n    r =\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    n \\<Longrightarrow>\n    r \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1)", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)\n\ngoal (1 subgoal):\n 1. r \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1)", "using n_prop"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<and>\n  r = sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n\ngoal (1 subgoal):\n 1. r \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1)", "by auto"], ["proof (state)\nthis:\n  r \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set qs. rpoly q ?r2 = 0 \\<Longrightarrow>\n  ?r2\n  \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "have prod_zer: \"\\<forall>x. (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow> (poly (prod_list (cast_rat_list qs)) x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow>\n       poly (prod_list (cast_rat_list qs)) x = 0", "using prod_list_zero_iff[where xs = \"(cast_rat_list qs)\"]"], ["proof (prove)\nusing this:\n  (prod_list (cast_rat_list qs) = 0) = (0 \\<in> set (cast_rat_list qs))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow>\n       poly (prod_list (cast_rat_list qs)) x = 0", "unfolding cast_rat_list_def"], ["proof (prove)\nusing this:\n  (prod_list (map real_of_rat_poly qs) = 0) =\n  (0 \\<in> set (map real_of_rat_poly qs))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow>\n       poly (prod_list (map real_of_rat_poly qs)) x = 0", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; rpoly q x = 0; 0 \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> rpoly (prod_list qs) x = 0\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; rpoly q x = 0; 0 \\<notin> set qs;\n        0 \\<notin> real_of_rat_poly ` set qs\\<rbrakk>\n       \\<Longrightarrow> rpoly (prod_list qs) x = 0", "using nonz_q"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; rpoly q x = 0; 0 \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> rpoly (prod_list qs) x = 0\n 2. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; rpoly q x = 0; 0 \\<notin> set qs;\n        0 \\<notin> real_of_rat_poly ` set qs\\<rbrakk>\n       \\<Longrightarrow> rpoly (prod_list qs) x = 0", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x q.\n       \\<lbrakk>q \\<in> set qs; rpoly q x = 0; 0 \\<notin> set qs;\n        0 \\<notin> real_of_rat_poly ` set qs\\<rbrakk>\n       \\<Longrightarrow> rpoly (prod_list qs) x = 0", "by (metis (no_types, hide_lams) image_eqI list.set_map of_rat_poly_hom.prod_list_map_hom poly_prod_list_zero_iff)"], ["proof (state)\nthis:\n  \\<forall>x.\n     (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow>\n     poly (prod_list (cast_rat_list qs)) x = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "have \"?zer_list \\<noteq>[] \\<longrightarrow> List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n     (?zer_list ! (length ?zer_list -1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n      (length\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n       1))", "using nth_Cons_0"], ["proof (prove)\nusing this:\n  (?x # ?xs) ! 0 = ?x\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n      (length\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n       1))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<Longrightarrow>\n    List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n      (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0))", "by (metis (no_types, lifting) diff_less in_set_conv_nth in_set_member length_greater_0_conv length_sorted_list_of_set zero_less_Suc)"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1))", "have \"?zer_list \\<noteq>[] \\<longrightarrow> (?zer_list ! (length ?zer_list -1))\n   \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\""], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1))\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "using in_set_member[where x = \"(sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (length ?zer_list -1))\",\n          where xs = \"sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\"]\n          set_sorted_list_of_set fin_set"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1))\n  (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a3)} !\n   (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n    1)\n   \\<in> set (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a3)})) =\n  List.member\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a3)})\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a3)} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1))\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a2)}\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "by blast"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}", "have \"?zer_list \\<noteq>[] \\<longrightarrow> (\\<exists>q\\<in>set qs. rpoly q (?zer_list ! (length ?zer_list -1)) = 0)\""], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  \\<in> {x. \\<exists>q\\<in>set qs. rpoly q x = 0}\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    (\\<exists>q\\<in>set qs.\n        rpoly q\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (length\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n           1)) =\n        0)", "by blast"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  (\\<exists>q\\<in>set qs.\n      rpoly q\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)) =\n      0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  (\\<exists>q\\<in>set qs.\n      rpoly q\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)) =\n      0)", "have poly_zer: \"?zer_list \\<noteq>[] \\<longrightarrow> (poly (prod_list (cast_rat_list qs)) (?zer_list ! (length ?zer_list -1))) = 0\""], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  (\\<exists>q\\<in>set qs.\n      rpoly q\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)) =\n      0)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    poly (prod_list (cast_rat_list qs))\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n      (length\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n       1)) =\n    0", "using prod_zer"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  (\\<exists>q\\<in>set qs.\n      rpoly q\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)) =\n      0)\n  \\<forall>x.\n     (\\<exists>q\\<in>set qs. rpoly q x = 0) \\<longrightarrow>\n     poly (prod_list (cast_rat_list qs)) x = 0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    poly (prod_list (cast_rat_list qs))\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n      (length\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n       1)) =\n    0", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  poly (prod_list (cast_rat_list qs))\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "have \"\\<forall>q. List.member (cast_rat_list qs) q \\<longrightarrow>q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0", "using nonz_q"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0", "unfolding cast_rat_list_def"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (map real_of_rat_poly qs) q \\<longrightarrow>\n       q \\<noteq> 0", "using in_set_member imageE image_set map_poly_zero of_rat_eq_0_iff"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. q \\<noteq> 0\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  \\<lbrakk>?b \\<in> ?f ` ?A;\n   \\<And>x.\n      \\<lbrakk>?b = ?f x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?f ` set ?xs = set (map ?f ?xs)\n  \\<forall>c.\n     ?f c = (0::?'b) \\<longrightarrow> c = (0::?'a) \\<Longrightarrow>\n  (map_poly ?f ?p = 0) = (?p = 0)\n  (of_rat ?a = (0::?'a)) = (?a = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (map real_of_rat_poly qs) q \\<longrightarrow>\n       q \\<noteq> 0", "by smt"], ["proof (state)\nthis:\n  \\<forall>q.\n     List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  \\<forall>q.\n     List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0", "have \"(prod_list (cast_rat_list qs)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>q.\n     List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod_list (cast_rat_list qs) \\<noteq> 0", "using prod_list_zero_iff in_set_member"], ["proof (prove)\nusing this:\n  \\<forall>q.\n     List.member (cast_rat_list qs) q \\<longrightarrow> q \\<noteq> 0\n  (prod_list ?xs = (0::?'a)) = ((0::?'a) \\<in> set ?xs)\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. prod_list (cast_rat_list qs) \\<noteq> 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                List.member (cast_rat_list qs) q \\<longrightarrow>\n                q \\<noteq> 0;\n     \\<And>x xs. (x \\<in> set xs) = List.member xs x;\n     0 \\<in> set (cast_rat_list qs)\\<rbrakk>\n    \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  prod_list (cast_rat_list qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "then"], ["proof (chain)\npicking this:\n  prod_list (cast_rat_list qs) \\<noteq> 0", "have crb_lt: \"?zer_list \\<noteq>[] \\<longrightarrow> ?pos_crb > ?zer_list ! (length ?zer_list -1)\""], ["proof (prove)\nusing this:\n  prod_list (cast_rat_list qs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    < real_of_int (crb (prod_list (cast_rat_list qs)))", "using crb_lem_pos[where p = \"(prod_list (cast_rat_list qs))\", where x = \"sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (length ?zer_list -1)\"]"], ["proof (prove)\nusing this:\n  prod_list (cast_rat_list qs) \\<noteq> 0\n  \\<lbrakk>poly (prod_list (cast_rat_list qs))\n            (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             (length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n              1)) =\n           0;\n   prod_list (cast_rat_list qs) \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sorted_list_of_set\n                     {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                    (length\n                      (sorted_list_of_set\n                        {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n                     1)\n                    < real_of_int (crb (prod_list (cast_rat_list qs)))\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)\n    < real_of_int (crb (prod_list (cast_rat_list qs)))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> set (cast_rat_list qs);\n     poly (prod_list (cast_rat_list qs))\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0)) =\n     0 \\<Longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0)\n     < real_of_int (crb (prod_list (cast_rat_list qs)));\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n     []\\<rbrakk>\n    \\<Longrightarrow> sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                      (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} -\n                       Suc 0)\n                      < real_of_int (crb (prod_list (cast_rat_list qs)))", "using poly_zer"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  poly (prod_list (cast_rat_list qs))\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n     1)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> set (cast_rat_list qs);\n     poly (prod_list (cast_rat_list qs))\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0)) =\n     0 \\<Longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0)\n     < real_of_int (crb (prod_list (cast_rat_list qs)));\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n     []\\<rbrakk>\n    \\<Longrightarrow> sorted_list_of_set\n                       {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                      (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} -\n                       Suc 0)\n                      < real_of_int (crb (prod_list (cast_rat_list qs)))", "by simp"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  < real_of_int (crb (prod_list (cast_rat_list qs)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "have crb_gt_x1: \"?zer_list \\<noteq>[] \\<longrightarrow> ((?pos_crb::real) > (x1::real) \\<longrightarrow> (sga \\<noteq> (sign_vec (qs::rat poly list) (?pos_crb::real))) \\<longrightarrow> (\\<exists>(r::real)<x1. r \\<ge> ?pos_crb \\<and> (\\<exists>(q::rat poly)\\<in>set qs. rpoly q r = 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    x1 < real_of_int (crb (prod_list (cast_rat_list qs))) \\<longrightarrow>\n    sga \\<noteq>\n    sign_vec qs\n     (real_of_int (crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n    (\\<exists>r<x1.\n        real_of_int (crb (prod_list (cast_rat_list qs))) \\<le> r \\<and>\n        (\\<exists>q\\<in>set qs. rpoly q r = 0))", "using x2gt"], ["proof (prove)\nusing this:\n  \\<forall>x2>x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r>x1.\n         r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n    [] \\<longrightarrow>\n    x1 < real_of_int (crb (prod_list (cast_rat_list qs))) \\<longrightarrow>\n    sga \\<noteq>\n    sign_vec qs\n     (real_of_int (crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n    (\\<exists>r<x1.\n        real_of_int (crb (prod_list (cast_rat_list qs))) \\<le> r \\<and>\n        (\\<exists>q\\<in>set qs. rpoly q r = 0))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x2>x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r>x1.\n                    r \\<le> x2 \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n     [];\n     x1 < real_of_int (crb (prod_list (cast_rat_list qs)));\n     sga \\<noteq>\n     sign_vec qs (real_of_int (crb (prod_list (cast_rat_list qs))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r<x1.\n                         real_of_int (crb (prod_list (cast_rat_list qs)))\n                         \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "using crb_lt r_gt x1_prop"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  < real_of_int (crb (prod_list (cast_rat_list qs)))\n  \\<exists>q\\<in>set qs. rpoly q ?r2 = 0 \\<Longrightarrow>\n  ?r2\n  \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)\n  sga = sign_vec qs x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x2>x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r>x1.\n                    r \\<le> x2 \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n     [];\n     x1 < real_of_int (crb (prod_list (cast_rat_list qs)));\n     sga \\<noteq>\n     sign_vec qs (real_of_int (crb (prod_list (cast_rat_list qs))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r<x1.\n                         real_of_int (crb (prod_list (cast_rat_list qs)))\n                         \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "using x1_lt"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  < real_of_int (crb (prod_list (cast_rat_list qs)))\n  \\<exists>q\\<in>set qs. rpoly q ?r2 = 0 \\<Longrightarrow>\n  ?r2\n  \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)\n  sga = sign_vec qs x1\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  < x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x2>x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r>x1.\n                    r \\<le> x2 \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n     [];\n     x1 < real_of_int (crb (prod_list (cast_rat_list qs)));\n     sga \\<noteq>\n     sign_vec qs (real_of_int (crb (prod_list (cast_rat_list qs))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r<x1.\n                         real_of_int (crb (prod_list (cast_rat_list qs)))\n                         \\<le> r \\<and>\n                         (\\<exists>q\\<in>set qs. rpoly q r = 0)", "by fastforce"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  x1 < real_of_int (crb (prod_list (cast_rat_list qs))) \\<longrightarrow>\n  sga \\<noteq>\n  sign_vec qs\n   (real_of_int (crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n  (\\<exists>r<x1.\n      real_of_int (crb (prod_list (cast_rat_list qs))) \\<le> r \\<and>\n      (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "have crb_lt_x1: \"?pos_crb < x1 \\<longrightarrow> (sga \\<noteq> (sign_vec qs ?pos_crb)) \\<longrightarrow> (\\<exists>r>x1. ?pos_crb \\<ge> r \\<and> (\\<exists>q\\<in>set qs. poly (real_of_rat_poly q) r = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (crb (prod_list (cast_rat_list qs))) < x1 \\<longrightarrow>\n    sga \\<noteq>\n    sign_vec qs\n     (real_of_int (crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n    (\\<exists>r.\n        x1 < real_of_int r \\<and>\n        r \\<le> crb (prod_list (cast_rat_list qs)) \\<and>\n        (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))", "using x2lt"], ["proof (prove)\nusing this:\n  \\<forall>x2<x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r<x1.\n         x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. real_of_int (crb (prod_list (cast_rat_list qs))) < x1 \\<longrightarrow>\n    sga \\<noteq>\n    sign_vec qs\n     (real_of_int (crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n    (\\<exists>r.\n        x1 < real_of_int r \\<and>\n        r \\<le> crb (prod_list (cast_rat_list qs)) \\<and>\n        (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x2<x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r<x1.\n                    x2 \\<le> r \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     real_of_int (crb (prod_list (cast_rat_list qs))) < x1;\n     sga \\<noteq>\n     sign_vec qs (real_of_int (crb (prod_list (cast_rat_list qs))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         x1 < real_of_int r \\<and>\n                         r \\<le> crb (prod_list (cast_rat_list qs)) \\<and>\n                         (\\<exists>q\\<in>set qs.\n                             rpoly q (real_of_int r) = 0)", "using x1_lt r_gt x1_prop"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  < x1\n  \\<exists>q\\<in>set qs. rpoly q ?r2 = 0 \\<Longrightarrow>\n  ?r2\n  \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)\n  sga = sign_vec qs x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x2<x1.\n                sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n                (\\<exists>r<x1.\n                    x2 \\<le> r \\<and>\n                    (\\<exists>q\\<in>set qs. rpoly q r = 0));\n     real_of_int (crb (prod_list (cast_rat_list qs))) < x1;\n     sga \\<noteq>\n     sign_vec qs (real_of_int (crb (prod_list (cast_rat_list qs))))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         x1 < real_of_int r \\<and>\n                         r \\<le> crb (prod_list (cast_rat_list qs)) \\<and>\n                         (\\<exists>q\\<in>set qs.\n                             rpoly q (real_of_int r) = 0)", "by (meson \\<open>prod_list (cast_rat_list qs) \\<noteq> 0\\<close> crb_lem_pos not_less prod_zer)"], ["proof (state)\nthis:\n  real_of_int (crb (prod_list (cast_rat_list qs))) < x1 \\<longrightarrow>\n  sga \\<noteq>\n  sign_vec qs\n   (real_of_int (crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n  (\\<exists>r.\n      x1 < real_of_int r \\<and>\n      r \\<le> crb (prod_list (cast_rat_list qs)) \\<and>\n      (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1)\n     < x1\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sga = sign_vec qs (real_of_int (crb (prod_list (cast_rat_list qs))))", "using len_nontriv crb_gt_x1 crb_lt_x1  x1_lt crb_lt r_gt"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq> []\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  x1 < real_of_int (crb (prod_list (cast_rat_list qs))) \\<longrightarrow>\n  sga \\<noteq>\n  sign_vec qs\n   (real_of_int (crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n  (\\<exists>r<x1.\n      real_of_int (crb (prod_list (cast_rat_list qs))) \\<le> r \\<and>\n      (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  real_of_int (crb (prod_list (cast_rat_list qs))) < x1 \\<longrightarrow>\n  sga \\<noteq>\n  sign_vec qs\n   (real_of_int (crb (prod_list (cast_rat_list qs)))) \\<longrightarrow>\n  (\\<exists>r.\n      x1 < real_of_int r \\<and>\n      r \\<le> crb (prod_list (cast_rat_list qs)) \\<and>\n      (\\<exists>q\\<in>set qs. rpoly q (real_of_int r) = 0))\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  < x1\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  < real_of_int (crb (prod_list (cast_rat_list qs)))\n  \\<exists>q\\<in>set qs. rpoly q ?r2 = 0 \\<Longrightarrow>\n  ?r2\n  \\<le> sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (length\n          (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n         1)\n\ngoal (1 subgoal):\n 1. sga = sign_vec qs (real_of_int (crb (prod_list (cast_rat_list qs))))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0)\n     < real_of_int (crb (prod_list (cast_rat_list qs)));\n     \\<And>r.\n        \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n        r \\<le> sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0);\n     x1 = real_of_int (crb (prod_list (cast_rat_list qs)))\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "using x1_prop"], ["proof (prove)\nusing this:\n  sga = sign_vec qs x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_list_of_set\n              {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n             [];\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n     (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0)\n     < real_of_int (crb (prod_list (cast_rat_list qs)));\n     \\<And>r.\n        \\<exists>q\\<in>set qs. rpoly q r = 0 \\<Longrightarrow>\n        r \\<le> sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                (card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0);\n     x1 = real_of_int (crb (prod_list (cast_rat_list qs)))\\<rbrakk>\n    \\<Longrightarrow> sga =\n                      sign_vec qs\n                       (real_of_int (crb (prod_list (cast_rat_list qs))))", "by blast"], ["proof (state)\nthis:\n  sga = sign_vec qs (real_of_int (crb (prod_list (cast_rat_list qs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n           [];\n   sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n   (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n    1)\n   < x1\\<rbrakk>\n  \\<Longrightarrow> sga =\n                    sign_vec qs\n                     (real_of_int (crb (prod_list (cast_rat_list qs))))\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have between_h: \"(\\<exists> n < (length ?zer_list - 1). x1 > (?zer_list ! n) \\<and> x1 < (?zer_list ! (n+1))) \\<Longrightarrow> (\\<exists>w \\<in> (roots_of_coprime_r (cast_rat_list qs)). sga = (sign_vec qs w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "assume \"(\\<exists> n < (length ?zer_list - 1). x1 > (?zer_list ! n) \\<and> x1 < (?zer_list ! (n+1)))\""], ["proof (state)\nthis:\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1.\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < x1 \\<and>\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1.\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < x1 \\<and>\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1)", "obtain n where n_prop: \"n < (length ?zer_list - 1) \\<and> x1 > (?zer_list ! n) \\<and> x1 < (?zer_list ! (n+1))\""], ["proof (prove)\nusing this:\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1.\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < x1 \\<and>\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n < length\n             (sorted_list_of_set\n               {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n            1 \\<and>\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n        < x1 \\<and>\n        x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             (n + 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have \"\\<forall>q1 q2. (q1 \\<noteq> q2 \\<and> (List.member (cast_rat_list qs) q1) \\<and> (List.member (cast_rat_list qs) q2))\\<longrightarrow> coprime q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q1 q2.\n       q1 \\<noteq> q2 \\<and>\n       List.member (cast_rat_list qs) q1 \\<and>\n       List.member (cast_rat_list qs) q2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime q1 q2", "using pairwise_rel_prime coprime_rat_poly_iff_coprimereal_poly"], ["proof (prove)\nusing this:\n  pairwise_coprime_list qs\n  comm_monoid_mult_class.coprime ?p ?q =\n  comm_monoid_mult_class.coprime (real_of_rat_poly ?p) (real_of_rat_poly ?q)\n\ngoal (1 subgoal):\n 1. \\<forall>q1 q2.\n       q1 \\<noteq> q2 \\<and>\n       List.member (cast_rat_list qs) q1 \\<and>\n       List.member (cast_rat_list qs) q2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime q1 q2", "unfolding pairwise_coprime_list_def"], ["proof (prove)\nusing this:\n  \\<forall>m<length qs.\n     \\<forall>n<length qs.\n        m \\<noteq> n \\<longrightarrow>\n        comm_monoid_mult_class.coprime (qs ! n) (qs ! m)\n  comm_monoid_mult_class.coprime ?p ?q =\n  comm_monoid_mult_class.coprime (real_of_rat_poly ?p) (real_of_rat_poly ?q)\n\ngoal (1 subgoal):\n 1. \\<forall>q1 q2.\n       q1 \\<noteq> q2 \\<and>\n       List.member (cast_rat_list qs) q1 \\<and>\n       List.member (cast_rat_list qs) q2 \\<longrightarrow>\n       comm_monoid_mult_class.coprime q1 q2", "by (smt cast_rat_list_def imageE image_set in_set_conv_nth in_set_member)"], ["proof (state)\nthis:\n  \\<forall>q1 q2.\n     q1 \\<noteq> q2 \\<and>\n     List.member (cast_rat_list qs) q1 \\<and>\n     List.member (cast_rat_list qs) q2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime q1 q2\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  \\<forall>q1 q2.\n     q1 \\<noteq> q2 \\<and>\n     List.member (cast_rat_list qs) q1 \\<and>\n     List.member (cast_rat_list qs) q2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime q1 q2", "have all_prop: \"\\<forall>x1. \\<forall>x2. ((x1 < x2 \\<and> (\\<exists>q1 \\<in> set (cast_rat_list(qs)). (poly q1 x1) = 0) \\<and> (\\<exists>q2\\<in> set((cast_rat_list(qs))). (poly q2 x2) = 0)) \\<longrightarrow> (\\<exists>q. x1 < q \\<and> q < x2 \\<and> poly (coprime_r (cast_rat_list qs)) q = 0))\""], ["proof (prove)\nusing this:\n  \\<forall>q1 q2.\n     q1 \\<noteq> q2 \\<and>\n     List.member (cast_rat_list qs) q1 \\<and>\n     List.member (cast_rat_list qs) q2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime q1 q2\n\ngoal (1 subgoal):\n 1. \\<forall>x1 x2.\n       x1 < x2 \\<and>\n       (\\<exists>q1\\<in>set (cast_rat_list qs). poly q1 x1 = 0) \\<and>\n       (\\<exists>q2\\<in>set (cast_rat_list qs).\n           poly q2 x2 = 0) \\<longrightarrow>\n       (\\<exists>q>x1.\n           q < x2 \\<and> poly (coprime_r (cast_rat_list qs)) q = 0)", "using coprime_r_roots_prop"], ["proof (prove)\nusing this:\n  \\<forall>q1 q2.\n     q1 \\<noteq> q2 \\<and>\n     List.member (cast_rat_list qs) q1 \\<and>\n     List.member (cast_rat_list qs) q2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime q1 q2\n  \\<forall>q1 q2.\n     q1 \\<noteq> q2 \\<and>\n     List.member ?qs q1 \\<and> List.member ?qs q2 \\<longrightarrow>\n     comm_monoid_mult_class.coprime q1 q2 \\<Longrightarrow>\n  \\<forall>x1 x2.\n     x1 < x2 \\<and>\n     (\\<exists>q1\\<in>set ?qs. poly q1 x1 = 0) \\<and>\n     (\\<exists>q2\\<in>set ?qs. poly q2 x2 = 0) \\<longrightarrow>\n     (\\<exists>q>x1. q < x2 \\<and> poly (coprime_r ?qs) q = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>x1 x2.\n       x1 < x2 \\<and>\n       (\\<exists>q1\\<in>set (cast_rat_list qs). poly q1 x1 = 0) \\<and>\n       (\\<exists>q2\\<in>set (cast_rat_list qs).\n           poly q2 x2 = 0) \\<longrightarrow>\n       (\\<exists>q>x1.\n           q < x2 \\<and> poly (coprime_r (cast_rat_list qs)) q = 0)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x1 x2.\n     x1 < x2 \\<and>\n     (\\<exists>q1\\<in>set (cast_rat_list qs). poly q1 x1 = 0) \\<and>\n     (\\<exists>q2\\<in>set (cast_rat_list qs).\n         poly q2 x2 = 0) \\<longrightarrow>\n     (\\<exists>q>x1.\n         q < x2 \\<and> poly (coprime_r (cast_rat_list qs)) q = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have exq1: \"(\\<exists>q1 \\<in> set (cast_rat_list(qs)). (poly q1 (?zer_list ! n)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q1\\<in>set (cast_rat_list qs).\n       poly q1\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n) =\n       0", "unfolding cast_rat_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q1\\<in>set (map real_of_rat_poly qs).\n       poly q1\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n) =\n       0", "using n_prop"], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>q1\\<in>set (map real_of_rat_poly qs).\n       poly q1\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n) =\n       0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < card {x. \\<exists>q\\<in>set qs. rpoly q x = 0} - Suc 0;\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n < x1;\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          Suc n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q1\\<in>set qs.\n                         rpoly q1\n                          (sorted_list_of_set\n                            {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                           n) =\n                         0", "by (smt (verit, ccfv_SIG) One_nat_def Suc_eq_plus1 Suc_lessD fin_set length_sorted_list_of_set less_diff_conv mem_Collect_eq nth_mem set_sorted_list_of_set)"], ["proof (state)\nthis:\n  \\<exists>q1\\<in>set (cast_rat_list qs).\n     poly q1\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n) =\n     0\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have exq2: \"(\\<exists>q2 \\<in> set (cast_rat_list(qs)). (poly q2 (?zer_list ! (n+1))) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q2\\<in>set (cast_rat_list qs).\n       poly q2\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (n + 1)) =\n       0", "unfolding cast_rat_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q2\\<in>set (map real_of_rat_poly qs).\n       poly q2\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (n + 1)) =\n       0", "using n_prop One_nat_def Suc_eq_plus1 fin_set less_diff_conv mem_Collect_eq nth_mem set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n  1 = Suc 0\n  Suc ?n = ?n + 1\n  finite {x. \\<exists>q\\<in>set qs. rpoly q x = (0::?'a2)}\n  (?i < ?j - ?k) = (?i + ?k < ?j)\n  (?a \\<in> Collect ?P) = ?P ?a\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n\ngoal (1 subgoal):\n 1. \\<exists>q2\\<in>set (map real_of_rat_poly qs).\n       poly q2\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (n + 1)) =\n       0", "by (smt (verit, ccfv_SIG) image_eqI set_map)"], ["proof (state)\nthis:\n  \\<exists>q2\\<in>set (cast_rat_list qs).\n     poly q2\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)) =\n     0\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have n_prop2: \"(((?zer_list ! n) < (?zer_list ! (n+1)) \\<and> (\\<exists>q1 \\<in> set (cast_rat_list(qs)). (poly q1 (?zer_list ! n)) = 0) \\<and> (\\<exists>q2\\<in> set((cast_rat_list(qs))). (poly q2 (?zer_list ! (n+1))) = 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n    < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n      (n + 1) \\<and>\n    (\\<exists>q1\\<in>set (cast_rat_list qs).\n        poly q1\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          n) =\n        0) \\<and>\n    (\\<exists>q2\\<in>set (cast_rat_list qs).\n        poly q2\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1)) =\n        0)", "using exq1 exq2 sorted_hyp n_prop"], ["proof (prove)\nusing this:\n  \\<exists>q1\\<in>set (cast_rat_list qs).\n     poly q1\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n) =\n     0\n  \\<exists>q2\\<in>set (cast_rat_list qs).\n     poly q2\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)) =\n     0\n  \\<forall>q<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     q + 1\n     < length\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q\n     < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (q + 1)\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n    < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n      (n + 1) \\<and>\n    (\\<exists>q1\\<in>set (cast_rat_list qs).\n        poly q1\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          n) =\n        0) \\<and>\n    (\\<exists>q2\\<in>set (cast_rat_list qs).\n        poly q2\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1)) =\n        0)", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (n + 1) \\<and>\n  (\\<exists>q1\\<in>set (cast_rat_list qs).\n      poly q1\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n) =\n      0) \\<and>\n  (\\<exists>q2\\<in>set (cast_rat_list qs).\n      poly q2\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (n + 1)) =\n      0)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (n + 1) \\<and>\n  (\\<exists>q1\\<in>set (cast_rat_list qs).\n      poly q1\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n) =\n      0) \\<and>\n  (\\<exists>q2\\<in>set (cast_rat_list qs).\n      poly q2\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (n + 1)) =\n      0)", "have \"(\\<exists>q. (?zer_list ! n) < q \\<and> q < (?zer_list ! (n+1)) \\<and> poly (coprime_r (cast_rat_list qs)) q = 0)\""], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (n + 1) \\<and>\n  (\\<exists>q1\\<in>set (cast_rat_list qs).\n      poly q1\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n) =\n      0) \\<and>\n  (\\<exists>q2\\<in>set (cast_rat_list qs).\n      poly q2\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (n + 1)) =\n      0)\n\ngoal (1 subgoal):\n 1. \\<exists>q>sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               n.\n       q < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (n + 1) \\<and>\n       poly (coprime_r (cast_rat_list qs)) q = 0", "using all_prop n_prop2"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (n + 1) \\<and>\n  (\\<exists>q1\\<in>set (cast_rat_list qs).\n      poly q1\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n) =\n      0) \\<and>\n  (\\<exists>q2\\<in>set (cast_rat_list qs).\n      poly q2\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (n + 1)) =\n      0)\n  \\<forall>x1 x2.\n     x1 < x2 \\<and>\n     (\\<exists>q1\\<in>set (cast_rat_list qs). poly q1 x1 = 0) \\<and>\n     (\\<exists>q2\\<in>set (cast_rat_list qs).\n         poly q2 x2 = 0) \\<longrightarrow>\n     (\\<exists>q>x1.\n         q < x2 \\<and> poly (coprime_r (cast_rat_list qs)) q = 0)\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n    (n + 1) \\<and>\n  (\\<exists>q1\\<in>set (cast_rat_list qs).\n      poly q1\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n) =\n      0) \\<and>\n  (\\<exists>q2\\<in>set (cast_rat_list qs).\n      poly q2\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (n + 1)) =\n      0)\n\ngoal (1 subgoal):\n 1. \\<exists>q>sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n               n.\n       q < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (n + 1) \\<and>\n       poly (coprime_r (cast_rat_list qs)) q = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>q>sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             n.\n     q < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (n + 1) \\<and>\n     poly (coprime_r (cast_rat_list qs)) q = 0\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  \\<exists>q>sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             n.\n     q < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (n + 1) \\<and>\n     poly (coprime_r (cast_rat_list qs)) q = 0", "have \"\\<exists>w \\<in> (roots_of_coprime_r (cast_rat_list qs)). (?zer_list ! n) < w \\<and> w < (?zer_list ! (n+1))\""], ["proof (prove)\nusing this:\n  \\<exists>q>sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n             n.\n     q < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (n + 1) \\<and>\n     poly (coprime_r (cast_rat_list qs)) q = 0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < w \\<and>\n       w < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (n + 1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                n\n                < q;\n        q < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            Suc n;\n        poly (coprime_r (cast_rat_list qs)) q = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>roots_of_coprime_r\n   (cast_rat_list qs).\n                            sorted_list_of_set\n                             {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                            n\n                            < w \\<and>\n                            w < sorted_list_of_set\n                                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                                Suc n", "using roots_of_coprime_r_def"], ["proof (prove)\nusing this:\n  roots_of_coprime_r ?qs = {x. poly (coprime_r ?qs) x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                n\n                < q;\n        q < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            Suc n;\n        poly (coprime_r (cast_rat_list qs)) q = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>roots_of_coprime_r\n   (cast_rat_list qs).\n                            sorted_list_of_set\n                             {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                            n\n                            < w \\<and>\n                            w < sorted_list_of_set\n                                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n                                Suc n", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < w \\<and>\n     w < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < w \\<and>\n     w < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (n + 1)", "obtain w where w_prop: \"w \\<in> (roots_of_coprime_r (cast_rat_list qs)) \\<and> (?zer_list ! n) < w \\<and> w < (?zer_list ! (n+1))\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < w \\<and>\n     w < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n         (n + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> roots_of_coprime_r (cast_rat_list qs) \\<and>\n        sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n        < w \\<and>\n        w < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> roots_of_coprime_r (cast_rat_list qs) \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < w \\<and>\n  w < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have n_lt1: \"n < length ?zer_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})", "using n_prop"], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n\ngoal (1 subgoal):\n 1. n < length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})", "using add_lessD1 less_diff_conv"], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n  ?i + ?j < ?k \\<Longrightarrow> ?i < ?k\n  (?i < ?j - ?k) = (?i + ?k < ?j)\n\ngoal (1 subgoal):\n 1. n < length\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})", "by blast"], ["proof (state)\nthis:\n  n < length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have n_lt2: \"n + 1 < length ?zer_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1\n    < length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})", "using n_prop"], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n\ngoal (1 subgoal):\n 1. n + 1\n    < length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})", "using less_diff_conv"], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n  (?i < ?j - ?k) = (?i + ?k < ?j)\n\ngoal (1 subgoal):\n 1. n + 1\n    < length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})", "by blast"], ["proof (state)\nthis:\n  n + 1\n  < length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have sorted_hyp_var3: \"?zer_list ! n  < ?zer_list ! (n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n    < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)", "using sorted_hyp \n        n_lt1 n_lt2"], ["proof (prove)\nusing this:\n  \\<forall>q<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}).\n     q + 1\n     < length\n        (sorted_list_of_set\n          {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) \\<longrightarrow>\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! q\n     < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (q + 1)\n  n < length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n  n + 1\n  < length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n\ngoal (1 subgoal):\n 1. sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n    < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)", "have helper: \"w > x1 \\<longrightarrow> \\<not>(\\<exists>(x::real). (List.member ?zer_list x \\<and> x1 \\<le> x \\<and> x \\<le> w))\""], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n\ngoal (1 subgoal):\n 1. x1 < w \\<longrightarrow>\n    (\\<nexists>x.\n        List.member\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n         x \\<and>\n        x1 \\<le> x \\<and> x \\<le> w)", "using n_prop w_prop x1_prop strict_sorted_h sorted_list_lemma[where n = \"n\", where l = ?zer_list, where a = \"x1\", where b = \"w\"] sorted_hyp_var3"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n  w \\<in> roots_of_coprime_r (cast_rat_list qs) \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < w \\<and>\n  w < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n  sga = sign_vec qs x1\n  strict_sorted\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n  \\<lbrakk>x1 < w;\n   n + 1\n   < length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0});\n   strict_sorted\n    (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0});\n   sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n < x1;\n   w < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>x.\n                       List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                        x \\<and>\n                       x1 \\<le> x \\<and> x \\<le> w\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n\ngoal (1 subgoal):\n 1. x1 < w \\<longrightarrow>\n    (\\<nexists>x.\n        List.member\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n         x \\<and>\n        x1 \\<le> x \\<and> x \\<le> w)", "by auto"], ["proof (state)\nthis:\n  x1 < w \\<longrightarrow>\n  (\\<nexists>x.\n      List.member\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n       x \\<and>\n      x1 \\<le> x \\<and> x \\<le> w)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have no_root1: \"w > x1 \\<Longrightarrow> \\<not>(\\<exists>r>x1. r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 < w \\<Longrightarrow>\n    \\<not> (\\<exists>r>x1.\n               r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x1 < w \\<Longrightarrow>\n    \\<not> (\\<exists>r>x1.\n               r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "assume \"w > x1\""], ["proof (state)\nthis:\n  x1 < w\n\ngoal (1 subgoal):\n 1. x1 < w \\<Longrightarrow>\n    \\<not> (\\<exists>r>x1.\n               r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "then"], ["proof (chain)\npicking this:\n  x1 < w", "have nex: \"\\<not>(\\<exists>(x::real). (List.member ?zer_list x \\<and> x1 \\<le> x \\<and> x \\<le> w))\""], ["proof (prove)\nusing this:\n  x1 < w\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       List.member\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n        x \\<and>\n       x1 \\<le> x \\<and> x \\<le> w", "using helper"], ["proof (prove)\nusing this:\n  x1 < w\n  x1 < w \\<longrightarrow>\n  (\\<nexists>x.\n      List.member\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n       x \\<and>\n      x1 \\<le> x \\<and> x \\<le> w)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       List.member\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n        x \\<and>\n       x1 \\<le> x \\<and> x \\<le> w", "by auto"], ["proof (state)\nthis:\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n      x \\<and>\n     x1 \\<le> x \\<and> x \\<le> w\n\ngoal (1 subgoal):\n 1. x1 < w \\<Longrightarrow>\n    \\<not> (\\<exists>r>x1.\n               r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "have \"(\\<exists>r>x1. r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r>x1.\n       r \\<le> w \\<and>\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n    False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r>x1.\n       r \\<le> w \\<and>\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n    False", "assume \"(\\<exists>r>x1. r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\""], ["proof (state)\nthis:\n  \\<exists>r>x1. r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>r>x1.\n       r \\<le> w \\<and>\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>r>x1. r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)", "obtain r where r_prop: \"r > x1 \\<and>r \\<le> w \\<and>(\\<exists>q\\<in>set qs. rpoly q r = 0)\""], ["proof (prove)\nusing this:\n  \\<exists>r>x1. r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        x1 < r \\<and>\n        r \\<le> w \\<and>\n        (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x1 < r \\<and> r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>r>x1.\n       r \\<le> w \\<and>\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  x1 < r \\<and> r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have \"List.member ?zer_list r \\<and>x1 \\<le> r \\<and>x1 \\<le> w \""], ["proof (prove)\nusing this:\n  x1 < r \\<and> r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) r \\<and>\n    x1 \\<le> r \\<and> x1 \\<le> w", "by (smt fin_set in_set_member mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r \\<and>\n  x1 \\<le> r \\<and> x1 \\<le> w\n\ngoal (1 subgoal):\n 1. \\<exists>r>x1.\n       r \\<le> w \\<and>\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r \\<and>\n  x1 \\<le> r \\<and> x1 \\<le> w", "show ?thesis"], ["proof (prove)\nusing this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r \\<and>\n  x1 \\<le> r \\<and> x1 \\<le> w\n\ngoal (1 subgoal):\n 1. False", "using nex r_prop"], ["proof (prove)\nusing this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r \\<and>\n  x1 \\<le> r \\<and> x1 \\<le> w\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n      x \\<and>\n     x1 \\<le> x \\<and> x \\<le> w\n  x1 < r \\<and> r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r>x1.\n     r \\<le> w \\<and>\n     (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. x1 < w \\<Longrightarrow>\n    \\<not> (\\<exists>r>x1.\n               r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "then"], ["proof (chain)\npicking this:\n  \\<exists>r>x1.\n     r \\<le> w \\<and>\n     (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>r>x1.\n     r \\<le> w \\<and>\n     (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>r>x1.\n               r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<exists>r>x1.\n             r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x1 < w \\<Longrightarrow>\n  \\<not> (\\<exists>r>x1.\n             r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have helper2: \"w < x1 \\<longrightarrow> \\<not>(\\<exists>(x::real). (List.member ?zer_list x \\<and> w \\<le> x \\<and> x \\<le> x1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w < x1 \\<longrightarrow>\n    (\\<nexists>x.\n        List.member\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n         x \\<and>\n        w \\<le> x \\<and> x \\<le> x1)", "using n_prop w_prop x1_prop strict_sorted_h sorted_list_lemma[where n = \"n\", where l = ?zer_list, where a = \"w\", where b = \"x1\"] sorted_hyp_var3"], ["proof (prove)\nusing this:\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n  w \\<in> roots_of_coprime_r (cast_rat_list qs) \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < w \\<and>\n  w < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n  sga = sign_vec qs x1\n  strict_sorted\n   (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n  \\<lbrakk>w < x1;\n   n + 1\n   < length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0});\n   strict_sorted\n    (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0});\n   sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n < w;\n   x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        (n + 1)\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>x.\n                       List.member\n                        (sorted_list_of_set\n                          {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n                        x \\<and>\n                       w \\<le> x \\<and> x \\<le> x1\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n\ngoal (1 subgoal):\n 1. w < x1 \\<longrightarrow>\n    (\\<nexists>x.\n        List.member\n         (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n         x \\<and>\n        w \\<le> x \\<and> x \\<le> x1)", "by auto"], ["proof (state)\nthis:\n  w < x1 \\<longrightarrow>\n  (\\<nexists>x.\n      List.member\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n       x \\<and>\n      w \\<le> x \\<and> x \\<le> x1)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have no_root2: \"w < x1 \\<Longrightarrow> \\<not>(\\<exists>r<x1. w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w < x1 \\<Longrightarrow>\n    \\<not> (\\<exists>r<x1.\n               w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w < x1 \\<Longrightarrow>\n    \\<not> (\\<exists>r<x1.\n               w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "assume \"w < x1\""], ["proof (state)\nthis:\n  w < x1\n\ngoal (1 subgoal):\n 1. w < x1 \\<Longrightarrow>\n    \\<not> (\\<exists>r<x1.\n               w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "then"], ["proof (chain)\npicking this:\n  w < x1", "have nex: \"\\<not>(\\<exists>(x::real). (List.member ?zer_list x \\<and>  w \\<le> x \\<and> x \\<le> x1))\""], ["proof (prove)\nusing this:\n  w < x1\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       List.member\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n        x \\<and>\n       w \\<le> x \\<and> x \\<le> x1", "using helper2"], ["proof (prove)\nusing this:\n  w < x1\n  w < x1 \\<longrightarrow>\n  (\\<nexists>x.\n      List.member\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n       x \\<and>\n      w \\<le> x \\<and> x \\<le> x1)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       List.member\n        (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n        x \\<and>\n       w \\<le> x \\<and> x \\<le> x1", "by auto"], ["proof (state)\nthis:\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n      x \\<and>\n     w \\<le> x \\<and> x \\<le> x1\n\ngoal (1 subgoal):\n 1. w < x1 \\<Longrightarrow>\n    \\<not> (\\<exists>r<x1.\n               w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "have \"(\\<exists>r<x1. w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r<x1.\n       w \\<le> r \\<and>\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n    False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r<x1.\n       w \\<le> r \\<and>\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n    False", "assume \"(\\<exists>r<x1. w \\<le> r\\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\""], ["proof (state)\nthis:\n  \\<exists>r<x1. w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>r<x1.\n       w \\<le> r \\<and>\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>r<x1. w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)", "obtain r where r_prop: \"r < x1 \\<and> w \\<le> r \\<and>(\\<exists>q\\<in>set qs. rpoly q r = 0)\""], ["proof (prove)\nusing this:\n  \\<exists>r<x1. w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r < x1 \\<and>\n        w \\<le> r \\<and>\n        (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r < x1 \\<and> w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>r<x1.\n       w \\<le> r \\<and>\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  r < x1 \\<and> w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)", "have \"List.member ?zer_list r \\<and> w \\<le> r \\<and> r \\<le> x1 \""], ["proof (prove)\nusing this:\n  r < x1 \\<and> w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal (1 subgoal):\n 1. List.member\n     (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) r \\<and>\n    w \\<le> r \\<and> r \\<le> x1", "by (smt fin_set in_set_member mem_Collect_eq set_sorted_list_of_set)"], ["proof (state)\nthis:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r \\<and>\n  w \\<le> r \\<and> r \\<le> x1\n\ngoal (1 subgoal):\n 1. \\<exists>r<x1.\n       w \\<le> r \\<and>\n       (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r \\<and>\n  w \\<le> r \\<and> r \\<le> x1", "show ?thesis"], ["proof (prove)\nusing this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r \\<and>\n  w \\<le> r \\<and> r \\<le> x1\n\ngoal (1 subgoal):\n 1. False", "using nex r_prop"], ["proof (prove)\nusing this:\n  List.member (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n   r \\<and>\n  w \\<le> r \\<and> r \\<le> x1\n  \\<nexists>x.\n     List.member\n      (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0})\n      x \\<and>\n     w \\<le> x \\<and> x \\<le> x1\n  r < x1 \\<and> w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r<x1.\n     w \\<le> r \\<and>\n     (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. w < x1 \\<Longrightarrow>\n    \\<not> (\\<exists>r<x1.\n               w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "then"], ["proof (chain)\npicking this:\n  \\<exists>r<x1.\n     w \\<le> r \\<and>\n     (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>r<x1.\n     w \\<le> r \\<and>\n     (\\<exists>q\\<in>set qs. rpoly q r = 0) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>r<x1.\n               w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<exists>r<x1.\n             w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w < x1 \\<Longrightarrow>\n  \\<not> (\\<exists>r<x1.\n             w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  w < x1 \\<Longrightarrow>\n  \\<not> (\\<exists>r<x1.\n             w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))", "have w_gt: \"w > x1 \\<longrightarrow> (sign_vec qs x1) = (sign_vec qs w)\""], ["proof (prove)\nusing this:\n  w < x1 \\<Longrightarrow>\n  \\<not> (\\<exists>r<x1.\n             w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. x1 < w \\<longrightarrow> sign_vec qs x1 = sign_vec qs w", "using no_root1 n_prop x2gt"], ["proof (prove)\nusing this:\n  w < x1 \\<Longrightarrow>\n  \\<not> (\\<exists>r<x1.\n             w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  x1 < w \\<Longrightarrow>\n  \\<not> (\\<exists>r>x1.\n             r \\<le> w \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n  \\<forall>x2>x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r>x1.\n         r \\<le> x2 \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. x1 < w \\<longrightarrow> sign_vec qs x1 = sign_vec qs w", "by auto"], ["proof (state)\nthis:\n  x1 < w \\<longrightarrow> sign_vec qs x1 = sign_vec qs w\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "have w_lt: \"w < x1 \\<longrightarrow> (sign_vec qs x1)  = (sign_vec qs w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs w", "using no_root2 n_prop x2lt"], ["proof (prove)\nusing this:\n  w < x1 \\<Longrightarrow>\n  \\<not> (\\<exists>r<x1.\n             w \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n  n < length\n       (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n      1 \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < x1 \\<and>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       (n + 1)\n  \\<forall>x2<x1.\n     sign_vec qs x1 \\<noteq> sign_vec qs x2 \\<longrightarrow>\n     (\\<exists>r<x1.\n         x2 \\<le> r \\<and> (\\<exists>q\\<in>set qs. rpoly q r = 0))\n\ngoal (1 subgoal):\n 1. w < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs w", "by auto"], ["proof (state)\nthis:\n  w < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs w\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  w < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs w", "have \"sga = (sign_vec qs w)\""], ["proof (prove)\nusing this:\n  w < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs w\n\ngoal (1 subgoal):\n 1. sga = sign_vec qs w", "using w_gt w_lt x1_prop"], ["proof (prove)\nusing this:\n  w < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs w\n  x1 < w \\<longrightarrow> sign_vec qs x1 = sign_vec qs w\n  w < x1 \\<longrightarrow> sign_vec qs x1 = sign_vec qs w\n  sga = sign_vec qs x1\n\ngoal (1 subgoal):\n 1. sga = sign_vec qs w", "by auto"], ["proof (state)\nthis:\n  sga = sign_vec qs w\n\ngoal (1 subgoal):\n 1. \\<exists>n<length\n                (sorted_list_of_set\n                  {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n               1.\n       sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n       < x1 \\<and>\n       x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n            (n + 1) \\<Longrightarrow>\n    \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "then"], ["proof (chain)\npicking this:\n  sga = sign_vec qs w", "show \"(\\<exists>w \\<in> (roots_of_coprime_r (cast_rat_list qs)). sga = (sign_vec qs w))\""], ["proof (prove)\nusing this:\n  sga = sign_vec qs w\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "using w_prop"], ["proof (prove)\nusing this:\n  sga = sign_vec qs w\n  w \\<in> roots_of_coprime_r (cast_rat_list qs) \\<and>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n  < w \\<and>\n  w < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! (n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs). sga = sign_vec qs w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1.\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < x1 \\<and>\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1) \\<Longrightarrow>\n  \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs). sga = sign_vec qs w\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "using triv_neg_inf_h neg_inf_h pos_inf_h between_h x1_and_roots"], ["proof (prove)\nusing this:\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} =\n  [] \\<Longrightarrow>\n  sga = sign_vec qs (real_of_int (- crb (prod_list (cast_rat_list qs))))\n  \\<lbrakk>sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n           [];\n   x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n        0\\<rbrakk>\n  \\<Longrightarrow> sga =\n                    sign_vec qs\n                     (real_of_int (- crb (prod_list (cast_rat_list qs))))\n  \\<lbrakk>sorted_list_of_set\n            {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n           [];\n   sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n   (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n    1)\n   < x1\\<rbrakk>\n  \\<Longrightarrow> sga =\n                    sign_vec qs\n                     (real_of_int (crb (prod_list (cast_rat_list qs))))\n  \\<exists>n<length\n              (sorted_list_of_set\n                {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n             1.\n     sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n     < x1 \\<and>\n     x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n          (n + 1) \\<Longrightarrow>\n  \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs). sga = sign_vec qs w\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} \\<noteq>\n  [] \\<longrightarrow>\n  x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n       0 \\<or>\n  sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n  (length (sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n   1)\n  < x1 \\<or>\n  (\\<exists>n<length\n               (sorted_list_of_set\n                 {x. \\<exists>q\\<in>set qs. rpoly q x = 0}) -\n              1.\n      sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} ! n\n      < x1 \\<and>\n      x1 < sorted_list_of_set {x. \\<exists>q\\<in>set qs. rpoly q x = 0} !\n           (n + 1))\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs).\n       sga = sign_vec qs w", "by (metis (mono_tags, lifting) coprime_r_zero1 coprime_r_zero2 mem_Collect_eq roots_of_coprime_r_def)"], ["proof (state)\nthis:\n  \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list qs). sga = sign_vec qs w\n\ngoal:\nNo subgoals!", "qed"], ["", "(* This lemma heavily relies on the main BKR_Proofs result and also the lemma named\n  roots_of_coprime_r_capture_sgas_without_zeros *)"], ["", "lemma find_csas_lemma_nozeros:\n  fixes qs:: \"rat poly list\"\n  assumes fs: \"factorize_polys qs = (fs,data)\"\n  assumes \"fs \\<noteq> []\"\n  shows \"(csa \\<in> (consistent_sign_vectors fs UNIV) \\<and> has_no_zeros csa) \\<longleftrightarrow> \n    csa \\<in> set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))  (cast_rat_list fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "let ?new_l = \"cast_rat_list fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "let ?copr = \"coprime_r ?new_l\""], ["proof (state)\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "have copr_nonz: \"?copr \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime_r (cast_rat_list fs) \\<noteq> 0", "using coprime_r_nonzero[OF assms(1-2)]"], ["proof (prove)\nusing this:\n  ?fss = map real_of_rat_poly fs \\<Longrightarrow> coprime_r ?fss \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime_r (cast_rat_list fs) \\<noteq> 0", "unfolding cast_rat_list_def"], ["proof (prove)\nusing this:\n  ?fss = map real_of_rat_poly fs \\<Longrightarrow> coprime_r ?fss \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime_r (map real_of_rat_poly fs) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  coprime_r (cast_rat_list fs) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "have nontriv_list: \"0 < length ?new_l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (cast_rat_list fs)", "using assms cast_rat_list_def"], ["proof (prove)\nusing this:\n  factorize_polys qs = (fs, data)\n  fs \\<noteq> []\n  cast_rat_list ?qs = map real_of_rat_poly ?qs\n\ngoal (1 subgoal):\n 1. 0 < length (cast_rat_list fs)", "by (auto)"], ["proof (state)\nthis:\n  0 < length (cast_rat_list fs)\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "have pairwise_cp: \"(\\<And>q. q \\<in> set ?new_l \\<Longrightarrow>\n       algebraic_semidom_class.coprime ?copr q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> set (cast_rat_list fs) \\<Longrightarrow>\n       algebraic_semidom_class.coprime (coprime_r (cast_rat_list fs)) q", "using coprime_r_coprime_prop[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?fss = map real_of_rat_poly fs; ?f \\<in> set ?fss\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?f (coprime_r ?fss)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> set (cast_rat_list fs) \\<Longrightarrow>\n       algebraic_semidom_class.coprime (coprime_r (cast_rat_list fs)) q", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> set (cast_rat_list fs);\n        \\<And>fss f.\n           \\<lbrakk>fss = map real_of_rat_poly fs;\n            f \\<in> real_of_rat_poly ` set fs\\<rbrakk>\n           \\<Longrightarrow> algebraic_semidom_class.coprime f\n                              (coprime_r (map real_of_rat_poly fs))\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (coprime_r (cast_rat_list fs)) q", "by (metis cast_rat_list_def comm_monoid_mult_class.coprime_commute coprime_iff_coprime list.set_map)"], ["proof (state)\nthis:\n  ?q \\<in> set (cast_rat_list fs) \\<Longrightarrow>\n  algebraic_semidom_class.coprime (coprime_r (cast_rat_list fs)) ?q\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "have set_fsga: \"set(find_consistent_signs_at_roots ?copr ?new_l) = set(characterize_consistent_signs_at_roots ?copr ?new_l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n          (cast_rat_list fs)) =\n    set (characterize_consistent_signs_at_roots\n          (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "using find_consistent_signs_at_roots[OF copr_nonz pairwise_cp]"], ["proof (prove)\nusing this:\n  (\\<And>q.\n      q \\<in> set ?qs \\<Longrightarrow>\n      q \\<in> set (cast_rat_list fs)) \\<Longrightarrow>\n  set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs)) ?qs) =\n  set (characterize_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n        ?qs)\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n          (cast_rat_list fs)) =\n    set (characterize_consistent_signs_at_roots\n          (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "by auto"], ["proof (state)\nthis:\n  set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n        (cast_rat_list fs)) =\n  set (characterize_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n        (cast_rat_list fs))\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "then"], ["proof (chain)\npicking this:\n  set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n        (cast_rat_list fs)) =\n  set (characterize_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n        (cast_rat_list fs))", "have csa_in_hyp: \"csa \\<in> set (find_consistent_signs_at_roots ?copr ?new_l)\n      \\<longleftrightarrow> csa \\<in> set(characterize_consistent_signs_at_roots ?copr ?new_l)\""], ["proof (prove)\nusing this:\n  set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n        (cast_rat_list fs)) =\n  set (characterize_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n        (cast_rat_list fs))\n\ngoal (1 subgoal):\n 1. (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs))) =\n    (csa\n     \\<in> set (characterize_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "by auto"], ["proof (state)\nthis:\n  (csa\n   \\<in> set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n               (cast_rat_list fs))) =\n  (csa\n   \\<in> set (characterize_consistent_signs_at_roots\n               (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "have forward: \"(csa \\<in> (consistent_sign_vectors fs UNIV) \\<and> has_no_zeros csa)\n     \\<Longrightarrow> csa \\<in> set(characterize_consistent_signs_at_roots ?copr ?new_l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "assume csa_in: \"(csa \\<in> (consistent_sign_vectors fs UNIV) \\<and> has_no_zeros csa)\""], ["proof (state)\nthis:\n  csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "have fin: \"finite {x. poly (coprime_r (cast_rat_list fs)) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. poly (coprime_r (cast_rat_list fs)) x = 0}", "using copr_nonz poly_roots_finite"], ["proof (prove)\nusing this:\n  coprime_r (cast_rat_list fs) \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. finite {x. poly (coprime_r (cast_rat_list fs)) x = 0}", "by (simp add: poly_roots_finite fs)"], ["proof (state)\nthis:\n  finite {x. poly (coprime_r (cast_rat_list fs)) x = 0}\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "have pcl: \"pairwise_coprime_list fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise_coprime_list fs", "using coprime_factorize fs"], ["proof (prove)\nusing this:\n  pairwise_coprime_list (fst (factorize_polys ?qs))\n  factorize_polys qs = (fs, data)\n\ngoal (1 subgoal):\n 1. pairwise_coprime_list fs", "by (metis fst_conv)"], ["proof (state)\nthis:\n  pairwise_coprime_list fs\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "have sqf: \"\\<And>q. q \\<in> set fs \\<Longrightarrow> rsquarefree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q. q \\<in> set fs \\<Longrightarrow> rsquarefree q", "using factorize_polys_square_free[OF assms(1)]"], ["proof (prove)\nusing this:\n  ?f \\<in> set fs \\<Longrightarrow> square_free ?f\n\ngoal (1 subgoal):\n 1. \\<And>q. q \\<in> set fs \\<Longrightarrow> rsquarefree q", "by (metis square_free_rsquarefree)"], ["proof (state)\nthis:\n  ?q \\<in> set fs \\<Longrightarrow> rsquarefree ?q\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "obtain x1 where x1:\"csa = sign_vec fs x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        csa = sign_vec fs x1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using consistent_sign_vectors_def csa_in"], ["proof (prove)\nusing this:\n  consistent_sign_vectors ?qs ?S = sign_vec ?qs ` ?S\n  csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        csa = sign_vec fs x1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  csa = sign_vec fs x1\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "have hnz: \"has_no_zeros csa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_no_zeros csa", "using csa_in"], ["proof (prove)\nusing this:\n  csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa\n\ngoal (1 subgoal):\n 1. has_no_zeros csa", "by auto"], ["proof (state)\nthis:\n  has_no_zeros csa\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "obtain w where w_prop: \"w\\<in>roots_of_coprime_r (cast_rat_list fs)\" \"csa = sign_vec fs w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> roots_of_coprime_r (cast_rat_list fs);\n         csa = sign_vec fs w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using roots_of_coprime_r_capture_sgas_without_zeros[OF pcl sqf x1 hnz]"], ["proof (prove)\nusing this:\n  (\\<And>q.\n      q \\<in> set fs \\<Longrightarrow> q \\<in> set fs) \\<Longrightarrow>\n  \\<exists>w\\<in>roots_of_coprime_r (cast_rat_list fs). csa = sign_vec fs w\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> roots_of_coprime_r (cast_rat_list fs);\n         csa = sign_vec fs w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> roots_of_coprime_r (cast_rat_list fs)\n  csa = sign_vec fs w\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "have w_root: \"poly (coprime_r (cast_rat_list fs)) w = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (coprime_r (cast_rat_list fs)) w = 0", "using w_prop"], ["proof (prove)\nusing this:\n  w \\<in> roots_of_coprime_r (cast_rat_list fs)\n  csa = sign_vec fs w\n\ngoal (1 subgoal):\n 1. poly (coprime_r (cast_rat_list fs)) w = 0", "by (simp add: roots_of_coprime_r_def)"], ["proof (state)\nthis:\n  poly (coprime_r (cast_rat_list fs)) w = 0\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "then"], ["proof (chain)\npicking this:\n  poly (coprime_r (cast_rat_list fs)) w = 0", "have \"w \\<in> {x. poly (coprime_r (cast_rat_list fs)) x = 0}\""], ["proof (prove)\nusing this:\n  poly (coprime_r (cast_rat_list fs)) w = 0\n\ngoal (1 subgoal):\n 1. w \\<in> {x. poly (coprime_r (cast_rat_list fs)) x = 0}", "by auto"], ["proof (state)\nthis:\n  w \\<in> {x. poly (coprime_r (cast_rat_list fs)) x = 0}\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "then"], ["proof (chain)\npicking this:\n  w \\<in> {x. poly (coprime_r (cast_rat_list fs)) x = 0}", "have w_ins: \"w \\<in> set (characterize_root_list_p (coprime_r (cast_rat_list fs)))\""], ["proof (prove)\nusing this:\n  w \\<in> {x. poly (coprime_r (cast_rat_list fs)) x = 0}\n\ngoal (1 subgoal):\n 1. w \\<in> set (characterize_root_list_p (coprime_r (cast_rat_list fs)))", "using fin set_sorted_list_of_set[where A=\"{x. poly (coprime_r (cast_rat_list fs)) x = 0}\"]"], ["proof (prove)\nusing this:\n  w \\<in> {x. poly (coprime_r (cast_rat_list fs)) x = 0}\n  finite {x. poly (coprime_r (cast_rat_list fs)) x = 0}\n  finite {x. poly (coprime_r (cast_rat_list fs)) x = 0} \\<Longrightarrow>\n  set (sorted_list_of_set {x. poly (coprime_r (cast_rat_list fs)) x = 0}) =\n  {x. poly (coprime_r (cast_rat_list fs)) x = 0}\n\ngoal (1 subgoal):\n 1. w \\<in> set (characterize_root_list_p (coprime_r (cast_rat_list fs)))", "unfolding characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  w \\<in> {x. poly (coprime_r (cast_rat_list fs)) x = 0}\n  finite {x. poly (coprime_r (cast_rat_list fs)) x = 0}\n  finite {x. poly (coprime_r (cast_rat_list fs)) x = 0} \\<Longrightarrow>\n  set (sorted_list_of_set {x. poly (coprime_r (cast_rat_list fs)) x = 0}) =\n  {x. poly (coprime_r (cast_rat_list fs)) x = 0}\n\ngoal (1 subgoal):\n 1. w \\<in> set (sorted_list_of_set\n                  {x. poly (coprime_r (cast_rat_list fs)) x = 0})", "by auto"], ["proof (state)\nthis:\n  w \\<in> set (characterize_root_list_p (coprime_r (cast_rat_list fs)))\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "have \"map ((\\<lambda>x. if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ> (\\<lambda>p. rpoly p w)) fs =\n          map ((\\<lambda>x. if 0 < x then 1 else - 1) \\<circ> (\\<lambda>p. rpoly p w)) fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>x.\n             if 0 < x then 1::'a\n             else if x < 0 then - (1::'a) else (0::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs =\n    map ((\\<lambda>x. if 0 < x then 1::'a else - (1::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map ((\\<lambda>x.\n             if 0 < x then 1::'a\n             else if x < 0 then - (1::'a) else (0::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs =\n    map ((\\<lambda>x. if 0 < x then 1::'a else - (1::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs", "have \"\\<not>(\\<exists>x \\<in> set fs. rpoly x w = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x\\<in>set fs. rpoly x w = 0)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set fs; rpoly x w = 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set fs; rpoly x w = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume x_in: \"x \\<in> set fs\""], ["proof (state)\nthis:\n  x \\<in> set fs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set fs; rpoly x w = 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume x_zer: \"rpoly x w = 0\""], ["proof (state)\nthis:\n  rpoly x w = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set fs; rpoly x w = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  rpoly x w = 0", "have \"\\<exists>k < length fs. nth fs k = x\""], ["proof (prove)\nusing this:\n  rpoly x w = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k<length fs. fs ! k = x", "using x_in"], ["proof (prove)\nusing this:\n  rpoly x w = 0\n  x \\<in> set fs\n\ngoal (1 subgoal):\n 1. \\<exists>k<length fs. fs ! k = x", "by (simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>k<length fs. fs ! k = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set fs; rpoly x w = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>k<length fs. fs ! k = x", "obtain k where k_prop: \"k < length fs \\<and> fs ! k = x\""], ["proof (prove)\nusing this:\n  \\<exists>k<length fs. fs ! k = x\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k < length fs \\<and> fs ! k = x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k < length fs \\<and> fs ! k = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set fs; rpoly x w = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k < length fs \\<and> fs ! k = x", "have \"(sign_vec fs w) ! k = 0\""], ["proof (prove)\nusing this:\n  k < length fs \\<and> fs ! k = x\n\ngoal (1 subgoal):\n 1. sign_vec fs w ! k = 0", "using x_zer"], ["proof (prove)\nusing this:\n  k < length fs \\<and> fs ! k = x\n  rpoly x w = 0\n\ngoal (1 subgoal):\n 1. sign_vec fs w ! k = 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rpoly (fs ! k) w = 0; k < length fs; x = fs ! k\\<rbrakk>\n    \\<Longrightarrow> sign_vec fs w ! k = 0", "unfolding sign_vec_def squash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rpoly (fs ! k) w = 0; k < length fs; x = fs ! k\\<rbrakk>\n    \\<Longrightarrow> map ((\\<lambda>x.\n                               if 0 < x then 1\n                               else if x < 0 then - 1 else 0) \\<circ>\n                           (\\<lambda>p. rpoly p w))\n                       fs !\n                      k =\n                      0", "by auto"], ["proof (state)\nthis:\n  sign_vec fs w ! k = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set fs; rpoly x w = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  sign_vec fs w ! k = 0", "have \"\\<not> (has_no_zeros (sign_vec fs w))\""], ["proof (prove)\nusing this:\n  sign_vec fs w ! k = 0\n\ngoal (1 subgoal):\n 1. \\<not> has_no_zeros (sign_vec fs w)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_vec fs w ! k = 0; has_no_zeros (sign_vec fs w)\\<rbrakk>\n    \\<Longrightarrow> False", "by (simp add: hnz_prop k_prop)"], ["proof (state)\nthis:\n  \\<not> has_no_zeros (sign_vec fs w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set fs; rpoly x w = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> has_no_zeros (sign_vec fs w)", "show False"], ["proof (prove)\nusing this:\n  \\<not> has_no_zeros (sign_vec fs w)\n\ngoal (1 subgoal):\n 1. False", "using hnz"], ["proof (prove)\nusing this:\n  \\<not> has_no_zeros (sign_vec fs w)\n  has_no_zeros csa\n\ngoal (1 subgoal):\n 1. False", "unfolding sign_vec_def squash_def"], ["proof (prove)\nusing this:\n  \\<not> has_no_zeros\n          (map ((\\<lambda>x.\n                    if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n                (\\<lambda>p. rpoly p w))\n            fs)\n  has_no_zeros csa\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> has_no_zeros (sign_vec fs w)\\<close> w_prop(2)"], ["proof (prove)\nusing this:\n  \\<not> has_no_zeros\n          (map ((\\<lambda>x.\n                    if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n                (\\<lambda>p. rpoly p w))\n            fs)\n  has_no_zeros csa\n  \\<not> has_no_zeros (sign_vec fs w)\n  csa = sign_vec fs w\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x\\<in>set fs. rpoly x w = 0)\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>x.\n             if 0 < x then 1::'a\n             else if x < 0 then - (1::'a) else (0::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs =\n    map ((\\<lambda>x. if 0 < x then 1::'a else - (1::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>x\\<in>set fs. rpoly x w = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x\\<in>set fs. rpoly x w = 0)\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>x.\n             if 0 < x then 1::'a\n             else if x < 0 then - (1::'a) else (0::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs =\n    map ((\\<lambda>x. if 0 < x then 1::'a else - (1::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs", "using hnz"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x\\<in>set fs. rpoly x w = 0)\n  has_no_zeros csa\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>x.\n             if 0 < x then 1::'a\n             else if x < 0 then - (1::'a) else (0::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs =\n    map ((\\<lambda>x. if 0 < x then 1::'a else - (1::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs", "unfolding sign_vec_def squash_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x\\<in>set fs. rpoly x w = 0)\n  has_no_zeros csa\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>x.\n             if 0 < x then 1::'a\n             else if x < 0 then - (1::'a) else (0::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs =\n    map ((\\<lambda>x. if 0 < x then 1::'a else - (1::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs", "by auto"], ["proof (state)\nthis:\n  map ((\\<lambda>x.\n           if 0 < x then 1::'a\n           else if x < 0 then - (1::'a) else (0::'a)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs =\n  map ((\\<lambda>x. if 0 < x then 1::'a else - (1::'a)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map ((\\<lambda>x.\n           if 0 < x then 1::?'a1\n           else if x < 0 then - (1::?'a1) else (0::?'a1)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs =\n  map ((\\<lambda>x. if 0 < x then 1::?'a1 else - (1::?'a1)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "then"], ["proof (chain)\npicking this:\n  map ((\\<lambda>x.\n           if 0 < x then 1::?'a1\n           else if x < 0 then - (1::?'a1) else (0::?'a1)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs =\n  map ((\\<lambda>x. if 0 < x then 1::?'a1 else - (1::?'a1)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs", "have \"map ((\\<lambda>x. if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ> (\\<lambda>p. rpoly p w)) fs =\n    map (\\<lambda>q. if 0 < poly q w then 1 else - 1)\n     (cast_rat_list fs)\""], ["proof (prove)\nusing this:\n  map ((\\<lambda>x.\n           if 0 < x then 1::?'a1\n           else if x < 0 then - (1::?'a1) else (0::?'a1)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs =\n  map ((\\<lambda>x. if 0 < x then 1::?'a1 else - (1::?'a1)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>x.\n             if 0 < x then 1::'a\n             else if x < 0 then - (1::'a) else (0::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs =\n    map (\\<lambda>q. if 0 < poly q w then 1::'a else - (1::'a))\n     (cast_rat_list fs)", "unfolding cast_rat_list_def"], ["proof (prove)\nusing this:\n  map ((\\<lambda>x.\n           if 0 < x then 1::?'a1\n           else if x < 0 then - (1::?'a1) else (0::?'a1)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs =\n  map ((\\<lambda>x. if 0 < x then 1::?'a1 else - (1::?'a1)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>x.\n             if 0 < x then 1::'a\n             else if x < 0 then - (1::'a) else (0::'a)) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs =\n    map (\\<lambda>q. if 0 < poly q w then 1::'a else - (1::'a))\n     (map real_of_rat_poly fs)", "by auto"], ["proof (state)\nthis:\n  map ((\\<lambda>x.\n           if 0 < x then 1::?'a2\n           else if x < 0 then - (1::?'a2) else (0::?'a2)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs =\n  map (\\<lambda>q. if 0 < poly q w then 1::?'a2 else - (1::?'a2))\n   (cast_rat_list fs)\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "then"], ["proof (chain)\npicking this:\n  map ((\\<lambda>x.\n           if 0 < x then 1::?'a2\n           else if x < 0 then - (1::?'a2) else (0::?'a2)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs =\n  map (\\<lambda>q. if 0 < poly q w then 1::?'a2 else - (1::?'a2))\n   (cast_rat_list fs)", "have \"csa = map (\\<lambda>q. if 0 < poly q w then 1 else - 1)\n             (cast_rat_list fs)\""], ["proof (prove)\nusing this:\n  map ((\\<lambda>x.\n           if 0 < x then 1::?'a2\n           else if x < 0 then - (1::?'a2) else (0::?'a2)) \\<circ>\n       (\\<lambda>p. rpoly p w))\n   fs =\n  map (\\<lambda>q. if 0 < poly q w then 1::?'a2 else - (1::?'a2))\n   (cast_rat_list fs)\n\ngoal (1 subgoal):\n 1. csa =\n    map (\\<lambda>q. if 0 < poly q w then 1 else - 1) (cast_rat_list fs)", "by (simp add: comp_def sign_vec_def squash_def w_prop(2))"], ["proof (state)\nthis:\n  csa = map (\\<lambda>q. if 0 < poly q w then 1 else - 1) (cast_rat_list fs)\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n    has_no_zeros csa \\<Longrightarrow>\n    csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "then"], ["proof (chain)\npicking this:\n  csa = map (\\<lambda>q. if 0 < poly q w then 1 else - 1) (cast_rat_list fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  csa = map (\\<lambda>q. if 0 < poly q w then 1 else - 1) (cast_rat_list fs)\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "unfolding characterize_consistent_signs_at_roots_def"], ["proof (prove)\nusing this:\n  csa = map (\\<lambda>q. if 0 < poly q w then 1 else - 1) (cast_rat_list fs)\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (remdups\n                (map (signs_at (cast_rat_list fs))\n                  (characterize_root_list_p\n                    (coprime_r (cast_rat_list fs)))))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. csa =\n    map (\\<lambda>q. if 0 < poly q w then 1 else - 1)\n     (cast_rat_list fs) \\<Longrightarrow>\n    map (\\<lambda>q. if 0 < poly q w then 1 else - 1) (cast_rat_list fs)\n    \\<in> signs_at (cast_rat_list fs) `\n          set (characterize_root_list_p (coprime_r (cast_rat_list fs)))", "unfolding signs_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. csa =\n    map (\\<lambda>q. if 0 < poly q w then 1 else - 1)\n     (cast_rat_list fs) \\<Longrightarrow>\n    map (\\<lambda>q. if 0 < poly q w then 1 else - 1) (cast_rat_list fs)\n    \\<in> (\\<lambda>x.\n              map (squash \\<circ> (\\<lambda>q. poly q x))\n               (cast_rat_list fs)) `\n          set (characterize_root_list_p (coprime_r (cast_rat_list fs)))", "using w_ins w_prop"], ["proof (prove)\nusing this:\n  w \\<in> set (characterize_root_list_p (coprime_r (cast_rat_list fs)))\n  w \\<in> roots_of_coprime_r (cast_rat_list fs)\n  csa = sign_vec fs w\n\ngoal (1 subgoal):\n 1. csa =\n    map (\\<lambda>q. if 0 < poly q w then 1 else - 1)\n     (cast_rat_list fs) \\<Longrightarrow>\n    map (\\<lambda>q. if 0 < poly q w then 1 else - 1) (cast_rat_list fs)\n    \\<in> (\\<lambda>x.\n              map (squash \\<circ> (\\<lambda>q. poly q x))\n               (cast_rat_list fs)) `\n          set (characterize_root_list_p (coprime_r (cast_rat_list fs)))", "using consistent_sign_vectors_consistent_sign_vectors_r consistent_sign_vectors_def consistent_sign_vectors_r_def signs_at_def"], ["proof (prove)\nusing this:\n  w \\<in> set (characterize_root_list_p (coprime_r (cast_rat_list fs)))\n  w \\<in> roots_of_coprime_r (cast_rat_list fs)\n  csa = sign_vec fs w\n  consistent_sign_vectors_r (cast_rat_list ?qs) ?S =\n  consistent_sign_vectors ?qs ?S\n  consistent_sign_vectors ?qs ?S = sign_vec ?qs ` ?S\n  consistent_sign_vectors_r ?qs ?S = signs_at ?qs ` ?S\n  signs_at ?qs ?x \\<equiv> map (squash \\<circ> (\\<lambda>q. poly q ?x)) ?qs\n\ngoal (1 subgoal):\n 1. csa =\n    map (\\<lambda>q. if 0 < poly q w then 1 else - 1)\n     (cast_rat_list fs) \\<Longrightarrow>\n    map (\\<lambda>q. if 0 < poly q w then 1 else - 1) (cast_rat_list fs)\n    \\<in> (\\<lambda>x.\n              map (squash \\<circ> (\\<lambda>q. poly q x))\n               (cast_rat_list fs)) `\n          set (characterize_root_list_p (coprime_r (cast_rat_list fs)))", "by force"], ["proof (state)\nthis:\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots\n              (coprime_r (cast_rat_list fs)) (cast_rat_list fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n  has_no_zeros csa \\<Longrightarrow>\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots\n              (coprime_r (cast_rat_list fs)) (cast_rat_list fs))\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "have backward: \"csa \\<in> set(characterize_consistent_signs_at_roots ?copr ?new_l) \\<Longrightarrow>\n    (csa \\<in> (consistent_sign_vectors fs UNIV) \\<and> has_no_zeros csa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "assume csa_in: \"csa \\<in> set(characterize_consistent_signs_at_roots ?copr ?new_l)\""], ["proof (state)\nthis:\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots\n              (coprime_r (cast_rat_list fs)) (cast_rat_list fs))\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "have csa_in_old_set: \"csa \\<in> set (characterize_consistent_signs_at_roots_copr ?copr ?new_l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots_copr\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "using csa_list_copr_rel copr_nonz csa_in find_consistent_signs_at_roots_copr pairwise_cp set_fsga"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<forall>q.\n      List.member ?qs q \\<longrightarrow>\n      algebraic_semidom_class.coprime ?p q\\<rbrakk>\n  \\<Longrightarrow> characterize_consistent_signs_at_roots ?p ?qs =\n                    characterize_consistent_signs_at_roots_copr ?p ?qs\n  coprime_r (cast_rat_list fs) \\<noteq> 0\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots\n              (coprime_r (cast_rat_list fs)) (cast_rat_list fs))\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<And>q.\n      q \\<in> set ?qs \\<Longrightarrow>\n      algebraic_semidom_class.coprime ?p q\\<rbrakk>\n  \\<Longrightarrow> set (find_consistent_signs_at_roots ?p ?qs) =\n                    set (characterize_consistent_signs_at_roots_copr ?p ?qs)\n  ?q \\<in> set (cast_rat_list fs) \\<Longrightarrow>\n  algebraic_semidom_class.coprime (coprime_r (cast_rat_list fs)) ?q\n  set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n        (cast_rat_list fs)) =\n  set (characterize_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n        (cast_rat_list fs))\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots_copr\n                (coprime_r (cast_rat_list fs)) (cast_rat_list fs))", "by auto"], ["proof (state)\nthis:\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots_copr\n              (coprime_r (cast_rat_list fs)) (cast_rat_list fs))\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "have \"\\<forall>(x::real). \\<forall> (l::real poly list). rec_list True (\\<lambda>h T. If (h = 0) False)\n          (map (\\<lambda>q. if 0 < poly q x then (1::rat) else (-1::rat))\n            l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x l.\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)", "fix x::\"real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)", "fix l::\"real poly list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)", "show \" rec_list True (\\<lambda>h T. If (h = 0) False)\n            (map (\\<lambda>q. if 0 < poly q x then (1::rat) else (-1::rat)) l) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_list True (\\<lambda>h T. If (h = 0) False)\n     (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. rec_list True (\\<lambda>h T. If (h = 0) False)\n     (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) [])\n 2. \\<And>a l.\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n          l) \\<Longrightarrow>\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (a # l))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. rec_list True (\\<lambda>h T. If (h = 0) False)\n     (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) [])\n 2. \\<And>a l.\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n          l) \\<Longrightarrow>\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (a # l))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_list True (\\<lambda>h T. If (h = 0) False)\n     (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) [])", "by simp"], ["proof (state)\nthis:\n  rec_list True (\\<lambda>h T. If (h = 0) False)\n   (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) [])\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n          l) \\<Longrightarrow>\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n          l) \\<Longrightarrow>\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (a # l))", "case (Cons a l)"], ["proof (state)\nthis:\n  rec_list True (\\<lambda>h T. If (h = 0) False)\n   (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n          l) \\<Longrightarrow>\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (a # l))", "then"], ["proof (chain)\npicking this:\n  rec_list True (\\<lambda>h T. If (h = 0) False)\n   (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)", "show ?case"], ["proof (prove)\nusing this:\n  rec_list True (\\<lambda>h T. If (h = 0) False)\n   (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)\n\ngoal (1 subgoal):\n 1. rec_list True (\\<lambda>h T. If (h = 0) False)\n     (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (a # l))", "by auto"], ["proof (state)\nthis:\n  rec_list True (\\<lambda>h T. If (h = 0) False)\n   (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (a # l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_list True (\\<lambda>h T. If (h = 0) False)\n   (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x l.\n     rec_list True (\\<lambda>h T. If (h = 0) False)\n      (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "then"], ["proof (chain)\npicking this:\n  \\<forall>x l.\n     rec_list True (\\<lambda>h T. If (h = 0) False)\n      (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)", "have \"\\<forall>x. rec_list True (\\<lambda>h T. If (h = 0) False)\n          (map (\\<lambda>q. if 0 < poly q x then (1::rat) else - 1)\n            (cast_rat_list fs))\""], ["proof (prove)\nusing this:\n  \\<forall>x l.\n     rec_list True (\\<lambda>h T. If (h = 0) False)\n      (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) l)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       rec_list True (\\<lambda>h T. If (h = 0) False)\n        (map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n          (cast_rat_list fs))", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     rec_list True (\\<lambda>h T. If (h = 0) False)\n      (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (cast_rat_list fs))\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     rec_list True (\\<lambda>h T. If (h = 0) False)\n      (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (cast_rat_list fs))", "have hnz: \"has_no_zeros csa\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     rec_list True (\\<lambda>h T. If (h = 0) False)\n      (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (cast_rat_list fs))\n\ngoal (1 subgoal):\n 1. has_no_zeros csa", "using csa_in_old_set"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     rec_list True (\\<lambda>h T. If (h = 0) False)\n      (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (cast_rat_list fs))\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots_copr\n              (coprime_r (cast_rat_list fs)) (cast_rat_list fs))\n\ngoal (1 subgoal):\n 1. has_no_zeros csa", "unfolding characterize_consistent_signs_at_roots_copr_def consistent_sign_vec_copr_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     rec_list True (\\<lambda>h T. If (h = 0) False)\n      (map (\\<lambda>q. if 0 < poly q x then 1 else - 1) (cast_rat_list fs))\n  csa\n  \\<in> set (remdups\n              (map (\\<lambda>x.\n                       map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n                        (cast_rat_list fs))\n                (characterize_root_list_p (coprime_r (cast_rat_list fs)))))\n\ngoal (1 subgoal):\n 1. has_no_zeros csa", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   rec_list True (\\<lambda>h T. If (h = 0) False)\n                    (map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n                      (cast_rat_list fs));\n        x \\<in> set (characterize_root_list_p\n                      (coprime_r (cast_rat_list fs)));\n        csa =\n        map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n         (cast_rat_list fs)\\<rbrakk>\n       \\<Longrightarrow> has_no_zeros\n                          (map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n                            (cast_rat_list fs))", "unfolding has_no_zeros_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   rec_list True (\\<lambda>h T. If (h = 0) False)\n                    (map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n                      (cast_rat_list fs));\n        x \\<in> set (characterize_root_list_p\n                      (coprime_r (cast_rat_list fs)));\n        csa =\n        map (\\<lambda>q. if 0 < poly q x then 1 else - 1)\n         (cast_rat_list fs)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<notin> set (map\n    (\\<lambda>q. if 0 < poly q x then 1 else - 1) (cast_rat_list fs))", "by auto"], ["proof (state)\nthis:\n  has_no_zeros csa\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "have \"\\<exists>w \\<in> set(characterize_root_list_p ?copr). csa = consistent_sign_vec_copr ?new_l w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>set (characterize_root_list_p\n                         (coprime_r (cast_rat_list fs))).\n       csa = consistent_sign_vec_copr (cast_rat_list fs) w", "using csa_in_old_set"], ["proof (prove)\nusing this:\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots_copr\n              (coprime_r (cast_rat_list fs)) (cast_rat_list fs))\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>set (characterize_root_list_p\n                         (coprime_r (cast_rat_list fs))).\n       csa = consistent_sign_vec_copr (cast_rat_list fs) w", "using characterize_consistent_signs_at_roots_copr_def"], ["proof (prove)\nusing this:\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots_copr\n              (coprime_r (cast_rat_list fs)) (cast_rat_list fs))\n  characterize_consistent_signs_at_roots_copr ?p ?qss =\n  remdups\n   (map (consistent_sign_vec_copr ?qss) (characterize_root_list_p ?p))\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>set (characterize_root_list_p\n                         (coprime_r (cast_rat_list fs))).\n       csa = consistent_sign_vec_copr (cast_rat_list fs) w", "by auto"], ["proof (state)\nthis:\n  \\<exists>w\\<in>set (characterize_root_list_p\n                       (coprime_r (cast_rat_list fs))).\n     csa = consistent_sign_vec_copr (cast_rat_list fs) w\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "then"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>set (characterize_root_list_p\n                       (coprime_r (cast_rat_list fs))).\n     csa = consistent_sign_vec_copr (cast_rat_list fs) w", "obtain w where w_prop: \"w \\<in> set (characterize_root_list_p ?copr) \\<and> csa = consistent_sign_vec_copr ?new_l w\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>set (characterize_root_list_p\n                       (coprime_r (cast_rat_list fs))).\n     csa = consistent_sign_vec_copr (cast_rat_list fs) w\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> set (characterize_root_list_p\n                      (coprime_r (cast_rat_list fs))) \\<and>\n        csa =\n        consistent_sign_vec_copr (cast_rat_list fs) w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> set (characterize_root_list_p\n                (coprime_r (cast_rat_list fs))) \\<and>\n  csa = consistent_sign_vec_copr (cast_rat_list fs) w\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "then"], ["proof (chain)\npicking this:\n  w \\<in> set (characterize_root_list_p\n                (coprime_r (cast_rat_list fs))) \\<and>\n  csa = consistent_sign_vec_copr (cast_rat_list fs) w", "have \"poly ?copr w = 0\""], ["proof (prove)\nusing this:\n  w \\<in> set (characterize_root_list_p\n                (coprime_r (cast_rat_list fs))) \\<and>\n  csa = consistent_sign_vec_copr (cast_rat_list fs) w\n\ngoal (1 subgoal):\n 1. poly (coprime_r (cast_rat_list fs)) w = 0", "unfolding characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  w \\<in> set (sorted_list_of_set\n                {x. poly (coprime_r (cast_rat_list fs)) x = 0}) \\<and>\n  csa = consistent_sign_vec_copr (cast_rat_list fs) w\n\ngoal (1 subgoal):\n 1. poly (coprime_r (cast_rat_list fs)) w = 0", "by (simp add: copr_nonz poly_roots_finite)"], ["proof (state)\nthis:\n  poly (coprime_r (cast_rat_list fs)) w = 0\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "then"], ["proof (chain)\npicking this:\n  poly (coprime_r (cast_rat_list fs)) w = 0", "have copr_prop: \"\\<forall>p \\<in> set(?new_l). poly p w \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly (coprime_r (cast_rat_list fs)) w = 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (cast_rat_list fs). poly p w \\<noteq> 0", "using w_prop coprime_r_coprime_prop"], ["proof (prove)\nusing this:\n  poly (coprime_r (cast_rat_list fs)) w = 0\n  w \\<in> set (characterize_root_list_p\n                (coprime_r (cast_rat_list fs))) \\<and>\n  csa = consistent_sign_vec_copr (cast_rat_list fs) w\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data);\n   ?fss = map real_of_rat_poly ?fs; ?f \\<in> set ?fss\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?f (coprime_r ?fss)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (cast_rat_list fs). poly p w \\<noteq> 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>poly (coprime_r (cast_rat_list fs)) w = 0;\n        \\<And>ps fs data fss f.\n           \\<lbrakk>factorize_polys ps = (fs, data);\n            fss = map real_of_rat_poly fs;\n            f \\<in> real_of_rat_poly ` set fs\\<rbrakk>\n           \\<Longrightarrow> algebraic_semidom_class.coprime f\n                              (coprime_r (map real_of_rat_poly fs));\n        p \\<in> set (cast_rat_list fs);\n        w \\<in> set (characterize_root_list_p\n                      (coprime_r (cast_rat_list fs)));\n        csa = consistent_sign_vec_copr (cast_rat_list fs) w;\n        poly p w = 0\\<rbrakk>\n       \\<Longrightarrow> False", "by (meson coprime_poly_0 in_set_member pairwise_cp)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (cast_rat_list fs). poly p w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set (cast_rat_list fs). poly p w \\<noteq> 0", "have \"consistent_sign_vec_copr ?new_l w = sign_vec fs w\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (cast_rat_list fs). poly p w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. consistent_sign_vec_copr (cast_rat_list fs) w = sign_vec fs w", "unfolding sign_vec_def squash_def consistent_sign_vec_copr_def\n        cast_rat_list_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (map real_of_rat_poly fs). poly p w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map (\\<lambda>q. if 0 < poly q w then 1 else - 1)\n     (map real_of_rat_poly fs) =\n    map ((\\<lambda>x. if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n         (\\<lambda>p. rpoly p w))\n     fs", "by auto"], ["proof (state)\nthis:\n  consistent_sign_vec_copr (cast_rat_list fs) w = sign_vec fs w\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (characterize_consistent_signs_at_roots\n                (coprime_r (cast_rat_list fs))\n                (cast_rat_list fs)) \\<Longrightarrow>\n    csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "then"], ["proof (chain)\npicking this:\n  consistent_sign_vec_copr (cast_rat_list fs) w = sign_vec fs w", "show ?thesis"], ["proof (prove)\nusing this:\n  consistent_sign_vec_copr (cast_rat_list fs) w = sign_vec fs w\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "using hnz w_prop"], ["proof (prove)\nusing this:\n  consistent_sign_vec_copr (cast_rat_list fs) w = sign_vec fs w\n  has_no_zeros csa\n  w \\<in> set (characterize_root_list_p\n                (coprime_r (cast_rat_list fs))) \\<and>\n  csa = consistent_sign_vec_copr (cast_rat_list fs) w\n\ngoal (1 subgoal):\n 1. csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent_sign_vec_copr (cast_rat_list fs) w = sign_vec fs w;\n     has_no_zeros (sign_vec fs w);\n     w \\<in> set (characterize_root_list_p (coprime_r (cast_rat_list fs)));\n     csa = sign_vec fs w\\<rbrakk>\n    \\<Longrightarrow> sign_vec fs w \\<in> consistent_sign_vectors fs UNIV", "using consistent_sign_vectors_def"], ["proof (prove)\nusing this:\n  consistent_sign_vectors ?qs ?S = sign_vec ?qs ` ?S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent_sign_vec_copr (cast_rat_list fs) w = sign_vec fs w;\n     has_no_zeros (sign_vec fs w);\n     w \\<in> set (characterize_root_list_p (coprime_r (cast_rat_list fs)));\n     csa = sign_vec fs w\\<rbrakk>\n    \\<Longrightarrow> sign_vec fs w \\<in> consistent_sign_vectors fs UNIV", "by blast"], ["proof (state)\nthis:\n  csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots\n              (coprime_r (cast_rat_list fs))\n              (cast_rat_list fs)) \\<Longrightarrow>\n  csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "have \"(csa \\<in> (consistent_sign_vectors fs UNIV) \\<and> has_no_zeros csa)\n     \\<longleftrightarrow> csa \\<in> set(characterize_consistent_signs_at_roots ?copr ?new_l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (characterize_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "using forward backward"], ["proof (prove)\nusing this:\n  csa \\<in> consistent_sign_vectors fs UNIV \\<and>\n  has_no_zeros csa \\<Longrightarrow>\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots\n              (coprime_r (cast_rat_list fs)) (cast_rat_list fs))\n  csa\n  \\<in> set (characterize_consistent_signs_at_roots\n              (coprime_r (cast_rat_list fs))\n              (cast_rat_list fs)) \\<Longrightarrow>\n  csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (characterize_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "by blast"], ["proof (state)\nthis:\n  (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n  (csa\n   \\<in> set (characterize_consistent_signs_at_roots\n               (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "then"], ["proof (chain)\npicking this:\n  (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n  (csa\n   \\<in> set (characterize_consistent_signs_at_roots\n               (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n  (csa\n   \\<in> set (characterize_consistent_signs_at_roots\n               (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "using  csa_in_hyp"], ["proof (prove)\nusing this:\n  (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n  (csa\n   \\<in> set (characterize_consistent_signs_at_roots\n               (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))\n  (csa\n   \\<in> set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n               (cast_rat_list fs))) =\n  (csa\n   \\<in> set (characterize_consistent_signs_at_roots\n               (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n    (csa\n     \\<in> set (find_consistent_signs_at_roots\n                 (coprime_r (cast_rat_list fs)) (cast_rat_list fs)))", "by auto"], ["proof (state)\nthis:\n  (csa \\<in> consistent_sign_vectors fs UNIV \\<and> has_no_zeros csa) =\n  (csa\n   \\<in> set (find_consistent_signs_at_roots (coprime_r (cast_rat_list fs))\n               (cast_rat_list fs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma range_eq: \n  fixes a\n  fixes b\n  shows \"a = b \\<longrightarrow> range a = range b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b \\<longrightarrow> range a = range b", "by simp"], ["", "lemma removeAt_distinct:\n  shows \"distinct fss \\<Longrightarrow> distinct (removeAt i fss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct fss \\<Longrightarrow> distinct (removeAt i fss)", "unfolding removeAt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct fss \\<Longrightarrow> distinct (take i fss @ drop (i + 1) fss)", "by (simp add: set_take_disj_set_drop_if_distinct)"], ["", "lemma consistent_signs_atw:\n  assumes \"\\<And>p. p \\<in> set fs \\<Longrightarrow> poly p x \\<noteq> 0\"\n  shows \"consistent_sign_vec_copr fs x = signs_at fs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_sign_vec_copr fs x = signs_at fs x", "unfolding consistent_sign_vec_copr_def signs_at_def squash_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>q. if 0 < poly q x then 1 else - 1) fs =\n    map (\\<lambda>xa.\n            if 0 < poly xa x then 1 else if poly xa x < 0 then - 1 else 0)\n     fs", "by (simp add: assms)"], ["", "(* This could be an alternate (equivalent) definition *)"], ["", "lemma characterize_consistent_signs_at_roots_rw:\n  assumes \"p \\<noteq> 0\"\n  assumes copr: \"\\<And>q. q \\<in> set fs \\<Longrightarrow> coprime p q\"\n  shows \"set (characterize_consistent_signs_at_roots p fs) =\n    consistent_sign_vectors_r fs ({x. poly p x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots p fs) =\n    consistent_sign_vectors_r fs {x. poly p x = 0}", "by (simp add: assms(1) characterize_consistent_signs_at_roots_def consistent_sign_vectors_r_def poly_roots_finite characterize_root_list_p_def)"], ["", "lemma signs_at_insert:\n  assumes \"i \\<le> length qs\"\n  shows \"insertAt i (squash (poly p x)) (signs_at qs x) =\n    signs_at (insertAt i p qs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAt i (squash (poly p x)) (signs_at qs x) =\n    signs_at (insertAt i p qs) x", "unfolding insertAt_def signs_at_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take i (map (\\<lambda>xa. squash (poly xa x)) qs) @\n    squash (poly p x) # drop i (map (\\<lambda>xa. squash (poly xa x)) qs) =\n    map (\\<lambda>xa. squash (poly xa x)) (take i qs @ p # drop i qs)", "using assms take_map"], ["proof (prove)\nusing this:\n  i \\<le> length qs\n  take ?n (map ?f ?xs) = map ?f (take ?n ?xs)\n\ngoal (1 subgoal):\n 1. take i (map (\\<lambda>xa. squash (poly xa x)) qs) @\n    squash (poly p x) # drop i (map (\\<lambda>xa. squash (poly xa x)) qs) =\n    map (\\<lambda>xa. squash (poly xa x)) (take i qs @ p # drop i qs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> length qs;\n     \\<And>n f xs. take n (map f xs) = map f (take n xs)\\<rbrakk>\n    \\<Longrightarrow> drop i (map (\\<lambda>xa. squash (poly xa x)) qs) =\n                      map (\\<lambda>xa. squash (poly xa x)) (drop i qs)", "apply (subst drop_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> length qs;\n     \\<And>n f xs. take n (map f xs) = map f (take n xs)\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>xa. squash (poly xa x)) (drop i qs) =\n                      map (\\<lambda>xa. squash (poly xa x)) (drop i qs)", "by simp"], ["", "lemma length_removeAt:\n  assumes \"i < length ls\"\n  shows \"length (removeAt i ls) = length ls - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (removeAt i ls) = length ls - 1", "unfolding removeAt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take i ls @ drop (i + 1) ls) = length ls - 1", "using assms"], ["proof (prove)\nusing this:\n  i < length ls\n\ngoal (1 subgoal):\n 1. length (take i ls @ drop (i + 1) ls) = length ls - 1", "by auto"], ["", "lemma insertAt_removeAt:\n  assumes \"i < length ls\"\n  shows \"insertAt i (ls!i) (removeAt i ls) = ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAt i (ls ! i) (removeAt i ls) = ls", "unfolding insertAt_def removeAt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take i (take i ls @ drop (i + 1) ls) @\n    ls ! i # drop i (take i ls @ drop (i + 1) ls) =\n    ls", "using assms"], ["proof (prove)\nusing this:\n  i < length ls\n\ngoal (1 subgoal):\n 1. take i (take i ls @ drop (i + 1) ls) @\n    ls ! i # drop i (take i ls @ drop (i + 1) ls) =\n    ls", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length ls \\<Longrightarrow>\n    take i ls @ ls ! i # drop (Suc i) ls = ls", "by (simp add: Cons_nth_drop_Suc)"], ["", "lemma insertAt_nth:\n  assumes \"i \\<le> length ls\"\n  shows \"insertAt i n ls ! i = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAt i n ls ! i = n", "unfolding insertAt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (take i ls @ n # drop i ls) ! i = n", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> length ls\n\ngoal (1 subgoal):\n 1. (take i ls @ n # drop i ls) ! i = n", "by (simp add: nth_append_take)"], ["", "lemma length_signs_at[simp]:\n  shows \"length (signs_at qs x) = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (signs_at qs x) = length qs", "unfolding signs_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (squash \\<circ> (\\<lambda>q. poly q x)) qs) = length qs", "by auto"], ["", "lemma find_csa_at_index:\n  assumes \"i < length fss\"\n  assumes \"\\<And>p q. p \\<in> set fss \\<Longrightarrow> q \\<in> set fss \\<Longrightarrow> p \\<noteq> q \\<Longrightarrow> coprime p q\"\n  assumes \"\\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0\"\n  assumes \"distinct fss\"\n  shows \"\n  set (map (\\<lambda>v. insertAt i 0 v) (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "from removeAt_distinct[OF assms(4)]"], ["proof (chain)\npicking this:\n  distinct (removeAt ?i fss)", "have neq: \"fss ! i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  distinct (removeAt ?i fss)\n\ngoal (1 subgoal):\n 1. fss ! i \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  distinct (removeAt ?i fss)\n  i < length fss\n  \\<lbrakk>?p \\<in> set fss; ?q \\<in> set fss; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?p ?q\n  ?p \\<in> set fss \\<Longrightarrow> ?p \\<noteq> 0\n  distinct fss\n\ngoal (1 subgoal):\n 1. fss ! i \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  fss ! i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "have cop: \"\\<And>q. q \\<in> set (removeAt i fss) \\<Longrightarrow> coprime (fss ! i) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> set (removeAt i fss) \\<Longrightarrow>\n       comm_monoid_mult_class.coprime (fss ! i) q", "using assms"], ["proof (prove)\nusing this:\n  i < length fss\n  \\<lbrakk>?p \\<in> set fss; ?q \\<in> set fss; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?p ?q\n  ?p \\<in> set fss \\<Longrightarrow> ?p \\<noteq> 0\n  distinct fss\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> set (removeAt i fss) \\<Longrightarrow>\n       comm_monoid_mult_class.coprime (fss ! i) q", "unfolding removeAt_def"], ["proof (prove)\nusing this:\n  i < length fss\n  \\<lbrakk>?p \\<in> set fss; ?q \\<in> set fss; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?p ?q\n  ?p \\<in> set fss \\<Longrightarrow> ?p \\<noteq> 0\n  distinct fss\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> set (take i fss @ drop (i + 1) fss) \\<Longrightarrow>\n       comm_monoid_mult_class.coprime (fss ! i) q", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>i < length fss;\n        \\<And>p q.\n           \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n           \\<Longrightarrow> algebraic_semidom_class.coprime p q;\n        \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0;\n        distinct fss; q \\<in> set (take i fss)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime (fss ! i) q\n 2. \\<And>q.\n       \\<lbrakk>i < length fss;\n        \\<And>p q.\n           \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n           \\<Longrightarrow> algebraic_semidom_class.coprime p q;\n        \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0;\n        distinct fss; q \\<in> set (drop (Suc i) fss)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime (fss ! i) q", "using dual_order.strict_trans find_first_unique image_iff less_imp_le_nat less_not_refl nth_image nth_mem"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b < ?a; ?c < ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n  \\<lbrakk>distinct ?xs; ?i < length ?xs\\<rbrakk>\n  \\<Longrightarrow> find_first (?xs ! ?i) ?xs = ?i\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n  \\<not> ?n < ?n\n  ?l \\<le> length ?xs \\<Longrightarrow>\n  (!) ?xs ` {0..<?l} = set (take ?l ?xs)\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>i < length fss;\n        \\<And>p q.\n           \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n           \\<Longrightarrow> algebraic_semidom_class.coprime p q;\n        \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0;\n        distinct fss; q \\<in> set (take i fss)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime (fss ! i) q\n 2. \\<And>q.\n       \\<lbrakk>i < length fss;\n        \\<And>p q.\n           \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n           \\<Longrightarrow> algebraic_semidom_class.coprime p q;\n        \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0;\n        distinct fss; q \\<in> set (drop (Suc i) fss)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime (fss ! i) q", "apply (smt atLeastLessThan_iff dual_order.strict_trans find_first_unique image_iff less_imp_le_nat less_not_refl nth_image nth_mem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>i < length fss;\n        \\<And>p q.\n           \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n           \\<Longrightarrow> algebraic_semidom_class.coprime p q;\n        \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0;\n        distinct fss; q \\<in> set (drop (Suc i) fss)\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime (fss ! i) q", "by (metis Cons_nth_drop_Suc distinct.simps(2) distinct_drop in_set_dropD nth_mem)"], ["proof (state)\nthis:\n  ?q \\<in> set (removeAt i fss) \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (fss ! i) ?q\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "from find_consistent_signs_at_roots[OF neq]"], ["proof (chain)\npicking this:\n  (\\<And>q.\n      q \\<in> set ?qs \\<Longrightarrow>\n      algebraic_semidom_class.coprime (fss ! i) q) \\<Longrightarrow>\n  set (find_consistent_signs_at_roots (fss ! i) ?qs) =\n  set (characterize_consistent_signs_at_roots (fss ! i) ?qs)", "have \"set (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)) =\n        set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss))\""], ["proof (prove)\nusing this:\n  (\\<And>q.\n      q \\<in> set ?qs \\<Longrightarrow>\n      algebraic_semidom_class.coprime (fss ! i) q) \\<Longrightarrow>\n  set (find_consistent_signs_at_roots (fss ! i) ?qs) =\n  set (characterize_consistent_signs_at_roots (fss ! i) ?qs)\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)) =\n    set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss))", "using cop"], ["proof (prove)\nusing this:\n  (\\<And>q.\n      q \\<in> set ?qs \\<Longrightarrow>\n      algebraic_semidom_class.coprime (fss ! i) q) \\<Longrightarrow>\n  set (find_consistent_signs_at_roots (fss ! i) ?qs) =\n  set (characterize_consistent_signs_at_roots (fss ! i) ?qs)\n  ?q \\<in> set (removeAt i fss) \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (fss ! i) ?q\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)) =\n    set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss))", "by auto"], ["proof (state)\nthis:\n  set (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)) =\n  set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss))\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "then"], ["proof (chain)\npicking this:\n  set (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)) =\n  set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss))", "have eq:  \"set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i)\n            (removeAt i fss))) = insertAt i 0 ` set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss)) \""], ["proof (prove)\nusing this:\n  set (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)) =\n  set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss))\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    insertAt i 0 `\n    set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss))", "by simp"], ["proof (state)\nthis:\n  set (map (insertAt i 0)\n        (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n  insertAt i 0 `\n  set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss))\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "from characterize_consistent_signs_at_roots_rw[OF neq cop]"], ["proof (chain)\npicking this:\n  (\\<And>q.\n      q \\<in> set ?fs \\<Longrightarrow>\n      q \\<in> set (removeAt i fss)) \\<Longrightarrow>\n  set (characterize_consistent_signs_at_roots (fss ! i) ?fs) =\n  consistent_sign_vectors_r ?fs {x. poly (fss ! i) x = 0}", "have eq2: \"set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss)) = consistent_sign_vectors_r (removeAt i fss)  {x. poly (fss ! i) x = 0}\""], ["proof (prove)\nusing this:\n  (\\<And>q.\n      q \\<in> set ?fs \\<Longrightarrow>\n      q \\<in> set (removeAt i fss)) \\<Longrightarrow>\n  set (characterize_consistent_signs_at_roots (fss ! i) ?fs) =\n  consistent_sign_vectors_r ?fs {x. poly (fss ! i) x = 0}\n\ngoal (1 subgoal):\n 1. set (characterize_consistent_signs_at_roots (fss ! i)\n          (removeAt i fss)) =\n    consistent_sign_vectors_r (removeAt i fss) {x. poly (fss ! i) x = 0}", "."], ["proof (state)\nthis:\n  set (characterize_consistent_signs_at_roots (fss ! i) (removeAt i fss)) =\n  consistent_sign_vectors_r (removeAt i fss) {x. poly (fss ! i) x = 0}\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "have ile: \"i \\<le> length (removeAt i fss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length (removeAt i fss)", "using  length_removeAt[OF assms(1)] assms(1)"], ["proof (prove)\nusing this:\n  length (removeAt i fss) = length fss - 1\n  i < length fss\n\ngoal (1 subgoal):\n 1. i \\<le> length (removeAt i fss)", "by linarith"], ["proof (state)\nthis:\n  i \\<le> length (removeAt i fss)\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "have 1: \"\\<And>xb. poly (fss ! i) xb = 0 \\<Longrightarrow>\n          insertAt i 0 (signs_at (removeAt i fss) xb) \\<in> range (signs_at fss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb)\n       \\<in> range (signs_at fss)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb)\n       \\<in> range (signs_at fss)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb)\n       \\<in> range (signs_at fss)", "assume \"poly (fss ! i) x = 0\""], ["proof (state)\nthis:\n  poly (fss ! i) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb)\n       \\<in> range (signs_at fss)", "then"], ["proof (chain)\npicking this:\n  poly (fss ! i) x = 0", "have \"insertAt i 0 (signs_at (removeAt i fss) x) =\n        insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x)\""], ["proof (prove)\nusing this:\n  poly (fss ! i) x = 0\n\ngoal (1 subgoal):\n 1. insertAt i 0 (signs_at (removeAt i fss) x) =\n    insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x)", "by (auto simp add: squash_def)"], ["proof (state)\nthis:\n  insertAt i 0 (signs_at (removeAt i fss) x) =\n  insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x)\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb)\n       \\<in> range (signs_at fss)", "also"], ["proof (state)\nthis:\n  insertAt i 0 (signs_at (removeAt i fss) x) =\n  insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x)\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb)\n       \\<in> range (signs_at fss)", "have \"... =  signs_at (insertAt i (fss ! i)  (removeAt i fss)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x) =\n    signs_at (insertAt i (fss ! i) (removeAt i fss)) x", "apply (intro signs_at_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length (removeAt i fss)", "using  length_removeAt[OF assms(1)]"], ["proof (prove)\nusing this:\n  length (removeAt i fss) = length fss - 1\n\ngoal (1 subgoal):\n 1. i \\<le> length (removeAt i fss)", "using assms(1)"], ["proof (prove)\nusing this:\n  length (removeAt i fss) = length fss - 1\n  i < length fss\n\ngoal (1 subgoal):\n 1. i \\<le> length (removeAt i fss)", "by linarith"], ["proof (state)\nthis:\n  insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x) =\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb)\n       \\<in> range (signs_at fss)", "also"], ["proof (state)\nthis:\n  insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x) =\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb)\n       \\<in> range (signs_at fss)", "have \"... = signs_at fss x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signs_at (insertAt i (fss ! i) (removeAt i fss)) x = signs_at fss x", "unfolding insertAt_removeAt[OF assms(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. signs_at fss x = signs_at fss x", "by auto"], ["proof (state)\nthis:\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x = signs_at fss x\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb)\n       \\<in> range (signs_at fss)", "ultimately"], ["proof (chain)\npicking this:\n  insertAt i 0 (signs_at (removeAt i fss) x) =\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x = signs_at fss x", "have *:\"insertAt i 0 (signs_at (removeAt i fss) x) = signs_at fss x\""], ["proof (prove)\nusing this:\n  insertAt i 0 (signs_at (removeAt i fss) x) =\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x = signs_at fss x\n\ngoal (1 subgoal):\n 1. insertAt i 0 (signs_at (removeAt i fss) x) = signs_at fss x", "by auto"], ["proof (state)\nthis:\n  insertAt i 0 (signs_at (removeAt i fss) x) = signs_at fss x\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb)\n       \\<in> range (signs_at fss)", "thus \"insertAt i 0 (signs_at (removeAt i fss) x) \\<in> range (signs_at fss)\""], ["proof (prove)\nusing this:\n  insertAt i 0 (signs_at (removeAt i fss) x) = signs_at fss x\n\ngoal (1 subgoal):\n 1. insertAt i 0 (signs_at (removeAt i fss) x) \\<in> range (signs_at fss)", "by auto"], ["proof (state)\nthis:\n  insertAt i 0 (signs_at (removeAt i fss) x) \\<in> range (signs_at fss)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (fss ! i) ?xb = 0 \\<Longrightarrow>\n  insertAt i 0 (signs_at (removeAt i fss) ?xb) \\<in> range (signs_at fss)\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "have 2: \"\\<And>xa. signs_at fss xa ! i = 0 \\<Longrightarrow>\n          i \\<le> length (removeAt i fss) \\<Longrightarrow>\n          signs_at fss xa\n          \\<in> insertAt i 0 `\n             signs_at (removeAt i fss) `\n             {x. poly (fss ! i) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "assume \"signs_at fss x ! i = 0\""], ["proof (state)\nthis:\n  signs_at fss x ! i = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "then"], ["proof (chain)\npicking this:\n  signs_at fss x ! i = 0", "have z:\"poly (fss ! i) x = 0\""], ["proof (prove)\nusing this:\n  signs_at fss x ! i = 0\n\ngoal (1 subgoal):\n 1. poly (fss ! i) x = 0", "unfolding signs_at_def o_def squash_def"], ["proof (prove)\nusing this:\n  map (\\<lambda>xa.\n          if 0 < poly xa x then 1 else if poly xa x < 0 then - 1 else 0)\n   fss !\n  i =\n  0\n\ngoal (1 subgoal):\n 1. poly (fss ! i) x = 0", "by (smt assms(1) class_field.zero_not_one nth_map zero_neq_neg_one)"], ["proof (state)\nthis:\n  poly (fss ! i) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "then"], ["proof (chain)\npicking this:\n  poly (fss ! i) x = 0", "have \"insertAt i 0 (signs_at (removeAt i fss) x) =\n      insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x)\""], ["proof (prove)\nusing this:\n  poly (fss ! i) x = 0\n\ngoal (1 subgoal):\n 1. insertAt i 0 (signs_at (removeAt i fss) x) =\n    insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x)", "by (auto simp add: squash_def)"], ["proof (state)\nthis:\n  insertAt i 0 (signs_at (removeAt i fss) x) =\n  insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "also"], ["proof (state)\nthis:\n  insertAt i 0 (signs_at (removeAt i fss) x) =\n  insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "have \"... =  signs_at (insertAt i (fss ! i)  (removeAt i fss)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x) =\n    signs_at (insertAt i (fss ! i) (removeAt i fss)) x", "apply (intro signs_at_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length (removeAt i fss)", "using  length_removeAt[OF assms(1)]"], ["proof (prove)\nusing this:\n  length (removeAt i fss) = length fss - 1\n\ngoal (1 subgoal):\n 1. i \\<le> length (removeAt i fss)", "using assms(1)"], ["proof (prove)\nusing this:\n  length (removeAt i fss) = length fss - 1\n  i < length fss\n\ngoal (1 subgoal):\n 1. i \\<le> length (removeAt i fss)", "by linarith"], ["proof (state)\nthis:\n  insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x) =\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "also"], ["proof (state)\nthis:\n  insertAt i (squash (poly (fss ! i) x)) (signs_at (removeAt i fss) x) =\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "have \"... = signs_at fss x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signs_at (insertAt i (fss ! i) (removeAt i fss)) x = signs_at fss x", "unfolding insertAt_removeAt[OF assms(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. signs_at fss x = signs_at fss x", "by auto"], ["proof (state)\nthis:\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x = signs_at fss x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "ultimately"], ["proof (chain)\npicking this:\n  insertAt i 0 (signs_at (removeAt i fss) x) =\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x = signs_at fss x", "have *:\"insertAt i 0 (signs_at (removeAt i fss) x) = signs_at fss x\""], ["proof (prove)\nusing this:\n  insertAt i 0 (signs_at (removeAt i fss) x) =\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x\n  signs_at (insertAt i (fss ! i) (removeAt i fss)) x = signs_at fss x\n\ngoal (1 subgoal):\n 1. insertAt i 0 (signs_at (removeAt i fss) x) = signs_at fss x", "by auto"], ["proof (state)\nthis:\n  insertAt i 0 (signs_at (removeAt i fss) x) = signs_at fss x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>signs_at fss xa ! i = 0;\n        i \\<le> length (removeAt i fss)\\<rbrakk>\n       \\<Longrightarrow> signs_at fss xa\n                         \\<in> insertAt i 0 `\n                               signs_at (removeAt i fss) `\n                               {x. poly (fss ! i) x = 0}", "thus \"signs_at fss x \\<in> insertAt i 0 ` signs_at (removeAt i fss) ` {x. poly (fss ! i) x = 0}\""], ["proof (prove)\nusing this:\n  insertAt i 0 (signs_at (removeAt i fss) x) = signs_at fss x\n\ngoal (1 subgoal):\n 1. signs_at fss x\n    \\<in> insertAt i 0 `\n          signs_at (removeAt i fss) ` {x. poly (fss ! i) x = 0}", "using z"], ["proof (prove)\nusing this:\n  insertAt i 0 (signs_at (removeAt i fss) x) = signs_at fss x\n  poly (fss ! i) x = 0\n\ngoal (1 subgoal):\n 1. signs_at fss x\n    \\<in> insertAt i 0 `\n          signs_at (removeAt i fss) ` {x. poly (fss ! i) x = 0}", "by (metis (mono_tags, lifting) mem_Collect_eq rev_image_eqI)"], ["proof (state)\nthis:\n  signs_at fss x\n  \\<in> insertAt i 0 ` signs_at (removeAt i fss) ` {x. poly (fss ! i) x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>signs_at fss ?xa ! i = 0;\n   i \\<le> length (removeAt i fss)\\<rbrakk>\n  \\<Longrightarrow> signs_at fss ?xa\n                    \\<in> insertAt i 0 `\n                          signs_at (removeAt i fss) `\n                          {x. poly (fss ! i) x = 0}\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "have \"insertAt i 0 ` consistent_sign_vectors_r (removeAt i fss)  {x. poly (fss ! i) x = 0} =\n         {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAt i 0 `\n    consistent_sign_vectors_r (removeAt i fss) {x. poly (fss ! i) x = 0} =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "unfolding consistent_sign_vectors_r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertAt i 0 ` signs_at (removeAt i fss) ` {x. poly (fss ! i) x = 0} =\n    {v \\<in> range (signs_at fss). v ! i = 0}", "apply (auto simp add: 1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       insertAt i 0 (signs_at (removeAt i fss) xb) ! i = 0\n 2. \\<And>xa.\n       signs_at fss xa ! i = 0 \\<Longrightarrow>\n       signs_at fss xa\n       \\<in> insertAt i 0 `\n             signs_at (removeAt i fss) ` {x. poly (fss ! i) x = 0}", "apply (subst insertAt_nth)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       i \\<le> length (signs_at (removeAt i fss) xb)\n 2. \\<And>xb. poly (fss ! i) xb = 0 \\<Longrightarrow> 0 = 0\n 3. \\<And>xa.\n       signs_at fss xa ! i = 0 \\<Longrightarrow>\n       signs_at fss xa\n       \\<in> insertAt i 0 `\n             signs_at (removeAt i fss) ` {x. poly (fss ! i) x = 0}", "using ile"], ["proof (prove)\nusing this:\n  i \\<le> length (removeAt i fss)\n\ngoal (3 subgoals):\n 1. \\<And>xb.\n       poly (fss ! i) xb = 0 \\<Longrightarrow>\n       i \\<le> length (signs_at (removeAt i fss) xb)\n 2. \\<And>xb. poly (fss ! i) xb = 0 \\<Longrightarrow> 0 = 0\n 3. \\<And>xa.\n       signs_at fss xa ! i = 0 \\<Longrightarrow>\n       signs_at fss xa\n       \\<in> insertAt i 0 `\n             signs_at (removeAt i fss) ` {x. poly (fss ! i) x = 0}", "by (auto simp add: 2)"], ["proof (state)\nthis:\n  insertAt i 0 `\n  consistent_sign_vectors_r (removeAt i fss) {x. poly (fss ! i) x = 0} =\n  {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "thus ?thesis"], ["proof (prove)\nusing this:\n  insertAt i 0 `\n  consistent_sign_vectors_r (removeAt i fss) {x. poly (fss ! i) x = 0} =\n  {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "unfolding eq eq2"], ["proof (prove)\nusing this:\n  insertAt i 0 `\n  consistent_sign_vectors_r (removeAt i fss) {x. poly (fss ! i) x = 0} =\n  {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. insertAt i 0 `\n    consistent_sign_vectors_r (removeAt i fss) {x. poly (fss ! i) x = 0} =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "."], ["proof (state)\nthis:\n  set (map (insertAt i 0)\n        (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n  {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_concat_map:\n  assumes \"i < length ls\"\n  assumes \"x \\<in> set (f (ls ! i))\"\n  shows \"x \\<in> set (concat (map f ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (concat (map f ls))", "using assms"], ["proof (prove)\nusing this:\n  i < length ls\n  x \\<in> set (f (ls ! i))\n\ngoal (1 subgoal):\n 1. x \\<in> set (concat (map f ls))", "by auto"], ["", "lemma find_csas_lemma_onezero_gen:\n  fixes qs:: \"rat poly list\"\n  assumes fs: \"factorize_polys qs = (fs,data)\"\n  assumes fss: \"fss = cast_rat_list fs\"\n  shows \"(csa \\<in> (consistent_sign_vectors_r fss UNIV) \\<and> \\<not>(has_no_zeros csa))\n    \\<longleftrightarrow>  csa \\<in> set (find_sgas_aux fss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors_r fss UNIV \\<and>\n     \\<not> has_no_zeros csa) =\n    (csa \\<in> set (find_sgas_aux fss))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors_r fss UNIV \\<and>\n     \\<not> has_no_zeros csa) =\n    (csa \\<in> set (find_sgas_aux fss))", "have a:\"(\\<And>p q. p \\<in> set fss \\<Longrightarrow>\n          q \\<in> set fss \\<Longrightarrow>\n          p \\<noteq> q \\<Longrightarrow> coprime p\n           q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime p q", "using cast_rat_list_def factorize_polys_map_coprime fs fss"], ["proof (prove)\nusing this:\n  cast_rat_list ?qs = map real_of_rat_poly ?qs\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data);\n   ?fss = map real_of_rat_poly ?fs; ?f \\<in> set ?fss; ?g \\<in> set ?fss;\n   ?f \\<noteq> ?g\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?f ?g\n  factorize_polys qs = (fs, data)\n  fss = cast_rat_list fs\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> comm_monoid_mult_class.coprime p q", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<in> set fss; ?q \\<in> set fss; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?p ?q\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors_r fss UNIV \\<and>\n     \\<not> has_no_zeros csa) =\n    (csa \\<in> set (find_sgas_aux fss))", "have b:\"(\\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0", "using factorize_polys_map_square_free_prod_list semidom_class.prod_list_zero_iff square_free_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data);\n   ?fss = map real_of_rat_poly ?fs\\<rbrakk>\n  \\<Longrightarrow> square_free (prod_list ?fss)\n  (prod_list ?xs = (0::?'a)) = ((0::?'a) \\<in> set ?xs)\n  square_free ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd ?p))\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0", "using cast_rat_list_def fs fss"], ["proof (prove)\nusing this:\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data);\n   ?fss = map real_of_rat_poly ?fs\\<rbrakk>\n  \\<Longrightarrow> square_free (prod_list ?fss)\n  (prod_list ?xs = (0::?'a)) = ((0::?'a) \\<in> set ?xs)\n  square_free ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd ?p))\n  cast_rat_list ?qs = map real_of_rat_poly ?qs\n  factorize_polys qs = (fs, data)\n  fss = cast_rat_list fs\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  ?p \\<in> set fss \\<Longrightarrow> ?p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors_r fss UNIV \\<and>\n     \\<not> has_no_zeros csa) =\n    (csa \\<in> set (find_sgas_aux fss))", "have c:\"distinct fss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct fss", "using factorize_polys_map_distinct[OF assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  ?fss = map real_of_rat_poly fs \\<Longrightarrow> distinct ?fss\n  fss = cast_rat_list fs\n\ngoal (1 subgoal):\n 1. distinct fss", "unfolding cast_rat_list_def"], ["proof (prove)\nusing this:\n  ?fss = map real_of_rat_poly fs \\<Longrightarrow> distinct ?fss\n  fss = map real_of_rat_poly fs\n\ngoal (1 subgoal):\n 1. distinct fss", "by auto"], ["proof (state)\nthis:\n  distinct fss\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors_r fss UNIV \\<and>\n     \\<not> has_no_zeros csa) =\n    (csa \\<in> set (find_sgas_aux fss))", "have forwards: \"csa \\<in> (consistent_sign_vectors_r fss UNIV) \\<Longrightarrow>\n    \\<not> (has_no_zeros csa)\n    \\<Longrightarrow> csa \\<in> set (find_sgas_aux fss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n     \\<not> has_no_zeros csa\\<rbrakk>\n    \\<Longrightarrow> csa \\<in> set (find_sgas_aux fss)", "unfolding find_sgas_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n     \\<not> has_no_zeros csa\\<rbrakk>\n    \\<Longrightarrow> csa\n                      \\<in> set (concat\n                                  (map (\\<lambda>i.\n     map (insertAt i 0)\n      (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n                                    [0..<length fss]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n     \\<not> has_no_zeros csa\\<rbrakk>\n    \\<Longrightarrow> csa\n                      \\<in> set (concat\n                                  (map (\\<lambda>i.\n     map (insertAt i 0)\n      (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n                                    [0..<length fss]))", "assume csa: \"csa \\<in> (consistent_sign_vectors_r fss UNIV)\""], ["proof (state)\nthis:\n  csa \\<in> consistent_sign_vectors_r fss UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n     \\<not> has_no_zeros csa\\<rbrakk>\n    \\<Longrightarrow> csa\n                      \\<in> set (concat\n                                  (map (\\<lambda>i.\n     map (insertAt i 0)\n      (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n                                    [0..<length fss]))", "assume hnz: \"\\<not>(has_no_zeros csa)\""], ["proof (state)\nthis:\n  \\<not> has_no_zeros csa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n     \\<not> has_no_zeros csa\\<rbrakk>\n    \\<Longrightarrow> csa\n                      \\<in> set (concat\n                                  (map (\\<lambda>i.\n     map (insertAt i 0)\n      (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n                                    [0..<length fss]))", "then"], ["proof (chain)\npicking this:\n  \\<not> has_no_zeros csa", "obtain i where i: \"i < length csa\" \"csa ! i = 0\""], ["proof (prove)\nusing this:\n  \\<not> has_no_zeros csa\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length csa; csa ! i = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding hnz_prop"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<exists>k<length csa. csa ! k = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length csa; csa ! i = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length csa\n  csa ! i = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n     \\<not> has_no_zeros csa\\<rbrakk>\n    \\<Longrightarrow> csa\n                      \\<in> set (concat\n                                  (map (\\<lambda>i.\n     map (insertAt i 0)\n      (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n                                    [0..<length fss]))", "then"], ["proof (chain)\npicking this:\n  i < length csa\n  csa ! i = 0", "have cin: \"csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\""], ["proof (prove)\nusing this:\n  i < length csa\n  csa ! i = 0\n\ngoal (1 subgoal):\n 1. csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "using csa"], ["proof (prove)\nusing this:\n  i < length csa\n  csa ! i = 0\n  csa \\<in> consistent_sign_vectors_r fss UNIV\n\ngoal (1 subgoal):\n 1. csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "by auto"], ["proof (state)\nthis:\n  csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n     \\<not> has_no_zeros csa\\<rbrakk>\n    \\<Longrightarrow> csa\n                      \\<in> set (concat\n                                  (map (\\<lambda>i.\n     map (insertAt i 0)\n      (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n                                    [0..<length fss]))", "have 1:\"i < length fss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length fss", "using i csa"], ["proof (prove)\nusing this:\n  i < length csa\n  csa ! i = 0\n  csa \\<in> consistent_sign_vectors_r fss UNIV\n\ngoal (1 subgoal):\n 1. i < length fss", "unfolding consistent_sign_vectors_r_def"], ["proof (prove)\nusing this:\n  i < length csa\n  csa ! i = 0\n  csa \\<in> range (signs_at fss)\n\ngoal (1 subgoal):\n 1. i < length fss", "by auto"], ["proof (state)\nthis:\n  i < length fss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n     \\<not> has_no_zeros csa\\<rbrakk>\n    \\<Longrightarrow> csa\n                      \\<in> set (concat\n                                  (map (\\<lambda>i.\n     map (insertAt i 0)\n      (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n                                    [0..<length fss]))", "from find_csa_at_index[OF 1 a b c]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>p q.\n              \\<lbrakk>p \\<in> set fss; q \\<in> set fss;\n               p \\<noteq> q\\<rbrakk>\n              \\<Longrightarrow> p \\<in> set fss;\n   \\<And>p q.\n      \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> q \\<in> set fss;\n   \\<And>p q.\n      \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> p \\<noteq> q;\n   \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<in> set fss\\<rbrakk>\n  \\<Longrightarrow> set (map (insertAt i 0)\n                          (find_consistent_signs_at_roots (fss ! i)\n                            (removeAt i fss))) =\n                    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "have eq: \"set (map (\\<lambda>v. insertAt i 0 v) (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n      {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>p q.\n              \\<lbrakk>p \\<in> set fss; q \\<in> set fss;\n               p \\<noteq> q\\<rbrakk>\n              \\<Longrightarrow> p \\<in> set fss;\n   \\<And>p q.\n      \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> q \\<in> set fss;\n   \\<And>p q.\n      \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> p \\<noteq> q;\n   \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<in> set fss\\<rbrakk>\n  \\<Longrightarrow> set (map (insertAt i 0)\n                          (find_consistent_signs_at_roots (fss ! i)\n                            (removeAt i fss))) =\n                    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "by auto"], ["proof (state)\nthis:\n  set (map (insertAt i 0)\n        (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n  {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n     \\<not> has_no_zeros csa\\<rbrakk>\n    \\<Longrightarrow> csa\n                      \\<in> set (concat\n                                  (map (\\<lambda>i.\n     map (insertAt i 0)\n      (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n                                    [0..<length fss]))", "show \"csa \\<in> set (concat (map (\\<lambda>i. map (insertAt i 0) (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) [0..<length fss]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (concat\n                (map (\\<lambda>i.\n                         map (insertAt i 0)\n                          (find_consistent_signs_at_roots (fss ! i)\n                            (removeAt i fss)))\n                  [0..<length fss]))", "using cin i"], ["proof (prove)\nusing this:\n  csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n  i < length csa\n  csa ! i = 0\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (concat\n                (map (\\<lambda>i.\n                         map (insertAt i 0)\n                          (find_consistent_signs_at_roots (fss ! i)\n                            (removeAt i fss)))\n                  [0..<length fss]))", "unfolding eq[symmetric]"], ["proof (prove)\nusing this:\n  csa\n  \\<in> set (map (insertAt i 0)\n              (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n  i < length csa\n  csa ! i = 0\n\ngoal (1 subgoal):\n 1. csa\n    \\<in> set (concat\n                (map (\\<lambda>i.\n                         map (insertAt i 0)\n                          (find_consistent_signs_at_roots (fss ! i)\n                            (removeAt i fss)))\n                  [0..<length fss]))", "apply (intro  in_set_concat_map[of i])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>csa\n             \\<in> set (map (insertAt i 0)\n                         (find_consistent_signs_at_roots (fss ! i)\n                           (removeAt i fss)));\n     i < length csa; csa ! i = 0\\<rbrakk>\n    \\<Longrightarrow> i < length [0..<length fss]\n 2. \\<lbrakk>csa\n             \\<in> set (map (insertAt i 0)\n                         (find_consistent_signs_at_roots (fss ! i)\n                           (removeAt i fss)));\n     i < length csa; csa ! i = 0\\<rbrakk>\n    \\<Longrightarrow> csa\n                      \\<in> set (map (insertAt ([0..<length fss] ! i) 0)\n                                  (find_consistent_signs_at_roots\n                                    (fss ! ([0..<length fss] ! i))\n                                    (removeAt ([0..<length fss] ! i) fss)))", "using 1"], ["proof (prove)\nusing this:\n  i < length fss\n\ngoal (2 subgoals):\n 1. \\<lbrakk>csa\n             \\<in> set (map (insertAt i 0)\n                         (find_consistent_signs_at_roots (fss ! i)\n                           (removeAt i fss)));\n     i < length csa; csa ! i = 0\\<rbrakk>\n    \\<Longrightarrow> i < length [0..<length fss]\n 2. \\<lbrakk>csa\n             \\<in> set (map (insertAt i 0)\n                         (find_consistent_signs_at_roots (fss ! i)\n                           (removeAt i fss)));\n     i < length csa; csa ! i = 0\\<rbrakk>\n    \\<Longrightarrow> csa\n                      \\<in> set (map (insertAt ([0..<length fss] ! i) 0)\n                                  (find_consistent_signs_at_roots\n                                    (fss ! ([0..<length fss] ! i))\n                                    (removeAt ([0..<length fss] ! i) fss)))", "by auto"], ["proof (state)\nthis:\n  csa\n  \\<in> set (concat\n              (map (\\<lambda>i.\n                       map (insertAt i 0)\n                        (find_consistent_signs_at_roots (fss ! i)\n                          (removeAt i fss)))\n                [0..<length fss]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n   \\<not> has_no_zeros csa\\<rbrakk>\n  \\<Longrightarrow> csa \\<in> set (find_sgas_aux fss)\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors_r fss UNIV \\<and>\n     \\<not> has_no_zeros csa) =\n    (csa \\<in> set (find_sgas_aux fss))", "have backwards: \"csa \\<in> set (find_sgas_aux fss) \\<Longrightarrow>\n    \\<not> (has_no_zeros csa) \\<and> csa \\<in> (consistent_sign_vectors_r fss UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csa \\<in> set (find_sgas_aux fss) \\<Longrightarrow>\n    \\<not> has_no_zeros csa \\<and>\n    csa \\<in> consistent_sign_vectors_r fss UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. csa \\<in> set (find_sgas_aux fss) \\<Longrightarrow>\n    \\<not> has_no_zeros csa \\<and>\n    csa \\<in> consistent_sign_vectors_r fss UNIV", "assume *: \"csa \\<in> set (find_sgas_aux fss)\""], ["proof (state)\nthis:\n  csa \\<in> set (find_sgas_aux fss)\n\ngoal (1 subgoal):\n 1. csa \\<in> set (find_sgas_aux fss) \\<Longrightarrow>\n    \\<not> has_no_zeros csa \\<and>\n    csa \\<in> consistent_sign_vectors_r fss UNIV", "then"], ["proof (chain)\npicking this:\n  csa \\<in> set (find_sgas_aux fss)", "obtain i where i: \"i < length fss\"\n      \"csa \\<in> set (map (\\<lambda>v. insertAt i 0 v) (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\""], ["proof (prove)\nusing this:\n  csa \\<in> set (find_sgas_aux fss)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length fss;\n         csa\n         \\<in> set (map (insertAt i 0)\n                     (find_consistent_signs_at_roots (fss ! i)\n                       (removeAt i fss)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding find_sgas_aux_def"], ["proof (prove)\nusing this:\n  csa\n  \\<in> set (concat\n              (map (\\<lambda>i.\n                       map (insertAt i 0)\n                        (find_consistent_signs_at_roots (fss ! i)\n                          (removeAt i fss)))\n                [0..<length fss]))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length fss;\n         csa\n         \\<in> set (map (insertAt i 0)\n                     (find_consistent_signs_at_roots (fss ! i)\n                       (removeAt i fss)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length fss\n  csa\n  \\<in> set (map (insertAt i 0)\n              (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n\ngoal (1 subgoal):\n 1. csa \\<in> set (find_sgas_aux fss) \\<Longrightarrow>\n    \\<not> has_no_zeros csa \\<and>\n    csa \\<in> consistent_sign_vectors_r fss UNIV", "from find_csa_at_index[OF i(1) a b c]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>p q.\n              \\<lbrakk>p \\<in> set fss; q \\<in> set fss;\n               p \\<noteq> q\\<rbrakk>\n              \\<Longrightarrow> p \\<in> set fss;\n   \\<And>p q.\n      \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> q \\<in> set fss;\n   \\<And>p q.\n      \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> p \\<noteq> q;\n   \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<in> set fss\\<rbrakk>\n  \\<Longrightarrow> set (map (insertAt i 0)\n                          (find_consistent_signs_at_roots (fss ! i)\n                            (removeAt i fss))) =\n                    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "have eq: \"set (map (\\<lambda>v. insertAt i 0 v) (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n      {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>p q.\n              \\<lbrakk>p \\<in> set fss; q \\<in> set fss;\n               p \\<noteq> q\\<rbrakk>\n              \\<Longrightarrow> p \\<in> set fss;\n   \\<And>p q.\n      \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> q \\<in> set fss;\n   \\<And>p q.\n      \\<lbrakk>p \\<in> set fss; q \\<in> set fss; p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> p \\<noteq> q;\n   \\<And>p. p \\<in> set fss \\<Longrightarrow> p \\<in> set fss\\<rbrakk>\n  \\<Longrightarrow> set (map (insertAt i 0)\n                          (find_consistent_signs_at_roots (fss ! i)\n                            (removeAt i fss))) =\n                    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. set (map (insertAt i 0)\n          (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n    {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "by auto"], ["proof (state)\nthis:\n  set (map (insertAt i 0)\n        (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n  {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. csa \\<in> set (find_sgas_aux fss) \\<Longrightarrow>\n    \\<not> has_no_zeros csa \\<and>\n    csa \\<in> consistent_sign_vectors_r fss UNIV", "have *: \"csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "using i eq"], ["proof (prove)\nusing this:\n  i < length fss\n  csa\n  \\<in> set (map (insertAt i 0)\n              (find_consistent_signs_at_roots (fss ! i) (removeAt i fss)))\n  set (map (insertAt i 0)\n        (find_consistent_signs_at_roots (fss ! i) (removeAt i fss))) =\n  {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "by auto"], ["proof (state)\nthis:\n  csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. csa \\<in> set (find_sgas_aux fss) \\<Longrightarrow>\n    \\<not> has_no_zeros csa \\<and>\n    csa \\<in> consistent_sign_vectors_r fss UNIV", "then"], ["proof (chain)\npicking this:\n  csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}", "have \"length csa = length fss\""], ["proof (prove)\nusing this:\n  csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. length csa = length fss", "unfolding consistent_sign_vectors_r_def"], ["proof (prove)\nusing this:\n  csa \\<in> {v \\<in> range (signs_at fss). v ! i = 0}\n\ngoal (1 subgoal):\n 1. length csa = length fss", "by auto"], ["proof (state)\nthis:\n  length csa = length fss\n\ngoal (1 subgoal):\n 1. csa \\<in> set (find_sgas_aux fss) \\<Longrightarrow>\n    \\<not> has_no_zeros csa \\<and>\n    csa \\<in> consistent_sign_vectors_r fss UNIV", "thus ?thesis"], ["proof (prove)\nusing this:\n  length csa = length fss\n\ngoal (1 subgoal):\n 1. \\<not> has_no_zeros csa \\<and>\n    csa \\<in> consistent_sign_vectors_r fss UNIV", "unfolding has_no_zeros_def"], ["proof (prove)\nusing this:\n  length csa = length fss\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<notin> set csa \\<and>\n    csa \\<in> consistent_sign_vectors_r fss UNIV", "using *"], ["proof (prove)\nusing this:\n  length csa = length fss\n  csa \\<in> {v \\<in> consistent_sign_vectors_r fss UNIV. v ! i = 0}\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<notin> set csa \\<and>\n    csa \\<in> consistent_sign_vectors_r fss UNIV", "apply (auto simp add:in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length csa = length fss;\n     csa \\<in> consistent_sign_vectors_r fss UNIV; csa ! i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<length fss. csa ! i = 0", "using i(1)"], ["proof (prove)\nusing this:\n  i < length fss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length csa = length fss;\n     csa \\<in> consistent_sign_vectors_r fss UNIV; csa ! i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<length fss. csa ! i = 0", "by auto"], ["proof (state)\nthis:\n  \\<not> has_no_zeros csa \\<and>\n  csa \\<in> consistent_sign_vectors_r fss UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  csa \\<in> set (find_sgas_aux fss) \\<Longrightarrow>\n  \\<not> has_no_zeros csa \\<and>\n  csa \\<in> consistent_sign_vectors_r fss UNIV\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors_r fss UNIV \\<and>\n     \\<not> has_no_zeros csa) =\n    (csa \\<in> set (find_sgas_aux fss))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors_r fss UNIV \\<and>\n     \\<not> has_no_zeros csa) =\n    (csa \\<in> set (find_sgas_aux fss))", "using  forwards backwards"], ["proof (prove)\nusing this:\n  \\<lbrakk>csa \\<in> consistent_sign_vectors_r fss UNIV;\n   \\<not> has_no_zeros csa\\<rbrakk>\n  \\<Longrightarrow> csa \\<in> set (find_sgas_aux fss)\n  csa \\<in> set (find_sgas_aux fss) \\<Longrightarrow>\n  \\<not> has_no_zeros csa \\<and>\n  csa \\<in> consistent_sign_vectors_r fss UNIV\n\ngoal (1 subgoal):\n 1. (csa \\<in> consistent_sign_vectors_r fss UNIV \\<and>\n     \\<not> has_no_zeros csa) =\n    (csa \\<in> set (find_sgas_aux fss))", "by blast"], ["proof (state)\nthis:\n  (csa \\<in> consistent_sign_vectors_r fss UNIV \\<and>\n   \\<not> has_no_zeros csa) =\n  (csa \\<in> set (find_sgas_aux fss))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_append: \"List.member (l1@l2) m \\<longleftrightarrow> (List.member l1 m \\<or> List.member l2 m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (l1 @ l2) m = (List.member l1 m \\<or> List.member l2 m)", "by (simp add: List.member_def)"], ["", "lemma same_sign_cond_rationals_reals:\n  fixes qs:: \"rat poly list\"\n  assumes lenh: \"length (fst(factorize_polys qs)) > 0\"\n  shows \"set(find_sgas (map (map_poly of_rat) (fst(factorize_polys qs)))) = consistent_sign_vectors (fst(factorize_polys qs)) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "let ?ftrs = \"(fst(factorize_polys qs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "have pairwise_rel_prime: \"pairwise_coprime_list (fst(factorize_polys qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise_coprime_list (fst (factorize_polys qs))", "using factorize_polys_coprime"], ["proof (prove)\nusing this:\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data); ?f \\<in> set ?fs;\n   ?g \\<in> set ?fs; ?f \\<noteq> ?g\\<rbrakk>\n  \\<Longrightarrow> comm_monoid_mult_class.coprime ?f ?g\n\ngoal (1 subgoal):\n 1. pairwise_coprime_list (fst (factorize_polys qs))", "by (simp add: coprime_factorize)"], ["proof (state)\nthis:\n  pairwise_coprime_list (fst (factorize_polys qs))\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "have all_squarefree:\"\\<forall>q. (List.member (fst(factorize_polys qs)) q) \\<longrightarrow> (rsquarefree q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (fst (factorize_polys qs)) q \\<longrightarrow>\n       rsquarefree q", "using factorize_polys_square_free"], ["proof (prove)\nusing this:\n  \\<lbrakk>factorize_polys ?ps = (?fs, ?data); ?f \\<in> set ?fs\\<rbrakk>\n  \\<Longrightarrow> square_free ?f\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (fst (factorize_polys qs)) q \\<longrightarrow>\n       rsquarefree q", "by (metis in_set_member prod.collapse square_free_rsquarefree)"], ["proof (state)\nthis:\n  \\<forall>q.\n     List.member (fst (factorize_polys qs)) q \\<longrightarrow>\n     rsquarefree q\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "have allnonzero: \"\\<forall>q. (List.member ?ftrs q) \\<longrightarrow> q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (fst (factorize_polys qs)) q \\<longrightarrow>\n       q \\<noteq> 0", "using all_squarefree"], ["proof (prove)\nusing this:\n  \\<forall>q.\n     List.member (fst (factorize_polys qs)) q \\<longrightarrow>\n     rsquarefree q\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       List.member (fst (factorize_polys qs)) q \\<longrightarrow>\n       q \\<noteq> 0", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                List.member (fst (factorize_polys qs)) q \\<longrightarrow>\n                rsquarefree q;\n     List.member (fst (factorize_polys qs)) 0\\<rbrakk>\n    \\<Longrightarrow> False", "using rsquarefree_def"], ["proof (prove)\nusing this:\n  rsquarefree ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>a. Polynomial.order a ?p = 0 \\<or> Polynomial.order a ?p = 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                List.member (fst (factorize_polys qs)) q \\<longrightarrow>\n                rsquarefree q;\n     List.member (fst (factorize_polys qs)) 0\\<rbrakk>\n    \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  \\<forall>q.\n     List.member (fst (factorize_polys qs)) q \\<longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "have h1: \"\\<forall> csa. (csa \\<in> (consistent_sign_vectors ?ftrs UNIV) \\<and> \\<not> (has_no_zeros csa))\n    \\<longleftrightarrow>  csa \\<in> set (find_sgas_aux (cast_rat_list ?ftrs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       (csa\n        \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n        \\<not> has_no_zeros csa) =\n       (csa\n        \\<in> set (find_sgas_aux\n                    (cast_rat_list (fst (factorize_polys qs)))))", "using lenh find_csas_lemma_onezero_gen pairwise_rel_prime allnonzero"], ["proof (prove)\nusing this:\n  0 < length (fst (factorize_polys qs))\n  \\<lbrakk>factorize_polys ?qs = (?fs, ?data);\n   ?fss = cast_rat_list ?fs\\<rbrakk>\n  \\<Longrightarrow> (?csa \\<in> consistent_sign_vectors_r ?fss UNIV \\<and>\n                     \\<not> has_no_zeros ?csa) =\n                    (?csa \\<in> set (find_sgas_aux ?fss))\n  pairwise_coprime_list (fst (factorize_polys qs))\n  \\<forall>q.\n     List.member (fst (factorize_polys qs)) q \\<longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       (csa\n        \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n        \\<not> has_no_zeros csa) =\n       (csa\n        \\<in> set (find_sgas_aux\n                    (cast_rat_list (fst (factorize_polys qs)))))", "by (metis consistent_sign_vectors_consistent_sign_vectors_r eq_fst_iff)"], ["proof (state)\nthis:\n  \\<forall>csa.\n     (csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      \\<not> has_no_zeros csa) =\n     (csa\n      \\<in> set (find_sgas_aux (cast_rat_list (fst (factorize_polys qs)))))\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "have h2: \"\\<forall>csa. (csa \\<in> (consistent_sign_vectors ?ftrs UNIV) \\<and> has_no_zeros csa) \\<longleftrightarrow> \n    List.member (find_consistent_signs_at_roots (coprime_r (cast_rat_list ?ftrs)) (cast_rat_list ?ftrs)) csa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       (csa\n        \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n        has_no_zeros csa) =\n       List.member\n        (find_consistent_signs_at_roots\n          (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n          (cast_rat_list (fst (factorize_polys qs))))\n        csa", "using lenh find_csas_lemma_nozeros pairwise_rel_prime allnonzero"], ["proof (prove)\nusing this:\n  0 < length (fst (factorize_polys qs))\n  \\<lbrakk>factorize_polys ?qs = (?fs, ?data); ?fs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?csa \\<in> consistent_sign_vectors ?fs UNIV \\<and>\n                     has_no_zeros ?csa) =\n                    (?csa\n                     \\<in> set (find_consistent_signs_at_roots\n                                 (coprime_r (cast_rat_list ?fs))\n                                 (cast_rat_list ?fs)))\n  pairwise_coprime_list (fst (factorize_polys qs))\n  \\<forall>q.\n     List.member (fst (factorize_polys qs)) q \\<longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       (csa\n        \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n        has_no_zeros csa) =\n       List.member\n        (find_consistent_signs_at_roots\n          (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n          (cast_rat_list (fst (factorize_polys qs))))\n        csa", "by (metis in_set_member length_greater_0_conv prod.collapse)"], ["proof (state)\nthis:\n  \\<forall>csa.\n     (csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      has_no_zeros csa) =\n     List.member\n      (find_consistent_signs_at_roots\n        (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n        (cast_rat_list (fst (factorize_polys qs))))\n      csa\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "have h3: \"\\<forall> csa. List.member (find_sgas (map (map_poly of_rat) ?ftrs)) csa \\<longleftrightarrow> \n      ((List.member (find_sgas_aux (cast_rat_list ?ftrs)) csa) \\<or>  (List.member (find_consistent_signs_at_roots (coprime_r (cast_rat_list ?ftrs)) (cast_rat_list ?ftrs)) csa))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       List.member\n        (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n       (List.member\n         (find_sgas_aux (cast_rat_list (fst (factorize_polys qs))))\n         csa \\<or>\n        List.member\n         (find_consistent_signs_at_roots\n           (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n           (cast_rat_list (fst (factorize_polys qs))))\n         csa)", "unfolding find_sgas_def cast_rat_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       List.member\n        (let r = coprime_r (map real_of_rat_poly (fst (factorize_polys qs)))\n         in find_consistent_signs_at_roots r\n             (map real_of_rat_poly (fst (factorize_polys qs))) @\n            find_sgas_aux (map real_of_rat_poly (fst (factorize_polys qs))))\n        csa =\n       (List.member\n         (find_sgas_aux (map real_of_rat_poly (fst (factorize_polys qs))))\n         csa \\<or>\n        List.member\n         (find_consistent_signs_at_roots\n           (coprime_r (map real_of_rat_poly (fst (factorize_polys qs))))\n           (map real_of_rat_poly (fst (factorize_polys qs))))\n         csa)", "using mem_append"], ["proof (prove)\nusing this:\n  List.member (?l1.0 @ ?l2.0) ?m =\n  (List.member ?l1.0 ?m \\<or> List.member ?l2.0 ?m)\n\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       List.member\n        (let r = coprime_r (map real_of_rat_poly (fst (factorize_polys qs)))\n         in find_consistent_signs_at_roots r\n             (map real_of_rat_poly (fst (factorize_polys qs))) @\n            find_sgas_aux (map real_of_rat_poly (fst (factorize_polys qs))))\n        csa =\n       (List.member\n         (find_sgas_aux (map real_of_rat_poly (fst (factorize_polys qs))))\n         csa \\<or>\n        List.member\n         (find_consistent_signs_at_roots\n           (coprime_r (map real_of_rat_poly (fst (factorize_polys qs))))\n           (map real_of_rat_poly (fst (factorize_polys qs))))\n         csa)", "by metis"], ["proof (state)\nthis:\n  \\<forall>csa.\n     List.member\n      (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n     (List.member (find_sgas_aux (cast_rat_list (fst (factorize_polys qs))))\n       csa \\<or>\n      List.member\n       (find_consistent_signs_at_roots\n         (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n         (cast_rat_list (fst (factorize_polys qs))))\n       csa)\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "have h4: \"\\<forall> csa. List.member (find_sgas (map (map_poly of_rat) ?ftrs)) csa \\<longleftrightarrow>\n   ((csa \\<in> (consistent_sign_vectors ?ftrs UNIV) \\<and> has_no_zeros csa) \\<or>  (csa \\<in> (consistent_sign_vectors ?ftrs UNIV) \\<and> \\<not> (has_no_zeros csa)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       List.member\n        (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n       (csa\n        \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n        has_no_zeros csa \\<or>\n        csa\n        \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n        \\<not> has_no_zeros csa)", "using h1 h2 h3"], ["proof (prove)\nusing this:\n  \\<forall>csa.\n     (csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      \\<not> has_no_zeros csa) =\n     (csa\n      \\<in> set (find_sgas_aux (cast_rat_list (fst (factorize_polys qs)))))\n  \\<forall>csa.\n     (csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      has_no_zeros csa) =\n     List.member\n      (find_consistent_signs_at_roots\n        (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n        (cast_rat_list (fst (factorize_polys qs))))\n      csa\n  \\<forall>csa.\n     List.member\n      (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n     (List.member (find_sgas_aux (cast_rat_list (fst (factorize_polys qs))))\n       csa \\<or>\n      List.member\n       (find_consistent_signs_at_roots\n         (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n         (cast_rat_list (fst (factorize_polys qs))))\n       csa)\n\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       List.member\n        (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n       (csa\n        \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n        has_no_zeros csa \\<or>\n        csa\n        \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n        \\<not> has_no_zeros csa)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>csa.\n       \\<lbrakk>\\<forall>csa.\n                   (csa\n                    \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                           UNIV \\<and>\n                    \\<not> has_no_zeros csa) =\n                   (csa\n                    \\<in> set (find_sgas_aux\n                                (cast_rat_list\n                                  (fst (factorize_polys qs)))));\n        \\<forall>csa.\n           (csa\n            \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                   UNIV \\<and>\n            has_no_zeros csa) =\n           List.member\n            (find_consistent_signs_at_roots\n              (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n              (cast_rat_list (fst (factorize_polys qs))))\n            csa;\n        \\<forall>csa.\n           List.member\n            (find_sgas (map real_of_rat_poly (fst (factorize_polys qs))))\n            csa =\n           (List.member\n             (find_sgas_aux (cast_rat_list (fst (factorize_polys qs))))\n             csa \\<or>\n            List.member\n             (find_consistent_signs_at_roots\n               (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n               (cast_rat_list (fst (factorize_polys qs))))\n             csa);\n        csa\n        \\<notin> set (find_sgas_aux\n                       (cast_rat_list (fst (factorize_polys qs))));\n        List.member\n         (find_sgas_aux (cast_rat_list (fst (factorize_polys qs))))\n         csa\\<rbrakk>\n       \\<Longrightarrow> List.member\n                          (find_consistent_signs_at_roots\n                            (coprime_r\n                              (cast_rat_list (fst (factorize_polys qs))))\n                            (cast_rat_list (fst (factorize_polys qs))))\n                          csa\n 2. \\<And>csa.\n       \\<lbrakk>\\<forall>csa.\n                   (csa\n                    \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                           UNIV \\<and>\n                    \\<not> has_no_zeros csa) =\n                   (csa\n                    \\<in> set (find_sgas_aux\n                                (cast_rat_list\n                                  (fst (factorize_polys qs)))));\n        \\<forall>csa.\n           (csa\n            \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                   UNIV \\<and>\n            has_no_zeros csa) =\n           List.member\n            (find_consistent_signs_at_roots\n              (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n              (cast_rat_list (fst (factorize_polys qs))))\n            csa;\n        \\<forall>csa.\n           List.member\n            (find_sgas (map real_of_rat_poly (fst (factorize_polys qs))))\n            csa =\n           (List.member\n             (find_sgas_aux (cast_rat_list (fst (factorize_polys qs))))\n             csa \\<or>\n            List.member\n             (find_consistent_signs_at_roots\n               (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n               (cast_rat_list (fst (factorize_polys qs))))\n             csa);\n        \\<not> List.member\n                (find_consistent_signs_at_roots\n                  (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n                  (cast_rat_list (fst (factorize_polys qs))))\n                csa;\n        csa\n        \\<in> set (find_sgas_aux\n                    (cast_rat_list (fst (factorize_polys qs))))\\<rbrakk>\n       \\<Longrightarrow> List.member\n                          (find_sgas_aux\n                            (cast_rat_list (fst (factorize_polys qs))))\n                          csa", "apply (simp add: in_set_member)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>csa.\n       \\<lbrakk>\\<forall>csa.\n                   (csa\n                    \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                           UNIV \\<and>\n                    \\<not> has_no_zeros csa) =\n                   (csa\n                    \\<in> set (find_sgas_aux\n                                (cast_rat_list\n                                  (fst (factorize_polys qs)))));\n        \\<forall>csa.\n           (csa\n            \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                   UNIV \\<and>\n            has_no_zeros csa) =\n           List.member\n            (find_consistent_signs_at_roots\n              (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n              (cast_rat_list (fst (factorize_polys qs))))\n            csa;\n        \\<forall>csa.\n           List.member\n            (find_sgas (map real_of_rat_poly (fst (factorize_polys qs))))\n            csa =\n           (List.member\n             (find_sgas_aux (cast_rat_list (fst (factorize_polys qs))))\n             csa \\<or>\n            List.member\n             (find_consistent_signs_at_roots\n               (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n               (cast_rat_list (fst (factorize_polys qs))))\n             csa);\n        \\<not> List.member\n                (find_consistent_signs_at_roots\n                  (coprime_r (cast_rat_list (fst (factorize_polys qs))))\n                  (cast_rat_list (fst (factorize_polys qs))))\n                csa;\n        csa\n        \\<in> set (find_sgas_aux\n                    (cast_rat_list (fst (factorize_polys qs))))\\<rbrakk>\n       \\<Longrightarrow> List.member\n                          (find_sgas_aux\n                            (cast_rat_list (fst (factorize_polys qs))))\n                          csa", "by (simp add: in_set_member)"], ["proof (state)\nthis:\n  \\<forall>csa.\n     List.member\n      (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n     (csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      has_no_zeros csa \\<or>\n      csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      \\<not> has_no_zeros csa)\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "have h5: \"\\<forall>csa. (csa \\<in> (consistent_sign_vectors ?ftrs UNIV) \\<and> has_no_zeros csa) \\<or>  (csa \\<in> (consistent_sign_vectors ?ftrs UNIV) \\<and> \\<not> (has_no_zeros csa))\n    \\<longleftrightarrow> csa \\<in> (consistent_sign_vectors ?ftrs UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       (csa\n        \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n        has_no_zeros csa \\<or>\n        csa\n        \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n        \\<not> has_no_zeros csa) =\n       (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)", "by auto"], ["proof (state)\nthis:\n  \\<forall>csa.\n     (csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      has_no_zeros csa \\<or>\n      csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      \\<not> has_no_zeros csa) =\n     (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "then"], ["proof (chain)\npicking this:\n  \\<forall>csa.\n     (csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      has_no_zeros csa \\<or>\n      csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      \\<not> has_no_zeros csa) =\n     (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)", "have \"\\<forall> csa. List.member (find_sgas (map (map_poly of_rat) ?ftrs)) csa \\<longleftrightarrow> csa \\<in> (consistent_sign_vectors ?ftrs UNIV)\""], ["proof (prove)\nusing this:\n  \\<forall>csa.\n     (csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      has_no_zeros csa \\<or>\n      csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      \\<not> has_no_zeros csa) =\n     (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)\n\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       List.member\n        (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n       (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)", "using h4"], ["proof (prove)\nusing this:\n  \\<forall>csa.\n     (csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      has_no_zeros csa \\<or>\n      csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      \\<not> has_no_zeros csa) =\n     (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)\n  \\<forall>csa.\n     List.member\n      (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n     (csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      has_no_zeros csa \\<or>\n      csa\n      \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV \\<and>\n      \\<not> has_no_zeros csa)\n\ngoal (1 subgoal):\n 1. \\<forall>csa.\n       List.member\n        (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n       (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)", "by blast"], ["proof (state)\nthis:\n  \\<forall>csa.\n     List.member\n      (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n     (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "then"], ["proof (chain)\npicking this:\n  \\<forall>csa.\n     List.member\n      (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n     (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>csa.\n     List.member\n      (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n     (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "using in_set_member"], ["proof (prove)\nusing this:\n  \\<forall>csa.\n     List.member\n      (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) csa =\n     (csa \\<in> consistent_sign_vectors (fst (factorize_polys qs)) UNIV)\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>csa.\n                   List.member\n                    (find_sgas\n                      (map real_of_rat_poly (fst (factorize_polys qs))))\n                    csa =\n                   (csa\n                    \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                           UNIV);\n        \\<And>x xs. (x \\<in> set xs) = List.member xs x;\n        x \\<in> set (find_sgas\n                      (map real_of_rat_poly\n                        (fst (factorize_polys qs))))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> consistent_sign_vectors\n                                  (fst (factorize_polys qs)) UNIV\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>csa.\n                   List.member\n                    (find_sgas\n                      (map real_of_rat_poly (fst (factorize_polys qs))))\n                    csa =\n                   (csa\n                    \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                           UNIV);\n        \\<And>x xs. (x \\<in> set xs) = List.member xs x;\n        x \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                 UNIV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (find_sgas\n (map real_of_rat_poly (fst (factorize_polys qs))))", "apply (simp add: in_set_member)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>csa.\n                   List.member\n                    (find_sgas\n                      (map real_of_rat_poly (fst (factorize_polys qs))))\n                    csa =\n                   (csa\n                    \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                           UNIV);\n        \\<And>x xs. (x \\<in> set xs) = List.member xs x;\n        x \\<in> consistent_sign_vectors (fst (factorize_polys qs))\n                 UNIV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (find_sgas\n (map real_of_rat_poly (fst (factorize_polys qs))))", "by (simp add: in_set_member)"], ["proof (state)\nthis:\n  set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n  consistent_sign_vectors (fst (factorize_polys qs)) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorize_polys_undo_factorize_polys_set:\n  assumes \"factorize_polys ps = (ftrs,data)\"\n  assumes \"sgas =  find_sgas (map (map_poly of_rat) ftrs)\"\n  assumes sgas_set: \"set (sgas) = consistent_sign_vectors ftrs UNIV\"\n  shows \"set (map (undo_factorize_polys data) sgas) = consistent_sign_vectors ps UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas) =\n    consistent_sign_vectors ps UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas) =\n    consistent_sign_vectors ps UNIV", "have h: \"\\<forall>x. undo_factorize_polys data (sign_vec ftrs x) = sign_vec ps x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. undo_factorize_polys data (sign_vec ftrs x) = sign_vec ps x", "using factorize_polys_undo_factorize_polys"], ["proof (prove)\nusing this:\n  factorize_polys ?ps = (?ftrs, ?data) \\<Longrightarrow>\n  undo_factorize_polys ?data (sign_vec ?ftrs ?x) = sign_vec ?ps ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x. undo_factorize_polys data (sign_vec ftrs x) = sign_vec ps x", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  \\<forall>x. undo_factorize_polys data (sign_vec ftrs x) = sign_vec ps x\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas) =\n    consistent_sign_vectors ps UNIV", "have h1: \"\\<forall>x. sign_vec ps x \\<in> set (map (undo_factorize_polys data) sgas)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       sign_vec ps x \\<in> set (map (undo_factorize_polys data) sgas)", "using sgas_set"], ["proof (prove)\nusing this:\n  set sgas = consistent_sign_vectors ftrs UNIV\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       sign_vec ps x \\<in> set (map (undo_factorize_polys data) sgas)", "by (metis UNIV_I consistent_sign_vectors_def h image_eqI image_set)"], ["proof (state)\nthis:\n  \\<forall>x. sign_vec ps x \\<in> set (map (undo_factorize_polys data) sgas)\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas) =\n    consistent_sign_vectors ps UNIV", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. sign_vec ps x \\<in> set (map (undo_factorize_polys data) sgas)", "have subset_h: \"consistent_sign_vectors ps UNIV \\<subseteq> set (map (undo_factorize_polys data) sgas)\""], ["proof (prove)\nusing this:\n  \\<forall>x. sign_vec ps x \\<in> set (map (undo_factorize_polys data) sgas)\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors ps UNIV\n    \\<subseteq> set (map (undo_factorize_polys data) sgas)", "unfolding consistent_sign_vectors_def"], ["proof (prove)\nusing this:\n  \\<forall>x. sign_vec ps x \\<in> set (map (undo_factorize_polys data) sgas)\n\ngoal (1 subgoal):\n 1. range (sign_vec ps)\n    \\<subseteq> set (map (undo_factorize_polys data) sgas)", "by auto"], ["proof (state)\nthis:\n  consistent_sign_vectors ps UNIV\n  \\<subseteq> set (map (undo_factorize_polys data) sgas)\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas) =\n    consistent_sign_vectors ps UNIV", "have supset_h:  \"consistent_sign_vectors ps UNIV \\<supseteq> set (map (undo_factorize_polys data) sgas)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas)\n    \\<subseteq> consistent_sign_vectors ps UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas)\n    \\<subseteq> consistent_sign_vectors ps UNIV", "have \"\\<forall> ele. ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n       (\\<exists>n < length sgas. ele = (undo_factorize_polys data (nth sgas n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ele.\n       ele\n       \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n       (\\<exists>n<length sgas. ele = undo_factorize_polys data (sgas ! n))", "using index_of_lookup(1) index_of_lookup(2)"], ["proof (prove)\nusing this:\n  ?p \\<in> set ?ls \\<Longrightarrow> index_of ?ls ?p < length ?ls\n  ?p \\<in> set ?ls \\<Longrightarrow> ?ls ! index_of ?ls ?p = ?p\n\ngoal (1 subgoal):\n 1. \\<forall>ele.\n       ele\n       \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n       (\\<exists>n<length sgas. ele = undo_factorize_polys data (sgas ! n))", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>ele.\n     ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n     (\\<exists>n<length sgas. ele = undo_factorize_polys data (sgas ! n))\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas)\n    \\<subseteq> consistent_sign_vectors ps UNIV", "then"], ["proof (chain)\npicking this:\n  \\<forall>ele.\n     ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n     (\\<exists>n<length sgas. ele = undo_factorize_polys data (sgas ! n))", "have \"\\<forall> ele. ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n       (\\<exists>x. ele = (undo_factorize_polys data (sign_vec ftrs x)))\""], ["proof (prove)\nusing this:\n  \\<forall>ele.\n     ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n     (\\<exists>n<length sgas. ele = undo_factorize_polys data (sgas ! n))\n\ngoal (1 subgoal):\n 1. \\<forall>ele.\n       ele\n       \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n       (\\<exists>x. ele = undo_factorize_polys data (sign_vec ftrs x))", "using sgas_set"], ["proof (prove)\nusing this:\n  \\<forall>ele.\n     ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n     (\\<exists>n<length sgas. ele = undo_factorize_polys data (sgas ! n))\n  set sgas = consistent_sign_vectors ftrs UNIV\n\ngoal (1 subgoal):\n 1. \\<forall>ele.\n       ele\n       \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n       (\\<exists>x. ele = undo_factorize_polys data (sign_vec ftrs x))", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>ele.\n                   ele\n                   \\<in> undo_factorize_polys data `\n                         consistent_sign_vectors ftrs UNIV \\<longrightarrow>\n                   (\\<exists>n<length sgas.\n                       ele = undo_factorize_polys data (sgas ! n));\n        set sgas = consistent_sign_vectors ftrs UNIV;\n        x \\<in> consistent_sign_vectors ftrs UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            undo_factorize_polys data x =\n                            undo_factorize_polys data (sign_vec ftrs xa)", "using consistent_sign_vectors_def"], ["proof (prove)\nusing this:\n  consistent_sign_vectors ?qs ?S = sign_vec ?qs ` ?S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>ele.\n                   ele\n                   \\<in> undo_factorize_polys data `\n                         consistent_sign_vectors ftrs UNIV \\<longrightarrow>\n                   (\\<exists>n<length sgas.\n                       ele = undo_factorize_polys data (sgas ! n));\n        set sgas = consistent_sign_vectors ftrs UNIV;\n        x \\<in> consistent_sign_vectors ftrs UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            undo_factorize_polys data x =\n                            undo_factorize_polys data (sign_vec ftrs xa)", "by auto"], ["proof (state)\nthis:\n  \\<forall>ele.\n     ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n     (\\<exists>x. ele = undo_factorize_polys data (sign_vec ftrs x))\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas)\n    \\<subseteq> consistent_sign_vectors ps UNIV", "then"], ["proof (chain)\npicking this:\n  \\<forall>ele.\n     ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n     (\\<exists>x. ele = undo_factorize_polys data (sign_vec ftrs x))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>ele.\n     ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n     (\\<exists>x. ele = undo_factorize_polys data (sign_vec ftrs x))\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas)\n    \\<subseteq> consistent_sign_vectors ps UNIV", "using h"], ["proof (prove)\nusing this:\n  \\<forall>ele.\n     ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n     (\\<exists>x. ele = undo_factorize_polys data (sign_vec ftrs x))\n  \\<forall>x. undo_factorize_polys data (sign_vec ftrs x) = sign_vec ps x\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas)\n    \\<subseteq> consistent_sign_vectors ps UNIV", "using consistent_sign_vectors_def"], ["proof (prove)\nusing this:\n  \\<forall>ele.\n     ele \\<in> set (map (undo_factorize_polys data) sgas) \\<longrightarrow>\n     (\\<exists>x. ele = undo_factorize_polys data (sign_vec ftrs x))\n  \\<forall>x. undo_factorize_polys data (sign_vec ftrs x) = sign_vec ps x\n  consistent_sign_vectors ?qs ?S = sign_vec ?qs ` ?S\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas)\n    \\<subseteq> consistent_sign_vectors ps UNIV", "by auto"], ["proof (state)\nthis:\n  set (map (undo_factorize_polys data) sgas)\n  \\<subseteq> consistent_sign_vectors ps UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (map (undo_factorize_polys data) sgas)\n  \\<subseteq> consistent_sign_vectors ps UNIV\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas) =\n    consistent_sign_vectors ps UNIV", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas) =\n    consistent_sign_vectors ps UNIV", "using subset_h supset_h"], ["proof (prove)\nusing this:\n  consistent_sign_vectors ps UNIV\n  \\<subseteq> set (map (undo_factorize_polys data) sgas)\n  set (map (undo_factorize_polys data) sgas)\n  \\<subseteq> consistent_sign_vectors ps UNIV\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys data) sgas) =\n    consistent_sign_vectors ps UNIV", "by blast"], ["proof (state)\nthis:\n  set (map (undo_factorize_polys data) sgas) =\n  consistent_sign_vectors ps UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma main_step_aux1:\n  fixes qs:: \"rat poly list\"\n  assumes empty: \"(fst(factorize_polys qs)) = []\"\n  shows \"set (find_consistent_signs qs) =  consistent_sign_vectors qs UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "have set_eq: \"set (find_consistent_signs qs) = {(map (\\<lambda>x. if poly x 0 < 0 then -1 else if poly x 0 = 0 then 0 else 1) qs)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "using empty"], ["proof (prove)\nusing this:\n  fst (factorize_polys qs) = []\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "unfolding find_consistent_signs_def"], ["proof (prove)\nusing this:\n  fst (factorize_polys qs) = []\n\ngoal (1 subgoal):\n 1. set (let (fs, data) = factorize_polys qs;\n             sgas = find_sgas (map real_of_rat_poly fs)\n         in Let (map (undo_factorize_polys data) sgas)\n             (If (fs = [])\n               [map (\\<lambda>x.\n                        if poly x 0 < 0 then - 1\n                        else if poly x 0 = 0 then 0 else 1)\n                 qs])) =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ uua_ xa.\n       \\<lbrakk>fst (factorize_polys qs) = []; uua_ \\<noteq> [];\n        (uua_, uu_) = factorize_polys qs;\n        xa \\<in> set (find_sgas (map real_of_rat_poly uua_))\\<rbrakk>\n       \\<Longrightarrow> undo_factorize_polys uu_ xa =\n                         map (\\<lambda>x.\n                                 if poly x 0 < 0 then - 1\n                                 else if poly x 0 = 0 then 0 else 1)\n                          qs\n 2. fst (factorize_polys qs) = [] \\<Longrightarrow>\n    \\<exists>uu_ uua_.\n       (uua_ = [] \\<longrightarrow> ([], uu_) = factorize_polys qs) \\<and>\n       (uua_ \\<noteq> [] \\<longrightarrow>\n        (uua_, uu_) = factorize_polys qs \\<and>\n        map (\\<lambda>x.\n                if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n         qs\n        \\<in> undo_factorize_polys uu_ `\n              set (find_sgas (map real_of_rat_poly uua_)))", "apply (metis fst_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (factorize_polys qs) = [] \\<Longrightarrow>\n    \\<exists>uu_ uua_.\n       (uua_ = [] \\<longrightarrow> ([], uu_) = factorize_polys qs) \\<and>\n       (uua_ \\<noteq> [] \\<longrightarrow>\n        (uua_, uu_) = factorize_polys qs \\<and>\n        map (\\<lambda>x.\n                if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n         qs\n        \\<in> undo_factorize_polys uu_ `\n              set (find_sgas (map real_of_rat_poly uua_)))", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  set (find_consistent_signs qs) =\n  {map (\\<lambda>x.\n           if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n    qs}\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "have deg_q_prop: \"fst(factorize_polys qs) = [] \\<Longrightarrow> (\\<forall>q \\<in>set(qs). degree q = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (factorize_polys qs) = [] \\<Longrightarrow>\n    \\<forall>q\\<in>set qs. degree q = 0", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (factorize_polys qs) = [];\n     \\<not> (\\<forall>q\\<in>set qs. degree q = 0)\\<rbrakk>\n    \\<Longrightarrow> False", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>fst (factorize_polys qs) = []; q \\<in> set qs;\n        0 < degree q\\<rbrakk>\n       \\<Longrightarrow> False", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>fst (factorize_polys qs) = []; q \\<in> set qs;\n        0 < degree q\\<rbrakk>\n       \\<Longrightarrow> False", "assume *:\"fst(factorize_polys qs) = []\""], ["proof (state)\nthis:\n  fst (factorize_polys qs) = []\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>fst (factorize_polys qs) = []; q \\<in> set qs;\n        0 < degree q\\<rbrakk>\n       \\<Longrightarrow> False", "assume q: \"q \\<in> set qs\" \"0 < degree q\""], ["proof (state)\nthis:\n  q \\<in> set qs\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>fst (factorize_polys qs) = []; q \\<in> set qs;\n        0 < degree q\\<rbrakk>\n       \\<Longrightarrow> False", "obtain arb where \"factorize_rat_poly_monic q = (arb,[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>arb.\n        factorize_rat_poly_monic q = (arb, []) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using * q"], ["proof (prove)\nusing this:\n  fst (factorize_polys qs) = []\n  q \\<in> set qs\n  0 < degree q\n\ngoal (1 subgoal):\n 1. (\\<And>arb.\n        factorize_rat_poly_monic q = (arb, []) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding factorize_polys_def"], ["proof (prove)\nusing this:\n  fst (let fact_ps = map factorize_rat_poly_monic qs;\n           factors = remdups (map fst (concat (map snd fact_ps)))\n       in Let (map (\\<lambda>(c, fs).\n                       (c, map (\\<lambda>(f, y). (index_of factors f, y))\n                            fs))\n                fact_ps)\n           (Pair factors)) =\n  []\n  q \\<in> set qs\n  0 < degree q\n\ngoal (1 subgoal):\n 1. (\\<And>arb.\n        factorize_rat_poly_monic q = (arb, []) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (auto simp add:Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb.\n                factorize_rat_poly_monic q = (arb, []) \\<Longrightarrow>\n                thesis;\n     \\<forall>xs\\<in>set qs. snd (factorize_rat_poly_monic xs) = [];\n     q \\<in> set qs; 0 < degree q\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  factorize_rat_poly_monic q = (arb, [])\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>fst (factorize_polys qs) = []; q \\<in> set qs;\n        0 < degree q\\<rbrakk>\n       \\<Longrightarrow> False", "from squarefree_factorization_degree[OF factorize_rat_poly_monic_square_free_factorization[OF this]]"], ["proof (chain)\npicking this:\n  degree q = (\\<Sum>(f, c)\\<leftarrow>[]. (c + 1) * degree f)", "have \"degree q = 0\""], ["proof (prove)\nusing this:\n  degree q = (\\<Sum>(f, c)\\<leftarrow>[]. (c + 1) * degree f)\n\ngoal (1 subgoal):\n 1. degree q = 0", "by auto"], ["proof (state)\nthis:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>fst (factorize_polys qs) = []; q \\<in> set qs;\n        0 < degree q\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. False", "using q"], ["proof (prove)\nusing this:\n  degree q = 0\n  q \\<in> set qs\n  0 < degree q\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (factorize_polys qs) = [] \\<Longrightarrow>\n  \\<forall>q\\<in>set qs. degree q = 0\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "have deg_q_cons: \"(\\<forall>q \\<in>set(qs). degree q = 0) \\<Longrightarrow> (consistent_sign_vectors qs UNIV =  {(map (\\<lambda>x. if poly x 0 < 0 then -1 else if poly x 0 = 0 then 0 else 1) qs)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n    consistent_sign_vectors qs UNIV =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n    consistent_sign_vectors qs UNIV =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "assume deg_z: \"(\\<forall>q \\<in>set(qs). degree q = 0)\""], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. degree q = 0\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n    consistent_sign_vectors qs UNIV =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs. degree q = 0", "have \"\\<forall>q \\<in>set(qs). \\<forall>x y. poly q x = poly q y\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. degree q = 0\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. \\<forall>x y. poly q x = poly q y", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q x y.\n       \\<lbrakk>\\<forall>q\\<in>set qs. degree q = 0; q \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> poly q x = poly q y", "by (meson constant_def constant_degree)"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. \\<forall>x y. poly q x = poly q y\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n    consistent_sign_vectors qs UNIV =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs. \\<forall>x y. poly q x = poly q y", "have csv: \"consistent_sign_vectors qs UNIV = {sign_vec qs 0}\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. \\<forall>x y. poly q x = poly q y\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors qs UNIV = {sign_vec qs 0}", "unfolding consistent_sign_vectors_def sign_vec_def"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. \\<forall>x y. poly q x = poly q y\n\ngoal (1 subgoal):\n 1. range (\\<lambda>x. map (squash \\<circ> (\\<lambda>p. rpoly p x)) qs) =\n    {map (squash \\<circ> (\\<lambda>p. rpoly p 0)) qs}", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa x.\n       \\<lbrakk>\\<forall>q\\<in>set qs. \\<forall>x y. poly q x = poly q y;\n        x \\<in> set qs\\<rbrakk>\n       \\<Longrightarrow> squash (rpoly x xa) = squash (poly x 0)\n 2. \\<forall>q\\<in>set qs.\n       \\<forall>x y. poly q x = poly q y \\<Longrightarrow>\n    map (squash \\<circ> (\\<lambda>p. real_of_rat (poly p 0))) qs\n    \\<in> range\n           (\\<lambda>x. map (squash \\<circ> (\\<lambda>p. rpoly p x)) qs)", "apply (metis deg_z degree_0_id of_rat_hom.map_poly_hom_coeff_lift poly_0_coeff_0 poly_const_conv squash_real_of_rat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       \\<forall>x y. poly q x = poly q y \\<Longrightarrow>\n    map (squash \\<circ> (\\<lambda>p. real_of_rat (poly p 0))) qs\n    \\<in> range\n           (\\<lambda>x. map (squash \\<circ> (\\<lambda>p. rpoly p x)) qs)", "by (metis (mono_tags, lifting) class_semiring.add.one_closed comp_def image_iff list.map_cong0 of_rat_hom.poly_map_poly_0)"], ["proof (state)\nthis:\n  consistent_sign_vectors qs UNIV = {sign_vec qs 0}\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n    consistent_sign_vectors qs UNIV =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "have \"sign_vec qs 0 = (map (\\<lambda>x. if poly x 0 < 0 then -1 else if poly x 0 = 0 then 0 else 1) qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_vec qs 0 =\n    map (\\<lambda>x.\n            if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n     qs", "unfolding sign_vec_def squash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>x. if 0 < x then 1 else if x < 0 then - 1 else 0) \\<circ>\n         (\\<lambda>p. rpoly p 0))\n     qs =\n    map (\\<lambda>x.\n            if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n     qs", "by auto"], ["proof (state)\nthis:\n  sign_vec qs 0 =\n  map (\\<lambda>x.\n          if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n   qs\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n    consistent_sign_vectors qs UNIV =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "then"], ["proof (chain)\npicking this:\n  sign_vec qs 0 =\n  map (\\<lambda>x.\n          if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n   qs", "show \"consistent_sign_vectors qs UNIV =  {(map (\\<lambda>x. if poly x 0 < 0 then -1 else if poly x 0 = 0 then 0 else 1) qs)}\""], ["proof (prove)\nusing this:\n  sign_vec qs 0 =\n  map (\\<lambda>x.\n          if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n   qs\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors qs UNIV =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "using csv"], ["proof (prove)\nusing this:\n  sign_vec qs 0 =\n  map (\\<lambda>x.\n          if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n   qs\n  consistent_sign_vectors qs UNIV = {sign_vec qs 0}\n\ngoal (1 subgoal):\n 1. consistent_sign_vectors qs UNIV =\n    {map (\\<lambda>x.\n             if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n      qs}", "by auto"], ["proof (state)\nthis:\n  consistent_sign_vectors qs UNIV =\n  {map (\\<lambda>x.\n           if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n    qs}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n  consistent_sign_vectors qs UNIV =\n  {map (\\<lambda>x.\n           if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n    qs}\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n  consistent_sign_vectors qs UNIV =\n  {map (\\<lambda>x.\n           if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n    qs}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n  consistent_sign_vectors qs UNIV =\n  {map (\\<lambda>x.\n           if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n    qs}\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "using deg_q_prop deg_q_cons set_eq"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n  consistent_sign_vectors qs UNIV =\n  {map (\\<lambda>x.\n           if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n    qs}\n  fst (factorize_polys qs) = [] \\<Longrightarrow>\n  \\<forall>q\\<in>set qs. degree q = 0\n  \\<forall>q\\<in>set qs. degree q = 0 \\<Longrightarrow>\n  consistent_sign_vectors qs UNIV =\n  {map (\\<lambda>x.\n           if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n    qs}\n  set (find_consistent_signs qs) =\n  {map (\\<lambda>x.\n           if poly x 0 < 0 then - 1 else if poly x 0 = 0 then 0 else 1)\n    qs}\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "by (simp add: empty)"], ["proof (state)\nthis:\n  set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma main_step_aux2:\n  fixes qs:: \"rat poly list\"\n  assumes lenh: \"length (fst(factorize_polys qs)) > 0\"\n  shows \"set (find_consistent_signs qs) =  consistent_sign_vectors qs UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "let ?fs = \"fst(factorize_polys qs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "let ?data = \"snd(factorize_polys qs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "let ?sgas = \"find_sgas (map (map_poly of_rat) ?fs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "have h0: \"set (?sgas) = consistent_sign_vectors ?fs UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "using lenh same_sign_cond_rationals_reals coprime_factorize"], ["proof (prove)\nusing this:\n  0 < length (fst (factorize_polys qs))\n  0 < length (fst (factorize_polys ?qs)) \\<Longrightarrow>\n  set (find_sgas (map real_of_rat_poly (fst (factorize_polys ?qs)))) =\n  consistent_sign_vectors (fst (factorize_polys ?qs)) UNIV\n  pairwise_coprime_list (fst (factorize_polys ?qs))\n\ngoal (1 subgoal):\n 1. set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n    consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "by auto"], ["proof (state)\nthis:\n  set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n  consistent_sign_vectors (fst (factorize_polys qs)) UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "then"], ["proof (chain)\npicking this:\n  set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n  consistent_sign_vectors (fst (factorize_polys qs)) UNIV", "have h1: \"set (map (undo_factorize_polys ?data) ?sgas) = consistent_sign_vectors qs UNIV\""], ["proof (prove)\nusing this:\n  set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n  consistent_sign_vectors (fst (factorize_polys qs)) UNIV\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys (snd (factorize_polys qs)))\n          (find_sgas (map real_of_rat_poly (fst (factorize_polys qs))))) =\n    consistent_sign_vectors qs UNIV", "using factorize_polys_undo_factorize_polys_set"], ["proof (prove)\nusing this:\n  set (find_sgas (map real_of_rat_poly (fst (factorize_polys qs)))) =\n  consistent_sign_vectors (fst (factorize_polys qs)) UNIV\n  \\<lbrakk>factorize_polys ?ps = (?ftrs, ?data);\n   ?sgas = find_sgas (map real_of_rat_poly ?ftrs);\n   set ?sgas = consistent_sign_vectors ?ftrs UNIV\\<rbrakk>\n  \\<Longrightarrow> set (map (undo_factorize_polys ?data) ?sgas) =\n                    consistent_sign_vectors ?ps UNIV\n\ngoal (1 subgoal):\n 1. set (map (undo_factorize_polys (snd (factorize_polys qs)))\n          (find_sgas (map real_of_rat_poly (fst (factorize_polys qs))))) =\n    consistent_sign_vectors qs UNIV", "by simp"], ["proof (state)\nthis:\n  set (map (undo_factorize_polys (snd (factorize_polys qs)))\n        (find_sgas (map real_of_rat_poly (fst (factorize_polys qs))))) =\n  consistent_sign_vectors qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "then"], ["proof (chain)\npicking this:\n  set (map (undo_factorize_polys (snd (factorize_polys qs)))\n        (find_sgas (map real_of_rat_poly (fst (factorize_polys qs))))) =\n  consistent_sign_vectors qs UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  set (map (undo_factorize_polys (snd (factorize_polys qs)))\n        (find_sgas (map real_of_rat_poly (fst (factorize_polys qs))))) =\n  consistent_sign_vectors qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "using lenh"], ["proof (prove)\nusing this:\n  set (map (undo_factorize_polys (snd (factorize_polys qs)))\n        (find_sgas (map real_of_rat_poly (fst (factorize_polys qs))))) =\n  consistent_sign_vectors qs UNIV\n  0 < length (fst (factorize_polys qs))\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>undo_factorize_polys (snd (factorize_polys qs)) `\n                set (find_sgas\n                      (map real_of_rat_poly (fst (factorize_polys qs)))) =\n                consistent_sign_vectors qs UNIV;\n        fst (factorize_polys qs) \\<noteq> [];\n        x \\<in> set (find_consistent_signs qs)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> consistent_sign_vectors qs UNIV\n 2. \\<And>x.\n       \\<lbrakk>undo_factorize_polys (snd (factorize_polys qs)) `\n                set (find_sgas\n                      (map real_of_rat_poly (fst (factorize_polys qs)))) =\n                consistent_sign_vectors qs UNIV;\n        fst (factorize_polys qs) \\<noteq> [];\n        x \\<in> consistent_sign_vectors qs UNIV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (find_consistent_signs qs)", "apply (smt case_prod_unfold find_consistent_signs_def h1 main_step_aux1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>undo_factorize_polys (snd (factorize_polys qs)) `\n                set (find_sgas\n                      (map real_of_rat_poly (fst (factorize_polys qs)))) =\n                consistent_sign_vectors qs UNIV;\n        fst (factorize_polys qs) \\<noteq> [];\n        x \\<in> consistent_sign_vectors qs UNIV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (find_consistent_signs qs)", "by (simp add: find_consistent_signs_def prod.case_eq_if)"], ["proof (state)\nthis:\n  set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma main_step:\n  fixes qs:: \"rat poly list\"\n  shows \"set (find_consistent_signs qs) =  consistent_sign_vectors qs UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "using main_step_aux1 main_step_aux2"], ["proof (prove)\nusing this:\n  fst (factorize_polys ?qs) = [] \\<Longrightarrow>\n  set (find_consistent_signs ?qs) = consistent_sign_vectors ?qs UNIV\n  0 < length (fst (factorize_polys ?qs)) \\<Longrightarrow>\n  set (find_consistent_signs ?qs) = consistent_sign_vectors ?qs UNIV\n\ngoal (1 subgoal):\n 1. set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV", "by auto"], ["", "subsection \"Decision Procedure: Main Lemmas\""], ["", "lemma decide_univ_lem_helper:\n  assumes \"(fml_struct,polys) = convert fml\"\n  shows \"(\\<forall>x::real. lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) \\<longleftrightarrow>\n    (decide_universal fml)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n    decide_universal fml", "using universal_lookup_sem main_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i. i \\<in> set_fml ?fml \\<Longrightarrow> i < length ?qs;\n   set ?signs = consistent_sign_vectors ?qs UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x.\n                        lookup_sem ?fml (map (\\<lambda>p. rpoly p x) ?qs)) =\n                    list_all (lookup_sem ?fml) ?signs\n  set (find_consistent_signs ?qs) = consistent_sign_vectors ?qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n    decide_universal fml", "unfolding decide_universal_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i. i \\<in> set_fml ?fml \\<Longrightarrow> i < length ?qs;\n   set ?signs = consistent_sign_vectors ?qs UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x.\n                        lookup_sem ?fml (map (\\<lambda>p. rpoly p x) ?qs)) =\n                    list_all (lookup_sem ?fml) ?signs\n  set (find_consistent_signs ?qs) = consistent_sign_vectors ?qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n    (let (fml_struct, polys) = convert fml\n     in Let (find_consistent_signs polys)\n         (list_all (lookup_sem fml_struct)))", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fml_structa polysa.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>x.\n   lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n                                     list_all (lookup_sem fml) signs;\n        \\<And>qs.\n           set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV;\n        \\<forall>x.\n           lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys);\n        convert fml = (fml_structa, polysa)\\<rbrakk>\n       \\<Longrightarrow> list_all (lookup_sem fml_structa)\n                          (find_consistent_signs polysa)\n 2. \\<And>x y xa.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>x.\n   lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n                                     list_all (lookup_sem fml) signs;\n        \\<And>qs.\n           set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV;\n        convert fml = (x, y);\n        list_all (lookup_sem x) (find_consistent_signs y)\\<rbrakk>\n       \\<Longrightarrow> lookup_sem fml_struct\n                          (map (\\<lambda>p. rpoly p xa) polys)", "apply (metis assms convert_closed fst_conv snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>x.\n   lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n                                     list_all (lookup_sem fml) signs;\n        \\<And>qs.\n           set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV;\n        convert fml = (x, y);\n        list_all (lookup_sem x) (find_consistent_signs y)\\<rbrakk>\n       \\<Longrightarrow> lookup_sem fml_struct\n                          (map (\\<lambda>p. rpoly p xa) polys)", "by (metis (full_types) assms convert_closed fst_conv snd_conv)"], ["", "lemma decide_exis_lem_helper:\n  assumes \"(fml_struct,polys) = convert fml\"\n  shows \"(\\<exists>x::real. lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) \\<longleftrightarrow>\n    (decide_existential fml)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n    decide_existential fml", "using existential_lookup_sem main_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i. i \\<in> set_fml ?fml \\<Longrightarrow> i < length ?qs;\n   set ?signs = consistent_sign_vectors ?qs UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        lookup_sem ?fml (map (\\<lambda>p. rpoly p x) ?qs)) =\n                    (find (lookup_sem ?fml) ?signs \\<noteq> None)\n  set (find_consistent_signs ?qs) = consistent_sign_vectors ?qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n    decide_existential fml", "unfolding decide_existential_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i. i \\<in> set_fml ?fml \\<Longrightarrow> i < length ?qs;\n   set ?signs = consistent_sign_vectors ?qs UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>x.\n                        lookup_sem ?fml (map (\\<lambda>p. rpoly p x) ?qs)) =\n                    (find (lookup_sem ?fml) ?signs \\<noteq> None)\n  set (find_consistent_signs ?qs) = consistent_sign_vectors ?qs UNIV\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n    (let (fml_struct, polys) = convert fml;\n         conds = find_consistent_signs polys\n     in find (lookup_sem fml_struct) conds \\<noteq> None)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fml_structa polysa x.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>x.\n   lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n                                     (\\<exists>y.\n   find (lookup_sem fml) signs = Some y);\n        \\<And>qs.\n           set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV;\n        convert fml = (fml_structa, polysa);\n        lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            find (lookup_sem fml_structa)\n                             (find_consistent_signs polysa) =\n                            Some y\n 2. \\<And>x y ya.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>x.\n   lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n                                     (\\<exists>y.\n   find (lookup_sem fml) signs = Some y);\n        \\<And>qs.\n           set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV;\n        convert fml = (x, y);\n        find (lookup_sem x) (find_consistent_signs y) = Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            lookup_sem fml_struct\n                             (map (\\<lambda>p. rpoly p x) polys)", "apply (metis assms convert_closed fst_conv snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya.\n       \\<lbrakk>\\<And>fml qs signs.\n                   \\<lbrakk>\\<And>i.\n                               i \\<in> set_fml fml \\<Longrightarrow>\n                               i < length qs;\n                    set signs = consistent_sign_vectors qs UNIV\\<rbrakk>\n                   \\<Longrightarrow> (\\<exists>x.\n   lookup_sem fml (map (\\<lambda>p. rpoly p x) qs)) =\n                                     (\\<exists>y.\n   find (lookup_sem fml) signs = Some y);\n        \\<And>qs.\n           set (find_consistent_signs qs) = consistent_sign_vectors qs UNIV;\n        convert fml = (x, y);\n        find (lookup_sem x) (find_consistent_signs y) = Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            lookup_sem fml_struct\n                             (map (\\<lambda>p. rpoly p x) polys)", "by (metis (full_types) assms convert_closed fst_conv snd_conv)"], ["", "theorem decision_procedure:\n  shows \"(\\<forall>x::real. fml_sem fml x) \\<longleftrightarrow> (decide_universal fml)\"\n    \"\\<exists>x::real. fml_sem fml x \\<longleftrightarrow> (decide_existential fml)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. fml_sem fml x) = decide_universal fml &&&\n    \\<exists>x. fml_sem fml x = decide_existential fml", "using  convert_semantics_lem decide_univ_lem_helper"], ["proof (prove)\nusing this:\n  (\\<And>p.\n      p \\<in> set (poly_list ?fml) \\<Longrightarrow>\n      ?ls ! index_of ?ps p = rpoly p ?x) \\<Longrightarrow>\n  fml_sem ?fml ?x = lookup_sem (map_fml (index_of ?ps) ?fml) ?ls\n  (?fml_struct, ?polys) = convert ?fml \\<Longrightarrow>\n  (\\<forall>x.\n      lookup_sem ?fml_struct (map (\\<lambda>p. rpoly p x) ?polys)) =\n  decide_universal ?fml\n\ngoal (1 subgoal):\n 1. (\\<forall>x. fml_sem fml x) = decide_universal fml &&&\n    \\<exists>x. fml_sem fml x = decide_existential fml", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>fml ls ps x.\n                (\\<And>p.\n                    p \\<in> set (poly_list fml) \\<Longrightarrow>\n                    ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n                fml_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls;\n     \\<And>fml_struct polys fml.\n        (fml_struct, polys) = convert fml \\<Longrightarrow>\n        (\\<forall>x.\n            lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n        decide_universal fml;\n     \\<forall>x. fml_sem fml x\\<rbrakk>\n    \\<Longrightarrow> decide_universal fml\n 2. \\<And>x.\n       \\<lbrakk>\\<And>fml ls ps x.\n                   (\\<And>p.\n                       p \\<in> set (poly_list fml) \\<Longrightarrow>\n                       ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n                   fml_sem fml x =\n                   lookup_sem (map_fml (index_of ps) fml) ls;\n        \\<And>fml_struct polys fml.\n           (fml_struct, polys) = convert fml \\<Longrightarrow>\n           (\\<forall>x.\n               lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n           decide_universal fml;\n        decide_universal fml\\<rbrakk>\n       \\<Longrightarrow> fml_sem fml x\n 3. \\<lbrakk>\\<And>fml ls ps x.\n                (\\<And>p.\n                    p \\<in> set (poly_list fml) \\<Longrightarrow>\n                    ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n                fml_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls;\n     \\<And>fml_struct polys fml.\n        (fml_struct, polys) = convert fml \\<Longrightarrow>\n        (\\<forall>x.\n            lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n        decide_universal fml\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. fml_sem fml x = decide_existential fml", "apply (simp add: convert_semantics)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>fml ls ps x.\n                   (\\<And>p.\n                       p \\<in> set (poly_list fml) \\<Longrightarrow>\n                       ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n                   fml_sem fml x =\n                   lookup_sem (map_fml (index_of ps) fml) ls;\n        \\<And>fml_struct polys fml.\n           (fml_struct, polys) = convert fml \\<Longrightarrow>\n           (\\<forall>x.\n               lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n           decide_universal fml;\n        decide_universal fml\\<rbrakk>\n       \\<Longrightarrow> fml_sem fml x\n 2. \\<lbrakk>\\<And>fml ls ps x.\n                (\\<And>p.\n                    p \\<in> set (poly_list fml) \\<Longrightarrow>\n                    ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n                fml_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls;\n     \\<And>fml_struct polys fml.\n        (fml_struct, polys) = convert fml \\<Longrightarrow>\n        (\\<forall>x.\n            lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n        decide_universal fml\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. fml_sem fml x = decide_existential fml", "apply (metis convert_def convert_semantics fst_conv snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>fml ls ps x.\n                (\\<And>p.\n                    p \\<in> set (poly_list fml) \\<Longrightarrow>\n                    ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n                fml_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls;\n     \\<And>fml_struct polys fml.\n        (fml_struct, polys) = convert fml \\<Longrightarrow>\n        (\\<forall>x.\n            lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n        decide_universal fml\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. fml_sem fml x = decide_existential fml", "using convert_semantics_lem"], ["proof (prove)\nusing this:\n  (\\<And>p.\n      p \\<in> set (poly_list ?fml) \\<Longrightarrow>\n      ?ls ! index_of ?ps p = rpoly p ?x) \\<Longrightarrow>\n  fml_sem ?fml ?x = lookup_sem (map_fml (index_of ?ps) ?fml) ?ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>fml ls ps x.\n                (\\<And>p.\n                    p \\<in> set (poly_list fml) \\<Longrightarrow>\n                    ls ! index_of ps p = rpoly p x) \\<Longrightarrow>\n                fml_sem fml x = lookup_sem (map_fml (index_of ps) fml) ls;\n     \\<And>fml_struct polys fml.\n        (fml_struct, polys) = convert fml \\<Longrightarrow>\n        (\\<forall>x.\n            lookup_sem fml_struct (map (\\<lambda>p. rpoly p x) polys)) =\n        decide_universal fml\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. fml_sem fml x = decide_existential fml", "by (metis convert_def convert_semantics decide_exis_lem_helper fst_conv snd_conv)"], ["", "end"]]}