{"file_name": "/home/qj213/afp-2021-10-22/thys/BenOr_Kozen_Reif/Matrix_Equation_Construction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BenOr_Kozen_Reif", "problem_names": ["lemma relprime:\n  fixes q::\"real poly\"\n  assumes \"coprime p q\"\n  assumes \"p \\<noteq> 0\"\n  assumes \"q \\<noteq> 0\"\n  shows \"changes_R_smods p (pderiv p) = card {x. poly p x = 0 \\<and> poly q x > 0} + card {x. poly p x = 0 \\<and> poly q x < 0}\"", "lemma card_eq_const_sum: \n  fixes k:: real\n  assumes \"finite A\"\n  shows \"k*card A = sum (\\<lambda>x. k) A\"", "lemma restate_tarski:\n  fixes q::\"real poly\"\n  assumes \"coprime p q\"\n  assumes \"p \\<noteq> 0\"       \n  assumes \"q \\<noteq> 0\"\n  shows \"changes_R_smods p ((pderiv p) * q) = card {x. poly p x = 0 \\<and> poly q x > 0} -  int(card {x. poly p x = 0 \\<and> poly q x < 0})\"", "lemma restate_tarski2:\n  fixes q::\"real poly\"\n  assumes \"p \\<noteq> 0\"\n  shows \"changes_R_smods p ((pderiv p) * q) =\n        int(card {x. poly p x = 0 \\<and> poly q x > 0}) -\n        int(card {x. poly p x = 0 \\<and> poly q x < 0})\"", "lemma coprime_set_prod:\n  fixes I:: \"real poly set\"\n  shows \"finite I \\<Longrightarrow> ((\\<forall> q \\<in> I. (coprime p q)) \\<longrightarrow> (coprime p (\\<Prod> I)))\"", "lemma finite_nonzero_set_prod:\n  fixes I:: \"real poly set\"\n  shows  nonzero_hyp: \"finite I \\<Longrightarrow> ((\\<forall> q \\<in> I. q \\<noteq> 0) \\<longrightarrow> \\<Prod> I \\<noteq> 0)\"", "lemma construct_NofI_prop:\n  fixes p:: \"real poly\"\n  fixes I:: \"real poly list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  shows \"construct_NofI p I =\n    rat_of_int (int (card {x. poly p x = 0 \\<and> poly (prod_list I) x > 0}) - \n    int (card {x. poly p x = 0 \\<and> poly (prod_list I) x < 0}))\"", "lemma csa_list_copr_rel:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes pairwise_rel_prime: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  shows \"characterize_consistent_signs_at_roots p qs = characterize_consistent_signs_at_roots_copr p qs\"", "lemma alt_matrix_char: \"alt_matrix_A signs subsets = matrix_A signs subsets\"", "lemma subsets_are_rows: \"\\<forall>i < (length subsets). row (alt_matrix_A signs subsets) i  = vec (length signs) (\\<lambda>j. z (subsets ! i) (signs ! j))\"", "lemma signs_are_cols: \"\\<forall>i < (length signs). col (alt_matrix_A signs subsets) i  = vec (length subsets) (\\<lambda>j. z (subsets ! j) (signs ! i))\"", "lemma row_mat_of_rows_list:\n  assumes \"list_all (\\<lambda>r. length r = nc) rs\"\n  assumes \"i < length rs\"\n  shows \"row (mat_of_rows_list nc rs) i = vec_of_list (nth rs i)\"", "lemma mult_mat_vec_of_list:\n  assumes \"length ls = nc\"\n  assumes \"list_all (\\<lambda>r. length r = nc) rs\"\n  shows \"mat_of_rows_list nc rs *\\<^sub>v vec_of_list ls =\n    vec_of_list (map (\\<lambda>r. vec_of_list r \\<bullet> vec_of_list ls) rs)\"", "lemma mtx_row_length:\n  \"list_all (\\<lambda>r. length r = length signs) (map (mtx_row signs) ls)\"", "lemma construct_lhs_vector_clean:\n  assumes \"p \\<noteq> 0\"\n  assumes \"i < length signs\"\n  shows \"(construct_lhs_vector p qs signs) $ i =\n    card {x. poly p x = 0 \\<and> ((consistent_sign_vec_copr qs x) = (nth signs i))}\"", "lemma construct_lhs_vector_cleaner:\n  assumes \"p \\<noteq> 0\"\n  shows \"(construct_lhs_vector p qs signs) =\n   vec_of_list (map (\\<lambda>s. rat_of_int (card {x. poly p x = 0 \\<and> ((consistent_sign_vec_copr qs x) = s)})) signs)\"", "lemma z_signs:\n  assumes \"list_all (\\<lambda>i. i < length signs) I\"\n  assumes \"list_all (\\<lambda>s. s = 1 \\<or> s = -1) signs\"\n  shows \"(z I signs = 1) \\<or> (z I signs = -1)\"", "lemma z_lemma:\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  assumes consistent: \"sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows \"(z I sign = 1) \\<or> (z I sign = -1)\"", "lemma in_set: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec_copr qs x\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows \"sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\"", "lemma nonzero_product: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  fixes I:: \"nat list\" \n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows \"(poly (prod_list (retrieve_polys qs I)) x > 0) \\<or> (poly (prod_list (retrieve_polys qs I)) x < 0)\"", "lemma horiz_vector_helper_pos_ind: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec_copr qs x\"\n  shows \"(list_constr I (length qs)) \\<longrightarrow> (poly (prod_list (retrieve_polys qs I)) x > 0) \\<longleftrightarrow> (z I sign = 1)\"", "lemma horiz_vector_helper_pos: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec_copr qs x\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows \"(poly (prod_list (retrieve_polys qs I)) x > 0) \\<longleftrightarrow> (z I sign = 1)\"", "lemma horiz_vector_helper_neg: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec_copr qs x\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows \"(poly (prod_list (retrieve_polys qs I)) x < 0) \\<longleftrightarrow> (z I sign = -1)\"", "lemma vec_of_list_dot_rewrite:\n  assumes \"length xs = length ys\"\n  shows \"vec_of_list xs \\<bullet> vec_of_list ys =\n    sum_list (map2 (*) xs ys)\"", "lemma lhs_dot_rewrite:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  shows\n    \"(vec_of_list (mtx_row signs I) \\<bullet> (construct_lhs_vector p qs signs)) =\n   sum_list (map (\\<lambda>s. (z I s)  *  rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) signs)\"", "lemma sum_list_distinct_filter:\n  fixes f:: \"'a \\<Rightarrow> int\"\n  assumes \"distinct xs\" \"distinct ys\"\n  assumes \"set ys \\<subseteq> set xs\"\n  assumes \"\\<And>x. x \\<in> set xs - set ys \\<Longrightarrow> f x = 0\"\n  shows \"sum_list (map f xs) = sum_list (map f ys)\"", "lemma construct_lhs_vector_drop_consistent:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots_copr p qs) \\<subseteq> set(signs)\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows\n    \"(vec_of_list (mtx_row signs I) \\<bullet> (construct_lhs_vector p qs signs)) =\n     (vec_of_list (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n      (construct_lhs_vector p qs (characterize_consistent_signs_at_roots_copr p qs)))\"", "lemma matrix_equation_helper_step:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots_copr p qs) \\<subseteq> set(signs)\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  shows \"(vec_of_list (mtx_row signs I) \\<bullet> (construct_lhs_vector p qs signs)) =\n   rat_of_int (card {x. poly p x = 0 \\<and> poly (prod_list (retrieve_polys qs I)) x > 0}) -\n   rat_of_int (card {x. poly p x = 0 \\<and> poly (prod_list (retrieve_polys qs I)) x < 0})\"", "lemma matrix_equation_main_step:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots_copr p qs) \\<subseteq> set(signs)\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  shows \"(vec_of_list (mtx_row signs I) \\<bullet> (construct_lhs_vector p qs signs)) =  \n    construct_NofI p (retrieve_polys qs I)\"", "lemma map_vec_vec_of_list_eq_intro:\n  assumes \"map f xs = map g ys\"\n  shows \"map_vec f (vec_of_list xs) = map_vec g (vec_of_list ys)\"", "theorem matrix_equation:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes subsets:: \"nat list list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots_copr p qs) \\<subseteq> set(signs)\"\n  assumes pairwise_rel_prime: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  assumes welldefined: \"all_list_constr (subsets) (length qs)\"\n  shows \"satisfy_equation p qs subsets signs\"", "lemma consistent_signs_at_roots_eq:\n  assumes \"p \\<noteq> 0\"\n  shows \"consistent_signs_at_roots p qs =\n         set (characterize_consistent_signs_at_roots p qs)\"", "theorem matrix_equation_pretty:\n  assumes \"p\\<noteq>0\"\n  assumes \"\\<And>q. q \\<in> set qs \\<Longrightarrow> coprime p q\"\n  assumes \"distinct signs\"\n  assumes \"consistent_signs_at_roots p qs \\<subseteq> set signs\"\n  assumes \"\\<And>l i. l \\<in> set subsets \\<Longrightarrow> i \\<in> set l \\<Longrightarrow> i < length qs\"\n  shows \"M_mat signs subsets *\\<^sub>v w_vec p qs signs = v_vec p qs subsets\""], "translations": [["", "lemma relprime:\n  fixes q::\"real poly\"\n  assumes \"coprime p q\"\n  assumes \"p \\<noteq> 0\"\n  assumes \"q \\<noteq> 0\"\n  shows \"changes_R_smods p (pderiv p) = card {x. poly p x = 0 \\<and> poly q x > 0} + card {x. poly p x = 0 \\<and> poly q x < 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n         card {x. poly p x = 0 \\<and> poly q x < 0})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n         card {x. poly p x = 0 \\<and> poly q x < 0})", "have 1: \"{x. poly p x = 0 \\<and> poly q x = 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0 \\<and> poly q x = 0} = {}", "using assms(1) coprime_poly_0"], ["proof (prove)\nusing this:\n  coprime p q\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0 \\<and> poly q x = 0} = {}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0 \\<and> poly q x = 0} = {}\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n         card {x. poly p x = 0 \\<and> poly q x < 0})", "have 2: \"changes_R_smods p (pderiv p) = int (card {x . poly p x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) = int (card {x. poly p x = 0})", "using sturm_R"], ["proof (prove)\nusing this:\n  int (card {x. poly ?p x = 0}) = changes_R_smods ?p (pderiv ?p)\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) = int (card {x. poly p x = 0})", "by auto"], ["proof (state)\nthis:\n  changes_R_smods p (pderiv p) = int (card {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n         card {x. poly p x = 0 \\<and> poly q x < 0})", "have 3: \"{x. poly p x = 0 \\<and> poly q x > 0} \\<inter> {x. poly p x = 0 \\<and> poly q x < 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0 \\<and> 0 < poly q x} \\<inter>\n    {x. poly p x = 0 \\<and> poly q x < 0} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<inter>\n  {x. poly p x = 0 \\<and> poly q x < 0} =\n  {}\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n         card {x. poly p x = 0 \\<and> poly q x < 0})", "have \"{x . poly p x = 0} =  {x. poly p x = 0 \\<and> poly q x > 0} \\<union>{x. poly p x = 0 \\<and> poly q x < 0} \\<union> {x. poly p x = 0 \\<and> poly q x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} =\n    {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n    {x. poly p x = 0 \\<and> poly q x = 0}", "by force"], ["proof (state)\nthis:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n  {x. poly p x = 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n         card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n  {x. poly p x = 0 \\<and> poly q x = 0}", "have \"{x . poly p x = 0} = {x. poly p x = 0 \\<and> poly q x > 0} \\<union>{x. poly p x = 0 \\<and> poly q x < 0}\""], ["proof (prove)\nusing this:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n  {x. poly p x = 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} =\n    {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x < 0}", "using 1"], ["proof (prove)\nusing this:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n  {x. poly p x = 0 \\<and> poly q x = 0}\n  {x. poly p x = 0 \\<and> poly q x = 0} = {}\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} =\n    {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x < 0}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0}\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n         card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0}", "have \"(card {x . poly p x = 0}) = (card ({x. poly p x = 0 \\<and> poly q x > 0} \\<union>{x. poly p x = 0 \\<and> poly q x < 0}))\""], ["proof (prove)\nusing this:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0}\n\ngoal (1 subgoal):\n 1. card {x. poly p x = 0} =\n    card\n     ({x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n      {x. poly p x = 0 \\<and> poly q x < 0})", "by presburger"], ["proof (state)\nthis:\n  card {x. poly p x = 0} =\n  card\n   ({x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n         card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  card {x. poly p x = 0} =\n  card\n   ({x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x < 0})", "have 4: \"(card {x . poly p x = 0}) =  card {x. poly p x = 0 \\<and> poly q x > 0} + card {x. poly p x = 0 \\<and> poly q x < 0}\""], ["proof (prove)\nusing this:\n  card {x. poly p x = 0} =\n  card\n   ({x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal (1 subgoal):\n 1. card {x. poly p x = 0} =\n    card {x. poly p x = 0 \\<and> 0 < poly q x} +\n    card {x. poly p x = 0 \\<and> poly q x < 0}", "using 3"], ["proof (prove)\nusing this:\n  card {x. poly p x = 0} =\n  card\n   ({x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x < 0})\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<inter>\n  {x. poly p x = 0 \\<and> poly q x < 0} =\n  {}\n\ngoal (1 subgoal):\n 1. card {x. poly p x = 0} =\n    card {x. poly p x = 0 \\<and> 0 < poly q x} +\n    card {x. poly p x = 0 \\<and> poly q x < 0}", "by (simp add: card_Un_disjoint assms(2) poly_roots_finite)"], ["proof (state)\nthis:\n  card {x. poly p x = 0} =\n  card {x. poly p x = 0 \\<and> 0 < poly q x} +\n  card {x. poly p x = 0 \\<and> poly q x < 0}\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n         card {x. poly p x = 0 \\<and> poly q x < 0})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n         card {x. poly p x = 0 \\<and> poly q x < 0})", "by (simp add: \"2\" \"4\")"], ["proof (state)\nthis:\n  changes_R_smods p (pderiv p) =\n  int (card {x. poly p x = 0 \\<and> 0 < poly q x} +\n       card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal:\nNo subgoals!", "qed"], ["", "(* This is the same proof as card_eq_sum *)"], ["", "lemma card_eq_const_sum: \n  fixes k:: real\n  assumes \"finite A\"\n  shows \"k*card A = sum (\\<lambda>x. k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * real (card A) = (\\<Sum>x\\<in>A. k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k * real (card A) = (\\<Sum>x\\<in>A. k)", "have \"plus \\<circ> (\\<lambda>_. Suc 0) = (\\<lambda>_. Suc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) \\<circ> (\\<lambda>_. Suc 0) = (\\<lambda>_. Suc)", "by (simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  (+) \\<circ> (\\<lambda>_. Suc 0) = (\\<lambda>_. Suc)\n\ngoal (1 subgoal):\n 1. k * real (card A) = (\\<Sum>x\\<in>A. k)", "then"], ["proof (chain)\npicking this:\n  (+) \\<circ> (\\<lambda>_. Suc 0) = (\\<lambda>_. Suc)", "have \"Finite_Set.fold (plus \\<circ> (\\<lambda>_. Suc 0)) = Finite_Set.fold (\\<lambda>_. Suc)\""], ["proof (prove)\nusing this:\n  (+) \\<circ> (\\<lambda>_. Suc 0) = (\\<lambda>_. Suc)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold ((+) \\<circ> (\\<lambda>_. Suc 0)) =\n    Finite_Set.fold (\\<lambda>_. Suc)", "by (rule arg_cong)"], ["proof (state)\nthis:\n  Finite_Set.fold ((+) \\<circ> (\\<lambda>_. Suc 0)) =\n  Finite_Set.fold (\\<lambda>_. Suc)\n\ngoal (1 subgoal):\n 1. k * real (card A) = (\\<Sum>x\\<in>A. k)", "then"], ["proof (chain)\npicking this:\n  Finite_Set.fold ((+) \\<circ> (\\<lambda>_. Suc 0)) =\n  Finite_Set.fold (\\<lambda>_. Suc)", "have \"Finite_Set.fold (plus \\<circ> (\\<lambda>_. Suc 0)) 0 A = Finite_Set.fold (\\<lambda>_. Suc) 0 A\""], ["proof (prove)\nusing this:\n  Finite_Set.fold ((+) \\<circ> (\\<lambda>_. Suc 0)) =\n  Finite_Set.fold (\\<lambda>_. Suc)\n\ngoal (1 subgoal):\n 1. Finite_Set.fold ((+) \\<circ> (\\<lambda>_. Suc 0)) 0 A =\n    Finite_Set.fold (\\<lambda>_. Suc) 0 A", "by (blast intro: fun_cong)"], ["proof (state)\nthis:\n  Finite_Set.fold ((+) \\<circ> (\\<lambda>_. Suc 0)) 0 A =\n  Finite_Set.fold (\\<lambda>_. Suc) 0 A\n\ngoal (1 subgoal):\n 1. k * real (card A) = (\\<Sum>x\\<in>A. k)", "then"], ["proof (chain)\npicking this:\n  Finite_Set.fold ((+) \\<circ> (\\<lambda>_. Suc 0)) 0 A =\n  Finite_Set.fold (\\<lambda>_. Suc) 0 A", "show ?thesis"], ["proof (prove)\nusing this:\n  Finite_Set.fold ((+) \\<circ> (\\<lambda>_. Suc 0)) 0 A =\n  Finite_Set.fold (\\<lambda>_. Suc) 0 A\n\ngoal (1 subgoal):\n 1. k * real (card A) = (\\<Sum>x\\<in>A. k)", "by (simp add: card.eq_fold sum.eq_fold)"], ["proof (state)\nthis:\n  k * real (card A) = (\\<Sum>x\\<in>A. k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restate_tarski:\n  fixes q::\"real poly\"\n  assumes \"coprime p q\"\n  assumes \"p \\<noteq> 0\"       \n  assumes \"q \\<noteq> 0\"\n  shows \"changes_R_smods p ((pderiv p) * q) = card {x. poly p x = 0 \\<and> poly q x > 0} -  int(card {x. poly p x = 0 \\<and> poly q x < 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "have 3: \"taq {x. poly p x=0} q \\<equiv> \\<Sum>y\\<in>{x. poly p x=0}. sign (poly q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q \\<equiv>\n    \\<Sum>y\\<in>{x. poly p x = 0}. Sturm_Tarski.sign (poly q y)", "by (simp add: taq_def)"], ["proof (state)\nthis:\n  taq {x. poly p x = 0} q \\<equiv>\n  \\<Sum>y\\<in>{x. poly p x = 0}. Sturm_Tarski.sign (poly q y)\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "have 4: \"{x. poly p x=0} =  {x. poly p x = 0 \\<and> poly q x > 0} \\<union> {x. poly p x = 0 \\<and> poly q x < 0} \\<union> {x. poly p x = 0 \\<and> poly q x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} =\n    {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n    {x. poly p x = 0 \\<and> poly q x = 0}", "by force"], ["proof (state)\nthis:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n  {x. poly p x = 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n  {x. poly p x = 0 \\<and> poly q x = 0}", "have 5: \"{x. poly p x=0} =  {x. poly p x = 0 \\<and> poly q x > 0} \\<union> {x. poly p x = 0 \\<and> poly q x < 0}\""], ["proof (prove)\nusing this:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n  {x. poly p x = 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} =\n    {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x < 0}", "using assms(1) coprime_poly_0"], ["proof (prove)\nusing this:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n  {x. poly p x = 0 \\<and> poly q x = 0}\n  coprime p q\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} =\n    {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x < 0}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0}\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0}", "have 6: \"\\<Sum>y\\<in>{x. poly p x=0}. sign (poly q y) \\<equiv> \\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x > 0} \\<union> {x. poly p x = 0 \\<and> poly q x < 0}. sign (poly q y)\""], ["proof (prove)\nusing this:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x < 0}\n\ngoal (1 subgoal):\n 1. \\<Sum>y\\<in>{x. poly p x = 0}. Sturm_Tarski.sign (poly q y) \\<equiv>\n    \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n                {x. poly p x = 0 \\<and> poly q x < 0}.\n      Sturm_Tarski.sign (poly q y)", "by presburger"], ["proof (state)\nthis:\n  \\<Sum>y\\<in>{x. poly p x = 0}. Sturm_Tarski.sign (poly q y) \\<equiv>\n  \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n              {x. poly p x = 0 \\<and> poly q x < 0}.\n    Sturm_Tarski.sign (poly q y)\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  \\<Sum>y\\<in>{x. poly p x = 0}. Sturm_Tarski.sign (poly q y) \\<equiv>\n  \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n              {x. poly p x = 0 \\<and> poly q x < 0}.\n    Sturm_Tarski.sign (poly q y)", "have 12: \"taq {x. poly p x=0} q \\<equiv> \\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x > 0} \\<union> {x. poly p x = 0 \\<and> poly q x < 0}. sign (poly q y)\""], ["proof (prove)\nusing this:\n  \\<Sum>y\\<in>{x. poly p x = 0}. Sturm_Tarski.sign (poly q y) \\<equiv>\n  \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n              {x. poly p x = 0 \\<and> poly q x < 0}.\n    Sturm_Tarski.sign (poly q y)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q \\<equiv>\n    \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n                {x. poly p x = 0 \\<and> poly q x < 0}.\n      Sturm_Tarski.sign (poly q y)", "using 3"], ["proof (prove)\nusing this:\n  \\<Sum>y\\<in>{x. poly p x = 0}. Sturm_Tarski.sign (poly q y) \\<equiv>\n  \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n              {x. poly p x = 0 \\<and> poly q x < 0}.\n    Sturm_Tarski.sign (poly q y)\n  taq {x. poly p x = 0} q \\<equiv>\n  \\<Sum>y\\<in>{x. poly p x = 0}. Sturm_Tarski.sign (poly q y)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q \\<equiv>\n    \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n                {x. poly p x = 0 \\<and> poly q x < 0}.\n      Sturm_Tarski.sign (poly q y)", "by linarith"], ["proof (state)\nthis:\n  taq {x. poly p x = 0} q \\<equiv>\n  \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n              {x. poly p x = 0 \\<and> poly q x < 0}.\n    Sturm_Tarski.sign (poly q y)\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "have 7: \"{x. poly p x = 0 \\<and> poly q x > 0} \\<inter> {x. poly p x = 0 \\<and> poly q x < 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0 \\<and> 0 < poly q x} \\<inter>\n    {x. poly p x = 0 \\<and> poly q x < 0} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<inter>\n  {x. poly p x = 0 \\<and> poly q x < 0} =\n  {}\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<inter>\n  {x. poly p x = 0 \\<and> poly q x < 0} =\n  {}", "have 8: \"\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x > 0} \\<union> {x. poly p x = 0 \\<and> poly q x < 0}. sign (poly q y) \\<equiv> (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x > 0}.sign (poly q y)) + (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.sign(poly q y))\""], ["proof (prove)\nusing this:\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<inter>\n  {x. poly p x = 0 \\<and> poly q x < 0} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n                {x. poly p x = 0 \\<and> poly q x < 0}.\n      Sturm_Tarski.sign (poly q y) \\<equiv>\n    (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}.\n       Sturm_Tarski.sign (poly q y)) +\n    (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.\n       Sturm_Tarski.sign (poly q y))", "by (simp add: assms(2) poly_roots_finite sum.union_disjoint)"], ["proof (state)\nthis:\n  \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n              {x. poly p x = 0 \\<and> poly q x < 0}.\n    Sturm_Tarski.sign (poly q y) \\<equiv>\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}.\n     Sturm_Tarski.sign (poly q y)) +\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.\n     Sturm_Tarski.sign (poly q y))\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n              {x. poly p x = 0 \\<and> poly q x < 0}.\n    Sturm_Tarski.sign (poly q y) \\<equiv>\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}.\n     Sturm_Tarski.sign (poly q y)) +\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.\n     Sturm_Tarski.sign (poly q y))", "have 13: \"taq {x. poly p x=0} q \\<equiv> (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x > 0}.sign (poly q y)) + (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.sign(poly q y))\""], ["proof (prove)\nusing this:\n  \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n              {x. poly p x = 0 \\<and> poly q x < 0}.\n    Sturm_Tarski.sign (poly q y) \\<equiv>\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}.\n     Sturm_Tarski.sign (poly q y)) +\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.\n     Sturm_Tarski.sign (poly q y))\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q \\<equiv>\n    (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}.\n       Sturm_Tarski.sign (poly q y)) +\n    (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.\n       Sturm_Tarski.sign (poly q y))", "using 12"], ["proof (prove)\nusing this:\n  \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n              {x. poly p x = 0 \\<and> poly q x < 0}.\n    Sturm_Tarski.sign (poly q y) \\<equiv>\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}.\n     Sturm_Tarski.sign (poly q y)) +\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.\n     Sturm_Tarski.sign (poly q y))\n  taq {x. poly p x = 0} q \\<equiv>\n  \\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n              {x. poly p x = 0 \\<and> poly q x < 0}.\n    Sturm_Tarski.sign (poly q y)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q \\<equiv>\n    (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}.\n       Sturm_Tarski.sign (poly q y)) +\n    (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.\n       Sturm_Tarski.sign (poly q y))", "by linarith"], ["proof (state)\nthis:\n  taq {x. poly p x = 0} q \\<equiv>\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}.\n     Sturm_Tarski.sign (poly q y)) +\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.\n     Sturm_Tarski.sign (poly q y))\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  taq {x. poly p x = 0} q \\<equiv>\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}.\n     Sturm_Tarski.sign (poly q y)) +\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.\n     Sturm_Tarski.sign (poly q y))", "have 9: \"taq {x. poly p x = 0} q \\<equiv> (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x > 0}.1) + (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.(-1))\""], ["proof (prove)\nusing this:\n  taq {x. poly p x = 0} q \\<equiv>\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}.\n     Sturm_Tarski.sign (poly q y)) +\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.\n     Sturm_Tarski.sign (poly q y))\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q \\<equiv>\n    (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}. 1) +\n    (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}. - 1)", "by simp"], ["proof (state)\nthis:\n  taq {x. poly p x = 0} q \\<equiv>\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}. 1) +\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}. - 1)\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "have 10: \"(\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x > 0}.1) =  card {x. poly p x = 0 \\<and> poly q x > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}. 1) =\n    card {x. poly p x = 0 \\<and> 0 < poly q x}", "using card_eq_sum"], ["proof (prove)\nusing this:\n  card ?A = (\\<Sum>x\\<in>?A. 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}. 1) =\n    card {x. poly p x = 0 \\<and> 0 < poly q x}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}. 1) =\n  card {x. poly p x = 0 \\<and> 0 < poly q x}\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "have 11: \" (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}.(-1)) = -1*card {x. poly p x = 0 \\<and> poly q x < 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}. - 1) =\n    - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})", "using card_eq_const_sum"], ["proof (prove)\nusing this:\n  finite ?A \\<Longrightarrow> ?k * real (card ?A) = (\\<Sum>x\\<in>?A. ?k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}. - 1) =\n    - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}. - 1) =\n  - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "have 14: \"taq {x. poly p x = 0} q \\<equiv> card {x. poly p x = 0 \\<and> poly q x > 0} + -1*card {x. poly p x = 0 \\<and> poly q x < 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q \\<equiv>\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) +\n    - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})", "using 9 10 11"], ["proof (prove)\nusing this:\n  taq {x. poly p x = 0} q \\<equiv>\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}. 1) +\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}. - 1)\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> 0 < poly q x}. 1) =\n  card {x. poly p x = 0 \\<and> 0 < poly q x}\n  (\\<Sum>y\\<in>{x. poly p x = 0 \\<and> poly q x < 0}. - 1) =\n  - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q \\<equiv>\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) +\n    - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})", "by simp"], ["proof (state)\nthis:\n  taq {x. poly p x = 0} q \\<equiv>\n  int (card {x. poly p x = 0 \\<and> 0 < poly q x}) +\n  - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "have 1: \"changes_R_smods p (pderiv p * q) = taq {x. poly p x=0} q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) = taq {x. poly p x = 0} q", "using sturm_tarski_R"], ["proof (prove)\nusing this:\n  taq {x. poly ?p x = 0} ?q = changes_R_smods ?p (pderiv ?p * ?q)\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) = taq {x. poly p x = 0} q", "by simp"], ["proof (state)\nthis:\n  changes_R_smods p (pderiv p * q) = taq {x. poly p x = 0} q\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  changes_R_smods p (pderiv p * q) = taq {x. poly p x = 0} q", "have 15: \"changes_R_smods p (pderiv p * q) = card {x. poly p x = 0 \\<and> poly q x > 0} + (-1*card {x. poly p x = 0 \\<and> poly q x < 0})\""], ["proof (prove)\nusing this:\n  changes_R_smods p (pderiv p * q) = taq {x. poly p x = 0} q\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) +\n    - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})", "using 14"], ["proof (prove)\nusing this:\n  changes_R_smods p (pderiv p * q) = taq {x. poly p x = 0} q\n  taq {x. poly p x = 0} q \\<equiv>\n  int (card {x. poly p x = 0 \\<and> 0 < poly q x}) +\n  - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) +\n    - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})", "by linarith"], ["proof (state)\nthis:\n  changes_R_smods p (pderiv p * q) =\n  int (card {x. poly p x = 0 \\<and> 0 < poly q x}) +\n  - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "have 16: \"(-1*card {x. poly p x = 0 \\<and> poly q x < 0}) = - card {x. poly p x = 0 \\<and> poly q x < 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0}) =\n    - int (card {x. poly p x = 0 \\<and> poly q x < 0})", "by auto"], ["proof (state)\nthis:\n  - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0}) =\n  - int (card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "then"], ["proof (chain)\npicking this:\n  - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0}) =\n  - int (card {x. poly p x = 0 \\<and> poly q x < 0})", "show ?thesis"], ["proof (prove)\nusing this:\n  - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0}) =\n  - int (card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "using 15"], ["proof (prove)\nusing this:\n  - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0}) =\n  - int (card {x. poly p x = 0 \\<and> poly q x < 0})\n  changes_R_smods p (pderiv p * q) =\n  int (card {x. poly p x = 0 \\<and> 0 < poly q x}) +\n  - 1 * int (card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "by linarith"], ["proof (state)\nthis:\n  changes_R_smods p (pderiv p * q) =\n  int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n  int (card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restate_tarski2:\n  fixes q::\"real poly\"\n  assumes \"p \\<noteq> 0\"\n  shows \"changes_R_smods p ((pderiv p) * q) =\n        int(card {x. poly p x = 0 \\<and> poly q x > 0}) -\n        int(card {x. poly p x = 0 \\<and> poly q x < 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "unfolding sturm_tarski_R[symmetric] taq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "let ?all = \"{x. poly p x=0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "let ?lt = \"{x. poly p x=0 \\<and> poly q x < 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "let ?gt = \"{x. poly p x=0 \\<and> poly q x > 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "let ?eq = \"{x. poly p x=0 \\<and> poly q x = 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "have eq: \"?all = ?lt \\<union> ?gt \\<union> ?eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} =\n    {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n    {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n    {x. poly p x = 0 \\<and> poly q x = 0}", "by force"], ["proof (state)\nthis:\n  {x. poly p x = 0} =\n  {x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n  {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n  {x. poly p x = 0 \\<and> poly q x = 0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "from poly_roots_finite[OF assms]"], ["proof (chain)\npicking this:\n  finite {x. poly p x = 0}", "have fin: \"finite ?all\""], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0}", "."], ["proof (state)\nthis:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "show  \"(\\<Sum>x | poly p x = 0. sign (poly q x)) = int (card ?gt) - int (card ?lt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n                 {x. poly p x = 0 \\<and> 0 < poly q x} \\<union>\n                 {x. poly p x = 0 \\<and> poly q x = 0}.\n       Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "apply (subst sum_Un)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     ({x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n      {x. poly p x = 0 \\<and> 0 < poly q x})\n 2. finite {x. poly p x = 0 \\<and> poly q x = 0}\n 3. (\\<Sum>x\\<in>{x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n                 {x. poly p x = 0 \\<and> 0 < poly q x}.\n       Sturm_Tarski.sign (poly q x)) +\n    (\\<Sum>x | poly p x = 0 \\<and> poly q x = 0.\n       Sturm_Tarski.sign (poly q x)) -\n    (\\<Sum>x\\<in>({x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n                  {x. poly p x = 0 \\<and> 0 < poly q x}) \\<inter>\n                 {x. poly p x = 0 \\<and> poly q x = 0}.\n       Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "apply (auto simp add:fin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{x. poly p x = 0 \\<and> poly q x < 0} \\<union>\n                 {x. poly p x = 0 \\<and> 0 < poly q x}.\n       Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "apply (subst sum_Un)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {x. poly p x = 0 \\<and> poly q x < 0}\n 2. finite {x. poly p x = 0 \\<and> 0 < poly q x}\n 3. (\\<Sum>x | poly p x = 0 \\<and> poly q x < 0.\n       Sturm_Tarski.sign (poly q x)) +\n    (\\<Sum>x | poly p x = 0 \\<and> 0 < poly q x.\n       Sturm_Tarski.sign (poly q x)) -\n    (\\<Sum>x\\<in>{x. poly p x = 0 \\<and> poly q x < 0} \\<inter>\n                 {x. poly p x = 0 \\<and> 0 < poly q x}.\n       Sturm_Tarski.sign (poly q x)) =\n    int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n    int (card {x. poly p x = 0 \\<and> poly q x < 0})", "by (auto simp add:fin)"], ["proof (state)\nthis:\n  (\\<Sum>x | poly p x = 0. Sturm_Tarski.sign (poly q x)) =\n  int (card {x. poly p x = 0 \\<and> 0 < poly q x}) -\n  int (card {x. poly p x = 0 \\<and> poly q x < 0})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_set_prod:\n  fixes I:: \"real poly set\"\n  shows \"finite I \\<Longrightarrow> ((\\<forall> q \\<in> I. (coprime p q)) \\<longrightarrow> (coprime p (\\<Prod> I)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I \\<Longrightarrow>\n    (\\<forall>q\\<in>I. coprime p q) \\<longrightarrow> coprime p (\\<Prod>I)", "proof (induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>a\\<in>{}. coprime p a) \\<longrightarrow> coprime p (\\<Prod>{})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>a\\<in>F. coprime p a) \\<longrightarrow>\n        coprime p (\\<Prod>F)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>insert x F.\n                             coprime p a) \\<longrightarrow>\n                         coprime p (\\<Prod>(insert x F))", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<forall>a\\<in>{}. coprime p a) \\<longrightarrow> coprime p (\\<Prod>{})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>a\\<in>F. coprime p a) \\<longrightarrow>\n        coprime p (\\<Prod>F)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>insert x F.\n                             coprime p a) \\<longrightarrow>\n                         coprime p (\\<Prod>(insert x F))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>{}. coprime p a) \\<longrightarrow> coprime p (\\<Prod>{})", "by simp"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>{}. coprime p a) \\<longrightarrow> coprime p (\\<Prod>{})\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>a\\<in>F. coprime p a) \\<longrightarrow>\n        coprime p (\\<Prod>F)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>insert x F.\n                             coprime p a) \\<longrightarrow>\n                         coprime p (\\<Prod>(insert x F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>a\\<in>F. coprime p a) \\<longrightarrow>\n        coprime p (\\<Prod>F)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>insert x F.\n                             coprime p a) \\<longrightarrow>\n                         coprime p (\\<Prod>(insert x F))", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  (\\<forall>a\\<in>F. coprime p a) \\<longrightarrow> coprime p (\\<Prod>F)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>a\\<in>F. coprime p a) \\<longrightarrow>\n        coprime p (\\<Prod>F)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>a\\<in>insert x F.\n                             coprime p a) \\<longrightarrow>\n                         coprime p (\\<Prod>(insert x F))", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  (\\<forall>a\\<in>F. coprime p a) \\<longrightarrow> coprime p (\\<Prod>F)", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  (\\<forall>a\\<in>F. coprime p a) \\<longrightarrow> coprime p (\\<Prod>F)\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>insert x F. coprime p a) \\<longrightarrow>\n    coprime p (\\<Prod>(insert x F))", "using coprime_mult_right_iff"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  (\\<forall>a\\<in>F. coprime p a) \\<longrightarrow> coprime p (\\<Prod>F)\n  coprime ?c (?a * ?b) = (coprime ?c ?a \\<and> coprime ?c ?b)\n\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>insert x F. coprime p a) \\<longrightarrow>\n    coprime p (\\<Prod>(insert x F))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>insert x F. coprime p a) \\<longrightarrow>\n  coprime p (\\<Prod>(insert x F))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_nonzero_set_prod:\n  fixes I:: \"real poly set\"\n  shows  nonzero_hyp: \"finite I \\<Longrightarrow> ((\\<forall> q \\<in> I. q \\<noteq> 0) \\<longrightarrow> \\<Prod> I \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I \\<Longrightarrow>\n    (\\<forall>q\\<in>I. q \\<noteq> 0) \\<longrightarrow> \\<Prod>I \\<noteq> 0", "proof (induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>q\\<in>{}. q \\<noteq> 0) \\<longrightarrow> \\<Prod>{} \\<noteq> 0\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>q\\<in>F. q \\<noteq> 0) \\<longrightarrow>\n        \\<Prod>F \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>q\\<in>insert x F.\n                             q \\<noteq> 0) \\<longrightarrow>\n                         \\<Prod>(insert x F) \\<noteq> 0", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<forall>q\\<in>{}. q \\<noteq> 0) \\<longrightarrow> \\<Prod>{} \\<noteq> 0\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>q\\<in>F. q \\<noteq> 0) \\<longrightarrow>\n        \\<Prod>F \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>q\\<in>insert x F.\n                             q \\<noteq> 0) \\<longrightarrow>\n                         \\<Prod>(insert x F) \\<noteq> 0", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>q\\<in>{}. q \\<noteq> 0) \\<longrightarrow> \\<Prod>{} \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  (\\<forall>q\\<in>{}. q \\<noteq> 0) \\<longrightarrow> \\<Prod>{} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>q\\<in>F. q \\<noteq> 0) \\<longrightarrow>\n        \\<Prod>F \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>q\\<in>insert x F.\n                             q \\<noteq> 0) \\<longrightarrow>\n                         \\<Prod>(insert x F) \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>q\\<in>F. q \\<noteq> 0) \\<longrightarrow>\n        \\<Prod>F \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>q\\<in>insert x F.\n                             q \\<noteq> 0) \\<longrightarrow>\n                         \\<Prod>(insert x F) \\<noteq> 0", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  (\\<forall>q\\<in>F. q \\<noteq> 0) \\<longrightarrow> \\<Prod>F \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>q\\<in>F. q \\<noteq> 0) \\<longrightarrow>\n        \\<Prod>F \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>q\\<in>insert x F.\n                             q \\<noteq> 0) \\<longrightarrow>\n                         \\<Prod>(insert x F) \\<noteq> 0", "have h: \"\\<Prod> (insert x F) = x * (\\<Prod> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>(insert x F) = x * \\<Prod>F", "by (simp add: insert.hyps(1) insert.hyps(2))"], ["proof (state)\nthis:\n  \\<Prod>(insert x F) = x * \\<Prod>F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>q\\<in>F. q \\<noteq> 0) \\<longrightarrow>\n        \\<Prod>F \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>q\\<in>insert x F.\n                             q \\<noteq> 0) \\<longrightarrow>\n                         \\<Prod>(insert x F) \\<noteq> 0", "have h_xin: \"x \\<in> insert x F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> insert x F", "by simp"], ["proof (state)\nthis:\n  x \\<in> insert x F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>q\\<in>F. q \\<noteq> 0) \\<longrightarrow>\n        \\<Prod>F \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>q\\<in>insert x F.\n                             q \\<noteq> 0) \\<longrightarrow>\n                         \\<Prod>(insert x F) \\<noteq> 0", "have hq: \"(\\<forall> q \\<in> (insert x F). q \\<noteq> 0) \\<longrightarrow> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>q\\<in>insert x F. q \\<noteq> 0) \\<longrightarrow> x \\<noteq> 0", "using h_xin"], ["proof (prove)\nusing this:\n  x \\<in> insert x F\n\ngoal (1 subgoal):\n 1. (\\<forall>q\\<in>insert x F. q \\<noteq> 0) \\<longrightarrow> x \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  (\\<forall>q\\<in>insert x F. q \\<noteq> 0) \\<longrightarrow> x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<forall>q\\<in>F. q \\<noteq> 0) \\<longrightarrow>\n        \\<Prod>F \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>q\\<in>insert x F.\n                             q \\<noteq> 0) \\<longrightarrow>\n                         \\<Prod>(insert x F) \\<noteq> 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>q\\<in>insert x F. q \\<noteq> 0) \\<longrightarrow>\n    \\<Prod>(insert x F) \\<noteq> 0", "using h hq"], ["proof (prove)\nusing this:\n  \\<Prod>(insert x F) = x * \\<Prod>F\n  (\\<forall>q\\<in>insert x F. q \\<noteq> 0) \\<longrightarrow> x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<forall>q\\<in>insert x F. q \\<noteq> 0) \\<longrightarrow>\n    \\<Prod>(insert x F) \\<noteq> 0", "using insert.hyps(3)"], ["proof (prove)\nusing this:\n  \\<Prod>(insert x F) = x * \\<Prod>F\n  (\\<forall>q\\<in>insert x F. q \\<noteq> 0) \\<longrightarrow> x \\<noteq> 0\n  (\\<forall>q\\<in>F. q \\<noteq> 0) \\<longrightarrow> \\<Prod>F \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<forall>q\\<in>insert x F. q \\<noteq> 0) \\<longrightarrow>\n    \\<Prod>(insert x F) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (\\<forall>q\\<in>insert x F. q \\<noteq> 0) \\<longrightarrow>\n  \\<Prod>(insert x F) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Setting up the construction: Definitions\""], ["", "definition characterize_root_list_p:: \"real poly \\<Rightarrow> real list\"\n  where \"characterize_root_list_p p \\<equiv> sorted_list_of_set({x. poly p x = 0}::real set)\""], ["", "(************** Renegar's N(I); towards defining the RHS of the matrix equation **************)"], ["", "lemma construct_NofI_prop:\n  fixes p:: \"real poly\"\n  fixes I:: \"real poly list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  shows \"construct_NofI p I =\n    rat_of_int (int (card {x. poly p x = 0 \\<and> poly (prod_list I) x > 0}) - \n    int (card {x. poly p x = 0 \\<and> poly (prod_list I) x < 0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_NofI p I =\n    rat_of_int\n     (int (card {x. poly p x = 0 \\<and> 0 < poly (prod_list I) x}) -\n      int (card {x. poly p x = 0 \\<and> poly (prod_list I) x < 0}))", "unfolding construct_NofI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (changes_R_smods p (pderiv p * prod_list I)) =\n    rat_of_int\n     (int (card {x. poly p x = 0 \\<and> 0 < poly (prod_list I) x}) -\n      int (card {x. poly p x = 0 \\<and> poly (prod_list I) x < 0}))", "using assms restate_tarski2 nonzero rsquarefree_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  changes_R_smods ?p (pderiv ?p * ?q) =\n  int (card {x. poly ?p x = 0 \\<and> 0 < poly ?q x}) -\n  int (card {x. poly ?p x = 0 \\<and> poly ?q x < 0})\n  p \\<noteq> 0\n  rsquarefree ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>a. Polynomial.order a ?p = 0 \\<or> Polynomial.order a ?p = 1))\n\ngoal (1 subgoal):\n 1. rat_of_int (changes_R_smods p (pderiv p * prod_list I)) =\n    rat_of_int\n     (int (card {x. poly p x = 0 \\<and> 0 < poly (prod_list I) x}) -\n      int (card {x. poly p x = 0 \\<and> poly (prod_list I) x < 0}))", "by (simp add: rsquarefree_def)"], ["", "definition construct_s_vector:: \"real poly \\<Rightarrow> real poly list list \\<Rightarrow> rat vec\"\n  where \"construct_s_vector p Is = vec_of_list (map (\\<lambda> I.(construct_NofI p I)) Is)\""], ["", "(* Consistent sign assignments *)"], ["", "definition squash::\"'a::linordered_field \\<Rightarrow> rat\"\n  where \"squash x = (if x > 0 then 1\n                    else if x < 0 then -1\n                    else 0)\""], ["", "definition signs_at::\"real poly list \\<Rightarrow> real \\<Rightarrow> rat list\"\n  where \"signs_at qs x \\<equiv>\n    map (squash \\<circ> (\\<lambda>q. poly q x)) qs\""], ["", "definition characterize_consistent_signs_at_roots:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> rat list list\"\n  where \"characterize_consistent_signs_at_roots p qs =\n  (remdups (map (signs_at qs) (characterize_root_list_p p)))\""], ["", "(* An alternate version designed to be used when every polynomial in qs is relatively prime to p*)"], ["", "definition consistent_sign_vec_copr::\"real poly list \\<Rightarrow> real \\<Rightarrow> rat list\"\n  where \"consistent_sign_vec_copr qs x \\<equiv>\n    map (\\<lambda> q. if (poly q x > 0) then (1::rat) else (-1::rat)) qs\""], ["", "definition characterize_consistent_signs_at_roots_copr:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> rat list list\"\n  where \"characterize_consistent_signs_at_roots_copr p qss =\n  (remdups (map (consistent_sign_vec_copr qss) (characterize_root_list_p p)))\""], ["", "lemma csa_list_copr_rel:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes pairwise_rel_prime: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  shows \"characterize_consistent_signs_at_roots p qs = characterize_consistent_signs_at_roots_copr p qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. characterize_consistent_signs_at_roots p qs =\n    characterize_consistent_signs_at_roots_copr p qs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. characterize_consistent_signs_at_roots p qs =\n    characterize_consistent_signs_at_roots_copr p qs", "have \"\\<forall>q \\<in> set(qs). \\<forall> x \\<in> set (characterize_root_list_p p).  poly q x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       \\<forall>x\\<in>set (characterize_root_list_p p). poly q x \\<noteq> 0", "using pairwise_rel_prime"], ["proof (prove)\nusing this:\n  \\<forall>q. List.member qs q \\<longrightarrow> coprime p q\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       \\<forall>x\\<in>set (characterize_root_list_p p). poly q x \\<noteq> 0", "using coprime_poly_0 in_set_member nonzero poly_roots_finite characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  \\<forall>q. List.member qs q \\<longrightarrow> coprime p q\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n  characterize_root_list_p ?p \\<equiv> sorted_list_of_set {x. poly ?p x = 0}\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       \\<forall>x\\<in>set (characterize_root_list_p p). poly q x \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     \\<forall>x\\<in>set (characterize_root_list_p p). poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. characterize_consistent_signs_at_roots p qs =\n    characterize_consistent_signs_at_roots_copr p qs", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>set qs.\n     \\<forall>x\\<in>set (characterize_root_list_p p). poly q x \\<noteq> 0", "have h: \"\\<forall>q \\<in> set(qs). \\<forall> x \\<in> set (characterize_root_list_p p). squash (poly q x) = (if (poly q x > 0) then (1::rat) else (-1::rat))\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>set qs.\n     \\<forall>x\\<in>set (characterize_root_list_p p). poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>set qs.\n       \\<forall>x\\<in>set (characterize_root_list_p p).\n          squash (poly q x) = (if 0 < poly q x then 1 else - 1)", "by (simp add: squash_def)"], ["proof (state)\nthis:\n  \\<forall>q\\<in>set qs.\n     \\<forall>x\\<in>set (characterize_root_list_p p).\n        squash (poly q x) = (if 0 < poly q x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. characterize_consistent_signs_at_roots p qs =\n    characterize_consistent_signs_at_roots_copr p qs", "have \"map (\\<lambda>r. map (\\<lambda>p. if 0 < poly p r then 1 else - 1) qs) (characterize_root_list_p p) = map (\\<lambda>r. map (squash \\<circ> (\\<lambda>p. poly p r)) qs) (characterize_root_list_p p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>r. map (\\<lambda>p. if 0 < poly p r then 1 else - 1) qs)\n     (characterize_root_list_p p) =\n    map (\\<lambda>r. map (squash \\<circ> (\\<lambda>p. poly p r)) qs)\n     (characterize_root_list_p p)", "by (simp add: h)"], ["proof (state)\nthis:\n  map (\\<lambda>r. map (\\<lambda>p. if 0 < poly p r then 1 else - 1) qs)\n   (characterize_root_list_p p) =\n  map (\\<lambda>r. map (squash \\<circ> (\\<lambda>p. poly p r)) qs)\n   (characterize_root_list_p p)\n\ngoal (1 subgoal):\n 1. characterize_consistent_signs_at_roots p qs =\n    characterize_consistent_signs_at_roots_copr p qs", "thus ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>r. map (\\<lambda>p. if 0 < poly p r then 1 else - 1) qs)\n   (characterize_root_list_p p) =\n  map (\\<lambda>r. map (squash \\<circ> (\\<lambda>p. poly p r)) qs)\n   (characterize_root_list_p p)\n\ngoal (1 subgoal):\n 1. characterize_consistent_signs_at_roots p qs =\n    characterize_consistent_signs_at_roots_copr p qs", "unfolding characterize_consistent_signs_at_roots_def characterize_consistent_signs_at_roots_copr_def\n      signs_at_def consistent_sign_vec_copr_def"], ["proof (prove)\nusing this:\n  map (\\<lambda>r. map (\\<lambda>p. if 0 < poly p r then 1 else - 1) qs)\n   (characterize_root_list_p p) =\n  map (\\<lambda>r. map (squash \\<circ> (\\<lambda>p. poly p r)) qs)\n   (characterize_root_list_p p)\n\ngoal (1 subgoal):\n 1. remdups\n     (map (\\<lambda>x. map (squash \\<circ> (\\<lambda>q. poly q x)) qs)\n       (characterize_root_list_p p)) =\n    remdups\n     (map (\\<lambda>x. map (\\<lambda>q. if 0 < poly q x then 1 else - 1) qs)\n       (characterize_root_list_p p))", "by presburger"], ["proof (state)\nthis:\n  characterize_consistent_signs_at_roots p qs =\n  characterize_consistent_signs_at_roots_copr p qs\n\ngoal:\nNo subgoals!", "qed"], ["", "(************** Towards defining Renegar's polynomial function and the LHS of the matrix equation **************)"], ["", "definition list_constr:: \"nat list \\<Rightarrow> nat \\<Rightarrow> bool\"\n  where \"list_constr L n \\<equiv> list_all (\\<lambda>x. x < n) L\""], ["", "definition all_list_constr:: \"nat list list \\<Rightarrow> nat \\<Rightarrow> bool\"\n  where \"all_list_constr L n \\<equiv> (\\<forall>x. List.member L x \\<longrightarrow> list_constr x n)\""], ["", "(* The first input is the subset; the second input is the consistent sign assignment.\n  We want to map over the first list and pull out all of the elements in the second list with\n  corresponding positions, and then multiply those together.\n*)"], ["", "definition z:: \"nat list \\<Rightarrow> rat list \\<Rightarrow> rat\"\n  where \"z index_list sign_asg \\<equiv> (prod_list (map (nth sign_asg) index_list))\""], ["", "definition mtx_row:: \"rat list list \\<Rightarrow> nat list \\<Rightarrow> rat list\"\n  where \"mtx_row sign_list index_list \\<equiv> (map ( (z index_list)) sign_list)\""], ["", "definition matrix_A:: \"rat list list \\<Rightarrow> nat list list \\<Rightarrow> rat mat\" \n  where \"matrix_A sign_list subset_list = \n    (mat_of_rows_list (length sign_list) (map (\\<lambda>i .(mtx_row sign_list i)) subset_list))\""], ["", "definition alt_matrix_A:: \"rat list list \\<Rightarrow> nat list list \\<Rightarrow> rat mat\"\n  where \"alt_matrix_A signs subsets = (mat (length subsets) (length signs) \n    (\\<lambda>(i, j). z (subsets ! i) (signs ! j)))\""], ["", "lemma alt_matrix_char: \"alt_matrix_A signs subsets = matrix_A signs subsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_matrix_A signs subsets = matrix_A signs subsets", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alt_matrix_A signs subsets = matrix_A signs subsets", "have h0: \"(\\<And>i j. i < length subsets \\<Longrightarrow>\n            j < length signs \\<Longrightarrow>\n            map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! j = z (subsets ! i) (signs ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list. map (z index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z (subsets ! i) (signs ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list. map (z index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z (subsets ! i) (signs ! j)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list. map (z index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z (subsets ! i) (signs ! j)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list. map (z index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z (subsets ! i) (signs ! j)", "assume i_lt: \"i < length subsets\""], ["proof (state)\nthis:\n  i < length subsets\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list. map (z index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z (subsets ! i) (signs ! j)", "assume j_lt: \"j < length signs\""], ["proof (state)\nthis:\n  j < length signs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length subsets; j < length signs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>index_list. map (z index_list) signs)\n                          subsets !\n                         i !\n                         j =\n                         z (subsets ! i) (signs ! j)", "show \"((map (\\<lambda>index_list. map (z index_list) signs) subsets) ! i) ! j = z (subsets ! i) (signs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! j =\n    z (subsets ! i) (signs ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! j =\n    z (subsets ! i) (signs ! j)", "have h0: \"(map (\\<lambda>index_list. map (z index_list) signs) subsets) ! i =  map (z (subsets ! i)) signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z index_list) signs) subsets ! i =\n    map (z (subsets ! i)) signs", "using nth_map i_lt"], ["proof (prove)\nusing this:\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n  i < length subsets\n\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z index_list) signs) subsets ! i =\n    map (z (subsets ! i)) signs", "by blast"], ["proof (state)\nthis:\n  map (\\<lambda>index_list. map (z index_list) signs) subsets ! i =\n  map (z (subsets ! i)) signs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! j =\n    z (subsets ! i) (signs ! j)", "then"], ["proof (chain)\npicking this:\n  map (\\<lambda>index_list. map (z index_list) signs) subsets ! i =\n  map (z (subsets ! i)) signs", "show ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>index_list. map (z index_list) signs) subsets ! i =\n  map (z (subsets ! i)) signs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! j =\n    z (subsets ! i) (signs ! j)", "using nth_map j_lt"], ["proof (prove)\nusing this:\n  map (\\<lambda>index_list. map (z index_list) signs) subsets ! i =\n  map (z (subsets ! i)) signs\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n  j < length signs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! j =\n    z (subsets ! i) (signs ! j)", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! j =\n  z (subsets ! i) (signs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! j =\n  z (subsets ! i) (signs ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length subsets; ?j < length signs\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>index_list. map (z index_list) signs)\n                     subsets !\n                    ?i !\n                    ?j =\n                    z (subsets ! ?i) (signs ! ?j)\n\ngoal (1 subgoal):\n 1. alt_matrix_A signs subsets = matrix_A signs subsets", "have h: \" mat (length subsets) (length signs) (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs) (\\<lambda>(i, y). map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs)\n     (\\<lambda>(i, y).\n         map (\\<lambda>index_list. map (z index_list) signs) subsets ! i !\n         y)", "using h0 eq_matI[where A = \"mat (length subsets) (length signs) (\\<lambda>(i, j). z (subsets ! i) (signs ! j))\",\n        where B = \"mat (length subsets) (length signs) (\\<lambda>(i, y). map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! y)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length subsets; ?j < length signs\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>index_list. map (z index_list) signs)\n                     subsets !\n                    ?i !\n                    ?j =\n                    z (subsets ! ?i) (signs ! ?j)\n  \\<lbrakk>\\<And>i j.\n              \\<lbrakk>i < dim_row\n                            (mat (length subsets) (length signs)\n                              (\\<lambda>(i, y).\n                                  map (\\<lambda>index_list.\n    map (z index_list) signs)\n                                   subsets !\n                                  i !\n                                  y));\n               j < dim_col\n                    (mat (length subsets) (length signs)\n                      (\\<lambda>(i, y).\n                          map (\\<lambda>index_list.\n                                  map (z index_list) signs)\n                           subsets !\n                          i !\n                          y))\\<rbrakk>\n              \\<Longrightarrow> mat (length subsets) (length signs)\n                                 (\\<lambda>(i, j).\n                                     z (subsets ! i) (signs ! j)) $$\n                                (i, j) =\n                                mat (length subsets) (length signs)\n                                 (\\<lambda>(i, y).\n                                     map\n(\\<lambda>index_list. map (z index_list) signs) subsets !\n                                     i !\n                                     y) $$\n                                (i, j);\n   dim_row\n    (mat (length subsets) (length signs)\n      (\\<lambda>(i, j). z (subsets ! i) (signs ! j))) =\n   dim_row\n    (mat (length subsets) (length signs)\n      (\\<lambda>(i, y).\n          map (\\<lambda>index_list. map (z index_list) signs) subsets ! i !\n          y));\n   dim_col\n    (mat (length subsets) (length signs)\n      (\\<lambda>(i, j). z (subsets ! i) (signs ! j))) =\n   dim_col\n    (mat (length subsets) (length signs)\n      (\\<lambda>(i, y).\n          map (\\<lambda>index_list. map (z index_list) signs) subsets ! i !\n          y))\\<rbrakk>\n  \\<Longrightarrow> mat (length subsets) (length signs)\n                     (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) =\n                    mat (length subsets) (length signs)\n                     (\\<lambda>(i, y).\n                         map (\\<lambda>index_list. map (z index_list) signs)\n                          subsets !\n                         i !\n                         y)\n\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs)\n     (\\<lambda>(i, y).\n         map (\\<lambda>index_list. map (z index_list) signs) subsets ! i !\n         y)", "by auto"], ["proof (state)\nthis:\n  mat (length subsets) (length signs)\n   (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) =\n  mat (length subsets) (length signs)\n   (\\<lambda>(i, y).\n       map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! y)\n\ngoal (1 subgoal):\n 1. alt_matrix_A signs subsets = matrix_A signs subsets", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_matrix_A signs subsets = matrix_A signs subsets", "unfolding alt_matrix_A_def matrix_A_def mat_of_rows_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) =\n    mat (length (map (mtx_row signs) subsets)) (length signs)\n     (\\<lambda>(i, y). map (mtx_row signs) subsets ! i ! y)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs)\n     (\\<lambda>(i, y). map (mtx_row signs) subsets ! i ! y)", "unfolding mtx_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs)\n     (\\<lambda>(i, y).\n         map (\\<lambda>index_list. map (z index_list) signs) subsets ! i !\n         y)", "using h"], ["proof (prove)\nusing this:\n  mat (length subsets) (length signs)\n   (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) =\n  mat (length subsets) (length signs)\n   (\\<lambda>(i, y).\n       map (\\<lambda>index_list. map (z index_list) signs) subsets ! i ! y)\n\ngoal (1 subgoal):\n 1. mat (length subsets) (length signs)\n     (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) =\n    mat (length subsets) (length signs)\n     (\\<lambda>(i, y).\n         map (\\<lambda>index_list. map (z index_list) signs) subsets ! i !\n         y)", "by blast"], ["proof (state)\nthis:\n  alt_matrix_A signs subsets = matrix_A signs subsets\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subsets_are_rows: \"\\<forall>i < (length subsets). row (alt_matrix_A signs subsets) i  = vec (length signs) (\\<lambda>j. z (subsets ! i) (signs ! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length subsets.\n       row (alt_matrix_A signs subsets) i =\n       vec (length signs) (\\<lambda>j. z (subsets ! i) (signs ! j))", "unfolding row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length subsets.\n       vec (dim_col (alt_matrix_A signs subsets))\n        (\\<lambda>j. alt_matrix_A signs subsets $$ (i, j)) =\n       vec (length signs) (\\<lambda>j. z (subsets ! i) (signs ! j))", "unfolding alt_matrix_A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length subsets.\n       vec (dim_col\n             (mat (length subsets) (length signs)\n               (\\<lambda>(i, j). z (subsets ! i) (signs ! j))))\n        (\\<lambda>j.\n            mat (length subsets) (length signs)\n             (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) $$\n            (i, j)) =\n       vec (length signs) (\\<lambda>j. z (subsets ! i) (signs ! j))", "by auto"], ["", "lemma signs_are_cols: \"\\<forall>i < (length signs). col (alt_matrix_A signs subsets) i  = vec (length subsets) (\\<lambda>j. z (subsets ! j) (signs ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length signs.\n       col (alt_matrix_A signs subsets) i =\n       vec (length subsets) (\\<lambda>j. z (subsets ! j) (signs ! i))", "unfolding col_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length signs.\n       vec (dim_row (alt_matrix_A signs subsets))\n        (\\<lambda>ia. alt_matrix_A signs subsets $$ (ia, i)) =\n       vec (length subsets) (\\<lambda>j. z (subsets ! j) (signs ! i))", "unfolding alt_matrix_A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length signs.\n       vec (dim_row\n             (mat (length subsets) (length signs)\n               (\\<lambda>(i, j). z (subsets ! i) (signs ! j))))\n        (\\<lambda>ia.\n            mat (length subsets) (length signs)\n             (\\<lambda>(i, j). z (subsets ! i) (signs ! j)) $$\n            (ia, i)) =\n       vec (length subsets) (\\<lambda>j. z (subsets ! j) (signs ! i))", "by auto"], ["", "(* ith entry of LHS vector is the number of (distinct) real zeros of p where the sign vector of the qs  is the ith entry of signs.*)"], ["", "definition construct_lhs_vector:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> rat list list  \\<Rightarrow> rat vec\"\n  where \"construct_lhs_vector p qs signs \\<equiv>\n  vec_of_list (map (\\<lambda>w.  rat_of_int (int (length (filter (\\<lambda>v. v = w) (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)))))) signs)\""], ["", "(* Putting all of the pieces of the construction together *)"], ["", "definition satisfy_equation:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> nat list list \\<Rightarrow> rat list list \\<Rightarrow> bool\"\n  where \"satisfy_equation p qs subset_list sign_list =\n        (mult_mat_vec (matrix_A sign_list subset_list) (construct_lhs_vector p qs sign_list) = (construct_rhs_vector p qs subset_list))\""], ["", "section \"Setting up the construction: Proofs\""], ["", "(* Some matrix lemmas  *)"], ["", "lemma row_mat_of_rows_list:\n  assumes \"list_all (\\<lambda>r. length r = nc) rs\"\n  assumes \"i < length rs\"\n  shows \"row (mat_of_rows_list nc rs) i = vec_of_list (nth rs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_of_rows_list nc rs) i = vec_of_list (rs ! i)", "by (smt assms(1) assms(2) dim_col_mat(1) dim_vec_of_list eq_vecI index_row(2) index_vec list_all_length mat_of_rows_list_def row_mat split_conv vec_of_list_index)"], ["", "lemma mult_mat_vec_of_list:\n  assumes \"length ls = nc\"\n  assumes \"list_all (\\<lambda>r. length r = nc) rs\"\n  shows \"mat_of_rows_list nc rs *\\<^sub>v vec_of_list ls =\n    vec_of_list (map (\\<lambda>r. vec_of_list r \\<bullet> vec_of_list ls) rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list nc rs *\\<^sub>v vec_of_list ls =\n    vec_of_list\n     (map (\\<lambda>r. vec_of_list r \\<bullet> vec_of_list ls) rs)", "unfolding mult_mat_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (dim_row (mat_of_rows_list nc rs))\n     (\\<lambda>i. row (mat_of_rows_list nc rs) i \\<bullet> vec_of_list ls) =\n    vec_of_list\n     (map (\\<lambda>r. vec_of_list r \\<bullet> vec_of_list ls) rs)", "using row_mat_of_rows_list assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all (\\<lambda>r. length r = ?nc) ?rs;\n   ?i < length ?rs\\<rbrakk>\n  \\<Longrightarrow> row (mat_of_rows_list ?nc ?rs) ?i =\n                    vec_of_list (?rs ! ?i)\n  length ls = nc\n  list_all (\\<lambda>r. length r = nc) rs\n\ngoal (1 subgoal):\n 1. vec (dim_row (mat_of_rows_list nc rs))\n     (\\<lambda>i. row (mat_of_rows_list nc rs) i \\<bullet> vec_of_list ls) =\n    vec_of_list\n     (map (\\<lambda>r. vec_of_list r \\<bullet> vec_of_list ls) rs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>nc rs i.\n                \\<lbrakk>list_all (\\<lambda>r. length r = nc) rs;\n                 i < length rs\\<rbrakk>\n                \\<Longrightarrow> row (mat_of_rows_list nc rs) i =\n                                  vec_of_list (rs ! i);\n     list_all (\\<lambda>r. length r = length ls) rs; nc = length ls\\<rbrakk>\n    \\<Longrightarrow> vec (dim_row (mat_of_rows_list (length ls) rs))\n                       (\\<lambda>i.\n                           row (mat_of_rows_list (length ls) rs) i \\<bullet>\n                           vec_of_list ls) =\n                      map_vec\n                       (\\<lambda>r. vec_of_list r \\<bullet> vec_of_list ls)\n                       (vec_of_list rs)", "by (smt dim_row_mat(1) dim_vec dim_vec_of_list eq_vecI index_map_vec(1) index_map_vec(2) index_vec list_all_length mat_of_rows_list_def row_mat_of_rows_list vec_of_list_index)"], ["", "lemma mtx_row_length:\n  \"list_all (\\<lambda>r. length r = length signs) (map (mtx_row signs) ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>r. length r = length signs) (map (mtx_row signs) ls)", "apply (induction ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all (\\<lambda>r. length r = length signs) (map (mtx_row signs) [])\n 2. \\<And>a ls.\n       list_all (\\<lambda>r. length r = length signs)\n        (map (mtx_row signs) ls) \\<Longrightarrow>\n       list_all (\\<lambda>r. length r = length signs)\n        (map (mtx_row signs) (a # ls))", "by (auto simp add: mtx_row_def)"], ["", "thm construct_lhs_vector_def"], ["", "thm  poly_roots_finite"], ["", "(* Recharacterize the LHS vector *)"], ["", "lemma construct_lhs_vector_clean:\n  assumes \"p \\<noteq> 0\"\n  assumes \"i < length signs\"\n  shows \"(construct_lhs_vector p qs signs) $ i =\n    card {x. poly p x = 0 \\<and> ((consistent_sign_vec_copr qs x) = (nth signs i))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat (construct_lhs_vector p qs signs $ i) =\n    of_nat\n     (card\n       {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_rat (construct_lhs_vector p qs signs $ i) =\n    of_nat\n     (card\n       {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i})", "from poly_roots_finite[OF assms(1)]"], ["proof (chain)\npicking this:\n  finite {x. poly p x = 0}", "have \"finite {x. poly p x = 0}\""], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0}", "."], ["proof (state)\nthis:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. of_rat (construct_lhs_vector p qs signs $ i) =\n    of_nat\n     (card\n       {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i})", "then"], ["proof (chain)\npicking this:\n  finite {x. poly p x = 0}", "have eq: \"(Collect\n       ((\\<lambda>v. v = signs ! i) \\<circ>\n        consistent_sign_vec_copr qs) \\<inter>\n      set (sorted_list_of_set\n            {x. poly p x = 0})) =\n    {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i}\""], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. Collect\n     ((\\<lambda>v. v = signs ! i) \\<circ>\n      consistent_sign_vec_copr qs) \\<inter>\n    set (sorted_list_of_set {x. poly p x = 0}) =\n    {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i}", "by auto"], ["proof (state)\nthis:\n  Collect\n   ((\\<lambda>v. v = signs ! i) \\<circ>\n    consistent_sign_vec_copr qs) \\<inter>\n  set (sorted_list_of_set {x. poly p x = 0}) =\n  {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i}\n\ngoal (1 subgoal):\n 1. of_rat (construct_lhs_vector p qs signs $ i) =\n    of_nat\n     (card\n       {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat (construct_lhs_vector p qs signs $ i) =\n    of_nat\n     (card\n       {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i})", "unfolding construct_lhs_vector_def vec_of_list_index characterize_root_list_p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat\n     (map (\\<lambda>w.\n              rat_of_int\n               (int (length\n                      (filter (\\<lambda>v. v = w)\n                        (map (consistent_sign_vec_copr qs)\n                          (sorted_list_of_set {x. poly p x = 0}))))))\n       signs !\n      i) =\n    of_nat\n     (card\n       {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat\n     (map (\\<lambda>w.\n              rat_of_nat\n               (length\n                 (filter\n                   ((\\<lambda>v. v = w) \\<circ> consistent_sign_vec_copr qs)\n                   (sorted_list_of_set {x. poly p x = 0}))))\n       signs !\n      i) =\n    of_nat\n     (card\n       {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i})", "apply (subst nth_map[OF assms(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat\n     (rat_of_nat\n       (length\n         (filter\n           ((\\<lambda>v. v = signs ! i) \\<circ> consistent_sign_vec_copr qs)\n           (sorted_list_of_set {x. poly p x = 0})))) =\n    of_nat\n     (card\n       {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter\n       ((\\<lambda>v. v = signs ! i) \\<circ> consistent_sign_vec_copr qs)\n       (sorted_list_of_set {x. poly p x = 0})) =\n    card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i}", "apply (subst distinct_length_filter)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (sorted_list_of_set {x. poly p x = 0})\n 2. card\n     (Collect\n       ((\\<lambda>v. v = signs ! i) \\<circ>\n        consistent_sign_vec_copr qs) \\<inter>\n      set (sorted_list_of_set {x. poly p x = 0})) =\n    card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i}", "using eq"], ["proof (prove)\nusing this:\n  Collect\n   ((\\<lambda>v. v = signs ! i) \\<circ>\n    consistent_sign_vec_copr qs) \\<inter>\n  set (sorted_list_of_set {x. poly p x = 0}) =\n  {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i}\n\ngoal (2 subgoals):\n 1. distinct (sorted_list_of_set {x. poly p x = 0})\n 2. card\n     (Collect\n       ((\\<lambda>v. v = signs ! i) \\<circ>\n        consistent_sign_vec_copr qs) \\<inter>\n      set (sorted_list_of_set {x. poly p x = 0})) =\n    card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i}", "by auto"], ["proof (state)\nthis:\n  of_rat (construct_lhs_vector p qs signs $ i) =\n  of_nat\n   (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = signs ! i})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma construct_lhs_vector_cleaner:\n  assumes \"p \\<noteq> 0\"\n  shows \"(construct_lhs_vector p qs signs) =\n   vec_of_list (map (\\<lambda>s. rat_of_int (card {x. poly p x = 0 \\<and> ((consistent_sign_vec_copr qs x) = s)})) signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. construct_lhs_vector p qs signs =\n    vec_of_list\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec_copr qs x = s})))\n       signs)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_list\n              (map (\\<lambda>s.\n                       rat_of_int\n                        (int (card\n                               {x. poly p x = 0 \\<and>\n                                   consistent_sign_vec_copr qs x = s})))\n                signs)) \\<Longrightarrow>\n       construct_lhs_vector p qs signs $ i =\n       vec_of_list\n        (map (\\<lambda>s.\n                 rat_of_int\n                  (int (card\n                         {x. poly p x = 0 \\<and>\n                             consistent_sign_vec_copr qs x = s})))\n          signs) $\n       i\n 2. dim_vec (construct_lhs_vector p qs signs) =\n    dim_vec\n     (vec_of_list\n       (map (\\<lambda>s.\n                rat_of_int\n                 (int (card\n                        {x. poly p x = 0 \\<and>\n                            consistent_sign_vec_copr qs x = s})))\n         signs))", "apply (auto simp add:  construct_lhs_vector_clean[OF assms] )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length signs \\<Longrightarrow>\n       construct_lhs_vector p qs signs $ i =\n       rat_of_nat\n        (card\n          {x. poly p x = 0 \\<and>\n              consistent_sign_vec_copr qs x = vec_of_list signs $ i})\n 2. dim_vec (construct_lhs_vector p qs signs) = length signs", "apply (simp add: vec_of_list_index)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length signs \\<Longrightarrow>\n       construct_lhs_vector p qs signs $ i =\n       rat_of_nat\n        (card\n          {x. poly p x = 0 \\<and>\n              consistent_sign_vec_copr qs x = signs ! i})\n 2. dim_vec (construct_lhs_vector p qs signs) = length signs", "unfolding construct_lhs_vector_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length signs \\<Longrightarrow>\n       vec_of_list\n        (map (\\<lambda>w.\n                 rat_of_int\n                  (int (length\n                         (filter (\\<lambda>v. v = w)\n                           (map (consistent_sign_vec_copr qs)\n                             (characterize_root_list_p p))))))\n          signs) $\n       i =\n       rat_of_nat\n        (card\n          {x. poly p x = 0 \\<and>\n              consistent_sign_vec_copr qs x = signs ! i})\n 2. dim_vec\n     (vec_of_list\n       (map (\\<lambda>w.\n                rat_of_int\n                 (int (length\n                        (filter (\\<lambda>v. v = w)\n                          (map (consistent_sign_vec_copr qs)\n                            (characterize_root_list_p p))))))\n         signs)) =\n    length signs", "using assms construct_lhs_vector_clean construct_lhs_vector_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<lbrakk>?p \\<noteq> 0; ?i < length ?signs\\<rbrakk>\n  \\<Longrightarrow> of_rat (construct_lhs_vector ?p ?qs ?signs $ ?i) =\n                    of_nat\n                     (card\n                       {x. poly ?p x = 0 \\<and>\n                           consistent_sign_vec_copr ?qs x = ?signs ! ?i})\n  construct_lhs_vector ?p ?qs ?signs \\<equiv>\n  vec_of_list\n   (map (\\<lambda>w.\n            rat_of_int\n             (int (length\n                    (filter (\\<lambda>v. v = w)\n                      (map (consistent_sign_vec_copr ?qs)\n                        (characterize_root_list_p ?p))))))\n     ?signs)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length signs \\<Longrightarrow>\n       vec_of_list\n        (map (\\<lambda>w.\n                 rat_of_int\n                  (int (length\n                         (filter (\\<lambda>v. v = w)\n                           (map (consistent_sign_vec_copr qs)\n                             (characterize_root_list_p p))))))\n          signs) $\n       i =\n       rat_of_nat\n        (card\n          {x. poly p x = 0 \\<and>\n              consistent_sign_vec_copr qs x = signs ! i})\n 2. dim_vec\n     (vec_of_list\n       (map (\\<lambda>w.\n                rat_of_int\n                 (int (length\n                        (filter (\\<lambda>v. v = w)\n                          (map (consistent_sign_vec_copr qs)\n                            (characterize_root_list_p p))))))\n         signs)) =\n    length signs", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (map (\\<lambda>w.\n                rat_of_int\n                 (int (length\n                        (filter (\\<lambda>v. v = w)\n                          (map (consistent_sign_vec_copr qs)\n                            (characterize_root_list_p p))))))\n         signs)) =\n    length signs", "by simp"], ["", "(* Show that because our consistent sign vectors consist of 1 and -1's, z returns 1 or -1 \n  when applied to a consistent sign vector *)"], ["", "lemma z_signs:\n  assumes \"list_all (\\<lambda>i. i < length signs) I\"\n  assumes \"list_all (\\<lambda>s. s = 1 \\<or> s = -1) signs\"\n  shows \"(z I signs = 1) \\<or> (z I signs = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z I signs = 1 \\<or> z I signs = - 1", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) I\n  list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. z I signs = 1 \\<or> z I signs = - 1", "proof (induction I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>i. i < length signs) [];\n     list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n    \\<Longrightarrow> z [] signs = 1 \\<or> z [] signs = - 1\n 2. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n                \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n       \\<Longrightarrow> z (a # I) signs = 1 \\<or> z (a # I) signs = - 1", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>i. i < length signs) []\n  list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>i. i < length signs) [];\n     list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n    \\<Longrightarrow> z [] signs = 1 \\<or> z [] signs = - 1\n 2. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n                \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n       \\<Longrightarrow> z (a # I) signs = 1 \\<or> z (a # I) signs = - 1", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>i. i < length signs) []\n  list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs", "show ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>i. i < length signs) []\n  list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. z [] signs = 1 \\<or> z [] signs = - 1", "by (auto simp add:z_def)"], ["proof (state)\nthis:\n  z [] signs = 1 \\<or> z [] signs = - 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n                \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n       \\<Longrightarrow> z (a # I) signs = 1 \\<or> z (a # I) signs = - 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n                \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n       \\<Longrightarrow> z (a # I) signs = 1 \\<or> z (a # I) signs = - 1", "case (Cons a I)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n  \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1\n  list_all (\\<lambda>i. i < length signs) (a # I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n                \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n       \\<Longrightarrow> z (a # I) signs = 1 \\<or> z (a # I) signs = - 1", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n  \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1\n  list_all (\\<lambda>i. i < length signs) (a # I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n                \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n       \\<Longrightarrow> z (a # I) signs = 1 \\<or> z (a # I) signs = - 1", "have \"signs ! a = 1 \\<or> signs ! a = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signs ! a = 1 \\<or> signs ! a = - 1", "by (metis (mono_tags, lifting) add_Suc_right calculation(2) calculation(3) gr0_conv_Suc list.size(4) list_all_length nth_Cons_0)"], ["proof (state)\nthis:\n  signs ! a = 1 \\<or> signs ! a = - 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       \\<lbrakk>\\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n                 list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n                \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1;\n        list_all (\\<lambda>i. i < length signs) (a # I);\n        list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n       \\<Longrightarrow> z (a # I) signs = 1 \\<or> z (a # I) signs = - 1", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n  \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1\n  list_all (\\<lambda>i. i < length signs) (a # I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\n  signs ! a = 1 \\<or> signs ! a = - 1", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all (\\<lambda>i. i < length signs) I;\n   list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\\<rbrakk>\n  \\<Longrightarrow> z I signs = 1 \\<or> z I signs = - 1\n  list_all (\\<lambda>i. i < length signs) (a # I)\n  list_all (\\<lambda>s. s = 1 \\<or> s = - 1) signs\n  signs ! a = 1 \\<or> signs ! a = - 1\n\ngoal (1 subgoal):\n 1. z (a # I) signs = 1 \\<or> z (a # I) signs = - 1", "by (auto simp add:z_def)"], ["proof (state)\nthis:\n  z (a # I) signs = 1 \\<or> z (a # I) signs = - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma z_lemma:\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  assumes consistent: \"sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows \"(z I sign = 1) \\<or> (z I sign = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z I sign = 1 \\<or> z I sign = - 1", "proof (rule z_signs)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all (\\<lambda>i. i < length sign) I\n 2. list_all (\\<lambda>s. s = 1 \\<or> s = - 1) sign", "have \"length sign = length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length sign = length qs", "using consistent"], ["proof (prove)\nusing this:\n  sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\n\ngoal (1 subgoal):\n 1. length sign = length qs", "by (auto simp add: characterize_consistent_signs_at_roots_copr_def consistent_sign_vec_copr_def)"], ["proof (state)\nthis:\n  length sign = length qs\n\ngoal (2 subgoals):\n 1. list_all (\\<lambda>i. i < length sign) I\n 2. list_all (\\<lambda>s. s = 1 \\<or> s = - 1) sign", "thus \"list_all (\\<lambda>i. i < length sign) I\""], ["proof (prove)\nusing this:\n  length sign = length qs\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>i. i < length sign) I", "using welldefined"], ["proof (prove)\nusing this:\n  length sign = length qs\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>i. i < length sign) I", "by (auto simp add: list_constr_def characterize_consistent_signs_at_roots_copr_def consistent_sign_vec_copr_def)"], ["proof (state)\nthis:\n  list_all (\\<lambda>i. i < length sign) I\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = - 1) sign", "show \"list_all (\\<lambda>s. s = 1 \\<or> s = - 1) sign\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = - 1) sign", "using consistent"], ["proof (prove)\nusing this:\n  sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>s. s = 1 \\<or> s = - 1) sign", "apply (auto simp add: list.pred_map  characterize_consistent_signs_at_roots_copr_def  consistent_sign_vec_copr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (characterize_root_list_p p);\n        sign = map (\\<lambda>q. if 0 < poly q x then 1 else - 1) qs\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          ((\\<lambda>s. s = 1 \\<or> s = - 1) \\<circ>\n                           (\\<lambda>q. if 0 < poly q x then 1 else - 1))\n                          qs", "using Ball_set"], ["proof (prove)\nusing this:\n  Ball (set ?xs) ?P = list_all ?P ?xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (characterize_root_list_p p);\n        sign = map (\\<lambda>q. if 0 < poly q x then 1 else - 1) qs\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          ((\\<lambda>s. s = 1 \\<or> s = - 1) \\<circ>\n                           (\\<lambda>q. if 0 < poly q x then 1 else - 1))\n                          qs", "by force"], ["proof (state)\nthis:\n  list_all (\\<lambda>s. s = 1 \\<or> s = - 1) sign\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Show that all consistent sign vectors on roots of polynomials are in characterize_consistent_signs_at_roots_copr  *)"], ["", "lemma in_set: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec_copr qs x\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows \"sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)", "have h1: \"consistent_sign_vec_copr qs x \\<in>\n      set (remdups (map (consistent_sign_vec_copr qs) (sorted_list_of_set {x. poly p x = 0})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_sign_vec_copr qs x\n    \\<in> set (remdups\n                (map (consistent_sign_vec_copr qs)\n                  (sorted_list_of_set {x. poly p x = 0})))", "using root_p"], ["proof (prove)\nusing this:\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. consistent_sign_vec_copr qs x\n    \\<in> set (remdups\n                (map (consistent_sign_vec_copr qs)\n                  (sorted_list_of_set {x. poly p x = 0})))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = 0 \\<Longrightarrow>\n    consistent_sign_vec_copr qs x\n    \\<in> consistent_sign_vec_copr qs `\n          set (sorted_list_of_set {x. poly p x = 0})", "apply (subst set_sorted_list_of_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly p x = 0 \\<Longrightarrow> finite {x. poly p x = 0}\n 2. poly p x = 0 \\<Longrightarrow>\n    consistent_sign_vec_copr qs x\n    \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0}", "using nonzero poly_roots_finite rsquarefree_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n  rsquarefree ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>a. Polynomial.order a ?p = 0 \\<or> Polynomial.order a ?p = 1))\n\ngoal (2 subgoals):\n 1. poly p x = 0 \\<Longrightarrow> finite {x. poly p x = 0}\n 2. poly p x = 0 \\<Longrightarrow>\n    consistent_sign_vec_copr qs x\n    \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = 0 \\<Longrightarrow>\n    consistent_sign_vec_copr qs x\n    \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  consistent_sign_vec_copr qs x\n  \\<in> set (remdups\n              (map (consistent_sign_vec_copr qs)\n                (sorted_list_of_set {x. poly p x = 0})))\n\ngoal (1 subgoal):\n 1. sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  consistent_sign_vec_copr qs x\n  \\<in> set (remdups\n              (map (consistent_sign_vec_copr qs)\n                (sorted_list_of_set {x. poly p x = 0})))\n\ngoal (1 subgoal):\n 1. sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)", "unfolding characterize_consistent_signs_at_roots_copr_def characterize_root_list_p_def"], ["proof (prove)\nusing this:\n  consistent_sign_vec_copr qs x\n  \\<in> set (remdups\n              (map (consistent_sign_vec_copr qs)\n                (sorted_list_of_set {x. poly p x = 0})))\n\ngoal (1 subgoal):\n 1. sign\n    \\<in> set (remdups\n                (map (consistent_sign_vec_copr qs)\n                  (sorted_list_of_set {x. poly p x = 0})))", "using sign_fix"], ["proof (prove)\nusing this:\n  consistent_sign_vec_copr qs x\n  \\<in> set (remdups\n              (map (consistent_sign_vec_copr qs)\n                (sorted_list_of_set {x. poly p x = 0})))\n  sign = consistent_sign_vec_copr qs x\n\ngoal (1 subgoal):\n 1. sign\n    \\<in> set (remdups\n                (map (consistent_sign_vec_copr qs)\n                  (sorted_list_of_set {x. poly p x = 0})))", "by blast"], ["proof (state)\nthis:\n  sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Since all of the polynomials in qs are relatively prime to p, products of subsets of these\n    polynomials are also relatively prime to p  *)"], ["", "lemma nonzero_product: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  fixes I:: \"nat list\" \n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows \"(poly (prod_list (retrieve_polys qs I)) x > 0) \\<or> (poly (prod_list (retrieve_polys qs I)) x < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "have \"\\<And>x. x \\<in> set (retrieve_polys qs I) \\<Longrightarrow> coprime p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (retrieve_polys qs I) \\<Longrightarrow> coprime p x", "unfolding retrieve_polys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (map ((!) qs) I) \\<Longrightarrow> coprime p x", "by (smt in_set_conv_nth in_set_member length_map list_all_length list_constr_def nth_map pairwise_rel_prime_1 welldefined)"], ["proof (state)\nthis:\n  ?x \\<in> set (retrieve_polys qs I) \\<Longrightarrow> coprime p ?x\n\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> set (retrieve_polys qs I) \\<Longrightarrow> coprime p ?x", "have coprimeh: \"coprime p (prod_list (retrieve_polys qs I))\""], ["proof (prove)\nusing this:\n  ?x \\<in> set (retrieve_polys qs I) \\<Longrightarrow> coprime p ?x\n\ngoal (1 subgoal):\n 1. coprime p (prod_list (retrieve_polys qs I))", "using prod_list_coprime_right"], ["proof (prove)\nusing this:\n  ?x \\<in> set (retrieve_polys qs I) \\<Longrightarrow> coprime p ?x\n  (\\<And>x.\n      x \\<in> set ?xs \\<Longrightarrow> coprime ?a x) \\<Longrightarrow>\n  coprime ?a (prod_list ?xs)\n\ngoal (1 subgoal):\n 1. coprime p (prod_list (retrieve_polys qs I))", "by auto"], ["proof (state)\nthis:\n  coprime p (prod_list (retrieve_polys qs I))\n\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  coprime p (prod_list (retrieve_polys qs I))\n\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "using root_p"], ["proof (prove)\nusing this:\n  coprime p (prod_list (retrieve_polys qs I))\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "using coprime_poly_0 linorder_neqE_linordered_idom"], ["proof (prove)\nusing this:\n  coprime p (prod_list (retrieve_polys qs I))\n  x \\<in> {x. poly p x = 0}\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n  \\<lbrakk>?x \\<noteq> ?y; ?x < ?y \\<Longrightarrow> ?thesis;\n   ?y < ?x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "by blast"], ["proof (state)\nthis:\n  0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n  poly (prod_list (retrieve_polys qs I)) x < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "(* The next few lemmas relate z to the signs of the product of subsets of polynomials of qs *)"], ["", "lemma horiz_vector_helper_pos_ind: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec_copr qs x\"\n  shows \"(list_constr I (length qs)) \\<longrightarrow> (poly (prod_list (retrieve_polys qs I)) x > 0) \\<longleftrightarrow> (z I sign = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)", "proof (induct I)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_constr [] (length qs) \\<longrightarrow>\n    (0 < poly (prod_list (retrieve_polys qs [])) x) = (z [] sign = 1)\n 2. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. list_constr [] (length qs) \\<longrightarrow>\n    (0 < poly (prod_list (retrieve_polys qs [])) x) = (z [] sign = 1)\n 2. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr [] (length qs) \\<longrightarrow>\n    (0 < poly (prod_list (retrieve_polys qs [])) x) = (z [] sign = 1)", "by (simp add: retrieve_polys_def z_def)"], ["proof (state)\nthis:\n  list_constr [] (length qs) \\<longrightarrow>\n  (0 < poly (prod_list (retrieve_polys qs [])) x) = (z [] sign = 1)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "case (Cons a I)"], ["proof (state)\nthis:\n  list_constr I (length qs) \\<longrightarrow>\n  (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have welldef: \"list_constr (a#I) (length qs) \\<longrightarrow> (list_constr I (length qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    list_constr I (length qs)", "unfolding list_constr_def list_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (a # I). x < length qs) \\<longrightarrow>\n    (\\<forall>x\\<in>set I. x < length qs)", "by auto"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have set_hyp: \"list_constr I (length qs) \\<longrightarrow> sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)", "using in_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec_copr ?qs ?x;\n   list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> ?sign\n                    \\<in> set (characterize_consistent_signs_at_roots_copr\n                                ?p ?qs)\n\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)", "using nonzero root_p sign_fix"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec_copr ?qs ?x;\n   list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> ?sign\n                    \\<in> set (characterize_consistent_signs_at_roots_copr\n                                ?p ?qs)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec_copr qs x\n\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)", "by blast"], ["proof (state)\nthis:\n  list_constr I (length qs) \\<longrightarrow>\n  sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have z_hyp: \"list_constr I (length qs) \\<longrightarrow> ((z I sign = 1) \\<or> (z I sign = -1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    z I sign = 1 \\<or> z I sign = - 1", "using set_hyp z_lemma[where sign=\"sign\", where I = \"I\", where p=\"p\", where qs=\"qs\"]"], ["proof (prove)\nusing this:\n  list_constr I (length qs) \\<longrightarrow>\n  sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\n  \\<lbrakk>sign\n           \\<in> set (characterize_consistent_signs_at_roots_copr p qs);\n   list_constr I (length qs)\\<rbrakk>\n  \\<Longrightarrow> z I sign = 1 \\<or> z I sign = - 1\n\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    z I sign = 1 \\<or> z I sign = - 1", "by blast"], ["proof (state)\nthis:\n  list_constr I (length qs) \\<longrightarrow>\n  z I sign = 1 \\<or> z I sign = - 1\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have sign_hyp: \"sign = map (\\<lambda> q. if (poly q x > 0) then 1 else -1) qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign = map (\\<lambda>q. if 0 < poly q x then 1 else - 1) qs", "using sign_fix"], ["proof (prove)\nusing this:\n  sign = consistent_sign_vec_copr qs x\n\ngoal (1 subgoal):\n 1. sign = map (\\<lambda>q. if 0 < poly q x then 1 else - 1) qs", "unfolding consistent_sign_vec_copr_def"], ["proof (prove)\nusing this:\n  sign = map (\\<lambda>q. if 0 < poly q x then 1 else - 1) qs\n\ngoal (1 subgoal):\n 1. sign = map (\\<lambda>q. if 0 < poly q x then 1 else - 1) qs", "by blast"], ["proof (state)\nthis:\n  sign = map (\\<lambda>q. if 0 < poly q x then 1 else - 1) qs\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have ind_hyp_1: \"list_constr (a#I) (length qs) \\<longrightarrow> \n    ((0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)", "using welldef Cons.hyps"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  list_constr I (length qs)\n  list_constr I (length qs) \\<longrightarrow>\n  (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)", "by auto"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have ind_hyp_2: \"list_constr (a#I) (length qs) \\<longrightarrow> \n    ((0 > poly (prod_list (retrieve_polys qs I)) x) = (z I sign = -1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "using welldef z_hyp Cons.hyps nonzero_product"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  list_constr I (length qs)\n  list_constr I (length qs) \\<longrightarrow>\n  z I sign = 1 \\<or> z I sign = - 1\n  list_constr I (length qs) \\<longrightarrow>\n  (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<forall>q. List.member ?qs q \\<longrightarrow> coprime ?p q;\n   ?x \\<in> {x. poly ?p x = 0}; list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> 0 < poly (prod_list (retrieve_polys ?qs ?I)) ?x \\<or>\n                    poly (prod_list (retrieve_polys ?qs ?I)) ?x < 0\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "using pairwise_rel_prime_1 nonzero root_p"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  list_constr I (length qs)\n  list_constr I (length qs) \\<longrightarrow>\n  z I sign = 1 \\<or> z I sign = - 1\n  list_constr I (length qs) \\<longrightarrow>\n  (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<forall>q. List.member ?qs q \\<longrightarrow> coprime ?p q;\n   ?x \\<in> {x. poly ?p x = 0}; list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> 0 < poly (prod_list (retrieve_polys ?qs ?I)) ?x \\<or>\n                    poly (prod_list (retrieve_polys ?qs ?I)) ?x < 0\n  \\<forall>q. List.member qs q \\<longrightarrow> coprime p q\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "by auto"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have h1: \"prod_list (retrieve_polys qs (a # I)) = (nth qs a)*(prod_list (retrieve_polys qs I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (retrieve_polys qs (a # I)) =\n    qs ! a * prod_list (retrieve_polys qs I)", "by (simp add: retrieve_polys_def)"], ["proof (state)\nthis:\n  prod_list (retrieve_polys qs (a # I)) =\n  qs ! a * prod_list (retrieve_polys qs I)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have h2: \"(z (a # I) sign) = (nth sign a)*(z I sign)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z (a # I) sign = sign ! a * z I sign", "by (metis (mono_tags, hide_lams) list.simps(9) prod_list.Cons z_def)"], ["proof (state)\nthis:\n  z (a # I) sign = sign ! a * z I sign\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have h3help: \"list_constr (a#I) (length qs) \\<longrightarrow> a < length qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow> a < length qs", "unfolding list_constr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x < length qs) (a # I) \\<longrightarrow>\n    a < length qs", "by simp"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow> a < length qs\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "then"], ["proof (chain)\npicking this:\n  list_constr (a # I) (length qs) \\<longrightarrow> a < length qs", "have h3: \"list_constr (a#I) (length qs) \\<longrightarrow> \n    ((nth sign a) = (if (poly (nth qs a) x > 0) then 1 else -1))\""], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow> a < length qs\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    sign ! a = (if 0 < poly (qs ! a) x then 1 else - 1)", "using nth_map sign_hyp"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow> a < length qs\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n  sign = map (\\<lambda>q. if 0 < poly q x then 1 else - 1) qs\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    sign ! a = (if 0 < poly (qs ! a) x then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  sign ! a = (if 0 < poly (qs ! a) x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have h2: \"(0 < poly ((nth qs a)*(prod_list (retrieve_polys qs I))) x) \\<longleftrightarrow> \n    ((0 < poly (nth qs a) x \\<and> (0 < poly (prod_list (retrieve_polys qs I)) x)) \\<or>\n   (0 > poly (nth qs a) x \\<and> (0 > poly (prod_list (retrieve_polys qs I)) x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < poly (qs ! a * prod_list (retrieve_polys qs I)) x) =\n    (0 < poly (qs ! a) x \\<and>\n     0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n     poly (qs ! a) x < 0 \\<and>\n     poly (prod_list (retrieve_polys qs I)) x < 0)", "by (simp add: zero_less_mult_iff)"], ["proof (state)\nthis:\n  (0 < poly (qs ! a * prod_list (retrieve_polys qs I)) x) =\n  (0 < poly (qs ! a) x \\<and>\n   0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n   poly (qs ! a) x < 0 \\<and> poly (prod_list (retrieve_polys qs I)) x < 0)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "have final_hyp_a: \"list_constr (a#I) (length qs) \\<longrightarrow> (((0 < poly (nth qs a) x \\<and> (0 < poly (prod_list (retrieve_polys qs I)) x)) \n    \\<or> (0 > poly (nth qs a) x \\<and> (0 > poly (prod_list (retrieve_polys qs I)) x))) = \n    ((nth sign a)*(z I sign) = 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x \\<and>\n     0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n     poly (qs ! a) x < 0 \\<and>\n     poly (prod_list (retrieve_polys qs I)) x < 0) =\n    (sign ! a * z I sign = 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x \\<and>\n     0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n     poly (qs ! a) x < 0 \\<and>\n     poly (prod_list (retrieve_polys qs I)) x < 0) =\n    (sign ! a * z I sign = 1)", "have extra_hyp_a: \"list_constr (a#I) (length qs) \\<longrightarrow> (0 < poly (nth qs a) x = ((nth sign a) = 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x) = (sign ! a = 1)", "using h3"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  sign ! a = (if 0 < poly (qs ! a) x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x) = (sign ! a = 1)", "by simp"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x) = (sign ! a = 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x \\<and>\n     0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n     poly (qs ! a) x < 0 \\<and>\n     poly (prod_list (retrieve_polys qs I)) x < 0) =\n    (sign ! a * z I sign = 1)", "have extra_hyp_b: \"list_constr (a#I) (length qs) \\<longrightarrow>  (0 > poly (nth qs a) x = ((nth sign a) = -1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (poly (qs ! a) x < 0) = (sign ! a = - 1)", "using h3"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  sign ! a = (if 0 < poly (qs ! a) x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (poly (qs ! a) x < 0) = (sign ! a = - 1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < poly (qs ! a) x; list_constr (a # I) (length qs);\n     sign ! a = - 1\\<rbrakk>\n    \\<Longrightarrow> poly (qs ! a) x < 0", "using coprime_poly_0 h3help in_set_member nth_mem pairwise_rel_prime_1 root_p"], ["proof (prove)\nusing this:\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n  list_constr (a # I) (length qs) \\<longrightarrow> a < length qs\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  \\<forall>q. List.member qs q \\<longrightarrow> coprime p q\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> 0 < poly (qs ! a) x; list_constr (a # I) (length qs);\n     sign ! a = - 1\\<rbrakk>\n    \\<Longrightarrow> poly (qs ! a) x < 0", "by fastforce"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (poly (qs ! a) x < 0) = (sign ! a = - 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x \\<and>\n     0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n     poly (qs ! a) x < 0 \\<and>\n     poly (prod_list (retrieve_polys qs I)) x < 0) =\n    (sign ! a * z I sign = 1)", "have ind_hyp_1: \"list_constr (a#I) (length qs) \\<longrightarrow> (((0 < poly (nth qs a) x \\<and> (z I sign = 1)) \\<or> \n    (0 > poly (nth qs a) x \\<and> (z I sign = -1)))\n      = ((nth sign a)*(z I sign) = 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x \\<and> z I sign = 1 \\<or>\n     poly (qs ! a) x < 0 \\<and> z I sign = - 1) =\n    (sign ! a * z I sign = 1)", "using extra_hyp_a extra_hyp_b"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x) = (sign ! a = 1)\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (poly (qs ! a) x < 0) = (sign ! a = - 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x \\<and> z I sign = 1 \\<or>\n     poly (qs ! a) x < 0 \\<and> z I sign = - 1) =\n    (sign ! a * z I sign = 1)", "using zmult_eq_1_iff"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x) = (sign ! a = 1)\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (poly (qs ! a) x < 0) = (sign ! a = - 1)\n  (?m * ?n = 1) = (?m = 1 \\<and> ?n = 1 \\<or> ?m = - 1 \\<and> ?n = - 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x \\<and> z I sign = 1 \\<or>\n     poly (qs ! a) x < 0 \\<and> z I sign = - 1) =\n    (sign ! a * z I sign = 1)", "by (simp add: h3)"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x \\<and> z I sign = 1 \\<or>\n   poly (qs ! a) x < 0 \\<and> z I sign = - 1) =\n  (sign ! a * z I sign = 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x \\<and>\n     0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n     poly (qs ! a) x < 0 \\<and>\n     poly (prod_list (retrieve_polys qs I)) x < 0) =\n    (sign ! a * z I sign = 1)", "then"], ["proof (chain)\npicking this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x \\<and> z I sign = 1 \\<or>\n   poly (qs ! a) x < 0 \\<and> z I sign = - 1) =\n  (sign ! a * z I sign = 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x \\<and> z I sign = 1 \\<or>\n   poly (qs ! a) x < 0 \\<and> z I sign = - 1) =\n  (sign ! a * z I sign = 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x \\<and>\n     0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n     poly (qs ! a) x < 0 \\<and>\n     poly (prod_list (retrieve_polys qs I)) x < 0) =\n    (sign ! a * z I sign = 1)", "using ind_hyp_1 ind_hyp_2"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x \\<and> z I sign = 1 \\<or>\n   poly (qs ! a) x < 0 \\<and> z I sign = - 1) =\n  (sign ! a * z I sign = 1)\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x \\<and> z I sign = 1 \\<or>\n   poly (qs ! a) x < 0 \\<and> z I sign = - 1) =\n  (sign ! a * z I sign = 1)\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (qs ! a) x \\<and>\n     0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n     poly (qs ! a) x < 0 \\<and>\n     poly (prod_list (retrieve_polys qs I)) x < 0) =\n    (sign ! a * z I sign = 1)", "by (simp add: Cons.hyps welldef)"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x \\<and>\n   0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n   poly (qs ! a) x < 0 \\<and>\n   poly (prod_list (retrieve_polys qs I)) x < 0) =\n  (sign ! a * z I sign = 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x \\<and>\n   0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n   poly (qs ! a) x < 0 \\<and>\n   poly (prod_list (retrieve_polys qs I)) x < 0) =\n  (sign ! a * z I sign = 1)\n\ngoal (1 subgoal):\n 1. \\<And>a I.\n       list_constr I (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs I)) x) =\n       (z I sign = 1) \\<Longrightarrow>\n       list_constr (a # I) (length qs) \\<longrightarrow>\n       (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n       (z (a # I) sign = 1)", "then"], ["proof (chain)\npicking this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x \\<and>\n   0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n   poly (qs ! a) x < 0 \\<and>\n   poly (prod_list (retrieve_polys qs I)) x < 0) =\n  (sign ! a * z I sign = 1)", "show ?case"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x \\<and>\n   0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n   poly (qs ! a) x < 0 \\<and>\n   poly (prod_list (retrieve_polys qs I)) x < 0) =\n  (sign ! a * z I sign = 1)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n    (z (a # I) sign = 1)", "using h1 z_def"], ["proof (prove)\nusing this:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (qs ! a) x \\<and>\n   0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n   poly (qs ! a) x < 0 \\<and>\n   poly (prod_list (retrieve_polys qs I)) x < 0) =\n  (sign ! a * z I sign = 1)\n  prod_list (retrieve_polys qs (a # I)) =\n  qs ! a * prod_list (retrieve_polys qs I)\n  z ?index_list ?sign_asg \\<equiv>\n  prod_list (map ((!) ?sign_asg) ?index_list)\n\ngoal (1 subgoal):\n 1. list_constr (a # I) (length qs) \\<longrightarrow>\n    (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n    (z (a # I) sign = 1)", "by (simp add: zero_less_mult_iff)"], ["proof (state)\nthis:\n  list_constr (a # I) (length qs) \\<longrightarrow>\n  (0 < poly (prod_list (retrieve_polys qs (a # I))) x) =\n  (z (a # I) sign = 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma horiz_vector_helper_pos: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec_copr qs x\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows \"(poly (prod_list (retrieve_polys qs I)) x > 0) \\<longleftrightarrow> (z I sign = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)", "using horiz_vector_helper_pos_ind"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<forall>q. List.member ?qs q \\<longrightarrow> coprime ?p q;\n   ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec_copr ?qs ?x\\<rbrakk>\n  \\<Longrightarrow> list_constr ?I (length ?qs) \\<longrightarrow>\n                    (0 < poly (prod_list (retrieve_polys ?qs ?I)) ?x) =\n                    (z ?I ?sign = 1)\n\ngoal (1 subgoal):\n 1. (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)", "using pairwise_rel_prime_1 nonzero  root_p sign_fix welldefined"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<forall>q. List.member ?qs q \\<longrightarrow> coprime ?p q;\n   ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec_copr ?qs ?x\\<rbrakk>\n  \\<Longrightarrow> list_constr ?I (length ?qs) \\<longrightarrow>\n                    (0 < poly (prod_list (retrieve_polys ?qs ?I)) ?x) =\n                    (z ?I ?sign = 1)\n  \\<forall>q. List.member qs q \\<longrightarrow> coprime p q\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec_copr qs x\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)", "by blast"], ["", "lemma horiz_vector_helper_neg: \n  fixes p:: \"real poly\"\n  assumes nonzero: \"p\\<noteq>0\"\n  fixes qs:: \"real poly list\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  fixes I:: \"nat list\" \n  fixes sign:: \"rat list\"\n  fixes x:: \"real\"\n  assumes root_p: \"x \\<in> {x. poly p x = 0}\"\n  assumes sign_fix: \"sign = consistent_sign_vec_copr qs x\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows \"(poly (prod_list (retrieve_polys qs I)) x < 0) \\<longleftrightarrow> (z I sign = -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "have set_hyp: \"list_constr I (length qs) \\<longrightarrow> sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)", "using in_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec_copr ?qs ?x;\n   list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> ?sign\n                    \\<in> set (characterize_consistent_signs_at_roots_copr\n                                ?p ?qs)\n\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)", "using nonzero root_p sign_fix"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0; ?x \\<in> {x. poly ?p x = 0};\n   ?sign = consistent_sign_vec_copr ?qs ?x;\n   list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> ?sign\n                    \\<in> set (characterize_consistent_signs_at_roots_copr\n                                ?p ?qs)\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec_copr qs x\n\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)", "by blast"], ["proof (state)\nthis:\n  list_constr I (length qs) \\<longrightarrow>\n  sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\n\ngoal (1 subgoal):\n 1. (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "have z_hyp: \"list_constr I (length qs) \\<longrightarrow> ((z I sign = 1) \\<or> (z I sign = -1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    z I sign = 1 \\<or> z I sign = - 1", "using set_hyp  z_lemma[where sign=\"sign\", where I = \"I\", where p=\"p\", where qs=\"qs\"]"], ["proof (prove)\nusing this:\n  list_constr I (length qs) \\<longrightarrow>\n  sign \\<in> set (characterize_consistent_signs_at_roots_copr p qs)\n  \\<lbrakk>sign\n           \\<in> set (characterize_consistent_signs_at_roots_copr p qs);\n   list_constr I (length qs)\\<rbrakk>\n  \\<Longrightarrow> z I sign = 1 \\<or> z I sign = - 1\n\ngoal (1 subgoal):\n 1. list_constr I (length qs) \\<longrightarrow>\n    z I sign = 1 \\<or> z I sign = - 1", "by blast"], ["proof (state)\nthis:\n  list_constr I (length qs) \\<longrightarrow>\n  z I sign = 1 \\<or> z I sign = - 1\n\ngoal (1 subgoal):\n 1. (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "have poly_hyp: \"(poly (prod_list (retrieve_polys qs I)) x > 0) \\<or> (poly (prod_list (retrieve_polys qs I)) x < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "using nonzero_product"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<forall>q. List.member ?qs q \\<longrightarrow> coprime ?p q;\n   ?x \\<in> {x. poly ?p x = 0}; list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> 0 < poly (prod_list (retrieve_polys ?qs ?I)) ?x \\<or>\n                    poly (prod_list (retrieve_polys ?qs ?I)) ?x < 0\n\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "using pairwise_rel_prime_1 nonzero root_p"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<forall>q. List.member ?qs q \\<longrightarrow> coprime ?p q;\n   ?x \\<in> {x. poly ?p x = 0}; list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> 0 < poly (prod_list (retrieve_polys ?qs ?I)) ?x \\<or>\n                    poly (prod_list (retrieve_polys ?qs ?I)) ?x < 0\n  \\<forall>q. List.member qs q \\<longrightarrow> coprime p q\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "using welldefined"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<forall>q. List.member ?qs q \\<longrightarrow> coprime ?p q;\n   ?x \\<in> {x. poly ?p x = 0}; list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> 0 < poly (prod_list (retrieve_polys ?qs ?I)) ?x \\<or>\n                    poly (prod_list (retrieve_polys ?qs ?I)) ?x < 0\n  \\<forall>q. List.member qs q \\<longrightarrow> coprime p q\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. 0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n    poly (prod_list (retrieve_polys qs I)) x < 0", "by blast"], ["proof (state)\nthis:\n  0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n  poly (prod_list (retrieve_polys qs I)) x < 0\n\ngoal (1 subgoal):\n 1. (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "have pos_hyp: \"(poly (prod_list (retrieve_polys qs I)) x > 0) \\<longleftrightarrow> (z I sign = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)", "using horiz_vector_helper_pos"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<forall>q. List.member ?qs q \\<longrightarrow> coprime ?p q;\n   ?x \\<in> {x. poly ?p x = 0}; ?sign = consistent_sign_vec_copr ?qs ?x;\n   list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> (0 < poly (prod_list (retrieve_polys ?qs ?I)) ?x) =\n                    (z ?I ?sign = 1)\n\ngoal (1 subgoal):\n 1. (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)", "using pairwise_rel_prime_1 nonzero root_p sign_fix welldefined"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<noteq> 0;\n   \\<forall>q. List.member ?qs q \\<longrightarrow> coprime ?p q;\n   ?x \\<in> {x. poly ?p x = 0}; ?sign = consistent_sign_vec_copr ?qs ?x;\n   list_constr ?I (length ?qs)\\<rbrakk>\n  \\<Longrightarrow> (0 < poly (prod_list (retrieve_polys ?qs ?I)) ?x) =\n                    (z ?I ?sign = 1)\n  \\<forall>q. List.member qs q \\<longrightarrow> coprime p q\n  p \\<noteq> 0\n  x \\<in> {x. poly p x = 0}\n  sign = consistent_sign_vec_copr qs x\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)", "by blast"], ["proof (state)\nthis:\n  (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)\n\ngoal (1 subgoal):\n 1. (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "using z_hyp poly_hyp pos_hyp"], ["proof (prove)\nusing this:\n  list_constr I (length qs) \\<longrightarrow>\n  z I sign = 1 \\<or> z I sign = - 1\n  0 < poly (prod_list (retrieve_polys qs I)) x \\<or>\n  poly (prod_list (retrieve_polys qs I)) x < 0\n  (0 < poly (prod_list (retrieve_polys qs I)) x) = (z I sign = 1)\n\ngoal (1 subgoal):\n 1. (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> list_constr I (length qs); z I sign \\<noteq> 1;\n     poly (prod_list (retrieve_polys qs I)) x < 0\\<rbrakk>\n    \\<Longrightarrow> z I sign = - 1", "using welldefined"], ["proof (prove)\nusing this:\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> list_constr I (length qs); z I sign \\<noteq> 1;\n     poly (prod_list (retrieve_polys qs I)) x < 0\\<rbrakk>\n    \\<Longrightarrow> z I sign = - 1", "by blast"], ["proof (state)\nthis:\n  (poly (prod_list (retrieve_polys qs I)) x < 0) = (z I sign = - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Recharacterize the dot product *)"], ["", "lemma vec_of_list_dot_rewrite:\n  assumes \"length xs = length ys\"\n  shows \"vec_of_list xs \\<bullet> vec_of_list ys =\n    sum_list (map2 (*) xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list xs \\<bullet> vec_of_list ys = sum_list (map2 (*) xs ys)", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. vec_of_list xs \\<bullet> vec_of_list ys = sum_list (map2 (*) xs ys)", "proof (induction xs arbitrary:ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       length [] = length ys \\<Longrightarrow>\n       vec_of_list [] \\<bullet> vec_of_list ys = sum_list (map2 (*) [] ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs = length ys \\<Longrightarrow>\n                   vec_of_list xs \\<bullet> vec_of_list ys =\n                   sum_list (map2 (*) xs ys);\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> vec_of_list (a # xs) \\<bullet> vec_of_list ys =\n                         sum_list (map2 (*) (a # xs) ys)", "case Nil"], ["proof (state)\nthis:\n  length [] = length ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       length [] = length ys \\<Longrightarrow>\n       vec_of_list [] \\<bullet> vec_of_list ys = sum_list (map2 (*) [] ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs = length ys \\<Longrightarrow>\n                   vec_of_list xs \\<bullet> vec_of_list ys =\n                   sum_list (map2 (*) xs ys);\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> vec_of_list (a # xs) \\<bullet> vec_of_list ys =\n                         sum_list (map2 (*) (a # xs) ys)", "then"], ["proof (chain)\npicking this:\n  length [] = length ys", "show ?case"], ["proof (prove)\nusing this:\n  length [] = length ys\n\ngoal (1 subgoal):\n 1. vec_of_list [] \\<bullet> vec_of_list ys = sum_list (map2 (*) [] ys)", "by auto"], ["proof (state)\nthis:\n  vec_of_list [] \\<bullet> vec_of_list ys = sum_list (map2 (*) [] ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs = length ys \\<Longrightarrow>\n                   vec_of_list xs \\<bullet> vec_of_list ys =\n                   sum_list (map2 (*) xs ys);\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> vec_of_list (a # xs) \\<bullet> vec_of_list ys =\n                         sum_list (map2 (*) (a # xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs = length ys \\<Longrightarrow>\n                   vec_of_list xs \\<bullet> vec_of_list ys =\n                   sum_list (map2 (*) xs ys);\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> vec_of_list (a # xs) \\<bullet> vec_of_list ys =\n                         sum_list (map2 (*) (a # xs) ys)", "case (Cons a xs)"], ["proof (state)\nthis:\n  length xs = length ?ys \\<Longrightarrow>\n  vec_of_list xs \\<bullet> vec_of_list ?ys = sum_list (map2 (*) xs ?ys)\n  length (a # xs) = length ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs = length ys \\<Longrightarrow>\n                   vec_of_list xs \\<bullet> vec_of_list ys =\n                   sum_list (map2 (*) xs ys);\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> vec_of_list (a # xs) \\<bullet> vec_of_list ys =\n                         sum_list (map2 (*) (a # xs) ys)", "then"], ["proof (chain)\npicking this:\n  length xs = length ?ys \\<Longrightarrow>\n  vec_of_list xs \\<bullet> vec_of_list ?ys = sum_list (map2 (*) xs ?ys)\n  length (a # xs) = length ys", "show ?case"], ["proof (prove)\nusing this:\n  length xs = length ?ys \\<Longrightarrow>\n  vec_of_list xs \\<bullet> vec_of_list ?ys = sum_list (map2 (*) xs ?ys)\n  length (a # xs) = length ys\n\ngoal (1 subgoal):\n 1. vec_of_list (a # xs) \\<bullet> vec_of_list ys =\n    sum_list (map2 (*) (a # xs) ys)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys.\n                length xs = length ys \\<Longrightarrow>\n                vec_of_list xs \\<bullet> vec_of_list ys =\n                sum_list (map2 (*) xs ys);\n     Suc (length xs) = length ys\\<rbrakk>\n    \\<Longrightarrow> vCons a (vec_of_list xs) \\<bullet> vec_of_list ys =\n                      sum_list (map2 (*) (a # xs) ys)", "by (smt (verit, best) Suc_length_conv list.simps(9) old.prod.case scalar_prod_vCons sum_list.Cons vec_of_list_Cons zip_Cons_Cons)"], ["proof (state)\nthis:\n  vec_of_list (a # xs) \\<bullet> vec_of_list ys =\n  sum_list (map2 (*) (a # xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lhs_dot_rewrite:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  shows\n    \"(vec_of_list (mtx_row signs I) \\<bullet> (construct_lhs_vector p qs signs)) =\n   sum_list (map (\\<lambda>s. (z I s)  *  rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) signs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "have \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using nonzero"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "from construct_lhs_vector_cleaner[OF this]"], ["proof (chain)\npicking this:\n  construct_lhs_vector p ?qs ?signs =\n  vec_of_list\n   (map (\\<lambda>s.\n            rat_of_int\n             (int (card\n                    {x. poly p x = 0 \\<and>\n                        consistent_sign_vec_copr ?qs x = s})))\n     ?signs)", "have rhseq: \"construct_lhs_vector p qs signs =\n    vec_of_list\n    (map (\\<lambda>s. rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) signs)\""], ["proof (prove)\nusing this:\n  construct_lhs_vector p ?qs ?signs =\n  vec_of_list\n   (map (\\<lambda>s.\n            rat_of_int\n             (int (card\n                    {x. poly p x = 0 \\<and>\n                        consistent_sign_vec_copr ?qs x = s})))\n     ?signs)\n\ngoal (1 subgoal):\n 1. construct_lhs_vector p qs signs =\n    vec_of_list\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec_copr qs x = s})))\n       signs)", "by auto"], ["proof (state)\nthis:\n  construct_lhs_vector p qs signs =\n  vec_of_list\n   (map (\\<lambda>s.\n            rat_of_int\n             (int (card\n                    {x. poly p x = 0 \\<and>\n                        consistent_sign_vec_copr qs x = s})))\n     signs)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "have \"(vec_of_list (mtx_row signs I) \\<bullet> (construct_lhs_vector p qs signs)) =    \n    sum_list (map2 (*) (mtx_row signs I) (map (\\<lambda>s. rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) signs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    sum_list\n     (map2 (*) (mtx_row signs I)\n       (map (\\<lambda>s.\n                rat_of_int\n                 (int (card\n                        {x. poly p x = 0 \\<and>\n                            consistent_sign_vec_copr qs x = s})))\n         signs))", "unfolding rhseq"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    vec_of_list\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec_copr qs x = s})))\n       signs) =\n    sum_list\n     (map2 (*) (mtx_row signs I)\n       (map (\\<lambda>s.\n                rat_of_int\n                 (int (card\n                        {x. poly p x = 0 \\<and>\n                            consistent_sign_vec_copr qs x = s})))\n         signs))", "apply (intro vec_of_list_dot_rewrite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mtx_row signs I) =\n    length\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec_copr qs x = s})))\n       signs)", "by (auto simp add: mtx_row_def)"], ["proof (state)\nthis:\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  sum_list\n   (map2 (*) (mtx_row signs I)\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec_copr qs x = s})))\n       signs))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "thus ?thesis"], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  sum_list\n   (map2 (*) (mtx_row signs I)\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec_copr qs x = s})))\n       signs))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "unfolding mtx_row_def"], ["proof (prove)\nusing this:\n  vec_of_list (map (z I) signs) \\<bullet> construct_lhs_vector p qs signs =\n  sum_list\n   (map2 (*) (map (z I) signs)\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec_copr qs x = s})))\n       signs))\n\ngoal (1 subgoal):\n 1. vec_of_list (map (z I) signs) \\<bullet>\n    construct_lhs_vector p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "using map2_map_map"], ["proof (prove)\nusing this:\n  vec_of_list (map (z I) signs) \\<bullet> construct_lhs_vector p qs signs =\n  sum_list\n   (map2 (*) (map (z I) signs)\n     (map (\\<lambda>s.\n              rat_of_int\n               (int (card\n                      {x. poly p x = 0 \\<and>\n                          consistent_sign_vec_copr qs x = s})))\n       signs))\n  map2 ?h (map ?f ?xs) (map ?g ?xs) = map (\\<lambda>x. ?h (?f x) (?g x)) ?xs\n\ngoal (1 subgoal):\n 1. vec_of_list (map (z I) signs) \\<bullet>\n    construct_lhs_vector p qs signs =\n    (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "by (auto simp add: map2_map_map)"], ["proof (state)\nthis:\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  (\\<Sum>s\\<leftarrow>signs. z I s *\n                             rat_of_int\n                              (int (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_distinct_filter:\n  fixes f:: \"'a \\<Rightarrow> int\"\n  assumes \"distinct xs\" \"distinct ys\"\n  assumes \"set ys \\<subseteq> set xs\"\n  assumes \"\\<And>x. x \\<in> set xs - set ys \\<Longrightarrow> f x = 0\"\n  shows \"sum_list (map f xs) = sum_list (map f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f xs) = sum_list (map f ys)", "by (metis List.finite_set assms(1) assms(2) assms(3) assms(4) sum.mono_neutral_cong_left sum_list_distinct_conv_sum_set)"], ["", "(* If we have a superset of the signs, we can drop to just the consistent ones *)"], ["", "lemma construct_lhs_vector_drop_consistent:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots_copr p qs) \\<subseteq> set(signs)\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  shows\n    \"(vec_of_list (mtx_row signs I) \\<bullet> (construct_lhs_vector p qs signs)) =\n     (vec_of_list (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n      (construct_lhs_vector p qs (characterize_consistent_signs_at_roots_copr p qs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "have h0: \"\\<forall> sgn. sgn \\<in> set signs \\<and> sgn \\<notin> consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<and> 0 < rat_of_nat (card\n                  {xa. poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow> z I sgn = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "have \"\\<forall> sgn. sgn \\<in> set signs \\<and> sgn \\<notin> consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<and> 0 < rat_of_int (card\n                  {xa. poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow> {xa. poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {}", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_int\n          (int (card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec_copr qs xa = sgn})) \\<longrightarrow>\n     {xa.\n      poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n     {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_int\n          (int (card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec_copr qs xa = sgn})) \\<longrightarrow>\n     {xa.\n      poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n     {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_int\n          (int (card\n                 {xa.\n                  poly p xa = 0 \\<and>\n                  consistent_sign_vec_copr qs xa = sgn})) \\<longrightarrow>\n     {xa.\n      poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n     {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "fix iis :: \"rat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "have ff1: \"0 \\<noteq> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> p", "using nonzero rsquarefree_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  rsquarefree ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>a. Polynomial.order a ?p = 0 \\<or> Polynomial.order a ?p = 1))\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> p", "by blast"], ["proof (state)\nthis:\n  0 \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "obtain rr :: \"(real \\<Rightarrow> bool) \\<Rightarrow> real\" where\n          ff2: \"\\<And>p. p (rr p) \\<or> Collect p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rr.\n        (\\<And>p. p (rr p) \\<or> Collect p = {}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  ?p (rr ?p) \\<or> Collect ?p = {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "{"], ["proof (state)\nthis:\n  ?p (rr ?p) \\<or> Collect ?p = {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "assume \"\\<exists>is. is = iis \\<and> {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq> {}", "have \"\\<exists>is. consistent_sign_vec_copr qs (rr (\\<lambda>r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is)) = iis \\<and> {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>is.\n       consistent_sign_vec_copr qs\n        (rr (\\<lambda>r.\n                poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is)) =\n       iis \\<and>\n       {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq>\n       {}", "using ff2"], ["proof (prove)\nusing this:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq> {}\n  ?p (rr ?p) \\<or> Collect ?p = {}\n\ngoal (1 subgoal):\n 1. \\<exists>is.\n       consistent_sign_vec_copr qs\n        (rr (\\<lambda>r.\n                poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is)) =\n       iis \\<and>\n       {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq>\n       {}", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  \\<exists>is.\n     consistent_sign_vec_copr qs\n      (rr (\\<lambda>r.\n              poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is)) =\n     iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>is.\n     consistent_sign_vec_copr qs\n      (rr (\\<lambda>r.\n              poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is)) =\n     iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq> {}", "have \"\\<exists>r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = iis\""], ["proof (prove)\nusing this:\n  \\<exists>is.\n     consistent_sign_vec_copr qs\n      (rr (\\<lambda>r.\n              poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is)) =\n     iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = iis", "using ff2"], ["proof (prove)\nusing this:\n  \\<exists>is.\n     consistent_sign_vec_copr qs\n      (rr (\\<lambda>r.\n              poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is)) =\n     iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq> {}\n  ?p (rr ?p) \\<or> Collect ?p = {}\n\ngoal (1 subgoal):\n 1. \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = iis", "by smt"], ["proof (state)\nthis:\n  \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = iis\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = iis", "have \"iis \\<in> consistent_sign_vec_copr qs ` set (sorted_list_of_set {r. poly p r = 0})\""], ["proof (prove)\nusing this:\n  \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = iis\n\ngoal (1 subgoal):\n 1. iis\n    \\<in> consistent_sign_vec_copr qs `\n          set (sorted_list_of_set {r. poly p r = 0})", "using ff1 poly_roots_finite"], ["proof (prove)\nusing this:\n  \\<exists>r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = iis\n  0 \\<noteq> p\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. iis\n    \\<in> consistent_sign_vec_copr qs `\n          set (sorted_list_of_set {r. poly p r = 0})", "by fastforce"], ["proof (state)\nthis:\n  iis\n  \\<in> consistent_sign_vec_copr qs `\n        set (sorted_list_of_set {r. poly p r = 0})\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "}"], ["proof (state)\nthis:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq>\n     {} \\<Longrightarrow>\n  iis\n  \\<in> consistent_sign_vec_copr qs `\n        set (sorted_list_of_set {r. poly p r = 0})\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq>\n     {} \\<Longrightarrow>\n  iis\n  \\<in> consistent_sign_vec_copr qs `\n        set (sorted_list_of_set {r. poly p r = 0})", "have \"iis \\<notin> set signs \\<or> iis \\<in> consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<or> \\<not> 0 < rat_of_int (int (card {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = iis}))\""], ["proof (prove)\nusing this:\n  \\<exists>is.\n     is = iis \\<and>\n     {r. poly p r = 0 \\<and> consistent_sign_vec_copr qs r = is} \\<noteq>\n     {} \\<Longrightarrow>\n  iis\n  \\<in> consistent_sign_vec_copr qs `\n        set (sorted_list_of_set {r. poly p r = 0})\n\ngoal (1 subgoal):\n 1. iis \\<notin> set signs \\<or>\n    iis\n    \\<in> consistent_sign_vec_copr qs `\n          set (characterize_root_list_p p) \\<or>\n    \\<not> 0 < rat_of_int\n                (int (card\n                       {r. poly p r = 0 \\<and>\n                           consistent_sign_vec_copr qs r = iis}))", "by (metis (no_types) \\<open>\\<forall>sgn. sgn \\<in> set signs \\<and> sgn \\<notin> consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<and> 0 < rat_of_int (int (card {xa. poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn})) \\<longrightarrow> {xa. poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq> {}\\<close> characterize_root_list_p_def)"], ["proof (state)\nthis:\n  iis \\<notin> set signs \\<or>\n  iis\n  \\<in> consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<or>\n  \\<not> 0 < rat_of_int\n              (int (card\n                     {r. poly p r = 0 \\<and>\n                         consistent_sign_vec_copr qs r = iis}))\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "}"], ["proof (state)\nthis:\n  ?iis2 \\<notin> set signs \\<or>\n  ?iis2\n  \\<in> consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<or>\n  \\<not> 0 < rat_of_int\n              (int (card\n                     {r. poly p r = 0 \\<and>\n                         consistent_sign_vec_copr qs r = ?iis2}))\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_int\n            (int (card\n                   {xa.\n                    poly p xa = 0 \\<and>\n                    consistent_sign_vec_copr qs xa =\n                    sgn})) \\<longrightarrow>\n       {xa.\n        poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn} \\<noteq>\n       {} \\<Longrightarrow>\n    \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "then"], ["proof (chain)\npicking this:\n  ?iis2 \\<notin> set signs \\<or>\n  ?iis2\n  \\<in> consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<or>\n  \\<not> 0 < rat_of_int\n              (int (card\n                     {r. poly p r = 0 \\<and>\n                         consistent_sign_vec_copr qs r = ?iis2}))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?iis2 \\<notin> set signs \\<or>\n  ?iis2\n  \\<in> consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<or>\n  \\<not> 0 < rat_of_int\n              (int (card\n                     {r. poly p r = 0 \\<and>\n                         consistent_sign_vec_copr qs r = ?iis2}))\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<and>\n       0 < rat_of_nat\n            (card\n              {xa.\n               poly p xa = 0 \\<and>\n               consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n       z I sgn = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_nat\n          (card\n            {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n     z I sgn = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_nat\n          (card\n            {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n     z I sgn = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_nat\n          (card\n            {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n     z I sgn = 0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_nat\n          (card\n            {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n     z I sgn = 0", "have \"\\<forall> sgn. sgn \\<in> set signs \\<and> sgn \\<notin> consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<longrightarrow> ((0 = rat_of_nat (card\n                  {xa. poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn}) \\<or> z I sgn = 0))\""], ["proof (prove)\nusing this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<and>\n     0 < rat_of_nat\n          (card\n            {xa.\n             poly p xa = 0 \\<and>\n             consistent_sign_vec_copr qs xa = sgn}) \\<longrightarrow>\n     z I sgn = 0\n\ngoal (1 subgoal):\n 1. \\<forall>sgn.\n       sgn \\<in> set signs \\<and>\n       sgn\n       \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<longrightarrow>\n       0 =\n       rat_of_nat\n        (card\n          {xa.\n           poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn}) \\<or>\n       z I sgn = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<longrightarrow>\n     0 =\n     rat_of_nat\n      (card\n        {xa.\n         poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn}) \\<or>\n     z I sgn = 0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<longrightarrow>\n     0 =\n     rat_of_nat\n      (card\n        {xa.\n         poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn}) \\<or>\n     z I sgn = 0", "have hyp: \"\\<forall> s. s \\<in> set signs \\<and> s \\<notin> consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<longrightarrow> (z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) = 0)\""], ["proof (prove)\nusing this:\n  \\<forall>sgn.\n     sgn \\<in> set signs \\<and>\n     sgn\n     \\<notin> consistent_sign_vec_copr qs `\n              set (characterize_root_list_p p) \\<longrightarrow>\n     0 =\n     rat_of_nat\n      (card\n        {xa.\n         poly p xa = 0 \\<and> consistent_sign_vec_copr qs xa = sgn}) \\<or>\n     z I sgn = 0\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec_copr qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n       0", "by auto"], ["proof (state)\nthis:\n  \\<forall>s.\n     s \\<in> set signs \\<and>\n     s \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<longrightarrow>\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n     0\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>s.\n     s \\<in> set signs \\<and>\n     s \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<longrightarrow>\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n     0", "have \"(\\<Sum>s\\<in> set(signs). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) = \n        (\\<Sum>s\\<in>(set (signs) \\<inter> (consistent_sign_vec_copr qs ` set (characterize_root_list_p p))). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\nusing this:\n  \\<forall>s.\n     s \\<in> set signs \\<and>\n     s \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<longrightarrow>\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n     0\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec_copr qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n       0 \\<Longrightarrow>\n    (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "have \"set(signs) =(set (signs) \\<inter> (consistent_sign_vec_copr qs ` set (characterize_root_list_p p))) \\<union>\n              (set(signs)-(consistent_sign_vec_copr qs ` set (characterize_root_list_p p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set signs =\n    set signs \\<inter>\n    consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<union>\n    (set signs -\n     consistent_sign_vec_copr qs ` set (characterize_root_list_p p))", "by blast"], ["proof (state)\nthis:\n  set signs =\n  set signs \\<inter>\n  consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<union>\n  (set signs -\n   consistent_sign_vec_copr qs ` set (characterize_root_list_p p))\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec_copr qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n       0 \\<Longrightarrow>\n    (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "then"], ["proof (chain)\npicking this:\n  set signs =\n  set signs \\<inter>\n  consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<union>\n  (set signs -\n   consistent_sign_vec_copr qs ` set (characterize_root_list_p p))", "have sum_rewrite: \"(\\<Sum>s\\<in> set(signs). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =  \n          (\\<Sum>s\\<in> (set (signs) \\<inter> (consistent_sign_vec_copr qs ` set (characterize_root_list_p p))) \\<union>\n              (set(signs)-(consistent_sign_vec_copr qs ` set (characterize_root_list_p p))). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\nusing this:\n  set signs =\n  set signs \\<inter>\n  consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<union>\n  (set signs -\n   consistent_sign_vec_copr qs ` set (characterize_root_list_p p))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p) \\<union>\n                 (set signs -\n                  consistent_sign_vec_copr qs `\n                  set (characterize_root_list_p p)).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p)).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec_copr qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n       0 \\<Longrightarrow>\n    (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p)).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "have sum_split: \"(\\<Sum>s\\<in> (set (signs) \\<inter> (consistent_sign_vec_copr qs ` set (characterize_root_list_p p))) \\<union>\n              (set(signs)-(consistent_sign_vec_copr qs ` set (characterize_root_list_p p))). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n          = \n(\\<Sum>s\\<in> (set (signs) \\<inter> (consistent_sign_vec_copr qs ` set (characterize_root_list_p p))). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n+ (\\<Sum>s\\<in> (set(signs)-(consistent_sign_vec_copr qs ` set (characterize_root_list_p p))). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p)).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p) \\<union>\n                 (set signs -\n                  consistent_sign_vec_copr qs `\n                  set (characterize_root_list_p p)).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) +\n    (\\<Sum>s\\<in>set signs -\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "by (metis (no_types, lifting) List.finite_set sum.Int_Diff)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p)).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) +\n  (\\<Sum>s\\<in>set signs -\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec_copr qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n       0 \\<Longrightarrow>\n    (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "have sum_zero: \"(\\<Sum>s\\<in> (set(signs)-(consistent_sign_vec_copr qs ` set (characterize_root_list_p p))). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs -\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    0", "using hyp"], ["proof (prove)\nusing this:\n  \\<forall>s.\n     s \\<in> set signs \\<and>\n     s \\<notin> consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p) \\<longrightarrow>\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n     0\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs -\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    0", "by (simp add: hyp)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs -\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  0\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> set signs \\<and>\n       s \\<notin> consistent_sign_vec_copr qs `\n                  set (characterize_root_list_p p) \\<longrightarrow>\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n       0 \\<Longrightarrow>\n    (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "using sum_rewrite sum_split sum_zero"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p)).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p) \\<union>\n               (set signs -\n                consistent_sign_vec_copr qs `\n                set (characterize_root_list_p p)).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) +\n  (\\<Sum>s\\<in>set signs -\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  (\\<Sum>s\\<in>set signs -\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "have set_eq: \"set (remdups\n           (map (consistent_sign_vec_copr qs)\n             (characterize_root_list_p p))) = set (signs) \\<inter> (consistent_sign_vec_copr qs ` set (characterize_root_list_p p))\""], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. set (remdups\n          (map (consistent_sign_vec_copr qs)\n            (characterize_root_list_p p))) =\n    set signs \\<inter>\n    consistent_sign_vec_copr qs ` set (characterize_root_list_p p)", "using all_info"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  set (characterize_consistent_signs_at_roots_copr p qs)\n  \\<subseteq> set signs\n\ngoal (1 subgoal):\n 1. set (remdups\n          (map (consistent_sign_vec_copr qs)\n            (characterize_root_list_p p))) =\n    set signs \\<inter>\n    consistent_sign_vec_copr qs ` set (characterize_root_list_p p)", "by (simp add: characterize_consistent_signs_at_roots_copr_def subset_antisym)"], ["proof (state)\nthis:\n  set (remdups\n        (map (consistent_sign_vec_copr qs) (characterize_root_list_p p))) =\n  set signs \\<inter>\n  consistent_sign_vec_copr qs ` set (characterize_root_list_p p)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "have hyp1: \"(\\<Sum>s\\<leftarrow>signs. z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) = \n        (\\<Sum>s\\<in>set (signs). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "using distinct_signs sum_list_distinct_conv_sum_set"], ["proof (prove)\nusing this:\n  distinct signs\n  distinct ?xs \\<Longrightarrow> sum_list (map ?f ?xs) = sum ?f (set ?xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set signs.\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>s\\<leftarrow>signs. z I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "have hyp2: \"(\\<Sum>s\\<leftarrow>remdups\n           (map (consistent_sign_vec_copr qs)\n             (characterize_root_list_p p)). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  = (\\<Sum>s\\<in> set (remdups\n           (map (consistent_sign_vec_copr qs)\n             (characterize_root_list_p p))). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec_copr qs)\n                           (characterize_root_list_p\n                             p)). z I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set (remdups\n                       (map (consistent_sign_vec_copr qs)\n                         (characterize_root_list_p p))).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "using sum_list_distinct_conv_sum_set"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow> sum_list (map ?f ?xs) = sum ?f (set ?xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec_copr qs)\n                           (characterize_root_list_p\n                             p)). z I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set (remdups\n                       (map (consistent_sign_vec_copr qs)\n                         (characterize_root_list_p p))).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec_copr qs)\n                         (characterize_root_list_p\n                           p)). z I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p))).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "have set_sum_eq: \"(\\<Sum>s\\<in>(set (signs) \\<inter> (consistent_sign_vec_copr qs ` set (characterize_root_list_p p))). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in> set (remdups\n           (map (consistent_sign_vec_copr qs)\n             (characterize_root_list_p p))). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set (remdups\n                       (map (consistent_sign_vec_copr qs)\n                         (characterize_root_list_p p))).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "using set_eq"], ["proof (prove)\nusing this:\n  set (remdups\n        (map (consistent_sign_vec_copr qs) (characterize_root_list_p p))) =\n  set signs \\<inter>\n  consistent_sign_vec_copr qs ` set (characterize_root_list_p p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set signs \\<inter>\n                 consistent_sign_vec_copr qs `\n                 set (characterize_root_list_p p).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<in>set (remdups\n                       (map (consistent_sign_vec_copr qs)\n                         (characterize_root_list_p p))).\n       z I s *\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p))).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p))).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "have \"(\\<Sum>s\\<leftarrow>signs. z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n           (map (consistent_sign_vec_copr qs)\n             (characterize_root_list_p p)). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p))).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec_copr qs)\n                           (characterize_root_list_p\n                             p)). z I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "using set_sum_eq hyp1 hyp2"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p))).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p))).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  (\\<Sum>s\\<leftarrow>signs. z I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec_copr qs)\n                         (characterize_root_list_p\n                           p)). z I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p))).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec_copr qs)\n                           (characterize_root_list_p\n                             p)). z I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "using \\<open>(\\<Sum>s\\<in>set signs. z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) = (\\<Sum>s\\<in>set signs \\<inter> consistent_sign_vec_copr qs ` set (characterize_root_list_p p). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p))).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p))).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  (\\<Sum>s\\<leftarrow>signs. z I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec_copr qs)\n                         (characterize_root_list_p\n                           p)). z I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set (remdups\n                     (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p))).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n  (\\<Sum>s\\<in>set signs.\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<in>set signs \\<inter>\n               consistent_sign_vec_copr qs `\n               set (characterize_root_list_p p).\n     z I s *\n     rat_of_nat\n      (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec_copr qs)\n                           (characterize_root_list_p\n                             p)). z I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>s\\<leftarrow>signs. z I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec_copr qs)\n                         (characterize_root_list_p\n                           p)). z I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<leftarrow>signs. z I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec_copr qs)\n                         (characterize_root_list_p\n                           p)). z I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s}))", "have \"consistent_sign_vec_copr qs ` set (characterize_root_list_p p) \\<subseteq> set signs \\<Longrightarrow>\n    (\\<And>p qss.\n        characterize_consistent_signs_at_roots_copr p qss =\n        remdups (map (consistent_sign_vec_copr qss) (characterize_root_list_p p))) \\<Longrightarrow>\n    (\\<Sum>s\\<leftarrow>signs. z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n           (map (consistent_sign_vec_copr qs)\n             (characterize_root_list_p p)). z I s * rat_of_nat (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<leftarrow>signs. z I s *\n                             rat_of_nat\n                              (card\n                                {x. poly p x = 0 \\<and>\n                                    consistent_sign_vec_copr qs x = s})) =\n  (\\<Sum>s\\<leftarrow>remdups\n                       (map (consistent_sign_vec_copr qs)\n                         (characterize_root_list_p\n                           p)). z I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent_sign_vec_copr qs ` set (characterize_root_list_p p)\n             \\<subseteq> set signs;\n     \\<And>p qss.\n        characterize_consistent_signs_at_roots_copr p qss =\n        remdups\n         (map (consistent_sign_vec_copr qss)\n           (characterize_root_list_p p))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z I s *\n           rat_of_nat\n            (card\n              {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n                      (\\<Sum>s\\<leftarrow>remdups\n     (map (consistent_sign_vec_copr qs)\n       (characterize_root_list_p\n         p)). z I s *\n              rat_of_nat\n               (card\n                 {x. poly p x = 0 \\<and>\n                     consistent_sign_vec_copr qs x = s}))", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>consistent_sign_vec_copr qs ` set (characterize_root_list_p p)\n           \\<subseteq> set signs;\n   \\<And>p qss.\n      characterize_consistent_signs_at_roots_copr p qss =\n      remdups\n       (map (consistent_sign_vec_copr qss)\n         (characterize_root_list_p p))\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z I s *\n         rat_of_nat\n          (card\n            {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n                    (\\<Sum>s\\<leftarrow>remdups\n   (map (consistent_sign_vec_copr qs)\n     (characterize_root_list_p\n       p)). z I s *\n            rat_of_nat\n             (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>consistent_sign_vec_copr qs ` set (characterize_root_list_p p)\n           \\<subseteq> set signs;\n   \\<And>p qss.\n      characterize_consistent_signs_at_roots_copr p qss =\n      remdups\n       (map (consistent_sign_vec_copr qss)\n         (characterize_root_list_p p))\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z I s *\n         rat_of_nat\n          (card\n            {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n                    (\\<Sum>s\\<leftarrow>remdups\n   (map (consistent_sign_vec_copr qs)\n     (characterize_root_list_p\n       p)). z I s *\n            rat_of_nat\n             (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>consistent_sign_vec_copr qs ` set (characterize_root_list_p p)\n           \\<subseteq> set signs;\n   \\<And>p qss.\n      characterize_consistent_signs_at_roots_copr p qss =\n      remdups\n       (map (consistent_sign_vec_copr qss)\n         (characterize_root_list_p p))\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z I s *\n         rat_of_nat\n          (card\n            {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n                    (\\<Sum>s\\<leftarrow>remdups\n   (map (consistent_sign_vec_copr qs)\n     (characterize_root_list_p\n       p)). z I s *\n            rat_of_nat\n             (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "unfolding lhs_dot_rewrite[OF nonzero]"], ["proof (prove)\nusing this:\n  \\<lbrakk>consistent_sign_vec_copr qs ` set (characterize_root_list_p p)\n           \\<subseteq> set signs;\n   \\<And>p qss.\n      characterize_consistent_signs_at_roots_copr p qss =\n      remdups\n       (map (consistent_sign_vec_copr qss)\n         (characterize_root_list_p p))\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>s\\<leftarrow>signs. z I s *\n         rat_of_nat\n          (card\n            {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n                    (\\<Sum>s\\<leftarrow>remdups\n   (map (consistent_sign_vec_copr qs)\n     (characterize_root_list_p\n       p)). z I s *\n            rat_of_nat\n             (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_int\n                                (int (card\n {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n    (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                         qs. z I s *\n                             rat_of_int\n                              (int (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "apply (auto intro!: sum_list_distinct_filter simp add: distinct_signs  characterize_consistent_signs_at_roots_copr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (consistent_sign_vec_copr qs ` set (characterize_root_list_p p)\n     \\<subseteq> set signs \\<Longrightarrow>\n     (\\<Sum>s\\<leftarrow>signs. z I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s})) =\n     (\\<Sum>s\\<leftarrow>remdups\n                          (map (consistent_sign_vec_copr qs)\n                            (characterize_root_list_p\n                              p)). z I s *\n                                   rat_of_nat\n                                    (card\n{x. poly p x = 0 \\<and>\n    consistent_sign_vec_copr qs x = s}))) \\<Longrightarrow>\n    (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec_copr qs)\n                           (characterize_root_list_p\n                             p)). z I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "using all_info characterize_consistent_signs_at_roots_copr_def"], ["proof (prove)\nusing this:\n  set (characterize_consistent_signs_at_roots_copr p qs)\n  \\<subseteq> set signs\n  characterize_consistent_signs_at_roots_copr ?p ?qss =\n  remdups\n   (map (consistent_sign_vec_copr ?qss) (characterize_root_list_p ?p))\n\ngoal (1 subgoal):\n 1. (consistent_sign_vec_copr qs ` set (characterize_root_list_p p)\n     \\<subseteq> set signs \\<Longrightarrow>\n     (\\<Sum>s\\<leftarrow>signs. z I s *\n                                rat_of_nat\n                                 (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s})) =\n     (\\<Sum>s\\<leftarrow>remdups\n                          (map (consistent_sign_vec_copr qs)\n                            (characterize_root_list_p\n                              p)). z I s *\n                                   rat_of_nat\n                                    (card\n{x. poly p x = 0 \\<and>\n    consistent_sign_vec_copr qs x = s}))) \\<Longrightarrow>\n    (\\<Sum>s\\<leftarrow>signs. z I s *\n                               rat_of_nat\n                                (card\n                                  {x. poly p x = 0 \\<and>\nconsistent_sign_vec_copr qs x = s})) =\n    (\\<Sum>s\\<leftarrow>remdups\n                         (map (consistent_sign_vec_copr qs)\n                           (characterize_root_list_p\n                             p)). z I s *\n                                  rat_of_nat\n                                   (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))", "by auto[1]"], ["proof (state)\nthis:\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Both matrix_equation_helper_step and matrix_equation_main_step relate the matrix construction \n   to the Tarski queries, i.e. relate the product of a row of the matrix and the LHS vector to a \n   Tarski query on the RHS *)"], ["", "lemma matrix_equation_helper_step:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots_copr p qs) \\<subseteq> set(signs)\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  shows \"(vec_of_list (mtx_row signs I) \\<bullet> (construct_lhs_vector p qs signs)) =\n   rat_of_int (card {x. poly p x = 0 \\<and> poly (prod_list (retrieve_polys qs I)) x > 0}) -\n   rat_of_int (card {x. poly p x = 0 \\<and> poly (prod_list (retrieve_polys qs I)) x < 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have \"finite (set (map (consistent_sign_vec_copr qs)  (characterize_root_list_p p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)))", "by auto"], ["proof (state)\nthis:\n  finite\n   (set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "let ?gt = \"(set (map (consistent_sign_vec_copr qs)  (characterize_root_list_p p)) \\<inter> {s. z I s = 1})\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "let ?lt = \"  (set (map (consistent_sign_vec_copr qs)  (characterize_root_list_p p)) \\<inter> {s. z I s = -1})\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have eq: \"set (map (consistent_sign_vec_copr qs)  (characterize_root_list_p p)) = ?gt \\<union> ?lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)) =\n    set (map (consistent_sign_vec_copr qs)\n          (characterize_root_list_p p)) \\<inter>\n    {s. z I s = 1} \\<union>\n    set (map (consistent_sign_vec_copr qs)\n          (characterize_root_list_p p)) \\<inter>\n    {s. z I s = - 1}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (characterize_root_list_p p);\n        z I (consistent_sign_vec_copr qs xa) \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> z I (consistent_sign_vec_copr qs xa) = 1", "by (metis characterize_root_list_p_def horiz_vector_helper_neg horiz_vector_helper_pos_ind nonzero nonzero_product pairwise_rel_prime_1 poly_roots_finite sorted_list_of_set(1) welldefined)"], ["proof (state)\nthis:\n  set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)) =\n  set (map (consistent_sign_vec_copr qs)\n        (characterize_root_list_p p)) \\<inter>\n  {s. z I s = 1} \\<union>\n  set (map (consistent_sign_vec_copr qs)\n        (characterize_root_list_p p)) \\<inter>\n  {s. z I s = - 1}\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "(* First, drop the signs that are irrelevant *)"], ["proof (state)\nthis:\n  set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)) =\n  set (map (consistent_sign_vec_copr qs)\n        (characterize_root_list_p p)) \\<inter>\n  {s. z I s = 1} \\<union>\n  set (map (consistent_sign_vec_copr qs)\n        (characterize_root_list_p p)) \\<inter>\n  {s. z I s = - 1}\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "from construct_lhs_vector_drop_consistent[OF assms(1-4)]"], ["proof (chain)\npicking this:\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs)", "have\n    \"vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  vec_of_list (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs (characterize_consistent_signs_at_roots_copr p qs)\""], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs)", "."], ["proof (state)\nthis:\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "(* Now we split the sum *)"], ["proof (state)\nthis:\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "from lhs_dot_rewrite[OF assms(1)]"], ["proof (chain)\npicking this:\n  vec_of_list (mtx_row ?signs ?I) \\<bullet>\n  construct_lhs_vector p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr ?qs x = s})))", "moreover"], ["proof (chain)\npicking this:\n  vec_of_list (mtx_row ?signs ?I) \\<bullet>\n  construct_lhs_vector p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr ?qs x = s})))", "have \"... =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p qs.\n    z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row ?signs ?I) \\<bullet>\n  construct_lhs_vector p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr ?qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n       I) \\<bullet>\n    construct_lhs_vector p qs\n     (characterize_consistent_signs_at_roots_copr p qs) =\n    (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                         qs. z I s *\n                             rat_of_int\n                              (int (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "."], ["proof (state)\nthis:\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                       qs. z I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "moreover"], ["proof (state)\nthis:\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                       qs. z I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have \"... =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)  (characterize_root_list_p p)).\n    z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                         qs. z I s *\n                             rat_of_int\n                              (int (card\n                                     {x.\npoly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p)).\n       z I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "unfolding characterize_consistent_signs_at_roots_copr_def sum_code[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p)).\n       z I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and>\n                   consistent_sign_vec_copr qs x = s}))) =\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p)).\n       z I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "by (auto)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                       qs. z I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)).\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "ultimately"], ["proof (chain)\npicking this:\n  vec_of_list (mtx_row ?signs ?I) \\<bullet>\n  construct_lhs_vector p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr ?qs x = s})))\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                       qs. z I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s})))\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                       qs. z I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)).\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "have \"... =\n  (\\<Sum>s\\<in>?gt. z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) +\n  (\\<Sum>s\\<in>?lt. z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\""], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row ?signs ?I) \\<bullet>\n  construct_lhs_vector p ?qs ?signs =\n  (\\<Sum>s\\<leftarrow>?signs. z ?I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr ?qs x = s})))\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                       qs. z I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s})))\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                       qs. z I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)).\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p)).\n       z I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and>\n                   consistent_sign_vec_copr qs x = s}))) =\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z I s = 1}.\n       z I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and>\n                   consistent_sign_vec_copr qs x = s}))) +\n    (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z I s = - 1}.\n       z I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))", "apply (subst eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>signs I qs.\n                vec_of_list (mtx_row signs I) \\<bullet>\n                construct_lhs_vector p qs signs =\n                (\\<Sum>s\\<leftarrow>signs. z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})));\n     vec_of_list\n      (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n        I) \\<bullet>\n     construct_lhs_vector p qs\n      (characterize_consistent_signs_at_roots_copr p qs) =\n     (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                          qs. z I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})));\n     (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                          qs. z I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n     (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                        (characterize_root_list_p p)).\n        z I s *\n        rat_of_int\n         (int (card\n                {x. poly p x = 0 \\<and>\n                    consistent_sign_vec_copr qs x = s})))\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n   (characterize_root_list_p p)) \\<inter>\n                                   {s. z I s = 1} \\<union>\n                                   set (map (consistent_sign_vec_copr qs)\n   (characterize_root_list_p p)) \\<inter>\n                                   {s. z I s = - 1}.\n                         z I s *\n                         rat_of_int\n                          (int (card\n                                 {x. poly p x = 0 \\<and>\n                                     consistent_sign_vec_copr qs x = s}))) =\n                      (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n   (characterize_root_list_p p)) \\<inter>\n                                   {s. z I s = 1}.\n                         z I s *\n                         rat_of_int\n                          (int (card\n                                 {x. poly p x = 0 \\<and>\n                                     consistent_sign_vec_copr qs x = s}))) +\n                      (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n   (characterize_root_list_p p)) \\<inter>\n                                   {s. z I s = - 1}.\n                         z I s *\n                         rat_of_int\n                          (int (card\n                                 {x. poly p x = 0 \\<and>\n                                     consistent_sign_vec_copr qs x = s})))", "apply (rule sum.union_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>signs I qs.\n                vec_of_list (mtx_row signs I) \\<bullet>\n                construct_lhs_vector p qs signs =\n                (\\<Sum>s\\<leftarrow>signs. z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})));\n     vec_of_list\n      (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n        I) \\<bullet>\n     construct_lhs_vector p qs\n      (characterize_consistent_signs_at_roots_copr p qs) =\n     (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                          qs. z I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})));\n     (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                          qs. z I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n     (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                        (characterize_root_list_p p)).\n        z I s *\n        rat_of_int\n         (int (card\n                {x. poly p x = 0 \\<and>\n                    consistent_sign_vec_copr qs x = s})))\\<rbrakk>\n    \\<Longrightarrow> finite\n                       (set (map (consistent_sign_vec_copr qs)\n                              (characterize_root_list_p p)) \\<inter>\n                        {s. z I s = 1})\n 2. \\<lbrakk>\\<And>signs I qs.\n                vec_of_list (mtx_row signs I) \\<bullet>\n                construct_lhs_vector p qs signs =\n                (\\<Sum>s\\<leftarrow>signs. z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})));\n     vec_of_list\n      (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n        I) \\<bullet>\n     construct_lhs_vector p qs\n      (characterize_consistent_signs_at_roots_copr p qs) =\n     (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                          qs. z I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})));\n     (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                          qs. z I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n     (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                        (characterize_root_list_p p)).\n        z I s *\n        rat_of_int\n         (int (card\n                {x. poly p x = 0 \\<and>\n                    consistent_sign_vec_copr qs x = s})))\\<rbrakk>\n    \\<Longrightarrow> finite\n                       (set (map (consistent_sign_vec_copr qs)\n                              (characterize_root_list_p p)) \\<inter>\n                        {s. z I s = - 1})\n 3. \\<lbrakk>\\<And>signs I qs.\n                vec_of_list (mtx_row signs I) \\<bullet>\n                construct_lhs_vector p qs signs =\n                (\\<Sum>s\\<leftarrow>signs. z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})));\n     vec_of_list\n      (mtx_row (characterize_consistent_signs_at_roots_copr p qs)\n        I) \\<bullet>\n     construct_lhs_vector p qs\n      (characterize_consistent_signs_at_roots_copr p qs) =\n     (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                          qs. z I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})));\n     (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                          qs. z I s *\n                              rat_of_int\n                               (int (card\n{x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n     (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                        (characterize_root_list_p p)).\n        z I s *\n        rat_of_int\n         (int (card\n                {x. poly p x = 0 \\<and>\n                    consistent_sign_vec_copr qs x = s})))\\<rbrakk>\n    \\<Longrightarrow> set (map (consistent_sign_vec_copr qs)\n                            (characterize_root_list_p p)) \\<inter>\n                      {s. z I s = 1} \\<inter>\n                      (set (map (consistent_sign_vec_copr qs)\n                             (characterize_root_list_p p)) \\<inter>\n                       {s. z I s = - 1}) =\n                      {}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)).\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = - 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "(* Now recharacterize lt, gt*)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)).\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = - 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have setroots: \"set (characterize_root_list_p p) = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (characterize_root_list_p p) = {x. poly p x = 0}", "unfolding characterize_root_list_p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sorted_list_of_set {x. poly p x = 0}) = {x. poly p x = 0}", "using poly_roots_finite nonzero rsquarefree_def set_sorted_list_of_set"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n  p \\<noteq> 0\n  rsquarefree ?p =\n  (?p \\<noteq> 0 \\<and>\n   (\\<forall>a. Polynomial.order a ?p = 0 \\<or> Polynomial.order a ?p = 1))\n  finite ?A \\<Longrightarrow> set (sorted_list_of_set ?A) = ?A\n\ngoal (1 subgoal):\n 1. set (sorted_list_of_set {x. poly p x = 0}) = {x. poly p x = 0}", "by blast"], ["proof (state)\nthis:\n  set (characterize_root_list_p p) = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have *: \"\\<And>s. {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s} =\n        {x \\<in>{x. poly p x = 0}. consistent_sign_vec_copr qs x = s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s} =\n       {x \\<in> {x. poly p x = 0}. consistent_sign_vec_copr qs x = s}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = ?s} =\n  {x \\<in> {x. poly p x = 0}. consistent_sign_vec_copr qs x = ?s}\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have lem_e1: \"\\<And>x. x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr  qs ` {x. poly p x = 0} \\<inter> {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "assume rt: \"x \\<in> {x. poly p x = 0}\""], ["proof (state)\nthis:\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  x \\<in> {x. poly p x = 0}", "have 1: \"{s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter> {s. z I s = 1}. consistent_sign_vec_copr qs x = s} =\n      {s. z I s = 1 \\<and> consistent_sign_vec_copr qs x = s}\""], ["proof (prove)\nusing this:\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n             {s. z I s = 1}.\n     consistent_sign_vec_copr qs x = s} =\n    {s. z I s = 1 \\<and> consistent_sign_vec_copr qs x = s}", "by auto"], ["proof (state)\nthis:\n  {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n           {s. z I s = 1}.\n   consistent_sign_vec_copr qs x = s} =\n  {s. z I s = 1 \\<and> consistent_sign_vec_copr qs x = s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "from horiz_vector_helper_pos[OF assms(1) assms(5) rt]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?sign = consistent_sign_vec_copr qs x;\n   list_constr ?I (length qs)\\<rbrakk>\n  \\<Longrightarrow> (0 < poly (prod_list (retrieve_polys qs ?I)) x) =\n                    (z ?I ?sign = 1)", "have 2: \"... = {s. (0 < poly (prod_list (retrieve_polys qs I)) x)  \\<and> consistent_sign_vec_copr qs x = s}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?sign = consistent_sign_vec_copr qs x;\n   list_constr ?I (length qs)\\<rbrakk>\n  \\<Longrightarrow> (0 < poly (prod_list (retrieve_polys qs ?I)) x) =\n                    (z ?I ?sign = 1)\n\ngoal (1 subgoal):\n 1. {s. z I s = 1 \\<and> consistent_sign_vec_copr qs x = s} =\n    {s. 0 < poly (prod_list (retrieve_polys qs I)) x \\<and>\n        consistent_sign_vec_copr qs x = s}", "using welldefined"], ["proof (prove)\nusing this:\n  \\<lbrakk>?sign = consistent_sign_vec_copr qs x;\n   list_constr ?I (length qs)\\<rbrakk>\n  \\<Longrightarrow> (0 < poly (prod_list (retrieve_polys qs ?I)) x) =\n                    (z ?I ?sign = 1)\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. {s. z I s = 1 \\<and> consistent_sign_vec_copr qs x = s} =\n    {s. 0 < poly (prod_list (retrieve_polys qs I)) x \\<and>\n        consistent_sign_vec_copr qs x = s}", "by blast"], ["proof (state)\nthis:\n  {s. z I s = 1 \\<and> consistent_sign_vec_copr qs x = s} =\n  {s. 0 < poly (prod_list (retrieve_polys qs I)) x \\<and>\n      consistent_sign_vec_copr qs x = s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "have 3: \"... = (if (0 < poly (prod_list (retrieve_polys qs I)) x)  then {consistent_sign_vec_copr qs x} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. 0 < poly (prod_list (retrieve_polys qs I)) x \\<and>\n        consistent_sign_vec_copr qs x = s} =\n    (if 0 < poly (prod_list (retrieve_polys qs I)) x\n     then {consistent_sign_vec_copr qs x} else {})", "by auto"], ["proof (state)\nthis:\n  {s. 0 < poly (prod_list (retrieve_polys qs I)) x \\<and>\n      consistent_sign_vec_copr qs x = s} =\n  (if 0 < poly (prod_list (retrieve_polys qs I)) x\n   then {consistent_sign_vec_copr qs x} else {})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "thus \"card {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter> {s. z I s = 1}. consistent_sign_vec_copr qs x = s} =\n         (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0) \""], ["proof (prove)\nusing this:\n  {s. 0 < poly (prod_list (retrieve_polys qs I)) x \\<and>\n      consistent_sign_vec_copr qs x = s} =\n  (if 0 < poly (prod_list (retrieve_polys qs I)) x\n   then {consistent_sign_vec_copr qs x} else {})\n\ngoal (1 subgoal):\n 1. card\n     {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n              {s. z I s = 1}.\n      consistent_sign_vec_copr qs x = s} =\n    (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "using 1 2 3"], ["proof (prove)\nusing this:\n  {s. 0 < poly (prod_list (retrieve_polys qs I)) x \\<and>\n      consistent_sign_vec_copr qs x = s} =\n  (if 0 < poly (prod_list (retrieve_polys qs I)) x\n   then {consistent_sign_vec_copr qs x} else {})\n  {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n           {s. z I s = 1}.\n   consistent_sign_vec_copr qs x = s} =\n  {s. z I s = 1 \\<and> consistent_sign_vec_copr qs x = s}\n  {s. z I s = 1 \\<and> consistent_sign_vec_copr qs x = s} =\n  {s. 0 < poly (prod_list (retrieve_polys qs I)) x \\<and>\n      consistent_sign_vec_copr qs x = s}\n  {s. 0 < poly (prod_list (retrieve_polys qs I)) x \\<and>\n      consistent_sign_vec_copr qs x = s} =\n  (if 0 < poly (prod_list (retrieve_polys qs I)) x\n   then {consistent_sign_vec_copr qs x} else {})\n\ngoal (1 subgoal):\n 1. card\n     {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n              {s. z I s = 1}.\n      consistent_sign_vec_copr qs x = s} =\n    (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  card\n   {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n            {s. z I s = 1}.\n    consistent_sign_vec_copr qs x = s} =\n  (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n  card\n   {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n            {s. z I s = 1}.\n    consistent_sign_vec_copr qs ?x = s} =\n  (if 0 < poly (prod_list (retrieve_polys qs I)) ?x then 1 else 0)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have e1: \"(\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter> {s. z I s = 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n     (sum (\\<lambda>x. if (poly (prod_list (retrieve_polys qs I)) x) > 0 then 1 else 0) {x. poly p x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n    (\\<Sum>x | poly p x = 0.\n       if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n       card\n        {x \\<in> {x. poly p x = 0}. consistent_sign_vec_copr qs x = s}) =\n    (\\<Sum>x | poly p x = 0.\n       if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "apply (rule sum_multicount_gen)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     (consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n      {s. z I s = 1})\n 2. finite {x. poly p x = 0}\n 3. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "using \\<open>finite (set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)))\\<close> setroots"], ["proof (prove)\nusing this:\n  finite\n   (set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)))\n  set (characterize_root_list_p p) = {x. poly p x = 0}\n\ngoal (3 subgoals):\n 1. finite\n     (consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n      {s. z I s = 1})\n 2. finite {x. poly p x = 0}\n 3. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {x. poly p x = 0}\n 2. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "apply (metis List.finite_set setroots)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "using lem_e1"], ["proof (prove)\nusing this:\n  ?x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n  card\n   {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n            {s. z I s = 1}.\n    consistent_sign_vec_copr qs ?x = s} =\n  (if 0 < poly (prod_list (retrieve_polys qs I)) ?x then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n               {s. z I s = 1}.\n     card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n  (\\<Sum>x | poly p x = 0.\n     if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have gtchr: \"(\\<Sum>s\\<in>?gt. z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    rat_of_int (card {x. poly p x = 0 \\<and> 0 < poly (prod_list (retrieve_polys qs I)) x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z I s = 1}.\n       z I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and>\n                   consistent_sign_vec_copr qs x = s}))) =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x}))", "apply (auto simp add: setroots)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    rat_of_nat\n     (card\n       {x. poly p x = 0 \\<and>\n           0 < poly (prod_list (retrieve_polys qs I)) x})", "apply (subst of_nat_sum[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat\n     (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                  {s. z I s = 1}.\n        card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n    rat_of_nat\n     (card\n       {x. poly p x = 0 \\<and>\n           0 < poly (prod_list (retrieve_polys qs I)) x})", "apply (subst of_nat_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n    card\n     {x. poly p x = 0 \\<and> 0 < poly (prod_list (retrieve_polys qs I)) x}", "apply (subst e1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0.\n       if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0) =\n    card\n     {x. poly p x = 0 \\<and> 0 < poly (prod_list (retrieve_polys qs I)) x}", "apply (subst card_eq_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0.\n       if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0) =\n    (\\<Sum>x | poly p x = 0 \\<and>\n               0 < poly (prod_list (retrieve_polys qs I)) x.\n       1)", "apply (rule sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {x. poly p x = 0}\n 2. {x. poly p x = 0 \\<and> 0 < poly (prod_list (retrieve_polys qs I)) x}\n    \\<subseteq> {x. poly p x = 0}\n 3. \\<forall>i\\<in>{x. poly p x = 0} -\n                   {x. poly p x = 0 \\<and>\n                       0 < poly (prod_list (retrieve_polys qs I)) x}.\n       (if 0 < poly (prod_list (retrieve_polys qs I)) i then 1 else 0) = 0\n 4. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and>\n                   0 < poly (prod_list (retrieve_polys qs I))\n                        x} \\<Longrightarrow>\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0) = 1", "apply (metis List.finite_set setroots)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {x. poly p x = 0 \\<and> 0 < poly (prod_list (retrieve_polys qs I)) x}\n    \\<subseteq> {x. poly p x = 0}\n 2. \\<forall>i\\<in>{x. poly p x = 0} -\n                   {x. poly p x = 0 \\<and>\n                       0 < poly (prod_list (retrieve_polys qs I)) x}.\n       (if 0 < poly (prod_list (retrieve_polys qs I)) i then 1 else 0) = 0\n 3. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and>\n                   0 < poly (prod_list (retrieve_polys qs I))\n                        x} \\<Longrightarrow>\n       (if 0 < poly (prod_list (retrieve_polys qs I)) x then 1 else 0) = 1", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              0 < poly (prod_list (retrieve_polys qs I)) x}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have lem_e2: \"\\<And>x. x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr  qs ` {x. poly p x = 0} \\<inter> {s. z I s = -1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "assume rt: \"x \\<in> {x. poly p x = 0}\""], ["proof (state)\nthis:\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "then"], ["proof (chain)\npicking this:\n  x \\<in> {x. poly p x = 0}", "have 1: \"{s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter> {s. z I s = -1}. consistent_sign_vec_copr qs x = s} =\n      {s. z I s = -1 \\<and> consistent_sign_vec_copr qs x = s}\""], ["proof (prove)\nusing this:\n  x \\<in> {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n             {s. z I s = - 1}.\n     consistent_sign_vec_copr qs x = s} =\n    {s. z I s = - 1 \\<and> consistent_sign_vec_copr qs x = s}", "by auto"], ["proof (state)\nthis:\n  {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n           {s. z I s = - 1}.\n   consistent_sign_vec_copr qs x = s} =\n  {s. z I s = - 1 \\<and> consistent_sign_vec_copr qs x = s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "from horiz_vector_helper_neg[OF assms(1) assms(5) rt]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?sign = consistent_sign_vec_copr qs x;\n   list_constr ?I (length qs)\\<rbrakk>\n  \\<Longrightarrow> (poly (prod_list (retrieve_polys qs ?I)) x < 0) =\n                    (z ?I ?sign = - 1)", "have 2: \"... = {s. (0 > poly (prod_list (retrieve_polys qs I)) x)  \\<and> consistent_sign_vec_copr qs x = s}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?sign = consistent_sign_vec_copr qs x;\n   list_constr ?I (length qs)\\<rbrakk>\n  \\<Longrightarrow> (poly (prod_list (retrieve_polys qs ?I)) x < 0) =\n                    (z ?I ?sign = - 1)\n\ngoal (1 subgoal):\n 1. {s. z I s = - 1 \\<and> consistent_sign_vec_copr qs x = s} =\n    {s. poly (prod_list (retrieve_polys qs I)) x < 0 \\<and>\n        consistent_sign_vec_copr qs x = s}", "using welldefined"], ["proof (prove)\nusing this:\n  \\<lbrakk>?sign = consistent_sign_vec_copr qs x;\n   list_constr ?I (length qs)\\<rbrakk>\n  \\<Longrightarrow> (poly (prod_list (retrieve_polys qs ?I)) x < 0) =\n                    (z ?I ?sign = - 1)\n  list_constr I (length qs)\n\ngoal (1 subgoal):\n 1. {s. z I s = - 1 \\<and> consistent_sign_vec_copr qs x = s} =\n    {s. poly (prod_list (retrieve_polys qs I)) x < 0 \\<and>\n        consistent_sign_vec_copr qs x = s}", "by blast"], ["proof (state)\nthis:\n  {s. z I s = - 1 \\<and> consistent_sign_vec_copr qs x = s} =\n  {s. poly (prod_list (retrieve_polys qs I)) x < 0 \\<and>\n      consistent_sign_vec_copr qs x = s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "have 3: \"... = (if (0 > poly (prod_list (retrieve_polys qs I)) x)  then {consistent_sign_vec_copr qs x} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. poly (prod_list (retrieve_polys qs I)) x < 0 \\<and>\n        consistent_sign_vec_copr qs x = s} =\n    (if poly (prod_list (retrieve_polys qs I)) x < 0\n     then {consistent_sign_vec_copr qs x} else {})", "by auto"], ["proof (state)\nthis:\n  {s. poly (prod_list (retrieve_polys qs I)) x < 0 \\<and>\n      consistent_sign_vec_copr qs x = s} =\n  (if poly (prod_list (retrieve_polys qs I)) x < 0\n   then {consistent_sign_vec_copr qs x} else {})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "thus \"card {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter> {s. z I s = -1}. consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)\""], ["proof (prove)\nusing this:\n  {s. poly (prod_list (retrieve_polys qs I)) x < 0 \\<and>\n      consistent_sign_vec_copr qs x = s} =\n  (if poly (prod_list (retrieve_polys qs I)) x < 0\n   then {consistent_sign_vec_copr qs x} else {})\n\ngoal (1 subgoal):\n 1. card\n     {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n              {s. z I s = - 1}.\n      consistent_sign_vec_copr qs x = s} =\n    (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "using 1 2 3"], ["proof (prove)\nusing this:\n  {s. poly (prod_list (retrieve_polys qs I)) x < 0 \\<and>\n      consistent_sign_vec_copr qs x = s} =\n  (if poly (prod_list (retrieve_polys qs I)) x < 0\n   then {consistent_sign_vec_copr qs x} else {})\n  {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n           {s. z I s = - 1}.\n   consistent_sign_vec_copr qs x = s} =\n  {s. z I s = - 1 \\<and> consistent_sign_vec_copr qs x = s}\n  {s. z I s = - 1 \\<and> consistent_sign_vec_copr qs x = s} =\n  {s. poly (prod_list (retrieve_polys qs I)) x < 0 \\<and>\n      consistent_sign_vec_copr qs x = s}\n  {s. poly (prod_list (retrieve_polys qs I)) x < 0 \\<and>\n      consistent_sign_vec_copr qs x = s} =\n  (if poly (prod_list (retrieve_polys qs I)) x < 0\n   then {consistent_sign_vec_copr qs x} else {})\n\ngoal (1 subgoal):\n 1. card\n     {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n              {s. z I s = - 1}.\n      consistent_sign_vec_copr qs x = s} =\n    (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  card\n   {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n            {s. z I s = - 1}.\n    consistent_sign_vec_copr qs x = s} =\n  (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n  card\n   {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n            {s. z I s = - 1}.\n    consistent_sign_vec_copr qs ?x = s} =\n  (if poly (prod_list (retrieve_polys qs I)) ?x < 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have e2: \" (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter> {s. z I s = - 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n     (sum (\\<lambda>x. if (poly (prod_list (retrieve_polys qs I)) x) < 0 then 1 else 0) {x. poly p x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n    (\\<Sum>x | poly p x = 0.\n       if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n       card\n        {x \\<in> {x. poly p x = 0}. consistent_sign_vec_copr qs x = s}) =\n    (\\<Sum>x | poly p x = 0.\n       if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "apply (rule sum_multicount_gen)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     (consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n      {s. z I s = - 1})\n 2. finite {x. poly p x = 0}\n 3. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "using \\<open>finite (set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)))\\<close> setroots"], ["proof (prove)\nusing this:\n  finite\n   (set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)))\n  set (characterize_root_list_p p) = {x. poly p x = 0}\n\ngoal (3 subgoals):\n 1. finite\n     (consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n      {s. z I s = - 1})\n 2. finite {x. poly p x = 0}\n 3. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {x. poly p x = 0}\n 2. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "apply (metis List.finite_set setroots)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "using lem_e2"], ["proof (prove)\nusing this:\n  ?x \\<in> {x. poly p x = 0} \\<Longrightarrow>\n  card\n   {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n            {s. z I s = - 1}.\n    consistent_sign_vec_copr qs ?x = s} =\n  (if poly (prod_list (retrieve_polys qs I)) ?x < 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. poly p x = 0}.\n       card\n        {s \\<in> consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n         consistent_sign_vec_copr qs x = s} =\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n               {s. z I s = - 1}.\n     card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n  (\\<Sum>x | poly p x = 0.\n     if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "have ltchr: \"(\\<Sum>s\\<in>?lt. z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    - rat_of_int (card {x. poly p x = 0 \\<and> 0 > poly (prod_list (retrieve_polys qs I)) x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                       (characterize_root_list_p p)) \\<inter>\n                 {s. z I s = - 1}.\n       z I s *\n       rat_of_int\n        (int (card\n               {x. poly p x = 0 \\<and>\n                   consistent_sign_vec_copr qs x = s}))) =\n    - rat_of_int\n       (int (card\n              {x. poly p x = 0 \\<and>\n                  poly (prod_list (retrieve_polys qs I)) x < 0}))", "apply (auto simp add: setroots sum_negf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n       rat_of_nat\n        (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) =\n    rat_of_nat\n     (card\n       {x. poly p x = 0 \\<and>\n           poly (prod_list (retrieve_polys qs I)) x < 0})", "apply (subst of_nat_sum[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat\n     (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                  {s. z I s = - 1}.\n        card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n    rat_of_nat\n     (card\n       {x. poly p x = 0 \\<and>\n           poly (prod_list (retrieve_polys qs I)) x < 0})", "apply (subst of_nat_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>consistent_sign_vec_copr qs ` {x. poly p x = 0} \\<inter>\n                 {s. z I s = - 1}.\n       card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}) =\n    card\n     {x. poly p x = 0 \\<and> poly (prod_list (retrieve_polys qs I)) x < 0}", "apply (subst e2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0.\n       if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0) =\n    card\n     {x. poly p x = 0 \\<and> poly (prod_list (retrieve_polys qs I)) x < 0}", "apply (subst card_eq_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0.\n       if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0) =\n    (\\<Sum>x | poly p x = 0 \\<and>\n               poly (prod_list (retrieve_polys qs I)) x < 0.\n       1)", "apply (rule sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {x. poly p x = 0}\n 2. {x. poly p x = 0 \\<and> poly (prod_list (retrieve_polys qs I)) x < 0}\n    \\<subseteq> {x. poly p x = 0}\n 3. \\<forall>i\\<in>{x. poly p x = 0} -\n                   {x. poly p x = 0 \\<and>\n                       poly (prod_list (retrieve_polys qs I)) x < 0}.\n       (if poly (prod_list (retrieve_polys qs I)) i < 0 then 1 else 0) = 0\n 4. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and>\n                   poly (prod_list (retrieve_polys qs I)) x\n                   < 0} \\<Longrightarrow>\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0) = 1", "apply (metis List.finite_set setroots)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {x. poly p x = 0 \\<and> poly (prod_list (retrieve_polys qs I)) x < 0}\n    \\<subseteq> {x. poly p x = 0}\n 2. \\<forall>i\\<in>{x. poly p x = 0} -\n                   {x. poly p x = 0 \\<and>\n                       poly (prod_list (retrieve_polys qs I)) x < 0}.\n       (if poly (prod_list (retrieve_polys qs I)) i < 0 then 1 else 0) = 0\n 3. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and>\n                   poly (prod_list (retrieve_polys qs I)) x\n                   < 0} \\<Longrightarrow>\n       (if poly (prod_list (retrieve_polys qs I)) x < 0 then 1 else 0) = 1", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = - 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n  - rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "using gtchr ltchr"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              0 < poly (prod_list (retrieve_polys qs I)) x}))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = - 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n  - rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "using \\<open>(\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)). z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) = (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)) \\<inter> {s. z I s = 1}. z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) + (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)) \\<inter> {s. z I s = - 1}. z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\\<close> \\<open>(\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p qs. z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})) = (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs) (characterize_root_list_p p)). z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\\<close> \\<open>vec_of_list (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet> construct_lhs_vector p qs (characterize_consistent_signs_at_roots_copr p qs) = (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p qs. z I s * rat_of_int (card {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))\\<close> \\<open>vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs = vec_of_list (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet> construct_lhs_vector p qs (characterize_consistent_signs_at_roots_copr p qs)\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              0 < poly (prod_list (retrieve_polys qs I)) x}))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = - 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n  - rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)).\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s}))) +\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)) \\<inter>\n               {s. z I s = - 1}.\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                       qs. z I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s}))) =\n  (\\<Sum>s\\<in>set (map (consistent_sign_vec_copr qs)\n                     (characterize_root_list_p p)).\n     z I s *\n     rat_of_int\n      (int (card\n             {x. poly p x = 0 \\<and> consistent_sign_vec_copr qs x = s})))\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs) =\n  (\\<Sum>s\\<leftarrow>characterize_consistent_signs_at_roots_copr p\n                       qs. z I s *\n                           rat_of_int\n                            (int (card\n                                   {x. poly p x = 0 \\<and>\n consistent_sign_vec_copr qs x = s})))\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  vec_of_list\n   (mtx_row (characterize_consistent_signs_at_roots_copr p qs) I) \\<bullet>\n  construct_lhs_vector p qs\n   (characterize_consistent_signs_at_roots_copr p qs)\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x})) -\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "by linarith"], ["proof (state)\nthis:\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              0 < poly (prod_list (retrieve_polys qs I)) x})) -\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              poly (prod_list (retrieve_polys qs I)) x < 0}))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* A clean restatement of the helper lemma *)"], ["", "lemma matrix_equation_main_step:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes I:: \"nat list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots_copr p qs) \\<subseteq> set(signs)\"\n  assumes welldefined: \"list_constr I (length qs)\"\n  assumes pairwise_rel_prime_1: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  shows \"(vec_of_list (mtx_row signs I) \\<bullet> (construct_lhs_vector p qs signs)) =  \n    construct_NofI p (retrieve_polys qs I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    construct_NofI p (retrieve_polys qs I)", "unfolding construct_NofI_prop[OF nonzero]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x}) -\n      int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "using matrix_equation_helper_step[OF assms]"], ["proof (prove)\nusing this:\n  vec_of_list (mtx_row signs I) \\<bullet> construct_lhs_vector p qs signs =\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              0 < poly (prod_list (retrieve_polys qs I)) x})) -\n  rat_of_int\n   (int (card\n          {x. poly p x = 0 \\<and>\n              poly (prod_list (retrieve_polys qs I)) x < 0}))\n\ngoal (1 subgoal):\n 1. vec_of_list (mtx_row signs I) \\<bullet>\n    construct_lhs_vector p qs signs =\n    rat_of_int\n     (int (card\n            {x. poly p x = 0 \\<and>\n                0 < poly (prod_list (retrieve_polys qs I)) x}) -\n      int (card\n            {x. poly p x = 0 \\<and>\n                poly (prod_list (retrieve_polys qs I)) x < 0}))", "by linarith"], ["", "lemma map_vec_vec_of_list_eq_intro:\n  assumes \"map f xs = map g ys\"\n  shows \"map_vec f (vec_of_list xs) = map_vec g (vec_of_list ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vec f (vec_of_list xs) = map_vec g (vec_of_list ys)", "by (metis assms vec_of_list_map)"], ["", "(* Shows that as long as we have a \"basis\" of sign assignments (see assumptions all_info, welldefined), \n  and some other mild assumptions on our inputs (given in nonzero, distinct_signs, pairwise_rel_prime),\n  the construction will be satisfied *)"], ["", "theorem matrix_equation:\n  fixes p:: \"real poly\"\n  fixes qs:: \"real poly list\"\n  fixes subsets:: \"nat list list\" \n  fixes signs:: \"rat list list\"\n  assumes nonzero: \"p\\<noteq>0\"\n  assumes distinct_signs: \"distinct signs\"\n  assumes all_info: \"set (characterize_consistent_signs_at_roots_copr p qs) \\<subseteq> set(signs)\"\n  assumes pairwise_rel_prime: \"\\<forall>q. ((List.member qs q) \\<longrightarrow> (coprime p q))\"\n  assumes welldefined: \"all_list_constr (subsets) (length qs)\"\n  shows \"satisfy_equation p qs subsets signs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation p qs subsets signs", "unfolding satisfy_equation_def matrix_A_def\n    construct_lhs_vector_def construct_rhs_vector_def all_list_constr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list (length signs) (map (mtx_row signs) subsets) *\\<^sub>v\n    vec_of_list\n     (map (\\<lambda>w.\n              rat_of_int\n               (int (length\n                      (filter (\\<lambda>v. v = w)\n                        (map (consistent_sign_vec_copr qs)\n                          (characterize_root_list_p p))))))\n       signs) =\n    vec_of_list\n     (map (\\<lambda>I. construct_NofI p (retrieve_polys qs I)) subsets)", "apply (subst mult_mat_vec_of_list)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length\n     (map (\\<lambda>w.\n              rat_of_int\n               (int (length\n                      (filter (\\<lambda>v. v = w)\n                        (map (consistent_sign_vec_copr qs)\n                          (characterize_root_list_p p))))))\n       signs) =\n    length signs\n 2. list_all (\\<lambda>r. length r = length signs)\n     (map (mtx_row signs) subsets)\n 3. vec_of_list\n     (map (\\<lambda>r.\n              vec_of_list r \\<bullet>\n              vec_of_list\n               (map (\\<lambda>w.\n                        rat_of_int\n                         (int (length\n                                (filter (\\<lambda>v. v = w)\n                                  (map (consistent_sign_vec_copr qs)\n                                    (characterize_root_list_p p))))))\n                 signs))\n       (map (mtx_row signs) subsets)) =\n    vec_of_list\n     (map (\\<lambda>I. construct_NofI p (retrieve_polys qs I)) subsets)", "apply (auto simp add: mtx_row_length intro!: map_vec_vec_of_list_eq_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set subsets \\<Longrightarrow>\n       vec_of_list (mtx_row signs x) \\<bullet>\n       map_vec\n        (\\<lambda>w.\n            rat_of_nat\n             (length\n               (filter\n                 ((\\<lambda>v. v = w) \\<circ> consistent_sign_vec_copr qs)\n                 (characterize_root_list_p p))))\n        (vec_of_list signs) =\n       construct_NofI p (retrieve_polys qs x)", "using matrix_equation_main_step[OF assms(1-3) _ assms(4), unfolded construct_lhs_vector_def]"], ["proof (prove)\nusing this:\n  list_constr ?I (length qs) \\<Longrightarrow>\n  vec_of_list (mtx_row signs ?I) \\<bullet>\n  vec_of_list\n   (map (\\<lambda>w.\n            rat_of_int\n             (int (length\n                    (filter (\\<lambda>v. v = w)\n                      (map (consistent_sign_vec_copr qs)\n                        (characterize_root_list_p p))))))\n     signs) =\n  construct_NofI p (retrieve_polys qs ?I)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set subsets \\<Longrightarrow>\n       vec_of_list (mtx_row signs x) \\<bullet>\n       map_vec\n        (\\<lambda>w.\n            rat_of_nat\n             (length\n               (filter\n                 ((\\<lambda>v. v = w) \\<circ> consistent_sign_vec_copr qs)\n                 (characterize_root_list_p p))))\n        (vec_of_list signs) =\n       construct_NofI p (retrieve_polys qs x)", "using all_list_constr_def in_set_member welldefined"], ["proof (prove)\nusing this:\n  list_constr ?I (length qs) \\<Longrightarrow>\n  vec_of_list (mtx_row signs ?I) \\<bullet>\n  vec_of_list\n   (map (\\<lambda>w.\n            rat_of_int\n             (int (length\n                    (filter (\\<lambda>v. v = w)\n                      (map (consistent_sign_vec_copr qs)\n                        (characterize_root_list_p p))))))\n     signs) =\n  construct_NofI p (retrieve_polys qs ?I)\n  all_list_constr ?L ?n \\<equiv>\n  \\<forall>x. List.member ?L x \\<longrightarrow> list_constr x ?n\n  (?x \\<in> set ?xs) = List.member ?xs ?x\n  all_list_constr subsets (length qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set subsets \\<Longrightarrow>\n       vec_of_list (mtx_row signs x) \\<bullet>\n       map_vec\n        (\\<lambda>w.\n            rat_of_nat\n             (length\n               (filter\n                 ((\\<lambda>v. v = w) \\<circ> consistent_sign_vec_copr qs)\n                 (characterize_root_list_p p))))\n        (vec_of_list signs) =\n       construct_NofI p (retrieve_polys qs x)", "by fastforce"], ["", "(* Prettifying some theorems*)"], ["", "definition roots:: \"real poly \\<Rightarrow> real set\"\n  where \"roots p = {x. poly p x = 0}\""], ["", "definition sgn::\"'a::linordered_field \\<Rightarrow> rat\"\n  where \"sgn x = (if x > 0 then 1\n                  else if x < 0 then -1\n                  else 0)\""], ["", "definition sgn_vec::\"real poly list \\<Rightarrow> real \\<Rightarrow> rat list\"\n  where \"sgn_vec qs x \\<equiv>  map (sgn \\<circ> (\\<lambda>q. poly q x)) qs\""], ["", "definition consistent_signs_at_roots:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> rat list set\"\n  where \"consistent_signs_at_roots p qs =\n    (sgn_vec qs) ` (roots p)\""], ["", "lemma consistent_signs_at_roots_eq:\n  assumes \"p \\<noteq> 0\"\n  shows \"consistent_signs_at_roots p qs =\n         set (characterize_consistent_signs_at_roots p qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent_signs_at_roots p qs =\n    set (characterize_consistent_signs_at_roots p qs)", "unfolding consistent_signs_at_roots_def characterize_consistent_signs_at_roots_def\n    characterize_root_list_p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn_vec qs ` roots p =\n    set (remdups (map (signs_at qs) (sorted_list_of_set {x. poly p x = 0})))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       sgn_vec qs xa\n       \\<in> signs_at qs ` set (sorted_list_of_set {x. poly p x = 0})\n 2. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       signs_at qs xa \\<in> sgn_vec qs ` roots p", "apply (subst set_sorted_list_of_set)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa. xa \\<in> roots p \\<Longrightarrow> finite {x. poly p x = 0}\n 2. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       sgn_vec qs xa \\<in> signs_at qs ` {x. poly p x = 0}\n 3. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       signs_at qs xa \\<in> sgn_vec qs ` roots p", "using assms poly_roots_finite"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (3 subgoals):\n 1. \\<And>xa. xa \\<in> roots p \\<Longrightarrow> finite {x. poly p x = 0}\n 2. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       sgn_vec qs xa \\<in> signs_at qs ` {x. poly p x = 0}\n 3. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       signs_at qs xa \\<in> sgn_vec qs ` roots p", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       sgn_vec qs xa \\<in> signs_at qs ` {x. poly p x = 0}\n 2. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       signs_at qs xa \\<in> sgn_vec qs ` roots p", "unfolding sgn_vec_def sgn_def signs_at_def squash_def o_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       map (\\<lambda>x.\n               if 0 < poly x xa then 1\n               else if poly x xa < 0 then - 1 else 0)\n        qs\n       \\<in> (\\<lambda>x.\n                 map (\\<lambda>xa.\n                         if 0 < poly xa x then 1\n                         else if poly xa x < 0 then - 1 else 0)\n                  qs) `\n             {x. poly p x = 0}\n 2. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       map (\\<lambda>x.\n               if 0 < poly x xa then 1\n               else if poly x xa < 0 then - 1 else 0)\n        qs\n       \\<in> (\\<lambda>x.\n                 map (\\<lambda>xa.\n                         if 0 < poly xa x then 1\n                         else if poly xa x < 0 then - 1 else 0)\n                  qs) `\n             roots p", "using roots_def"], ["proof (prove)\nusing this:\n  roots ?p = {x. poly ?p x = 0}\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> roots p \\<Longrightarrow>\n       map (\\<lambda>x.\n               if 0 < poly x xa then 1\n               else if poly x xa < 0 then - 1 else 0)\n        qs\n       \\<in> (\\<lambda>x.\n                 map (\\<lambda>xa.\n                         if 0 < poly xa x then 1\n                         else if poly xa x < 0 then - 1 else 0)\n                  qs) `\n             {x. poly p x = 0}\n 2. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       map (\\<lambda>x.\n               if 0 < poly x xa then 1\n               else if poly x xa < 0 then - 1 else 0)\n        qs\n       \\<in> (\\<lambda>x.\n                 map (\\<lambda>xa.\n                         if 0 < poly xa x then 1\n                         else if poly xa x < 0 then - 1 else 0)\n                  qs) `\n             roots p", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set (sorted_list_of_set {x. poly p x = 0}) \\<Longrightarrow>\n       map (\\<lambda>x.\n               if 0 < poly x xa then 1\n               else if poly x xa < 0 then - 1 else 0)\n        qs\n       \\<in> (\\<lambda>x.\n                 map (\\<lambda>xa.\n                         if 0 < poly xa x then 1\n                         else if poly xa x < 0 then - 1 else 0)\n                  qs) `\n             roots p", "by (smt Collect_cong assms image_iff poly_roots_finite roots_def sorted_list_of_set(1))"], ["", "abbreviation w_vec:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> rat list list  \\<Rightarrow> rat vec\"\n  where \"w_vec \\<equiv> construct_lhs_vector\""], ["", "abbreviation v_vec:: \"real poly \\<Rightarrow> real poly list \\<Rightarrow> nat list list \\<Rightarrow> rat vec\"\n  where \"v_vec \\<equiv> construct_rhs_vector\""], ["", "abbreviation M_mat:: \"rat list list \\<Rightarrow> nat list list \\<Rightarrow> rat mat\"\n  where \"M_mat \\<equiv> matrix_A\""], ["", "theorem matrix_equation_pretty:\n  assumes \"p\\<noteq>0\"\n  assumes \"\\<And>q. q \\<in> set qs \\<Longrightarrow> coprime p q\"\n  assumes \"distinct signs\"\n  assumes \"consistent_signs_at_roots p qs \\<subseteq> set signs\"\n  assumes \"\\<And>l i. l \\<in> set subsets \\<Longrightarrow> i \\<in> set l \\<Longrightarrow> i < length qs\"\n  shows \"M_mat signs subsets *\\<^sub>v w_vec p qs signs = v_vec p qs subsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_mat signs subsets *\\<^sub>v w_vec p qs signs = v_vec p qs subsets", "unfolding satisfy_equation_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfy_equation p qs subsets signs", "apply (rule matrix_equation[OF assms(1) assms(3)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. set (characterize_consistent_signs_at_roots_copr p qs)\n    \\<subseteq> set signs\n 2. \\<forall>q. List.member qs q \\<longrightarrow> coprime p q\n 3. all_list_constr subsets (length qs)", "apply (metis assms(1) assms(2) assms(4) consistent_signs_at_roots_eq csa_list_copr_rel member_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>q. List.member qs q \\<longrightarrow> coprime p q\n 2. all_list_constr subsets (length qs)", "apply (simp add: assms(2) in_set_member)"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_list_constr subsets (length qs)", "using Ball_set all_list_constr_def assms(5) list_constr_def member_def"], ["proof (prove)\nusing this:\n  Ball (set ?xs) ?P = list_all ?P ?xs\n  all_list_constr ?L ?n \\<equiv>\n  \\<forall>x. List.member ?L x \\<longrightarrow> list_constr x ?n\n  \\<lbrakk>?l \\<in> set subsets; ?i \\<in> set ?l\\<rbrakk>\n  \\<Longrightarrow> ?i < length qs\n  list_constr ?L ?n \\<equiv> list_all (\\<lambda>x. x < ?n) ?L\n  List.member ?xs ?x = (?x \\<in> set ?xs)\n\ngoal (1 subgoal):\n 1. all_list_constr subsets (length qs)", "by fastforce"], ["", "end"]]}