{"file_name": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto/Guessing_Many_One.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto", "problem_names": ["lemma many_single_reduction:\n  assumes bound: \"\\<And>c_a c_o s. (c_o, c_a, s) \\<in> set_spmf init \\<Longrightarrow> interaction_bounded_by (Not \\<circ> isl) (\\<A> c_a) q\"\n  and lossless_oracle: \"\\<And>c_a c_o s s' x. (c_o, c_a, s) \\<in> set_spmf init \\<Longrightarrow> lossless_spmf (oracle c_o s' x)\"\n  and lossless_eval: \"\\<And>c_a c_o s s' guess. (c_o, c_a, s) \\<in> set_spmf init \\<Longrightarrow> lossless_spmf (eval c_o c_a s' guess)\"\n  shows \"advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * q\""], "translations": [["", "lemma many_single_reduction:\n  assumes bound: \"\\<And>c_a c_o s. (c_o, c_a, s) \\<in> set_spmf init \\<Longrightarrow> interaction_bounded_by (Not \\<circ> isl) (\\<A> c_a) q\"\n  and lossless_oracle: \"\\<And>c_a c_o s s' x. (c_o, c_a, s) \\<in> set_spmf init \\<Longrightarrow> lossless_spmf (oracle c_o s' x)\"\n  and lossless_eval: \"\\<And>c_a c_o s s' guess. (c_o, c_a, s) \\<in> set_spmf init \\<Longrightarrow> lossless_spmf (eval c_o c_a s' guess)\"\n  shows \"advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "define eval_oracle'\n    where \"eval_oracle' = (\\<lambda>c_o c_a ((id, occ :: nat option), s') guess. \n    map_spmf (\\<lambda>b'. case occ of Some j\\<^sub>0 \\<Rightarrow> ((), (Suc id, Some j\\<^sub>0), s')\n                                | None \\<Rightarrow> ((), (Suc id, (if b' then Some id else None)), s'))\n      (eval c_o c_a s' guess))\""], ["proof (state)\nthis:\n  eval_oracle' =\n  (\\<lambda>c_o c_a ((id, occ), s') guess.\n      map_spmf\n       (\\<lambda>b'.\n           case occ of\n           None \\<Rightarrow>\n             ((), (Suc id, if b' then Some id else None), s')\n           | Some j\\<^sub>0 \\<Rightarrow>\n               ((), (Suc id, Some j\\<^sub>0), s'))\n       (eval c_o c_a s' guess))\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "let ?multi'_body = \"\\<lambda>c_o c_a s. exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a) (\\<A> c_a) ((0, None), s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "define game_multi' where \"game_multi' = (\\<lambda>c_o c_a s. do {\n    (_, ((id, j\\<^sub>0), s' :: 's)) \\<leftarrow> ?multi'_body c_o c_a s;\n    return_spmf (j\\<^sub>0 \\<noteq> None) })\""], ["proof (state)\nthis:\n  game_multi' =\n  (\\<lambda>c_o c_a s.\n      exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s) \\<bind>\n      (\\<lambda>(uu_, (id, j\\<^sub>0), s').\n          return_spmf (j\\<^sub>0 \\<noteq> None)))\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "define initialize :: \"('c_o \\<Rightarrow> 'c_a \\<Rightarrow> 's \\<Rightarrow> nat \\<Rightarrow> bool spmf) \\<Rightarrow> bool spmf\" where\n    \"initialize body = do {\n      (c_o, c_a, s) \\<leftarrow> init;\n      j\\<^sub>s \\<leftarrow> spmf_of_set {..<q};\n      body c_o c_a s j\\<^sub>s }\" for body"], ["proof (state)\nthis:\n  initialize ?body =\n  init \\<bind>\n  (\\<lambda>(c_o, c_a, s). spmf_of_set {..<q} \\<bind> ?body c_o c_a s)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "define body2 where \"body2 c_o c_a s j\\<^sub>s = do {\n    (_, (id, j\\<^sub>0), s') \\<leftarrow> ?multi'_body c_o c_a s;\n    return_spmf (j\\<^sub>0 = Some j\\<^sub>s) }\" for c_o c_a s j\\<^sub>s"], ["proof (state)\nthis:\n  body2 ?c_o ?c_a ?s ?j\\<^sub>s =\n  exec_gpv (\\<dagger>(oracle ?c_o) \\<oplus>\\<^sub>O eval_oracle' ?c_o ?c_a)\n   (\\<A> ?c_a) ((0, None), ?s) \\<bind>\n  (\\<lambda>(uu_, (id, j\\<^sub>0), s').\n      return_spmf (j\\<^sub>0 = Some ?j\\<^sub>s))\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "let ?game2 = \"initialize body2\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "define stop_oracle where \"stop_oracle = (\\<lambda>c_o. \n     (\\<lambda>(idgs, s) x. case idgs of Inr _ \\<Rightarrow> map_spmf (\\<lambda>(y, s). (Some y, (idgs, s))) (oracle c_o s x) | Inl _ \\<Rightarrow> return_spmf (None, (idgs, s)))\n     \\<oplus>\\<^sub>O\\<^sup>S\n     (\\<lambda>(idgs, s) guess :: 'guess. return_spmf (case idgs of Inr 0 \\<Rightarrow> (None, Inl (guess, s), s) | Inr (Suc i) \\<Rightarrow> (Some (), Inr i, s) | Inl _ \\<Rightarrow> (None, idgs, s))))\""], ["proof (state)\nthis:\n  stop_oracle =\n  (\\<lambda>c_o.\n      (\\<lambda>(idgs, s) x.\n          case idgs of Inl x \\<Rightarrow> return_spmf (None, idgs, s)\n          | Inr xa \\<Rightarrow>\n              map_spmf (\\<lambda>(y, s). (Some y, idgs, s))\n               (oracle c_o s x)) \\<oplus>\\<^sub>O\\<^sup>S\n      (\\<lambda>(idgs, s) guess.\n          return_spmf\n           (case idgs of Inl x \\<Rightarrow> (None, idgs, s)\n            | Inr 0 \\<Rightarrow> (None, Inl (guess, s), s)\n            | Inr (Suc i) \\<Rightarrow> (Some (), Inr i, s))))\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "define body3 where \"body3 c_o c_a s j\\<^sub>s = do {\n    (_ :: unit option, idgs, _) \\<leftarrow> exec_gpv_stop (stop_oracle c_o) (\\<A> c_a) (Inr j\\<^sub>s, s);\n    (b' :: bool) \\<leftarrow> case idgs of Inr _ \\<Rightarrow> return_spmf False | Inl (g, s') \\<Rightarrow> eval c_o c_a s' g;\n    return_spmf b' }\" for c_o c_a s j\\<^sub>s"], ["proof (state)\nthis:\n  body3 ?c_o ?c_a ?s ?j\\<^sub>s =\n  exec_gpv_stop (stop_oracle ?c_o) (\\<A> ?c_a) (Inr ?j\\<^sub>s, ?s) \\<bind>\n  (\\<lambda>(uu_, idgs, uu_).\n      (case idgs of Inl (g, s') \\<Rightarrow> eval ?c_o ?c_a s' g\n       | Inr x \\<Rightarrow> return_spmf False) \\<bind>\n      return_spmf)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "let ?game3 = \"initialize body3\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "define S :: \"bool \\<Rightarrow> nat \\<times> nat option \\<Rightarrow> bool\" where \"S \\<equiv> \\<lambda>b' (id, occ). b' \\<longleftrightarrow> (\\<exists>j\\<^sub>0. occ = Some j\\<^sub>0)\""], ["proof (state)\nthis:\n  S \\<equiv>\n  \\<lambda>b' (id, occ). b' = (\\<exists>j\\<^sub>0. occ = Some j\\<^sub>0)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "let ?S = \"rel_prod S (=)\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "define initial :: \"nat \\<times> nat option\" where \"initial = (0, None)\""], ["proof (state)\nthis:\n  initial = (0, None)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "define result :: \"nat \\<times> nat option \\<Rightarrow> bool\" where \"result p = (snd p \\<noteq> None)\" for p"], ["proof (state)\nthis:\n  result ?p = (snd ?p \\<noteq> None)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "have [transfer_rule]: \"(S ===> (=)) (\\<lambda>b. b) result\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S ===> (=)) (\\<lambda>b. b) result", "by(simp add: rel_fun_def result_def S_def)"], ["proof (state)\nthis:\n  (S ===> (=)) (\\<lambda>b. b) result\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "have [transfer_rule]: \"S False initial\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S False initial", "by (simp add: S_def initial_def)"], ["proof (state)\nthis:\n  S False initial\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "have eval_oracle'[transfer_rule]: \n      \"((=) ===> (=) ===> ?S ===> (=) ===> rel_spmf (rel_prod (=) ?S))\n       eval_oracle eval_oracle'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     (=) ===>\n     rel_prod S (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod S (=))))\n     eval_oracle eval_oracle'", "unfolding eval_oracle_def[abs_def] eval_oracle'_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     (=) ===>\n     rel_prod S (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod S (=))))\n     (\\<lambda>c_o c_a (b, s') guess.\n         map_spmf (\\<lambda>b'. ((), b \\<or> b', s'))\n          (eval c_o c_a s' guess))\n     (\\<lambda>c_o c_a ((id, occ), s') guess.\n         map_spmf\n          (\\<lambda>b'.\n              case occ of\n              None \\<Rightarrow>\n                ((), (Suc id, if b' then Some id else None), s')\n              | Some j\\<^sub>0 \\<Rightarrow>\n                  ((), (Suc id, Some j\\<^sub>0), s'))\n          (eval c_o c_a s' guess))", "by (auto simp add: rel_fun_def S_def map_spmf_conv_bind_spmf intro!: rel_spmf_bind_reflI split: option.split)"], ["proof (state)\nthis:\n  ((=) ===>\n   (=) ===>\n   rel_prod S (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod S (=))))\n   eval_oracle eval_oracle'\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "have game_multi': \"game_multi \\<A> = bind_spmf init (\\<lambda>(c_o, c_a, s). game_multi' c_o c_a s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. game_multi \\<A> =\n    init \\<bind> (\\<lambda>(c_o, c_a, s). game_multi' c_o c_a s)", "unfolding game_multi_def game_multi'_def initial_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. init \\<bind>\n    (\\<lambda>(c_o, c_a, s).\n        exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle c_o c_a)\n         (\\<A> c_a) (False, s) \\<bind>\n        (\\<lambda>(uu_, b, uu_). return_spmf b)) =\n    init \\<bind>\n    (\\<lambda>(c_o, c_a, s).\n        exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) (initial, s) \\<bind>\n        (\\<lambda>(uu_, (id, j\\<^sub>0), s').\n            return_spmf (j\\<^sub>0 \\<noteq> None)))", "by (rewrite in \"case_prod \\<hole>\" in \"bind_spmf _ (case_prod \\<hole>)\" in \"_ = bind_spmf _ \\<hole>\" split_def)\n         (fold result_def; transfer_prover)"], ["proof (state)\nthis:\n  game_multi \\<A> =\n  init \\<bind> (\\<lambda>(c_o, c_a, s). game_multi' c_o c_a s)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "}"], ["proof (state)\nthis:\n  game_multi \\<A> =\n  init \\<bind> (\\<lambda>(c_o, c_a, s). game_multi' c_o c_a s)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "moreover"], ["proof (state)\nthis:\n  game_multi \\<A> =\n  init \\<bind> (\\<lambda>(c_o, c_a, s). game_multi' c_o c_a s)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "have \"spmf (game_multi' c_o c_a s) True = spmf (bind_spmf (spmf_of_set {..<q}) (body2 c_o c_a s)) True * q\"\n    if \"(c_o, c_a, s) \\<in> set_spmf init\" for c_o c_a s"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "have bnd: \"interaction_bounded_by (Not \\<circ> isl) (\\<A> c_a) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by' (Not \\<circ> isl) (\\<A> c_a) q", "using bound that"], ["proof (prove)\nusing this:\n  (?c_o, ?c_a, ?s) \\<in> set_spmf init \\<Longrightarrow>\n  interaction_bounded_by' (Not \\<circ> isl) (\\<A> ?c_a) q\n  (c_o, c_a, s) \\<in> set_spmf init\n\ngoal (1 subgoal):\n 1. interaction_bounded_by' (Not \\<circ> isl) (\\<A> c_a) q", "by blast"], ["proof (state)\nthis:\n  interaction_bounded_by' (Not \\<circ> isl) (\\<A> c_a) q\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "have bound_occ: \"j\\<^sub>s < q\" if that: \"((), (id, Some j\\<^sub>s), s') \\<in> set_spmf (?multi'_body c_o c_a s)\" \n      for s' id j\\<^sub>s"], ["proof (prove)\ngoal (1 subgoal):\n 1. j\\<^sub>s < q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j\\<^sub>s < q", "have \"id \\<le> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> q", "by(rule oi_True.interaction_bounded_by'_exec_gpv_count[OF bnd that, where count=\"fst \\<circ> fst\", simplified])\n          (auto simp add: eval_oracle'_def split: plus_oracle_split_asm option.split_asm)"], ["proof (state)\nthis:\n  id \\<le> q\n\ngoal (1 subgoal):\n 1. j\\<^sub>s < q", "moreover"], ["proof (state)\nthis:\n  id \\<le> q\n\ngoal (1 subgoal):\n 1. j\\<^sub>s < q", "let ?I = \"\\<lambda>((id, occ), s'). case occ of None \\<Rightarrow> True | Some j\\<^sub>s \\<Rightarrow> j\\<^sub>s < id\""], ["proof (state)\ngoal (1 subgoal):\n 1. j\\<^sub>s < q", "have \"callee_invariant (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a) ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant\n     (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n     (\\<lambda>((id, occ), s').\n         case occ of None \\<Rightarrow> True\n         | Some j\\<^sub>s \\<Rightarrow> j\\<^sub>s < id)", "by(clarsimp simp add: split_def intro!: conjI[OF callee_invariant_extend_state_oracle_const'])\n          (unfold_locales; auto simp add: eval_oracle'_def split: option.split_asm)"], ["proof (state)\nthis:\n  callee_invariant\n   (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n   (\\<lambda>((id, occ), s').\n       case occ of None \\<Rightarrow> True\n       | Some j\\<^sub>s \\<Rightarrow> j\\<^sub>s < id)\n\ngoal (1 subgoal):\n 1. j\\<^sub>s < q", "from callee_invariant_on.exec_gpv_invariant[OF this that]"], ["proof (chain)\npicking this:\n  \\<lbrakk>case ((0, None), s) of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (id, occ) \\<Rightarrow>\n                \\<lambda>s'.\n                   case occ of None \\<Rightarrow> True\n                   | Some j\\<^sub>s \\<Rightarrow> j\\<^sub>s < id)\n              xa;\n   \\<I>_full \\<turnstile>g \\<A> c_a \\<surd>\\<rbrakk>\n  \\<Longrightarrow> case ((id, Some j\\<^sub>s), s') of\n                    (x, xa) \\<Rightarrow>\n                      (case x of\n                       (id, occ) \\<Rightarrow>\n                         \\<lambda>s'.\n                            case occ of None \\<Rightarrow> True\n                            | Some j\\<^sub>s \\<Rightarrow> j\\<^sub>s < id)\n                       xa", "have \"j\\<^sub>s < id\""], ["proof (prove)\nusing this:\n  \\<lbrakk>case ((0, None), s) of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (id, occ) \\<Rightarrow>\n                \\<lambda>s'.\n                   case occ of None \\<Rightarrow> True\n                   | Some j\\<^sub>s \\<Rightarrow> j\\<^sub>s < id)\n              xa;\n   \\<I>_full \\<turnstile>g \\<A> c_a \\<surd>\\<rbrakk>\n  \\<Longrightarrow> case ((id, Some j\\<^sub>s), s') of\n                    (x, xa) \\<Rightarrow>\n                      (case x of\n                       (id, occ) \\<Rightarrow>\n                         \\<lambda>s'.\n                            case occ of None \\<Rightarrow> True\n                            | Some j\\<^sub>s \\<Rightarrow> j\\<^sub>s < id)\n                       xa\n\ngoal (1 subgoal):\n 1. j\\<^sub>s < id", "by simp"], ["proof (state)\nthis:\n  j\\<^sub>s < id\n\ngoal (1 subgoal):\n 1. j\\<^sub>s < q", "ultimately"], ["proof (chain)\npicking this:\n  id \\<le> q\n  j\\<^sub>s < id", "show ?thesis"], ["proof (prove)\nusing this:\n  id \\<le> q\n  j\\<^sub>s < id\n\ngoal (1 subgoal):\n 1. j\\<^sub>s < q", "by simp"], ["proof (state)\nthis:\n  j\\<^sub>s < q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((), (?id, Some ?j\\<^sub>s), ?s')\n  \\<in> set_spmf\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s)) \\<Longrightarrow>\n  ?j\\<^sub>s < q\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "let ?M = \"measure (measure_spmf (?multi'_body c_o c_a s))\""], ["proof (state)\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "have \"spmf (game_multi' c_o c_a s) True = ?M {(u, (id, j\\<^sub>0), s'). j\\<^sub>0 \\<noteq> None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {(u, (id, j\\<^sub>0), s'). j\\<^sub>0 \\<noteq> None}", "by(auto simp add: game_multi'_def map_spmf_conv_bind_spmf[symmetric] split_def spmf_conv_measure_spmf measure_map_spmf vimage_def)"], ["proof (state)\nthis:\n  spmf (game_multi' c_o c_a s) True =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   {(u, (id, j\\<^sub>0), s'). j\\<^sub>0 \\<noteq> None}\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "also"], ["proof (state)\nthis:\n  spmf (game_multi' c_o c_a s) True =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   {(u, (id, j\\<^sub>0), s'). j\\<^sub>0 \\<noteq> None}\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "have \"{(u, (id, j\\<^sub>0), s'). j\\<^sub>0 \\<noteq> None} =\n      {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} \\<union> {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s \\<ge> q}\"\n      (is \"_ = ?A \\<union> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, (id, j\\<^sub>0), s'). j\\<^sub>0 \\<noteq> None} =\n    {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id.\n     j\\<^sub>s < q} \\<union>\n    {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. q \\<le> j\\<^sub>s}", "by auto"], ["proof (state)\nthis:\n  {(u, (id, j\\<^sub>0), s'). j\\<^sub>0 \\<noteq> None} =\n  {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} \\<union>\n  {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. q \\<le> j\\<^sub>s}\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "also"], ["proof (state)\nthis:\n  {(u, (id, j\\<^sub>0), s'). j\\<^sub>0 \\<noteq> None} =\n  {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} \\<union>\n  {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. q \\<le> j\\<^sub>s}\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "have \"?M \\<dots> = ?M ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     ({((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id.\n       j\\<^sub>s < q} \\<union>\n      {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id.\n       q \\<le> j\\<^sub>s}) =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q}", "by (rule measure_spmf.measure_zero_union)(auto simp add: measure_spmf_zero_iff dest: bound_occ)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   ({((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id.\n     j\\<^sub>s < q} \\<union>\n    {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. q \\<le> j\\<^sub>s}) =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q}\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   ({((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id.\n     j\\<^sub>s < q} \\<union>\n    {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. q \\<le> j\\<^sub>s}) =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q}\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "have \"\\<dots> = measure (measure_spmf (pair_spmf (spmf_of_set {..< q}) (?multi'_body c_o c_a s)))\n         {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id. j\\<^sub>0 = Some j\\<^sub>s } * q\"\n      (is \"_ = measure ?M' ?B * _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "have \"?B = {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id. j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n        {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id. j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s \\<ge> q}\" (is \"_ = ?Set1 \\<union> ?Set2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s} =\n    {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n    {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s \\<and> q \\<le> j\\<^sub>s}", "by auto"], ["proof (state)\nthis:\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s} =\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s \\<and> q \\<le> j\\<^sub>s}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "then"], ["proof (chain)\npicking this:\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s} =\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s \\<and> q \\<le> j\\<^sub>s}", "have \"measure ?M' ?B = measure ?M' (?Set1 \\<union> ?Set2)\""], ["proof (prove)\nusing this:\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s} =\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s \\<and> q \\<le> j\\<^sub>s}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     ({(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n       j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n      {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n       j\\<^sub>0 = Some j\\<^sub>s \\<and> q \\<le> j\\<^sub>s})", "by simp"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s} =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   ({(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n    {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s \\<and> q \\<le> j\\<^sub>s})\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s} =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   ({(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n    {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s \\<and> q \\<le> j\\<^sub>s})\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "have \"\\<dots> = measure ?M' ?Set1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     ({(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n       j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n      {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n       j\\<^sub>0 = Some j\\<^sub>s \\<and> q \\<le> j\\<^sub>s}) =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q}", "by (rule measure_spmf.measure_zero_union) (auto simp add: measure_spmf_zero_iff)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   ({(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n    {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s \\<and> q \\<le> j\\<^sub>s}) =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   ({(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} \\<union>\n    {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s \\<and> q \\<le> j\\<^sub>s}) =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "have \"\\<dots> = (\\<Sum>j\\<in>{0..<q}. measure ?M' ({j} \\<times> {((), (id, Some j), s')|s' id. True}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} =\n    (\\<Sum>j = 0..<q.\n        Sigma_Algebra.measure\n         (measure_spmf\n           (pair_spmf (spmf_of_set {..<q})\n             (exec_gpv\n               (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n               (\\<A> c_a) ((0, None), s))))\n         ({j} \\<times> {((), (id, Some j), s') |s' id. True}))", "by(subst measure_spmf.finite_measure_finite_Union[symmetric])\n          (auto intro!: arg_cong2[where f=measure] simp add: disjoint_family_on_def)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} =\n  (\\<Sum>j = 0..<q.\n      Sigma_Algebra.measure\n       (measure_spmf\n         (pair_spmf (spmf_of_set {..<q})\n           (exec_gpv\n             (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n             (\\<A> c_a) ((0, None), s))))\n       ({j} \\<times> {((), (id, Some j), s') |s' id. True}))\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s \\<and> j\\<^sub>s < q} =\n  (\\<Sum>j = 0..<q.\n      Sigma_Algebra.measure\n       (measure_spmf\n         (pair_spmf (spmf_of_set {..<q})\n           (exec_gpv\n             (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n             (\\<A> c_a) ((0, None), s))))\n       ({j} \\<times> {((), (id, Some j), s') |s' id. True}))\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "have \"\\<dots> = (\\<Sum>j\\<in>{0..<q}. 1 / q * measure (measure_spmf (?multi'_body c_o c_a s)) {((), (id, Some j), s')|s' id. True})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<q.\n        Sigma_Algebra.measure\n         (measure_spmf\n           (pair_spmf (spmf_of_set {..<q})\n             (exec_gpv\n               (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n               (\\<A> c_a) ((0, None), s))))\n         ({j} \\<times> {((), (id, Some j), s') |s' id. True})) =\n    (\\<Sum>j = 0..<q.\n        1 / real q *\n        Sigma_Algebra.measure\n         (measure_spmf\n           (exec_gpv\n             (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n             (\\<A> c_a) ((0, None), s)))\n         {((), (id, Some j), s') |s' id. True})", "by(simp add: measure_pair_spmf_times spmf_conv_measure_spmf[symmetric] spmf_of_set)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<q.\n      Sigma_Algebra.measure\n       (measure_spmf\n         (pair_spmf (spmf_of_set {..<q})\n           (exec_gpv\n             (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n             (\\<A> c_a) ((0, None), s))))\n       ({j} \\<times> {((), (id, Some j), s') |s' id. True})) =\n  (\\<Sum>j = 0..<q.\n      1 / real q *\n      Sigma_Algebra.measure\n       (measure_spmf\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s)))\n       {((), (id, Some j), s') |s' id. True})\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<q.\n      Sigma_Algebra.measure\n       (measure_spmf\n         (pair_spmf (spmf_of_set {..<q})\n           (exec_gpv\n             (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n             (\\<A> c_a) ((0, None), s))))\n       ({j} \\<times> {((), (id, Some j), s') |s' id. True})) =\n  (\\<Sum>j = 0..<q.\n      1 / real q *\n      Sigma_Algebra.measure\n       (measure_spmf\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s)))\n       {((), (id, Some j), s') |s' id. True})\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "have \"\\<dots> = 1 / q * measure (measure_spmf (?multi'_body c_o c_a s)) {((), (id, Some j\\<^sub>s), s')|j\\<^sub>s s' id. j\\<^sub>s < q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<q.\n        1 / real q *\n        Sigma_Algebra.measure\n         (measure_spmf\n           (exec_gpv\n             (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n             (\\<A> c_a) ((0, None), s)))\n         {((), (id, Some j), s') |s' id. True}) =\n    1 / real q *\n    Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q}", "unfolding sum_distrib_left[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real q *\n    (\\<Sum>j = 0..<q.\n        Sigma_Algebra.measure\n         (measure_spmf\n           (exec_gpv\n             (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n             (\\<A> c_a) ((0, None), s)))\n         {((), (id, Some j), s') |s' id. True}) =\n    1 / real q *\n    Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q}", "by(subst measure_spmf.finite_measure_finite_Union[symmetric])\n          (auto intro!: arg_cong2[where f=measure] simp add: disjoint_family_on_def)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<q.\n      1 / real q *\n      Sigma_Algebra.measure\n       (measure_spmf\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s)))\n       {((), (id, Some j), s') |s' id. True}) =\n  1 / real q *\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "finally"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s} =\n  1 / real q *\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q}", "show ?thesis"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s} =\n  1 / real q *\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s)))\n     {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n      j\\<^sub>0 = Some j\\<^sub>s} *\n    real q", "by simp"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s} *\n  real q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s} *\n  real q\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s)))\n   {((), (id, Some j\\<^sub>s), s') |j\\<^sub>s s' id. j\\<^sub>s < q} =\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n    j\\<^sub>0 = Some j\\<^sub>s} *\n  real q\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "have \"?B = (\\<lambda>(j\\<^sub>s, _, (_, j\\<^sub>0), _). j\\<^sub>0 = Some j\\<^sub>s) -` {True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n     j\\<^sub>0 = Some j\\<^sub>s} =\n    (\\<lambda>(j\\<^sub>s, uu_, (uu_, j\\<^sub>0), uu_).\n        j\\<^sub>0 = Some j\\<^sub>s) -`\n    {True}", "by (auto simp add: vimage_def)"], ["proof (state)\nthis:\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s} =\n  (\\<lambda>(j\\<^sub>s, uu_, (uu_, j\\<^sub>0), uu_).\n      j\\<^sub>0 = Some j\\<^sub>s) -`\n  {True}\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "also"], ["proof (state)\nthis:\n  {(j\\<^sub>s, (), (id, j\\<^sub>0), s') |j\\<^sub>s j\\<^sub>0 s' id.\n   j\\<^sub>0 = Some j\\<^sub>s} =\n  (\\<lambda>(j\\<^sub>s, uu_, (uu_, j\\<^sub>0), uu_).\n      j\\<^sub>0 = Some j\\<^sub>s) -`\n  {True}\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "have rw2: \"measure ?M' \\<dots> = spmf (bind_spmf (spmf_of_set {..<q}) (body2 c_o c_a s)) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (pair_spmf (spmf_of_set {..<q})\n         (exec_gpv\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n           (\\<A> c_a) ((0, None), s))))\n     ((\\<lambda>(j\\<^sub>s, uu_, (uu_, j\\<^sub>0), uu_).\n          j\\<^sub>0 = Some j\\<^sub>s) -`\n      {True}) =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True", "by (simp add: body2_def[abs_def] measure_map_spmf[symmetric] map_spmf_conv_bind_spmf\n        split_def pair_spmf_alt_def spmf_conv_measure_spmf[symmetric])"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (pair_spmf (spmf_of_set {..<q})\n       (exec_gpv\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n         (\\<A> c_a) ((0, None), s))))\n   ((\\<lambda>(j\\<^sub>s, uu_, (uu_, j\\<^sub>0), uu_).\n        j\\<^sub>0 = Some j\\<^sub>s) -`\n    {True}) =\n  spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "finally"], ["proof (chain)\npicking this:\n  spmf (game_multi' c_o c_a s) True =\n  spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "show ?thesis"], ["proof (prove)\nusing this:\n  spmf (game_multi' c_o c_a s) True =\n  spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q\n\ngoal (1 subgoal):\n 1. spmf (game_multi' c_o c_a s) True =\n    spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q", "."], ["proof (state)\nthis:\n  spmf (game_multi' c_o c_a s) True =\n  spmf (spmf_of_set {..<q} \\<bind> body2 c_o c_a s) True * real q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?c_o, ?c_a, ?s) \\<in> set_spmf init \\<Longrightarrow>\n  spmf (game_multi' ?c_o ?c_a ?s) True =\n  spmf (spmf_of_set {..<q} \\<bind> body2 ?c_o ?c_a ?s) True * real q\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "hence \"spmf (bind_spmf init (\\<lambda>(c_a, c_o, s). game_multi' c_a c_o s)) True = spmf ?game2 True * q\""], ["proof (prove)\nusing this:\n  (?c_o, ?c_a, ?s) \\<in> set_spmf init \\<Longrightarrow>\n  spmf (game_multi' ?c_o ?c_a ?s) True =\n  spmf (spmf_of_set {..<q} \\<bind> body2 ?c_o ?c_a ?s) True * real q\n\ngoal (1 subgoal):\n 1. spmf (init \\<bind> (\\<lambda>(c_a, c_o, s). game_multi' c_a c_o s))\n     True =\n    spmf (initialize body2) True * real q", "unfolding initialize_def spmf_bind[where p=init]"], ["proof (prove)\nusing this:\n  (?c_o, ?c_a, ?s) \\<in> set_spmf init \\<Longrightarrow>\n  spmf (game_multi' ?c_o ?c_a ?s) True =\n  spmf (spmf_of_set {..<q} \\<bind> body2 ?c_o ?c_a ?s) True * real q\n\ngoal (1 subgoal):\n 1. LINT x|measure_spmf init.\n       spmf (case x of (c_a, xa, xb) \\<Rightarrow> game_multi' c_a xa xb)\n        True =\n    (LINT x|measure_spmf init.\n        spmf\n         (case x of\n          (c_o, c_a, s) \\<Rightarrow>\n            spmf_of_set {..<q} \\<bind> body2 c_o c_a s)\n         True) *\n    real q", "by (auto intro!: integral_cong_AE simp del: integral_mult_left_zero simp add: integral_mult_left_zero[symmetric])"], ["proof (state)\nthis:\n  spmf (init \\<bind> (\\<lambda>(c_a, c_o, s). game_multi' c_a c_o s)) True =\n  spmf (initialize body2) True * real q\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "moreover"], ["proof (state)\nthis:\n  spmf (init \\<bind> (\\<lambda>(c_a, c_o, s). game_multi' c_a c_o s)) True =\n  spmf (initialize body2) True * real q\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "have \"ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s) (body3 c_o c_a s j\\<^sub>s)\"\n    if init: \"(c_o, c_a, s) \\<in> set_spmf init\" and j\\<^sub>s: \"j\\<^sub>s < Suc q\" for c_o c_a s j\\<^sub>s"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "define oracle2' where \"oracle2' \\<equiv> \\<lambda>(b, (id, gs), s) guess. if id = j\\<^sub>s then do {\n        b' :: bool \\<leftarrow> eval c_o c_a s guess;\n        return_spmf ((), (Some b', (Suc id, Some (guess, s)), s))\n      } else return_spmf ((), (b, (Suc id, gs), s))\""], ["proof (state)\nthis:\n  oracle2' \\<equiv>\n  \\<lambda>(b, (id, gs), s) guess.\n     if id = j\\<^sub>s\n     then eval c_o c_a s guess \\<bind>\n          (\\<lambda>b'.\n              return_spmf ((), Some b', (Suc id, Some (guess, s)), s))\n     else return_spmf ((), b, (Suc id, gs), s)\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "let ?R = \"\\<lambda>((id1, j\\<^sub>0), s1) (b', (id2, gs), s2). s1 = s2 \\<and> id1 = id2 \\<and> (j\\<^sub>0 = Some j\\<^sub>s \\<longrightarrow> b' = Some True) \\<and> (id2 \\<le> j\\<^sub>s \\<longrightarrow> b' = None)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "from init"], ["proof (chain)\npicking this:\n  (c_o, c_a, s) \\<in> set_spmf init", "have \"rel_spmf (rel_prod (=) ?R)\n      (exec_gpv (extend_state_oracle (oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a) (\\<A> c_a) ((0, None), s))\n      (exec_gpv (extend_state_oracle (extend_state_oracle (oracle c_o)) \\<oplus>\\<^sub>O oracle2') (\\<A> c_a) (None, (0, None), s))\""], ["proof (prove)\nusing this:\n  (c_o, c_a, s) \\<in> set_spmf init\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_prod (=)\n       (\\<lambda>((id1, j\\<^sub>0), s1) (b', (id2, gs), s2).\n           s1 = s2 \\<and>\n           id1 = id2 \\<and>\n           (j\\<^sub>0 = Some j\\<^sub>s \\<longrightarrow>\n            b' = Some True) \\<and>\n           (id2 \\<le> j\\<^sub>s \\<longrightarrow> b' = None)))\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s))\n     (exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n       (\\<A> c_a) (None, (0, None), s))", "by(intro exec_gpv_oracle_bisim[where X=\"?R\"])(auto simp add: oracle2'_def eval_oracle'_def spmf_rel_map map_spmf_conv_bind_spmf[symmetric] rel_spmf_return_spmf2 lossless_eval o_def intro!: rel_spmf_reflI split: option.split_asm plus_oracle_split if_split_asm)"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_prod (=)\n     (\\<lambda>((id1, j\\<^sub>0), s1) (b', (id2, gs), s2).\n         s1 = s2 \\<and>\n         id1 = id2 \\<and>\n         (j\\<^sub>0 = Some j\\<^sub>s \\<longrightarrow>\n          b' = Some True) \\<and>\n         (id2 \\<le> j\\<^sub>s \\<longrightarrow> b' = None)))\n   (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n     (\\<A> c_a) ((0, None), s))\n   (exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n     (\\<A> c_a) (None, (0, None), s))\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "then"], ["proof (chain)\npicking this:\n  rel_spmf\n   (rel_prod (=)\n     (\\<lambda>((id1, j\\<^sub>0), s1) (b', (id2, gs), s2).\n         s1 = s2 \\<and>\n         id1 = id2 \\<and>\n         (j\\<^sub>0 = Some j\\<^sub>s \\<longrightarrow>\n          b' = Some True) \\<and>\n         (id2 \\<le> j\\<^sub>s \\<longrightarrow> b' = None)))\n   (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n     (\\<A> c_a) ((0, None), s))\n   (exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n     (\\<A> c_a) (None, (0, None), s))", "have \"rel_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s) \n      (do {\n        (_, b', _, _) \\<leftarrow> exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2') (\\<A> c_a) (None, (0, None), s);\n        return_spmf (b' = Some True) })\"\n      (is \"rel_spmf _ _ ?body2'\")\n      \\<comment> \\<open>We do not get equality here because the right hand side may return @{const True} even\n        when the bad event has happened before the @{text j\\<^sub>s}-th iteration.\\<close>"], ["proof (prove)\nusing this:\n  rel_spmf\n   (rel_prod (=)\n     (\\<lambda>((id1, j\\<^sub>0), s1) (b', (id2, gs), s2).\n         s1 = s2 \\<and>\n         id1 = id2 \\<and>\n         (j\\<^sub>0 = Some j\\<^sub>s \\<longrightarrow>\n          b' = Some True) \\<and>\n         (id2 \\<le> j\\<^sub>s \\<longrightarrow> b' = None)))\n   (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n     (\\<A> c_a) ((0, None), s))\n   (exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n     (\\<A> c_a) (None, (0, None), s))\n\ngoal (1 subgoal):\n 1. rel_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n       (\\<A> c_a) (None, (0, None), s) \\<bind>\n      (\\<lambda>(uu_, b', uu_, uu_). return_spmf (b' = Some True)))", "unfolding body2_def"], ["proof (prove)\nusing this:\n  rel_spmf\n   (rel_prod (=)\n     (\\<lambda>((id1, j\\<^sub>0), s1) (b', (id2, gs), s2).\n         s1 = s2 \\<and>\n         id1 = id2 \\<and>\n         (j\\<^sub>0 = Some j\\<^sub>s \\<longrightarrow>\n          b' = Some True) \\<and>\n         (id2 \\<le> j\\<^sub>s \\<longrightarrow> b' = None)))\n   (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n     (\\<A> c_a) ((0, None), s))\n   (exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n     (\\<A> c_a) (None, (0, None), s))\n\ngoal (1 subgoal):\n 1. rel_spmf (\\<longrightarrow>)\n     (exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O eval_oracle' c_o c_a)\n       (\\<A> c_a) ((0, None), s) \\<bind>\n      (\\<lambda>(uu_, (id, j\\<^sub>0), s').\n          return_spmf (j\\<^sub>0 = Some j\\<^sub>s)))\n     (exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n       (\\<A> c_a) (None, (0, None), s) \\<bind>\n      (\\<lambda>(uu_, b', uu_, uu_). return_spmf (b' = Some True)))", "by(rule rel_spmf_bindI) clarsimp"], ["proof (state)\nthis:\n  rel_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n   (exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n     (\\<A> c_a) (None, (0, None), s) \\<bind>\n    (\\<lambda>(uu_, b', uu_, uu_). return_spmf (b' = Some True)))\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "also"], ["proof (state)\nthis:\n  rel_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n   (exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n     (\\<A> c_a) (None, (0, None), s) \\<bind>\n    (\\<lambda>(uu_, b', uu_, uu_). return_spmf (b' = Some True)))\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "let ?guess_oracle = \"\\<lambda>((id, gs), s) guess. return_spmf ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "let ?I = \"\\<lambda>(idgs, s). case idgs of (_, None) \\<Rightarrow> False | (i, Some _) \\<Rightarrow> j\\<^sub>s < i\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "interpret I: callee_invariant_on \"\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O ?guess_oracle\" \"?I\" \\<I>_full"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant\n     (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n      (\\<lambda>((id, gs), s) guess.\n          return_spmf\n           ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n            s)))\n     (\\<lambda>(idgs, s).\n         case idgs of (x, None) \\<Rightarrow> False\n         | (x, Some xa) \\<Rightarrow> j\\<^sub>s < x)", "by(simp)(unfold_locales; auto split: option.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "let ?f = \"\\<lambda>s. case snd (fst s) of None \\<Rightarrow> return_spmf False | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "let ?X = \"\\<lambda>j\\<^sub>s (b1, (id1, gs1), s1) (b2, (id2, gs2), s2). b1 = b2 \\<and> id1 = id2 \\<and> gs1 = gs2 \\<and> s1 = s2 \\<and> (b2 = None \\<longleftrightarrow> gs2 = None) \\<and> (id2 \\<le> j\\<^sub>s \\<longrightarrow> b2 = None)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "have \"?body2' = do {\n      (a, r, s) \\<leftarrow> exec_gpv (\\<lambda>(r, s) x. do {\n               (y, s') \\<leftarrow> (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O ?guess_oracle) s x;\n               if ?I s' \\<and> r = None then map_spmf (\\<lambda>r. (y, Some r, s')) (?f s') else return_spmf (y, r, s')\n             })\n         (\\<A> c_a) (None, (0, None), s);\n      case r of None \\<Rightarrow> ?f s \\<bind> return_spmf | Some r' \\<Rightarrow> return_spmf r' }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n     (\\<A> c_a) (None, (0, None), s) \\<bind>\n    (\\<lambda>(uu_, b', uu_, uu_). return_spmf (b' = Some True)) =\n    exec_gpv\n     (\\<lambda>(r, s) x.\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n          (\\<lambda>((id, gs), s) guess.\n              return_spmf\n               ((),\n                (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n                s)))\n          s x \\<bind>\n         (\\<lambda>(y, s').\n             if (case s' of ((x, None), s) \\<Rightarrow> False\n                 | ((x, Some xa), s) \\<Rightarrow> j\\<^sub>s < x) \\<and>\n                r = None\n             then map_spmf (\\<lambda>r. (y, Some r, s'))\n                   (case snd (fst s') of\n                    None \\<Rightarrow> return_spmf False\n                    | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a))\n             else return_spmf (y, r, s')))\n     (\\<A> c_a) (None, (0, None), s) \\<bind>\n    (\\<lambda>(a, r, s).\n        case r of\n        None \\<Rightarrow>\n          (case snd (fst s) of None \\<Rightarrow> return_spmf False\n           | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n          return_spmf\n        | Some r' \\<Rightarrow> return_spmf r')", "unfolding oracle2'_def spmf_rel_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (exec_gpv\n       (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n        (\\<lambda>(b, (id, gs), s) guess.\n            if id = j\\<^sub>s\n            then eval c_o c_a s guess \\<bind>\n                 (\\<lambda>b'.\n                     return_spmf\n                      ((), Some b', (Suc id, Some (guess, s)), s))\n            else return_spmf ((), b, (Suc id, gs), s)))\n       (\\<A> c_a) (None, (0, None), s) \\<bind>\n      (\\<lambda>(uu_, b', uu_, uu_). return_spmf (b' = Some True)))\n     (exec_gpv\n       (\\<lambda>(r, s) x.\n           (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n            (\\<lambda>((id, gs), s) guess.\n                return_spmf\n                 ((),\n                  (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n                  s)))\n            s x \\<bind>\n           (\\<lambda>(y, s').\n               if (case s' of ((x, None), s) \\<Rightarrow> False\n                   | ((x, Some xa), s) \\<Rightarrow> j\\<^sub>s < x) \\<and>\n                  r = None\n               then map_spmf (\\<lambda>r. (y, Some r, s'))\n                     (case snd (fst s') of\n                      None \\<Rightarrow> return_spmf False\n                      | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a))\n               else return_spmf (y, r, s')))\n       (\\<A> c_a) (None, (0, None), s) \\<bind>\n      (\\<lambda>(a, r, s).\n          case r of\n          None \\<Rightarrow>\n            (case snd (fst s) of None \\<Rightarrow> return_spmf False\n             | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n            return_spmf\n          | Some r' \\<Rightarrow> return_spmf r'))", "by(rule rel_spmf_bindI[OF exec_gpv_oracle_bisim'[where X=\"?X j\\<^sub>s\"]])\n        (auto simp add: bind_map_spmf o_def spmf.map_comp split_beta conj_comms map_spmf_conv_bind_spmf[symmetric] spmf_rel_map rel_spmf_reflI cong: conj_cong split: plus_oracle_split)"], ["proof (state)\nthis:\n  exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n   (\\<A> c_a) (None, (0, None), s) \\<bind>\n  (\\<lambda>(uu_, b', uu_, uu_). return_spmf (b' = Some True)) =\n  exec_gpv\n   (\\<lambda>(r, s) x.\n       (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n              s)))\n        s x \\<bind>\n       (\\<lambda>(y, s').\n           if (case s' of ((x, None), s) \\<Rightarrow> False\n               | ((x, Some xa), s) \\<Rightarrow> j\\<^sub>s < x) \\<and>\n              r = None\n           then map_spmf (\\<lambda>r. (y, Some r, s'))\n                 (case snd (fst s') of None \\<Rightarrow> return_spmf False\n                  | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a))\n           else return_spmf (y, r, s')))\n   (\\<A> c_a) (None, (0, None), s) \\<bind>\n  (\\<lambda>(a, r, s).\n      case r of\n      None \\<Rightarrow>\n        (case snd (fst s) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf\n      | Some r' \\<Rightarrow> return_spmf r')\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "also"], ["proof (state)\nthis:\n  exec_gpv (\\<dagger>\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O oracle2')\n   (\\<A> c_a) (None, (0, None), s) \\<bind>\n  (\\<lambda>(uu_, b', uu_, uu_). return_spmf (b' = Some True)) =\n  exec_gpv\n   (\\<lambda>(r, s) x.\n       (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n              s)))\n        s x \\<bind>\n       (\\<lambda>(y, s').\n           if (case s' of ((x, None), s) \\<Rightarrow> False\n               | ((x, Some xa), s) \\<Rightarrow> j\\<^sub>s < x) \\<and>\n              r = None\n           then map_spmf (\\<lambda>r. (y, Some r, s'))\n                 (case snd (fst s') of None \\<Rightarrow> return_spmf False\n                  | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a))\n           else return_spmf (y, r, s')))\n   (\\<A> c_a) (None, (0, None), s) \\<bind>\n  (\\<lambda>(a, r, s).\n      case r of\n      None \\<Rightarrow>\n        (case snd (fst s) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf\n      | Some r' \\<Rightarrow> return_spmf r')\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "have \"\\<dots> = do {\n        us' \\<leftarrow> exec_gpv (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O ?guess_oracle) (\\<A> c_a) ((0, None), s);\n        (b' :: bool) \\<leftarrow> ?f (snd us');\n        return_spmf b' }\"\n      (is \"_ = ?body2''\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv\n     (\\<lambda>(r, s) x.\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n          (\\<lambda>((id, gs), s) guess.\n              return_spmf\n               ((),\n                (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n                s)))\n          s x \\<bind>\n         (\\<lambda>(y, s').\n             if (case s' of ((x, None), s) \\<Rightarrow> False\n                 | ((x, Some xa), s) \\<Rightarrow> j\\<^sub>s < x) \\<and>\n                r = None\n             then map_spmf (\\<lambda>r. (y, Some r, s'))\n                   (case snd (fst s') of\n                    None \\<Rightarrow> return_spmf False\n                    | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a))\n             else return_spmf (y, r, s')))\n     (\\<A> c_a) (None, (0, None), s) \\<bind>\n    (\\<lambda>(a, r, s).\n        case r of\n        None \\<Rightarrow>\n          (case snd (fst s) of None \\<Rightarrow> return_spmf False\n           | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n          return_spmf\n        | Some r' \\<Rightarrow> return_spmf r') =\n    exec_gpv\n     (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n      (\\<lambda>((id, gs), s) guess.\n          return_spmf\n           ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n            s)))\n     (\\<A> c_a) ((0, None), s) \\<bind>\n    (\\<lambda>us'.\n        (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf)", "by(rule I.exec_gpv_bind_materialize[symmetric])(auto split: plus_oracle_split_asm option.split_asm)"], ["proof (state)\nthis:\n  exec_gpv\n   (\\<lambda>(r, s) x.\n       (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n              s)))\n        s x \\<bind>\n       (\\<lambda>(y, s').\n           if (case s' of ((x, None), s) \\<Rightarrow> False\n               | ((x, Some xa), s) \\<Rightarrow> j\\<^sub>s < x) \\<and>\n              r = None\n           then map_spmf (\\<lambda>r. (y, Some r, s'))\n                 (case snd (fst s') of None \\<Rightarrow> return_spmf False\n                  | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a))\n           else return_spmf (y, r, s')))\n   (\\<A> c_a) (None, (0, None), s) \\<bind>\n  (\\<lambda>(a, r, s).\n      case r of\n      None \\<Rightarrow>\n        (case snd (fst s) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf\n      | Some r' \\<Rightarrow> return_spmf r') =\n  exec_gpv\n   (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n    (\\<lambda>((id, gs), s) guess.\n        return_spmf\n         ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n   (\\<A> c_a) ((0, None), s) \\<bind>\n  (\\<lambda>us'.\n      (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n       | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n      return_spmf)\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "also"], ["proof (state)\nthis:\n  exec_gpv\n   (\\<lambda>(r, s) x.\n       (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n              s)))\n        s x \\<bind>\n       (\\<lambda>(y, s').\n           if (case s' of ((x, None), s) \\<Rightarrow> False\n               | ((x, Some xa), s) \\<Rightarrow> j\\<^sub>s < x) \\<and>\n              r = None\n           then map_spmf (\\<lambda>r. (y, Some r, s'))\n                 (case snd (fst s') of None \\<Rightarrow> return_spmf False\n                  | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a))\n           else return_spmf (y, r, s')))\n   (\\<A> c_a) (None, (0, None), s) \\<bind>\n  (\\<lambda>(a, r, s).\n      case r of\n      None \\<Rightarrow>\n        (case snd (fst s) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf\n      | Some r' \\<Rightarrow> return_spmf r') =\n  exec_gpv\n   (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n    (\\<lambda>((id, gs), s) guess.\n        return_spmf\n         ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n   (\\<A> c_a) ((0, None), s) \\<bind>\n  (\\<lambda>us'.\n      (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n       | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n      return_spmf)\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "have \"\\<dots> = do {\n        us' \\<leftarrow> exec_gpv_stop (lift_stop_oracle (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O ?guess_oracle)) (\\<A> c_a) ((0, None), s);\n        (b' :: bool) \\<leftarrow> ?f (snd us');\n        return_spmf b' }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv\n     (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n      (\\<lambda>((id, gs), s) guess.\n          return_spmf\n           ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n            s)))\n     (\\<A> c_a) ((0, None), s) \\<bind>\n    (\\<lambda>us'.\n        (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf) =\n    exec_gpv_stop\n     (lift_stop_oracle\n       (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n              s))))\n     (\\<A> c_a) ((0, None), s) \\<bind>\n    (\\<lambda>us'.\n        (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf)", "supply lift_stop_oracle_transfer[transfer_rule] gpv_stop_transfer[transfer_rule] exec_gpv_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv\n     (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n      (\\<lambda>((id, gs), s) guess.\n          return_spmf\n           ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n            s)))\n     (\\<A> c_a) ((0, None), s) \\<bind>\n    (\\<lambda>us'.\n        (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf) =\n    exec_gpv_stop\n     (lift_stop_oracle\n       (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n              s))))\n     (\\<A> c_a) ((0, None), s) \\<bind>\n    (\\<lambda>us'.\n        (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf)", "by transfer simp"], ["proof (state)\nthis:\n  exec_gpv\n   (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n    (\\<lambda>((id, gs), s) guess.\n        return_spmf\n         ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n   (\\<A> c_a) ((0, None), s) \\<bind>\n  (\\<lambda>us'.\n      (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n       | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n      return_spmf) =\n  exec_gpv_stop\n   (lift_stop_oracle\n     (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n      (\\<lambda>((id, gs), s) guess.\n          return_spmf\n           ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n            s))))\n   (\\<A> c_a) ((0, None), s) \\<bind>\n  (\\<lambda>us'.\n      (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n       | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n      return_spmf)\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "also"], ["proof (state)\nthis:\n  exec_gpv\n   (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n    (\\<lambda>((id, gs), s) guess.\n        return_spmf\n         ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n   (\\<A> c_a) ((0, None), s) \\<bind>\n  (\\<lambda>us'.\n      (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n       | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n      return_spmf) =\n  exec_gpv_stop\n   (lift_stop_oracle\n     (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n      (\\<lambda>((id, gs), s) guess.\n          return_spmf\n           ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n            s))))\n   (\\<A> c_a) ((0, None), s) \\<bind>\n  (\\<lambda>us'.\n      (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n       | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n      return_spmf)\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "let ?S = \"\\<lambda>((id1, gs1), s1) ((id2, gs2), s2). gs1 = gs2 \\<and> (gs2 = None \\<longrightarrow> s1 = s2 \\<and> id1 = id2) \\<and> (gs1 = None \\<longleftrightarrow> id1 \\<le> j\\<^sub>s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "have \"ord_spmf (\\<longrightarrow>) \\<dots> (exec_gpv_stop ((\\<lambda>((id, gs), s) x. case gs of None \\<Rightarrow> lift_stop_oracle (\\<dagger>(oracle c_o)) ((id, gs), s) x | Some _ \\<Rightarrow> return_spmf (None, ((id, gs), s))) \\<oplus>\\<^sub>O\\<^sup>S\n            (\\<lambda>((id, gs), s) guess. return_spmf (if id \\<ge> j\\<^sub>s then None else Some (), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n           (\\<A> c_a) ((0, None), s) \\<bind>\n          (\\<lambda>us'. case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>)\n     (exec_gpv_stop\n       (lift_stop_oracle\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n          (\\<lambda>((id, gs), s) guess.\n              return_spmf\n               ((),\n                (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n                s))))\n       (\\<A> c_a) ((0, None), s) \\<bind>\n      (\\<lambda>us'.\n          (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n           | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n          return_spmf))\n     (exec_gpv_stop\n       ((\\<lambda>((id, gs), s) x.\n            case gs of\n            None \\<Rightarrow>\n              lift_stop_oracle \\<dagger>(oracle c_o) ((id, gs), s) x\n            | Some x \\<Rightarrow>\n                return_spmf (None, (id, gs), s)) \\<oplus>\\<^sub>O\\<^sup>S\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             (if j\\<^sub>s \\<le> id then None else Some (),\n              (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n       (\\<A> c_a) ((0, None), s) \\<bind>\n      (\\<lambda>us'.\n          case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n          | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)))", "unfolding body3_def stop_oracle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>)\n     (exec_gpv_stop\n       (lift_stop_oracle\n         (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n          (\\<lambda>((id, gs), s) guess.\n              return_spmf\n               ((),\n                (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n                s))))\n       (\\<A> c_a) ((0, None), s) \\<bind>\n      (\\<lambda>us'.\n          (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n           | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n          return_spmf))\n     (exec_gpv_stop\n       ((\\<lambda>((id, gs), s) x.\n            case gs of\n            None \\<Rightarrow>\n              lift_stop_oracle \\<dagger>(oracle c_o) ((id, gs), s) x\n            | Some x \\<Rightarrow>\n                return_spmf (None, (id, gs), s)) \\<oplus>\\<^sub>O\\<^sup>S\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             (if j\\<^sub>s \\<le> id then None else Some (),\n              (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n       (\\<A> c_a) ((0, None), s) \\<bind>\n      (\\<lambda>us'.\n          case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n          | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)))", "by(rule ord_spmf_exec_gpv_stop[where stop = \"\\<lambda>((id, guess), _). guess \\<noteq> None\" and S=\"?S\", THEN ord_spmf_bindI])\n        (auto split: prod.split_asm plus_oracle_split_asm split!: plus_oracle_stop_split simp del: not_None_eq simp add: spmf.map_comp o_def apfst_compose ord_spmf_map_spmf1 ord_spmf_map_spmf2 split_beta ord_spmf_return_spmf2 intro!: ord_spmf_reflI)"], ["proof (state)\nthis:\n  ord_spmf (\\<longrightarrow>)\n   (exec_gpv_stop\n     (lift_stop_oracle\n       (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n              s))))\n     (\\<A> c_a) ((0, None), s) \\<bind>\n    (\\<lambda>us'.\n        (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf))\n   (exec_gpv_stop\n     ((\\<lambda>((id, gs), s) x.\n          case gs of\n          None \\<Rightarrow>\n            lift_stop_oracle \\<dagger>(oracle c_o) ((id, gs), s) x\n          | Some x \\<Rightarrow>\n              return_spmf (None, (id, gs), s)) \\<oplus>\\<^sub>O\\<^sup>S\n      (\\<lambda>((id, gs), s) guess.\n          return_spmf\n           (if j\\<^sub>s \\<le> id then None else Some (),\n            (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n     (\\<A> c_a) ((0, None), s) \\<bind>\n    (\\<lambda>us'.\n        case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n        | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)))\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "also"], ["proof (state)\nthis:\n  ord_spmf (\\<longrightarrow>)\n   (exec_gpv_stop\n     (lift_stop_oracle\n       (\\<dagger>(oracle c_o) \\<oplus>\\<^sub>O\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             ((), (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs),\n              s))))\n     (\\<A> c_a) ((0, None), s) \\<bind>\n    (\\<lambda>us'.\n        (case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n         | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) \\<bind>\n        return_spmf))\n   (exec_gpv_stop\n     ((\\<lambda>((id, gs), s) x.\n          case gs of\n          None \\<Rightarrow>\n            lift_stop_oracle \\<dagger>(oracle c_o) ((id, gs), s) x\n          | Some x \\<Rightarrow>\n              return_spmf (None, (id, gs), s)) \\<oplus>\\<^sub>O\\<^sup>S\n      (\\<lambda>((id, gs), s) guess.\n          return_spmf\n           (if j\\<^sub>s \\<le> id then None else Some (),\n            (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n     (\\<A> c_a) ((0, None), s) \\<bind>\n    (\\<lambda>us'.\n        case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n        | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)))\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "let ?X = \"\\<lambda>((id, gs), s1) (idgs, s2). s1 = s2 \\<and> (case (gs, idgs) of (None, Inr id') \\<Rightarrow> id' = j\\<^sub>s - id \\<and> id \\<le> j\\<^sub>s | (Some gs, Inl gs') \\<Rightarrow> gs = gs' \\<and> id > j\\<^sub>s | _ \\<Rightarrow> False)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "have \"\\<dots> = body3 c_o c_a s j\\<^sub>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv_stop\n     ((\\<lambda>((id, gs), s) x.\n          case gs of\n          None \\<Rightarrow>\n            lift_stop_oracle \\<dagger>(oracle c_o) ((id, gs), s) x\n          | Some x \\<Rightarrow>\n              return_spmf (None, (id, gs), s)) \\<oplus>\\<^sub>O\\<^sup>S\n      (\\<lambda>((id, gs), s) guess.\n          return_spmf\n           (if j\\<^sub>s \\<le> id then None else Some (),\n            (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n     (\\<A> c_a) ((0, None), s) \\<bind>\n    (\\<lambda>us'.\n        case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n        | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) =\n    body3 c_o c_a s j\\<^sub>s", "unfolding body3_def spmf_rel_eq[symmetric] stop_oracle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (exec_gpv_stop\n       ((\\<lambda>((id, gs), s) x.\n            case gs of\n            None \\<Rightarrow>\n              lift_stop_oracle \\<dagger>(oracle c_o) ((id, gs), s) x\n            | Some x \\<Rightarrow>\n                return_spmf (None, (id, gs), s)) \\<oplus>\\<^sub>O\\<^sup>S\n        (\\<lambda>((id, gs), s) guess.\n            return_spmf\n             (if j\\<^sub>s \\<le> id then None else Some (),\n              (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n       (\\<A> c_a) ((0, None), s) \\<bind>\n      (\\<lambda>us'.\n          case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n          | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)))\n     (exec_gpv_stop\n       ((\\<lambda>(idgs, s) x.\n            case idgs of Inl x \\<Rightarrow> return_spmf (None, idgs, s)\n            | Inr xa \\<Rightarrow>\n                map_spmf (\\<lambda>(y, s). (Some y, idgs, s))\n                 (oracle c_o s x)) \\<oplus>\\<^sub>O\\<^sup>S\n        (\\<lambda>(idgs, s) guess.\n            return_spmf\n             (case idgs of Inl x \\<Rightarrow> (None, idgs, s)\n              | Inr 0 \\<Rightarrow> (None, Inl (guess, s), s)\n              | Inr (Suc i) \\<Rightarrow> (Some (), Inr i, s))))\n       (\\<A> c_a) (Inr j\\<^sub>s, s) \\<bind>\n      (\\<lambda>(uu_, idgs, uu_).\n          (case idgs of Inl (g, s') \\<Rightarrow> eval c_o c_a s' g\n           | Inr x \\<Rightarrow> return_spmf False) \\<bind>\n          return_spmf))", "by(rule exec_gpv_oracle_bisim'[where X=\"?X\", THEN rel_spmf_bindI])\n        (auto split: option.split_asm plus_oracle_stop_split nat.splits split!: sum.split simp add: spmf_rel_map intro!: rel_spmf_reflI)"], ["proof (state)\nthis:\n  exec_gpv_stop\n   ((\\<lambda>((id, gs), s) x.\n        case gs of\n        None \\<Rightarrow>\n          lift_stop_oracle \\<dagger>(oracle c_o) ((id, gs), s) x\n        | Some x \\<Rightarrow>\n            return_spmf (None, (id, gs), s)) \\<oplus>\\<^sub>O\\<^sup>S\n    (\\<lambda>((id, gs), s) guess.\n        return_spmf\n         (if j\\<^sub>s \\<le> id then None else Some (),\n          (Suc id, if id = j\\<^sub>s then Some (guess, s) else gs), s)))\n   (\\<A> c_a) ((0, None), s) \\<bind>\n  (\\<lambda>us'.\n      case snd (fst (snd us')) of None \\<Rightarrow> return_spmf False\n      | Some a \\<Rightarrow> eval c_o c_a (snd a) (fst a)) =\n  body3 c_o c_a s j\\<^sub>s\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "finally"], ["proof (chain)\npicking this:\n  rel_pmf (rel_option (\\<longrightarrow>) OO ord_option (\\<longrightarrow>))\n   (body2 c_o c_a s j\\<^sub>s) (body3 c_o c_a s j\\<^sub>s)", "show ?thesis"], ["proof (prove)\nusing this:\n  rel_pmf (rel_option (\\<longrightarrow>) OO ord_option (\\<longrightarrow>))\n   (body2 c_o c_a s j\\<^sub>s) (body3 c_o c_a s j\\<^sub>s)\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n     (body3 c_o c_a s j\\<^sub>s)", "by(rule pmf.rel_mono_strong)(auto elim!: option.rel_cases ord_option.cases)"], ["proof (state)\nthis:\n  ord_spmf (\\<longrightarrow>) (body2 c_o c_a s j\\<^sub>s)\n   (body3 c_o c_a s j\\<^sub>s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?c_o, ?c_a, ?s) \\<in> set_spmf init; ?j\\<^sub>s < Suc q\\<rbrakk>\n  \\<Longrightarrow> ord_spmf (\\<longrightarrow>)\n                     (body2 ?c_o ?c_a ?s ?j\\<^sub>s)\n                     (body3 ?c_o ?c_a ?s ?j\\<^sub>s)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?c_o, ?c_a, ?s) \\<in> set_spmf init; ?j\\<^sub>s < Suc q\\<rbrakk>\n  \\<Longrightarrow> ord_spmf (\\<longrightarrow>)\n                     (body2 ?c_o ?c_a ?s ?j\\<^sub>s)\n                     (body3 ?c_o ?c_a ?s ?j\\<^sub>s)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?c_o, ?c_a, ?s) \\<in> set_spmf init; ?j\\<^sub>s < Suc q\\<rbrakk>\n  \\<Longrightarrow> ord_spmf (\\<longrightarrow>)\n                     (body2 ?c_o ?c_a ?s ?j\\<^sub>s)\n                     (body3 ?c_o ?c_a ?s ?j\\<^sub>s)", "have \"ord_spmf (\\<longrightarrow>) ?game2 ?game3\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?c_o, ?c_a, ?s) \\<in> set_spmf init; ?j\\<^sub>s < Suc q\\<rbrakk>\n  \\<Longrightarrow> ord_spmf (\\<longrightarrow>)\n                     (body2 ?c_o ?c_a ?s ?j\\<^sub>s)\n                     (body3 ?c_o ?c_a ?s ?j\\<^sub>s)\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (initialize body2) (initialize body3)", "by(clarsimp simp add: initialize_def intro!: ord_spmf_bind_reflI)"], ["proof (state)\nthis:\n  ord_spmf (\\<longrightarrow>) (initialize body2) (initialize body3)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "also"], ["proof (state)\nthis:\n  ord_spmf (\\<longrightarrow>) (initialize body2) (initialize body3)\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "let ?X = \"\\<lambda>(gsid, s) (gid, s'). s = s' \\<and> rel_sum (\\<lambda>(g, s1) g'. g = g' \\<and> s1 = s') (=) gsid gid\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "have \"rel_spmf (\\<longrightarrow>) ?game3 (game_single (reduction q \\<A>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (\\<longrightarrow>) (initialize body3)\n     (game_single (reduction q \\<A>))", "unfolding body3_def stop_oracle_def game_single_def reduction_def split_def initialize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (\\<longrightarrow>)\n     (init \\<bind>\n      (\\<lambda>p.\n          spmf_of_set {..<q} \\<bind>\n          (\\<lambda>j\\<^sub>s.\n              exec_gpv_stop\n               ((\\<lambda>pa x.\n                    case fst pa of\n                    Inl x \\<Rightarrow> return_spmf (None, fst pa, snd pa)\n                    | Inr xa \\<Rightarrow>\n                        map_spmf (\\<lambda>p. (Some (fst p), fst pa, snd p))\n                         (oracle (fst p) (snd pa)\n                           x)) \\<oplus>\\<^sub>O\\<^sup>S\n                (\\<lambda>p guess.\n                    return_spmf\n                     (case fst p of Inl x \\<Rightarrow> (None, fst p, snd p)\n                      | Inr 0 \\<Rightarrow>\n                          (None, Inl (guess, snd p), snd p)\n                      | Inr (Suc i) \\<Rightarrow> (Some (), Inr i, snd p))))\n               (\\<A> (fst (snd p))) (Inr j\\<^sub>s, snd (snd p)) \\<bind>\n              (\\<lambda>pa.\n                  (case fst (snd pa) of\n                   Inl pa \\<Rightarrow>\n                     eval (fst p) (fst (snd p)) (snd pa) (fst pa)\n                   | Inr x \\<Rightarrow> return_spmf False) \\<bind>\n                  return_spmf))))\n     (init \\<bind>\n      (\\<lambda>p.\n          exec_gpv (oracle (fst p))\n           (lift_spmf (spmf_of_set {..<q}) \\<bind>\n            (\\<lambda>j_star.\n                inline_stop reduction_oracle (\\<A> (fst (snd p)))\n                 (Inr j_star) \\<bind>\n                (\\<lambda>p.\n                    Generative_Probabilistic_Value.Done (projl (snd p)))))\n           (snd (snd p)) \\<bind>\n          (\\<lambda>pa. eval (fst p) (fst (snd p)) (snd pa) (fst pa))))", "apply(clarsimp simp add: bind_map_spmf exec_gpv_bind exec_gpv_inline intro!: rel_spmf_bind_reflI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b x.\n       \\<lbrakk>(a, aa, b) \\<in> set_spmf init; x < q\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (\\<longrightarrow>)\n                          (exec_gpv_stop\n                            ((\\<lambda>p x.\n                                 case fst p of\n                                 Inl x \\<Rightarrow>\n                                   return_spmf (None, fst p, snd p)\n                                 | Inr xa \\<Rightarrow>\n                                     map_spmf\n(\\<lambda>pa. (Some (fst pa), fst p, snd pa))\n(oracle (fst (a, aa, b)) (snd p) x)) \\<oplus>\\<^sub>O\\<^sup>S\n                             (\\<lambda>p guess.\n                                 return_spmf\n                                  (case fst p of\n                                   Inl x \\<Rightarrow> (None, fst p, snd p)\n                                   | Inr 0 \\<Rightarrow>\n (None, Inl (guess, snd p), snd p)\n                                   | Inr (Suc i) \\<Rightarrow>\n (Some (), Inr i, snd p))))\n                            (\\<A> aa) (Inr x, b) \\<bind>\n                           (\\<lambda>p.\n                               case fst (snd p) of\n                               Inl p \\<Rightarrow>\n                                 eval (fst (a, aa, b))\n                                  (fst (snd (a, aa, b))) (snd p) (fst p)\n                               | Inr x \\<Rightarrow> return_spmf False))\n                          (exec_gpv_stop\n                            (\\<lambda>(s', s) y.\n                                map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n                                 (exec_gpv (oracle a)\n                                   (reduction_oracle s' y) s))\n                            (\\<A> aa) (Inr x, b) \\<bind>\n                           (\\<lambda>y.\n                               (case case y of\n                                     (x, s', xb) \\<Rightarrow>\n ((x, s'), xb) of\n                                (x, s') \\<Rightarrow>\n                                  return_spmf (projl (snd x), s')) \\<bind>\n                               (\\<lambda>p. eval a aa (snd p) (fst p))))", "apply(rule rel_spmf_bindI[OF exec_gpv_oracle_bisim'[where X=\"?X\"]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b x.\n       \\<lbrakk>(a, aa, b) \\<in> set_spmf init; x < q\\<rbrakk>\n       \\<Longrightarrow> (case (Inr x, b) of\n                          (gsid, s) \\<Rightarrow>\n                            \\<lambda>(gid, s').\n                               s = s' \\<and>\n                               rel_sum\n                                (\\<lambda>(g, s1) g'. g = g' \\<and> s1 = s')\n                                (=) gsid gid)\n                          (Inr x, b)\n 2. \\<And>a aa b x s1 s2 xa.\n       \\<lbrakk>(a, aa, b) \\<in> set_spmf init; x < q;\n        (case s1 of\n         (gsid, s) \\<Rightarrow>\n           \\<lambda>(gid, s').\n              s = s' \\<and>\n              rel_sum (\\<lambda>(g, s1) g'. g = g' \\<and> s1 = s') (=) gsid\n               gid)\n         s2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (\\<lambda>(a, s1') (b, s2').\n                              a = b \\<and>\n                              (case s1' of\n                               (gsid, s) \\<Rightarrow>\n                                 \\<lambda>(gid, s').\n                                    s = s' \\<and>\n                                    rel_sum\n                                     (\\<lambda>(g, s1) g'.\n   g = g' \\<and> s1 = s')\n                                     (=) gsid gid)\n                               s2')\n                          (((\\<lambda>p x.\n                                case fst p of\n                                Inl x \\<Rightarrow>\n                                  return_spmf (None, fst p, snd p)\n                                | Inr xa \\<Rightarrow>\n                                    map_spmf\n                                     (\\<lambda>pa.\n   (Some (fst pa), fst p, snd pa))\n                                     (oracle (fst (a, aa, b)) (snd p)\n x)) \\<oplus>\\<^sub>O\\<^sup>S\n                            (\\<lambda>p guess.\n                                return_spmf\n                                 (case fst p of\n                                  Inl x \\<Rightarrow> (None, fst p, snd p)\n                                  | Inr 0 \\<Rightarrow>\n(None, Inl (guess, snd p), snd p)\n                                  | Inr (Suc i) \\<Rightarrow>\n(Some (), Inr i, snd p))))\n                            s1 xa)\n                          ((case s2 of\n                            (s', s) \\<Rightarrow>\n                              \\<lambda>y.\n                                 map_spmf\n                                  (\\<lambda>((x, s'), s). (x, s', s))\n                                  (exec_gpv (oracle a)\n                                    (reduction_oracle s' y) s))\n                            xa)\n 3. \\<And>a aa b x xa y.\n       \\<lbrakk>(a, aa, b) \\<in> set_spmf init; x < q;\n        (case xa of\n         (a, s1') \\<Rightarrow>\n           \\<lambda>(b, s2').\n              a = b \\<and>\n              (case s1' of\n               (gsid, s) \\<Rightarrow>\n                 \\<lambda>(gid, s').\n                    s = s' \\<and>\n                    rel_sum (\\<lambda>(g, s1) g'. g = g' \\<and> s1 = s') (=)\n                     gsid gid)\n               s2')\n         y\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (\\<longrightarrow>)\n                          (case fst (snd xa) of\n                           Inl p \\<Rightarrow>\n                             eval (fst (a, aa, b)) (fst (snd (a, aa, b)))\n                              (snd p) (fst p)\n                           | Inr x \\<Rightarrow> return_spmf False)\n                          ((case case y of\n                                 (x, s', xb) \\<Rightarrow> ((x, s'), xb) of\n                            (x, s') \\<Rightarrow>\n                              return_spmf (projl (snd x), s')) \\<bind>\n                           (\\<lambda>p. eval a aa (snd p) (fst p)))", "apply(auto split: plus_oracle_stop_split elim!: rel_sum.cases simp add: map_spmf_conv_bind_spmf[symmetric] split_def spmf_rel_map rel_spmf_reflI rel_spmf_return_spmf1 lossless_eval split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_spmf (\\<longrightarrow>) (initialize body3)\n   (game_single (reduction q \\<A>))\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "finally"], ["proof (chain)\npicking this:\n  rel_pmf (ord_option (\\<longrightarrow>) OO rel_option (\\<longrightarrow>))\n   (initialize body2) (game_single (reduction q \\<A>))", "have \"ord_spmf (\\<longrightarrow>) ?game2 (game_single (reduction q \\<A>))\""], ["proof (prove)\nusing this:\n  rel_pmf (ord_option (\\<longrightarrow>) OO rel_option (\\<longrightarrow>))\n   (initialize body2) (game_single (reduction q \\<A>))\n\ngoal (1 subgoal):\n 1. ord_spmf (\\<longrightarrow>) (initialize body2)\n     (game_single (reduction q \\<A>))", "by(rule pmf.rel_mono_strong)(auto elim!: option.rel_cases ord_option.cases)"], ["proof (state)\nthis:\n  ord_spmf (\\<longrightarrow>) (initialize body2)\n   (game_single (reduction q \\<A>))\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "from this[THEN ord_spmf_measureD, of \"{True}\"]"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure (measure_spmf (initialize body2)) {True}\n  \\<le> Sigma_Algebra.measure\n         (measure_spmf (game_single (reduction q \\<A>)))\n         {y. \\<exists>x\\<in>{True}. x \\<longrightarrow> y}", "have \"spmf ?game2 True \\<le> spmf (game_single (reduction q \\<A>)) True\""], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure (measure_spmf (initialize body2)) {True}\n  \\<le> Sigma_Algebra.measure\n         (measure_spmf (game_single (reduction q \\<A>)))\n         {y. \\<exists>x\\<in>{True}. x \\<longrightarrow> y}\n\ngoal (1 subgoal):\n 1. spmf (initialize body2) True\n    \\<le> spmf (game_single (reduction q \\<A>)) True", "unfolding spmf_conv_measure_spmf"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure (measure_spmf (initialize body2)) {True}\n  \\<le> Sigma_Algebra.measure\n         (measure_spmf (game_single (reduction q \\<A>)))\n         {y. \\<exists>x\\<in>{True}. x \\<longrightarrow> y}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (initialize body2)) {True}\n    \\<le> Sigma_Algebra.measure\n           (measure_spmf (game_single (reduction q \\<A>))) {True}", "by(rule ord_le_eq_trans)(auto intro: arg_cong2[where f=measure])"], ["proof (state)\nthis:\n  spmf (initialize body2) True\n  \\<le> spmf (game_single (reduction q \\<A>)) True\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "}"], ["proof (state)\nthis:\n  spmf (initialize body2) True\n  \\<le> spmf (game_single (reduction q \\<A>)) True\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "ultimately"], ["proof (chain)\npicking this:\n  game_multi \\<A> =\n  init \\<bind> (\\<lambda>(c_o, c_a, s). game_multi' c_o c_a s)\n  spmf (init \\<bind> (\\<lambda>(c_a, c_o, s). game_multi' c_a c_o s)) True =\n  spmf (initialize body2) True * real q\n  spmf (initialize body2) True\n  \\<le> spmf (game_single (reduction q \\<A>)) True", "show ?thesis"], ["proof (prove)\nusing this:\n  game_multi \\<A> =\n  init \\<bind> (\\<lambda>(c_o, c_a, s). game_multi' c_o c_a s)\n  spmf (init \\<bind> (\\<lambda>(c_a, c_o, s). game_multi' c_a c_o s)) True =\n  spmf (initialize body2) True * real q\n  spmf (initialize body2) True\n  \\<le> spmf (game_single (reduction q \\<A>)) True\n\ngoal (1 subgoal):\n 1. advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q", "unfolding advantage_multi_def advantage_single_def"], ["proof (prove)\nusing this:\n  game_multi \\<A> =\n  init \\<bind> (\\<lambda>(c_o, c_a, s). game_multi' c_o c_a s)\n  spmf (init \\<bind> (\\<lambda>(c_a, c_o, s). game_multi' c_a c_o s)) True =\n  spmf (initialize body2) True * real q\n  spmf (initialize body2) True\n  \\<le> spmf (game_single (reduction q \\<A>)) True\n\ngoal (1 subgoal):\n 1. spmf (game_multi \\<A>) True\n    \\<le> spmf (game_single (reduction q \\<A>)) True * real q", "by(simp add: mult_right_mono)"], ["proof (state)\nthis:\n  advantage_multi \\<A> \\<le> advantage_single (reduction q \\<A>) * real q\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}