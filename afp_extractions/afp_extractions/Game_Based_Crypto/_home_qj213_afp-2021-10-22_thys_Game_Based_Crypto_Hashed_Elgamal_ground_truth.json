{"file_name": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto/Hashed_Elgamal.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto", "problem_names": ["lemma invariant_initial [simp]: \"invariant initial\"", "lemma invariant_update [simp]: \"\\<lbrakk> invariant \\<sigma>; length bs = len \\<rbrakk> \\<Longrightarrow> invariant (\\<sigma>(x \\<mapsto> bs))\"", "lemma invariant [intro!, simp]: \"callee_invariant oracle invariant\"", "lemma invariant_in_dom [simp]: \"callee_invariant oracle (\\<lambda>\\<sigma>. x \\<in> dom \\<sigma>)\"", "lemma lossless_oracle [simp]: \"lossless_spmf (oracle \\<sigma> x)\"", "lemma card_dom_state:\n  assumes \\<sigma>': \"(x, \\<sigma>') \\<in> set_spmf (exec_gpv oracle gpv \\<sigma>)\"\n  and ibound: \"interaction_any_bounded_by gpv n\"\n  shows \"card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)\"", "lemma lossless_aencrypt [simp]: \"lossless_gpv \\<I> (aencrypt \\<alpha> msg) \\<longleftrightarrow> 0 < order \\<G>\"", "lemma interaction_bounded_by_aencrypt [interaction_bound, simp]:\n  \"interaction_bounded_by (\\<lambda>_. True) (aencrypt \\<alpha> msg) 1\"", "lemma advantage_elgamal: \n  includes lifting_syntax\n  assumes lossless: \"ind_cpa.lossless \\<A>\"\n  shows \"ind_cpa.advantage hash.oracle hash.initial \\<A> \\<le> lcdh.advantage (elgamal_adversary \\<A>)\"", "lemma lossless_key_gen [simp]: \"lossless_spmf key_gen \\<longleftrightarrow> 0 < order \\<G>\"", "lemma lossless_elgamal_adversary:\n  \"\\<lbrakk> ind_cpa.lossless \\<A>; \\<And>\\<eta>. 0 < order \\<G> \\<rbrakk>\n  \\<Longrightarrow> lcdh.lossless (elgamal_adversary \\<A>)\""], "translations": [["", "lemma invariant_initial [simp]: \"invariant initial\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant Map.empty", "by(rule invariant.intros) auto"], ["", "lemma invariant_update [simp]: \"\\<lbrakk> invariant \\<sigma>; length bs = len \\<rbrakk> \\<Longrightarrow> invariant (\\<sigma>(x \\<mapsto> bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant \\<sigma>; length bs = len\\<rbrakk>\n    \\<Longrightarrow> invariant (\\<sigma>(x \\<mapsto> bs))", "by(auto simp add: invariant.simps ran_def)"], ["", "lemma invariant [intro!, simp]: \"callee_invariant oracle invariant\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant oracle invariant", "by unfold_locales(simp_all add: oracle_def in_nlists_UNIV split: option.split_asm)"], ["", "lemma invariant_in_dom [simp]: \"callee_invariant oracle (\\<lambda>\\<sigma>. x \\<in> dom \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant oracle (\\<lambda>\\<sigma>. x \\<in> dom \\<sigma>)", "by unfold_locales(simp_all add: oracle_def split: option.split_asm)"], ["", "lemma lossless_oracle [simp]: \"lossless_spmf (oracle \\<sigma> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (oracle \\<sigma> x)", "by(simp add: oracle_def split: option.split)"], ["", "lemma card_dom_state:\n  assumes \\<sigma>': \"(x, \\<sigma>') \\<in> set_spmf (exec_gpv oracle gpv \\<sigma>)\"\n  and ibound: \"interaction_any_bounded_by gpv n\"\n  shows \"card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "proof(cases \"finite (dom \\<sigma>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)\n 2. infinite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "case True"], ["proof (state)\nthis:\n  finite (dom \\<sigma>)\n\ngoal (2 subgoals):\n 1. finite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)\n 2. infinite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "interpret callee_invariant_on \"oracle\" \"\\<lambda>\\<sigma>. finite (dom \\<sigma>)\" \\<I>_full"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant oracle (\\<lambda>\\<sigma>. finite (dom \\<sigma>))", "by unfold_locales(auto simp add: oracle_def split: option.split_asm)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)\n 2. infinite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "from ibound \\<sigma>' _ _ _ True"], ["proof (chain)\npicking this:\n  interaction_bounded_by' (\\<lambda>_. True) gpv n\n  (x, \\<sigma>') \\<in> set_spmf (exec_gpv oracle gpv \\<sigma>)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite (dom \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  interaction_bounded_by' (\\<lambda>_. True) gpv n\n  (x, \\<sigma>') \\<in> set_spmf (exec_gpv oracle gpv \\<sigma>)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite (dom \\<sigma>)\n\ngoal (1 subgoal):\n 1. card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "by(rule interaction_bounded_by'_exec_gpv_count)(auto simp add: oracle_def card_insert_if simp del: fun_upd_apply split: option.split_asm)"], ["proof (state)\nthis:\n  card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)\n\ngoal (1 subgoal):\n 1. infinite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "case False"], ["proof (state)\nthis:\n  infinite (dom \\<sigma>)\n\ngoal (1 subgoal):\n 1. infinite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "interpret callee_invariant_on \"oracle\" \"\\<lambda>\\<sigma>'. dom \\<sigma> \\<subseteq> dom \\<sigma>'\" \\<I>_full"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant oracle\n     (\\<lambda>\\<sigma>'. dom \\<sigma> \\<subseteq> dom \\<sigma>')", "by unfold_locales(auto simp add: oracle_def split: option.split_asm)"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "from \\<sigma>'"], ["proof (chain)\npicking this:\n  (x, \\<sigma>') \\<in> set_spmf (exec_gpv oracle gpv \\<sigma>)", "have \"dom \\<sigma> \\<subseteq> dom \\<sigma>'\""], ["proof (prove)\nusing this:\n  (x, \\<sigma>') \\<in> set_spmf (exec_gpv oracle gpv \\<sigma>)\n\ngoal (1 subgoal):\n 1. dom \\<sigma> \\<subseteq> dom \\<sigma>'", "by(rule exec_gpv_invariant) simp_all"], ["proof (state)\nthis:\n  dom \\<sigma> \\<subseteq> dom \\<sigma>'\n\ngoal (1 subgoal):\n 1. infinite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "with False"], ["proof (chain)\npicking this:\n  infinite (dom \\<sigma>)\n  dom \\<sigma> \\<subseteq> dom \\<sigma>'", "have \"infinite (dom \\<sigma>')\""], ["proof (prove)\nusing this:\n  infinite (dom \\<sigma>)\n  dom \\<sigma> \\<subseteq> dom \\<sigma>'\n\ngoal (1 subgoal):\n 1. infinite (dom \\<sigma>')", "by(auto intro: finite_subset)"], ["proof (state)\nthis:\n  infinite (dom \\<sigma>')\n\ngoal (1 subgoal):\n 1. infinite (dom \\<sigma>) \\<Longrightarrow>\n    card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "with False"], ["proof (chain)\npicking this:\n  infinite (dom \\<sigma>)\n  infinite (dom \\<sigma>')", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite (dom \\<sigma>)\n  infinite (dom \\<sigma>')\n\ngoal (1 subgoal):\n 1. card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  card (dom \\<sigma>') \\<le> n + card (dom \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale elgamal_base =\n  fixes \\<G> :: \"'grp cyclic_group\" (structure)\n  and len_plain :: \"nat\"\nbegin"], ["", "sublocale hash: hash_oracle \"len_plain\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation hash :: \"'grp \\<Rightarrow> (bitstring, 'grp, bitstring) gpv\"\nwhere \"hash x \\<equiv> Pause x Done\""], ["", "type_synonym 'grp' pub_key = \"'grp'\""], ["", "type_synonym 'grp' priv_key = nat"], ["", "type_synonym plain = bitstring"], ["", "type_synonym 'grp' cipher = \"'grp' \\<times> bitstring\""], ["", "definition key_gen :: \"('grp pub_key \\<times> 'grp priv_key) spmf\"\nwhere \n  \"key_gen = do {\n     x \\<leftarrow> sample_uniform (order \\<G>);\n     return_spmf (\\<^bold>g [^] x, x)\n  }\""], ["", "definition aencrypt :: \"'grp pub_key \\<Rightarrow> plain \\<Rightarrow> ('grp cipher, 'grp, bitstring) gpv\"\nwhere\n  \"aencrypt \\<alpha> msg = do {\n    y \\<leftarrow> lift_spmf (sample_uniform (order \\<G>));\n    h \\<leftarrow> hash (\\<alpha> [^] y);\n    Done (\\<^bold>g [^] y, h [\\<oplus>] msg)\n  }\""], ["", "definition adecrypt :: \"'grp priv_key \\<Rightarrow> 'grp cipher \\<Rightarrow> (plain, 'grp, bitstring) gpv\"\nwhere\n  \"adecrypt x = (\\<lambda>(\\<beta>, \\<zeta>). do {\n    h \\<leftarrow> hash (\\<beta> [^] x);\n    Done (\\<zeta> [\\<oplus>] h)\n  })\""], ["", "definition valid_plains :: \"plain \\<Rightarrow> plain \\<Rightarrow> bool\"\nwhere \"valid_plains msg1 msg2 \\<longleftrightarrow> length msg1 = len_plain \\<and> length msg2 = len_plain\""], ["", "lemma lossless_aencrypt [simp]: \"lossless_gpv \\<I> (aencrypt \\<alpha> msg) \\<longleftrightarrow> 0 < order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_gpv \\<I> (aencrypt \\<alpha> msg) = (0 < order \\<G>)", "by(simp add: aencrypt_def Let_def)"], ["", "lemma interaction_bounded_by_aencrypt [interaction_bound, simp]:\n  \"interaction_bounded_by (\\<lambda>_. True) (aencrypt \\<alpha> msg) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_by (aencrypt \\<alpha> msg) 1", "unfolding aencrypt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_by\n     (lift_spmf (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>y.\n          hash (\\<alpha> [^] y) \\<bind>\n          (\\<lambda>h.\n              Generative_Probabilistic_Value.Done\n               (\\<^bold>g [^] y, h [\\<oplus>] msg))))\n     1", "by interaction_bound(simp add: one_enat_def SUP_le_iff)"], ["", "sublocale ind_cpa: ind_cpa_pk \"lift_spmf key_gen\" aencrypt adecrypt valid_plains"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale lcdh: lcdh \\<G>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "fun elgamal_adversary\n   :: \"('grp pub_key, plain, 'grp cipher, 'grp, bitstring, 'state) ind_cpa.adversary\n   \\<Rightarrow> 'grp lcdh.adversary\"                     \nwhere\n  \"elgamal_adversary (\\<A>1, \\<A>2) \\<alpha> \\<beta> = do {\n    (((msg1, msg2), \\<sigma>), s) \\<leftarrow> exec_gpv hash.oracle (\\<A>1 \\<alpha>) hash.initial;\n    \\<comment> \\<open>have to check that the attacker actually sends an element from the group; otherwise stop early\\<close>\n    TRY do {\n      _ :: unit \\<leftarrow> assert_spmf (valid_plains msg1 msg2);\n      h' \\<leftarrow> spmf_of_set (nlists UNIV len_plain);\n      (guess, s') \\<leftarrow> exec_gpv hash.oracle (\\<A>2 (\\<beta>, h') \\<sigma>) s;\n      return_spmf (dom s')\n    } ELSE return_spmf (dom s)\n  }\""], ["", "end"], ["", "locale elgamal = elgamal_base +\n  assumes cyclic_group: \"cyclic_group \\<G>\"\nbegin"], ["", "interpretation cyclic_group \\<G>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cyclic_group \\<G>", "by(fact cyclic_group)"], ["", "lemma advantage_elgamal: \n  includes lifting_syntax\n  assumes lossless: \"ind_cpa.lossless \\<A>\"\n  shows \"ind_cpa.advantage hash.oracle hash.initial \\<A> \\<le> lcdh.advantage (elgamal_adversary \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "note [cong del] = if_weak_cong and [split del] = if_split\n    and [simp] = map_lift_spmf gpv.map_id lossless_weight_spmfD map_spmf_bind_spmf bind_spmf_const"], ["proof (state)\nthis:\n  ?b = ?c \\<Longrightarrow>\n  (if ?b then ?x else ?y) = (if ?c then ?x else ?y)\n  ?P (if ?Q then ?x else ?y) =\n  ((?Q \\<longrightarrow> ?P ?x) \\<and> (\\<not> ?Q \\<longrightarrow> ?P ?y))\n  map_gpv ?f ?g (lift_spmf ?p) = lift_spmf (map_spmf ?f ?p)\n  map_gpv id id ?t = ?t\n  lossless_spmf ?p \\<Longrightarrow> weight_spmf ?p = 1\n  map_spmf ?f (?p \\<bind> ?g) = ?p \\<bind> map_spmf ?f \\<circ> ?g\n  ?p \\<bind> (\\<lambda>x. ?q) = scale_spmf (weight_spmf ?p) ?q\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "obtain \\<A>1 \\<A>2 where \\<A> [simp]: \"\\<A> = (\\<A>1, \\<A>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<A>1 \\<A>2.\n        \\<A> = (\\<A>1, \\<A>2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"\\<A>\")"], ["proof (state)\nthis:\n  \\<A> = (\\<A>1, \\<A>2)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "interpret cyclic_group: cyclic_group \\<G>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cyclic_group \\<G>", "by(rule cyclic_group)"], ["proof (state)\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "from finite_carrier"], ["proof (chain)\npicking this:\n  finite (carrier \\<G>)", "have [simp]: \"order \\<G> > 0\""], ["proof (prove)\nusing this:\n  finite (carrier \\<G>)\n\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "using order_gt_0_iff_finite"], ["proof (prove)\nusing this:\n  finite (carrier \\<G>)\n  (0 < order \\<G>) = finite (carrier \\<G>)\n\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by(simp)"], ["proof (state)\nthis:\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "from lossless"], ["proof (chain)\npicking this:\n  ind_cpa.lossless \\<A>", "have lossless1 [simp]: \"\\<And>pk. lossless_gpv \\<I>_full (\\<A>1 pk)\"\n    and lossless2 [simp]: \"\\<And>\\<sigma> cipher. lossless_gpv \\<I>_full (\\<A>2 \\<sigma> cipher)\""], ["proof (prove)\nusing this:\n  ind_cpa.lossless \\<A>\n\ngoal (1 subgoal):\n 1. (\\<And>pk. lossless_gpv \\<I>_full (\\<A>1 pk)) &&&\n    (\\<And>\\<sigma> cipher. lossless_gpv \\<I>_full (\\<A>2 \\<sigma> cipher))", "by(auto simp add: ind_cpa.lossless_def)"], ["proof (state)\nthis:\n  lossless_gpv \\<I>_full (\\<A>1 ?pk6)\n  lossless_gpv \\<I>_full (\\<A>2 ?\\<sigma>6 ?cipher6)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "text \\<open>We change the adversary's oracle to record the queries made by the adversary\\<close>"], ["proof (state)\nthis:\n  lossless_gpv \\<I>_full (\\<A>1 ?pk6)\n  lossless_gpv \\<I>_full (\\<A>2 ?\\<sigma>6 ?cipher6)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "define hash_oracle' where \"hash_oracle' = (\\<lambda>\\<sigma> x. do {\n      h \\<leftarrow> hash x;\n      Done (h, insert x \\<sigma>)\n    })\""], ["proof (state)\nthis:\n  hash_oracle' =\n  (\\<lambda>\\<sigma> x.\n      hash x \\<bind>\n      (\\<lambda>h.\n          Generative_Probabilistic_Value.Done (h, insert x \\<sigma>)))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have [simp]: \"lossless_gpv \\<I>_full (hash_oracle' \\<sigma> x)\" for \\<sigma> x"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_gpv \\<I>_full (hash_oracle' \\<sigma> x)", "by(simp add: hash_oracle'_def)"], ["proof (state)\nthis:\n  lossless_gpv \\<I>_full (hash_oracle' ?\\<sigma>6 ?x6)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have [simp]: \"lossless_gpv \\<I>_full (inline hash_oracle' (\\<A>1 \\<alpha>) s)\" for \\<alpha> s"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_gpv \\<I>_full (inline hash_oracle' (\\<A>1 \\<alpha>) s)", "by(rule lossless_inline[where \\<I>=\\<I>_full]) simp_all"], ["proof (state)\nthis:\n  lossless_gpv \\<I>_full (inline hash_oracle' (\\<A>1 ?\\<alpha>6) ?s6)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "define game0 where \"game0 = TRY do {\n      (pk, _) \\<leftarrow> lift_spmf key_gen;\n      b \\<leftarrow> lift_spmf coin_spmf;\n      (((msg1, msg2), \\<sigma>), s) \\<leftarrow> inline hash_oracle' (\\<A>1 pk) {};\n      assert_gpv (valid_plains msg1 msg2);\n      cipher \\<leftarrow> aencrypt pk (if b then msg1 else msg2);\n      (guess, s') \\<leftarrow> inline hash_oracle' (\\<A>2 cipher \\<sigma>) s;\n      Done (guess = b)\n    } ELSE lift_spmf coin_spmf\""], ["proof (state)\nthis:\n  game0 =\n  TRY lift_spmf key_gen \\<bind>\n      (\\<lambda>(pk, uu_).\n          lift_spmf coin_spmf \\<bind>\n          (\\<lambda>b.\n              inline hash_oracle' (\\<A>1 pk) {} \\<bind>\n              (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n                  assert_gpv (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      aencrypt pk (if b then msg1 else msg2) \\<bind>\n                      (\\<lambda>cipher.\n                          inline hash_oracle' (\\<A>2 cipher \\<sigma>)\n                           s \\<bind>\n                          (\\<lambda>(guess, s').\n                              Generative_Probabilistic_Value.Done\n                               (guess = b))))))) ELSE lift_spmf coin_spmf\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "{"], ["proof (state)\nthis:\n  game0 =\n  TRY lift_spmf key_gen \\<bind>\n      (\\<lambda>(pk, uu_).\n          lift_spmf coin_spmf \\<bind>\n          (\\<lambda>b.\n              inline hash_oracle' (\\<A>1 pk) {} \\<bind>\n              (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n                  assert_gpv (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      aencrypt pk (if b then msg1 else msg2) \\<bind>\n                      (\\<lambda>cipher.\n                          inline hash_oracle' (\\<A>2 cipher \\<sigma>)\n                           s \\<bind>\n                          (\\<lambda>(guess, s').\n                              Generative_Probabilistic_Value.Done\n                               (guess = b))))))) ELSE lift_spmf coin_spmf\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "define cr where \"cr = (\\<lambda>_ :: unit. \\<lambda>_ :: 'a set. True)\""], ["proof (state)\nthis:\n  cr = (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have [transfer_rule]: \"cr () {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr () {}", "by(simp add: cr_def)"], ["proof (state)\nthis:\n  cr () {}\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have [transfer_rule]: \"((=) ===> cr ===> cr) (\\<lambda>_ \\<sigma>. \\<sigma>) insert\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr ===> cr) (\\<lambda>_ \\<sigma>. \\<sigma>) insert", "by(simp add: rel_fun_def cr_def)"], ["proof (state)\nthis:\n  ((=) ===> cr ===> cr) (\\<lambda>_ \\<sigma>. \\<sigma>) insert\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have [transfer_rule]: \"(cr ===> (=) ===> rel_gpv (rel_prod (=) cr) (=)) id_oracle hash_oracle'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr ===> (=) ===> rel_gpv (rel_prod (=) cr) (=)) id_oracle hash_oracle'", "unfolding hash_oracle'_def id_oracle_def[abs_def] bind_gpv_Pause bind_rpv_Done"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr ===> (=) ===> rel_gpv (rel_prod (=) cr) (=))\n     (\\<lambda>s x.\n         Generative_Probabilistic_Value.Pause x\n          (\\<lambda>x. Generative_Probabilistic_Value.Done (x, s)))\n     (\\<lambda>\\<sigma> x.\n         Generative_Probabilistic_Value.Pause x\n          (\\<lambda>h.\n              Generative_Probabilistic_Value.Done (h, insert x \\<sigma>)))", "by transfer_prover"], ["proof (state)\nthis:\n  (cr ===> (=) ===> rel_gpv (rel_prod (=) cr) (=)) id_oracle hash_oracle'\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"ind_cpa.ind_cpa \\<A> = game0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_cpa.ind_cpa \\<A> = game0", "unfolding game0_def \\<A> ind_cpa_pk.ind_cpa.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY lift_spmf key_gen \\<bind>\n        (\\<lambda>(pk, sk).\n            lift_spmf coin_spmf \\<bind>\n            (\\<lambda>b.\n                \\<A>1 pk \\<bind>\n                (\\<lambda>((m0, m1), \\<sigma>).\n                    assert_gpv (valid_plains m0 m1) \\<bind>\n                    (\\<lambda>_.\n                        aencrypt pk (if b then m0 else m1) \\<bind>\n                        (\\<lambda>cipher.\n                            \\<A>2 cipher \\<sigma> \\<bind>\n                            (\\<lambda>guess.\n                                Generative_Probabilistic_Value.Done\n                                 (guess =\n                                  b))))))) ELSE lift_spmf coin_spmf =\n    TRY lift_spmf key_gen \\<bind>\n        (\\<lambda>(pk, uu_).\n            lift_spmf coin_spmf \\<bind>\n            (\\<lambda>b.\n                inline hash_oracle' (\\<A>1 pk) {} \\<bind>\n                (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n                    assert_gpv (valid_plains msg1 msg2) \\<bind>\n                    (\\<lambda>_.\n                        aencrypt pk (if b then msg1 else msg2) \\<bind>\n                        (\\<lambda>cipher.\n                            inline hash_oracle' (\\<A>2 cipher \\<sigma>)\n                             s \\<bind>\n                            (\\<lambda>(guess, s').\n                                Generative_Probabilistic_Value.Done\n                                 (guess = b))))))) ELSE lift_spmf coin_spmf", "by(transfer fixing: \\<G> len_plain \\<A>1 \\<A>2)(simp add: bind_map_gpv o_def ind_cpa_pk.ind_cpa.simps split_def)"], ["proof (state)\nthis:\n  ind_cpa.ind_cpa \\<A> = game0\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "}"], ["proof (state)\nthis:\n  ind_cpa.ind_cpa \\<A> = game0\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "note game0 = this"], ["proof (state)\nthis:\n  ind_cpa.ind_cpa \\<A> = game0\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have game0_alt_def: \"game0 = do {\n      x \\<leftarrow> lift_spmf (sample_uniform (order \\<G>));\n      b \\<leftarrow> lift_spmf coin_spmf;\n      (((msg1, msg2), \\<sigma>), s) \\<leftarrow> inline hash_oracle' (\\<A>1 (\\<^bold>g [^] x)) {};\n      TRY do {\n        _ :: unit \\<leftarrow> assert_gpv (valid_plains msg1 msg2);\n        cipher \\<leftarrow> aencrypt (\\<^bold>g [^] x) (if b then msg1 else msg2);\n        (guess, s') \\<leftarrow> inline hash_oracle' (\\<A>2 cipher \\<sigma>) s;\n        Done (guess = b)\n      } ELSE lift_spmf coin_spmf\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. game0 =\n    lift_spmf (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>x.\n        lift_spmf coin_spmf \\<bind>\n        (\\<lambda>b.\n            inline hash_oracle' (\\<A>1 (\\<^bold>g [^] x)) {} \\<bind>\n            (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n                TRY assert_gpv (valid_plains msg1 msg2) \\<bind>\n                    (\\<lambda>_.\n                        aencrypt (\\<^bold>g [^] x)\n                         (if b then msg1 else msg2) \\<bind>\n                        (\\<lambda>cipher.\n                            inline hash_oracle' (\\<A>2 cipher \\<sigma>)\n                             s \\<bind>\n                            (\\<lambda>(guess, s').\n                                Generative_Probabilistic_Value.Done\n                                 (guess = b)))) ELSE lift_spmf coin_spmf)))", "by(simp add: split_def game0_def key_gen_def lift_spmf_bind_spmf bind_gpv_assoc try_gpv_bind_lossless[symmetric])"], ["proof (state)\nthis:\n  game0 =\n  lift_spmf (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>x.\n      lift_spmf coin_spmf \\<bind>\n      (\\<lambda>b.\n          inline hash_oracle' (\\<A>1 (\\<^bold>g [^] x)) {} \\<bind>\n          (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n              TRY assert_gpv (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      aencrypt (\\<^bold>g [^] x)\n                       (if b then msg1 else msg2) \\<bind>\n                      (\\<lambda>cipher.\n                          inline hash_oracle' (\\<A>2 cipher \\<sigma>)\n                           s \\<bind>\n                          (\\<lambda>(guess, s').\n                              Generative_Probabilistic_Value.Done\n                               (guess = b)))) ELSE lift_spmf coin_spmf)))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "define hash_oracle'' where \"hash_oracle'' = (\\<lambda>(s, \\<sigma>) (x :: 'a). do {\n      (h, \\<sigma>') \\<leftarrow> case \\<sigma> x of\n          None \\<Rightarrow> bind_spmf (spmf_of_set (nlists UNIV len_plain)) (\\<lambda>bs. return_spmf (bs, \\<sigma>(x \\<mapsto> bs)))\n        | Some (bs :: bitstring) \\<Rightarrow> return_spmf (bs, \\<sigma>);\n      return_spmf (h, insert x s, \\<sigma>')\n    })\""], ["proof (state)\nthis:\n  hash_oracle'' =\n  (\\<lambda>(s, \\<sigma>) x.\n      (case \\<sigma> x of\n       None \\<Rightarrow>\n         spmf_of_set (nlists UNIV len_plain) \\<bind>\n         (\\<lambda>bs. return_spmf (bs, \\<sigma>(x \\<mapsto> bs)))\n       | Some bs \\<Rightarrow> return_spmf (bs, \\<sigma>)) \\<bind>\n      (\\<lambda>(h, \\<sigma>'). return_spmf (h, insert x s, \\<sigma>')))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have *: \"exec_gpv hash.oracle (inline hash_oracle' \\<A> s) \\<sigma> = \n    map_spmf (\\<lambda>(a, b, c). ((a, b), c)) (exec_gpv hash_oracle'' \\<A> (s, \\<sigma>))\" for \\<A> \\<sigma> s"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv hash.oracle (inline hash_oracle' \\<A> s) \\<sigma> =\n    map_spmf (\\<lambda>(a, b, c). ((a, b), c))\n     (exec_gpv hash_oracle'' \\<A> (s, \\<sigma>))", "by(simp add: hash_oracle'_def hash_oracle''_def hash.oracle_def Let_def exec_gpv_inline exec_gpv_bind o_def split_def cong del: option.case_cong_weak)"], ["proof (state)\nthis:\n  exec_gpv hash.oracle (inline hash_oracle' ?\\<A>7 ?s7) ?\\<sigma>7 =\n  map_spmf (\\<lambda>(a, b, c). ((a, b), c))\n   (exec_gpv hash_oracle'' ?\\<A>7 (?s7, ?\\<sigma>7))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have [simp]: \"lossless_spmf (hash_oracle'' s plain)\" for s plain"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (hash_oracle'' s plain)", "by(simp add: hash_oracle''_def Let_def split: prod.split option.split)"], ["proof (state)\nthis:\n  lossless_spmf (hash_oracle'' ?s7 ?plain7)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have [simp]: \"lossless_spmf (exec_gpv hash_oracle'' (\\<A>1 \\<alpha>) s)\" for s \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv hash_oracle'' (\\<A>1 \\<alpha>) s)", "by(rule lossless_exec_gpv[where \\<I>=\\<I>_full]) simp_all"], ["proof (state)\nthis:\n  lossless_spmf (exec_gpv hash_oracle'' (\\<A>1 ?\\<alpha>7) ?s7)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have [simp]: \"lossless_spmf (exec_gpv hash_oracle'' (\\<A>2 \\<sigma> cipher) s)\" for \\<sigma> cipher s"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv hash_oracle'' (\\<A>2 \\<sigma> cipher) s)", "by(rule lossless_exec_gpv[where \\<I>=\\<I>_full]) simp_all"], ["proof (state)\nthis:\n  lossless_spmf (exec_gpv hash_oracle'' (\\<A>2 ?\\<sigma>7 ?cipher7) ?s7)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "let ?sample = \"\\<lambda>f. bind_spmf (sample_uniform (order \\<G>)) (\\<lambda>x. bind_spmf (sample_uniform (order \\<G>)) (f x))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "define game1 where \"game1 = (\\<lambda>(x :: nat) (y :: nat). do {\n      b \\<leftarrow> coin_spmf;\n      (((msg1, msg2), \\<sigma>), (s, s_h)) \\<leftarrow> exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x)) ({}, hash.initial);\n      TRY do {\n        _ :: unit \\<leftarrow> assert_spmf (valid_plains msg1 msg2);\n        (h, s_h') \\<leftarrow> hash.oracle s_h (\\<^bold>g [^] (x * y));\n        let cipher = (\\<^bold>g [^] y, h [\\<oplus>] (if b then msg1 else msg2));\n        (guess, (s', s_h'')) \\<leftarrow> exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>) (s, s_h');\n        return_spmf (guess = b, \\<^bold>g [^] (x * y) \\<in> s')\n      } ELSE do {\n        b \\<leftarrow> coin_spmf;\n        return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s)\n      }\n    })\""], ["proof (state)\nthis:\n  game1 =\n  (\\<lambda>x y.\n      coin_spmf \\<bind>\n      (\\<lambda>b.\n          exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n           ({}, Map.empty) \\<bind>\n          (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n              TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      hash.oracle s_h (\\<^bold>g [^] (x * y)) \\<bind>\n                      (\\<lambda>(h, s_h').\n                          let cipher =\n                                (\\<^bold>g [^] y,\n                                 h [\\<oplus>] (if b then msg1 else msg2))\n                          in exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>)\n                              (s, s_h') \\<bind>\n                             (\\<lambda>(guess, s', s_h'').\n                                 return_spmf\n                                  (guess = b,\n                                   \\<^bold>g [^] (x * y)\n                                   \\<in> s')))) ELSE (coin_spmf \\<bind>\n                (\\<lambda>b.\n                    return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s))))))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have game01: \"run_gpv hash.oracle game0 hash.initial = map_spmf fst (?sample game1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_gpv hash.oracle game0 Map.empty =\n    map_spmf fst\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x))", "apply(simp add: exec_gpv_bind split_def bind_gpv_assoc aencrypt_def game0_alt_def game1_def o_def bind_map_spmf if_distribs * try_bind_assert_gpv try_bind_assert_spmf lossless_inline[where \\<I>=\\<I>_full] bind_rpv_def nat_pow_pow del: bind_spmf_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        coin_spmf \\<bind>\n        (\\<lambda>xa.\n            exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n             ({}, Map.empty) \\<bind>\n            (\\<lambda>xb.\n                if valid_plains (fst (fst (fst xb))) (snd (fst (fst xb)))\n                then sample_uniform (order \\<G>) \\<bind>\n                     (\\<lambda>xc.\n                         hash.oracle (snd (snd xb))\n                          (\\<^bold>g [^] (x * xc)) \\<bind>\n                         (\\<lambda>x.\n                             exec_gpv hash_oracle''\n                              (\\<A>2\n                                (\\<^bold>g [^] xc,\n                                 fst x [\\<oplus>]\n                                 (if xa then fst (fst (fst xb))\n                                  else snd (fst (fst xb))))\n                                (snd (fst xb)))\n                              (fst (snd xb), snd x) \\<bind>\n                             (\\<lambda>x. return_spmf (fst x = xa))))\n                else coin_spmf))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>xa.\n            coin_spmf \\<bind>\n            (\\<lambda>xb.\n                exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n                 ({}, Map.empty) \\<bind>\n                (\\<lambda>xc.\n                    if valid_plains (fst (fst (fst xc)))\n                        (snd (fst (fst xc)))\n                    then hash.oracle (snd (snd xc))\n                          (\\<^bold>g [^] (x * xa)) \\<bind>\n                         (\\<lambda>x.\n                             exec_gpv hash_oracle''\n                              (\\<A>2\n                                (\\<^bold>g [^] xa,\n                                 fst x [\\<oplus>]\n                                 (if xb then fst (fst (fst xc))\n                                  else snd (fst (fst xc))))\n                                (snd (fst xc)))\n                              (fst (snd xc), snd x) \\<bind>\n                             (\\<lambda>x. return_spmf (fst x = xb)))\n                    else coin_spmf))))", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        coin_spmf \\<bind>\n        (\\<lambda>xa.\n            exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n             ({}, Map.empty) \\<bind>\n            (\\<lambda>xb.\n                if valid_plains (fst (fst (fst xb))) (snd (fst (fst xb)))\n                then sample_uniform (order \\<G>) \\<bind>\n                     (\\<lambda>xc.\n                         hash.oracle (snd (snd xb))\n                          (\\<^bold>g [^] (x * xc)) \\<bind>\n                         (\\<lambda>x.\n                             exec_gpv hash_oracle''\n                              (\\<A>2\n                                (\\<^bold>g [^] xc,\n                                 fst x [\\<oplus>]\n                                 (if xa then fst (fst (fst xb))\n                                  else snd (fst (fst xb))))\n                                (snd (fst xb)))\n                              (fst (snd xb), snd x) \\<bind>\n                             (\\<lambda>x. return_spmf (fst x = xa))))\n                else coin_spmf))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>xa.\n            coin_spmf \\<bind>\n            (\\<lambda>xb.\n                exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n                 ({}, Map.empty) \\<bind>\n                (\\<lambda>xc.\n                    if valid_plains (fst (fst (fst xc)))\n                        (snd (fst (fst xc)))\n                    then hash.oracle (snd (snd xc))\n                          (\\<^bold>g [^] (x * xa)) \\<bind>\n                         (\\<lambda>x.\n                             exec_gpv hash_oracle''\n                              (\\<A>2\n                                (\\<^bold>g [^] xa,\n                                 fst x [\\<oplus>]\n                                 (if xb then fst (fst (fst xc))\n                                  else snd (fst (fst xc))))\n                                (snd (fst xc)))\n                              (fst (snd xc), snd x) \\<bind>\n                             (\\<lambda>x. return_spmf (fst x = xb)))\n                    else coin_spmf))))", "by(simp add: bind_rpv_def nat_pow_pow)"], ["proof (state)\nthis:\n  run_gpv hash.oracle game0 Map.empty =\n  map_spmf fst\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "define game2 where \"game2 = (\\<lambda>(x :: nat) (y :: nat). do {\n    b \\<leftarrow> coin_spmf;\n    (((msg1, msg2), \\<sigma>), (s, s_h)) \\<leftarrow> exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x)) ({}, hash.initial);\n    TRY do {\n      _ :: unit \\<leftarrow> assert_spmf (valid_plains msg1 msg2);\n      h \\<leftarrow> spmf_of_set (nlists UNIV len_plain);\n      \\<comment> \\<open>We do not do the lookup in \\<open>s_h\\<close> here, so the rest differs only if the adversary guessed \\<open>y\\<close>\\<close>\n      let cipher = (\\<^bold>g [^] y, h [\\<oplus>] (if b then msg1 else msg2));\n      (guess, (s', s_h')) \\<leftarrow> exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>) (s, s_h);\n      return_spmf (guess = b, \\<^bold>g [^] (x * y) \\<in> s')\n    } ELSE do {\n      b \\<leftarrow> coin_spmf;\n      return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s)\n    }\n  })\""], ["proof (state)\nthis:\n  game2 =\n  (\\<lambda>x y.\n      coin_spmf \\<bind>\n      (\\<lambda>b.\n          exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n           ({}, Map.empty) \\<bind>\n          (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n              TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      spmf_of_set (nlists UNIV len_plain) \\<bind>\n                      (\\<lambda>h.\n                          let cipher =\n                                (\\<^bold>g [^] y,\n                                 h [\\<oplus>] (if b then msg1 else msg2))\n                          in exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>)\n                              (s, s_h) \\<bind>\n                             (\\<lambda>(guess, s', s_h').\n                                 return_spmf\n                                  (guess = b,\n                                   \\<^bold>g [^] (x * y)\n                                   \\<in> s')))) ELSE (coin_spmf \\<bind>\n                (\\<lambda>b.\n                    return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s))))))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "interpret inv'': callee_invariant_on \"hash_oracle''\" \"\\<lambda>(s, s_h). s = dom s_h\" \\<I>_full"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant hash_oracle'' (\\<lambda>(s, s_h). s = dom s_h)", "by unfold_locales(auto simp add: hash_oracle''_def split: option.split_asm if_split)"], ["proof (state)\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have in_encrypt_oracle: \"callee_invariant hash_oracle'' (\\<lambda>(s, _). x \\<in> s)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant hash_oracle'' (\\<lambda>(s, uu_). x \\<in> s)", "by unfold_locales(auto simp add: hash_oracle''_def)"], ["proof (state)\nthis:\n  callee_invariant hash_oracle'' (\\<lambda>(s, uu_). ?x8 \\<in> s)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "{"], ["proof (state)\nthis:\n  callee_invariant hash_oracle'' (\\<lambda>(s, uu_). ?x8 \\<in> s)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "fix x y :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "let ?bad = \"\\<lambda>(s, s_h). \\<^bold>g [^] (x * y) \\<in> s\""], ["proof (state)\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "let ?X = \"\\<lambda>(s, s_h) (s', s_h'). s = dom s_h \\<and> s' = s \\<and> s_h = s_h'(\\<^bold>g [^] (x * y) := None)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have bisim:\n      \"rel_spmf (\\<lambda>(a, s1') (b, s2'). ?bad s1' = ?bad s2' \\<and> (\\<not> ?bad s2' \\<longrightarrow> a = b \\<and> ?X s1' s2'))\n             (hash_oracle'' s1 plain) (hash_oracle'' s2 plain)\"\n      if \"?X s1 s2\" for s1 s2 plain"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1') (b, s2').\n         (case s1' of\n          (s, s_h) \\<Rightarrow> \\<^bold>g [^] (x * y) \\<in> s) =\n         (case s2' of\n          (s, s_h) \\<Rightarrow> \\<^bold>g [^] (x * y) \\<in> s) \\<and>\n         (\\<not> (case s2' of\n                  (s, s_h) \\<Rightarrow>\n                    \\<^bold>g [^] (x * y) \\<in> s) \\<longrightarrow>\n          a = b \\<and>\n          (case s1' of\n           (s, s_h) \\<Rightarrow>\n             \\<lambda>(s', s_h').\n                s = dom s_h \\<and>\n                s' = s \\<and> s_h = s_h'(\\<^bold>g [^] (x * y) := None))\n           s2'))\n     (hash_oracle'' s1 plain) (hash_oracle'' s2 plain)", "using that"], ["proof (prove)\nusing this:\n  (case s1 of\n   (s, s_h) \\<Rightarrow>\n     \\<lambda>(s', s_h').\n        s = dom s_h \\<and>\n        s' = s \\<and> s_h = s_h'(\\<^bold>g [^] (x * y) := None))\n   s2\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1') (b, s2').\n         (case s1' of\n          (s, s_h) \\<Rightarrow> \\<^bold>g [^] (x * y) \\<in> s) =\n         (case s2' of\n          (s, s_h) \\<Rightarrow> \\<^bold>g [^] (x * y) \\<in> s) \\<and>\n         (\\<not> (case s2' of\n                  (s, s_h) \\<Rightarrow>\n                    \\<^bold>g [^] (x * y) \\<in> s) \\<longrightarrow>\n          a = b \\<and>\n          (case s1' of\n           (s, s_h) \\<Rightarrow>\n             \\<lambda>(s', s_h').\n                s = dom s_h \\<and>\n                s' = s \\<and> s_h = s_h'(\\<^bold>g [^] (x * y) := None))\n           s2'))\n     (hash_oracle'' s1 plain) (hash_oracle'' s2 plain)", "by(auto split: prod.splits intro!: rel_spmf_bind_reflI simp add: hash_oracle''_def rel_spmf_return_spmf2 fun_upd_twist split: option.split dest!: fun_upd_eqD)"], ["proof (state)\nthis:\n  (case ?s1.10 of\n   (s, s_h) \\<Rightarrow>\n     \\<lambda>(s', s_h').\n        s = dom s_h \\<and>\n        s' = s \\<and> s_h = s_h'(\\<^bold>g [^] (x * y) := None))\n   ?s2.10 \\<Longrightarrow>\n  rel_spmf\n   (\\<lambda>(a, s1') (b, s2').\n       (case s1' of (s, s_h) \\<Rightarrow> \\<^bold>g [^] (x * y) \\<in> s) =\n       (case s2' of\n        (s, s_h) \\<Rightarrow> \\<^bold>g [^] (x * y) \\<in> s) \\<and>\n       (\\<not> (case s2' of\n                (s, s_h) \\<Rightarrow>\n                  \\<^bold>g [^] (x * y) \\<in> s) \\<longrightarrow>\n        a = b \\<and>\n        (case s1' of\n         (s, s_h) \\<Rightarrow>\n           \\<lambda>(s', s_h').\n              s = dom s_h \\<and>\n              s' = s \\<and> s_h = s_h'(\\<^bold>g [^] (x * y) := None))\n         s2'))\n   (hash_oracle'' ?s1.10 ?plain10) (hash_oracle'' ?s2.10 ?plain10)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have inv: \"callee_invariant hash_oracle'' ?bad\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant hash_oracle''\n     (\\<lambda>(s, s_h). \\<^bold>g [^] (x * y) \\<in> s)", "by(unfold_locales)(auto simp add: hash_oracle''_def split: option.split_asm)"], ["proof (state)\nthis:\n  callee_invariant hash_oracle''\n   (\\<lambda>(s, s_h). \\<^bold>g [^] (x * y) \\<in> s)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"rel_spmf (\\<lambda>(win, bad) (win', bad'). bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> win = win')) (game2 x y) (game1 x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(win, bad) (win', bad').\n         bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> win = win'))\n     (game2 x y) (game1 x y)", "unfolding game1_def game2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(win, bad) (win', bad').\n         bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> win = win'))\n     (coin_spmf \\<bind>\n      (\\<lambda>b.\n          exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n           ({}, Map.empty) \\<bind>\n          (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n              TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      spmf_of_set (nlists UNIV len_plain) \\<bind>\n                      (\\<lambda>h.\n                          let cipher =\n                                (\\<^bold>g [^] y,\n                                 h [\\<oplus>] (if b then msg1 else msg2))\n                          in exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>)\n                              (s, s_h) \\<bind>\n                             (\\<lambda>(guess, s', s_h').\n                                 return_spmf\n                                  (guess = b,\n                                   \\<^bold>g [^] (x * y)\n                                   \\<in> s')))) ELSE (coin_spmf \\<bind>\n                (\\<lambda>b.\n                    return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s))))))\n     (coin_spmf \\<bind>\n      (\\<lambda>b.\n          exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n           ({}, Map.empty) \\<bind>\n          (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n              TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      hash.oracle s_h (\\<^bold>g [^] (x * y)) \\<bind>\n                      (\\<lambda>(h, s_h').\n                          let cipher =\n                                (\\<^bold>g [^] y,\n                                 h [\\<oplus>] (if b then msg1 else msg2))\n                          in exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>)\n                              (s, s_h') \\<bind>\n                             (\\<lambda>(guess, s', s_h'').\n                                 return_spmf\n                                  (guess = b,\n                                   \\<^bold>g [^] (x * y)\n                                   \\<in> s')))) ELSE (coin_spmf \\<bind>\n                (\\<lambda>b.\n                    return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s))))))", "apply(clarsimp simp add: split_def o_def hash.oracle_def rel_spmf_bind_reflI if_distribs intro!: rel_spmf_bind_reflI simp del: bind_spmf_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa a b ba aa baa.\n       (((a, b), ba), aa, baa)\n       \\<in> set_spmf\n              (exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n                ({}, Map.empty)) \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>p pa.\n            snd p = snd pa \\<and>\n            (\\<not> snd pa \\<longrightarrow> fst p = fst pa))\n        (TRY assert_spmf (valid_plains a b) \\<bind>\n             (\\<lambda>_.\n                 spmf_of_set (nlists UNIV len_plain) \\<bind>\n                 (\\<lambda>h.\n                     exec_gpv hash_oracle''\n                      (\\<A>2\n                        (\\<^bold>g [^] y,\n                         h [\\<oplus>] (if xa then a else b))\n                        ba)\n                      (aa, baa) \\<bind>\n                     (\\<lambda>p.\n                         return_spmf\n                          (fst p = xa,\n                           \\<^bold>g [^] (x * y)\n                           \\<in> fst (snd\n p))))) ELSE (coin_spmf \\<bind>\n              (\\<lambda>b.\n                  return_spmf (b, \\<^bold>g [^] (x * y) \\<in> aa))))\n        (TRY assert_spmf (valid_plains a b) \\<bind>\n             (\\<lambda>_.\n                 (case baa (\\<^bold>g [^] (x * y)) of\n                  None \\<Rightarrow>\n                    spmf_of_set (nlists UNIV len_plain) \\<bind>\n                    (\\<lambda>bs.\n                        return_spmf\n                         (bs, snd (snd (((a, b), ba), aa, baa))\n                          (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                  | Some bs \\<Rightarrow>\n                      return_spmf\n                       (bs, snd (snd (((a, b), ba), aa, baa)))) \\<bind>\n                 (\\<lambda>p.\n                     exec_gpv hash_oracle''\n                      (\\<A>2\n                        (\\<^bold>g [^] y,\n                         fst p [\\<oplus>] (if xa then a else b))\n                        ba)\n                      (aa, snd p) \\<bind>\n                     (\\<lambda>p.\n                         return_spmf\n                          (fst p = xa,\n                           \\<^bold>g [^] (x * y)\n                           \\<in> fst (snd\n p))))) ELSE (coin_spmf \\<bind>\n              (\\<lambda>b.\n                  return_spmf (b, \\<^bold>g [^] (x * y) \\<in> aa))))", "apply(rule rel_spmf_try_spmf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a b ba aa bb.\n       (((a, b), ba), aa, bb)\n       \\<in> set_spmf\n              (exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n                ({}, Map.empty)) \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>p pa.\n            snd p = snd pa \\<and>\n            (\\<not> snd pa \\<longrightarrow> fst p = fst pa))\n        (assert_spmf (valid_plains a b) \\<bind>\n         (\\<lambda>_.\n             spmf_of_set (nlists UNIV len_plain) \\<bind>\n             (\\<lambda>h.\n                 exec_gpv hash_oracle''\n                  (\\<A>2\n                    (\\<^bold>g [^] y, h [\\<oplus>] (if xa then a else b))\n                    ba)\n                  (aa, bb) \\<bind>\n                 (\\<lambda>p.\n                     return_spmf\n                      (fst p = xa,\n                       \\<^bold>g [^] (x * y) \\<in> fst (snd p))))))\n        (assert_spmf (valid_plains a b) \\<bind>\n         (\\<lambda>_.\n             (case bb (\\<^bold>g [^] (x * y)) of\n              None \\<Rightarrow>\n                spmf_of_set (nlists UNIV len_plain) \\<bind>\n                (\\<lambda>bs.\n                    return_spmf\n                     (bs, snd (snd (((a, b), ba), aa, bb))\n                      (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n              | Some bs \\<Rightarrow>\n                  return_spmf\n                   (bs, snd (snd (((a, b), ba), aa, bb)))) \\<bind>\n             (\\<lambda>p.\n                 exec_gpv hash_oracle''\n                  (\\<A>2\n                    (\\<^bold>g [^] y,\n                     fst p [\\<oplus>] (if xa then a else b))\n                    ba)\n                  (aa, snd p) \\<bind>\n                 (\\<lambda>p.\n                     return_spmf\n                      (fst p = xa,\n                       \\<^bold>g [^] (x * y) \\<in> fst (snd p))))))\n 2. \\<And>xa a b ba aa bb.\n       \\<lbrakk>(((a, b), ba), aa, bb)\n                \\<in> set_spmf\n                       (exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n                         ({}, Map.empty));\n        \\<not> lossless_spmf\n                (assert_spmf (valid_plains a b) \\<bind>\n                 (\\<lambda>_.\n                     (case bb (\\<^bold>g [^] (x * y)) of\n                      None \\<Rightarrow>\n                        spmf_of_set (nlists UNIV len_plain) \\<bind>\n                        (\\<lambda>bs.\n                            return_spmf\n                             (bs, snd (snd (((a, b), ba), aa, bb))\n                              (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                      | Some bs \\<Rightarrow>\n                          return_spmf\n                           (bs, snd (snd (((a, b), ba), aa, bb)))) \\<bind>\n                     (\\<lambda>p.\n                         exec_gpv hash_oracle''\n                          (\\<A>2\n                            (\\<^bold>g [^] y,\n                             fst p [\\<oplus>] (if xa then a else b))\n                            ba)\n                          (aa, snd p) \\<bind>\n                         (\\<lambda>p.\n                             return_spmf\n                              (fst p = xa,\n                               \\<^bold>g [^] (x * y)\n                               \\<in> fst (snd p))))))\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (\\<lambda>p pa.\n                              snd p = snd pa \\<and>\n                              (\\<not> snd pa \\<longrightarrow>\n                               fst p = fst pa))\n                          (coin_spmf \\<bind>\n                           (\\<lambda>b.\n                               return_spmf\n                                (b, \\<^bold>g [^] (x * y) \\<in> aa)))\n                          (coin_spmf \\<bind>\n                           (\\<lambda>b.\n                               return_spmf\n                                (b, \\<^bold>g [^] (x * y) \\<in> aa)))", "subgoal for b msg1 msg2 \\<sigma> s s_h"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((msg1, msg2), \\<sigma>), s, s_h)\n    \\<in> set_spmf\n           (exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n             ({}, Map.empty)) \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>p pa.\n         snd p = snd pa \\<and>\n         (\\<not> snd pa \\<longrightarrow> fst p = fst pa))\n     (assert_spmf (valid_plains msg1 msg2) \\<bind>\n      (\\<lambda>_.\n          spmf_of_set (nlists UNIV len_plain) \\<bind>\n          (\\<lambda>h.\n              exec_gpv hash_oracle''\n               (\\<A>2\n                 (\\<^bold>g [^] y, h [\\<oplus>] (if b then msg1 else msg2))\n                 \\<sigma>)\n               (s, s_h) \\<bind>\n              (\\<lambda>p.\n                  return_spmf\n                   (fst p = b, \\<^bold>g [^] (x * y) \\<in> fst (snd p))))))\n     (assert_spmf (valid_plains msg1 msg2) \\<bind>\n      (\\<lambda>_.\n          (case s_h (\\<^bold>g [^] (x * y)) of\n           None \\<Rightarrow>\n             spmf_of_set (nlists UNIV len_plain) \\<bind>\n             (\\<lambda>bs.\n                 return_spmf\n                  (bs, snd (snd (((msg1, msg2), \\<sigma>), s, s_h))\n                   (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n           | Some bs \\<Rightarrow>\n               return_spmf\n                (bs, snd (snd (((msg1, msg2), \\<sigma>), s, s_h)))) \\<bind>\n          (\\<lambda>p.\n              exec_gpv hash_oracle''\n               (\\<A>2\n                 (\\<^bold>g [^] y,\n                  fst p [\\<oplus>] (if b then msg1 else msg2))\n                 \\<sigma>)\n               (s, snd p) \\<bind>\n              (\\<lambda>p.\n                  return_spmf\n                   (fst p = b, \\<^bold>g [^] (x * y) \\<in> fst (snd p))))))", "apply(rule rel_spmf_bind_reflI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>(((msg1, msg2), \\<sigma>), s, s_h)\n                \\<in> set_spmf\n                       (exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n                         ({}, Map.empty));\n        xa \\<in> set_spmf (assert_spmf (valid_plains msg1 msg2))\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (\\<lambda>p pa.\n                              snd p = snd pa \\<and>\n                              (\\<not> snd pa \\<longrightarrow>\n                               fst p = fst pa))\n                          (spmf_of_set (nlists UNIV len_plain) \\<bind>\n                           (\\<lambda>h.\n                               exec_gpv hash_oracle''\n                                (\\<A>2\n                                  (\\<^bold>g [^] y,\n                                   h [\\<oplus>] (if b then msg1 else msg2))\n                                  \\<sigma>)\n                                (s, s_h) \\<bind>\n                               (\\<lambda>p.\n                                   return_spmf\n                                    (fst p = b,\n                                     \\<^bold>g [^] (x * y)\n                                     \\<in> fst (snd p)))))\n                          ((case s_h (\\<^bold>g [^] (x * y)) of\n                            None \\<Rightarrow>\n                              spmf_of_set (nlists UNIV len_plain) \\<bind>\n                              (\\<lambda>bs.\n                                  return_spmf\n                                   (bs,\n                                    snd (snd\n    (((msg1, msg2), \\<sigma>), s, s_h))\n                                    (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                            | Some bs \\<Rightarrow>\n                                return_spmf\n                                 (bs,\n                                  snd (snd\n  (((msg1, msg2), \\<sigma>), s, s_h)))) \\<bind>\n                           (\\<lambda>p.\n                               exec_gpv hash_oracle''\n                                (\\<A>2\n                                  (\\<^bold>g [^] y,\n                                   fst p [\\<oplus>]\n                                   (if b then msg1 else msg2))\n                                  \\<sigma>)\n                                (s, snd p) \\<bind>\n                               (\\<lambda>p.\n                                   return_spmf\n                                    (fst p = b,\n                                     \\<^bold>g [^] (x * y)\n                                     \\<in> fst (snd p)))))", "apply(drule inv''.exec_gpv_invariant; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_plains msg1 msg2; s = dom s_h\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (\\<lambda>p pa.\n                           snd p = snd pa \\<and>\n                           (\\<not> snd pa \\<longrightarrow> fst p = fst pa))\n                       (spmf_of_set (nlists UNIV len_plain) \\<bind>\n                        (\\<lambda>h.\n                            exec_gpv hash_oracle''\n                             (\\<A>2\n                               (\\<^bold>g [^] y,\n                                h [\\<oplus>] (if b then msg1 else msg2))\n                               \\<sigma>)\n                             (dom s_h, s_h) \\<bind>\n                            (\\<lambda>p.\n                                return_spmf\n                                 (fst p = b,\n                                  \\<^bold>g [^] (x * y)\n                                  \\<in> fst (snd p)))))\n                       ((case s_h (\\<^bold>g [^] (x * y)) of\n                         None \\<Rightarrow>\n                           spmf_of_set (nlists UNIV len_plain) \\<bind>\n                           (\\<lambda>bs.\n                               return_spmf\n                                (bs,\n                                 snd (snd\n (((msg1, msg2), \\<sigma>), dom s_h, s_h))\n                                 (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                         | Some bs \\<Rightarrow>\n                             return_spmf\n                              (bs,\n                               snd (snd (((msg1, msg2), \\<sigma>), dom s_h,\n   s_h)))) \\<bind>\n                        (\\<lambda>p.\n                            exec_gpv hash_oracle''\n                             (\\<A>2\n                               (\\<^bold>g [^] y,\n                                fst p [\\<oplus>] (if b then msg1 else msg2))\n                               \\<sigma>)\n                             (dom s_h, snd p) \\<bind>\n                            (\\<lambda>p.\n                                return_spmf\n                                 (fst p = b,\n                                  \\<^bold>g [^] (x * y)\n                                  \\<in> fst (snd p)))))", "apply(cases \"s_h (\\<^bold>g [^] (x * y))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_plains msg1 msg2; s = dom s_h;\n     s_h (\\<^bold>g [^] (x * y)) = None\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (\\<lambda>p pa.\n                           snd p = snd pa \\<and>\n                           (\\<not> snd pa \\<longrightarrow> fst p = fst pa))\n                       (spmf_of_set (nlists UNIV len_plain) \\<bind>\n                        (\\<lambda>h.\n                            exec_gpv hash_oracle''\n                             (\\<A>2\n                               (\\<^bold>g [^] y,\n                                h [\\<oplus>] (if b then msg1 else msg2))\n                               \\<sigma>)\n                             (dom s_h, s_h) \\<bind>\n                            (\\<lambda>p.\n                                return_spmf\n                                 (fst p = b,\n                                  \\<^bold>g [^] (x * y)\n                                  \\<in> fst (snd p)))))\n                       ((case s_h (\\<^bold>g [^] (x * y)) of\n                         None \\<Rightarrow>\n                           spmf_of_set (nlists UNIV len_plain) \\<bind>\n                           (\\<lambda>bs.\n                               return_spmf\n                                (bs,\n                                 snd (snd\n (((msg1, msg2), \\<sigma>), dom s_h, s_h))\n                                 (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                         | Some bs \\<Rightarrow>\n                             return_spmf\n                              (bs,\n                               snd (snd (((msg1, msg2), \\<sigma>), dom s_h,\n   s_h)))) \\<bind>\n                        (\\<lambda>p.\n                            exec_gpv hash_oracle''\n                             (\\<A>2\n                               (\\<^bold>g [^] y,\n                                fst p [\\<oplus>] (if b then msg1 else msg2))\n                               \\<sigma>)\n                             (dom s_h, snd p) \\<bind>\n                            (\\<lambda>p.\n                                return_spmf\n                                 (fst p = b,\n                                  \\<^bold>g [^] (x * y)\n                                  \\<in> fst (snd p)))))\n 2. \\<And>a.\n       \\<lbrakk>valid_plains msg1 msg2; s = dom s_h;\n        s_h (\\<^bold>g [^] (x * y)) = Some a\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (\\<lambda>p pa.\n                              snd p = snd pa \\<and>\n                              (\\<not> snd pa \\<longrightarrow>\n                               fst p = fst pa))\n                          (spmf_of_set (nlists UNIV len_plain) \\<bind>\n                           (\\<lambda>h.\n                               exec_gpv hash_oracle''\n                                (\\<A>2\n                                  (\\<^bold>g [^] y,\n                                   h [\\<oplus>] (if b then msg1 else msg2))\n                                  \\<sigma>)\n                                (dom s_h, s_h) \\<bind>\n                               (\\<lambda>p.\n                                   return_spmf\n                                    (fst p = b,\n                                     \\<^bold>g [^] (x * y)\n                                     \\<in> fst (snd p)))))\n                          ((case s_h (\\<^bold>g [^] (x * y)) of\n                            None \\<Rightarrow>\n                              spmf_of_set (nlists UNIV len_plain) \\<bind>\n                              (\\<lambda>bs.\n                                  return_spmf\n                                   (bs,\n                                    snd (snd\n    (((msg1, msg2), \\<sigma>), dom s_h, s_h))\n                                    (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                            | Some bs \\<Rightarrow>\n                                return_spmf\n                                 (bs,\n                                  snd (snd\n  (((msg1, msg2), \\<sigma>), dom s_h, s_h)))) \\<bind>\n                           (\\<lambda>p.\n                               exec_gpv hash_oracle''\n                                (\\<A>2\n                                  (\\<^bold>g [^] y,\n                                   fst p [\\<oplus>]\n                                   (if b then msg1 else msg2))\n                                  \\<sigma>)\n                                (dom s_h, snd p) \\<bind>\n                               (\\<lambda>p.\n                                   return_spmf\n                                    (fst p = b,\n                                     \\<^bold>g [^] (x * y)\n                                     \\<in> fst (snd p)))))", "subgoal \\<comment> \\<open>case @{const None}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_plains msg1 msg2; s = dom s_h;\n     s_h (\\<^bold>g [^] (x * y)) = None\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (\\<lambda>p pa.\n                           snd p = snd pa \\<and>\n                           (\\<not> snd pa \\<longrightarrow> fst p = fst pa))\n                       (spmf_of_set (nlists UNIV len_plain) \\<bind>\n                        (\\<lambda>h.\n                            exec_gpv hash_oracle''\n                             (\\<A>2\n                               (\\<^bold>g [^] y,\n                                h [\\<oplus>] (if b then msg1 else msg2))\n                               \\<sigma>)\n                             (dom s_h, s_h) \\<bind>\n                            (\\<lambda>p.\n                                return_spmf\n                                 (fst p = b,\n                                  \\<^bold>g [^] (x * y)\n                                  \\<in> fst (snd p)))))\n                       ((case s_h (\\<^bold>g [^] (x * y)) of\n                         None \\<Rightarrow>\n                           spmf_of_set (nlists UNIV len_plain) \\<bind>\n                           (\\<lambda>bs.\n                               return_spmf\n                                (bs,\n                                 snd (snd\n (((msg1, msg2), \\<sigma>), dom s_h, s_h))\n                                 (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                         | Some bs \\<Rightarrow>\n                             return_spmf\n                              (bs,\n                               snd (snd (((msg1, msg2), \\<sigma>), dom s_h,\n   s_h)))) \\<bind>\n                        (\\<lambda>p.\n                            exec_gpv hash_oracle''\n                             (\\<A>2\n                               (\\<^bold>g [^] y,\n                                fst p [\\<oplus>] (if b then msg1 else msg2))\n                               \\<sigma>)\n                             (dom s_h, snd p) \\<bind>\n                            (\\<lambda>p.\n                                return_spmf\n                                 (fst p = b,\n                                  \\<^bold>g [^] (x * y)\n                                  \\<in> fst (snd p)))))", "apply(clarsimp intro!: rel_spmf_bind_reflI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>valid_plains msg1 msg2; s = dom s_h;\n        s_h (\\<^bold>g [^] (x * y)) = None;\n        xa \\<in> nlists UNIV len_plain\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (\\<lambda>p pa.\n                              snd p = snd pa \\<and>\n                              (\\<not> snd pa \\<longrightarrow>\n                               fst p = fst pa))\n                          (exec_gpv hash_oracle''\n                            (\\<A>2\n                              (\\<^bold>g [^] y,\n                               xa [\\<oplus>] (if b then msg1 else msg2))\n                              \\<sigma>)\n                            (dom s_h, s_h) \\<bind>\n                           (\\<lambda>p.\n                               return_spmf\n                                (fst p = b,\n                                 \\<^bold>g [^] (x * y) \\<in> fst (snd p))))\n                          (exec_gpv hash_oracle''\n                            (\\<A>2\n                              (\\<^bold>g [^] y,\n                               xa [\\<oplus>] (if b then msg1 else msg2))\n                              \\<sigma>)\n                            (dom s_h, s_h(\\<^bold>g [^] (x * y) \\<mapsto>\n                             xa)) \\<bind>\n                           (\\<lambda>p.\n                               return_spmf\n                                (fst p = b,\n                                 \\<^bold>g [^] (x * y) \\<in> fst (snd p))))", "apply(rule rel_spmf_bindI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>valid_plains msg1 msg2; s = dom s_h;\n        s_h (\\<^bold>g [^] (x * y)) = None;\n        xa \\<in> nlists UNIV len_plain\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (?R3 xa)\n                          (exec_gpv hash_oracle''\n                            (\\<A>2\n                              (\\<^bold>g [^] y,\n                               xa [\\<oplus>] (if b then msg1 else msg2))\n                              \\<sigma>)\n                            (dom s_h, s_h))\n                          (exec_gpv hash_oracle''\n                            (\\<A>2\n                              (\\<^bold>g [^] y,\n                               xa [\\<oplus>] (if b then msg1 else msg2))\n                              \\<sigma>)\n                            (dom s_h, s_h(\\<^bold>g [^] (x * y) \\<mapsto>\n                             xa)))\n 2. \\<And>xa xaa ya.\n       \\<lbrakk>valid_plains msg1 msg2; s = dom s_h;\n        s_h (\\<^bold>g [^] (x * y)) = None; xa \\<in> nlists UNIV len_plain;\n        ?R3 xa xaa ya\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (\\<lambda>p pa.\n                              snd p = snd pa \\<and>\n                              (\\<not> snd pa \\<longrightarrow>\n                               fst p = fst pa))\n                          (return_spmf\n                            (fst xaa = b,\n                             \\<^bold>g [^] (x * y) \\<in> fst (snd xaa)))\n                          (return_spmf\n                            (fst ya = b,\n                             \\<^bold>g [^] (x * y) \\<in> fst (snd ya)))", "apply(rule exec_gpv_oracle_bisim_bad_full[OF _ _ bisim inv inv, where R=\"\\<lambda>(x, s1) (y, s2). ?bad s1 = ?bad s2 \\<and> (\\<not> ?bad s2 \\<longrightarrow> x = y)\"]; clarsimp simp add: fun_upd_idem; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xaa ya.\n       \\<lbrakk>valid_plains msg1 msg2; s = dom s_h;\n        s_h (\\<^bold>g [^] (x * y)) = None; xa \\<in> nlists UNIV len_plain;\n        (case xaa of\n         (xa, s1) \\<Rightarrow>\n           \\<lambda>(ya, s2).\n              (case s1 of\n               (s, s_h) \\<Rightarrow> \\<^bold>g [^] (x * y) \\<in> s) =\n              (case s2 of\n               (s, s_h) \\<Rightarrow> \\<^bold>g [^] (x * y) \\<in> s) \\<and>\n              (\\<not> (case s2 of\n                       (s, s_h) \\<Rightarrow>\n                         \\<^bold>g [^] (x * y) \\<in> s) \\<longrightarrow>\n               xa = ya))\n         ya\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (\\<lambda>p pa.\n                              snd p = snd pa \\<and>\n                              (\\<not> snd pa \\<longrightarrow>\n                               fst p = fst pa))\n                          (return_spmf\n                            (fst xaa = b,\n                             \\<^bold>g [^] (x * y) \\<in> fst (snd xaa)))\n                          (return_spmf\n                            (fst ya = b,\n                             \\<^bold>g [^] (x * y) \\<in> fst (snd ya)))", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>valid_plains msg1 msg2; s = dom s_h;\n        s_h (\\<^bold>g [^] (x * y)) = Some a\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (\\<lambda>p pa.\n                              snd p = snd pa \\<and>\n                              (\\<not> snd pa \\<longrightarrow>\n                               fst p = fst pa))\n                          (spmf_of_set (nlists UNIV len_plain) \\<bind>\n                           (\\<lambda>h.\n                               exec_gpv hash_oracle''\n                                (\\<A>2\n                                  (\\<^bold>g [^] y,\n                                   h [\\<oplus>] (if b then msg1 else msg2))\n                                  \\<sigma>)\n                                (dom s_h, s_h) \\<bind>\n                               (\\<lambda>p.\n                                   return_spmf\n                                    (fst p = b,\n                                     \\<^bold>g [^] (x * y)\n                                     \\<in> fst (snd p)))))\n                          ((case s_h (\\<^bold>g [^] (x * y)) of\n                            None \\<Rightarrow>\n                              spmf_of_set (nlists UNIV len_plain) \\<bind>\n                              (\\<lambda>bs.\n                                  return_spmf\n                                   (bs,\n                                    snd (snd\n    (((msg1, msg2), \\<sigma>), dom s_h, s_h))\n                                    (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                            | Some bs \\<Rightarrow>\n                                return_spmf\n                                 (bs,\n                                  snd (snd\n  (((msg1, msg2), \\<sigma>), dom s_h, s_h)))) \\<bind>\n                           (\\<lambda>p.\n                               exec_gpv hash_oracle''\n                                (\\<A>2\n                                  (\\<^bold>g [^] y,\n                                   fst p [\\<oplus>]\n                                   (if b then msg1 else msg2))\n                                  \\<sigma>)\n                                (dom s_h, snd p) \\<bind>\n                               (\\<lambda>p.\n                                   return_spmf\n                                    (fst p = b,\n                                     \\<^bold>g [^] (x * y)\n                                     \\<in> fst (snd p)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_plains msg1 msg2; s = dom s_h;\n     s_h (\\<^bold>g [^] (x * y)) = Some a_\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (\\<lambda>p pa.\n                           snd p = snd pa \\<and>\n                           (\\<not> snd pa \\<longrightarrow> fst p = fst pa))\n                       (spmf_of_set (nlists UNIV len_plain) \\<bind>\n                        (\\<lambda>h.\n                            exec_gpv hash_oracle''\n                             (\\<A>2\n                               (\\<^bold>g [^] y,\n                                h [\\<oplus>] (if b then msg1 else msg2))\n                               \\<sigma>)\n                             (dom s_h, s_h) \\<bind>\n                            (\\<lambda>p.\n                                return_spmf\n                                 (fst p = b,\n                                  \\<^bold>g [^] (x * y)\n                                  \\<in> fst (snd p)))))\n                       ((case s_h (\\<^bold>g [^] (x * y)) of\n                         None \\<Rightarrow>\n                           spmf_of_set (nlists UNIV len_plain) \\<bind>\n                           (\\<lambda>bs.\n                               return_spmf\n                                (bs,\n                                 snd (snd\n (((msg1, msg2), \\<sigma>), dom s_h, s_h))\n                                 (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                         | Some bs \\<Rightarrow>\n                             return_spmf\n                              (bs,\n                               snd (snd (((msg1, msg2), \\<sigma>), dom s_h,\n   s_h)))) \\<bind>\n                        (\\<lambda>p.\n                            exec_gpv hash_oracle''\n                             (\\<A>2\n                               (\\<^bold>g [^] y,\n                                fst p [\\<oplus>] (if b then msg1 else msg2))\n                               \\<sigma>)\n                             (dom s_h, snd p) \\<bind>\n                            (\\<lambda>p.\n                                return_spmf\n                                 (fst p = b,\n                                  \\<^bold>g [^] (x * y)\n                                  \\<in> fst (snd p)))))", "by(auto intro!: rel_spmf_bindI1 rel_spmf_bindI2 lossless_exec_gpv[where \\<I>=\\<I>_full] dest!: callee_invariant_on.exec_gpv_invariant[OF in_encrypt_oracle])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa a b ba aa bb.\n       \\<lbrakk>(((a, b), ba), aa, bb)\n                \\<in> set_spmf\n                       (exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n                         ({}, Map.empty));\n        \\<not> lossless_spmf\n                (assert_spmf (valid_plains a b) \\<bind>\n                 (\\<lambda>_.\n                     (case bb (\\<^bold>g [^] (x * y)) of\n                      None \\<Rightarrow>\n                        spmf_of_set (nlists UNIV len_plain) \\<bind>\n                        (\\<lambda>bs.\n                            return_spmf\n                             (bs, snd (snd (((a, b), ba), aa, bb))\n                              (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                      | Some bs \\<Rightarrow>\n                          return_spmf\n                           (bs, snd (snd (((a, b), ba), aa, bb)))) \\<bind>\n                     (\\<lambda>p.\n                         exec_gpv hash_oracle''\n                          (\\<A>2\n                            (\\<^bold>g [^] y,\n                             fst p [\\<oplus>] (if xa then a else b))\n                            ba)\n                          (aa, snd p) \\<bind>\n                         (\\<lambda>p.\n                             return_spmf\n                              (fst p = xa,\n                               \\<^bold>g [^] (x * y)\n                               \\<in> fst (snd p))))))\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (\\<lambda>p pa.\n                              snd p = snd pa \\<and>\n                              (\\<not> snd pa \\<longrightarrow>\n                               fst p = fst pa))\n                          (coin_spmf \\<bind>\n                           (\\<lambda>b.\n                               return_spmf\n                                (b, \\<^bold>g [^] (x * y) \\<in> aa)))\n                          (coin_spmf \\<bind>\n                           (\\<lambda>b.\n                               return_spmf\n                                (b, \\<^bold>g [^] (x * y) \\<in> aa)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(((a_, b_), ba_), aa_, bb_)\n             \\<in> set_spmf\n                    (exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n                      ({}, Map.empty));\n     \\<not> lossless_spmf\n             (assert_spmf (valid_plains a_ b_) \\<bind>\n              (\\<lambda>_.\n                  (case bb_ (\\<^bold>g [^] (x * y)) of\n                   None \\<Rightarrow>\n                     spmf_of_set (nlists UNIV len_plain) \\<bind>\n                     (\\<lambda>bs.\n                         return_spmf\n                          (bs, snd (snd (((a_, b_), ba_), aa_, bb_))\n                           (\\<^bold>g [^] (x * y) \\<mapsto> bs)))\n                   | Some bs \\<Rightarrow>\n                       return_spmf\n                        (bs, snd (snd (((a_, b_), ba_), aa_, bb_)))) \\<bind>\n                  (\\<lambda>p.\n                      exec_gpv hash_oracle''\n                       (\\<A>2\n                         (\\<^bold>g [^] y,\n                          fst p [\\<oplus>] (if xa_ then a_ else b_))\n                         ba_)\n                       (aa_, snd p) \\<bind>\n                      (\\<lambda>p.\n                          return_spmf\n                           (fst p = xa_,\n                            \\<^bold>g [^] (x * y)\n                            \\<in> fst (snd p))))))\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (\\<lambda>p pa.\n                           snd p = snd pa \\<and>\n                           (\\<not> snd pa \\<longrightarrow> fst p = fst pa))\n                       (coin_spmf \\<bind>\n                        (\\<lambda>b.\n                            return_spmf\n                             (b, \\<^bold>g [^] (x * y) \\<in> aa_)))\n                       (coin_spmf \\<bind>\n                        (\\<lambda>b.\n                            return_spmf\n                             (b, \\<^bold>g [^] (x * y) \\<in> aa_)))", "by(rule rel_spmf_reflI) simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(win, bad) (win', bad').\n       bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> win = win'))\n   (game2 x y) (game1 x y)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "}"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(win, bad) (win', bad').\n       bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> win = win'))\n   (game2 ?x10 ?y10) (game1 ?x10 ?y10)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "hence \"rel_spmf (\\<lambda>(win, bad) (win', bad'). (bad \\<longleftrightarrow> bad') \\<and> (\\<not> bad' \\<longrightarrow> win \\<longleftrightarrow> win')) (?sample game2) (?sample game1)\""], ["proof (prove)\nusing this:\n  rel_spmf\n   (\\<lambda>(win, bad) (win', bad').\n       bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> win = win'))\n   (game2 ?x10 ?y10) (game1 ?x10 ?y10)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(win, bad) (win', bad').\n         bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> win = win'))\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x))\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x))", "by(intro rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(win, bad) (win', bad').\n       bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> win = win'))\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x))\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "hence \"\\<bar>measure (measure_spmf (?sample game2)) {(x, _). x} - measure (measure_spmf (?sample game1)) {(y, _). y}\\<bar>\n        \\<le> measure (measure_spmf (?sample game2)) {(_, bad). bad}\""], ["proof (prove)\nusing this:\n  rel_spmf\n   (\\<lambda>(win, bad) (win', bad').\n       bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> win = win'))\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x))\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x))\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure\n           (measure_spmf\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n           {(x, uu_). x} -\n          Sigma_Algebra.measure\n           (measure_spmf\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n           {(y, uu_). y}\\<bar>\n    \\<le> Sigma_Algebra.measure\n           (measure_spmf\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n           {(uu_, bad). bad}", "unfolding split_def"], ["proof (prove)\nusing this:\n  rel_spmf\n   (\\<lambda>p pa.\n       snd p = snd pa \\<and>\n       (\\<not> snd pa \\<longrightarrow> fst p = fst pa))\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x))\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x))\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure\n           (measure_spmf\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n           {p. fst p} -\n          Sigma_Algebra.measure\n           (measure_spmf\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n           {p. fst p}\\<bar>\n    \\<le> Sigma_Algebra.measure\n           (measure_spmf\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n           {p. snd p}", "by(rule fundamental_lemma)"], ["proof (state)\nthis:\n  \\<bar>Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         {(x, uu_). x} -\n        Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         {(y, uu_). y}\\<bar>\n  \\<le> Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         {(uu_, bad). bad}\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "moreover"], ["proof (state)\nthis:\n  \\<bar>Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         {(x, uu_). x} -\n        Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         {(y, uu_). y}\\<bar>\n  \\<le> Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         {(uu_, bad). bad}\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"measure (measure_spmf (?sample game2)) {(x, _). x} = spmf (map_spmf fst (?sample game2)) True\"\n    and \"measure (measure_spmf (?sample game1)) {(y, _). y} = spmf (map_spmf fst (?sample game1)) True\"\n    and \"measure (measure_spmf (?sample game2)) {(_, bad). bad} = spmf (map_spmf snd (?sample game2)) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n     {(x, uu_). x} =\n    spmf\n     (map_spmf fst\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n     True &&&\n    Sigma_Algebra.measure\n     (measure_spmf\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n     {(y, uu_). y} =\n    spmf\n     (map_spmf fst\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n     True &&&\n    Sigma_Algebra.measure\n     (measure_spmf\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n     {(uu_, bad). bad} =\n    spmf\n     (map_spmf snd\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n     True", "unfolding spmf_conv_measure_spmf measure_map_spmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (measure_spmf\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n     {(x, uu_). x} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n     (fst -` {True}) &&&\n    Sigma_Algebra.measure\n     (measure_spmf\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n     {(y, uu_). y} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n     (fst -` {True}) &&&\n    Sigma_Algebra.measure\n     (measure_spmf\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n     {(uu_, bad). bad} =\n    Sigma_Algebra.measure\n     (measure_spmf\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n     (snd -` {True})", "by(rule arg_cong2[where f=measure]; fastforce)+"], ["proof (state)\nthis:\n  Sigma_Algebra.measure\n   (measure_spmf\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   {(x, uu_). x} =\n  spmf\n   (map_spmf fst\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   True\n  Sigma_Algebra.measure\n   (measure_spmf\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n   {(y, uu_). y} =\n  spmf\n   (map_spmf fst\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n   True\n  Sigma_Algebra.measure\n   (measure_spmf\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   {(uu_, bad). bad} =\n  spmf\n   (map_spmf snd\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   True\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         {(x, uu_). x} -\n        Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         {(y, uu_). y}\\<bar>\n  \\<le> Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         {(uu_, bad). bad}\n  Sigma_Algebra.measure\n   (measure_spmf\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   {(x, uu_). x} =\n  spmf\n   (map_spmf fst\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   True\n  Sigma_Algebra.measure\n   (measure_spmf\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n   {(y, uu_). y} =\n  spmf\n   (map_spmf fst\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n   True\n  Sigma_Algebra.measure\n   (measure_spmf\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   {(uu_, bad). bad} =\n  spmf\n   (map_spmf snd\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   True", "have hop23: \"\\<bar>spmf (map_spmf fst (?sample game2)) True - spmf (map_spmf fst (?sample game1)) True\\<bar> \\<le> spmf (map_spmf snd (?sample game2)) True\""], ["proof (prove)\nusing this:\n  \\<bar>Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         {(x, uu_). x} -\n        Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         {(y, uu_). y}\\<bar>\n  \\<le> Sigma_Algebra.measure\n         (measure_spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         {(uu_, bad). bad}\n  Sigma_Algebra.measure\n   (measure_spmf\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   {(x, uu_). x} =\n  spmf\n   (map_spmf fst\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   True\n  Sigma_Algebra.measure\n   (measure_spmf\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n   {(y, uu_). y} =\n  spmf\n   (map_spmf fst\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n   True\n  Sigma_Algebra.measure\n   (measure_spmf\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   {(uu_, bad). bad} =\n  spmf\n   (map_spmf snd\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   True\n\ngoal (1 subgoal):\n 1. \\<bar>spmf\n           (map_spmf fst\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n           True -\n          spmf\n           (map_spmf fst\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n           True\\<bar>\n    \\<le> spmf\n           (map_spmf snd\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n           True", "by simp"], ["proof (state)\nthis:\n  \\<bar>spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         True -\n        spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         True\\<bar>\n  \\<le> spmf\n         (map_spmf snd\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         True\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "define game3\n    where \"game3 = (\\<lambda>f :: _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> bitstring spmf \\<Rightarrow> _ spmf. \\<lambda>(x :: nat) (y :: nat). do {\n      b \\<leftarrow> coin_spmf;\n      (((msg1, msg2), \\<sigma>), (s, s_h)) \\<leftarrow> exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x)) ({}, hash.initial);\n      TRY do {\n        _ :: unit \\<leftarrow> assert_spmf (valid_plains msg1 msg2);\n        h' \\<leftarrow> f b msg1 msg2 (spmf_of_set (nlists UNIV len_plain));\n        let cipher = (\\<^bold>g [^] y, h');\n        (guess, (s', s_h')) \\<leftarrow> exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>) (s, s_h);\n        return_spmf (guess = b, \\<^bold>g [^] (x * y) \\<in> s')\n      } ELSE do {\n        b \\<leftarrow> coin_spmf;\n        return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s)\n      }\n    })\""], ["proof (state)\nthis:\n  game3 =\n  (\\<lambda>f x y.\n      coin_spmf \\<bind>\n      (\\<lambda>b.\n          exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n           ({}, Map.empty) \\<bind>\n          (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n              TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      f b msg1 msg2\n                       (spmf_of_set (nlists UNIV len_plain)) \\<bind>\n                      (\\<lambda>h'.\n                          let cipher = (\\<^bold>g [^] y, h')\n                          in exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>)\n                              (s, s_h) \\<bind>\n                             (\\<lambda>(guess, s', s_h').\n                                 return_spmf\n                                  (guess = b,\n                                   \\<^bold>g [^] (x * y)\n                                   \\<in> s')))) ELSE (coin_spmf \\<bind>\n                (\\<lambda>b.\n                    return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s))))))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "let ?f = \"\\<lambda>b msg1 msg2. map_spmf (\\<lambda>h. (if b then msg1 else msg2) [\\<oplus>] h)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"game2 x y = game3 ?f x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. game2 x y =\n    game3\n     (\\<lambda>b msg1 msg2.\n         map_spmf (([\\<oplus>]) (if b then msg1 else msg2)))\n     x y", "unfolding game2_def game3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coin_spmf \\<bind>\n    (\\<lambda>b.\n        exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n         ({}, Map.empty) \\<bind>\n        (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n            TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                (\\<lambda>_.\n                    spmf_of_set (nlists UNIV len_plain) \\<bind>\n                    (\\<lambda>h.\n                        let cipher =\n                              (\\<^bold>g [^] y,\n                               h [\\<oplus>] (if b then msg1 else msg2))\n                        in exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>)\n                            (s, s_h) \\<bind>\n                           (\\<lambda>(guess, s', s_h').\n                               return_spmf\n                                (guess = b,\n                                 \\<^bold>g [^] (x * y)\n                                 \\<in> s')))) ELSE (coin_spmf \\<bind>\n              (\\<lambda>b.\n                  return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s))))) =\n    coin_spmf \\<bind>\n    (\\<lambda>b.\n        exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n         ({}, Map.empty) \\<bind>\n        (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n            TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                (\\<lambda>_.\n                    map_spmf (([\\<oplus>]) (if b then msg1 else msg2))\n                     (spmf_of_set (nlists UNIV len_plain)) \\<bind>\n                    (\\<lambda>h'.\n                        let cipher = (\\<^bold>g [^] y, h')\n                        in exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>)\n                            (s, s_h) \\<bind>\n                           (\\<lambda>(guess, s', s_h').\n                               return_spmf\n                                (guess = b,\n                                 \\<^bold>g [^] (x * y)\n                                 \\<in> s')))) ELSE (coin_spmf \\<bind>\n              (\\<lambda>b.\n                  return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s)))))", "by(simp add: Let_def bind_map_spmf xor_list_commute o_def nat_pow_pow)"], ["proof (state)\nthis:\n  game2 ?x9 ?y9 =\n  game3\n   (\\<lambda>b msg1 msg2.\n       map_spmf (([\\<oplus>]) (if b then msg1 else msg2)))\n   ?x9 ?y9\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "also"], ["proof (state)\nthis:\n  game2 ?x9 ?y9 =\n  game3\n   (\\<lambda>b msg1 msg2.\n       map_spmf (([\\<oplus>]) (if b then msg1 else msg2)))\n   ?x9 ?y9\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"game3 ?f x y = game3 (\\<lambda>_ _ _ x. x) x y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. game3\n     (\\<lambda>b msg1 msg2.\n         map_spmf (([\\<oplus>]) (if b then msg1 else msg2)))\n     x y =\n    game3 (\\<lambda>_ _ _ x. x) x y", "(* optimistic sampling *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. game3\n     (\\<lambda>b msg1 msg2.\n         map_spmf (([\\<oplus>]) (if b then msg1 else msg2)))\n     x y =\n    game3 (\\<lambda>_ _ _ x. x) x y", "unfolding game3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. coin_spmf \\<bind>\n    (\\<lambda>b.\n        exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n         ({}, Map.empty) \\<bind>\n        (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n            TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                (\\<lambda>_.\n                    map_spmf (([\\<oplus>]) (if b then msg1 else msg2))\n                     (spmf_of_set (nlists UNIV len_plain)) \\<bind>\n                    (\\<lambda>h'.\n                        let cipher = (\\<^bold>g [^] y, h')\n                        in exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>)\n                            (s, s_h) \\<bind>\n                           (\\<lambda>(guess, s', s_h').\n                               return_spmf\n                                (guess = b,\n                                 \\<^bold>g [^] (x * y)\n                                 \\<in> s')))) ELSE (coin_spmf \\<bind>\n              (\\<lambda>b.\n                  return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s))))) =\n    coin_spmf \\<bind>\n    (\\<lambda>b.\n        exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n         ({}, Map.empty) \\<bind>\n        (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n            TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                (\\<lambda>_.\n                    spmf_of_set (nlists UNIV len_plain) \\<bind>\n                    (\\<lambda>h'.\n                        let cipher = (\\<^bold>g [^] y, h')\n                        in exec_gpv hash_oracle'' (\\<A>2 cipher \\<sigma>)\n                            (s, s_h) \\<bind>\n                           (\\<lambda>(guess, s', s_h').\n                               return_spmf\n                                (guess = b,\n                                 \\<^bold>g [^] (x * y)\n                                 \\<in> s')))) ELSE (coin_spmf \\<bind>\n              (\\<lambda>b.\n                  return_spmf (b, \\<^bold>g [^] (x * y) \\<in> s)))))", "by(auto intro!: try_spmf_cong bind_spmf_cong[OF refl] if_cong[OF refl] simp add: split_def one_time_pad valid_plains_def simp del: map_spmf_of_set_inj_on bind_spmf_const split: if_split)"], ["proof (state)\nthis:\n  game3\n   (\\<lambda>b msg1 msg2.\n       map_spmf (([\\<oplus>]) (if b then msg1 else msg2)))\n   ?x9 ?y9 =\n  game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "finally"], ["proof (chain)\npicking this:\n  game2 ?x10 ?y10 = game3 (\\<lambda>_ _ _ x. x) ?x10 ?y10", "have game23: \"game2 x y = game3 (\\<lambda>_ _ _ x. x) x y\" for x y"], ["proof (prove)\nusing this:\n  game2 ?x10 ?y10 = game3 (\\<lambda>_ _ _ x. x) ?x10 ?y10\n\ngoal (1 subgoal):\n 1. game2 x y = game3 (\\<lambda>_ _ _ x. x) x y", "."], ["proof (state)\nthis:\n  game2 ?x9 ?y9 = game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "define hash_oracle''' where \"hash_oracle''' = (\\<lambda>(\\<sigma> :: 'a \\<Rightarrow> _). hash.oracle \\<sigma>)\""], ["proof (state)\nthis:\n  hash_oracle''' = hash.oracle\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "{"], ["proof (state)\nthis:\n  hash_oracle''' = hash.oracle\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "define bisim where \"bisim = (\\<lambda>\\<sigma> (s :: 'a set, \\<sigma>' :: 'a \\<rightharpoonup> bitstring). s = dom \\<sigma> \\<and> \\<sigma> = \\<sigma>')\""], ["proof (state)\nthis:\n  bisim =\n  (\\<lambda>\\<sigma> (s, \\<sigma>').\n      s = dom \\<sigma> \\<and> \\<sigma> = \\<sigma>')\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have [transfer_rule]: \"bisim Map_empty ({}, Map_empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisim Map_empty ({}, Map_empty)", "by(simp add: bisim_def)"], ["proof (state)\nthis:\n  bisim Map_empty ({}, Map_empty)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have [transfer_rule]: \"(bisim ===> (=) ===> rel_spmf (rel_prod (=) bisim)) hash_oracle''' hash_oracle''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bisim ===> (=) ===> rel_spmf (rel_prod (=) bisim)) hash_oracle'''\n     hash_oracle''", "by(auto simp add: hash_oracle''_def split_def hash_oracle'''_def spmf_rel_map hash.oracle_def rel_fun_def bisim_def split: option.split intro!: rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  (bisim ===> (=) ===> rel_spmf (rel_prod (=) bisim)) hash_oracle'''\n   hash_oracle''\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have * [transfer_rule]: \"(bisim ===> (=)) dom fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bisim ===> (=)) dom fst", "by(simp add: bisim_def rel_fun_def)"], ["proof (state)\nthis:\n  (bisim ===> (=)) dom fst\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have * [transfer_rule]: \"(bisim ===> (=)) (\\<lambda>x. x) snd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bisim ===> (=)) (\\<lambda>x. x) snd", "by(simp add: rel_fun_def bisim_def)"], ["proof (state)\nthis:\n  (bisim ===> (=)) (\\<lambda>x. x) snd\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"game3 (\\<lambda>_ _ _ x. x) x y = do {\n        b \\<leftarrow> coin_spmf;\n        (((msg1, msg2), \\<sigma>), s) \\<leftarrow> exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] x)) hash.initial;\n        TRY do {\n          _ :: unit \\<leftarrow> assert_spmf (valid_plains msg1 msg2);\n          h' \\<leftarrow> spmf_of_set (nlists UNIV len_plain);\n          let cipher = (\\<^bold>g [^] y, h');\n          (guess, s') \\<leftarrow> exec_gpv hash_oracle''' (\\<A>2 cipher \\<sigma>) s;\n          return_spmf (guess = b, \\<^bold>g [^] (x * y) \\<in> dom s')\n        } ELSE do {\n          b \\<leftarrow> coin_spmf;\n          return_spmf (b, \\<^bold>g [^] (x * y) \\<in> dom s)\n        }\n      }\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. game3 (\\<lambda>_ _ _ x. x) x y =\n    coin_spmf \\<bind>\n    (\\<lambda>b.\n        exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] x)) Map.empty \\<bind>\n        (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n            TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                (\\<lambda>_.\n                    spmf_of_set (nlists UNIV len_plain) \\<bind>\n                    (\\<lambda>h'.\n                        let cipher = (\\<^bold>g [^] y, h')\n                        in exec_gpv hash_oracle''' (\\<A>2 cipher \\<sigma>)\n                            s \\<bind>\n                           (\\<lambda>(guess, s').\n                               return_spmf\n                                (guess = b,\n                                 \\<^bold>g [^] (x * y)\n                                 \\<in> dom\n  s')))) ELSE (coin_spmf \\<bind>\n               (\\<lambda>b.\n                   return_spmf (b, \\<^bold>g [^] (x * y) \\<in> dom s)))))", "unfolding game3_def Map_empty_def[symmetric] split_def fst_conv snd_conv prod.collapse"], ["proof (prove)\ngoal (1 subgoal):\n 1. coin_spmf \\<bind>\n    (\\<lambda>b.\n        exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x))\n         ({}, Map_empty) \\<bind>\n        (\\<lambda>p.\n            TRY assert_spmf\n                 (valid_plains (fst (fst (fst p)))\n                   (snd (fst (fst p)))) \\<bind>\n                (\\<lambda>_.\n                    spmf_of_set (nlists UNIV len_plain) \\<bind>\n                    (\\<lambda>h'.\n                        let cipher = (\\<^bold>g [^] y, h')\n                        in exec_gpv hash_oracle''\n                            (\\<A>2 cipher (snd (fst p))) (snd p) \\<bind>\n                           (\\<lambda>p.\n                               return_spmf\n                                (fst p = b,\n                                 \\<^bold>g [^] (x * y)\n                                 \\<in> fst\n  (snd p))))) ELSE (coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        return_spmf\n                         (b, \\<^bold>g [^] (x * y) \\<in> fst (snd p)))))) =\n    coin_spmf \\<bind>\n    (\\<lambda>b.\n        exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] x)) Map_empty \\<bind>\n        (\\<lambda>p.\n            TRY assert_spmf\n                 (valid_plains (fst (fst (fst p)))\n                   (snd (fst (fst p)))) \\<bind>\n                (\\<lambda>_.\n                    spmf_of_set (nlists UNIV len_plain) \\<bind>\n                    (\\<lambda>h'.\n                        let cipher = (\\<^bold>g [^] y, h')\n                        in exec_gpv hash_oracle'''\n                            (\\<A>2 cipher (snd (fst p))) (snd p) \\<bind>\n                           (\\<lambda>p.\n                               return_spmf\n                                (fst p = b,\n                                 \\<^bold>g [^] (x * y)\n                                 \\<in> dom\n  (snd p))))) ELSE (coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        return_spmf\n                         (b, \\<^bold>g [^] (x * y) \\<in> dom (snd p))))))", "by(transfer fixing: \\<A>1 \\<G> len_plain x y \\<A>2) simp"], ["proof (state)\nthis:\n  game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9 =\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] ?x9)) Map.empty \\<bind>\n      (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n          TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n              (\\<lambda>_.\n                  spmf_of_set (nlists UNIV len_plain) \\<bind>\n                  (\\<lambda>h'.\n                      let cipher = (\\<^bold>g [^] ?y9, h')\n                      in exec_gpv hash_oracle''' (\\<A>2 cipher \\<sigma>)\n                          s \\<bind>\n                         (\\<lambda>(guess, s').\n                             return_spmf\n                              (guess = b,\n                               \\<^bold>g [^] (?x9 * ?y9)\n                               \\<in> dom\ns')))) ELSE (coin_spmf \\<bind>\n             (\\<lambda>b.\n                 return_spmf (b, \\<^bold>g [^] (?x9 * ?y9) \\<in> dom s)))))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "moreover"], ["proof (state)\nthis:\n  game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9 =\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] ?x9)) Map.empty \\<bind>\n      (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n          TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n              (\\<lambda>_.\n                  spmf_of_set (nlists UNIV len_plain) \\<bind>\n                  (\\<lambda>h'.\n                      let cipher = (\\<^bold>g [^] ?y9, h')\n                      in exec_gpv hash_oracle''' (\\<A>2 cipher \\<sigma>)\n                          s \\<bind>\n                         (\\<lambda>(guess, s').\n                             return_spmf\n                              (guess = b,\n                               \\<^bold>g [^] (?x9 * ?y9)\n                               \\<in> dom\ns')))) ELSE (coin_spmf \\<bind>\n             (\\<lambda>b.\n                 return_spmf (b, \\<^bold>g [^] (?x9 * ?y9) \\<in> dom s)))))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"map_spmf snd (\\<dots> x y) = do {\n        zs \\<leftarrow> elgamal_adversary \\<A> (\\<^bold>g [^] x) (\\<^bold>g [^] y);\n        return_spmf (\\<^bold>g [^] (x * y) \\<in> zs)\n      }\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd\n     (coin_spmf \\<bind>\n      (\\<lambda>b.\n          exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] x))\n           Map.empty \\<bind>\n          (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n              TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      spmf_of_set (nlists UNIV len_plain) \\<bind>\n                      (\\<lambda>h'.\n                          let cipher = (\\<^bold>g [^] y, h')\n                          in exec_gpv hash_oracle''' (\\<A>2 cipher \\<sigma>)\n                              s \\<bind>\n                             (\\<lambda>(guess, s').\n                                 return_spmf\n                                  (guess = b,\n                                   \\<^bold>g [^] (x * y)\n                                   \\<in> dom\n    s')))) ELSE (coin_spmf \\<bind>\n                 (\\<lambda>b.\n                     return_spmf\n                      (b, \\<^bold>g [^] (x * y) \\<in> dom s)))))) =\n    elgamal_adversary \\<A> (\\<^bold>g [^] x) (\\<^bold>g [^] y) \\<bind>\n    (\\<lambda>zs. return_spmf (\\<^bold>g [^] (x * y) \\<in> zs))", "by(simp add: o_def split_def hash_oracle'''_def map_try_spmf map_scale_spmf)\n        (simp add: o_def map_try_spmf map_scale_spmf map_spmf_conv_bind_spmf[symmetric] spmf.map_comp map_const_spmf_of_set)"], ["proof (state)\nthis:\n  map_spmf snd\n   (coin_spmf \\<bind>\n    (\\<lambda>b.\n        exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] ?x9))\n         Map.empty \\<bind>\n        (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n            TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                (\\<lambda>_.\n                    spmf_of_set (nlists UNIV len_plain) \\<bind>\n                    (\\<lambda>h'.\n                        let cipher = (\\<^bold>g [^] ?y9, h')\n                        in exec_gpv hash_oracle''' (\\<A>2 cipher \\<sigma>)\n                            s \\<bind>\n                           (\\<lambda>(guess, s').\n                               return_spmf\n                                (guess = b,\n                                 \\<^bold>g [^] (?x9 * ?y9)\n                                 \\<in> dom\n  s')))) ELSE (coin_spmf \\<bind>\n               (\\<lambda>b.\n                   return_spmf\n                    (b, \\<^bold>g [^] (?x9 * ?y9) \\<in> dom s)))))) =\n  elgamal_adversary \\<A> (\\<^bold>g [^] ?x9) (\\<^bold>g [^] ?y9) \\<bind>\n  (\\<lambda>zs. return_spmf (\\<^bold>g [^] (?x9 * ?y9) \\<in> zs))\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "ultimately"], ["proof (chain)\npicking this:\n  game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9 =\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] ?x9)) Map.empty \\<bind>\n      (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n          TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n              (\\<lambda>_.\n                  spmf_of_set (nlists UNIV len_plain) \\<bind>\n                  (\\<lambda>h'.\n                      let cipher = (\\<^bold>g [^] ?y9, h')\n                      in exec_gpv hash_oracle''' (\\<A>2 cipher \\<sigma>)\n                          s \\<bind>\n                         (\\<lambda>(guess, s').\n                             return_spmf\n                              (guess = b,\n                               \\<^bold>g [^] (?x9 * ?y9)\n                               \\<in> dom\ns')))) ELSE (coin_spmf \\<bind>\n             (\\<lambda>b.\n                 return_spmf (b, \\<^bold>g [^] (?x9 * ?y9) \\<in> dom s)))))\n  map_spmf snd\n   (coin_spmf \\<bind>\n    (\\<lambda>b.\n        exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] ?x9))\n         Map.empty \\<bind>\n        (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n            TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                (\\<lambda>_.\n                    spmf_of_set (nlists UNIV len_plain) \\<bind>\n                    (\\<lambda>h'.\n                        let cipher = (\\<^bold>g [^] ?y9, h')\n                        in exec_gpv hash_oracle''' (\\<A>2 cipher \\<sigma>)\n                            s \\<bind>\n                           (\\<lambda>(guess, s').\n                               return_spmf\n                                (guess = b,\n                                 \\<^bold>g [^] (?x9 * ?y9)\n                                 \\<in> dom\n  s')))) ELSE (coin_spmf \\<bind>\n               (\\<lambda>b.\n                   return_spmf\n                    (b, \\<^bold>g [^] (?x9 * ?y9) \\<in> dom s)))))) =\n  elgamal_adversary \\<A> (\\<^bold>g [^] ?x9) (\\<^bold>g [^] ?y9) \\<bind>\n  (\\<lambda>zs. return_spmf (\\<^bold>g [^] (?x9 * ?y9) \\<in> zs))", "have \"map_spmf snd (?sample (game3 (\\<lambda>_ _ _ x. x))) = lcdh.lcdh (elgamal_adversary \\<A>)\""], ["proof (prove)\nusing this:\n  game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9 =\n  coin_spmf \\<bind>\n  (\\<lambda>b.\n      exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] ?x9)) Map.empty \\<bind>\n      (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n          TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n              (\\<lambda>_.\n                  spmf_of_set (nlists UNIV len_plain) \\<bind>\n                  (\\<lambda>h'.\n                      let cipher = (\\<^bold>g [^] ?y9, h')\n                      in exec_gpv hash_oracle''' (\\<A>2 cipher \\<sigma>)\n                          s \\<bind>\n                         (\\<lambda>(guess, s').\n                             return_spmf\n                              (guess = b,\n                               \\<^bold>g [^] (?x9 * ?y9)\n                               \\<in> dom\ns')))) ELSE (coin_spmf \\<bind>\n             (\\<lambda>b.\n                 return_spmf (b, \\<^bold>g [^] (?x9 * ?y9) \\<in> dom s)))))\n  map_spmf snd\n   (coin_spmf \\<bind>\n    (\\<lambda>b.\n        exec_gpv hash_oracle''' (\\<A>1 (\\<^bold>g [^] ?x9))\n         Map.empty \\<bind>\n        (\\<lambda>(((msg1, msg2), \\<sigma>), s).\n            TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n                (\\<lambda>_.\n                    spmf_of_set (nlists UNIV len_plain) \\<bind>\n                    (\\<lambda>h'.\n                        let cipher = (\\<^bold>g [^] ?y9, h')\n                        in exec_gpv hash_oracle''' (\\<A>2 cipher \\<sigma>)\n                            s \\<bind>\n                           (\\<lambda>(guess, s').\n                               return_spmf\n                                (guess = b,\n                                 \\<^bold>g [^] (?x9 * ?y9)\n                                 \\<in> dom\n  s')))) ELSE (coin_spmf \\<bind>\n               (\\<lambda>b.\n                   return_spmf\n                    (b, \\<^bold>g [^] (?x9 * ?y9) \\<in> dom s)))))) =\n  elgamal_adversary \\<A> (\\<^bold>g [^] ?x9) (\\<^bold>g [^] ?y9) \\<bind>\n  (\\<lambda>zs. return_spmf (\\<^bold>g [^] (?x9 * ?y9) \\<in> zs))\n\ngoal (1 subgoal):\n 1. map_spmf snd\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          sample_uniform (order \\<G>) \\<bind>\n          game3 (\\<lambda>_ _ _ x. x) x)) =\n    local.lcdh.lcdh (elgamal_adversary \\<A>)", "by(simp add: o_def lcdh.lcdh_def Let_def nat_pow_pow)"], ["proof (state)\nthis:\n  map_spmf snd\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        game3 (\\<lambda>_ _ _ x. x) x)) =\n  local.lcdh.lcdh (elgamal_adversary \\<A>)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "}"], ["proof (state)\nthis:\n  map_spmf snd\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        game3 (\\<lambda>_ _ _ x. x) x)) =\n  local.lcdh.lcdh (elgamal_adversary \\<A>)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "then"], ["proof (chain)\npicking this:\n  map_spmf snd\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        game3 (\\<lambda>_ _ _ x. x) x)) =\n  local.lcdh.lcdh (elgamal_adversary \\<A>)", "have game2_snd: \"map_spmf snd (?sample game2) = lcdh.lcdh (elgamal_adversary \\<A>)\""], ["proof (prove)\nusing this:\n  map_spmf snd\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        game3 (\\<lambda>_ _ _ x. x) x)) =\n  local.lcdh.lcdh (elgamal_adversary \\<A>)\n\ngoal (1 subgoal):\n 1. map_spmf snd\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)) =\n    local.lcdh.lcdh (elgamal_adversary \\<A>)", "using game23"], ["proof (prove)\nusing this:\n  map_spmf snd\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        game3 (\\<lambda>_ _ _ x. x) x)) =\n  local.lcdh.lcdh (elgamal_adversary \\<A>)\n  game2 ?x9 ?y9 = game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9\n\ngoal (1 subgoal):\n 1. map_spmf snd\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)) =\n    local.lcdh.lcdh (elgamal_adversary \\<A>)", "by(simp add: o_def)"], ["proof (state)\nthis:\n  map_spmf snd\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)) =\n  local.lcdh.lcdh (elgamal_adversary \\<A>)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"map_spmf fst (game3 (\\<lambda>_ _ _ x. x) x y) = do {\n      (((msg1, msg2), \\<sigma>), (s, s_h)) \\<leftarrow> exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x)) ({}, hash.initial);\n      TRY do {\n        _ :: unit \\<leftarrow> assert_spmf (valid_plains msg1 msg2);\n        h' \\<leftarrow> spmf_of_set (nlists UNIV len_plain);\n        (guess, (s', s_h')) \\<leftarrow> exec_gpv hash_oracle'' (\\<A>2 (\\<^bold>g [^] y, h') \\<sigma>) (s, s_h);\n        map_spmf ((=) guess) coin_spmf\n      } ELSE coin_spmf\n    }\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf fst (game3 (\\<lambda>_ _ _ x. x) x y) =\n    exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x)) ({}, Map.empty) \\<bind>\n    (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n        TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n            (\\<lambda>_.\n                spmf_of_set (nlists UNIV len_plain) \\<bind>\n                (\\<lambda>h'.\n                    exec_gpv hash_oracle''\n                     (\\<A>2 (\\<^bold>g [^] y, h') \\<sigma>) (s, s_h) \\<bind>\n                    (\\<lambda>(guess, s', s_h').\n                        map_spmf ((=) guess) coin_spmf))) ELSE coin_spmf)", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf fst (game3 (\\<lambda>_ _ _ x. x) x y) =\n    exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] x)) ({}, Map.empty) \\<bind>\n    (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n        TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n            (\\<lambda>_.\n                spmf_of_set (nlists UNIV len_plain) \\<bind>\n                (\\<lambda>h'.\n                    exec_gpv hash_oracle''\n                     (\\<A>2 (\\<^bold>g [^] y, h') \\<sigma>) (s, s_h) \\<bind>\n                    (\\<lambda>(guess, s', s_h').\n                        map_spmf ((=) guess) coin_spmf))) ELSE coin_spmf)", "by(simp add: game3_def o_def split_def map_spmf_conv_bind_spmf try_spmf_bind_out weight_spmf_le_1 scale_bind_spmf try_spmf_bind_out1 bind_scale_spmf)"], ["proof (state)\nthis:\n  map_spmf fst (game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9) =\n  exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] ?x9)) ({}, Map.empty) \\<bind>\n  (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n      TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n          (\\<lambda>_.\n              spmf_of_set (nlists UNIV len_plain) \\<bind>\n              (\\<lambda>h'.\n                  exec_gpv hash_oracle''\n                   (\\<A>2 (\\<^bold>g [^] ?y9, h') \\<sigma>) (s, s_h) \\<bind>\n                  (\\<lambda>(guess, s', s_h').\n                      map_spmf ((=) guess) coin_spmf))) ELSE coin_spmf)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "then"], ["proof (chain)\npicking this:\n  map_spmf fst (game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9) =\n  exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] ?x9)) ({}, Map.empty) \\<bind>\n  (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n      TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n          (\\<lambda>_.\n              spmf_of_set (nlists UNIV len_plain) \\<bind>\n              (\\<lambda>h'.\n                  exec_gpv hash_oracle''\n                   (\\<A>2 (\\<^bold>g [^] ?y9, h') \\<sigma>) (s, s_h) \\<bind>\n                  (\\<lambda>(guess, s', s_h').\n                      map_spmf ((=) guess) coin_spmf))) ELSE coin_spmf)", "have game3_fst: \"map_spmf fst (game3 (\\<lambda>_ _ _ x. x) x y) = coin_spmf\" for x y"], ["proof (prove)\nusing this:\n  map_spmf fst (game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9) =\n  exec_gpv hash_oracle'' (\\<A>1 (\\<^bold>g [^] ?x9)) ({}, Map.empty) \\<bind>\n  (\\<lambda>(((msg1, msg2), \\<sigma>), s, s_h).\n      TRY assert_spmf (valid_plains msg1 msg2) \\<bind>\n          (\\<lambda>_.\n              spmf_of_set (nlists UNIV len_plain) \\<bind>\n              (\\<lambda>h'.\n                  exec_gpv hash_oracle''\n                   (\\<A>2 (\\<^bold>g [^] ?y9, h') \\<sigma>) (s, s_h) \\<bind>\n                  (\\<lambda>(guess, s', s_h').\n                      map_spmf ((=) guess) coin_spmf))) ELSE coin_spmf)\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 (\\<lambda>_ _ _ x. x) x y) = coin_spmf", "by(simp add: o_def if_distribs spmf.map_comp map_eq_const_coin_spmf split_def)"], ["proof (state)\nthis:\n  map_spmf fst (game3 (\\<lambda>_ _ _ x. x) ?x9 ?y9) = coin_spmf\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"ind_cpa.advantage hash.oracle hash.initial \\<A> = \\<bar>spmf (map_spmf fst (?sample game1)) True - 1 / 2\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A> =\n    \\<bar>spmf\n           (map_spmf fst\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n           True -\n          1 / 2\\<bar>", "using game0"], ["proof (prove)\nusing this:\n  ind_cpa.ind_cpa \\<A> = game0\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A> =\n    \\<bar>spmf\n           (map_spmf fst\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n           True -\n          1 / 2\\<bar>", "by(simp add: ind_cpa_pk.advantage_def game01 o_def)"], ["proof (state)\nthis:\n  ind_cpa.advantage hash.oracle Map.empty \\<A> =\n  \\<bar>spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         True -\n        1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "also"], ["proof (state)\nthis:\n  ind_cpa.advantage hash.oracle Map.empty \\<A> =\n  \\<bar>spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         True -\n        1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"\\<dots> = \\<bar>1 / 2 - spmf (map_spmf fst (?sample game1)) True\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf\n           (map_spmf fst\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n           True -\n          1 / 2\\<bar> =\n    \\<bar>1 / 2 -\n          spmf\n           (map_spmf fst\n             (sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n           True\\<bar>", "by(simp add: abs_minus_commute)"], ["proof (state)\nthis:\n  \\<bar>spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         True -\n        1 / 2\\<bar> =\n  \\<bar>1 / 2 -\n        spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         True\\<bar>\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "also"], ["proof (state)\nthis:\n  \\<bar>spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         True -\n        1 / 2\\<bar> =\n  \\<bar>1 / 2 -\n        spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         True\\<bar>\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "have \"1 / 2 = spmf (map_spmf fst (?sample game2)) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 =\n    spmf\n     (map_spmf fst\n       (sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n     True", "by(simp add: game23 o_def game3_fst spmf_of_set)"], ["proof (state)\nthis:\n  1 / 2 =\n  spmf\n   (map_spmf fst\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   True\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "also"], ["proof (state)\nthis:\n  1 / 2 =\n  spmf\n   (map_spmf fst\n     (sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n   True\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "note hop23"], ["proof (state)\nthis:\n  \\<bar>spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         True -\n        spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         True\\<bar>\n  \\<le> spmf\n         (map_spmf snd\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         True\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "also"], ["proof (state)\nthis:\n  \\<bar>spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         True -\n        spmf\n         (map_spmf fst\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game1 x)))\n         True\\<bar>\n  \\<le> spmf\n         (map_spmf snd\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)))\n         True\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "note game2_snd"], ["proof (state)\nthis:\n  map_spmf snd\n   (sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x. sample_uniform (order \\<G>) \\<bind> game2 x)) =\n  local.lcdh.lcdh (elgamal_adversary \\<A>)\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "finally"], ["proof (chain)\npicking this:\n  ind_cpa.advantage hash.oracle Map.empty \\<A>\n  \\<le> spmf (local.lcdh.lcdh (elgamal_adversary \\<A>)) True", "show ?thesis"], ["proof (prove)\nusing this:\n  ind_cpa.advantage hash.oracle Map.empty \\<A>\n  \\<le> spmf (local.lcdh.lcdh (elgamal_adversary \\<A>)) True\n\ngoal (1 subgoal):\n 1. ind_cpa.advantage hash.oracle Map.empty \\<A>\n    \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)", "by(simp add: lcdh.advantage_def)"], ["proof (state)\nthis:\n  ind_cpa.advantage hash.oracle Map.empty \\<A>\n  \\<le> local.lcdh.advantage (elgamal_adversary \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context elgamal_base begin"], ["", "lemma lossless_key_gen [simp]: \"lossless_spmf key_gen \\<longleftrightarrow> 0 < order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf key_gen = (0 < order \\<G>)", "by(simp add: key_gen_def Let_def)"], ["", "lemma lossless_elgamal_adversary:\n  \"\\<lbrakk> ind_cpa.lossless \\<A>; \\<And>\\<eta>. 0 < order \\<G> \\<rbrakk>\n  \\<Longrightarrow> lcdh.lossless (elgamal_adversary \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ind_cpa.lossless \\<A>; \\<And>\\<eta>. 0 < order \\<G>\\<rbrakk>\n    \\<Longrightarrow> local.lcdh.lossless (elgamal_adversary \\<A>)", "by(cases \\<A>)(auto simp add: lcdh.lossless_def ind_cpa.lossless_def split_def Let_def intro!: lossless_exec_gpv[where \\<I>=\\<I>_full] lossless_inline)"], ["", "end"], ["", "end"]]}