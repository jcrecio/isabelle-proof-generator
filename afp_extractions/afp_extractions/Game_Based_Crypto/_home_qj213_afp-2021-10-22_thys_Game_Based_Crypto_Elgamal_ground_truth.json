{"file_name": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto/Elgamal.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto", "problem_names": ["lemma key_gen_alt:\n  \"key_gen = map_spmf (\\<lambda>x. (\\<^bold>g [^] x, x)) (sample_uniform (order \\<G>))\"", "lemma aencrypt_alt:\n  \"aencrypt \\<alpha> msg = map_spmf (\\<lambda>y. (\\<^bold>g [^] y, (\\<alpha> [^] y) \\<otimes> msg)) (sample_uniform (order \\<G>))\"", "theorem advantage_elgamal: \"ind_cpa.advantage \\<A> = ddh.advantage (elgamal_adversary \\<A>)\"", "theorem elgamal_secure:\n  \"negligible (\\<lambda>\\<eta>. ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\" if \"negligible (\\<lambda>\\<eta>. ddh.advantage \\<eta> (elgamal_adversary \\<eta> (\\<A> \\<eta>)))\"", "lemma lossless_key_gen [simp]: \"lossless_spmf (key_gen) \\<longleftrightarrow> 0 < order \\<G>\"", "lemma lossless_aencrypt [simp]:\n  \"lossless_spmf (aencrypt key plain) \\<longleftrightarrow> 0 < order \\<G>\"", "lemma lossless_elgamal_adversary:\n  \"\\<lbrakk> ind_cpa.lossless \\<A>; 0 < order \\<G> \\<rbrakk>\n  \\<Longrightarrow> ddh.lossless (elgamal_adversary \\<A>)\""], "translations": [["", "lemma key_gen_alt:\n  \"key_gen = map_spmf (\\<lambda>x. (\\<^bold>g [^] x, x)) (sample_uniform (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_gen =\n    map_spmf (\\<lambda>x. (\\<^bold>g [^] x, x))\n     (sample_uniform (order \\<G>))", "by(simp add: map_spmf_conv_bind_spmf key_gen_def)"], ["", "definition aencrypt :: \"'grp pub_key \\<Rightarrow> 'grp \\<Rightarrow> 'grp cipher spmf\"\nwhere\n  \"aencrypt \\<alpha> msg = do {\n    y \\<leftarrow> sample_uniform (order \\<G>);\n    return_spmf (\\<^bold>g [^] y, (\\<alpha> [^] y) \\<otimes> msg)\n  }\""], ["", "lemma aencrypt_alt:\n  \"aencrypt \\<alpha> msg = map_spmf (\\<lambda>y. (\\<^bold>g [^] y, (\\<alpha> [^] y) \\<otimes> msg)) (sample_uniform (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aencrypt \\<alpha> msg =\n    map_spmf (\\<lambda>y. (\\<^bold>g [^] y, \\<alpha> [^] y \\<otimes> msg))\n     (sample_uniform (order \\<G>))", "by(simp add: map_spmf_conv_bind_spmf aencrypt_def)"], ["", "definition adecrypt :: \"'grp priv_key \\<Rightarrow> 'grp cipher \\<Rightarrow> 'grp option\"\nwhere\n  \"adecrypt x = (\\<lambda>(\\<beta>, \\<zeta>). Some (\\<zeta> \\<otimes> (inv (\\<beta> [^] x))))\""], ["", "abbreviation valid_plains :: \"'grp \\<Rightarrow> 'grp \\<Rightarrow> bool\"\nwhere \"valid_plains msg1 msg2 \\<equiv> msg1 \\<in> carrier \\<G> \\<and> msg2 \\<in> carrier \\<G>\""], ["", "sublocale ind_cpa: ind_cpa key_gen aencrypt adecrypt valid_plains"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale ddh: ddh \\<G>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "fun elgamal_adversary :: \"('grp pub_key, 'grp plain, 'grp cipher, 'state) ind_cpa.adversary \\<Rightarrow> 'grp ddh.adversary\"\nwhere\n  \"elgamal_adversary (\\<A>1, \\<A>2) \\<alpha> \\<beta> \\<gamma> = TRY do {\n    b \\<leftarrow> coin_spmf;\n    ((msg1, msg2), \\<sigma>) \\<leftarrow> \\<A>1 \\<alpha>;\n    \\<comment> \\<open>have to check that the attacker actually sends two elements from the group; otherwise flip a coin\\<close>\n    _ :: unit \\<leftarrow> assert_spmf (valid_plains msg1 msg2);\n    guess \\<leftarrow> \\<A>2 (\\<beta>, \\<gamma> \\<otimes> (if b then msg1 else msg2)) \\<sigma>;\n    return_spmf (guess = b)\n  } ELSE coin_spmf\""], ["", "end"], ["", "locale elgamal = elgamal_base + cyclic_group \\<G>\nbegin"], ["", "theorem advantage_elgamal: \"ind_cpa.advantage \\<A> = ddh.advantage (elgamal_adversary \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "obtain \\<A>1 and \\<A>2 where \"\\<A> = (\\<A>1, \\<A>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<A>1 \\<A>2.\n        \\<A> = (\\<A>1, \\<A>2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<A>)"], ["proof (state)\nthis:\n  \\<A> = (\\<A>1, \\<A>2)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "note [simp] = this order_gt_0_iff_finite finite_carrier try_spmf_bind_out split_def o_def spmf_of_set bind_map_spmf weight_spmf_le_1 scale_bind_spmf bind_spmf_const\n    and [cong] = bind_spmf_cong_simp"], ["proof (state)\nthis:\n  \\<A> = (\\<A>1, \\<A>2)\n  (0 < order \\<G>) = finite (carrier \\<G>)\n  finite (carrier \\<G>)\n  lossless_spmf ?p \\<Longrightarrow>\n  ?p \\<bind> (\\<lambda>x. TRY ?f x ELSE ?q) = TRY ?p \\<bind> ?f ELSE ?q\n  case_prod = (\\<lambda>c p. c (fst p) (snd p))\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  spmf (spmf_of_set ?A) ?x = indicat_real ?A ?x / real (card ?A)\n  map_spmf ?f ?p \\<bind> ?g = ?p \\<bind> ?g \\<circ> ?f\n  weight_spmf ?p \\<le> 1\n  ?r \\<le> 1 \\<Longrightarrow>\n  scale_spmf ?r (?p \\<bind> ?f) =\n  ?p \\<bind> (\\<lambda>x. scale_spmf ?r (?f x))\n  ?p \\<bind> (\\<lambda>x. ?q) = scale_spmf (weight_spmf ?p) ?q\n  \\<lbrakk>?p = ?q;\n   \\<And>x. x \\<in> set_spmf ?q =simp=> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> ?p \\<bind> ?f = ?q \\<bind> ?g\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "have \"ddh.ddh_1 (elgamal_adversary \\<A>) = TRY do {\n       x \\<leftarrow> sample_uniform (order \\<G>);\n       y \\<leftarrow> sample_uniform (order \\<G>);\n       ((msg1, msg2), \\<sigma>) \\<leftarrow> \\<A>1 (\\<^bold>g [^] x);\n       _ :: unit \\<leftarrow> assert_spmf (valid_plains msg1 msg2);\n       b \\<leftarrow> coin_spmf;\n       z \\<leftarrow> map_spmf (\\<lambda>z. \\<^bold>g [^] z \\<otimes> (if b then msg1 else msg2)) (sample_uniform (order \\<G>));\n       guess \\<leftarrow> \\<A>2 (\\<^bold>g [^] y, z) \\<sigma>;\n       return_spmf (guess \\<longleftrightarrow> b)\n     } ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ddh.ddh_1 (elgamal_adversary \\<A>) =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>y.\n                \\<A>1 (\\<^bold>g [^] x) \\<bind>\n                (\\<lambda>((msg1, msg2), \\<sigma>).\n                    assert_spmf (valid_plains msg1 msg2) \\<bind>\n                    (\\<lambda>_.\n                        coin_spmf \\<bind>\n                        (\\<lambda>b.\n                            map_spmf\n                             (\\<lambda>z.\n                                 \\<^bold>g [^] z \\<otimes>\n                                 (if b then msg1 else msg2))\n                             (sample_uniform (order \\<G>)) \\<bind>\n                            (\\<lambda>z.\n                                \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                                (\\<lambda>guess.\n                                    return_spmf\n                                     (guess = b)))))))) ELSE coin_spmf", "by(simp add: ddh.ddh_1_def)"], ["proof (state)\nthis:\n  local.ddh.ddh_1 (elgamal_adversary \\<A>) =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>y.\n              \\<A>1 (\\<^bold>g [^] x) \\<bind>\n              (\\<lambda>((msg1, msg2), \\<sigma>).\n                  assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          map_spmf\n                           (\\<lambda>z.\n                               \\<^bold>g [^] z \\<otimes>\n                               (if b then msg1 else msg2))\n                           (sample_uniform (order \\<G>)) \\<bind>\n                          (\\<lambda>z.\n                              \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                              (\\<lambda>guess.\n                                  return_spmf\n                                   (guess = b)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "also"], ["proof (state)\nthis:\n  local.ddh.ddh_1 (elgamal_adversary \\<A>) =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>y.\n              \\<A>1 (\\<^bold>g [^] x) \\<bind>\n              (\\<lambda>((msg1, msg2), \\<sigma>).\n                  assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          map_spmf\n                           (\\<lambda>z.\n                               \\<^bold>g [^] z \\<otimes>\n                               (if b then msg1 else msg2))\n                           (sample_uniform (order \\<G>)) \\<bind>\n                          (\\<lambda>z.\n                              \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                              (\\<lambda>guess.\n                                  return_spmf\n                                   (guess = b)))))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "have \"\\<dots> = TRY do {\n       x \\<leftarrow> sample_uniform (order \\<G>);\n       y \\<leftarrow> sample_uniform (order \\<G>);\n       ((msg1, msg2), \\<sigma>) \\<leftarrow> \\<A>1 (\\<^bold>g [^] x);\n       _ :: unit \\<leftarrow> assert_spmf (valid_plains msg1 msg2);\n       z \\<leftarrow> map_spmf (\\<lambda>z. \\<^bold>g [^] z) (sample_uniform (order \\<G>));\n       guess \\<leftarrow> \\<A>2 (\\<^bold>g [^] y, z) \\<sigma>;\n       map_spmf ((=) guess) coin_spmf\n     } ELSE coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>y.\n                \\<A>1 (\\<^bold>g [^] x) \\<bind>\n                (\\<lambda>((msg1, msg2), \\<sigma>).\n                    assert_spmf (valid_plains msg1 msg2) \\<bind>\n                    (\\<lambda>_.\n                        coin_spmf \\<bind>\n                        (\\<lambda>b.\n                            map_spmf\n                             (\\<lambda>z.\n                                 \\<^bold>g [^] z \\<otimes>\n                                 (if b then msg1 else msg2))\n                             (sample_uniform (order \\<G>)) \\<bind>\n                            (\\<lambda>z.\n                                \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                                (\\<lambda>guess.\n                                    return_spmf\n                                     (guess = b)))))))) ELSE coin_spmf =\n    TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>y.\n                \\<A>1 (\\<^bold>g [^] x) \\<bind>\n                (\\<lambda>((msg1, msg2), \\<sigma>).\n                    assert_spmf (valid_plains msg1 msg2) \\<bind>\n                    (\\<lambda>_.\n                        map_spmf (([^]) \\<^bold>g)\n                         (sample_uniform (order \\<G>)) \\<bind>\n                        (\\<lambda>z.\n                            \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                            (\\<lambda>guess.\n                                map_spmf ((=) guess)\n                                 coin_spmf)))))) ELSE coin_spmf", "by(simp add: sample_uniform_one_time_pad map_spmf_conv_bind_spmf[where p=coin_spmf])"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>y.\n              \\<A>1 (\\<^bold>g [^] x) \\<bind>\n              (\\<lambda>((msg1, msg2), \\<sigma>).\n                  assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          map_spmf\n                           (\\<lambda>z.\n                               \\<^bold>g [^] z \\<otimes>\n                               (if b then msg1 else msg2))\n                           (sample_uniform (order \\<G>)) \\<bind>\n                          (\\<lambda>z.\n                              \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                              (\\<lambda>guess.\n                                  return_spmf\n                                   (guess = b)))))))) ELSE coin_spmf =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>y.\n              \\<A>1 (\\<^bold>g [^] x) \\<bind>\n              (\\<lambda>((msg1, msg2), \\<sigma>).\n                  assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      map_spmf (([^]) \\<^bold>g)\n                       (sample_uniform (order \\<G>)) \\<bind>\n                      (\\<lambda>z.\n                          \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "also"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>y.\n              \\<A>1 (\\<^bold>g [^] x) \\<bind>\n              (\\<lambda>((msg1, msg2), \\<sigma>).\n                  assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          map_spmf\n                           (\\<lambda>z.\n                               \\<^bold>g [^] z \\<otimes>\n                               (if b then msg1 else msg2))\n                           (sample_uniform (order \\<G>)) \\<bind>\n                          (\\<lambda>z.\n                              \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                              (\\<lambda>guess.\n                                  return_spmf\n                                   (guess = b)))))))) ELSE coin_spmf =\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>y.\n              \\<A>1 (\\<^bold>g [^] x) \\<bind>\n              (\\<lambda>((msg1, msg2), \\<sigma>).\n                  assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      map_spmf (([^]) \\<^bold>g)\n                       (sample_uniform (order \\<G>)) \\<bind>\n                      (\\<lambda>z.\n                          \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "have \"\\<dots> = coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>x.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>y.\n                \\<A>1 (\\<^bold>g [^] x) \\<bind>\n                (\\<lambda>((msg1, msg2), \\<sigma>).\n                    assert_spmf (valid_plains msg1 msg2) \\<bind>\n                    (\\<lambda>_.\n                        map_spmf (([^]) \\<^bold>g)\n                         (sample_uniform (order \\<G>)) \\<bind>\n                        (\\<lambda>z.\n                            \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                            (\\<lambda>guess.\n                                map_spmf ((=) guess)\n                                 coin_spmf)))))) ELSE coin_spmf =\n    coin_spmf", "by(simp add: map_eq_const_coin_spmf try_bind_spmf_lossless2')"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>y.\n              \\<A>1 (\\<^bold>g [^] x) \\<bind>\n              (\\<lambda>((msg1, msg2), \\<sigma>).\n                  assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      map_spmf (([^]) \\<^bold>g)\n                       (sample_uniform (order \\<G>)) \\<bind>\n                      (\\<lambda>z.\n                          \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf =\n  coin_spmf\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "also"], ["proof (state)\nthis:\n  TRY sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>x.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>y.\n              \\<A>1 (\\<^bold>g [^] x) \\<bind>\n              (\\<lambda>((msg1, msg2), \\<sigma>).\n                  assert_spmf (valid_plains msg1 msg2) \\<bind>\n                  (\\<lambda>_.\n                      map_spmf (([^]) \\<^bold>g)\n                       (sample_uniform (order \\<G>)) \\<bind>\n                      (\\<lambda>z.\n                          \\<A>2 (\\<^bold>g [^] y, z) \\<sigma> \\<bind>\n                          (\\<lambda>guess.\n                              map_spmf ((=) guess)\n                               coin_spmf)))))) ELSE coin_spmf =\n  coin_spmf\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "have \"ddh.ddh_0 (elgamal_adversary \\<A>) = ind_cpa.ind_cpa \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ddh.ddh_0 (elgamal_adversary \\<A>) = local.ind_cpa.ind_cpa \\<A>", "by(simp add: ddh.ddh_0_def IND_CPA_PK_Single.ind_cpa.ind_cpa_def key_gen_def aencrypt_def nat_pow_pow eq_commute)"], ["proof (state)\nthis:\n  local.ddh.ddh_0 (elgamal_adversary \\<A>) = local.ind_cpa.ind_cpa \\<A>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "ultimately"], ["proof (chain)\npicking this:\n  local.ddh.ddh_1 (elgamal_adversary \\<A>) = coin_spmf\n  local.ddh.ddh_0 (elgamal_adversary \\<A>) = local.ind_cpa.ind_cpa \\<A>", "show ?thesis"], ["proof (prove)\nusing this:\n  local.ddh.ddh_1 (elgamal_adversary \\<A>) = coin_spmf\n  local.ddh.ddh_0 (elgamal_adversary \\<A>) = local.ind_cpa.ind_cpa \\<A>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A> =\n    local.ddh.advantage (elgamal_adversary \\<A>)", "by(simp add: ddh.advantage_def ind_cpa.advantage_def)"], ["proof (state)\nthis:\n  local.ind_cpa.advantage \\<A> =\n  local.ddh.advantage (elgamal_adversary \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale elgamal_asymp = \n  fixes \\<G> :: \"security \\<Rightarrow> 'grp cyclic_group\"\n  assumes elgamal: \"\\<And>\\<eta>. elgamal (\\<G> \\<eta>)\"\nbegin"], ["", "sublocale elgamal \"\\<G> \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. elgamal (\\<G> \\<eta>)", "by(simp add: elgamal)"], ["", "theorem elgamal_secure:\n  \"negligible (\\<lambda>\\<eta>. ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\" if \"negligible (\\<lambda>\\<eta>. ddh.advantage \\<eta> (elgamal_adversary \\<eta> (\\<A> \\<eta>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))", "by(simp add: advantage_elgamal that)"], ["", "end"], ["", "context elgamal_base begin"], ["", "lemma lossless_key_gen [simp]: \"lossless_spmf (key_gen) \\<longleftrightarrow> 0 < order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf key_gen = (0 < order \\<G>)", "by(simp add: key_gen_def Let_def)"], ["", "lemma lossless_aencrypt [simp]:\n  \"lossless_spmf (aencrypt key plain) \\<longleftrightarrow> 0 < order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (aencrypt key plain) = (0 < order \\<G>)", "by(simp add: aencrypt_def Let_def)"], ["", "lemma lossless_elgamal_adversary:\n  \"\\<lbrakk> ind_cpa.lossless \\<A>; 0 < order \\<G> \\<rbrakk>\n  \\<Longrightarrow> ddh.lossless (elgamal_adversary \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.ind_cpa.lossless \\<A>; 0 < order \\<G>\\<rbrakk>\n    \\<Longrightarrow> local.ddh.lossless (elgamal_adversary \\<A>)", "by(cases \\<A>)(simp add: ddh.lossless_def ind_cpa.lossless_def Let_def split_def)"], ["", "end"], ["", "end"]]}