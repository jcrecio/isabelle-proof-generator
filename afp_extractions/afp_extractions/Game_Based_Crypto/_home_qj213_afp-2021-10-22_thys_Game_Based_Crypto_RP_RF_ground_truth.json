{"file_name": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto/RP_RF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto", "problem_names": ["lemma rp_resample:\n  assumes \"B \\<subseteq> A \\<union> C\" \"A \\<inter> C = {}\" \"C \\<subseteq> B\" and finB: \"finite B\"\n  shows \"bind_spmf (spmf_of_set B) (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) = spmf_of_set C\"", "lemma advantage_nonneg: \"0 \\<le> advantage \\<A>\"", "lemma advantage_le_1: \"advantage \\<A> \\<le> 1\"", "lemma outs_\\<I>_\\<I> [simp]: \"outs_\\<I> \\<I> = A\"", "lemma responses_\\<I>_\\<I> [simp]: \"responses_\\<I> \\<I> x = (if x \\<in> A then A else {})\"", "lemma rp_rf:\n  assumes bound: \"interaction_any_bounded_by \\<A> q\"\n    and lossless: \"lossless_gpv \\<I> \\<A>\"\n    and WT: \"\\<I> \\<turnstile>g \\<A> \\<surd>\"\n  shows \"advantage \\<A> \\<le> q * q / card A\""], "translations": [["", "lemma rp_resample:\n  assumes \"B \\<subseteq> A \\<union> C\" \"A \\<inter> C = {}\" \"C \\<subseteq> B\" and finB: \"finite B\"\n  shows \"bind_spmf (spmf_of_set B) (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) = spmf_of_set C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "proof(cases \"C = {} \\<or> A \\<inter> B = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C\n 2. \\<not> (C = {} \\<or> A \\<inter> B = {}) \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "case False"], ["proof (state)\nthis:\n  \\<not> (C = {} \\<or> A \\<inter> B = {})\n\ngoal (2 subgoals):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C\n 2. \\<not> (C = {} \\<or> A \\<inter> B = {}) \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "define A' where \"A' \\<equiv> A \\<inter> B\""], ["proof (state)\nthis:\n  A' \\<equiv> A \\<inter> B\n\ngoal (2 subgoals):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C\n 2. \\<not> (C = {} \\<or> A \\<inter> B = {}) \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "from False"], ["proof (chain)\npicking this:\n  \\<not> (C = {} \\<or> A \\<inter> B = {})", "have C: \"C \\<noteq> {}\" and A': \"A' \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> (C = {} \\<or> A \\<inter> B = {})\n\ngoal (1 subgoal):\n 1. C \\<noteq> {} &&& A' \\<noteq> {}", "by(auto simp add: A'_def)"], ["proof (state)\nthis:\n  C \\<noteq> {}\n  A' \\<noteq> {}\n\ngoal (2 subgoals):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C\n 2. \\<not> (C = {} \\<or> A \\<inter> B = {}) \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "have B: \"B = A' \\<union> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A' \\<union> C", "using assms"], ["proof (prove)\nusing this:\n  B \\<subseteq> A \\<union> C\n  A \\<inter> C = {}\n  C \\<subseteq> B\n  finite B\n\ngoal (1 subgoal):\n 1. B = A' \\<union> C", "by(auto simp add: A'_def)"], ["proof (state)\nthis:\n  B = A' \\<union> C\n\ngoal (2 subgoals):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C\n 2. \\<not> (C = {} \\<or> A \\<inter> B = {}) \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "with finB"], ["proof (chain)\npicking this:\n  finite B\n  B = A' \\<union> C", "have finA: \"finite A'\" and finC: \"finite C\""], ["proof (prove)\nusing this:\n  finite B\n  B = A' \\<union> C\n\ngoal (1 subgoal):\n 1. finite A' &&& finite C", "by simp_all"], ["proof (state)\nthis:\n  finite A'\n  finite C\n\ngoal (2 subgoals):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C\n 2. \\<not> (C = {} \\<or> A \\<inter> B = {}) \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "from assms"], ["proof (chain)\npicking this:\n  B \\<subseteq> A \\<union> C\n  A \\<inter> C = {}\n  C \\<subseteq> B\n  finite B", "have A'C: \"A' \\<inter> C = {}\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A \\<union> C\n  A \\<inter> C = {}\n  C \\<subseteq> B\n  finite B\n\ngoal (1 subgoal):\n 1. A' \\<inter> C = {}", "by(auto simp add: A'_def)"], ["proof (state)\nthis:\n  A' \\<inter> C = {}\n\ngoal (2 subgoals):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C\n 2. \\<not> (C = {} \\<or> A \\<inter> B = {}) \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "have \"bind_spmf (spmf_of_set B) (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) = \n        bind_spmf (spmf_of_set B) (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x)", "by(rule bind_spmf_cong[OF refl])(simp add: set_spmf_of_set finB A'_def)"], ["proof (state)\nthis:\n  spmf_of_set B \\<bind>\n  (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n  spmf_of_set B \\<bind>\n  (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x)\n\ngoal (2 subgoals):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C\n 2. \\<not> (C = {} \\<or> A \\<inter> B = {}) \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "also"], ["proof (state)\nthis:\n  spmf_of_set B \\<bind>\n  (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n  spmf_of_set B \\<bind>\n  (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x)\n\ngoal (2 subgoals):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C\n 2. \\<not> (C = {} \\<or> A \\<inter> B = {}) \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "have \"\\<dots> = spmf_of_set C\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "proof(rule spmf_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (spmf_of_set B \\<bind>\n         (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x))\n        i =\n       spmf (spmf_of_set C) i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (spmf_of_set B \\<bind>\n         (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x))\n        i =\n       spmf (spmf_of_set C) i", "have \"(\\<Sum>x\\<in>C. spmf (if x \\<in> A' then spmf_of_set C else return_spmf x) i) = indicator C i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>C.\n       spmf (if x \\<in> A' then spmf_of_set C else return_spmf x) i) =\n    indicat_real C i", "using finA finC"], ["proof (prove)\nusing this:\n  finite A'\n  finite C\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>C.\n       spmf (if x \\<in> A' then spmf_of_set C else return_spmf x) i) =\n    indicat_real C i", "by(simp add: disjoint_notin1[OF A'C] indicator_single_Some sum_mult_indicator[of C \"\\<lambda>_. 1 :: real\" \"\\<lambda>_. _\" \"\\<lambda>x. x\", simplified] split: split_indicator cong: conj_cong sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>C.\n     spmf (if x \\<in> A' then spmf_of_set C else return_spmf x) i) =\n  indicat_real C i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf\n        (spmf_of_set B \\<bind>\n         (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x))\n        i =\n       spmf (spmf_of_set C) i", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>C.\n     spmf (if x \\<in> A' then spmf_of_set C else return_spmf x) i) =\n  indicat_real C i", "show \"spmf ?lhs i = spmf ?rhs i\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>C.\n     spmf (if x \\<in> A' then spmf_of_set C else return_spmf x) i) =\n  indicat_real C i\n\ngoal (1 subgoal):\n 1. spmf\n     (spmf_of_set B \\<bind>\n      (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x))\n     i =\n    spmf (spmf_of_set C) i", "using B finA finC A'C C A'"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>C.\n     spmf (if x \\<in> A' then spmf_of_set C else return_spmf x) i) =\n  indicat_real C i\n  B = A' \\<union> C\n  finite A'\n  finite C\n  A' \\<inter> C = {}\n  C \\<noteq> {}\n  A' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. spmf\n     (spmf_of_set B \\<bind>\n      (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x))\n     i =\n    spmf (spmf_of_set C) i", "by(simp add: spmf_bind integral_spmf_of_set sum_Un spmf_of_set field_simps)(simp add: field_simps card_Un_disjoint)"], ["proof (state)\nthis:\n  spmf\n   (spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x))\n   i =\n  spmf (spmf_of_set C) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spmf_of_set B \\<bind>\n  (\\<lambda>x. if x \\<in> A' then spmf_of_set C else return_spmf x) =\n  spmf_of_set C\n\ngoal (2 subgoals):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C\n 2. \\<not> (C = {} \\<or> A \\<inter> B = {}) \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "finally"], ["proof (chain)\npicking this:\n  spmf_of_set B \\<bind>\n  (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n  spmf_of_set C", "show ?thesis"], ["proof (prove)\nusing this:\n  spmf_of_set B \\<bind>\n  (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n  spmf_of_set C\n\ngoal (1 subgoal):\n 1. spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "."], ["proof (state)\nthis:\n  spmf_of_set B \\<bind>\n  (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n  spmf_of_set C\n\ngoal (1 subgoal):\n 1. C = {} \\<or> A \\<inter> B = {} \\<Longrightarrow>\n    spmf_of_set B \\<bind>\n    (\\<lambda>x. if x \\<in> A then spmf_of_set C else return_spmf x) =\n    spmf_of_set C", "qed(use assms in \\<open>auto 4 3 cong: bind_spmf_cong_simp simp add: subsetD bind_spmf_const spmf_of_set_empty disjoint_notin1 intro!: arg_cong[where f=spmf_of_set]\\<close>)"], ["", "locale rp_rf =\n  rp: random_permutation A +\n  rf: random_function \"spmf_of_set A\"\n  for A :: \"'a set\"\n  +\n  assumes finite_A: \"finite A\"\n  and nonempty_A: \"A \\<noteq> {}\"\nbegin"], ["", "type_synonym 'a' adversary = \"(bool, 'a', 'a') gpv\""], ["", "definition game :: \"bool \\<Rightarrow> 'a adversary \\<Rightarrow> bool spmf\" where\n  \"game b \\<A> = run_gpv (if b then rp.random_permutation else rf.random_oracle) \\<A> Map.empty\""], ["", "abbreviation prp_game :: \"'a adversary \\<Rightarrow> bool spmf\" where \"prp_game \\<equiv> game True\""], ["", "abbreviation prf_game :: \"'a adversary \\<Rightarrow> bool spmf\" where \"prf_game \\<equiv> game False\""], ["", "definition advantage :: \"'a adversary \\<Rightarrow> real\" where\n  \"advantage \\<A> = \\<bar>spmf (prp_game \\<A>) True - spmf (prf_game \\<A>) True\\<bar>\""], ["", "lemma advantage_nonneg: \"0 \\<le> advantage \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> advantage \\<A>", "by(simp add: advantage_def)"], ["", "lemma advantage_le_1: \"advantage \\<A> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> 1", "by(auto simp add: advantage_def intro!: abs_leI)(metis diff_0_right diff_left_mono order_trans pmf_le_1 pmf_nonneg) +"], ["", "context includes \\<I>.lifting begin"], ["", "lift_definition \\<I> :: \"('a, 'a) \\<I>\" is \"(\\<lambda>x. if x \\<in> A then A else {})\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma outs_\\<I>_\\<I> [simp]: \"outs_\\<I> \\<I> = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> \\<I> = A", "by transfer auto"], ["", "lemma responses_\\<I>_\\<I> [simp]: \"responses_\\<I> \\<I> x = (if x \\<in> A then A else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. responses_\\<I> \\<I> x = (if x \\<in> A then A else {})", "by transfer simp"], ["", "lifting_update \\<I>.lifting"], ["", "lifting_forget \\<I>.lifting"], ["", "end"], ["", "lemma rp_rf:\n  assumes bound: \"interaction_any_bounded_by \\<A> q\"\n    and lossless: \"lossless_gpv \\<I> \\<A>\"\n    and WT: \"\\<I> \\<turnstile>g \\<A> \\<surd>\"\n  shows \"advantage \\<A> \\<le> q * q / card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "let ?run = \"\\<lambda>b. exec_gpv (if b then rp.random_permutation else rf.random_oracle) \\<A> Map.empty\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "define rp_bad :: \"bool \\<times> ('a \\<rightharpoonup> 'a) \\<Rightarrow> 'a \\<Rightarrow> ('a \\<times> (bool \\<times> ('a \\<rightharpoonup> 'a))) spmf\"\n    where \"rp_bad = (\\<lambda>(bad, \\<sigma>) x. case \\<sigma> x of Some y \\<Rightarrow> return_spmf (y, (bad, \\<sigma>))\n      | None \\<Rightarrow> bind_spmf (spmf_of_set A) (\\<lambda>y. if y \\<in> ran \\<sigma> then map_spmf (\\<lambda>y'. (y', (True, \\<sigma>(x \\<mapsto> y')))) (spmf_of_set (A - ran \\<sigma>)) else return_spmf (y, (bad, (\\<sigma>(x \\<mapsto> y))))))\""], ["proof (state)\nthis:\n  rp_bad =\n  (\\<lambda>(bad, \\<sigma>) x.\n      case \\<sigma> x of\n      None \\<Rightarrow>\n        spmf_of_set A \\<bind>\n        (\\<lambda>y.\n            if y \\<in> ran \\<sigma>\n            then map_spmf\n                  (\\<lambda>y'. (y', True, \\<sigma>(x \\<mapsto> y')))\n                  (spmf_of_set (A - ran \\<sigma>))\n            else return_spmf (y, bad, \\<sigma>(x \\<mapsto> y)))\n      | Some y \\<Rightarrow> return_spmf (y, bad, \\<sigma>))\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have rp_bad_simps: \"rp_bad (bad, \\<sigma>) x = (case \\<sigma> x of Some y \\<Rightarrow> return_spmf (y, (bad, \\<sigma>))\n      | None \\<Rightarrow> bind_spmf (spmf_of_set A) (\\<lambda>y. if y \\<in> ran \\<sigma> then map_spmf (\\<lambda>y'. (y', (True, \\<sigma>(x \\<mapsto> y')))) (spmf_of_set (A - ran \\<sigma>)) else return_spmf (y, (bad, (\\<sigma>(x \\<mapsto> y))))))\"\n    for bad \\<sigma> x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rp_bad (bad, \\<sigma>) x =\n    (case \\<sigma> x of\n     None \\<Rightarrow>\n       spmf_of_set A \\<bind>\n       (\\<lambda>y.\n           if y \\<in> ran \\<sigma>\n           then map_spmf (\\<lambda>y'. (y', True, \\<sigma>(x \\<mapsto> y')))\n                 (spmf_of_set (A - ran \\<sigma>))\n           else return_spmf (y, bad, \\<sigma>(x \\<mapsto> y)))\n     | Some y \\<Rightarrow> return_spmf (y, bad, \\<sigma>))", "by(simp add: rp_bad_def)"], ["proof (state)\nthis:\n  rp_bad (?bad2, ?\\<sigma>2) ?x2 =\n  (case ?\\<sigma>2 ?x2 of\n   None \\<Rightarrow>\n     spmf_of_set A \\<bind>\n     (\\<lambda>y.\n         if y \\<in> ran ?\\<sigma>2\n         then map_spmf\n               (\\<lambda>y'. (y', True, ?\\<sigma>2(?x2 \\<mapsto> y')))\n               (spmf_of_set (A - ran ?\\<sigma>2))\n         else return_spmf (y, ?bad2, ?\\<sigma>2(?x2 \\<mapsto> y)))\n   | Some y \\<Rightarrow> return_spmf (y, ?bad2, ?\\<sigma>2))\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "let ?S = \"rel_prod2 (=)\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "define init :: \"bool \\<times> ('a \\<rightharpoonup> 'a)\" where \"init = (False, Map.empty)\""], ["proof (state)\nthis:\n  init = (False, Map.empty)\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have rp: \"rp.random_permutation = (\\<lambda>\\<sigma> x. case \\<sigma> x of Some y \\<Rightarrow> return_spmf (y, \\<sigma>) \n    | None \\<Rightarrow> bind_spmf (bind_spmf (spmf_of_set A) (\\<lambda>y. if y \\<in> ran \\<sigma> then spmf_of_set (A - ran \\<sigma>) else return_spmf y)) (\\<lambda>y. return_spmf (y, \\<sigma>(x \\<mapsto> y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rp.random_permutation =\n    (\\<lambda>\\<sigma> x.\n        case \\<sigma> x of\n        None \\<Rightarrow>\n          spmf_of_set A \\<bind>\n          (\\<lambda>y.\n              if y \\<in> ran \\<sigma> then spmf_of_set (A - ran \\<sigma>)\n              else return_spmf y) \\<bind>\n          (\\<lambda>y. return_spmf (y, \\<sigma>(x \\<mapsto> y)))\n        | Some y \\<Rightarrow> return_spmf (y, \\<sigma>))", "by(subst rp_resample)(auto simp add: finite_A rp.random_permutation_def[abs_def])"], ["proof (state)\nthis:\n  rp.random_permutation =\n  (\\<lambda>\\<sigma> x.\n      case \\<sigma> x of\n      None \\<Rightarrow>\n        spmf_of_set A \\<bind>\n        (\\<lambda>y.\n            if y \\<in> ran \\<sigma> then spmf_of_set (A - ran \\<sigma>)\n            else return_spmf y) \\<bind>\n        (\\<lambda>y. return_spmf (y, \\<sigma>(x \\<mapsto> y)))\n      | Some y \\<Rightarrow> return_spmf (y, \\<sigma>))\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [transfer_rule]: \"(?S ===> (=) ===> rel_spmf (rel_prod (=) ?S)) rp.random_permutation rp_bad\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_prod2 (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod2 (=))))\n     rp.random_permutation rp_bad", "unfolding rp rp_bad_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_prod2 (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod2 (=))))\n     (\\<lambda>\\<sigma> x.\n         case \\<sigma> x of\n         None \\<Rightarrow>\n           spmf_of_set A \\<bind>\n           (\\<lambda>y.\n               if y \\<in> ran \\<sigma> then spmf_of_set (A - ran \\<sigma>)\n               else return_spmf y) \\<bind>\n           (\\<lambda>y. return_spmf (y, \\<sigma>(x \\<mapsto> y)))\n         | Some y \\<Rightarrow> return_spmf (y, \\<sigma>))\n     (\\<lambda>(bad, \\<sigma>) x.\n         case \\<sigma> x of\n         None \\<Rightarrow>\n           spmf_of_set A \\<bind>\n           (\\<lambda>y.\n               if y \\<in> ran \\<sigma>\n               then map_spmf\n                     (\\<lambda>y'. (y', True, \\<sigma>(x \\<mapsto> y')))\n                     (spmf_of_set (A - ran \\<sigma>))\n               else return_spmf (y, bad, \\<sigma>(x \\<mapsto> y)))\n         | Some y \\<Rightarrow> return_spmf (y, bad, \\<sigma>))", "by(auto simp add: rel_fun_def map_spmf_conv_bind_spmf split: option.split intro!: rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  (rel_prod2 (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod2 (=))))\n   rp.random_permutation rp_bad\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [transfer_rule]: \"?S Map.empty init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod2 (=) Map.empty init", "by(simp add: init_def)"], ["proof (state)\nthis:\n  rel_prod2 (=) Map.empty init\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have \"spmf (prp_game \\<A>) True = spmf (run_gpv rp_bad \\<A> init) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (prp_game \\<A>) True = spmf (run_gpv rp_bad \\<A> init) True", "unfolding vimage_def game_def if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (run_gpv rp.random_permutation \\<A> Map.empty) True =\n    spmf (run_gpv rp_bad \\<A> init) True", "by transfer_prover"], ["proof (state)\nthis:\n  spmf (prp_game \\<A>) True = spmf (run_gpv rp_bad \\<A> init) True\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "moreover"], ["proof (state)\nthis:\n  spmf (prp_game \\<A>) True = spmf (run_gpv rp_bad \\<A> init) True\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "{"], ["proof (state)\nthis:\n  spmf (prp_game \\<A>) True = spmf (run_gpv rp_bad \\<A> init) True\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "define collision :: \"('a \\<rightharpoonup> 'a) \\<Rightarrow> bool\" where \"collision m \\<longleftrightarrow> \\<not> inj_on m (dom m)\" for m"], ["proof (state)\nthis:\n  collision ?m = (\\<not> inj_on ?m (dom ?m))\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [simp]: \"\\<not> collision Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> collision Map.empty", "by(simp add: collision_def)"], ["proof (state)\nthis:\n  \\<not> collision Map.empty\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [simp]: \"\\<lbrakk> collision m; m x = None \\<rbrakk> \\<Longrightarrow> collision (m(x := y))\" for m x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>collision m; m x = None\\<rbrakk>\n    \\<Longrightarrow> collision (m(x := y))", "by(auto simp add: collision_def fun_upd_idem dom_minus fun_upd_image dest: inj_on_fun_updD)"], ["proof (state)\nthis:\n  \\<lbrakk>collision ?m4; ?m4 ?x4 = None\\<rbrakk>\n  \\<Longrightarrow> collision (?m4(?x4 := ?y4))\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have collision_map_updI: \"\\<lbrakk> m x = None; y \\<in> ran m \\<rbrakk> \\<Longrightarrow> collision (m(x \\<mapsto> y))\" for m x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m x = None; y \\<in> ran m\\<rbrakk>\n    \\<Longrightarrow> collision (m(x \\<mapsto> y))", "by(auto simp add: collision_def ran_def intro: rev_image_eqI)"], ["proof (state)\nthis:\n  \\<lbrakk>?m4 ?x4 = None; ?y4 \\<in> ran ?m4\\<rbrakk>\n  \\<Longrightarrow> collision (?m4(?x4 \\<mapsto> ?y4))\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have collision_map_upd_iff: \"\\<not> collision m \\<Longrightarrow> collision (m(x \\<mapsto> y)) \\<longleftrightarrow> y \\<in> ran m \\<and> m x \\<noteq> Some y\" for m x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> collision m \\<Longrightarrow>\n    collision (m(x \\<mapsto> y)) =\n    (y \\<in> ran m \\<and> m x \\<noteq> Some y)", "by(auto simp add: collision_def ran_def fun_upd_idem intro: inj_on_fun_updI rev_image_eqI dest: inj_on_eq_iff)"], ["proof (state)\nthis:\n  \\<not> collision ?m4 \\<Longrightarrow>\n  collision (?m4(?x4 \\<mapsto> ?y4)) =\n  (?y4 \\<in> ran ?m4 \\<and> ?m4 ?x4 \\<noteq> Some ?y4)\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "let ?bad1 = \"collision\" and ?bad2 = \"fst\"\n      and ?X = \"\\<lambda>\\<sigma>1 (bad, \\<sigma>2). \\<sigma>1 = \\<sigma>2 \\<and> \\<not> collision \\<sigma>1 \\<and> \\<not> bad\"\n      and ?I1 = \"\\<lambda>\\<sigma>1. dom \\<sigma>1 \\<subseteq> A \\<and> ran \\<sigma>1 \\<subseteq> A\"\n      and ?I2 = \"\\<lambda>(bad, \\<sigma>2). dom \\<sigma>2 \\<subseteq> A \\<and> ran \\<sigma>2 \\<subseteq> A\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "let ?X_bad = \"\\<lambda>\\<sigma>1 s2. ?I1 \\<sigma>1 \\<and> ?I2 s2\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [simp]: \"\\<I> \\<turnstile>c rf.random_oracle s1 \\<surd>\" if \"ran s1 \\<subseteq> A\" for s1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>c rf.random_oracle s1 \\<surd>", "using that"], ["proof (prove)\nusing this:\n  ran s1 \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>c rf.random_oracle s1 \\<surd>", "by(intro WT_calleeI)(auto simp add: rf.random_oracle_def[abs_def] finite_A nonempty_A ran_def split: option.split_asm)"], ["proof (state)\nthis:\n  ran ?s1.6 \\<subseteq> A \\<Longrightarrow>\n  \\<I> \\<turnstile>c rf.random_oracle ?s1.6 \\<surd>\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [simp]: \"callee_invariant_on rf.random_oracle ?I1 \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on rf.random_oracle\n     (\\<lambda>\\<sigma>1.\n         dom \\<sigma>1 \\<subseteq> A \\<and> ran \\<sigma>1 \\<subseteq> A)\n     \\<I>", "by(unfold_locales)(auto simp add: rf.random_oracle_def finite_A split: option.split_asm)"], ["proof (state)\nthis:\n  callee_invariant_on rf.random_oracle\n   (\\<lambda>\\<sigma>1.\n       dom \\<sigma>1 \\<subseteq> A \\<and> ran \\<sigma>1 \\<subseteq> A)\n   \\<I>\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "then"], ["proof (chain)\npicking this:\n  callee_invariant_on rf.random_oracle\n   (\\<lambda>\\<sigma>1.\n       dom \\<sigma>1 \\<subseteq> A \\<and> ran \\<sigma>1 \\<subseteq> A)\n   \\<I>", "interpret rf: callee_invariant_on rf.random_oracle ?I1 \\<I>"], ["proof (prove)\nusing this:\n  callee_invariant_on rf.random_oracle\n   (\\<lambda>\\<sigma>1.\n       dom \\<sigma>1 \\<subseteq> A \\<and> ran \\<sigma>1 \\<subseteq> A)\n   \\<I>\n\ngoal (1 subgoal):\n 1. callee_invariant_on rf.random_oracle\n     (\\<lambda>\\<sigma>1.\n         dom \\<sigma>1 \\<subseteq> A \\<and> ran \\<sigma>1 \\<subseteq> A)\n     \\<I>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [simp]: \"\\<I> \\<turnstile>c rp_bad s2 \\<surd> \" if \"ran (snd s2) \\<subseteq> A\" for s2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>c rp_bad s2 \\<surd>", "using that"], ["proof (prove)\nusing this:\n  ran (snd s2) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>c rp_bad s2 \\<surd>", "by(intro WT_calleeI)(auto simp add: rp_bad_def finite_A split: prod.split_asm option.split_asm if_split_asm intro: ranI)"], ["proof (state)\nthis:\n  ran (snd ?s2.6) \\<subseteq> A \\<Longrightarrow>\n  \\<I> \\<turnstile>c rp_bad ?s2.6 \\<surd>\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [simp]: \"callee_invariant_on rf.random_oracle (\\<lambda>\\<sigma>1. ?bad1 \\<sigma>1 \\<and> ?I1 \\<sigma>1) \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on rf.random_oracle\n     (\\<lambda>\\<sigma>1.\n         collision \\<sigma>1 \\<and>\n         dom \\<sigma>1 \\<subseteq> A \\<and> ran \\<sigma>1 \\<subseteq> A)\n     \\<I>", "by(unfold_locales)(clarsimp simp add: rf.random_oracle_def finite_A  split: option.split_asm)+"], ["proof (state)\nthis:\n  callee_invariant_on rf.random_oracle\n   (\\<lambda>\\<sigma>1.\n       collision \\<sigma>1 \\<and>\n       dom \\<sigma>1 \\<subseteq> A \\<and> ran \\<sigma>1 \\<subseteq> A)\n   \\<I>\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [simp]: \"callee_invariant_on rp_bad (\\<lambda>s2. ?I2 s2) \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on rp_bad\n     (\\<lambda>s2.\n         case s2 of\n         (bad, \\<sigma>2) \\<Rightarrow>\n           dom \\<sigma>2 \\<subseteq> A \\<and> ran \\<sigma>2 \\<subseteq> A)\n     \\<I>", "by(unfold_locales)(auto 4 3 simp add: rp_bad_simps finite_A split: option.splits if_split_asm iff del: domIff)"], ["proof (state)\nthis:\n  callee_invariant_on rp_bad\n   (\\<lambda>s2.\n       case s2 of\n       (bad, \\<sigma>2) \\<Rightarrow>\n         dom \\<sigma>2 \\<subseteq> A \\<and> ran \\<sigma>2 \\<subseteq> A)\n   \\<I>\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [simp]: \"callee_invariant_on rp_bad (\\<lambda>s2. ?bad2 s2 \\<and> ?I2 s2) \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on rp_bad\n     (\\<lambda>s2.\n         fst s2 \\<and>\n         (case s2 of\n          (bad, \\<sigma>2) \\<Rightarrow>\n            dom \\<sigma>2 \\<subseteq> A \\<and> ran \\<sigma>2 \\<subseteq> A))\n     \\<I>", "by(unfold_locales)(auto 4 3 simp add: rp_bad_simps finite_A split: option.splits if_split_asm iff del: domIff)"], ["proof (state)\nthis:\n  callee_invariant_on rp_bad\n   (\\<lambda>s2.\n       fst s2 \\<and>\n       (case s2 of\n        (bad, \\<sigma>2) \\<Rightarrow>\n          dom \\<sigma>2 \\<subseteq> A \\<and> ran \\<sigma>2 \\<subseteq> A))\n   \\<I>\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [simp]: \"\\<I> \\<turnstile>c rp_bad (bad, \\<sigma>2) \\<surd>\" if \"ran \\<sigma>2 \\<subseteq> A\" for bad \\<sigma>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>c rp_bad (bad, \\<sigma>2) \\<surd>", "using that"], ["proof (prove)\nusing this:\n  ran \\<sigma>2 \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>c rp_bad (bad, \\<sigma>2) \\<surd>", "by(intro WT_calleeI)(auto simp add: rp_bad_def finite_A nonempty_A ran_def split: option.split_asm if_split_asm)"], ["proof (state)\nthis:\n  ran ?\\<sigma>2.6 \\<subseteq> A \\<Longrightarrow>\n  \\<I> \\<turnstile>c rp_bad (?bad6, ?\\<sigma>2.6) \\<surd>\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have [simp]: \"lossless_spmf (rp_bad (b, \\<sigma>2) x)\" if \"x \\<in> A\" \"dom \\<sigma>2 \\<subseteq> A\" \"ran \\<sigma>2 \\<subseteq> A\" for b \\<sigma>2 x"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (rp_bad (b, \\<sigma>2) x)", "using finite_A that"], ["proof (prove)\nusing this:\n  finite A\n  x \\<in> A\n  dom \\<sigma>2 \\<subseteq> A\n  ran \\<sigma>2 \\<subseteq> A\n\ngoal (1 subgoal):\n 1. lossless_spmf (rp_bad (b, \\<sigma>2) x)", "unfolding rp_bad_def"], ["proof (prove)\nusing this:\n  finite A\n  x \\<in> A\n  dom \\<sigma>2 \\<subseteq> A\n  ran \\<sigma>2 \\<subseteq> A\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     ((case (b, \\<sigma>2) of\n       (bad, \\<sigma>) \\<Rightarrow>\n         \\<lambda>x.\n            case \\<sigma> x of\n            None \\<Rightarrow>\n              spmf_of_set A \\<bind>\n              (\\<lambda>y.\n                  if y \\<in> ran \\<sigma>\n                  then map_spmf\n                        (\\<lambda>y'. (y', True, \\<sigma>(x \\<mapsto> y')))\n                        (spmf_of_set (A - ran \\<sigma>))\n                  else return_spmf (y, bad, \\<sigma>(x \\<mapsto> y)))\n            | Some y \\<Rightarrow> return_spmf (y, bad, \\<sigma>))\n       x)", "by(clarsimp simp add: nonempty_A dom_subset_ran_iff eq_None_iff_not_dom split: option.split)"], ["proof (state)\nthis:\n  \\<lbrakk>?x6 \\<in> A; dom ?\\<sigma>2.6 \\<subseteq> A;\n   ran ?\\<sigma>2.6 \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (rp_bad (?b6, ?\\<sigma>2.6) ?x6)\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have \"rel_spmf (\\<lambda>(b1, \\<sigma>1) (b2, state2). (?bad1 \\<sigma>1 \\<longleftrightarrow> ?bad2 state2) \\<and> (if ?bad2 state2 then ?X_bad \\<sigma>1 state2 else b1 = b2 \\<and> ?X \\<sigma>1 state2))\n            ((if False then rp.random_permutation else rf.random_oracle) s1 x) (rp_bad s2 x)\"\n      if \"?X s1 s2\" \"x \\<in> outs_\\<I> \\<I>\" \"?I1 s1\" \"?I2 s2\" for s1 s2 x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(b1, \\<sigma>1) (b2, state2).\n         collision \\<sigma>1 = fst state2 \\<and>\n         (if fst state2\n          then (dom \\<sigma>1 \\<subseteq> A \\<and>\n                ran \\<sigma>1 \\<subseteq> A) \\<and>\n               (case state2 of\n                (bad, \\<sigma>2) \\<Rightarrow>\n                  dom \\<sigma>2 \\<subseteq> A \\<and>\n                  ran \\<sigma>2 \\<subseteq> A)\n          else b1 = b2 \\<and>\n               (case state2 of\n                (bad, \\<sigma>2) \\<Rightarrow>\n                  \\<sigma>1 = \\<sigma>2 \\<and>\n                  \\<not> collision \\<sigma>1 \\<and> \\<not> bad)))\n     ((if False then rp.random_permutation else rf.random_oracle) s1 x)\n     (rp_bad s2 x)", "using that finite_A"], ["proof (prove)\nusing this:\n  case s2 of\n  (bad, \\<sigma>2) \\<Rightarrow>\n    s1 = \\<sigma>2 \\<and> \\<not> collision s1 \\<and> \\<not> bad\n  x \\<in> outs_\\<I> \\<I>\n  dom s1 \\<subseteq> A \\<and> ran s1 \\<subseteq> A\n  case s2 of\n  (bad, \\<sigma>2) \\<Rightarrow>\n    dom \\<sigma>2 \\<subseteq> A \\<and> ran \\<sigma>2 \\<subseteq> A\n  finite A\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(b1, \\<sigma>1) (b2, state2).\n         collision \\<sigma>1 = fst state2 \\<and>\n         (if fst state2\n          then (dom \\<sigma>1 \\<subseteq> A \\<and>\n                ran \\<sigma>1 \\<subseteq> A) \\<and>\n               (case state2 of\n                (bad, \\<sigma>2) \\<Rightarrow>\n                  dom \\<sigma>2 \\<subseteq> A \\<and>\n                  ran \\<sigma>2 \\<subseteq> A)\n          else b1 = b2 \\<and>\n               (case state2 of\n                (bad, \\<sigma>2) \\<Rightarrow>\n                  \\<sigma>1 = \\<sigma>2 \\<and>\n                  \\<not> collision \\<sigma>1 \\<and> \\<not> bad)))\n     ((if False then rp.random_permutation else rf.random_oracle) s1 x)\n     (rp_bad s2 x)", "by(auto split!: option.split simp add: rf.random_oracle_def rp_bad_def rel_spmf_return_spmf1 collision_map_updI dom_subset_ran_iff eq_None_iff_not_dom collision_map_upd_iff intro!: rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  \\<lbrakk>case ?s2.6 of\n           (bad, \\<sigma>2) \\<Rightarrow>\n             ?s1.6 = \\<sigma>2 \\<and>\n             \\<not> collision ?s1.6 \\<and> \\<not> bad;\n   ?x6 \\<in> outs_\\<I> \\<I>;\n   dom ?s1.6 \\<subseteq> A \\<and> ran ?s1.6 \\<subseteq> A;\n   case ?s2.6 of\n   (bad, \\<sigma>2) \\<Rightarrow>\n     dom \\<sigma>2 \\<subseteq> A \\<and> ran \\<sigma>2 \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> rel_spmf\n                     (\\<lambda>(b1, \\<sigma>1) (b2, state2).\n                         collision \\<sigma>1 = fst state2 \\<and>\n                         (if fst state2\n                          then (dom \\<sigma>1 \\<subseteq> A \\<and>\n                                ran \\<sigma>1 \\<subseteq> A) \\<and>\n                               (case state2 of\n                                (bad, \\<sigma>2) \\<Rightarrow>\n                                  dom \\<sigma>2 \\<subseteq> A \\<and>\n                                  ran \\<sigma>2 \\<subseteq> A)\n                          else b1 = b2 \\<and>\n                               (case state2 of\n                                (bad, \\<sigma>2) \\<Rightarrow>\n                                  \\<sigma>1 = \\<sigma>2 \\<and>\n                                  \\<not> collision \\<sigma>1 \\<and>\n                                  \\<not> bad)))\n                     ((if False then rp.random_permutation\n                       else rf.random_oracle)\n                       ?s1.6 ?x6)\n                     (rp_bad ?s2.6 ?x6)\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "with _ _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<lbrakk>case ?s2.6 of\n           (bad, \\<sigma>2) \\<Rightarrow>\n             ?s1.6 = \\<sigma>2 \\<and>\n             \\<not> collision ?s1.6 \\<and> \\<not> bad;\n   ?x6 \\<in> outs_\\<I> \\<I>;\n   dom ?s1.6 \\<subseteq> A \\<and> ran ?s1.6 \\<subseteq> A;\n   case ?s2.6 of\n   (bad, \\<sigma>2) \\<Rightarrow>\n     dom \\<sigma>2 \\<subseteq> A \\<and> ran \\<sigma>2 \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> rel_spmf\n                     (\\<lambda>(b1, \\<sigma>1) (b2, state2).\n                         collision \\<sigma>1 = fst state2 \\<and>\n                         (if fst state2\n                          then (dom \\<sigma>1 \\<subseteq> A \\<and>\n                                ran \\<sigma>1 \\<subseteq> A) \\<and>\n                               (case state2 of\n                                (bad, \\<sigma>2) \\<Rightarrow>\n                                  dom \\<sigma>2 \\<subseteq> A \\<and>\n                                  ran \\<sigma>2 \\<subseteq> A)\n                          else b1 = b2 \\<and>\n                               (case state2 of\n                                (bad, \\<sigma>2) \\<Rightarrow>\n                                  \\<sigma>1 = \\<sigma>2 \\<and>\n                                  \\<not> collision \\<sigma>1 \\<and>\n                                  \\<not> bad)))\n                     ((if False then rp.random_permutation\n                       else rf.random_oracle)\n                       ?s1.6 ?x6)\n                     (rp_bad ?s2.6 ?x6)", "have \"rel_spmf\n       (\\<lambda>(b1, \\<sigma>1) (b2, state2). (?bad1 \\<sigma>1 \\<longleftrightarrow> ?bad2 state2) \\<and> (if ?bad2 state2 then ?X_bad \\<sigma>1 state2 else b1 = b2 \\<and> ?X \\<sigma>1 state2))\n       (?run False) (exec_gpv rp_bad \\<A> init)\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<lbrakk>case ?s2.6 of\n           (bad, \\<sigma>2) \\<Rightarrow>\n             ?s1.6 = \\<sigma>2 \\<and>\n             \\<not> collision ?s1.6 \\<and> \\<not> bad;\n   ?x6 \\<in> outs_\\<I> \\<I>;\n   dom ?s1.6 \\<subseteq> A \\<and> ran ?s1.6 \\<subseteq> A;\n   case ?s2.6 of\n   (bad, \\<sigma>2) \\<Rightarrow>\n     dom \\<sigma>2 \\<subseteq> A \\<and> ran \\<sigma>2 \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> rel_spmf\n                     (\\<lambda>(b1, \\<sigma>1) (b2, state2).\n                         collision \\<sigma>1 = fst state2 \\<and>\n                         (if fst state2\n                          then (dom \\<sigma>1 \\<subseteq> A \\<and>\n                                ran \\<sigma>1 \\<subseteq> A) \\<and>\n                               (case state2 of\n                                (bad, \\<sigma>2) \\<Rightarrow>\n                                  dom \\<sigma>2 \\<subseteq> A \\<and>\n                                  ran \\<sigma>2 \\<subseteq> A)\n                          else b1 = b2 \\<and>\n                               (case state2 of\n                                (bad, \\<sigma>2) \\<Rightarrow>\n                                  \\<sigma>1 = \\<sigma>2 \\<and>\n                                  \\<not> collision \\<sigma>1 \\<and>\n                                  \\<not> bad)))\n                     ((if False then rp.random_permutation\n                       else rf.random_oracle)\n                       ?s1.6 ?x6)\n                     (rp_bad ?s2.6 ?x6)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(b1, \\<sigma>1) (b2, state2).\n         collision \\<sigma>1 = fst state2 \\<and>\n         (if fst state2\n          then (dom \\<sigma>1 \\<subseteq> A \\<and>\n                ran \\<sigma>1 \\<subseteq> A) \\<and>\n               (case state2 of\n                (bad, \\<sigma>2) \\<Rightarrow>\n                  dom \\<sigma>2 \\<subseteq> A \\<and>\n                  ran \\<sigma>2 \\<subseteq> A)\n          else b1 = b2 \\<and>\n               (case state2 of\n                (bad, \\<sigma>2) \\<Rightarrow>\n                  \\<sigma>1 = \\<sigma>2 \\<and>\n                  \\<not> collision \\<sigma>1 \\<and> \\<not> bad)))\n     (exec_gpv (if False then rp.random_permutation else rf.random_oracle)\n       \\<A> Map.empty)\n     (exec_gpv rp_bad \\<A> init)", "by(rule exec_gpv_oracle_bisim_bad_invariant[where \\<I> = \\<I> and ?I1.0 = \"?I1\" and ?I2.0=\"?I2\"])(auto simp add: init_def WT lossless finite_A nonempty_A)"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(b1, \\<sigma>1) (b2, state2).\n       collision \\<sigma>1 = fst state2 \\<and>\n       (if fst state2\n        then (dom \\<sigma>1 \\<subseteq> A \\<and>\n              ran \\<sigma>1 \\<subseteq> A) \\<and>\n             (case state2 of\n              (bad, \\<sigma>2) \\<Rightarrow>\n                dom \\<sigma>2 \\<subseteq> A \\<and>\n                ran \\<sigma>2 \\<subseteq> A)\n        else b1 = b2 \\<and>\n             (case state2 of\n              (bad, \\<sigma>2) \\<Rightarrow>\n                \\<sigma>1 = \\<sigma>2 \\<and>\n                \\<not> collision \\<sigma>1 \\<and> \\<not> bad)))\n   (exec_gpv (if False then rp.random_permutation else rf.random_oracle)\n     \\<A> Map.empty)\n   (exec_gpv rp_bad \\<A> init)\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "then"], ["proof (chain)\npicking this:\n  rel_spmf\n   (\\<lambda>(b1, \\<sigma>1) (b2, state2).\n       collision \\<sigma>1 = fst state2 \\<and>\n       (if fst state2\n        then (dom \\<sigma>1 \\<subseteq> A \\<and>\n              ran \\<sigma>1 \\<subseteq> A) \\<and>\n             (case state2 of\n              (bad, \\<sigma>2) \\<Rightarrow>\n                dom \\<sigma>2 \\<subseteq> A \\<and>\n                ran \\<sigma>2 \\<subseteq> A)\n        else b1 = b2 \\<and>\n             (case state2 of\n              (bad, \\<sigma>2) \\<Rightarrow>\n                \\<sigma>1 = \\<sigma>2 \\<and>\n                \\<not> collision \\<sigma>1 \\<and> \\<not> bad)))\n   (exec_gpv (if False then rp.random_permutation else rf.random_oracle)\n     \\<A> Map.empty)\n   (exec_gpv rp_bad \\<A> init)", "have \"\\<bar>spmf (map_spmf fst (?run False)) True - spmf (run_gpv rp_bad \\<A> init) True\\<bar> \\<le> spmf (map_spmf (?bad1 \\<circ> snd) (?run False)) True\""], ["proof (prove)\nusing this:\n  rel_spmf\n   (\\<lambda>(b1, \\<sigma>1) (b2, state2).\n       collision \\<sigma>1 = fst state2 \\<and>\n       (if fst state2\n        then (dom \\<sigma>1 \\<subseteq> A \\<and>\n              ran \\<sigma>1 \\<subseteq> A) \\<and>\n             (case state2 of\n              (bad, \\<sigma>2) \\<Rightarrow>\n                dom \\<sigma>2 \\<subseteq> A \\<and>\n                ran \\<sigma>2 \\<subseteq> A)\n        else b1 = b2 \\<and>\n             (case state2 of\n              (bad, \\<sigma>2) \\<Rightarrow>\n                \\<sigma>1 = \\<sigma>2 \\<and>\n                \\<not> collision \\<sigma>1 \\<and> \\<not> bad)))\n   (exec_gpv (if False then rp.random_permutation else rf.random_oracle)\n     \\<A> Map.empty)\n   (exec_gpv rp_bad \\<A> init)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf\n           (run_gpv\n             (if False then rp.random_permutation else rf.random_oracle)\n             \\<A> Map.empty)\n           True -\n          spmf (run_gpv rp_bad \\<A> init) True\\<bar>\n    \\<le> spmf\n           (map_spmf (collision \\<circ> snd)\n             (exec_gpv\n               (if False then rp.random_permutation else rf.random_oracle)\n               \\<A> Map.empty))\n           True", "unfolding spmf_conv_measure_spmf measure_map_spmf vimage_def"], ["proof (prove)\nusing this:\n  rel_spmf\n   (\\<lambda>(b1, \\<sigma>1) (b2, state2).\n       collision \\<sigma>1 = fst state2 \\<and>\n       (if fst state2\n        then (dom \\<sigma>1 \\<subseteq> A \\<and>\n              ran \\<sigma>1 \\<subseteq> A) \\<and>\n             (case state2 of\n              (bad, \\<sigma>2) \\<Rightarrow>\n                dom \\<sigma>2 \\<subseteq> A \\<and>\n                ran \\<sigma>2 \\<subseteq> A)\n        else b1 = b2 \\<and>\n             (case state2 of\n              (bad, \\<sigma>2) \\<Rightarrow>\n                \\<sigma>1 = \\<sigma>2 \\<and>\n                \\<not> collision \\<sigma>1 \\<and> \\<not> bad)))\n   (exec_gpv (if False then rp.random_permutation else rf.random_oracle)\n     \\<A> Map.empty)\n   (exec_gpv rp_bad \\<A> init)\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure\n           (measure_spmf\n             (exec_gpv\n               (if False then rp.random_permutation else rf.random_oracle)\n               \\<A> Map.empty))\n           {x. fst x \\<in> {True}} -\n          Sigma_Algebra.measure (measure_spmf (exec_gpv rp_bad \\<A> init))\n           {x. fst x \\<in> {True}}\\<bar>\n    \\<le> Sigma_Algebra.measure\n           (measure_spmf\n             (exec_gpv\n               (if False then rp.random_permutation else rf.random_oracle)\n               \\<A> Map.empty))\n           {x. (collision \\<circ> snd) x \\<in> {True}}", "by(intro fundamental_lemma[where ?bad2.0=\"\\<lambda>(_, s2). ?bad2 s2\"])(auto simp add: split_def elim: rel_spmf_mono)"], ["proof (state)\nthis:\n  \\<bar>spmf\n         (run_gpv\n           (if False then rp.random_permutation else rf.random_oracle) \\<A>\n           Map.empty)\n         True -\n        spmf (run_gpv rp_bad \\<A> init) True\\<bar>\n  \\<le> spmf\n         (map_spmf (collision \\<circ> snd)\n           (exec_gpv\n             (if False then rp.random_permutation else rf.random_oracle)\n             \\<A> Map.empty))\n         True\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "also"], ["proof (state)\nthis:\n  \\<bar>spmf\n         (run_gpv\n           (if False then rp.random_permutation else rf.random_oracle) \\<A>\n           Map.empty)\n         True -\n        spmf (run_gpv rp_bad \\<A> init) True\\<bar>\n  \\<le> spmf\n         (map_spmf (collision \\<circ> snd)\n           (exec_gpv\n             (if False then rp.random_permutation else rf.random_oracle)\n             \\<A> Map.empty))\n         True\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "have \"ennreal \\<dots> \\<le> ennreal (q / card A) * (enat q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (map_spmf (collision \\<circ> snd)\n         (exec_gpv\n           (if False then rp.random_permutation else rf.random_oracle) \\<A>\n           Map.empty))\n       True)\n    \\<le> ennreal (real q / real (card A)) * ennreal_of_enat (enat q)", "unfolding if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (map_spmf (collision \\<circ> snd)\n         (exec_gpv rf.random_oracle \\<A> Map.empty))\n       True)\n    \\<le> ennreal (real q / real (card A)) * ennreal_of_enat (enat q)", "using bound _ _ _ _ _ _ _ WT"], ["proof (prove)\nusing this:\n  interaction_bounded_by' (\\<lambda>_. True) \\<A> q\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<I> \\<turnstile>g \\<A> \\<surd>\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (map_spmf (collision \\<circ> snd)\n         (exec_gpv rf.random_oracle \\<A> Map.empty))\n       True)\n    \\<le> ennreal (real q / real (card A)) * ennreal_of_enat (enat q)", "by(rule rf.interaction_bounded_by_exec_gpv_bad_count[where count=\"\\<lambda>s. card (dom s)\"])\n        (auto simp add: rf.random_oracle_def finite_A nonempty_A card_insert_if finite_subset[OF _ finite_A] map_spmf_conv_bind_spmf[symmetric] spmf.map_comp o_def collision_map_upd_iff map_mem_spmf_of_set card_gt_0_iff card_mono field_simps Int_absorb2 intro: card_ran_le_dom[OF finite_subset, OF _ finite_A, THEN order_trans] split: option.splits)"], ["proof (state)\nthis:\n  ennreal\n   (spmf\n     (map_spmf (collision \\<circ> snd)\n       (exec_gpv (if False then rp.random_permutation else rf.random_oracle)\n         \\<A> Map.empty))\n     True)\n  \\<le> ennreal (real q / real (card A)) * ennreal_of_enat (enat q)\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "hence \"spmf (map_spmf (?bad1 \\<circ> snd) (?run False)) True \\<le> q * q / card A\""], ["proof (prove)\nusing this:\n  ennreal\n   (spmf\n     (map_spmf (collision \\<circ> snd)\n       (exec_gpv (if False then rp.random_permutation else rf.random_oracle)\n         \\<A> Map.empty))\n     True)\n  \\<le> ennreal (real q / real (card A)) * ennreal_of_enat (enat q)\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (collision \\<circ> snd)\n       (exec_gpv (if False then rp.random_permutation else rf.random_oracle)\n         \\<A> Map.empty))\n     True\n    \\<le> real (q * q) / real (card A)", "by(simp add: ennreal_of_nat_eq_real_of_nat ennreal_times_divide ennreal_mult''[symmetric])"], ["proof (state)\nthis:\n  spmf\n   (map_spmf (collision \\<circ> snd)\n     (exec_gpv (if False then rp.random_permutation else rf.random_oracle)\n       \\<A> Map.empty))\n   True\n  \\<le> real (q * q) / real (card A)\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>spmf\n         (run_gpv\n           (if False then rp.random_permutation else rf.random_oracle) \\<A>\n           Map.empty)\n         True -\n        spmf (run_gpv rp_bad \\<A> init) True\\<bar>\n  \\<le> real (q * q) / real (card A)", "have \"\\<bar>spmf (run_gpv rp_bad \\<A> init) True - spmf (run_gpv rf.random_oracle \\<A> Map.empty) True\\<bar> \\<le> q * q / card A\""], ["proof (prove)\nusing this:\n  \\<bar>spmf\n         (run_gpv\n           (if False then rp.random_permutation else rf.random_oracle) \\<A>\n           Map.empty)\n         True -\n        spmf (run_gpv rp_bad \\<A> init) True\\<bar>\n  \\<le> real (q * q) / real (card A)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (run_gpv rp_bad \\<A> init) True -\n          spmf (run_gpv rf.random_oracle \\<A> Map.empty) True\\<bar>\n    \\<le> real (q * q) / real (card A)", "by simp"], ["proof (state)\nthis:\n  \\<bar>spmf (run_gpv rp_bad \\<A> init) True -\n        spmf (run_gpv rf.random_oracle \\<A> Map.empty) True\\<bar>\n  \\<le> real (q * q) / real (card A)\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "}"], ["proof (state)\nthis:\n  \\<bar>spmf (run_gpv rp_bad \\<A> init) True -\n        spmf (run_gpv rf.random_oracle \\<A> Map.empty) True\\<bar>\n  \\<le> real (q * q) / real (card A)\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "ultimately"], ["proof (chain)\npicking this:\n  spmf (prp_game \\<A>) True = spmf (run_gpv rp_bad \\<A> init) True\n  \\<bar>spmf (run_gpv rp_bad \\<A> init) True -\n        spmf (run_gpv rf.random_oracle \\<A> Map.empty) True\\<bar>\n  \\<le> real (q * q) / real (card A)", "show ?thesis"], ["proof (prove)\nusing this:\n  spmf (prp_game \\<A>) True = spmf (run_gpv rp_bad \\<A> init) True\n  \\<bar>spmf (run_gpv rp_bad \\<A> init) True -\n        spmf (run_gpv rf.random_oracle \\<A> Map.empty) True\\<bar>\n  \\<le> real (q * q) / real (card A)\n\ngoal (1 subgoal):\n 1. advantage \\<A> \\<le> real q * real q / real (card A)", "by(simp add: advantage_def game_def)"], ["proof (state)\nthis:\n  advantage \\<A> \\<le> real q * real q / real (card A)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}