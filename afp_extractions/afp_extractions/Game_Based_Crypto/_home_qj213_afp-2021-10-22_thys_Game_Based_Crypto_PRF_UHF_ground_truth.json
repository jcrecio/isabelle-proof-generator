{"file_name": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto/PRF_UHF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto", "problem_names": ["lemma \\<epsilon>_uh_nonneg : \"\\<epsilon>_uh \\<ge> 0\"", "lemma hash_ineq_card:\n  assumes \"finite W\"\n  shows \"spmf (game_hash_set W) True \\<le> \\<epsilon>_uh * card W * card W\"", "lemma lossless_rand [simp]: \"lossless_spmf rand\"", "theorem prf_prf'_advantage: \n  assumes \"prf'.lossless \\<A>\"\n  and bounded: \"prf'.ibounded_by \\<A> q\" \n  shows \"prf'.advantage \\<A>  \\<le> prf.advantage (prf'_reduction \\<A>) + hash.\\<epsilon>_uh * q * q\""], "translations": [["", "lemma \\<epsilon>_uh_nonneg : \"\\<epsilon>_uh \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<epsilon>_uh", "by(auto 4 3 intro!: cSUP_upper2 bdd_aboveI2[where M=1] cSUP_least pmf_le_1 pmf_nonneg simp add: \\<epsilon>_uh_def)"], ["", "lemma hash_ineq_card:\n  assumes \"finite W\"\n  shows \"spmf (game_hash_set W) True \\<le> \\<epsilon>_uh * card W * card W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "let ?M = \"measure (measure_spmf seed_gen)\""], ["proof (state)\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "have bound: \"?M {x. hash x w = hash x w' \\<and> w \\<noteq> w'} \\<le> \\<epsilon>_uh\" for w w'"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf seed_gen)\n     {x. hash x w = hash x w' \\<and> w \\<noteq> w'}\n    \\<le> \\<epsilon>_uh", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf seed_gen)\n     {x. hash x w = hash x w' \\<and> w \\<noteq> w'}\n    \\<le> \\<epsilon>_uh", "have \"?M {x. hash x w = hash x w' \\<and> w \\<noteq> w'} = spmf (game_hash w w') True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf seed_gen)\n     {x. hash x w = hash x w' \\<and> w \\<noteq> w'} =\n    spmf (game_hash w w') True", "by(simp add: game_hash_def spmf_conv_measure_spmf map_spmf_conv_bind_spmf[symmetric] measure_map_spmf vimage_def)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf seed_gen)\n   {x. hash x w = hash x w' \\<and> w \\<noteq> w'} =\n  spmf (game_hash w w') True\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf seed_gen)\n     {x. hash x w = hash x w' \\<and> w \\<noteq> w'}\n    \\<le> \\<epsilon>_uh", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf seed_gen)\n   {x. hash x w = hash x w' \\<and> w \\<noteq> w'} =\n  spmf (game_hash w w') True\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf seed_gen)\n     {x. hash x w = hash x w' \\<and> w \\<noteq> w'}\n    \\<le> \\<epsilon>_uh", "have \"\\<dots> \\<le> \\<epsilon>_uh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (game_hash w w') True \\<le> \\<epsilon>_uh", "unfolding \\<epsilon>_uh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (game_hash w w') True\n    \\<le> (\\<Squnion>w w'. spmf (game_hash w w') True)", "by(auto intro!: cSUP_upper2 bdd_aboveI[where M=1] cSUP_least simp add: pmf_le_1)"], ["proof (state)\nthis:\n  spmf (game_hash w w') True \\<le> \\<epsilon>_uh\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf seed_gen)\n     {x. hash x w = hash x w' \\<and> w \\<noteq> w'}\n    \\<le> \\<epsilon>_uh", "finally"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure (measure_spmf seed_gen)\n   {x. hash x w = hash x w' \\<and> w \\<noteq> w'}\n  \\<le> \\<epsilon>_uh", "show ?thesis"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure (measure_spmf seed_gen)\n   {x. hash x w = hash x w' \\<and> w \\<noteq> w'}\n  \\<le> \\<epsilon>_uh\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf seed_gen)\n     {x. hash x w = hash x w' \\<and> w \\<noteq> w'}\n    \\<le> \\<epsilon>_uh", "."], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf seed_gen)\n   {x. hash x w = hash x w' \\<and> w \\<noteq> w'}\n  \\<le> \\<epsilon>_uh\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf seed_gen)\n   {x. hash x ?w = hash x ?w' \\<and> ?w \\<noteq> ?w'}\n  \\<le> \\<epsilon>_uh\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "have \"spmf (game_hash_set W) True = ?M {x. \\<exists>xa\\<in>W. \\<exists>y\\<in>W. hash x xa = hash x y \\<and> xa \\<noteq> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True =\n    Sigma_Algebra.measure (measure_spmf seed_gen)\n     {x. \\<exists>xa\\<in>W.\n            \\<exists>y\\<in>W. hash x xa = hash x y \\<and> xa \\<noteq> y}", "by(auto simp add: game_hash_set_def inj_on_def map_spmf_conv_bind_spmf[symmetric] spmf_conv_measure_spmf measure_map_spmf vimage_def)"], ["proof (state)\nthis:\n  spmf (game_hash_set W) True =\n  Sigma_Algebra.measure (measure_spmf seed_gen)\n   {x. \\<exists>xa\\<in>W.\n          \\<exists>y\\<in>W. hash x xa = hash x y \\<and> xa \\<noteq> y}\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "also"], ["proof (state)\nthis:\n  spmf (game_hash_set W) True =\n  Sigma_Algebra.measure (measure_spmf seed_gen)\n   {x. \\<exists>xa\\<in>W.\n          \\<exists>y\\<in>W. hash x xa = hash x y \\<and> xa \\<noteq> y}\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "have \"{x. \\<exists>xa\\<in>W. \\<exists>y\\<in>W. hash x xa = hash x y \\<and> xa \\<noteq> y} = (\\<Union>(w, w') \\<in> W\\<times> W. {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>xa\\<in>W.\n           \\<exists>y\\<in>W. hash x xa = hash x y \\<and> xa \\<noteq> y} =\n    (\\<Union>(w, w')\\<in>W \\<times> W.\n        {x. hash x w = hash x w' \\<and> w \\<noteq> w'})", "by(auto)"], ["proof (state)\nthis:\n  {x. \\<exists>xa\\<in>W.\n         \\<exists>y\\<in>W. hash x xa = hash x y \\<and> xa \\<noteq> y} =\n  (\\<Union>(w, w')\\<in>W \\<times> W.\n      {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "also"], ["proof (state)\nthis:\n  {x. \\<exists>xa\\<in>W.\n         \\<exists>y\\<in>W. hash x xa = hash x y \\<and> xa \\<noteq> y} =\n  (\\<Union>(w, w')\\<in>W \\<times> W.\n      {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "have \"?M \\<dots> \\<le> (\\<Sum>(w, w')\\<in>W \\<times> W. ?M {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf seed_gen)\n     (\\<Union>(w, w')\\<in>W \\<times> W.\n         {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\n    \\<le> (\\<Sum>(w, w')\\<in>W \\<times> W.\n             Sigma_Algebra.measure (measure_spmf seed_gen)\n              {x. hash x w = hash x w' \\<and> w \\<noteq> w'})", "by(auto intro!: measure_spmf.finite_measure_subadditive_finite simp add: split_def assms)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf seed_gen)\n   (\\<Union>(w, w')\\<in>W \\<times> W.\n       {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\n  \\<le> (\\<Sum>(w, w')\\<in>W \\<times> W.\n           Sigma_Algebra.measure (measure_spmf seed_gen)\n            {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf seed_gen)\n   (\\<Union>(w, w')\\<in>W \\<times> W.\n       {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\n  \\<le> (\\<Sum>(w, w')\\<in>W \\<times> W.\n           Sigma_Algebra.measure (measure_spmf seed_gen)\n            {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "have \"\\<dots> \\<le> (\\<Sum>(w, w')\\<in>W \\<times> W. \\<epsilon>_uh)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(w, w')\\<in>W \\<times> W.\n       Sigma_Algebra.measure (measure_spmf seed_gen)\n        {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\n    \\<le> (\\<Sum>(w, w')\\<in>W \\<times> W. \\<epsilon>_uh)", "by(rule sum_mono)(clarsimp simp add: bound)"], ["proof (state)\nthis:\n  (\\<Sum>(w, w')\\<in>W \\<times> W.\n     Sigma_Algebra.measure (measure_spmf seed_gen)\n      {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\n  \\<le> (\\<Sum>(w, w')\\<in>W \\<times> W. \\<epsilon>_uh)\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(w, w')\\<in>W \\<times> W.\n     Sigma_Algebra.measure (measure_spmf seed_gen)\n      {x. hash x w = hash x w' \\<and> w \\<noteq> w'})\n  \\<le> (\\<Sum>(w, w')\\<in>W \\<times> W. \\<epsilon>_uh)\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "have \"\\<dots> =  \\<epsilon>_uh * card(W) * card(W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(w, w')\\<in>W \\<times> W. \\<epsilon>_uh) =\n    \\<epsilon>_uh * real (card W) * real (card W)", "by(simp add: card_cartesian_product)"], ["proof (state)\nthis:\n  (\\<Sum>(w, w')\\<in>W \\<times> W. \\<epsilon>_uh) =\n  \\<epsilon>_uh * real (card W) * real (card W)\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "finally"], ["proof (chain)\npicking this:\n  spmf (game_hash_set W) True\n  \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "show ?thesis"], ["proof (prove)\nusing this:\n  spmf (game_hash_set W) True\n  \\<le> \\<epsilon>_uh * real (card W) * real (card W)\n\ngoal (1 subgoal):\n 1. spmf (game_hash_set W) True\n    \\<le> \\<epsilon>_uh * real (card W) * real (card W)", "."], ["proof (state)\nthis:\n  spmf (game_hash_set W) True\n  \\<le> \\<epsilon>_uh * real (card W) * real (card W)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale prf_hash =\n  fixes f :: \"'key \\<Rightarrow> '\\<alpha> \\<Rightarrow> '\\<gamma>\"\n  and h :: \"'seed \\<Rightarrow> '\\<beta> \\<Rightarrow> '\\<alpha>\"\n  and key_gen :: \"'key spmf\"\n  and seed_gen :: \"'seed spmf\"\n  and range_f :: \"'\\<gamma> set\"\n  assumes lossless_seed_gen: \"lossless_spmf seed_gen\"\n  and range_f_finite: \"finite range_f\"\n  and range_f_nonempty: \"range_f \\<noteq> {}\"\nbegin"], ["", "definition rand :: \"'\\<gamma> spmf\"\nwhere \"rand = spmf_of_set range_f\""], ["", "lemma lossless_rand [simp]: \"lossless_spmf rand\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf rand", "by(simp add: rand_def range_f_finite range_f_nonempty)"], ["", "definition key_seed_gen :: \"('key * 'seed) spmf\"\nwhere\n  \"key_seed_gen = do {\n     k \\<leftarrow> key_gen;\n     s :: 'seed \\<leftarrow> seed_gen;\n     return_spmf (k, s)\n   }\""], ["", "interpretation \"prf\": \"prf\" key_gen f rand"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation hash: hash \"seed_gen\" \"h\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "fun f' :: \"'key \\<times> 'seed \\<Rightarrow> '\\<beta> \\<Rightarrow> '\\<gamma>\"\nwhere \"f' (key, seed) x = f key (h seed x)\""], ["", "interpretation \"prf'\": \"prf\" key_seed_gen f' rand"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition reduction_oracle :: \"'seed \\<Rightarrow> unit \\<Rightarrow> '\\<beta> \\<Rightarrow> ('\\<gamma> \\<times> unit, '\\<alpha>, '\\<gamma>) gpv\"\nwhere \"reduction_oracle seed x b = Pause (h seed b) (\\<lambda>x. Done (x, ()))\""], ["", "definition prf'_reduction :: \" ('\\<beta>, '\\<gamma>) prf'.adversary \\<Rightarrow> ('\\<alpha>, '\\<gamma>) prf.adversary\"\nwhere\n  \"prf'_reduction \\<A> = do {\n      seed  \\<leftarrow> lift_spmf seed_gen;\n      (b, \\<sigma>) \\<leftarrow> inline (reduction_oracle seed) \\<A> ();\n      Done b\n  }\""], ["", "theorem prf_prf'_advantage: \n  assumes \"prf'.lossless \\<A>\"\n  and bounded: \"prf'.ibounded_by \\<A> q\" \n  shows \"prf'.advantage \\<A>  \\<le> prf.advantage (prf'_reduction \\<A>) + hash.\\<epsilon>_uh * q * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "let ?\\<A> = \"prf'_reduction \\<A>\""], ["proof (state)\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "define cr where \"cr = (\\<lambda>_ :: unit \\<times> unit. \\<lambda>_ :: unit. True)\""], ["proof (state)\nthis:\n  cr = (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have [transfer_rule]: \"cr ((), ()) ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr ((), ()) ()", "by(simp add: cr_def)"], ["proof (state)\nthis:\n  cr ((), ()) ()\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have \"prf.game_0 ?\\<A> = prf'.game_0 \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.prf.game_0 (prf'_reduction \\<A>) = prf'.game_0 \\<A>", "unfolding prf'.game_0_def prf.game_0_def prf'_reduction_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. key_gen \\<bind>\n    (\\<lambda>key.\n        exec_gpv (local.prf.prf_oracle key)\n         (lift_spmf seed_gen \\<bind>\n          (\\<lambda>seed.\n              inline (reduction_oracle seed) \\<A> () \\<bind>\n              (\\<lambda>(b, \\<sigma>).\n                  Generative_Probabilistic_Value.Done b)))\n         () \\<bind>\n        (\\<lambda>(b, uu_). return_spmf b)) =\n    key_seed_gen \\<bind>\n    (\\<lambda>key.\n        exec_gpv (prf'.prf_oracle key) \\<A> () \\<bind>\n        (\\<lambda>(b, uu_). return_spmf b))", "unfolding key_seed_gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. key_gen \\<bind>\n    (\\<lambda>key.\n        exec_gpv (local.prf.prf_oracle key)\n         (lift_spmf seed_gen \\<bind>\n          (\\<lambda>seed.\n              inline (reduction_oracle seed) \\<A> () \\<bind>\n              (\\<lambda>(b, \\<sigma>).\n                  Generative_Probabilistic_Value.Done b)))\n         () \\<bind>\n        (\\<lambda>(b, uu_). return_spmf b)) =\n    key_gen \\<bind>\n    (\\<lambda>k. seed_gen \\<bind> (\\<lambda>s. return_spmf (k, s))) \\<bind>\n    (\\<lambda>key.\n        exec_gpv (prf'.prf_oracle key) \\<A> () \\<bind>\n        (\\<lambda>(b, uu_). return_spmf b))", "by(simp add: exec_gpv_bind split_def exec_gpv_inline reduction_oracle_def bind_map_spmf prf.prf_oracle_def prf'.prf_oracle_def[abs_def]) \n        (transfer_prover)"], ["proof (state)\nthis:\n  local.prf.game_0 (prf'_reduction \\<A>) = prf'.game_0 \\<A>\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "}"], ["proof (state)\nthis:\n  local.prf.game_0 (prf'_reduction \\<A>) = prf'.game_0 \\<A>\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "note hop1 = this[symmetric]"], ["proof (state)\nthis:\n  prf'.game_0 \\<A> = local.prf.game_0 (prf'_reduction \\<A>)\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "define semi_forgetful_RO where \"semi_forgetful_RO = (\\<lambda>seed :: 'seed. \\<lambda>(\\<sigma> :: '\\<alpha> \\<rightharpoonup> '\\<beta> \\<times> '\\<gamma>, b :: bool). \\<lambda>x. \n    case \\<sigma> (h seed x) of Some (a, y) \\<Rightarrow> return_spmf (y, (\\<sigma>, a \\<noteq> x \\<or> b))\n     | None \\<Rightarrow> bind_spmf rand (\\<lambda>y. return_spmf (y, (\\<sigma>(h seed x \\<mapsto> (x, y)), b))))\""], ["proof (state)\nthis:\n  semi_forgetful_RO =\n  (\\<lambda>seed (\\<sigma>, b) x.\n      case \\<sigma> (h seed x) of\n      None \\<Rightarrow>\n        rand \\<bind>\n        (\\<lambda>y.\n            return_spmf (y, \\<sigma>(h seed x \\<mapsto> (x, y)), b))\n      | Some (a, y) \\<Rightarrow>\n          return_spmf (y, \\<sigma>, a \\<noteq> x \\<or> b))\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "define game_semi_forgetful where \"game_semi_forgetful = do {\n     seed :: 'seed \\<leftarrow> seed_gen;\n     (b, rep) \\<leftarrow> exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False);\n     return_spmf (b, rep) \n   }\""], ["proof (state)\nthis:\n  game_semi_forgetful =\n  seed_gen \\<bind>\n  (\\<lambda>seed.\n      exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False) \\<bind>\n      (\\<lambda>(b, rep). return_spmf (b, rep)))\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have bad_semi_forgetful [simp]: \"callee_invariant (semi_forgetful_RO seed) snd\" for seed"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant (semi_forgetful_RO seed) snd", "by(unfold_locales)(auto simp add: semi_forgetful_RO_def split: option.split_asm)"], ["proof (state)\nthis:\n  callee_invariant (semi_forgetful_RO ?seed1) snd\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have lossless_semi_forgetful [simp]: \"lossless_spmf (semi_forgetful_RO seed s1 x)\" for seed s1 x"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (semi_forgetful_RO seed s1 x)", "by(simp add: semi_forgetful_RO_def split_def split: option.split)"], ["proof (state)\nthis:\n  lossless_spmf (semi_forgetful_RO ?seed1 ?s1.1 ?x1)\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "{"], ["proof (state)\nthis:\n  lossless_spmf (semi_forgetful_RO ?seed1 ?s1.1 ?x1)\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "define cr\n      where \"cr = (\\<lambda>(_ :: unit, \\<sigma>) (\\<sigma>' :: '\\<alpha> \\<Rightarrow> ('\\<beta> \\<times> '\\<gamma>) option, _ :: bool). \\<sigma> = map_option snd \\<circ> \\<sigma>')\""], ["proof (state)\nthis:\n  cr =\n  (\\<lambda>(uu_, \\<sigma>) (\\<sigma>', uu_).\n      \\<sigma> = map_option snd \\<circ> \\<sigma>')\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "define initial where \"initial = (Map.empty :: '\\<alpha> \\<Rightarrow> ('\\<beta> \\<times> '\\<gamma>) option, False)\""], ["proof (state)\nthis:\n  initial = (Map.empty, False)\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have [transfer_rule]: \"cr ((), Map.empty) initial\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr ((), Map.empty) initial", "by(simp add: cr_def initial_def fun_eq_iff)"], ["proof (state)\nthis:\n  cr ((), Map.empty) initial\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have [transfer_rule]:  \"((=) ===> cr ===> (=) ===> rel_spmf (rel_prod (=) cr))\n        (\\<lambda>y p ya. do {y \\<leftarrow> prf.random_oracle (snd p) (h y ya); return_spmf (fst y, (), snd y) })\n        semi_forgetful_RO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr ===> (=) ===> rel_spmf (rel_prod (=) cr))\n     (\\<lambda>y p ya.\n         prf.random_oracle (snd p) (h y ya) \\<bind>\n         (\\<lambda>y. return_spmf (fst y, (), snd y)))\n     semi_forgetful_RO", "by(auto simp add: semi_forgetful_RO_def cr_def prf.random_oracle_def rel_fun_def fun_eq_iff split: option.split intro!: rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  ((=) ===> cr ===> (=) ===> rel_spmf (rel_prod (=) cr))\n   (\\<lambda>y p ya.\n       prf.random_oracle (snd p) (h y ya) \\<bind>\n       (\\<lambda>y. return_spmf (fst y, (), snd y)))\n   semi_forgetful_RO\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have \"prf.game_1 ?\\<A> = map_spmf fst game_semi_forgetful\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.prf.game_1 (prf'_reduction \\<A>) =\n    map_spmf fst game_semi_forgetful", "unfolding prf.game_1_def prf'_reduction_def game_semi_forgetful_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv prf.random_oracle\n     (lift_spmf seed_gen \\<bind>\n      (\\<lambda>seed.\n          inline (reduction_oracle seed) \\<A> () \\<bind>\n          (\\<lambda>(b, \\<sigma>). Generative_Probabilistic_Value.Done b)))\n     Map.empty \\<bind>\n    (\\<lambda>(b, uu_). return_spmf b) =\n    map_spmf fst\n     (seed_gen \\<bind>\n      (\\<lambda>seed.\n          exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False) \\<bind>\n          (\\<lambda>(b, rep). return_spmf (b, rep))))", "by(simp add: exec_gpv_bind exec_gpv_inline split_def bind_map_spmf map_spmf_bind_spmf o_def map_spmf_conv_bind_spmf reduction_oracle_def initial_def[symmetric])\n        (transfer_prover)"], ["proof (state)\nthis:\n  local.prf.game_1 (prf'_reduction \\<A>) = map_spmf fst game_semi_forgetful\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "}"], ["proof (state)\nthis:\n  local.prf.game_1 (prf'_reduction \\<A>) = map_spmf fst game_semi_forgetful\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "note hop2 = this"], ["proof (state)\nthis:\n  local.prf.game_1 (prf'_reduction \\<A>) = map_spmf fst game_semi_forgetful\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "define game_semi_forgetful_bad where \"game_semi_forgetful_bad = do {\n       seed :: 'seed \\<leftarrow> seed_gen;\n       x \\<leftarrow> exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False);\n       return_spmf (snd x) \n       }\""], ["proof (state)\nthis:\n  game_semi_forgetful_bad =\n  seed_gen \\<bind>\n  (\\<lambda>seed.\n      exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False) \\<bind>\n      (\\<lambda>x. return_spmf (snd x)))\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have game_semi_forgetful_bad : \"map_spmf snd game_semi_forgetful = game_semi_forgetful_bad\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd game_semi_forgetful = game_semi_forgetful_bad", "unfolding game_semi_forgetful_bad_def game_semi_forgetful_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd\n     (seed_gen \\<bind>\n      (\\<lambda>seed.\n          exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False) \\<bind>\n          (\\<lambda>(b, rep). return_spmf (b, rep)))) =\n    seed_gen \\<bind>\n    (\\<lambda>seed.\n        exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False) \\<bind>\n        (\\<lambda>x. return_spmf (snd x)))", "by(simp add: map_spmf_bind_spmf o_def)"], ["proof (state)\nthis:\n  map_spmf snd game_semi_forgetful = game_semi_forgetful_bad\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have bad_random_oracle_A [simp]: \"callee_invariant prf.random_oracle (\\<lambda>\\<sigma>. \\<not> inj_on (h seed) (dom \\<sigma>))\" for seed"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant prf.random_oracle\n     (\\<lambda>\\<sigma>. \\<not> inj_on (h seed) (dom \\<sigma>))", "by unfold_locales(auto simp add: prf.random_oracle_def split: option.split_asm)"], ["proof (state)\nthis:\n  callee_invariant prf.random_oracle\n   (\\<lambda>\\<sigma>. \\<not> inj_on (h ?seed1) (dom \\<sigma>))\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "define invar\n    where \"invar = (\\<lambda>seed (\\<sigma>1, b) (\\<sigma>2 :: '\\<beta> \\<Rightarrow> '\\<gamma> option). \\<not> b \\<and> dom \\<sigma>1 = h seed ` dom \\<sigma>2 \\<and> \n      (\\<forall>x \\<in> dom \\<sigma>2. \\<sigma>1 (h seed x) = map_option (Pair x) (\\<sigma>2 x)))\""], ["proof (state)\nthis:\n  invar =\n  (\\<lambda>seed (\\<sigma>1, b) \\<sigma>2.\n      \\<not> b \\<and>\n      dom \\<sigma>1 = h seed ` dom \\<sigma>2 \\<and>\n      (\\<forall>x\\<in>dom \\<sigma>2.\n          \\<sigma>1 (h seed x) = map_option (Pair x) (\\<sigma>2 x)))\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have rel_spmf_oracle_adv: \n    \"rel_spmf (\\<lambda>(x, s1) (y, s2). snd s1 \\<noteq> inj_on (h seed) (dom s2) \\<and> (inj_on (h seed) (dom s2) \\<longrightarrow> x = y \\<and> invar seed s1 s2))\n      (exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False))\n      (exec_gpv prf.random_oracle \\<A> Map.empty)\"\n    if seed: \"seed \\<in> set_spmf seed_gen\" for seed"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(x, s1) (y, s2).\n         snd s1 \\<noteq> inj_on (h seed) (dom s2) \\<and>\n         (inj_on (h seed) (dom s2) \\<longrightarrow>\n          x = y \\<and> invar seed s1 s2))\n     (exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False))\n     (exec_gpv prf.random_oracle \\<A> Map.empty)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(x, s1) (y, s2).\n         snd s1 \\<noteq> inj_on (h seed) (dom s2) \\<and>\n         (inj_on (h seed) (dom s2) \\<longrightarrow>\n          x = y \\<and> invar seed s1 s2))\n     (exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False))\n     (exec_gpv prf.random_oracle \\<A> Map.empty)", "have invar_initial [simp]: \"invar seed (Map.empty, False) Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar seed (Map.empty, False) Map.empty", "by(simp add: invar_def)"], ["proof (state)\nthis:\n  invar seed (Map.empty, False) Map.empty\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(x, s1) (y, s2).\n         snd s1 \\<noteq> inj_on (h seed) (dom s2) \\<and>\n         (inj_on (h seed) (dom s2) \\<longrightarrow>\n          x = y \\<and> invar seed s1 s2))\n     (exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False))\n     (exec_gpv prf.random_oracle \\<A> Map.empty)", "have invarD_inj: \"inj_on (h seed) (dom s2)\" if \"invar seed bs1 s2\" for bs1 s2"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (h seed) (dom s2)", "using that"], ["proof (prove)\nusing this:\n  invar seed bs1 s2\n\ngoal (1 subgoal):\n 1. inj_on (h seed) (dom s2)", "by(auto intro!: inj_onI simp add: invar_def)(metis domI domIff option.map_sel prod.inject)"], ["proof (state)\nthis:\n  invar seed ?bs1.1 ?s2.1 \\<Longrightarrow> inj_on (h seed) (dom ?s2.1)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(x, s1) (y, s2).\n         snd s1 \\<noteq> inj_on (h seed) (dom s2) \\<and>\n         (inj_on (h seed) (dom s2) \\<longrightarrow>\n          x = y \\<and> invar seed s1 s2))\n     (exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False))\n     (exec_gpv prf.random_oracle \\<A> Map.empty)", "let ?R = \"\\<lambda>(a, s1) (b, s2 :: '\\<beta> \\<Rightarrow> '\\<gamma> option).\n        snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n        (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow> a = b \\<and> invar seed s1 s2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(x, s1) (y, s2).\n         snd s1 \\<noteq> inj_on (h seed) (dom s2) \\<and>\n         (inj_on (h seed) (dom s2) \\<longrightarrow>\n          x = y \\<and> invar seed s1 s2))\n     (exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False))\n     (exec_gpv prf.random_oracle \\<A> Map.empty)", "have step: \"rel_spmf ?R (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\"\n      if X: \"invar seed \\<sigma>1b s2\" for s2 \\<sigma>1b x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "obtain \\<sigma>1 b where [simp]: \"\\<sigma>1b = (\\<sigma>1, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>1 b.\n        \\<sigma>1b = (\\<sigma>1, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \\<sigma>1b)"], ["proof (state)\nthis:\n  \\<sigma>1b = (\\<sigma>1, b)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "from X"], ["proof (chain)\npicking this:\n  invar seed \\<sigma>1b s2", "have not_b: \"\\<not> b\"\n        and dom: \"dom \\<sigma>1 = h seed ` dom s2\"\n        and eq: \"\\<forall>x\\<in>dom s2. \\<sigma>1 (h seed x) = map_option (Pair x) (s2 x)\""], ["proof (prove)\nusing this:\n  invar seed \\<sigma>1b s2\n\ngoal (1 subgoal):\n 1. \\<not> b &&&\n    dom \\<sigma>1 = h seed ` dom s2 &&&\n    \\<forall>x\\<in>dom s2. \\<sigma>1 (h seed x) = map_option (Pair x) (s2 x)", "by(simp_all add: invar_def)"], ["proof (state)\nthis:\n  \\<not> b\n  dom \\<sigma>1 = h seed ` dom s2\n  \\<forall>x\\<in>dom s2. \\<sigma>1 (h seed x) = map_option (Pair x) (s2 x)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "from X"], ["proof (chain)\npicking this:\n  invar seed \\<sigma>1b s2", "have inj: \"inj_on (h seed) (dom s2)\""], ["proof (prove)\nusing this:\n  invar seed \\<sigma>1b s2\n\ngoal (1 subgoal):\n 1. inj_on (h seed) (dom s2)", "by(rule invarD_inj)"], ["proof (state)\nthis:\n  inj_on (h seed) (dom s2)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "have not_in_image: \"h seed x \\<notin> h seed ` (dom s2 - {x})\" if \"\\<sigma>1 (h seed x) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h seed x \\<notin> h seed ` (dom s2 - {x})", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. h seed x \\<in> h seed ` (dom s2 - {x}) \\<Longrightarrow> False", "assume \"h seed x \\<in> h seed ` (dom s2 - {x})\""], ["proof (state)\nthis:\n  h seed x \\<in> h seed ` (dom s2 - {x})\n\ngoal (1 subgoal):\n 1. h seed x \\<in> h seed ` (dom s2 - {x}) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  h seed x \\<in> h seed ` (dom s2 - {x})", "obtain y where \"y \\<in> dom s2\" and hx_hy: \"h seed x = h seed y\""], ["proof (prove)\nusing this:\n  h seed x \\<in> h seed ` (dom s2 - {x})\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> dom s2; h seed x = h seed y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto)"], ["proof (state)\nthis:\n  y \\<in> dom s2\n  h seed x = h seed y\n\ngoal (1 subgoal):\n 1. h seed x \\<in> h seed ` (dom s2 - {x}) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y \\<in> dom s2\n  h seed x = h seed y", "have \"\\<sigma>1 (h seed y) = None\""], ["proof (prove)\nusing this:\n  y \\<in> dom s2\n  h seed x = h seed y\n\ngoal (1 subgoal):\n 1. \\<sigma>1 (h seed y) = None", "using that"], ["proof (prove)\nusing this:\n  y \\<in> dom s2\n  h seed x = h seed y\n  \\<sigma>1 (h seed x) = None\n\ngoal (1 subgoal):\n 1. \\<sigma>1 (h seed y) = None", "by (auto)"], ["proof (state)\nthis:\n  \\<sigma>1 (h seed y) = None\n\ngoal (1 subgoal):\n 1. h seed x \\<in> h seed ` (dom s2 - {x}) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<sigma>1 (h seed y) = None", "have \"h seed y \\<notin> h seed ` dom s2\""], ["proof (prove)\nusing this:\n  \\<sigma>1 (h seed y) = None\n\ngoal (1 subgoal):\n 1. h seed y \\<notin> h seed ` dom s2", "using dom"], ["proof (prove)\nusing this:\n  \\<sigma>1 (h seed y) = None\n  dom \\<sigma>1 = h seed ` dom s2\n\ngoal (1 subgoal):\n 1. h seed y \\<notin> h seed ` dom s2", "by (auto)"], ["proof (state)\nthis:\n  h seed y \\<notin> h seed ` dom s2\n\ngoal (1 subgoal):\n 1. h seed x \\<in> h seed ` (dom s2 - {x}) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  h seed y \\<notin> h seed ` dom s2", "have \"y \\<notin> dom s2\""], ["proof (prove)\nusing this:\n  h seed y \\<notin> h seed ` dom s2\n\ngoal (1 subgoal):\n 1. y \\<notin> dom s2", "by (auto)"], ["proof (state)\nthis:\n  y \\<notin> dom s2\n\ngoal (1 subgoal):\n 1. h seed x \\<in> h seed ` (dom s2 - {x}) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y \\<notin> dom s2", "show False"], ["proof (prove)\nusing this:\n  y \\<notin> dom s2\n\ngoal (1 subgoal):\n 1. False", "using \\<open>y \\<in> dom s2\\<close>"], ["proof (prove)\nusing this:\n  y \\<notin> dom s2\n  y \\<in> dom s2\n\ngoal (1 subgoal):\n 1. False", "by(auto)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma>1 (h seed x) = None \\<Longrightarrow>\n  h seed x \\<notin> h seed ` (dom s2 - {x})\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "proof(cases \"\\<sigma>1 (h seed x)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma>1 (h seed x) = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n 2. \\<And>a.\n       \\<sigma>1 (h seed x) = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "case \\<sigma>1: None"], ["proof (state)\nthis:\n  \\<sigma>1 (h seed x) = None\n\ngoal (2 subgoals):\n 1. \\<sigma>1 (h seed x) = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n 2. \\<And>a.\n       \\<sigma>1 (h seed x) = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "hence s2: \"s2 x = None\""], ["proof (prove)\nusing this:\n  \\<sigma>1 (h seed x) = None\n\ngoal (1 subgoal):\n 1. s2 x = None", "using dom"], ["proof (prove)\nusing this:\n  \\<sigma>1 (h seed x) = None\n  dom \\<sigma>1 = h seed ` dom s2\n\ngoal (1 subgoal):\n 1. s2 x = None", "by(auto)"], ["proof (state)\nthis:\n  s2 x = None\n\ngoal (2 subgoals):\n 1. \\<sigma>1 (h seed x) = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n 2. \\<And>a.\n       \\<sigma>1 (h seed x) = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "have \"insert (h seed x) (dom \\<sigma>1) = insert (h seed x) (h seed ` dom s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (h seed x) (dom \\<sigma>1) = insert (h seed x) (h seed ` dom s2)", "by(simp add: dom)"], ["proof (state)\nthis:\n  insert (h seed x) (dom \\<sigma>1) = insert (h seed x) (h seed ` dom s2)\n\ngoal (2 subgoals):\n 1. \\<sigma>1 (h seed x) = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n 2. \\<And>a.\n       \\<sigma>1 (h seed x) = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "then"], ["proof (chain)\npicking this:\n  insert (h seed x) (dom \\<sigma>1) = insert (h seed x) (h seed ` dom s2)", "have invar_update: \"invar seed (\\<sigma>1(h seed x \\<mapsto> (x, bs)), False) (s2(x \\<mapsto> bs))\" for bs"], ["proof (prove)\nusing this:\n  insert (h seed x) (dom \\<sigma>1) = insert (h seed x) (h seed ` dom s2)\n\ngoal (1 subgoal):\n 1. invar seed (\\<sigma>1(h seed x \\<mapsto> (x, bs)), False)\n     (s2(x \\<mapsto> bs))", "using inj not_b not_in_image \\<sigma>1 dom"], ["proof (prove)\nusing this:\n  insert (h seed x) (dom \\<sigma>1) = insert (h seed x) (h seed ` dom s2)\n  inj_on (h seed) (dom s2)\n  \\<not> b\n  \\<sigma>1 (h seed x) = None \\<Longrightarrow>\n  h seed x \\<notin> h seed ` (dom s2 - {x})\n  \\<sigma>1 (h seed x) = None\n  dom \\<sigma>1 = h seed ` dom s2\n\ngoal (1 subgoal):\n 1. invar seed (\\<sigma>1(h seed x \\<mapsto> (x, bs)), False)\n     (s2(x \\<mapsto> bs))", "by(auto simp add: invar_def domIff eq) (metis domI domIff imageI)"], ["proof (state)\nthis:\n  invar seed (\\<sigma>1(h seed x \\<mapsto> (x, ?bs2)), False)\n   (s2(x \\<mapsto> ?bs2))\n\ngoal (2 subgoals):\n 1. \\<sigma>1 (h seed x) = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n 2. \\<And>a.\n       \\<sigma>1 (h seed x) = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "with \\<sigma>1 s2"], ["proof (chain)\npicking this:\n  \\<sigma>1 (h seed x) = None\n  s2 x = None\n  invar seed (\\<sigma>1(h seed x \\<mapsto> (x, ?bs2)), False)\n   (s2(x \\<mapsto> ?bs2))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>1 (h seed x) = None\n  s2 x = None\n  invar seed (\\<sigma>1(h seed x \\<mapsto> (x, ?bs2)), False)\n   (s2(x \\<mapsto> ?bs2))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "using inj not_b not_in_image"], ["proof (prove)\nusing this:\n  \\<sigma>1 (h seed x) = None\n  s2 x = None\n  invar seed (\\<sigma>1(h seed x \\<mapsto> (x, ?bs2)), False)\n   (s2(x \\<mapsto> ?bs2))\n  inj_on (h seed) (dom s2)\n  \\<not> b\n  \\<sigma>1 (h seed x) = None \\<Longrightarrow>\n  h seed x \\<notin> h seed ` (dom s2 - {x})\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "by(auto simp add: semi_forgetful_RO_def prf.random_oracle_def intro: rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(a, s1) (b, s2).\n       snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n       (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n        a = b \\<and> invar seed s1 s2))\n   (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<sigma>1 (h seed x) = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<sigma>1 (h seed x) = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "case \\<sigma>1: (Some \"by\")"], ["proof (state)\nthis:\n  \\<sigma>1 (h seed x) = Some by\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<sigma>1 (h seed x) = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "proof(cases \"s2 x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n 2. \\<And>a.\n       s2 x = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "case s2: (Some z)"], ["proof (state)\nthis:\n  s2 x = Some z\n\ngoal (2 subgoals):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n 2. \\<And>a.\n       s2 x = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "with eq \\<sigma>1"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>dom s2. \\<sigma>1 (h seed x) = map_option (Pair x) (s2 x)\n  \\<sigma>1 (h seed x) = Some by\n  s2 x = Some z", "have \"by = (x, z)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>dom s2. \\<sigma>1 (h seed x) = map_option (Pair x) (s2 x)\n  \\<sigma>1 (h seed x) = Some by\n  s2 x = Some z\n\ngoal (1 subgoal):\n 1. by = (x, z)", "by(auto simp add: domIff)"], ["proof (state)\nthis:\n  by = (x, z)\n\ngoal (2 subgoals):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n 2. \\<And>a.\n       s2 x = Some a \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1) (b, s2).\n            snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n            (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n             a = b \\<and> invar seed s1 s2))\n        (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  by = (x, z)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "using \\<sigma>1 inj not_b s2 X"], ["proof (prove)\nusing this:\n  by = (x, z)\n  \\<sigma>1 (h seed x) = Some by\n  inj_on (h seed) (dom s2)\n  \\<not> b\n  s2 x = Some z\n  invar seed \\<sigma>1b s2\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "by(simp add: semi_forgetful_RO_def prf.random_oracle_def split_beta)"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(a, s1) (b, s2).\n       snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n       (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n        a = b \\<and> invar seed s1 s2))\n   (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n\ngoal (1 subgoal):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "case s2: None"], ["proof (state)\nthis:\n  s2 x = None\n\ngoal (1 subgoal):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "from \\<sigma>1 dom"], ["proof (chain)\npicking this:\n  \\<sigma>1 (h seed x) = Some by\n  dom \\<sigma>1 = h seed ` dom s2", "obtain y where y: \"y \\<in> dom s2\" and *: \"h seed x = h seed y\""], ["proof (prove)\nusing this:\n  \\<sigma>1 (h seed x) = Some by\n  dom \\<sigma>1 = h seed ` dom s2\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> dom s2; h seed x = h seed y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(metis domIff imageE option.distinct(1))"], ["proof (state)\nthis:\n  y \\<in> dom s2\n  h seed x = h seed y\n\ngoal (1 subgoal):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "from y"], ["proof (chain)\npicking this:\n  y \\<in> dom s2", "obtain z where z: \"s2 y = Some z\""], ["proof (prove)\nusing this:\n  y \\<in> dom s2\n\ngoal (1 subgoal):\n 1. (\\<And>z. s2 y = Some z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s2 y = Some z\n\ngoal (1 subgoal):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "from eq z \\<sigma>1"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>dom s2. \\<sigma>1 (h seed x) = map_option (Pair x) (s2 x)\n  s2 y = Some z\n  \\<sigma>1 (h seed x) = Some by", "have \"by\": \"by = (y, z)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>dom s2. \\<sigma>1 (h seed x) = map_option (Pair x) (s2 x)\n  s2 y = Some z\n  \\<sigma>1 (h seed x) = Some by\n\ngoal (1 subgoal):\n 1. by = (y, z)", "by(auto simp add: * domIff)"], ["proof (state)\nthis:\n  by = (y, z)\n\ngoal (1 subgoal):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "from y s2"], ["proof (chain)\npicking this:\n  y \\<in> dom s2\n  s2 x = None", "have xny: \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  y \\<in> dom s2\n  s2 x = None\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "with y *"], ["proof (chain)\npicking this:\n  y \\<in> dom s2\n  h seed x = h seed y\n  x \\<noteq> y", "have \"h seed x \\<in> h seed ` (dom s2 - {x})\""], ["proof (prove)\nusing this:\n  y \\<in> dom s2\n  h seed x = h seed y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. h seed x \\<in> h seed ` (dom s2 - {x})", "by auto"], ["proof (state)\nthis:\n  h seed x \\<in> h seed ` (dom s2 - {x})\n\ngoal (1 subgoal):\n 1. s2 x = None \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "then"], ["proof (chain)\npicking this:\n  h seed x \\<in> h seed ` (dom s2 - {x})", "show ?thesis"], ["proof (prove)\nusing this:\n  h seed x \\<in> h seed ` (dom s2 - {x})\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "using \\<sigma>1 s2 not_b \"by\" xny inj"], ["proof (prove)\nusing this:\n  h seed x \\<in> h seed ` (dom s2 - {x})\n  \\<sigma>1 (h seed x) = Some by\n  s2 x = None\n  \\<not> b\n  by = (y, z)\n  x \\<noteq> y\n  inj_on (h seed) (dom s2)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(a, s1) (b, s2).\n         snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n         (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n          a = b \\<and> invar seed s1 s2))\n     (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)", "by(simp add: semi_forgetful_RO_def prf.random_oracle_def split_beta)(rule rel_spmf_bindI2; simp)"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(a, s1) (b, s2).\n       snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n       (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n        a = b \\<and> invar seed s1 s2))\n   (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(a, s1) (b, s2).\n       snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n       (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n        a = b \\<and> invar seed s1 s2))\n   (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(a, s1) (b, s2).\n       snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n       (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n        a = b \\<and> invar seed s1 s2))\n   (semi_forgetful_RO seed \\<sigma>1b x) (prf.random_oracle s2 x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar seed ?\\<sigma>1b2 ?s2.2 \\<Longrightarrow>\n  rel_spmf\n   (\\<lambda>(a, s1) (b, s2).\n       snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n       (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n        a = b \\<and> invar seed s1 s2))\n   (semi_forgetful_RO seed ?\\<sigma>1b2 ?x2) (prf.random_oracle ?s2.2 ?x2)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(x, s1) (y, s2).\n         snd s1 \\<noteq> inj_on (h seed) (dom s2) \\<and>\n         (inj_on (h seed) (dom s2) \\<longrightarrow>\n          x = y \\<and> invar seed s1 s2))\n     (exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False))\n     (exec_gpv prf.random_oracle \\<A> Map.empty)", "from invar_initial _ step"], ["proof (chain)\npicking this:\n  invar seed (Map.empty, False) Map.empty\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  invar seed ?\\<sigma>1b2 ?s2.2 \\<Longrightarrow>\n  rel_spmf\n   (\\<lambda>(a, s1) (b, s2).\n       snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n       (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n        a = b \\<and> invar seed s1 s2))\n   (semi_forgetful_RO seed ?\\<sigma>1b2 ?x2) (prf.random_oracle ?s2.2 ?x2)", "show ?thesis"], ["proof (prove)\nusing this:\n  invar seed (Map.empty, False) Map.empty\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  invar seed ?\\<sigma>1b2 ?s2.2 \\<Longrightarrow>\n  rel_spmf\n   (\\<lambda>(a, s1) (b, s2).\n       snd s1 = (\\<not> inj_on (h seed) (dom s2)) \\<and>\n       (\\<not> \\<not> inj_on (h seed) (dom s2) \\<longrightarrow>\n        a = b \\<and> invar seed s1 s2))\n   (semi_forgetful_RO seed ?\\<sigma>1b2 ?x2) (prf.random_oracle ?s2.2 ?x2)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(x, s1) (y, s2).\n         snd s1 \\<noteq> inj_on (h seed) (dom s2) \\<and>\n         (inj_on (h seed) (dom s2) \\<longrightarrow>\n          x = y \\<and> invar seed s1 s2))\n     (exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False))\n     (exec_gpv prf.random_oracle \\<A> Map.empty)", "by(rule exec_gpv_oracle_bisim_bad_full[where ?bad1.0 = \"snd\" and ?bad2.0 = \"\\<lambda>\\<sigma>. \\<not> inj_on (h seed) (dom \\<sigma>)\"])\n        (simp_all add: assms)"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(x, s1) (y, s2).\n       snd s1 \\<noteq> inj_on (h seed) (dom s2) \\<and>\n       (inj_on (h seed) (dom s2) \\<longrightarrow>\n        x = y \\<and> invar seed s1 s2))\n   (exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False))\n   (exec_gpv prf.random_oracle \\<A> Map.empty)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?seed1 \\<in> set_spmf seed_gen \\<Longrightarrow>\n  rel_spmf\n   (\\<lambda>(x, s1) (y, s2).\n       snd s1 \\<noteq> inj_on (h ?seed1) (dom s2) \\<and>\n       (inj_on (h ?seed1) (dom s2) \\<longrightarrow>\n        x = y \\<and> invar ?seed1 s1 s2))\n   (exec_gpv (semi_forgetful_RO ?seed1) \\<A> (Map.empty, False))\n   (exec_gpv prf.random_oracle \\<A> Map.empty)\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "define game_A where \"game_A = do {\n      seed :: 'seed \\<leftarrow> seed_gen;\n      (b, \\<sigma>) \\<leftarrow> exec_gpv prf.random_oracle \\<A> Map.empty;\n      return_spmf (b, \\<not> inj_on (h seed) (dom \\<sigma>))\n    }\""], ["proof (state)\nthis:\n  game_A =\n  seed_gen \\<bind>\n  (\\<lambda>seed.\n      exec_gpv prf.random_oracle \\<A> Map.empty \\<bind>\n      (\\<lambda>(b, \\<sigma>).\n          return_spmf (b, \\<not> inj_on (h seed) (dom \\<sigma>))))\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "let ?bad1 = \"\\<lambda>x. snd (snd x)\" and ?bad2 = \"snd\""], ["proof (state)\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have hop3: \"rel_spmf (\\<lambda>x xa. (?bad1 x \\<longleftrightarrow> ?bad2 xa) \\<and> (\\<not> ?bad2 xa \\<longrightarrow> fst x \\<longleftrightarrow> fst xa)) game_semi_forgetful game_A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>x xa.\n         snd (snd x) = snd xa \\<and>\n         (\\<not> snd xa \\<longrightarrow> fst x = fst xa))\n     game_semi_forgetful game_A", "unfolding game_semi_forgetful_def game_A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>x xa.\n         snd (snd x) = snd xa \\<and>\n         (\\<not> snd xa \\<longrightarrow> fst x = fst xa))\n     (seed_gen \\<bind>\n      (\\<lambda>seed.\n          exec_gpv (semi_forgetful_RO seed) \\<A> (Map.empty, False) \\<bind>\n          (\\<lambda>(b, rep). return_spmf (b, rep))))\n     (seed_gen \\<bind>\n      (\\<lambda>seed.\n          exec_gpv prf.random_oracle \\<A> Map.empty \\<bind>\n          (\\<lambda>(b, \\<sigma>).\n              return_spmf (b, \\<not> inj_on (h seed) (dom \\<sigma>)))))", "by(clarsimp simp add: restrict_bind_spmf split_def map_spmf_bind_spmf restrict_return_spmf o_def intro!: rel_spmf_bind_reflI simp del: bind_return_spmf)\n      (rule rel_spmf_bindI[OF rel_spmf_oracle_adv]; auto)"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>x xa.\n       snd (snd x) = snd xa \\<and>\n       (\\<not> snd xa \\<longrightarrow> fst x = fst xa))\n   game_semi_forgetful game_A\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have bad1_bad2: \"spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True = spmf (map_spmf snd game_A) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True =\n    spmf (map_spmf snd game_A) True", "using fundamental_lemma_bad[OF hop3]"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure (measure_spmf game_semi_forgetful)\n   {x. snd (snd x)} =\n  Sigma_Algebra.measure (measure_spmf game_A) {y. snd y}\n\ngoal (1 subgoal):\n 1. spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True =\n    spmf (map_spmf snd game_A) True", "by(simp add: measure_map_spmf spmf_conv_measure_spmf vimage_def)"], ["proof (state)\nthis:\n  spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True =\n  spmf (map_spmf snd game_A) True\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have bound_bad1_event: \"\\<bar>spmf (map_spmf fst game_semi_forgetful) True - spmf (map_spmf fst game_A) True\\<bar> \\<le> spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n          spmf (map_spmf fst game_A) True\\<bar>\n    \\<le> spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True", "using fundamental_lemma[OF hop3]"], ["proof (prove)\nusing this:\n  \\<bar>Sigma_Algebra.measure (measure_spmf game_semi_forgetful)\n         {x. fst x} -\n        Sigma_Algebra.measure (measure_spmf game_A) {y. fst y}\\<bar>\n  \\<le> Sigma_Algebra.measure (measure_spmf game_semi_forgetful)\n         {x. snd (snd x)}\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n          spmf (map_spmf fst game_A) True\\<bar>\n    \\<le> spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True", "by(simp add: measure_map_spmf spmf_conv_measure_spmf vimage_def)"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n        spmf (map_spmf fst game_A) True\\<bar>\n  \\<le> spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "then"], ["proof (chain)\npicking this:\n  \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n        spmf (map_spmf fst game_A) True\\<bar>\n  \\<le> spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True", "have bound_bad2_event : \"\\<bar>spmf (map_spmf fst game_semi_forgetful) True - spmf (map_spmf fst game_A) True\\<bar> \\<le> spmf (map_spmf snd game_A) True\""], ["proof (prove)\nusing this:\n  \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n        spmf (map_spmf fst game_A) True\\<bar>\n  \\<le> spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n          spmf (map_spmf fst game_A) True\\<bar>\n    \\<le> spmf (map_spmf snd game_A) True", "using bad1_bad2"], ["proof (prove)\nusing this:\n  \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n        spmf (map_spmf fst game_A) True\\<bar>\n  \\<le> spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True\n  spmf (map_spmf (snd \\<circ> snd) game_semi_forgetful) True =\n  spmf (map_spmf snd game_A) True\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n          spmf (map_spmf fst game_A) True\\<bar>\n    \\<le> spmf (map_spmf snd game_A) True", "by (simp)"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n        spmf (map_spmf fst game_A) True\\<bar>\n  \\<le> spmf (map_spmf snd game_A) True\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "define game_B where \"game_B = do {\n      (b, \\<sigma>) \\<leftarrow> exec_gpv prf.random_oracle \\<A> Map.empty;\n      hash.game_hash_set (dom \\<sigma>)\n    }\""], ["proof (state)\nthis:\n  game_B =\n  exec_gpv prf.random_oracle \\<A> Map.empty \\<bind>\n  (\\<lambda>(b, \\<sigma>). local.hash.game_hash_set (dom \\<sigma>))\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have game_A_game_B: \"map_spmf snd game_A = game_B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd game_A = game_B", "unfolding game_B_def game_A_def hash.game_hash_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd\n     (seed_gen \\<bind>\n      (\\<lambda>seed.\n          exec_gpv prf.random_oracle \\<A> Map.empty \\<bind>\n          (\\<lambda>(b, \\<sigma>).\n              return_spmf (b, \\<not> inj_on (h seed) (dom \\<sigma>))))) =\n    exec_gpv prf.random_oracle \\<A> Map.empty \\<bind>\n    (\\<lambda>(b, \\<sigma>).\n        seed_gen \\<bind>\n        (\\<lambda>seed.\n            return_spmf (\\<not> inj_on (h seed) (dom \\<sigma>))))", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd\n     (seed_gen \\<bind>\n      (\\<lambda>seed.\n          exec_gpv prf.random_oracle \\<A> Map.empty \\<bind>\n          (\\<lambda>(b, \\<sigma>).\n              return_spmf (b, \\<not> inj_on (h seed) (dom \\<sigma>))))) =\n    exec_gpv prf.random_oracle \\<A> Map.empty \\<bind>\n    (\\<lambda>(b, \\<sigma>).\n        seed_gen \\<bind>\n        (\\<lambda>seed.\n            return_spmf (\\<not> inj_on (h seed) (dom \\<sigma>))))", "by(simp add: map_spmf_bind_spmf o_def split_def)"], ["proof (state)\nthis:\n  map_spmf snd game_A = game_B\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have game_B_bound : \"spmf game_B True \\<le> hash.\\<epsilon>_uh * q * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf game_B True \\<le> local.hash.\\<epsilon>_uh * real q * real q", "unfolding game_B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (exec_gpv prf.random_oracle \\<A> Map.empty \\<bind>\n      (\\<lambda>(b, \\<sigma>). local.hash.game_hash_set (dom \\<sigma>)))\n     True\n    \\<le> local.hash.\\<epsilon>_uh * real q * real q", "proof(rule spmf_bind_leI, clarify)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> set_spmf\n              (exec_gpv prf.random_oracle \\<A> Map.empty) \\<Longrightarrow>\n       spmf (local.hash.game_hash_set (dom b)) True\n       \\<le> local.hash.\\<epsilon>_uh * real q * real q\n 2. 0 \\<le> local.hash.\\<epsilon>_uh * real q * real q", "fix b \\<sigma>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> set_spmf\n              (exec_gpv prf.random_oracle \\<A> Map.empty) \\<Longrightarrow>\n       spmf (local.hash.game_hash_set (dom b)) True\n       \\<le> local.hash.\\<epsilon>_uh * real q * real q\n 2. 0 \\<le> local.hash.\\<epsilon>_uh * real q * real q", "assume *: \"(b, \\<sigma>) \\<in> set_spmf (exec_gpv prf.random_oracle \\<A> Map.empty)\""], ["proof (state)\nthis:\n  (b, \\<sigma>) \\<in> set_spmf (exec_gpv prf.random_oracle \\<A> Map.empty)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> set_spmf\n              (exec_gpv prf.random_oracle \\<A> Map.empty) \\<Longrightarrow>\n       spmf (local.hash.game_hash_set (dom b)) True\n       \\<le> local.hash.\\<epsilon>_uh * real q * real q\n 2. 0 \\<le> local.hash.\\<epsilon>_uh * real q * real q", "have \"finite (dom \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom \\<sigma>)", "by(rule prf.finite.exec_gpv_invariant[OF *]) simp_all"], ["proof (state)\nthis:\n  finite (dom \\<sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> set_spmf\n              (exec_gpv prf.random_oracle \\<A> Map.empty) \\<Longrightarrow>\n       spmf (local.hash.game_hash_set (dom b)) True\n       \\<le> local.hash.\\<epsilon>_uh * real q * real q\n 2. 0 \\<le> local.hash.\\<epsilon>_uh * real q * real q", "then"], ["proof (chain)\npicking this:\n  finite (dom \\<sigma>)", "have \"spmf (hash.game_hash_set (dom \\<sigma>)) True \\<le> hash.\\<epsilon>_uh * (card (dom \\<sigma>) * card (dom \\<sigma>))\""], ["proof (prove)\nusing this:\n  finite (dom \\<sigma>)\n\ngoal (1 subgoal):\n 1. spmf (local.hash.game_hash_set (dom \\<sigma>)) True\n    \\<le> local.hash.\\<epsilon>_uh *\n          real (card (dom \\<sigma>) * card (dom \\<sigma>))", "using hash.hash_ineq_card[of \"dom \\<sigma>\"]"], ["proof (prove)\nusing this:\n  finite (dom \\<sigma>)\n  finite (dom \\<sigma>) \\<Longrightarrow>\n  spmf (local.hash.game_hash_set (dom \\<sigma>)) True\n  \\<le> local.hash.\\<epsilon>_uh * real (card (dom \\<sigma>)) *\n        real (card (dom \\<sigma>))\n\ngoal (1 subgoal):\n 1. spmf (local.hash.game_hash_set (dom \\<sigma>)) True\n    \\<le> local.hash.\\<epsilon>_uh *\n          real (card (dom \\<sigma>) * card (dom \\<sigma>))", "by simp"], ["proof (state)\nthis:\n  spmf (local.hash.game_hash_set (dom \\<sigma>)) True\n  \\<le> local.hash.\\<epsilon>_uh *\n        real (card (dom \\<sigma>) * card (dom \\<sigma>))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> set_spmf\n              (exec_gpv prf.random_oracle \\<A> Map.empty) \\<Longrightarrow>\n       spmf (local.hash.game_hash_set (dom b)) True\n       \\<le> local.hash.\\<epsilon>_uh * real q * real q\n 2. 0 \\<le> local.hash.\\<epsilon>_uh * real q * real q", "also"], ["proof (state)\nthis:\n  spmf (local.hash.game_hash_set (dom \\<sigma>)) True\n  \\<le> local.hash.\\<epsilon>_uh *\n        real (card (dom \\<sigma>) * card (dom \\<sigma>))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> set_spmf\n              (exec_gpv prf.random_oracle \\<A> Map.empty) \\<Longrightarrow>\n       spmf (local.hash.game_hash_set (dom b)) True\n       \\<le> local.hash.\\<epsilon>_uh * real q * real q\n 2. 0 \\<le> local.hash.\\<epsilon>_uh * real q * real q", "have p1: \"card (dom \\<sigma>) \\<le> q + card (dom (Map.empty :: '\\<beta> \\<Rightarrow> '\\<gamma> option))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom \\<sigma>) \\<le> q + card (dom Map.empty)", "by(rule prf.card_dom_random_oracle[OF bounded *]) simp"], ["proof (state)\nthis:\n  card (dom \\<sigma>) \\<le> q + card (dom Map.empty)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> set_spmf\n              (exec_gpv prf.random_oracle \\<A> Map.empty) \\<Longrightarrow>\n       spmf (local.hash.game_hash_set (dom b)) True\n       \\<le> local.hash.\\<epsilon>_uh * real q * real q\n 2. 0 \\<le> local.hash.\\<epsilon>_uh * real q * real q", "then"], ["proof (chain)\npicking this:\n  card (dom \\<sigma>) \\<le> q + card (dom Map.empty)", "have \"card (dom \\<sigma>) * card (dom \\<sigma>) \\<le> q * q\""], ["proof (prove)\nusing this:\n  card (dom \\<sigma>) \\<le> q + card (dom Map.empty)\n\ngoal (1 subgoal):\n 1. card (dom \\<sigma>) * card (dom \\<sigma>) \\<le> q * q", "using mult_le_mono"], ["proof (prove)\nusing this:\n  card (dom \\<sigma>) \\<le> q + card (dom Map.empty)\n  \\<lbrakk>?i \\<le> ?j; ?k \\<le> ?l\\<rbrakk>\n  \\<Longrightarrow> ?i * ?k \\<le> ?j * ?l\n\ngoal (1 subgoal):\n 1. card (dom \\<sigma>) * card (dom \\<sigma>) \\<le> q * q", "by auto"], ["proof (state)\nthis:\n  card (dom \\<sigma>) * card (dom \\<sigma>) \\<le> q * q\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> set_spmf\n              (exec_gpv prf.random_oracle \\<A> Map.empty) \\<Longrightarrow>\n       spmf (local.hash.game_hash_set (dom b)) True\n       \\<le> local.hash.\\<epsilon>_uh * real q * real q\n 2. 0 \\<le> local.hash.\\<epsilon>_uh * real q * real q", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      local.hash.\\<epsilon>_uh * real x\n      \\<le> local.hash.\\<epsilon>_uh * real y) \\<Longrightarrow>\n  spmf (local.hash.game_hash_set (dom \\<sigma>)) True\n  \\<le> local.hash.\\<epsilon>_uh * real (q * q)", "show \"spmf (hash.game_hash_set (dom \\<sigma>)) True \\<le> hash.\\<epsilon>_uh * q * q\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      local.hash.\\<epsilon>_uh * real x\n      \\<le> local.hash.\\<epsilon>_uh * real y) \\<Longrightarrow>\n  spmf (local.hash.game_hash_set (dom \\<sigma>)) True\n  \\<le> local.hash.\\<epsilon>_uh * real (q * q)\n\ngoal (1 subgoal):\n 1. spmf (local.hash.game_hash_set (dom \\<sigma>)) True\n    \\<le> local.hash.\\<epsilon>_uh * real q * real q", "by(simp add: hash.\\<epsilon>_uh_nonneg mult_left_mono)"], ["proof (state)\nthis:\n  spmf (local.hash.game_hash_set (dom \\<sigma>)) True\n  \\<le> local.hash.\\<epsilon>_uh * real q * real q\n\ngoal (1 subgoal):\n 1. 0 \\<le> local.hash.\\<epsilon>_uh * real q * real q", "qed(simp add: hash.\\<epsilon>_uh_nonneg)"], ["proof (state)\nthis:\n  spmf game_B True \\<le> local.hash.\\<epsilon>_uh * real q * real q\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have hop4: \"prf'.game_1 \\<A> = map_spmf fst game_A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prf'.game_1 \\<A> = map_spmf fst game_A", "by(simp add: game_A_def prf'.game_1_def map_spmf_bind_spmf o_def split_def bind_spmf_const lossless_seed_gen lossless_weight_spmfD)"], ["proof (state)\nthis:\n  prf'.game_1 \\<A> = map_spmf fst game_A\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have \"prf'.advantage \\<A> \\<le> \\<bar>spmf (prf.game_0 ?\\<A>) True - spmf (prf'.game_1 \\<A>) True\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> \\<bar>spmf (local.prf.game_0 (prf'_reduction \\<A>)) True -\n                spmf (prf'.game_1 \\<A>) True\\<bar>", "using hop1"], ["proof (prove)\nusing this:\n  prf'.game_0 \\<A> = local.prf.game_0 (prf'_reduction \\<A>)\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> \\<bar>spmf (local.prf.game_0 (prf'_reduction \\<A>)) True -\n                spmf (prf'.game_1 \\<A>) True\\<bar>", "by(simp add: prf'.advantage_def)"], ["proof (state)\nthis:\n  prf'.advantage \\<A>\n  \\<le> \\<bar>spmf (local.prf.game_0 (prf'_reduction \\<A>)) True -\n              spmf (prf'.game_1 \\<A>) True\\<bar>\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "also"], ["proof (state)\nthis:\n  prf'.advantage \\<A>\n  \\<le> \\<bar>spmf (local.prf.game_0 (prf'_reduction \\<A>)) True -\n              spmf (prf'.game_1 \\<A>) True\\<bar>\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have \"\\<dots> \\<le> prf.advantage ?\\<A> + \\<bar>spmf (prf.game_1 ?\\<A>) True - spmf (prf'.game_1 \\<A>) True\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.prf.game_0 (prf'_reduction \\<A>)) True -\n          spmf (prf'.game_1 \\<A>) True\\<bar>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          \\<bar>spmf (local.prf.game_1 (prf'_reduction \\<A>)) True -\n                spmf (prf'.game_1 \\<A>) True\\<bar>", "by(simp add: prf.advantage_def)"], ["proof (state)\nthis:\n  \\<bar>spmf (local.prf.game_0 (prf'_reduction \\<A>)) True -\n        spmf (prf'.game_1 \\<A>) True\\<bar>\n  \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n        \\<bar>spmf (local.prf.game_1 (prf'_reduction \\<A>)) True -\n              spmf (prf'.game_1 \\<A>) True\\<bar>\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "also"], ["proof (state)\nthis:\n  \\<bar>spmf (local.prf.game_0 (prf'_reduction \\<A>)) True -\n        spmf (prf'.game_1 \\<A>) True\\<bar>\n  \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n        \\<bar>spmf (local.prf.game_1 (prf'_reduction \\<A>)) True -\n              spmf (prf'.game_1 \\<A>) True\\<bar>\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have \"\\<bar>spmf (prf.game_1 ?\\<A>) True - spmf (prf'.game_1 \\<A>) True\\<bar> \\<le>\n    \\<bar>spmf (map_spmf fst game_semi_forgetful) True - spmf (prf'.game_1 \\<A>) True\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.prf.game_1 (prf'_reduction \\<A>)) True -\n          spmf (prf'.game_1 \\<A>) True\\<bar>\n    \\<le> \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n                spmf (prf'.game_1 \\<A>) True\\<bar>", "using hop2"], ["proof (prove)\nusing this:\n  local.prf.game_1 (prf'_reduction \\<A>) = map_spmf fst game_semi_forgetful\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.prf.game_1 (prf'_reduction \\<A>)) True -\n          spmf (prf'.game_1 \\<A>) True\\<bar>\n    \\<le> \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n                spmf (prf'.game_1 \\<A>) True\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>spmf (local.prf.game_1 (prf'_reduction \\<A>)) True -\n        spmf (prf'.game_1 \\<A>) True\\<bar>\n  \\<le> \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n              spmf (prf'.game_1 \\<A>) True\\<bar>\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "also"], ["proof (state)\nthis:\n  \\<bar>spmf (local.prf.game_1 (prf'_reduction \\<A>)) True -\n        spmf (prf'.game_1 \\<A>) True\\<bar>\n  \\<le> \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n              spmf (prf'.game_1 \\<A>) True\\<bar>\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "have \"\\<dots> \\<le> hash.\\<epsilon>_uh * q * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n          spmf (prf'.game_1 \\<A>) True\\<bar>\n    \\<le> local.hash.\\<epsilon>_uh * real q * real q", "using game_A_game_B game_B_bound bound_bad2_event hop4"], ["proof (prove)\nusing this:\n  map_spmf snd game_A = game_B\n  spmf game_B True \\<le> local.hash.\\<epsilon>_uh * real q * real q\n  \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n        spmf (map_spmf fst game_A) True\\<bar>\n  \\<le> spmf (map_spmf snd game_A) True\n  prf'.game_1 \\<A> = map_spmf fst game_A\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n          spmf (prf'.game_1 \\<A>) True\\<bar>\n    \\<le> local.hash.\\<epsilon>_uh * real q * real q", "by(simp)"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game_semi_forgetful) True -\n        spmf (prf'.game_1 \\<A>) True\\<bar>\n  \\<le> local.hash.\\<epsilon>_uh * real q * real q\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              local.prf.advantage (prf'_reduction \\<A>) + x\n              \\<le> local.prf.advantage (prf'_reduction \\<A>) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      local.prf.advantage (prf'_reduction \\<A>) + x\n      \\<le> local.prf.advantage (prf'_reduction \\<A>) + y\\<rbrakk>\n  \\<Longrightarrow> prf'.advantage \\<A>\n                    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n                          local.hash.\\<epsilon>_uh * real q * real q", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              local.prf.advantage (prf'_reduction \\<A>) + x\n              \\<le> local.prf.advantage (prf'_reduction \\<A>) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      local.prf.advantage (prf'_reduction \\<A>) + x\n      \\<le> local.prf.advantage (prf'_reduction \\<A>) + y\\<rbrakk>\n  \\<Longrightarrow> prf'.advantage \\<A>\n                    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n                          local.hash.\\<epsilon>_uh * real q * real q\n\ngoal (1 subgoal):\n 1. prf'.advantage \\<A>\n    \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n          local.hash.\\<epsilon>_uh * real q * real q", "by(simp add: add_left_mono)"], ["proof (state)\nthis:\n  prf'.advantage \\<A>\n  \\<le> local.prf.advantage (prf'_reduction \\<A>) +\n        local.hash.\\<epsilon>_uh * real q * real q\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}