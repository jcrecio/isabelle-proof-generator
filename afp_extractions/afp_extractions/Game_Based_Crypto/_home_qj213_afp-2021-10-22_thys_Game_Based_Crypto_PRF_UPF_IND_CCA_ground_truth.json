{"file_name": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto/PRF_UPF_IND_CCA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto", "problem_names": ["lemma lossless_key_gen [simp]: \"lossless_spmf key_gen\"", "lemma lossless_encrypt [simp]: \"lossless_spmf (encrypt k m)\"", "lemma cipher_correct:\n  \"\\<lbrakk> k \\<in> set_spmf key_gen; length m = prf_clen \\<rbrakk>\n  \\<Longrightarrow> encrypt k m \\<bind> (\\<lambda>c. return_spmf (decrypt k c)) = return_spmf (Some m)\"", "lemma intercept_upf_simps [simp]:\n  \"intercept_upf k b (L, D) (Inr (x, c, t)) =\n    (if (x, c, t) \\<in> L \\<or> length x \\<noteq> prf_dlen then Done (Inr None, (L, D)) else do {\n      Pause (Inr (x @ c, t)) Done;\n      Done (Inr None, (L, insert (x, c, t) D))\n    })\"\n  \"intercept_upf k b (L, D) (Inl (m1, m0)) = \n    (case (length m1 = prf_clen \\<and> length m0 = prf_clen) of\n      False \\<Rightarrow> Done (Inl None, L, D)\n    | True \\<Rightarrow> do {\n        x \\<leftarrow> lift_spmf (spmf_of_set prf_domain);\n        let c = prf_fun k x [\\<oplus>] (if b then m1 else m0);\n        t \\<leftarrow> Pause (Inl (x @ c)) Done;\n        Done (Inl (Some (x, c, projl t)), (insert (x, c, projl t) L, D))\n      })\"", "lemma interaction_bounded_by_upf_enc_Inr [interaction_bound]:\n  \"interaction_bounded_by (Not \\<circ> isl) (intercept_upf_enc k b LD mm) 0\"", "lemma interaction_bounded_by_upf_dec_Inr [interaction_bound]:\n  \"interaction_bounded_by (Not \\<circ> isl) (intercept_upf_dec LD c) 1\"", "lemma interaction_bounded_by_intercept_upf_Inr [interaction_bound]:\n  \"interaction_bounded_by (Not \\<circ> isl) (intercept_upf k b LD x) 1\"", "lemma interaction_bounded_by_intercept_upf_Inl [interaction_bound]:\n  \"isl x \\<Longrightarrow> interaction_bounded_by (Not \\<circ> isl) (intercept_upf k b LD x) 0\"", "lemma lossless_intercept_upf_enc [simp]: \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (intercept_upf_enc k b LD mm)\"", "lemma lossless_intercept_upf_dec [simp]: \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (intercept_upf_dec LD mm)\"", "lemma lossless_intercept_upf [simp]: \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (intercept_upf k b LD x)\"", "lemma results_gpv_intercept_upf [simp]: \"results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (intercept_upf k b LD x) \\<subseteq> responses_\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) x \\<times> UNIV\"", "lemma lossless_reduction_upf [simp]: \n  \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A> \\<Longrightarrow> lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (reduction_upf \\<A>)\"", "lemma round_1:\n  assumes \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\"\n  shows \"\\<bar>spmf (ind_cca.game \\<A>) True - spmf (ind_cca'.game \\<A>) True\\<bar> \\<le> UPF.advantage (reduction_upf \\<A>)\"", "lemma lossless_oracle_decrypt2 [simp]: \"lossless_spmf (oracle_decrypt2 k Dbad c)\"", "lemma callee_invariant_oracle_decrypt2 [simp]: \"callee_invariant (oracle_decrypt2 key) fst\"", "lemma oracle_decrypt2_parametric [transfer_rule]:\n  \"(rel_prod P U ===> S ===> rel_prod (=) (rel_prod (=) H) ===> rel_spmf (rel_prod (=) S))\n   oracle_decrypt2 oracle_decrypt2\"", "lemma round_2: \"\\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> = PRF.advantage (reduction_prf \\<A>)\"", "lemma lossless_oracle_encrypt3 [simp]:\n  \"lossless_spmf (oracle_encrypt3 k b D m10) \"", "lemma callee_invariant_oracle_encrypt3 [simp]: \"callee_invariant (oracle_encrypt3 key b) fst\"", "lemma round_3:\n  assumes \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\"\n  shows \"\\<bar>measure (measure_spmf (game3 \\<A>)) {(b, bad). b} - spmf (game2 \\<A>) True\\<bar> \n          \\<le> measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\"", "lemma round_4:\n  assumes \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\"\n  shows \"map_spmf fst (game3 \\<A>) = coin_spmf\"", "lemma game3_bad:\n  assumes \"interaction_bounded_by isl \\<A> q\"\n  shows \"measure (measure_spmf (game3 \\<A>)) {(b, bad). bad} \\<le> q / card prf_domain * q\"", "theorem security:\n  assumes lossless: \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\"\n  and bound: \"interaction_bounded_by isl \\<A> q\"\n  shows \"ind_cca.advantage \\<A> \\<le> \n    PRF.advantage (reduction_prf \\<A>) + UPF.advantage (reduction_upf \\<A>) +\n    real q / real (card prf_domain) * real q\" (is \"?LHS \\<le> _\")", "theorem security1:\n  assumes lossless: \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\"\n  assumes q: \"interaction_bounded_by isl \\<A> q\"\n  and q': \"interaction_bounded_by (Not \\<circ> isl) \\<A> q'\"\n  shows \"ind_cca.advantage \\<A> \\<le> \n    PRF.advantage (reduction_prf \\<A>) +\n    UPF.advantage1 (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>) ()) * q' +\n    real q * real q / real (card prf_domain)\"", "theorem security_asymptotic:\n  fixes q q' :: \"security \\<Rightarrow> nat\"\n  assumes lossless: \"\\<And>\\<eta>. lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (\\<A> \\<eta>)\"\n  and bound: \"\\<And>\\<eta>. interaction_bounded_by isl (\\<A> \\<eta>) (q \\<eta>)\"\n  and bound': \"\\<And>\\<eta>. interaction_bounded_by (Not \\<circ> isl) (\\<A> \\<eta>) (q' \\<eta>)\"\n  and [negligible_intros]:\n    \"polynomial q'\" \"polynomial q\"\n    \"negligible (\\<lambda>\\<eta>. PRF.advantage \\<eta> (reduction_prf \\<eta> (\\<A> \\<eta>)))\"\n    \"negligible (\\<lambda>\\<eta>. UPF.advantage1 \\<eta> (guessing_many_one.reduction (q' \\<eta>) (\\<lambda>_. reduction_upf \\<eta> (\\<A> \\<eta>)) ()))\"\n    \"negligible (\\<lambda>\\<eta>. 1 / card (prf_domain \\<eta>))\"\n  shows \"negligible (\\<lambda>\\<eta>. ind_cca.advantage \\<eta> (\\<A> \\<eta>))\""], "translations": [["", "lemma lossless_key_gen [simp]: \"lossless_spmf key_gen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf key_gen", "by(simp add: key_gen_def prf_key_gen_lossless upf_key_gen_lossless)"], ["", "fun encrypt :: \"('prf_key \\<times> 'upf_key) \\<Rightarrow> bitstring \\<Rightarrow> 'hash cipher_text spmf\"\nwhere\n  \"encrypt (k_prf, k_upf) m = do {\n    x \\<leftarrow> spmf_of_set prf_domain;\n    let c = prf_fun k_prf x [\\<oplus>] m;\n    let t = upf_fun k_upf (x @ c);\n    return_spmf ((x, c, t))\n  }\""], ["", "lemma lossless_encrypt [simp]: \"lossless_spmf (encrypt k m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (encrypt k m)", "by (cases k) (simp add: Let_def prf_domain_nonempty prf_domain_finite split: bool.split)"], ["", "fun decrypt :: \"('prf_key \\<times> 'upf_key) \\<Rightarrow> 'hash cipher_text \\<Rightarrow> bitstring option\"\nwhere\n  \"decrypt (k_prf, k_upf) (x, c, t) = (\n    if upf_fun k_upf (x @ c) = t \\<and> length x = prf_dlen then\n      Some (prf_fun k_prf x [\\<oplus>] c)\n    else\n      None\n  )\""], ["", "lemma cipher_correct:\n  \"\\<lbrakk> k \\<in> set_spmf key_gen; length m = prf_clen \\<rbrakk>\n  \\<Longrightarrow> encrypt k m \\<bind> (\\<lambda>c. return_spmf (decrypt k c)) = return_spmf (Some m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<in> set_spmf key_gen; length m = prf_clen\\<rbrakk>\n    \\<Longrightarrow> encrypt k m \\<bind>\n                      (\\<lambda>c. return_spmf (decrypt k c)) =\n                      return_spmf (Some m)", "by (cases k) (simp add: prf_domain_nonempty prf_domain_finite prf_domain_length\n  prf_codomain_length key_gen_def bind_eq_return_spmf Let_def)"], ["", "declare encrypt.simps[simp del]"], ["", "sublocale ind_cca: ind_cca key_gen encrypt decrypt \"\\<lambda>m. length m = prf_clen\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation ind_cca': ind_cca key_gen encrypt \"\\<lambda> _ _. None\" \"\\<lambda>m. length m = prf_clen\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition intercept_upf_enc\n  :: \"'prf_key \\<Rightarrow> bool \\<Rightarrow> 'hash cipher_text set \\<times> 'hash cipher_text set \\<Rightarrow> bitstring \\<times> bitstring\n  \\<Rightarrow> ('hash cipher_text option \\<times> ('hash cipher_text set \\<times> 'hash cipher_text set),\n     bitstring + (bitstring \\<times> 'hash), 'hash + unit) gpv\" \nwhere \n  \"intercept_upf_enc k b = (\\<lambda>(L, D) (m1, m0).\n    (case (length m1 = prf_clen \\<and> length m0 = prf_clen) of\n      False \\<Rightarrow> Done (None, L, D)\n    | True \\<Rightarrow> do {\n        x \\<leftarrow> lift_spmf (spmf_of_set prf_domain);\n        let c = prf_fun k x [\\<oplus>] (if b then m1 else m0);\n        t \\<leftarrow> Pause (Inl (x @ c)) Done;\n        Done ((Some (x, c, projl t)), (insert (x, c, projl t) L, D))\n      }))\""], ["", "definition intercept_upf_dec\n  :: \"'hash cipher_text set \\<times> 'hash cipher_text set \\<Rightarrow> 'hash cipher_text\n  \\<Rightarrow> (bitstring option \\<times> ('hash cipher_text set \\<times> 'hash cipher_text set),\n     bitstring + (bitstring \\<times> 'hash), 'hash + unit) gpv\" \nwhere\n  \"intercept_upf_dec = (\\<lambda>(L, D) (x, c, t).\n    if (x, c, t) \\<in> L \\<or> length x \\<noteq> prf_dlen then Done (None, (L, D)) else do {\n      Pause (Inr (x @ c, t)) Done;\n      Done (None, (L, insert (x, c, t) D))\n    })\""], ["", "definition intercept_upf :: \n  \"'prf_key \\<Rightarrow> bool \\<Rightarrow> 'hash cipher_text set \\<times> 'hash cipher_text set \\<Rightarrow> bitstring \\<times> bitstring + 'hash cipher_text\n  \\<Rightarrow> (('hash cipher_text option + bitstring option) \\<times> ('hash cipher_text set \\<times> 'hash cipher_text set),\n     bitstring + (bitstring \\<times> 'hash), 'hash + unit) gpv\" \nwhere\n  \"intercept_upf k b = plus_intercept (intercept_upf_enc k b) intercept_upf_dec\""], ["", "lemma intercept_upf_simps [simp]:\n  \"intercept_upf k b (L, D) (Inr (x, c, t)) =\n    (if (x, c, t) \\<in> L \\<or> length x \\<noteq> prf_dlen then Done (Inr None, (L, D)) else do {\n      Pause (Inr (x @ c, t)) Done;\n      Done (Inr None, (L, insert (x, c, t) D))\n    })\"\n  \"intercept_upf k b (L, D) (Inl (m1, m0)) = \n    (case (length m1 = prf_clen \\<and> length m0 = prf_clen) of\n      False \\<Rightarrow> Done (Inl None, L, D)\n    | True \\<Rightarrow> do {\n        x \\<leftarrow> lift_spmf (spmf_of_set prf_domain);\n        let c = prf_fun k x [\\<oplus>] (if b then m1 else m0);\n        t \\<leftarrow> Pause (Inl (x @ c)) Done;\n        Done (Inl (Some (x, c, projl t)), (insert (x, c, projl t) L, D))\n      })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intercept_upf k b (L, D) (Inr (x, c, t)) =\n    (if (x, c, t) \\<in> L \\<or> length x \\<noteq> prf_dlen\n     then Generative_Probabilistic_Value.Done (Inr None, L, D)\n     else Generative_Probabilistic_Value.Pause (Inr (x @ c, t))\n           Generative_Probabilistic_Value.Done \\<bind>\n          (\\<lambda>_.\n              Generative_Probabilistic_Value.Done\n               (Inr None, L, insert (x, c, t) D))) &&&\n    intercept_upf k b (L, D) (Inl (m1, m0)) =\n    (case length m1 = prf_clen \\<and> length m0 = prf_clen of\n     True \\<Rightarrow>\n       lift_spmf (spmf_of_set prf_domain) \\<bind>\n       (\\<lambda>x.\n           let c = prf_fun k x [\\<oplus>] (if b then m1 else m0)\n           in Generative_Probabilistic_Value.Pause (Inl (x @ c))\n               Generative_Probabilistic_Value.Done \\<bind>\n              (\\<lambda>t.\n                  Generative_Probabilistic_Value.Done\n                   (Inl (Some (x, c, projl t)), insert (x, c, projl t) L,\n                    D)))\n     | False \\<Rightarrow>\n         Generative_Probabilistic_Value.Done (Inl None, L, D))", "by(simp_all add: intercept_upf_def intercept_upf_dec_def intercept_upf_enc_def o_def map_gpv_bind_gpv gpv.map_id Let_def split!: bool.split)"], ["", "lemma interaction_bounded_by_upf_enc_Inr [interaction_bound]:\n  \"interaction_bounded_by (Not \\<circ> isl) (intercept_upf_enc k b LD mm) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by (Not \\<circ> isl) (intercept_upf_enc k b LD mm) 0", "unfolding intercept_upf_enc_def case_prod_app"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by (Not \\<circ> isl)\n     (case LD of\n      (l, r) \\<Rightarrow>\n        case mm of\n        (m1, m0) \\<Rightarrow>\n          case length m1 = prf_clen \\<and> length m0 = prf_clen of\n          True \\<Rightarrow>\n            lift_spmf (spmf_of_set prf_domain) \\<bind>\n            (\\<lambda>x.\n                let c = prf_fun k x [\\<oplus>] (if b then m1 else m0)\n                in Generative_Probabilistic_Value.Pause (Inl (x @ c))\n                    Generative_Probabilistic_Value.Done \\<bind>\n                   (\\<lambda>t.\n                       Generative_Probabilistic_Value.Done\n                        (Some (x, c, projl t), insert (x, c, projl t) l,\n                         r)))\n          | False \\<Rightarrow>\n              Generative_Probabilistic_Value.Done (None, l, r))\n     0", "by(interaction_bound, clarsimp simp add: SUP_constant bot_enat_def split: prod.split)"], ["", "lemma interaction_bounded_by_upf_dec_Inr [interaction_bound]:\n  \"interaction_bounded_by (Not \\<circ> isl) (intercept_upf_dec LD c) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by (Not \\<circ> isl) (intercept_upf_dec LD c) 1", "unfolding intercept_upf_dec_def case_prod_app"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by (Not \\<circ> isl)\n     (case LD of\n      (l, r) \\<Rightarrow>\n        case c of\n        (x, c, t) \\<Rightarrow>\n          if (x, c, t) \\<in> l \\<or> length x \\<noteq> prf_dlen\n          then Generative_Probabilistic_Value.Done (None, l, r)\n          else Generative_Probabilistic_Value.Pause (Inr (x @ c, t))\n                Generative_Probabilistic_Value.Done \\<bind>\n               (\\<lambda>_.\n                   Generative_Probabilistic_Value.Done\n                    (None, l, insert (x, c, t) r)))\n     1", "by(interaction_bound, clarsimp simp add: SUP_constant split: prod.split)"], ["", "lemma interaction_bounded_by_intercept_upf_Inr [interaction_bound]:\n  \"interaction_bounded_by (Not \\<circ> isl) (intercept_upf k b LD x) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by (Not \\<circ> isl) (intercept_upf k b LD x) 1", "unfolding intercept_upf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by (Not \\<circ> isl)\n     (plus_intercept (intercept_upf_enc k b) intercept_upf_dec LD x) 1", "by interaction_bound(simp add: split_def one_enat_def SUP_le_iff split: sum.split)"], ["", "lemma interaction_bounded_by_intercept_upf_Inl [interaction_bound]:\n  \"isl x \\<Longrightarrow> interaction_bounded_by (Not \\<circ> isl) (intercept_upf k b LD x) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isl x \\<Longrightarrow>\n    interaction_bounded_by (Not \\<circ> isl) (intercept_upf k b LD x) 0", "unfolding intercept_upf_def case_prod_app"], ["proof (prove)\ngoal (1 subgoal):\n 1. isl x \\<Longrightarrow>\n    interaction_bounded_by (Not \\<circ> isl)\n     (plus_intercept (intercept_upf_enc k b) intercept_upf_dec LD x) 0", "by interaction_bound(auto split: sum.split)"], ["", "lemma lossless_intercept_upf_enc [simp]: \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (intercept_upf_enc k b LD mm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n     (intercept_upf_enc k b LD mm)", "by(simp add: intercept_upf_enc_def split_beta prf_domain_finite prf_domain_nonempty Let_def split: bool.split)"], ["", "lemma lossless_intercept_upf_dec [simp]: \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (intercept_upf_dec LD mm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n     (intercept_upf_dec LD mm)", "by(simp add: intercept_upf_dec_def split_beta)"], ["", "lemma lossless_intercept_upf [simp]: \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (intercept_upf k b LD x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n     (intercept_upf k b LD x)", "by(cases x)(simp_all add: intercept_upf_def)"], ["", "lemma results_gpv_intercept_upf [simp]: \"results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (intercept_upf k b LD x) \\<subseteq> responses_\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) x \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n     (intercept_upf k b LD x)\n    \\<subseteq> responses_\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n                 x \\<times>\n                UNIV", "by(cases x)(auto simp add: intercept_upf_def)"], ["", "definition reduction_upf :: \"(bitstring, 'hash cipher_text) ind_cca.adversary\n  \\<Rightarrow> (bitstring, 'hash) UPF.adversary\"\nwhere \"reduction_upf \\<A> = do {\n    k \\<leftarrow> lift_spmf prf_key_gen;\n    b \\<leftarrow> lift_spmf coin_spmf;\n    (_, (L, D)) \\<leftarrow> inline (intercept_upf k b) \\<A> ({}, {});\n    Done () }\""], ["", "lemma lossless_reduction_upf [simp]: \n  \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A> \\<Longrightarrow> lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (reduction_upf \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n     \\<A> \\<Longrightarrow>\n    lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n     (reduction_upf \\<A>)", "by(auto simp add: reduction_upf_def prf_key_gen_lossless intro: lossless_inline del: subsetI)"], ["", "context includes lifting_syntax begin"], ["", "lemma round_1:\n  assumes \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\"\n  shows \"\\<bar>spmf (ind_cca.game \\<A>) True - spmf (ind_cca'.game \\<A>) True\\<bar> \\<le> UPF.advantage (reduction_upf \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "define oracle_decrypt0' where \"oracle_decrypt0' \\<equiv> (\\<lambda>key (bad, L) (x', c', t'). return_spmf (\n      if (x', c', t') \\<in> L \\<or> length x' \\<noteq> prf_dlen then (None, (bad, L))\n      else (decrypt key (x', c', t'), (bad \\<or> upf_fun (snd key) (x' @ c') = t', L))))\""], ["proof (state)\nthis:\n  oracle_decrypt0' \\<equiv>\n  \\<lambda>key (bad, L) (x', c', t').\n     return_spmf\n      (if (x', c', t') \\<in> L \\<or> length x' \\<noteq> prf_dlen\n       then (None, bad, L)\n       else (decrypt key (x', c', t'),\n             bad \\<or> upf_fun (snd key) (x' @ c') = t', L))\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have oracle_decrypt0'_simps:\n    \"oracle_decrypt0' key (bad, L) (x', c', t') = return_spmf (\n       if (x', c', t') \\<in> L \\<or> length x' \\<noteq> prf_dlen then (None, (bad, L))\n       else (decrypt key (x', c', t'), (bad \\<or> upf_fun (snd key) (x' @ c') = t', L)))\"\n    for key L bad x' c' t'"], ["proof (prove)\ngoal (1 subgoal):\n 1. oracle_decrypt0' key (bad, L) (x', c', t') =\n    return_spmf\n     (if (x', c', t') \\<in> L \\<or> length x' \\<noteq> prf_dlen\n      then (None, bad, L)\n      else (decrypt key (x', c', t'),\n            bad \\<or> upf_fun (snd key) (x' @ c') = t', L))", "by(simp add: oracle_decrypt0'_def)"], ["proof (state)\nthis:\n  oracle_decrypt0' ?key1 (?bad1, ?L1) (?x'1, ?c'1, ?t'1) =\n  return_spmf\n   (if (?x'1, ?c'1, ?t'1) \\<in> ?L1 \\<or> length ?x'1 \\<noteq> prf_dlen\n    then (None, ?bad1, ?L1)\n    else (decrypt ?key1 (?x'1, ?c'1, ?t'1),\n          ?bad1 \\<or> upf_fun (snd ?key1) (?x'1 @ ?c'1) = ?t'1, ?L1))\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have lossless_oracle_decrypt0' [simp]: \"lossless_spmf (oracle_decrypt0' k Lbad c)\" for k Lbad c"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (oracle_decrypt0' k Lbad c)", "by(simp add: oracle_decrypt0'_def split_def)"], ["proof (state)\nthis:\n  lossless_spmf (oracle_decrypt0' ?k1 ?Lbad1 ?c1)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have callee_invariant_oracle_decrypt0' [simp]: \"callee_invariant (oracle_decrypt0' k) fst\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant (oracle_decrypt0' k) fst", "by (unfold_locales) (auto simp add: oracle_decrypt0'_def split: if_split_asm)"], ["proof (state)\nthis:\n  callee_invariant (oracle_decrypt0' ?k1) fst\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "define oracle_decrypt1'\n    where \"oracle_decrypt1' = (\\<lambda>(key :: 'prf_key \\<times> 'upf_key) (bad, L) (x', c', t'). \n      return_spmf (None :: bitstring option,\n        (bad \\<or> upf_fun (snd key) (x' @ c') = t' \\<and> (x', c', t') \\<notin> L \\<and> length x' = prf_dlen), L))\""], ["proof (state)\nthis:\n  oracle_decrypt1' =\n  (\\<lambda>key (bad, L) (x', c', t').\n      return_spmf\n       (None,\n        bad \\<or>\n        upf_fun (snd key) (x' @ c') = t' \\<and>\n        (x', c', t') \\<notin> L \\<and> length x' = prf_dlen,\n        L))\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have oracle_decrypt1'_simps:\n    \"oracle_decrypt1' key (bad, L) (x', c', t') = \n    return_spmf (None, \n      (bad \\<or> upf_fun (snd key) (x' @ c') = t' \\<and> (x', c', t') \\<notin> L \\<and> length x' = prf_dlen, L))\"\n    for key L bad x' c' t'"], ["proof (prove)\ngoal (1 subgoal):\n 1. oracle_decrypt1' key (bad, L) (x', c', t') =\n    return_spmf\n     (None,\n      bad \\<or>\n      upf_fun (snd key) (x' @ c') = t' \\<and>\n      (x', c', t') \\<notin> L \\<and> length x' = prf_dlen,\n      L)", "by(simp add: oracle_decrypt1'_def)"], ["proof (state)\nthis:\n  oracle_decrypt1' ?key1 (?bad1, ?L1) (?x'1, ?c'1, ?t'1) =\n  return_spmf\n   (None,\n    ?bad1 \\<or>\n    upf_fun (snd ?key1) (?x'1 @ ?c'1) = ?t'1 \\<and>\n    (?x'1, ?c'1, ?t'1) \\<notin> ?L1 \\<and> length ?x'1 = prf_dlen,\n    ?L1)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have lossless_oracle_decrypt1' [simp]: \"lossless_spmf (oracle_decrypt1' k Lbad c)\" for k Lbad c"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (oracle_decrypt1' k Lbad c)", "by(simp add: oracle_decrypt1'_def split_def)"], ["proof (state)\nthis:\n  lossless_spmf (oracle_decrypt1' ?k1 ?Lbad1 ?c1)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have callee_invariant_oracle_decrypt1' [simp]: \"callee_invariant (oracle_decrypt1' k) fst\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant (oracle_decrypt1' k) fst", "by (unfold_locales) (auto simp add: oracle_decrypt1'_def)"], ["proof (state)\nthis:\n  callee_invariant (oracle_decrypt1' ?k1) fst\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "define game01'\n    where \"game01' = (\\<lambda>(decrypt :: 'prf_key \\<times> 'upf_key \\<Rightarrow> (bitstring \\<times> bitstring \\<times> 'hash, bitstring option, bool \\<times> (bitstring \\<times> bitstring \\<times> 'hash) set) callee) \\<A>. do {\n    key \\<leftarrow> key_gen;\n    b \\<leftarrow> coin_spmf;\n    (b', (bad', L')) \\<leftarrow> exec_gpv (\\<dagger>(ind_cca.oracle_encrypt key b) \\<oplus>\\<^sub>O decrypt key) \\<A> (False, {});\n    return_spmf (b = b', bad') })\""], ["proof (state)\nthis:\n  game01' =\n  (\\<lambda>decrypt \\<A>.\n      key_gen \\<bind>\n      (\\<lambda>key.\n          coin_spmf \\<bind>\n          (\\<lambda>b.\n              exec_gpv\n               (\\<dagger>(ind_cca'.oracle_encrypt key b) \\<oplus>\\<^sub>O\n                decrypt key)\n               \\<A> (False, {}) \\<bind>\n              (\\<lambda>(b', bad', L'). return_spmf (b = b', bad')))))\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "let ?game0' = \"game01' oracle_decrypt0'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "let ?game1' = \"game01' oracle_decrypt1'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have game0'_eq: \"ind_cca.game \\<A> = map_spmf fst (?game0' \\<A>)\" (is ?game0)\n    and game1'_eq: \"ind_cca'.game \\<A> = map_spmf fst (?game1' \\<A>)\" (is ?game1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cca.game \\<A> =\n    map_spmf fst (game01' oracle_decrypt0' \\<A>) &&&\n    ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. local.ind_cca.game \\<A> = map_spmf fst (game01' oracle_decrypt0' \\<A>)\n 2. ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)", "let ?S = \"rel_prod2 (=)\""], ["proof (state)\ngoal (2 subgoals):\n 1. local.ind_cca.game \\<A> = map_spmf fst (game01' oracle_decrypt0' \\<A>)\n 2. ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)", "define initial where \"initial = (False, {} :: 'hash cipher_text set)\""], ["proof (state)\nthis:\n  initial = (False, {})\n\ngoal (2 subgoals):\n 1. local.ind_cca.game \\<A> = map_spmf fst (game01' oracle_decrypt0' \\<A>)\n 2. ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)", "have [transfer_rule]: \"?S {} initial\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod2 (=) {} initial", "by(simp add: initial_def)"], ["proof (state)\nthis:\n  rel_prod2 (=) {} initial\n\ngoal (2 subgoals):\n 1. local.ind_cca.game \\<A> = map_spmf fst (game01' oracle_decrypt0' \\<A>)\n 2. ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)", "have [transfer_rule]: \n      \"((=) ===> ?S ===> (=) ===> rel_spmf (rel_prod (=) ?S))\n       ind_cca.oracle_decrypt oracle_decrypt0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     rel_prod2 (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod2 (=))))\n     local.ind_cca.oracle_decrypt oracle_decrypt0'", "unfolding ind_cca.oracle_decrypt_def[abs_def] oracle_decrypt0'_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     rel_prod2 (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod2 (=))))\n     (\\<lambda>k L c.\n         return_spmf (if c \\<in> L then None else decrypt k c, L))\n     (\\<lambda>key (bad, L) (x', c', t').\n         return_spmf\n          (if (x', c', t') \\<in> L \\<or> length x' \\<noteq> prf_dlen\n           then (None, bad, L)\n           else (decrypt key (x', c', t'),\n                 bad \\<or> upf_fun (snd key) (x' @ c') = t', L)))", "by(simp add: rel_spmf_return_spmf1 rel_fun_def)"], ["proof (state)\nthis:\n  ((=) ===>\n   rel_prod2 (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod2 (=))))\n   local.ind_cca.oracle_decrypt oracle_decrypt0'\n\ngoal (2 subgoals):\n 1. local.ind_cca.game \\<A> = map_spmf fst (game01' oracle_decrypt0' \\<A>)\n 2. ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)", "have [transfer_rule]: \n      \"((=) ===> ?S ===> (=) ===> rel_spmf (rel_prod (=) ?S))\n       ind_cca'.oracle_decrypt oracle_decrypt1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     rel_prod2 (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod2 (=))))\n     ind_cca'.oracle_decrypt oracle_decrypt1'", "unfolding ind_cca'.oracle_decrypt_def[abs_def] oracle_decrypt1'_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     rel_prod2 (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod2 (=))))\n     (\\<lambda>k L c. return_spmf (if c \\<in> L then None else None, L))\n     (\\<lambda>key (bad, L) (x', c', t').\n         return_spmf\n          (None,\n           bad \\<or>\n           upf_fun (snd key) (x' @ c') = t' \\<and>\n           (x', c', t') \\<notin> L \\<and> length x' = prf_dlen,\n           L))", "by (simp add: rel_spmf_return_spmf1 rel_fun_def)"], ["proof (state)\nthis:\n  ((=) ===>\n   rel_prod2 (=) ===> (=) ===> rel_spmf (rel_prod (=) (rel_prod2 (=))))\n   ind_cca'.oracle_decrypt oracle_decrypt1'\n\ngoal (2 subgoals):\n 1. local.ind_cca.game \\<A> = map_spmf fst (game01' oracle_decrypt0' \\<A>)\n 2. ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)", "note [transfer_rule] = extend_state_oracle_transfer"], ["proof (state)\nthis:\n  ((?S ===> ?C ===> rel_spmf (rel_prod ?R ?S)) ===>\n   rel_prod2 ?S ===> ?C ===> rel_spmf (rel_prod ?R (rel_prod2 ?S)))\n   (\\<lambda>oracle. oracle) extend_state_oracle\n\ngoal (2 subgoals):\n 1. local.ind_cca.game \\<A> = map_spmf fst (game01' oracle_decrypt0' \\<A>)\n 2. ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)", "show ?game0 ?game1"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cca.game \\<A> =\n    map_spmf fst (game01' oracle_decrypt0' \\<A>) &&&\n    ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)", "unfolding game01'_def ind_cca.game_def ind_cca'.game_def initial_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. key_gen \\<bind>\n    (\\<lambda>key.\n        coin_spmf \\<bind>\n        (\\<lambda>b.\n            exec_gpv\n             (ind_cca'.oracle_encrypt key b \\<oplus>\\<^sub>O\n              local.ind_cca.oracle_decrypt key)\n             \\<A> {} \\<bind>\n            (\\<lambda>(b', L'). return_spmf (b = b')))) =\n    map_spmf fst\n     (key_gen \\<bind>\n      (\\<lambda>key.\n          coin_spmf \\<bind>\n          (\\<lambda>b.\n              exec_gpv\n               (\\<dagger>(ind_cca'.oracle_encrypt key b) \\<oplus>\\<^sub>O\n                oracle_decrypt0' key)\n               \\<A> initial \\<bind>\n              (\\<lambda>(b', bad', L'). return_spmf (b = b', bad'))))) &&&\n    key_gen \\<bind>\n    (\\<lambda>key.\n        coin_spmf \\<bind>\n        (\\<lambda>b.\n            exec_gpv\n             (ind_cca'.oracle_encrypt key b \\<oplus>\\<^sub>O\n              ind_cca'.oracle_decrypt key)\n             \\<A> {} \\<bind>\n            (\\<lambda>(b', L'). return_spmf (b = b')))) =\n    map_spmf fst\n     (key_gen \\<bind>\n      (\\<lambda>key.\n          coin_spmf \\<bind>\n          (\\<lambda>b.\n              exec_gpv\n               (\\<dagger>(ind_cca'.oracle_encrypt key b) \\<oplus>\\<^sub>O\n                oracle_decrypt1' key)\n               \\<A> initial \\<bind>\n              (\\<lambda>(b', bad', L'). return_spmf (b = b', bad')))))", "by (simp_all add: map_spmf_bind_spmf o_def split_def) transfer_prover+"], ["proof (state)\nthis:\n  local.ind_cca.game \\<A> = map_spmf fst (game01' oracle_decrypt0' \\<A>)\n  ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.ind_cca.game \\<A> = map_spmf fst (game01' oracle_decrypt0' \\<A>)\n  ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have *: \"rel_spmf (\\<lambda>(b'1, (bad1, L1)) (b'2, (bad2, L2)). bad1 = bad2 \\<and> (\\<not> bad2 \\<longrightarrow> b'1 = b'2))\n         (exec_gpv (\\<dagger>(ind_cca.oracle_encrypt k b) \\<oplus>\\<^sub>O oracle_decrypt1' k) \\<A> (False, {}))\n         (exec_gpv (\\<dagger>(ind_cca.oracle_encrypt k b) \\<oplus>\\<^sub>O oracle_decrypt0' k) \\<A> (False, {}))\"\n    for k b"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(b'1, bad1, L1) (b'2, bad2, L2).\n         bad1 = bad2 \\<and> (\\<not> bad2 \\<longrightarrow> b'1 = b'2))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt k b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' k)\n       \\<A> (False, {}))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt k b) \\<oplus>\\<^sub>O\n        oracle_decrypt0' k)\n       \\<A> (False, {}))", "by (cases k; rule exec_gpv_oracle_bisim_bad[where X=\"(=)\" and ?bad1.0=fst and ?bad2.0=fst and \\<I> = \"\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full\"])\n       (auto intro: rel_spmf_reflI callee_invariant_extend_state_oracle_const' simp add: spmf_rel_map1 spmf_rel_map2 oracle_decrypt0'_simps oracle_decrypt1'_simps assms split: plus_oracle_split)\n    \\<comment> \\<open>We cannot get rid of the losslessness assumption on @{term \\<A>} in this step, because if it \n      were not, then the bad event might still occur, but the adversary does not terminate in\n      the case of @{term \"?game1'\"}. Thus, the reduction does not terminate either, but it cannot\n      detect whether the bad event has happened. So the advantage in the UPF game could be lower than\n      the probability of the bad event, if the adversary is not lossless.\\<close>"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(b'1, bad1, L1) (b'2, bad2, L2).\n       bad1 = bad2 \\<and> (\\<not> bad2 \\<longrightarrow> b'1 = b'2))\n   (exec_gpv\n     (\\<dagger>(ind_cca'.oracle_encrypt ?k1 ?b1) \\<oplus>\\<^sub>O\n      oracle_decrypt1' ?k1)\n     \\<A> (False, {}))\n   (exec_gpv\n     (\\<dagger>(ind_cca'.oracle_encrypt ?k1 ?b1) \\<oplus>\\<^sub>O\n      oracle_decrypt0' ?k1)\n     \\<A> (False, {}))\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have \"\\<bar>measure (measure_spmf (?game1' \\<A>)) {(b, bad). b} - measure (measure_spmf (?game0' \\<A>)) {(b, bad). b}\\<bar> \n     \\<le> measure (measure_spmf (?game1' \\<A>)) {(b, bad). bad}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure\n           (measure_spmf (game01' oracle_decrypt1' \\<A>)) {(b, bad). b} -\n          Sigma_Algebra.measure\n           (measure_spmf (game01' oracle_decrypt0' \\<A>))\n           {(b, bad). b}\\<bar>\n    \\<le> Sigma_Algebra.measure\n           (measure_spmf (game01' oracle_decrypt1' \\<A>)) {(b, bad). bad}", "by (rule fundamental_lemma[where ?bad2.0=snd])(auto intro!: rel_spmf_bind_reflI rel_spmf_bindI[OF *] simp add: game01'_def)"], ["proof (state)\nthis:\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt1' \\<A>))\n         {(b, bad). b} -\n        Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt0' \\<A>))\n         {(b, bad). b}\\<bar>\n  \\<le> Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt1' \\<A>))\n         {(b, bad). bad}\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "also"], ["proof (state)\nthis:\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt1' \\<A>))\n         {(b, bad). b} -\n        Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt0' \\<A>))\n         {(b, bad). b}\\<bar>\n  \\<le> Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt1' \\<A>))\n         {(b, bad). bad}\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have \"\\<dots> = spmf (map_spmf snd (?game1' \\<A>)) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt1' \\<A>))\n     {(b, bad). bad} =\n    spmf (map_spmf snd (game01' oracle_decrypt1' \\<A>)) True", "by (simp add: spmf_conv_measure_spmf measure_map_spmf split_def vimage_def)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt1' \\<A>))\n   {(b, bad). bad} =\n  spmf (map_spmf snd (game01' oracle_decrypt1' \\<A>)) True\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt1' \\<A>))\n   {(b, bad). bad} =\n  spmf (map_spmf snd (game01' oracle_decrypt1' \\<A>)) True\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "have \"map_spmf snd (?game1' \\<A>) = UPF.game (reduction_upf \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd (game01' oracle_decrypt1' \\<A>) =\n    UPF.game (reduction_upf \\<A>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf snd (game01' oracle_decrypt1' \\<A>) =\n    UPF.game (reduction_upf \\<A>)", "note [split del] = if_split"], ["proof (state)\nthis:\n  ?P (if ?Q then ?x else ?y) =\n  ((?Q \\<longrightarrow> ?P ?x) \\<and> (\\<not> ?Q \\<longrightarrow> ?P ?y))\n\ngoal (1 subgoal):\n 1. map_spmf snd (game01' oracle_decrypt1' \\<A>) =\n    UPF.game (reduction_upf \\<A>)", "have \"map_spmf (\\<lambda>x. fst (snd x)) (exec_gpv (\\<dagger>(ind_cca.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O oracle_decrypt1' (k_prf, k_upf)) \\<A> (False, {})) = \n        map_spmf (\\<lambda>x. fst (snd x)) (exec_gpv (UPF.oracle k_upf) (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))\"\n      (is \"map_spmf ?fl ?lhs = map_spmf ?fr ?rhs\" is \"map_spmf _ (exec_gpv ?oracle_normal _ ?init_normal) = _\")\n      for k_prf k_upf b"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>x. fst (snd x))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {})) =\n    map_spmf (\\<lambda>x. fst (snd x))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "proof(rule map_spmf_eq_map_spmfI)"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "define oracle_intercept\n        where [simp]: \"oracle_intercept = (\\<lambda>(s', s) y. map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n         (exec_gpv (UPF.oracle k_upf) (intercept_upf k_prf b s' y) s))\""], ["proof (state)\nthis:\n  oracle_intercept =\n  (\\<lambda>(s', s) y.\n      map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n       (exec_gpv (UPF.oracle k_upf) (intercept_upf k_prf b s' y) s))\n\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "let ?I = \"(\\<lambda>((L, D), (flg, Li)).\n          (\\<forall>(x, c, t) \\<in> L. upf_fun k_upf (x @ c) = t \\<and> length x = prf_dlen) \\<and>\n          (\\<forall>e\\<in>Li. \\<exists>(x,c,_) \\<in> L. e = x @ c) \\<and>\n          ((\\<exists>(x, c, t) \\<in> D. upf_fun k_upf (x @ c) = t) \\<longleftrightarrow> flg))\""], ["proof (state)\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "interpret callee_invariant_on oracle_intercept \"?I\" \\<I>_full"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant oracle_intercept\n     (\\<lambda>((L, D), flg, Li).\n         (\\<forall>(x, c, t)\\<in>L.\n             upf_fun k_upf (x @ c) = t \\<and> length x = prf_dlen) \\<and>\n         (\\<forall>e\\<in>Li. \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n         (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) = flg)", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (oracle_intercept s x);\n        case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (L, D) \\<Rightarrow>\n             \\<lambda>(flg, Li).\n                (\\<forall>(x, c, t)\\<in>L.\n                    upf_fun k_upf (x @ c) = t \\<and>\n                    length x = prf_dlen) \\<and>\n                (\\<forall>e\\<in>Li.\n                    \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n                (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) = flg)\n           xa;\n        x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (x, xa) \\<Rightarrow>\n                           (case x of\n                            (L, D) \\<Rightarrow>\n                              \\<lambda>(flg, Li).\n                                 (\\<forall>(x, c, t)\\<in>L.\n                                     upf_fun k_upf (x @ c) = t \\<and>\n                                     length x = prf_dlen) \\<and>\n                                 (\\<forall>e\\<in>Li.\n                                     \\<exists>(x, c, uu_)\\<in>L.\n  e = x @ c) \\<and>\n                                 (\\<exists>(x, c, t)\\<in>D.\n                                     upf_fun k_upf (x @ c) = t) =\n                                 flg)\n                            xa\n 2. \\<And>s.\n       case s of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (L, D) \\<Rightarrow>\n            \\<lambda>(flg, Li).\n               (\\<forall>(x, c, t)\\<in>L.\n                   upf_fun k_upf (x @ c) = t \\<and>\n                   length x = prf_dlen) \\<and>\n               (\\<forall>e\\<in>Li.\n                   \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n               (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) = flg)\n          xa \\<Longrightarrow>\n       \\<I>_full \\<turnstile>c oracle_intercept s \\<surd>", "subgoal for s x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, s') \\<in> set_spmf (oracle_intercept s x);\n     case s of\n     (x, xa) \\<Rightarrow>\n       (case x of\n        (L, D) \\<Rightarrow>\n          \\<lambda>(flg, Li).\n             (\\<forall>(x, c, t)\\<in>L.\n                 upf_fun k_upf (x @ c) = t \\<and>\n                 length x = prf_dlen) \\<and>\n             (\\<forall>e\\<in>Li.\n                 \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n             (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) = flg)\n        xa;\n     x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n    \\<Longrightarrow> case s' of\n                      (x, xa) \\<Rightarrow>\n                        (case x of\n                         (L, D) \\<Rightarrow>\n                           \\<lambda>(flg, Li).\n                              (\\<forall>(x, c, t)\\<in>L.\n                                  upf_fun k_upf (x @ c) = t \\<and>\n                                  length x = prf_dlen) \\<and>\n                              (\\<forall>e\\<in>Li.\n                                  \\<exists>(x, c, uu_)\\<in>L.\n                                     e = x @ c) \\<and>\n                              (\\<exists>(x, c, t)\\<in>D.\n                                  upf_fun k_upf (x @ c) = t) =\n                              flg)\n                         xa", "apply(cases s; cases s'; cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c aa ba ca ab.\n       \\<lbrakk>(y, s') \\<in> set_spmf (oracle_intercept s x);\n        case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (L, D) \\<Rightarrow>\n             \\<lambda>(flg, Li).\n                (\\<forall>(x, c, t)\\<in>L.\n                    upf_fun k_upf (x @ c) = t \\<and>\n                    length x = prf_dlen) \\<and>\n                (\\<forall>e\\<in>Li.\n                    \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n                (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) = flg)\n           xa;\n        x \\<in> outs_\\<I> \\<I>_full; s = (a, b, c); s' = (aa, ba, ca);\n        x = Inl ab\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (x, xa) \\<Rightarrow>\n                           (case x of\n                            (L, D) \\<Rightarrow>\n                              \\<lambda>(flg, Li).\n                                 (\\<forall>(x, c, t)\\<in>L.\n                                     upf_fun k_upf (x @ c) = t \\<and>\n                                     length x = prf_dlen) \\<and>\n                                 (\\<forall>e\\<in>Li.\n                                     \\<exists>(x, c, uu_)\\<in>L.\n  e = x @ c) \\<and>\n                                 (\\<exists>(x, c, t)\\<in>D.\n                                     upf_fun k_upf (x @ c) = t) =\n                                 flg)\n                            xa\n 2. \\<And>a b c aa ba ca bb.\n       \\<lbrakk>(y, s') \\<in> set_spmf (oracle_intercept s x);\n        case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (L, D) \\<Rightarrow>\n             \\<lambda>(flg, Li).\n                (\\<forall>(x, c, t)\\<in>L.\n                    upf_fun k_upf (x @ c) = t \\<and>\n                    length x = prf_dlen) \\<and>\n                (\\<forall>e\\<in>Li.\n                    \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n                (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) = flg)\n           xa;\n        x \\<in> outs_\\<I> \\<I>_full; s = (a, b, c); s' = (aa, ba, ca);\n        x = Inr bb\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (x, xa) \\<Rightarrow>\n                           (case x of\n                            (L, D) \\<Rightarrow>\n                              \\<lambda>(flg, Li).\n                                 (\\<forall>(x, c, t)\\<in>L.\n                                     upf_fun k_upf (x @ c) = t \\<and>\n                                     length x = prf_dlen) \\<and>\n                                 (\\<forall>e\\<in>Li.\n                                     \\<exists>(x, c, uu_)\\<in>L.\n  e = x @ c) \\<and>\n                                 (\\<exists>(x, c, t)\\<in>D.\n                                     upf_fun k_upf (x @ c) = t) =\n                                 flg)\n                            xa", "apply(clarsimp simp add: set_spmf_of_set_finite[OF prf_domain_finite]\n                UPF.oracle_hash_def prf_domain_length exec_gpv_bind Let_def split: bool.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca bb.\n       \\<lbrakk>(y, s') \\<in> set_spmf (oracle_intercept s x);\n        case s of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (L, D) \\<Rightarrow>\n             \\<lambda>(flg, Li).\n                (\\<forall>(x, c, t)\\<in>L.\n                    upf_fun k_upf (x @ c) = t \\<and>\n                    length x = prf_dlen) \\<and>\n                (\\<forall>e\\<in>Li.\n                    \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n                (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) = flg)\n           xa;\n        x \\<in> outs_\\<I> \\<I>_full; s = (a, b, c); s' = (aa, ba, ca);\n        x = Inr bb\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (x, xa) \\<Rightarrow>\n                           (case x of\n                            (L, D) \\<Rightarrow>\n                              \\<lambda>(flg, Li).\n                                 (\\<forall>(x, c, t)\\<in>L.\n                                     upf_fun k_upf (x @ c) = t \\<and>\n                                     length x = prf_dlen) \\<and>\n                                 (\\<forall>e\\<in>Li.\n                                     \\<exists>(x, c, uu_)\\<in>L.\n  e = x @ c) \\<and>\n                                 (\\<exists>(x, c, t)\\<in>D.\n                                     upf_fun k_upf (x @ c) = t) =\n                                 flg)\n                            xa", "apply(force simp add: exec_gpv_bind UPF.oracle_flag_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       case s of\n       (x, xa) \\<Rightarrow>\n         (case x of\n          (L, D) \\<Rightarrow>\n            \\<lambda>(flg, Li).\n               (\\<forall>(x, c, t)\\<in>L.\n                   upf_fun k_upf (x @ c) = t \\<and>\n                   length x = prf_dlen) \\<and>\n               (\\<forall>e\\<in>Li.\n                   \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n               (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) = flg)\n          xa \\<Longrightarrow>\n       \\<I>_full \\<turnstile>c oracle_intercept s \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. case s_ of\n    (x, xa) \\<Rightarrow>\n      (case x of\n       (L, D) \\<Rightarrow>\n         \\<lambda>(flg, Li).\n            (\\<forall>(x, c, t)\\<in>L.\n                upf_fun k_upf (x @ c) = t \\<and> length x = prf_dlen) \\<and>\n            (\\<forall>e\\<in>Li.\n                \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n            (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) = flg)\n       xa \\<Longrightarrow>\n    \\<I>_full \\<turnstile>c oracle_intercept s_ \\<surd>", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "define S :: \"bool \\<times> 'hash cipher_text set \\<Rightarrow> ('hash cipher_text set \\<times> 'hash cipher_text set) \\<times>  bool \\<times> bitstring set \\<Rightarrow> bool\"\n        where \"S = (\\<lambda>(bad, L1) ((L2, D), _). bad = (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) \\<and> L1 = L2) \\<upharpoonleft> (\\<lambda>_. True) \\<otimes> ?I\""], ["proof (state)\nthis:\n  S =\n  (\\<lambda>(bad, L1) ((L2, D), uu_).\n      bad = (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) \\<and>\n      L1 =\n      L2) \\<upharpoonleft> (\\<lambda>_.\n                               True) \\<otimes> (\\<lambda>((L, D), flg, Li).\n             (\\<forall>(x, c, t)\\<in>L.\n                 upf_fun k_upf (x @ c) = t \\<and>\n                 length x = prf_dlen) \\<and>\n             (\\<forall>e\\<in>Li.\n                 \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n             (\\<exists>(x, c, t)\\<in>D. upf_fun k_upf (x @ c) = t) = flg)\n\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "define initial :: \"('hash cipher_text set \\<times> 'hash cipher_text set) \\<times>  bool \\<times> bitstring set\"\n        where \"initial = (({}, {}), (False, {}))\""], ["proof (state)\nthis:\n  initial = (({}, {}), False, {})\n\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "have [transfer_rule]: \"S ?init_normal initial\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S (False, {}) initial", "by(simp add: S_def initial_def)"], ["proof (state)\nthis:\n  S (False, {}) initial\n\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "have [transfer_rule]: \"(S ===> (=) ===> rel_spmf (rel_prod (=) S)) ?oracle_normal oracle_intercept\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S ===> (=) ===> rel_spmf (rel_prod (=) S))\n     (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n      oracle_decrypt1' (k_prf, k_upf))\n     oracle_intercept", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<lambda>(bad, L1) ((L2, D), uu_).\n          bad = (\\<exists>(x, c, y)\\<in>D. upf_fun k_upf (x @ c) = y) \\<and>\n          L1 =\n          L2) \\<upharpoonleft> (\\<lambda>_.\n                                   True) \\<otimes> (\\<lambda>((L, D), flg,\n                 Li).\n                 (\\<forall>(x, c, t)\\<in>L.\n                     upf_fun k_upf (x @ c) = t \\<and>\n                     length x = prf_dlen) \\<and>\n                 (\\<forall>e\\<in>Li.\n                     \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n                 (\\<exists>(x, c, y)\\<in>D. upf_fun k_upf (x @ c) = y) =\n                 flg)) ===>\n     (=) ===>\n     rel_spmf\n      (rel_prod (=)\n        ((\\<lambda>(bad, L1) ((L2, D), uu_).\n             bad =\n             (\\<exists>(x, c, y)\\<in>D. upf_fun k_upf (x @ c) = y) \\<and>\n             L1 =\n             L2) \\<upharpoonleft> (\\<lambda>_.\nTrue) \\<otimes> (\\<lambda>((L, D), flg, Li).\n                    (\\<forall>(x, c, t)\\<in>L.\n                        upf_fun k_upf (x @ c) = t \\<and>\n                        length x = prf_dlen) \\<and>\n                    (\\<forall>e\\<in>Li.\n                        \\<exists>(x, c, uu_)\\<in>L. e = x @ c) \\<and>\n                    (\\<exists>(x, c, y)\\<in>D. upf_fun k_upf (x @ c) = y) =\n                    flg))))\n     (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n      oracle_decrypt1' (k_prf, k_upf))\n     oracle_intercept", "by(rule callee_invariant_restrict_relp, unfold_locales)\n          (auto simp add: rel_fun_def bind_spmf_of_set prf_domain_finite prf_domain_nonempty bind_spmf_pmf_assoc bind_assoc_pmf bind_return_pmf spmf_rel_map exec_gpv_bind Let_def ind_cca.oracle_encrypt_def oracle_decrypt1'_def encrypt.simps UPF.oracle_hash_def UPF.oracle_flag_def bind_map_spmf o_def split: plus_oracle_split bool.split if_split intro!: rel_spmf_bind_reflI rel_pmf_bind_reflI)"], ["proof (state)\nthis:\n  (S ===> (=) ===> rel_spmf (rel_prod (=) S))\n   (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n    oracle_decrypt1' (k_prf, k_upf))\n   oracle_intercept\n\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "have \"rel_spmf (rel_prod (=) S) ?lhs (exec_gpv oracle_intercept \\<A> initial)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (=) S)\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv oracle_intercept \\<A> initial)", "by(transfer_prover)"], ["proof (state)\nthis:\n  rel_spmf (rel_prod (=) S)\n   (exec_gpv\n     (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n      oracle_decrypt1' (k_prf, k_upf))\n     \\<A> (False, {}))\n   (exec_gpv oracle_intercept \\<A> initial)\n\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "then"], ["proof (chain)\npicking this:\n  rel_spmf (rel_prod (=) S)\n   (exec_gpv\n     (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n      oracle_decrypt1' (k_prf, k_upf))\n     \\<A> (False, {}))\n   (exec_gpv oracle_intercept \\<A> initial)", "show \"rel_spmf (\\<lambda>x y. ?fl x = ?fr y) ?lhs ?rhs\""], ["proof (prove)\nusing this:\n  rel_spmf (rel_prod (=) S)\n   (exec_gpv\n     (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n      oracle_decrypt1' (k_prf, k_upf))\n     \\<A> (False, {}))\n   (exec_gpv oracle_intercept \\<A> initial)\n\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n     (exec_gpv\n       (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n        oracle_decrypt1' (k_prf, k_upf))\n       \\<A> (False, {}))\n     (exec_gpv (UPF.oracle k_upf)\n       (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))", "by(auto simp add: S_def exec_gpv_inline spmf_rel_map initial_def elim: rel_spmf_mono)"], ["proof (state)\nthis:\n  rel_spmf (\\<lambda>x y. fst (snd x) = fst (snd y))\n   (exec_gpv\n     (\\<dagger>(ind_cca'.oracle_encrypt (k_prf, k_upf) b) \\<oplus>\\<^sub>O\n      oracle_decrypt1' (k_prf, k_upf))\n     \\<A> (False, {}))\n   (exec_gpv (UPF.oracle k_upf)\n     (inline (intercept_upf k_prf b) \\<A> ({}, {})) (False, {}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>x. fst (snd x))\n   (exec_gpv\n     (\\<dagger>(ind_cca'.oracle_encrypt (?k_prf1, ?k_upf1)\n                 ?b1) \\<oplus>\\<^sub>O\n      oracle_decrypt1' (?k_prf1, ?k_upf1))\n     \\<A> (False, {})) =\n  map_spmf (\\<lambda>x. fst (snd x))\n   (exec_gpv (UPF.oracle ?k_upf1)\n     (inline (intercept_upf ?k_prf1 ?b1) \\<A> ({}, {})) (False, {}))\n\ngoal (1 subgoal):\n 1. map_spmf snd (game01' oracle_decrypt1' \\<A>) =\n    UPF.game (reduction_upf \\<A>)", "then"], ["proof (chain)\npicking this:\n  map_spmf (\\<lambda>x. fst (snd x))\n   (exec_gpv\n     (\\<dagger>(ind_cca'.oracle_encrypt (?k_prf1, ?k_upf1)\n                 ?b1) \\<oplus>\\<^sub>O\n      oracle_decrypt1' (?k_prf1, ?k_upf1))\n     \\<A> (False, {})) =\n  map_spmf (\\<lambda>x. fst (snd x))\n   (exec_gpv (UPF.oracle ?k_upf1)\n     (inline (intercept_upf ?k_prf1 ?b1) \\<A> ({}, {})) (False, {}))", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf (\\<lambda>x. fst (snd x))\n   (exec_gpv\n     (\\<dagger>(ind_cca'.oracle_encrypt (?k_prf1, ?k_upf1)\n                 ?b1) \\<oplus>\\<^sub>O\n      oracle_decrypt1' (?k_prf1, ?k_upf1))\n     \\<A> (False, {})) =\n  map_spmf (\\<lambda>x. fst (snd x))\n   (exec_gpv (UPF.oracle ?k_upf1)\n     (inline (intercept_upf ?k_prf1 ?b1) \\<A> ({}, {})) (False, {}))\n\ngoal (1 subgoal):\n 1. map_spmf snd (game01' oracle_decrypt1' \\<A>) =\n    UPF.game (reduction_upf \\<A>)", "including monad_normalisation"], ["proof (prove)\nusing this:\n  map_spmf (\\<lambda>x. fst (snd x))\n   (exec_gpv\n     (\\<dagger>(ind_cca'.oracle_encrypt (?k_prf1, ?k_upf1)\n                 ?b1) \\<oplus>\\<^sub>O\n      oracle_decrypt1' (?k_prf1, ?k_upf1))\n     \\<A> (False, {})) =\n  map_spmf (\\<lambda>x. fst (snd x))\n   (exec_gpv (UPF.oracle ?k_upf1)\n     (inline (intercept_upf ?k_prf1 ?b1) \\<A> ({}, {})) (False, {}))\n\ngoal (1 subgoal):\n 1. map_spmf snd (game01' oracle_decrypt1' \\<A>) =\n    UPF.game (reduction_upf \\<A>)", "by(auto simp add: reduction_upf_def UPF.game_def game01'_def key_gen_def map_spmf_conv_bind_spmf split_def exec_gpv_bind intro!: bind_spmf_cong[OF refl])"], ["proof (state)\nthis:\n  map_spmf snd (game01' oracle_decrypt1' \\<A>) =\n  UPF.game (reduction_upf \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_spmf snd (game01' oracle_decrypt1' \\<A>) =\n  UPF.game (reduction_upf \\<A>)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt1' \\<A>))\n         {a. case a of (b, bad) \\<Rightarrow> b} -\n        Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt0' \\<A>))\n         {a. case a of (b, bad) \\<Rightarrow> b}\\<bar>\n  \\<le> spmf (UPF.game (reduction_upf \\<A>)) True", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt1' \\<A>))\n         {a. case a of (b, bad) \\<Rightarrow> b} -\n        Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt0' \\<A>))\n         {a. case a of (b, bad) \\<Rightarrow> b}\\<bar>\n  \\<le> spmf (UPF.game (reduction_upf \\<A>)) True\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "using game0'_eq game1'_eq"], ["proof (prove)\nusing this:\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt1' \\<A>))\n         {a. case a of (b, bad) \\<Rightarrow> b} -\n        Sigma_Algebra.measure (measure_spmf (game01' oracle_decrypt0' \\<A>))\n         {a. case a of (b, bad) \\<Rightarrow> b}\\<bar>\n  \\<le> spmf (UPF.game (reduction_upf \\<A>)) True\n  local.ind_cca.game \\<A> = map_spmf fst (game01' oracle_decrypt0' \\<A>)\n  ind_cca'.game \\<A> = map_spmf fst (game01' oracle_decrypt1' \\<A>)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "by (auto simp add: spmf_conv_measure_spmf measure_map_spmf vimage_def fst_def UPF.advantage_def)"], ["proof (state)\nthis:\n  \\<bar>spmf (local.ind_cca.game \\<A>) True -\n        spmf (ind_cca'.game \\<A>) True\\<bar>\n  \\<le> UPF.advantage (reduction_upf \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition oracle_encrypt2 :: \n  \"('prf_key \\<times> 'upf_key) \\<Rightarrow> bool \\<Rightarrow> (bitstring, bitstring) PRF.dict \\<Rightarrow> bitstring \\<times> bitstring \n    \\<Rightarrow> ('hash cipher_text option \\<times> (bitstring, bitstring) PRF.dict) spmf\"\nwhere\n  \"oracle_encrypt2 = (\\<lambda>(k_prf, k_upf) b D (msg1, msg0). (case (length msg1 = prf_clen \\<and> length msg0 = prf_clen) of\n      False \\<Rightarrow> return_spmf (None, D)\n    | True \\<Rightarrow> do {\n        x \\<leftarrow> spmf_of_set prf_domain;\n        P \\<leftarrow> spmf_of_set (nlists UNIV prf_clen);\n        let p = (case D x of Some r \\<Rightarrow> r | None \\<Rightarrow> P);\n        let c = p [\\<oplus>] (if b then msg1 else msg0);\n        let t = upf_fun k_upf (x @ c);\n        return_spmf (Some (x, c, t), D(x \\<mapsto> p)) \n      }))\""], ["", "definition oracle_decrypt2:: \"('prf_key \\<times> 'upf_key) \\<Rightarrow> ('hash cipher_text, bitstring option, 'state) callee\"\nwhere \"oracle_decrypt2 = (\\<lambda>key D cipher. return_spmf (None, D))\""], ["", "lemma lossless_oracle_decrypt2 [simp]: \"lossless_spmf (oracle_decrypt2 k Dbad c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (oracle_decrypt2 k Dbad c)", "by(simp add: oracle_decrypt2_def split_def)"], ["", "lemma callee_invariant_oracle_decrypt2 [simp]: \"callee_invariant (oracle_decrypt2 key) fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant (oracle_decrypt2 key) fst", "by (unfold_locales) (auto simp add: oracle_decrypt2_def split: if_split_asm)"], ["", "lemma oracle_decrypt2_parametric [transfer_rule]:\n  \"(rel_prod P U ===> S ===> rel_prod (=) (rel_prod (=) H) ===> rel_spmf (rel_prod (=) S))\n   oracle_decrypt2 oracle_decrypt2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_prod P U ===>\n     S ===> rel_prod (=) (rel_prod (=) H) ===> rel_spmf (rel_prod (=) S))\n     oracle_decrypt2 oracle_decrypt2", "unfolding oracle_decrypt2_def split_def relator_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_prod P U ===>\n     S ===>\n     rel_prod (list_all2 (=)) (rel_prod (list_all2 (=)) H) ===>\n     rel_spmf (rel_prod (rel_option (list_all2 (=))) S))\n     (\\<lambda>key D cipher. return_spmf (None, D))\n     (\\<lambda>key D cipher. return_spmf (None, D))", "by transfer_prover"], ["", "definition game2 :: \"(bitstring, 'hash cipher_text) ind_cca.adversary \\<Rightarrow> bool spmf\" \nwhere \n  \"game2 \\<A> \\<equiv> do {\n    key \\<leftarrow> key_gen;\n    b \\<leftarrow> coin_spmf;\n    (b', D) \\<leftarrow> exec_gpv \n      (oracle_encrypt2 key b \\<oplus>\\<^sub>O oracle_decrypt2 key) \\<A> Map_empty;\n    return_spmf (b = b')\n  }\""], ["", "fun intercept_prf :: \n  \"'upf_key \\<Rightarrow> bool \\<Rightarrow> unit \\<Rightarrow> (bitstring \\<times> bitstring) + 'hash cipher_text\n  \\<Rightarrow> (('hash cipher_text option + bitstring option) \\<times> unit, bitstring, bitstring) gpv\" \nwhere\n  \"intercept_prf _ _ _ (Inr _) = Done (Inr None, ())\"\n| \"intercept_prf k b _ (Inl (m1, m0)) = (case (length m1) = prf_clen \\<and> (length m0) = prf_clen of\n      False \\<Rightarrow> Done (Inl None, ())\n    | True \\<Rightarrow> do {\n        x \\<leftarrow> lift_spmf (spmf_of_set prf_domain);\n        p \\<leftarrow> Pause x Done;\n        let c = p [\\<oplus>] (if b then m1 else m0);\n        let t = upf_fun k (x @ c);\n        Done (Inl (Some (x, c, t)), ())\n      })\""], ["", "definition reduction_prf\n  :: \"(bitstring, 'hash cipher_text) ind_cca.adversary \\<Rightarrow> (bitstring, bitstring) PRF.adversary\"\nwhere \n \"reduction_prf \\<A> = do {\n   k \\<leftarrow> lift_spmf upf_key_gen;\n   b \\<leftarrow> lift_spmf coin_spmf;\n   (b', _) \\<leftarrow> inline (intercept_prf k b) \\<A> ();\n   Done (b' = b)\n }\""], ["", "lemma round_2: \"\\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> = PRF.advantage (reduction_prf \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "define oracle_encrypt1''\n    where \"oracle_encrypt1'' = (\\<lambda>(k_prf, k_upf) b (_ :: unit) (msg1, msg0). \n      case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n        False \\<Rightarrow> return_spmf (None, ())\n      | True \\<Rightarrow> do {\n          x \\<leftarrow> spmf_of_set prf_domain;\n          let p = prf_fun k_prf x;\n          let c = p [\\<oplus>] (if b then msg1 else msg0);\n          let t = upf_fun k_upf (x @ c);\n          return_spmf (Some (x, c, t), ())})\""], ["proof (state)\nthis:\n  oracle_encrypt1'' =\n  (\\<lambda>(k_prf, k_upf) b _ (msg1, msg0).\n      case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n      True \\<Rightarrow>\n        spmf_of_set prf_domain \\<bind>\n        (\\<lambda>x.\n            let p = prf_fun k_prf x;\n                c = p [\\<oplus>] (if b then msg1 else msg0);\n                t = upf_fun k_upf (x @ c)\n            in return_spmf (Some (x, c, t), ()))\n      | False \\<Rightarrow> return_spmf (None, ()))\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "define game1'' where \"game1'' = do {\n    key \\<leftarrow> key_gen;\n    b \\<leftarrow> coin_spmf;\n    (b', D) \\<leftarrow> exec_gpv (oracle_encrypt1'' key b \\<oplus>\\<^sub>O oracle_decrypt2 key) \\<A> ();\n    return_spmf (b = b')}\""], ["proof (state)\nthis:\n  game1'' =\n  key_gen \\<bind>\n  (\\<lambda>key.\n      coin_spmf \\<bind>\n      (\\<lambda>b.\n          exec_gpv\n           (oracle_encrypt1'' key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n           \\<A> () \\<bind>\n          (\\<lambda>(b', D). return_spmf (b = b'))))\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "have \"ind_cca'.game \\<A> = game1''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_cca'.game \\<A> = game1''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ind_cca'.game \\<A> = game1''", "define S where \"S = (\\<lambda>(L :: 'hash cipher_text set) (D :: unit). True)\""], ["proof (state)\nthis:\n  S = (\\<lambda>L D. True)\n\ngoal (1 subgoal):\n 1. ind_cca'.game \\<A> = game1''", "have [transfer_rule]: \"S {} ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S {} ()", "by (simp add: S_def)"], ["proof (state)\nthis:\n  S {} ()\n\ngoal (1 subgoal):\n 1. ind_cca'.game \\<A> = game1''", "have [transfer_rule]: \n      \"((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n       ind_cca'.oracle_encrypt oracle_encrypt1''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n     ind_cca'.oracle_encrypt oracle_encrypt1''", "unfolding ind_cca'.oracle_encrypt_def[abs_def] oracle_encrypt1''_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n     (\\<lambda>k b L (msg1, msg0).\n         case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n         True \\<Rightarrow>\n           encrypt k (if b then msg1 else msg0) \\<bind>\n           (\\<lambda>c. return_spmf (Some c, {c} \\<union> L))\n         | False \\<Rightarrow> return_spmf (None, L))\n     (\\<lambda>(k_prf, k_upf) b _ (msg1, msg0).\n         case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n         True \\<Rightarrow>\n           spmf_of_set prf_domain \\<bind>\n           (\\<lambda>x.\n               let p = prf_fun k_prf x;\n                   c = p [\\<oplus>] (if b then msg1 else msg0);\n                   t = upf_fun k_upf (x @ c)\n               in return_spmf (Some (x, c, t), ()))\n         | False \\<Rightarrow> return_spmf (None, ()))", "by (auto simp add: rel_fun_def Let_def S_def encrypt.simps prf_domain_finite prf_domain_nonempty intro: rel_spmf_bind_reflI rel_pmf_bind_reflI split: bool.split)"], ["proof (state)\nthis:\n  ((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n   ind_cca'.oracle_encrypt oracle_encrypt1''\n\ngoal (1 subgoal):\n 1. ind_cca'.game \\<A> = game1''", "have [transfer_rule]:\n      \"((=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S)) \n       ind_cca'.oracle_decrypt oracle_decrypt2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n     ind_cca'.oracle_decrypt oracle_decrypt2", "unfolding ind_cca'.oracle_decrypt_def[abs_def] oracle_decrypt2_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n     (\\<lambda>k L c. return_spmf (if c \\<in> L then None else None, L))\n     (\\<lambda>key D cipher. return_spmf (None, D))", "by(auto simp add: rel_fun_def)"], ["proof (state)\nthis:\n  ((=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n   ind_cca'.oracle_decrypt oracle_decrypt2\n\ngoal (1 subgoal):\n 1. ind_cca'.game \\<A> = game1''", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ind_cca'.game \\<A> = game1''", "unfolding ind_cca'.game_def game1''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. key_gen \\<bind>\n    (\\<lambda>key.\n        coin_spmf \\<bind>\n        (\\<lambda>b.\n            exec_gpv\n             (ind_cca'.oracle_encrypt key b \\<oplus>\\<^sub>O\n              ind_cca'.oracle_decrypt key)\n             \\<A> {} \\<bind>\n            (\\<lambda>(b', L'). return_spmf (b = b')))) =\n    key_gen \\<bind>\n    (\\<lambda>key.\n        coin_spmf \\<bind>\n        (\\<lambda>b.\n            exec_gpv\n             (oracle_encrypt1'' key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n             \\<A> () \\<bind>\n            (\\<lambda>(b', D). return_spmf (b = b'))))", "by transfer_prover"], ["proof (state)\nthis:\n  ind_cca'.game \\<A> = game1''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ind_cca'.game \\<A> = game1''\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "also"], ["proof (state)\nthis:\n  ind_cca'.game \\<A> = game1''\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "have \"\\<dots> = PRF.game_0 (reduction_prf \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "fix k_prf k_upf b"], ["proof (state)\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "define oracle_normal\n        where \"oracle_normal = oracle_encrypt1'' (k_prf, k_upf) b \\<oplus>\\<^sub>O oracle_decrypt2 (k_prf, k_upf)\""], ["proof (state)\nthis:\n  oracle_normal =\n  oracle_encrypt1'' (k_prf, k_upf) b \\<oplus>\\<^sub>O\n  oracle_decrypt2 (k_prf, k_upf)\n\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "define oracle_intercept\n        where \"oracle_intercept = (\\<lambda>(s', s :: unit) y. map_spmf (\\<lambda>((x, s'), s). (x, s', s)) (exec_gpv (PRF.prf_oracle k_prf) (intercept_prf k_upf b s' y) ()))\""], ["proof (state)\nthis:\n  oracle_intercept =\n  (\\<lambda>(s', s) y.\n      map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n       (exec_gpv (PRF.prf_oracle k_prf) (intercept_prf k_upf b s' y) ()))\n\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "define initial where \"initial = ()\""], ["proof (state)\nthis:\n  initial = ()\n\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "define S where \"S = (\\<lambda>(s2 :: unit, _ :: unit) (s1 :: unit). True)\""], ["proof (state)\nthis:\n  S = (\\<lambda>(s2, uu_) s1. True)\n\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "have [transfer_rule]: \"S ((), ()) initial\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S ((), ()) initial", "by(simp add: S_def initial_def)"], ["proof (state)\nthis:\n  S ((), ()) initial\n\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "have [transfer_rule]: \"(S ===> (=) ===> rel_spmf (rel_prod (=) S)) oracle_intercept oracle_normal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S ===> (=) ===> rel_spmf (rel_prod (=) S)) oracle_intercept\n     oracle_normal", "unfolding oracle_normal_def oracle_intercept_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (S ===> (=) ===> rel_spmf (rel_prod (=) S))\n     (\\<lambda>(s', s) y.\n         map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n          (exec_gpv (PRF.prf_oracle k_prf) (intercept_prf k_upf b s' y) ()))\n     (oracle_encrypt1'' (k_prf, k_upf) b \\<oplus>\\<^sub>O\n      oracle_decrypt2 (k_prf, k_upf))", "by(auto split: bool.split plus_oracle_split simp add: S_def rel_fun_def exec_gpv_bind PRF.prf_oracle_def oracle_encrypt1''_def Let_def map_spmf_conv_bind_spmf oracle_decrypt2_def intro!: rel_spmf_bind_reflI rel_spmf_reflI)"], ["proof (state)\nthis:\n  (S ===> (=) ===> rel_spmf (rel_prod (=) S)) oracle_intercept oracle_normal\n\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "have \"map_spmf (\\<lambda>x. b = fst x) (exec_gpv oracle_normal \\<A> initial) =\n        map_spmf (\\<lambda>x. b = fst (fst x)) (exec_gpv (PRF.prf_oracle k_prf) (inline (intercept_prf k_upf b) \\<A> ()) ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>x. b = fst x) (exec_gpv oracle_normal \\<A> initial) =\n    map_spmf (\\<lambda>x. b = fst (fst x))\n     (exec_gpv (PRF.prf_oracle k_prf)\n       (inline (intercept_prf k_upf b) \\<A> ()) ())", "by(transfer fixing: b \\<A> prf_fun k_prf prf_domain prf_clen upf_fun k_upf)\n          (auto simp add: map_spmf_eq_map_spmf_iff exec_gpv_inline spmf_rel_map oracle_intercept_def split_def intro: rel_spmf_reflI)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>x. b = fst x) (exec_gpv oracle_normal \\<A> initial) =\n  map_spmf (\\<lambda>x. b = fst (fst x))\n   (exec_gpv (PRF.prf_oracle k_prf) (inline (intercept_prf k_upf b) \\<A> ())\n     ())\n\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "}"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>x. ?b4 = fst x)\n   (exec_gpv\n     (oracle_encrypt1'' (?k_prf4, ?k_upf4) ?b4 \\<oplus>\\<^sub>O\n      oracle_decrypt2 (?k_prf4, ?k_upf4))\n     \\<A> ()) =\n  map_spmf (\\<lambda>x. ?b4 = fst (fst x))\n   (exec_gpv (PRF.prf_oracle ?k_prf4)\n     (inline (intercept_prf ?k_upf4 ?b4) \\<A> ()) ())\n\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "then"], ["proof (chain)\npicking this:\n  map_spmf (\\<lambda>x. ?b4 = fst x)\n   (exec_gpv\n     (oracle_encrypt1'' (?k_prf4, ?k_upf4) ?b4 \\<oplus>\\<^sub>O\n      oracle_decrypt2 (?k_prf4, ?k_upf4))\n     \\<A> ()) =\n  map_spmf (\\<lambda>x. ?b4 = fst (fst x))\n   (exec_gpv (PRF.prf_oracle ?k_prf4)\n     (inline (intercept_prf ?k_upf4 ?b4) \\<A> ()) ())", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf (\\<lambda>x. ?b4 = fst x)\n   (exec_gpv\n     (oracle_encrypt1'' (?k_prf4, ?k_upf4) ?b4 \\<oplus>\\<^sub>O\n      oracle_decrypt2 (?k_prf4, ?k_upf4))\n     \\<A> ()) =\n  map_spmf (\\<lambda>x. ?b4 = fst (fst x))\n   (exec_gpv (PRF.prf_oracle ?k_prf4)\n     (inline (intercept_prf ?k_upf4 ?b4) \\<A> ()) ())\n\ngoal (1 subgoal):\n 1. game1'' = PRF.game_0 (reduction_prf \\<A>)", "unfolding game1''_def PRF.game_0_def key_gen_def reduction_prf_def"], ["proof (prove)\nusing this:\n  map_spmf (\\<lambda>x. ?b4 = fst x)\n   (exec_gpv\n     (oracle_encrypt1'' (?k_prf4, ?k_upf4) ?b4 \\<oplus>\\<^sub>O\n      oracle_decrypt2 (?k_prf4, ?k_upf4))\n     \\<A> ()) =\n  map_spmf (\\<lambda>x. ?b4 = fst (fst x))\n   (exec_gpv (PRF.prf_oracle ?k_prf4)\n     (inline (intercept_prf ?k_upf4 ?b4) \\<A> ()) ())\n\ngoal (1 subgoal):\n 1. prf_key_gen \\<bind>\n    (\\<lambda>k_prf.\n        upf_key_gen \\<bind>\n        (\\<lambda>k_upf. return_spmf (k_prf, k_upf))) \\<bind>\n    (\\<lambda>key.\n        coin_spmf \\<bind>\n        (\\<lambda>b.\n            exec_gpv\n             (oracle_encrypt1'' key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n             \\<A> () \\<bind>\n            (\\<lambda>(b', D). return_spmf (b = b')))) =\n    prf_key_gen \\<bind>\n    (\\<lambda>key.\n        exec_gpv (PRF.prf_oracle key)\n         (lift_spmf upf_key_gen \\<bind>\n          (\\<lambda>k.\n              lift_spmf coin_spmf \\<bind>\n              (\\<lambda>b.\n                  inline (intercept_prf k b) \\<A> () \\<bind>\n                  (\\<lambda>(b', uu_).\n                      Generative_Probabilistic_Value.Done (b' = b)))))\n         () \\<bind>\n        (\\<lambda>(b, uu_). return_spmf b))", "by (auto simp add: exec_gpv_bind_lift_spmf exec_gpv_bind map_spmf_conv_bind_spmf split_def eq_commute intro!: bind_spmf_cong[OF refl])"], ["proof (state)\nthis:\n  game1'' = PRF.game_0 (reduction_prf \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  game1'' = PRF.game_0 (reduction_prf \\<A>)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "also"], ["proof (state)\nthis:\n  game1'' = PRF.game_0 (reduction_prf \\<A>)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "have \"game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "note [split del] = if_split"], ["proof (state)\nthis:\n  ?P (if ?Q then ?x else ?y) =\n  ((?Q \\<longrightarrow> ?P ?x) \\<and> (\\<not> ?Q \\<longrightarrow> ?P ?y))\n\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "{"], ["proof (state)\nthis:\n  ?P (if ?Q then ?x else ?y) =\n  ((?Q \\<longrightarrow> ?P ?x) \\<and> (\\<not> ?Q \\<longrightarrow> ?P ?y))\n\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "fix k_upf b k_prf"], ["proof (state)\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "define oracle2\n        where \"oracle2 = oracle_encrypt2 (k_prf, k_upf) b \\<oplus>\\<^sub>O oracle_decrypt2 (k_prf, k_upf)\""], ["proof (state)\nthis:\n  oracle2 =\n  oracle_encrypt2 (k_prf, k_upf) b \\<oplus>\\<^sub>O\n  oracle_decrypt2 (k_prf, k_upf)\n\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "define oracle_intercept\n        where \"oracle_intercept = (\\<lambda>(s', s) y. map_spmf (\\<lambda>((x, s'), s). (x, s', s)) (exec_gpv PRF.random_oracle (intercept_prf k_upf b s' y) s))\""], ["proof (state)\nthis:\n  oracle_intercept =\n  (\\<lambda>(s', s) y.\n      map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n       (exec_gpv PRF.random_oracle (intercept_prf k_upf b s' y) s))\n\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "define S\n        where \"S = (\\<lambda>(s2 :: unit, s2') (s1 :: (bitstring, bitstring) PRF.dict). s2' = s1)\""], ["proof (state)\nthis:\n  S = (\\<lambda>(s2, s2'). (=) s2')\n\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "have [transfer_rule]: \"S ((), Map_empty) Map_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S ((), Map_empty) Map_empty", "by(simp add: S_def)"], ["proof (state)\nthis:\n  S ((), Map_empty) Map_empty\n\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "have [transfer_rule]: \"(S ===> (=) ===> rel_spmf (rel_prod (=) S)) oracle_intercept oracle2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S ===> (=) ===> rel_spmf (rel_prod (=) S)) oracle_intercept oracle2", "unfolding oracle2_def oracle_intercept_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (S ===> (=) ===> rel_spmf (rel_prod (=) S))\n     (\\<lambda>(s', s) y.\n         map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n          (exec_gpv PRF.random_oracle (intercept_prf k_upf b s' y) s))\n     (oracle_encrypt2 (k_prf, k_upf) b \\<oplus>\\<^sub>O\n      oracle_decrypt2 (k_prf, k_upf))", "by(auto split: bool.split plus_oracle_split option.split simp add: S_def rel_fun_def exec_gpv_bind PRF.random_oracle_def oracle_encrypt2_def Let_def map_spmf_conv_bind_spmf oracle_decrypt2_def rel_spmf_return_spmf1 fun_upd_idem intro!: rel_spmf_bind_reflI rel_spmf_reflI)"], ["proof (state)\nthis:\n  (S ===> (=) ===> rel_spmf (rel_prod (=) S)) oracle_intercept oracle2\n\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "have [symmetric]: \"map_spmf (\\<lambda>x. b = fst (fst x)) (exec_gpv (PRF.random_oracle) (inline (intercept_prf k_upf b) \\<A> ()) Map.empty) = \n        map_spmf (\\<lambda>x. b = fst x) (exec_gpv oracle2 \\<A> Map_empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>x. b = fst (fst x))\n     (exec_gpv PRF.random_oracle (inline (intercept_prf k_upf b) \\<A> ())\n       Map.empty) =\n    map_spmf (\\<lambda>x. b = fst x) (exec_gpv oracle2 \\<A> Map_empty)", "by(transfer fixing: b prf_clen prf_domain upf_fun k_upf \\<A> k_prf)\n          (simp add: exec_gpv_inline map_spmf_conv_bind_spmf[symmetric] spmf.map_comp o_def split_def oracle_intercept_def)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>x. b = fst x) (exec_gpv oracle2 \\<A> Map_empty) =\n  map_spmf (\\<lambda>x. b = fst (fst x))\n   (exec_gpv PRF.random_oracle (inline (intercept_prf k_upf b) \\<A> ())\n     Map.empty)\n\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "}"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>x. ?b4 = fst x)\n   (exec_gpv\n     (oracle_encrypt2 (?k_prf4, ?k_upf4) ?b4 \\<oplus>\\<^sub>O\n      oracle_decrypt2 (?k_prf4, ?k_upf4))\n     \\<A> Map_empty) =\n  map_spmf (\\<lambda>x. ?b4 = fst (fst x))\n   (exec_gpv PRF.random_oracle (inline (intercept_prf ?k_upf4 ?b4) \\<A> ())\n     Map.empty)\n\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "then"], ["proof (chain)\npicking this:\n  map_spmf (\\<lambda>x. ?b4 = fst x)\n   (exec_gpv\n     (oracle_encrypt2 (?k_prf4, ?k_upf4) ?b4 \\<oplus>\\<^sub>O\n      oracle_decrypt2 (?k_prf4, ?k_upf4))\n     \\<A> Map_empty) =\n  map_spmf (\\<lambda>x. ?b4 = fst (fst x))\n   (exec_gpv PRF.random_oracle (inline (intercept_prf ?k_upf4 ?b4) \\<A> ())\n     Map.empty)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf (\\<lambda>x. ?b4 = fst x)\n   (exec_gpv\n     (oracle_encrypt2 (?k_prf4, ?k_upf4) ?b4 \\<oplus>\\<^sub>O\n      oracle_decrypt2 (?k_prf4, ?k_upf4))\n     \\<A> Map_empty) =\n  map_spmf (\\<lambda>x. ?b4 = fst (fst x))\n   (exec_gpv PRF.random_oracle (inline (intercept_prf ?k_upf4 ?b4) \\<A> ())\n     Map.empty)\n\ngoal (1 subgoal):\n 1. game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "unfolding game2_def PRF.game_1_def key_gen_def reduction_prf_def"], ["proof (prove)\nusing this:\n  map_spmf (\\<lambda>x. ?b4 = fst x)\n   (exec_gpv\n     (oracle_encrypt2 (?k_prf4, ?k_upf4) ?b4 \\<oplus>\\<^sub>O\n      oracle_decrypt2 (?k_prf4, ?k_upf4))\n     \\<A> Map_empty) =\n  map_spmf (\\<lambda>x. ?b4 = fst (fst x))\n   (exec_gpv PRF.random_oracle (inline (intercept_prf ?k_upf4 ?b4) \\<A> ())\n     Map.empty)\n\ngoal (1 subgoal):\n 1. prf_key_gen \\<bind>\n    (\\<lambda>k_prf.\n        upf_key_gen \\<bind>\n        (\\<lambda>k_upf. return_spmf (k_prf, k_upf))) \\<bind>\n    (\\<lambda>key.\n        coin_spmf \\<bind>\n        (\\<lambda>b.\n            exec_gpv\n             (oracle_encrypt2 key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n             \\<A> Map_empty \\<bind>\n            (\\<lambda>(b', D). return_spmf (b = b')))) =\n    exec_gpv PRF.random_oracle\n     (lift_spmf upf_key_gen \\<bind>\n      (\\<lambda>k.\n          lift_spmf coin_spmf \\<bind>\n          (\\<lambda>b.\n              inline (intercept_prf k b) \\<A> () \\<bind>\n              (\\<lambda>(b', uu_).\n                  Generative_Probabilistic_Value.Done (b' = b)))))\n     Map.empty \\<bind>\n    (\\<lambda>(b, uu_). return_spmf b)", "by (clarsimp simp add: exec_gpv_bind_lift_spmf exec_gpv_bind map_spmf_conv_bind_spmf split_def bind_spmf_const prf_key_gen_lossless lossless_weight_spmfD eq_commute)"], ["proof (state)\nthis:\n  game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "ultimately"], ["proof (chain)\npicking this:\n  ind_cca'.game \\<A> = PRF.game_0 (reduction_prf \\<A>)\n  game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)", "show ?thesis"], ["proof (prove)\nusing this:\n  ind_cca'.game \\<A> = PRF.game_0 (reduction_prf \\<A>)\n  game2 \\<A> = PRF.game_1 (reduction_prf \\<A>)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "by(simp add: PRF.advantage_def)"], ["proof (state)\nthis:\n  \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n  PRF.advantage (reduction_prf \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition oracle_encrypt3 :: \n   \"('prf_key \\<times> 'upf_key) \\<Rightarrow> bool \\<Rightarrow> (bool \\<times> (bitstring, bitstring) PRF.dict) \\<Rightarrow>\n    bitstring \\<times> bitstring \\<Rightarrow> ('hash cipher_text option \\<times> (bool \\<times> (bitstring, bitstring) PRF.dict)) spmf\"\nwhere\n  \"oracle_encrypt3 = (\\<lambda>(k_prf, k_upf) b (bad, D) (msg1, msg0). \n    (case (length msg1 = prf_clen \\<and> length msg0 = prf_clen) of\n      False \\<Rightarrow> return_spmf (None, (bad, D))\n    | True \\<Rightarrow> do {\n        x \\<leftarrow> spmf_of_set prf_domain;\n        P \\<leftarrow> spmf_of_set (nlists UNIV prf_clen);\n        let (p, F) = (case D x of Some r \\<Rightarrow> (P, True) | None \\<Rightarrow> (P, False));\n        let c = p [\\<oplus>] (if b then msg1 else msg0);\n        let t = upf_fun k_upf (x @ c);\n        return_spmf (Some (x, c, t), (bad \\<or> F, D(x \\<mapsto> p))) \n      }))\""], ["", "lemma lossless_oracle_encrypt3 [simp]:\n  \"lossless_spmf (oracle_encrypt3 k b D m10) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (oracle_encrypt3 k b D m10)", "by (cases m10) (simp add: oracle_encrypt3_def prf_domain_nonempty prf_domain_finite\n    split_def Let_def split: bool.splits)"], ["", "lemma callee_invariant_oracle_encrypt3 [simp]: \"callee_invariant (oracle_encrypt3 key b) fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant (oracle_encrypt3 key b) fst", "by (unfold_locales) (auto simp add: oracle_encrypt3_def split_def Let_def split: bool.splits)"], ["", "definition game3 :: \"(bitstring, 'hash cipher_text) ind_cca.adversary \\<Rightarrow> (bool \\<times> bool) spmf\" \nwhere \n  \"game3 \\<A> \\<equiv> do {\n    key \\<leftarrow> key_gen;\n    b \\<leftarrow> coin_spmf;\n    (b', (bad, D)) \\<leftarrow> exec_gpv (oracle_encrypt3 key b \\<oplus>\\<^sub>O oracle_decrypt2 key) \\<A> (False, Map_empty);\n    return_spmf (b = b', bad)\n  }\""], ["", "lemma round_3:\n  assumes \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\"\n  shows \"\\<bar>measure (measure_spmf (game3 \\<A>)) {(b, bad). b} - spmf (game2 \\<A>) True\\<bar> \n          \\<le> measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "define oracle_encrypt2'\n    where \"oracle_encrypt2' = (\\<lambda>(k_prf :: 'prf_key, k_upf) b (bad, D) (msg1, msg0). \n      case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n        False \\<Rightarrow> return_spmf (None, (bad, D))\n      | True \\<Rightarrow> do {\n          x \\<leftarrow> spmf_of_set prf_domain;\n          P \\<leftarrow> spmf_of_set (nlists UNIV prf_clen);\n          let (p, F) = (case D x of Some r \\<Rightarrow> (r, True) | None \\<Rightarrow> (P, False));\n          let c = p [\\<oplus>] (if b then msg1 else msg0);\n          let t = upf_fun k_upf (x @ c);\n          return_spmf (Some (x, c, t), (bad \\<or> F, D(x \\<mapsto> p))) \n        })\""], ["proof (state)\nthis:\n  oracle_encrypt2' =\n  (\\<lambda>(k_prf, k_upf) b (bad, D) (msg1, msg0).\n      case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n      True \\<Rightarrow>\n        spmf_of_set prf_domain \\<bind>\n        (\\<lambda>x.\n            spmf_of_set (nlists UNIV prf_clen) \\<bind>\n            (\\<lambda>P.\n                let (p, F) =\n                      case D x of None \\<Rightarrow> (P, False)\n                      | Some r \\<Rightarrow> (r, True);\n                    c = p [\\<oplus>] (if b then msg1 else msg0);\n                    t = upf_fun k_upf (x @ c)\n                in return_spmf\n                    (Some (x, c, t), bad \\<or> F, D(x \\<mapsto> p))))\n      | False \\<Rightarrow> return_spmf (None, bad, D))\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "have [simp]: \"lossless_spmf (oracle_encrypt2' key b D msg10) \" for key b D msg10"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (oracle_encrypt2' key b D msg10)", "by (cases msg10) (simp add: oracle_encrypt2'_def prf_domain_nonempty prf_domain_finite\n      split_def Let_def split: bool.split)"], ["proof (state)\nthis:\n  lossless_spmf (oracle_encrypt2' ?key2 ?b2 ?D2 ?msg10.2)\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "have [simp]: \"callee_invariant (oracle_encrypt2' key b) fst\" for key b"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant (oracle_encrypt2' key b) fst", "by (unfold_locales) (auto simp add: oracle_encrypt2'_def split_def Let_def split: bool.splits)"], ["proof (state)\nthis:\n  callee_invariant (oracle_encrypt2' ?key2 ?b2) fst\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "define game2'\n    where \"game2' = (\\<lambda>\\<A>. do {\n      key \\<leftarrow> key_gen;\n      b \\<leftarrow> coin_spmf;\n      (b', (bad, D)) \\<leftarrow> exec_gpv (oracle_encrypt2' key b \\<oplus>\\<^sub>O oracle_decrypt2 key) \\<A> (False, Map_empty);\n      return_spmf (b = b', bad)})\""], ["proof (state)\nthis:\n  game2' =\n  (\\<lambda>\\<A>.\n      key_gen \\<bind>\n      (\\<lambda>key.\n          coin_spmf \\<bind>\n          (\\<lambda>b.\n              exec_gpv\n               (oracle_encrypt2' key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n               \\<A> (False, Map_empty) \\<bind>\n              (\\<lambda>(b', bad, D). return_spmf (b = b', bad)))))\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "have game2'_eq: \"game2 \\<A> = map_spmf fst (game2' \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. game2 \\<A> = map_spmf fst (game2' \\<A>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. game2 \\<A> = map_spmf fst (game2' \\<A>)", "define S where \"S = (\\<lambda>(D1 :: (bitstring, bitstring) PRF.dict) (bad :: bool, D2). D1 = D2)\""], ["proof (state)\nthis:\n  S = (\\<lambda>D1 (bad, D2). D1 = D2)\n\ngoal (1 subgoal):\n 1. game2 \\<A> = map_spmf fst (game2' \\<A>)", "have [transfer_rule, simp]: \"S Map_empty (b, Map_empty)\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. S Map_empty (b, Map_empty)", "by (simp add: S_def)"], ["proof (state)\nthis:\n  S Map_empty (?b2, Map_empty)\n\ngoal (1 subgoal):\n 1. game2 \\<A> = map_spmf fst (game2' \\<A>)", "have [transfer_rule]: \"((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n      oracle_encrypt2 oracle_encrypt2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n     oracle_encrypt2 oracle_encrypt2'", "unfolding oracle_encrypt2_def[abs_def] oracle_encrypt2'_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n     (\\<lambda>(k_prf, k_upf) b D (msg1, msg0).\n         case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n         True \\<Rightarrow>\n           spmf_of_set prf_domain \\<bind>\n           (\\<lambda>x.\n               spmf_of_set (nlists UNIV prf_clen) \\<bind>\n               (\\<lambda>P.\n                   let p = case D x of None \\<Rightarrow> P\n                           | Some r \\<Rightarrow> r;\n                       c = p [\\<oplus>] (if b then msg1 else msg0);\n                       t = upf_fun k_upf (x @ c)\n                   in return_spmf (Some (x, c, t), D(x \\<mapsto> p))))\n         | False \\<Rightarrow> return_spmf (None, D))\n     (\\<lambda>(k_prf, k_upf) b (bad, D) (msg1, msg0).\n         case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n         True \\<Rightarrow>\n           spmf_of_set prf_domain \\<bind>\n           (\\<lambda>x.\n               spmf_of_set (nlists UNIV prf_clen) \\<bind>\n               (\\<lambda>P.\n                   let (p, F) =\n                         case D x of None \\<Rightarrow> (P, False)\n                         | Some r \\<Rightarrow> (r, True);\n                       c = p [\\<oplus>] (if b then msg1 else msg0);\n                       t = upf_fun k_upf (x @ c)\n                   in return_spmf\n                       (Some (x, c, t), bad \\<or> F, D(x \\<mapsto> p))))\n         | False \\<Rightarrow> return_spmf (None, bad, D))", "by (auto simp add: rel_fun_def Let_def split_def S_def\n           intro!: rel_spmf_bind_reflI split: bool.split option.split)"], ["proof (state)\nthis:\n  ((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n   oracle_encrypt2 oracle_encrypt2'\n\ngoal (1 subgoal):\n 1. game2 \\<A> = map_spmf fst (game2' \\<A>)", "have [transfer_rule]: \"((=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S)) \n      oracle_decrypt2 oracle_decrypt2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S)) oracle_decrypt2\n     oracle_decrypt2", "by(auto simp add: rel_fun_def oracle_decrypt2_def)"], ["proof (state)\nthis:\n  ((=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S)) oracle_decrypt2\n   oracle_decrypt2\n\ngoal (1 subgoal):\n 1. game2 \\<A> = map_spmf fst (game2' \\<A>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. game2 \\<A> = map_spmf fst (game2' \\<A>)", "unfolding game2_def game2'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. key_gen \\<bind>\n    (\\<lambda>key.\n        coin_spmf \\<bind>\n        (\\<lambda>b.\n            exec_gpv\n             (oracle_encrypt2 key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n             \\<A> Map_empty \\<bind>\n            (\\<lambda>(b', D). return_spmf (b = b')))) =\n    map_spmf fst\n     (key_gen \\<bind>\n      (\\<lambda>key.\n          coin_spmf \\<bind>\n          (\\<lambda>b.\n              exec_gpv\n               (oracle_encrypt2' key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n               \\<A> (False, Map_empty) \\<bind>\n              (\\<lambda>(b', bad, D). return_spmf (b = b', bad)))))", "by (simp add: map_spmf_bind_spmf o_def split_def Map_empty_def[symmetric] del: Map_empty_def)\n         transfer_prover"], ["proof (state)\nthis:\n  game2 \\<A> = map_spmf fst (game2' \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  game2 \\<A> = map_spmf fst (game2' \\<A>)\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "moreover"], ["proof (state)\nthis:\n  game2 \\<A> = map_spmf fst (game2' \\<A>)\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "have *: \"rel_spmf (\\<lambda>(b'1, bad1, L1) (b'2, bad2, L2). (bad1 \\<longleftrightarrow> bad2) \\<and> (\\<not> bad2 \\<longrightarrow> b'1 \\<longleftrightarrow> b'2))\n    (exec_gpv (oracle_encrypt3 key b \\<oplus>\\<^sub>O oracle_decrypt2 key) \\<A> (False, Map_empty))\n    (exec_gpv (oracle_encrypt2' key b \\<oplus>\\<^sub>O oracle_decrypt2 key) \\<A> (False, Map_empty))\"\n    for key b"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(b'1, bad1, L1) (b'2, bad2, L2).\n         bad1 = bad2 \\<and> (\\<not> bad2 \\<longrightarrow> b'1 = b'2))\n     (exec_gpv (oracle_encrypt3 key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n       \\<A> (False, Map_empty))\n     (exec_gpv (oracle_encrypt2' key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n       \\<A> (False, Map_empty))", "apply(rule exec_gpv_oracle_bisim_bad[where X=\"(=)\" and X_bad = \"\\<lambda>_ _. True\" and ?bad1.0=fst and ?bad2.0=fst and \\<I>=\"\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full\"])"], ["proof (prove)\ngoal (12 subgoals):\n 1. if fst (False, Map_empty) then True\n    else (False, Map_empty) = (False, Map_empty)\n 2. fst (False, Map_empty) = fst (False, Map_empty)\n 3. \\<And>s1 s2 x.\n       s1 = s2 \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1') (b, s2').\n            fst s1' = fst s2' \\<and>\n            (if fst s2' then True else a = b \\<and> s1' = s2'))\n        ((oracle_encrypt3 key b \\<oplus>\\<^sub>O oracle_decrypt2 key) s1 x)\n        ((oracle_encrypt2' key b \\<oplus>\\<^sub>O oracle_decrypt2 key) s2 x)\n 4. \\<And>s2.\n       fst s2 \\<Longrightarrow>\n       callee_invariant_on\n        (oracle_encrypt3 key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n        (\\<lambda>s1. fst s1 \\<and> True)\n        (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n 5. \\<And>s1.\n       fst s1 \\<Longrightarrow>\n       callee_invariant_on\n        (oracle_encrypt2' key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n        (\\<lambda>s2. fst s2 \\<and> True)\n        (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n 6. \\<And>s1 x.\n       fst s1 \\<Longrightarrow>\n       lossless_spmf\n        ((oracle_encrypt3 key b \\<oplus>\\<^sub>O oracle_decrypt2 key) s1 x)\n 7. \\<And>s2 x.\n       fst s2 \\<Longrightarrow>\n       lossless_spmf\n        ((oracle_encrypt2' key b \\<oplus>\\<^sub>O oracle_decrypt2 key) s2 x)\n 8. lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\n 9. \\<And>s1.\n       \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>c\n       (oracle_encrypt3 key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n        s1 \\<surd>\n 10. \\<And>s2.\n        \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>c\n        (oracle_encrypt2' key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n         s2 \\<surd>\nA total of 12 subgoals...", "apply(simp_all add: assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 x.\n       s1 = s2 \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1') (b, s2').\n            (fst s2' \\<longrightarrow> fst s1') \\<and>\n            (\\<not> fst s2' \\<longrightarrow>\n             \\<not> fst s1' \\<and> a = b \\<and> s1' = s2'))\n        ((oracle_encrypt3 key b \\<oplus>\\<^sub>O oracle_decrypt2 key) s2 x)\n        ((oracle_encrypt2' key b \\<oplus>\\<^sub>O oracle_decrypt2 key) s2 x)\n 2. \\<And>a s1 b s2.\n       \\<lbrakk>fst s1 = fst s2;\n        \\<not> fst s2 \\<Longrightarrow> a = b \\<and> s1 = s2\\<rbrakk>\n       \\<Longrightarrow> (case s1 of\n                          (bad1, L1) \\<Rightarrow>\n                            \\<lambda>(b'2, bad2, L2).\n                               bad1 = bad2 \\<and>\n                               (\\<not> bad2 \\<longrightarrow> a = b'2))\n                          (b, s2)", "apply(auto simp add: assms spmf_rel_map Let_def oracle_encrypt2'_def oracle_encrypt3_def split: plus_oracle_split prod.split bool.split option.split intro!: rel_spmf_bind_reflI rel_spmf_reflI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(b'1, bad1, L1) (b'2, bad2, L2).\n       bad1 = bad2 \\<and> (\\<not> bad2 \\<longrightarrow> b'1 = b'2))\n   (exec_gpv\n     (oracle_encrypt3 ?key2 ?b2 \\<oplus>\\<^sub>O oracle_decrypt2 ?key2) \\<A>\n     (False, Map_empty))\n   (exec_gpv\n     (oracle_encrypt2' ?key2 ?b2 \\<oplus>\\<^sub>O oracle_decrypt2 ?key2)\n     \\<A> (False, Map_empty))\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "have \"\\<bar>measure (measure_spmf (game3 \\<A>)) {(b, bad). b} - measure (measure_spmf (game2' \\<A>)) {(b, bad). b}\\<bar> \\<le>\n    measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          Sigma_Algebra.measure (measure_spmf (game2' \\<A>))\n           {(b, bad). b}\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "unfolding game2'_def game3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure\n           (measure_spmf\n             (key_gen \\<bind>\n              (\\<lambda>key.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      exec_gpv\n                       (oracle_encrypt3 key b \\<oplus>\\<^sub>O\n                        oracle_decrypt2 key)\n                       \\<A> (False, Map_empty) \\<bind>\n                      (\\<lambda>(b', bad, D). return_spmf (b = b', bad))))))\n           {(b, bad). b} -\n          Sigma_Algebra.measure\n           (measure_spmf\n             (key_gen \\<bind>\n              (\\<lambda>key.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      exec_gpv\n                       (oracle_encrypt2' key b \\<oplus>\\<^sub>O\n                        oracle_decrypt2 key)\n                       \\<A> (False, Map_empty) \\<bind>\n                      (\\<lambda>(b', bad, D). return_spmf (b = b', bad))))))\n           {(b, bad). b}\\<bar>\n    \\<le> Sigma_Algebra.measure\n           (measure_spmf\n             (key_gen \\<bind>\n              (\\<lambda>key.\n                  coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      exec_gpv\n                       (oracle_encrypt3 key b \\<oplus>\\<^sub>O\n                        oracle_decrypt2 key)\n                       \\<A> (False, Map_empty) \\<bind>\n                      (\\<lambda>(b', bad, D). return_spmf (b = b', bad))))))\n           {(b, bad). bad}", "by(rule fundamental_lemma[where ?bad2.0=snd])(intro rel_spmf_bind_reflI rel_spmf_bindI[OF *]; clarsimp)"], ["proof (state)\nthis:\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n        Sigma_Algebra.measure (measure_spmf (game2' \\<A>))\n         {(b, bad). b}\\<bar>\n  \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "ultimately"], ["proof (chain)\npicking this:\n  game2 \\<A> = map_spmf fst (game2' \\<A>)\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n        Sigma_Algebra.measure (measure_spmf (game2' \\<A>))\n         {(b, bad). b}\\<bar>\n  \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "show ?thesis"], ["proof (prove)\nusing this:\n  game2 \\<A> = map_spmf fst (game2' \\<A>)\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n        Sigma_Algebra.measure (measure_spmf (game2' \\<A>))\n         {(b, bad). b}\\<bar>\n  \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "by(simp add: spmf_conv_measure_spmf measure_map_spmf vimage_def fst_def)"], ["proof (state)\nthis:\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n        spmf (game2 \\<A>) True\\<bar>\n  \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma round_4:\n  assumes \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\"\n  shows \"map_spmf fst (game3 \\<A>) = coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = coin_spmf", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = coin_spmf", "define oracle_encrypt4\n    where \"oracle_encrypt4 = (\\<lambda>(k_prf :: 'prf_key, k_upf) (s :: unit) (msg1 :: bitstring, msg0 :: bitstring).\n      case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n        False \\<Rightarrow> return_spmf (None, s)\n      | True \\<Rightarrow> do {\n          x \\<leftarrow> spmf_of_set prf_domain;\n          P \\<leftarrow> spmf_of_set (nlists UNIV prf_clen);\n          let c = P;\n          let t = upf_fun k_upf (x @ c);\n          return_spmf (Some (x, c, t), s) })\""], ["proof (state)\nthis:\n  oracle_encrypt4 =\n  (\\<lambda>(k_prf, k_upf) s (msg1, msg0).\n      case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n      True \\<Rightarrow>\n        spmf_of_set prf_domain \\<bind>\n        (\\<lambda>x.\n            spmf_of_set (nlists UNIV prf_clen) \\<bind>\n            (\\<lambda>P.\n                let c = P; t = upf_fun k_upf (x @ c)\n                in return_spmf (Some (x, c, t), s)))\n      | False \\<Rightarrow> return_spmf (None, s))\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = coin_spmf", "have [simp]: \"lossless_spmf (oracle_encrypt4 k s msg10)\" for k s msg10"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (oracle_encrypt4 k s msg10)", "by (cases msg10) (simp add: oracle_encrypt4_def prf_domain_finite prf_domain_nonempty\n      split_def Let_def split: bool.splits)"], ["proof (state)\nthis:\n  lossless_spmf (oracle_encrypt4 ?k2 ?s2 ?msg10.2)\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = coin_spmf", "define game4 where \"game4 = (\\<lambda>\\<A>. do {\n    key \\<leftarrow> key_gen;\n    (b', _) \\<leftarrow> exec_gpv (oracle_encrypt4 key \\<oplus>\\<^sub>O oracle_decrypt2 key) \\<A> ();\n    map_spmf ((=) b') coin_spmf})\""], ["proof (state)\nthis:\n  game4 =\n  (\\<lambda>\\<A>.\n      key_gen \\<bind>\n      (\\<lambda>key.\n          exec_gpv\n           (oracle_encrypt4 key \\<oplus>\\<^sub>O oracle_decrypt2 key) \\<A>\n           () \\<bind>\n          (\\<lambda>(b', uu_). map_spmf ((=) b') coin_spmf)))\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = coin_spmf", "have \"map_spmf fst (game3 \\<A>) = game4 \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = game4 \\<A>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = game4 \\<A>", "note [split del] = if_split"], ["proof (state)\nthis:\n  ?P (if ?Q then ?x else ?y) =\n  ((?Q \\<longrightarrow> ?P ?x) \\<and> (\\<not> ?Q \\<longrightarrow> ?P ?y))\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = game4 \\<A>", "define S where \"S = (\\<lambda>(_ :: unit) (_ :: bool \\<times> (bitstring, bitstring) PRF.dict). True)\""], ["proof (state)\nthis:\n  S = (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = game4 \\<A>", "define initial3 where \"initial3 = (False, Map.empty :: (bitstring, bitstring) PRF.dict)\""], ["proof (state)\nthis:\n  initial3 = (False, Map.empty)\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = game4 \\<A>", "have [transfer_rule]: \"S () initial3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S () initial3", "by(simp add: S_def)"], ["proof (state)\nthis:\n  S () initial3\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = game4 \\<A>", "have [transfer_rule]: \"((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n       (\\<lambda>key b. oracle_encrypt4 key) oracle_encrypt3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n     (\\<lambda>key b. oracle_encrypt4 key) oracle_encrypt3", "proof(intro rel_funI; hypsubst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       S xb yb \\<Longrightarrow>\n       rel_spmf (rel_prod (=) S) (oracle_encrypt4 y xb yc)\n        (oracle_encrypt3 y ya yb yc)", "fix key unit msg10 b Dbad"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       S xb yb \\<Longrightarrow>\n       rel_spmf (rel_prod (=) S) (oracle_encrypt4 y xb yc)\n        (oracle_encrypt3 y ya yb yc)", "have \"map_spmf fst (oracle_encrypt4 key () msg10) = map_spmf fst (oracle_encrypt3 key b Dbad msg10)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf fst (oracle_encrypt4 key () msg10) =\n    map_spmf fst (oracle_encrypt3 key b Dbad msg10)", "unfolding oracle_encrypt3_def oracle_encrypt4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf fst\n     ((case key of\n       (k_prf, k_upf) \\<Rightarrow>\n         \\<lambda>s (msg1, msg0).\n            case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n            True \\<Rightarrow>\n              spmf_of_set prf_domain \\<bind>\n              (\\<lambda>x.\n                  spmf_of_set (nlists UNIV prf_clen) \\<bind>\n                  (\\<lambda>P.\n                      let c = P; t = upf_fun k_upf (x @ c)\n                      in return_spmf (Some (x, c, t), s)))\n            | False \\<Rightarrow> return_spmf (None, s))\n       () msg10) =\n    map_spmf fst\n     ((case key of\n       (k_prf, k_upf) \\<Rightarrow>\n         \\<lambda>b (bad, D) (msg1, msg0).\n            case length msg1 = prf_clen \\<and> length msg0 = prf_clen of\n            True \\<Rightarrow>\n              spmf_of_set prf_domain \\<bind>\n              (\\<lambda>x.\n                  spmf_of_set (nlists UNIV prf_clen) \\<bind>\n                  (\\<lambda>P.\n                      let (p, F) =\n                            case D x of None \\<Rightarrow> (P, False)\n                            | Some r \\<Rightarrow> (P, True);\n                          c = p [\\<oplus>] (if b then msg1 else msg0);\n                          t = upf_fun k_upf (x @ c)\n                      in return_spmf\n                          (Some (x, c, t), bad \\<or> F, D(x \\<mapsto> p))))\n            | False \\<Rightarrow> return_spmf (None, bad, D))\n       b Dbad msg10)", "apply (clarsimp simp add: map_spmf_conv_bind_spmf Let_def split: bool.split prod.split; rule conjI; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>length x2a = length x1a; prf_clen = length x1a;\n        msg10 = (x1a, x2a); Dbad = (x1b, x2b); key = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> spmf_of_set prf_domain \\<bind>\n                         (\\<lambda>y.\n                             spmf_of_set (nlists UNIV (length x1a)) \\<bind>\n                             (\\<lambda>ya.\n                                 return_spmf\n                                  (Some (y, ya, upf_fun x2 (y @ ya))))) =\n                         spmf_of_set prf_domain \\<bind>\n                         (\\<lambda>y.\n                             spmf_of_set (nlists UNIV (length x1a)) \\<bind>\n                             (\\<lambda>ya.\n                                 (case case x2b y of\n None \\<Rightarrow> (ya, False) | Some r \\<Rightarrow> (ya, True) of\n                                  (p, F) \\<Rightarrow>\n                                    return_spmf\n                                     (Some\n (y, p [\\<oplus>] (if b then x1a else x2a),\n  upf_fun x2 (y @ p [\\<oplus>] (if b then x1a else x2a))),\nx1b \\<or> F, x2b(y \\<mapsto> p))) \\<bind>\n                                 (\\<lambda>x. return_spmf (fst x))))", "apply (rewrite in \"\\<hole> = _\" one_time_pad[symmetric, where xs=\"if b then fst msg10 else snd msg10\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xaa xaaa xaaaa xaaaaa xaaaaaa.\n       \\<lbrakk>length xaaa = length xaa; prf_clen = length xaa;\n        msg10 = (xaa, xaaa); Dbad = (xaaaa, xaaaaa); key = (x, xa)\\<rbrakk>\n       \\<Longrightarrow> length xaa\n                         \\<le> length (if b then fst msg10 else snd msg10)\n 2. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>length x2a = length x1a; prf_clen = length x1a;\n        msg10 = (x1a, x2a); Dbad = (x1b, x2b); key = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> spmf_of_set prf_domain \\<bind>\n                         (\\<lambda>y.\n                             map_spmf\n                              (([\\<oplus>])\n                                (if b then fst msg10 else snd msg10))\n                              (spmf_of_set\n                                (nlists UNIV (length x1a))) \\<bind>\n                             (\\<lambda>ya.\n                                 return_spmf\n                                  (Some (y, ya, upf_fun x2 (y @ ya))))) =\n                         spmf_of_set prf_domain \\<bind>\n                         (\\<lambda>y.\n                             spmf_of_set (nlists UNIV (length x1a)) \\<bind>\n                             (\\<lambda>ya.\n                                 (case case x2b y of\n None \\<Rightarrow> (ya, False) | Some r \\<Rightarrow> (ya, True) of\n                                  (p, F) \\<Rightarrow>\n                                    return_spmf\n                                     (Some\n (y, p [\\<oplus>] (if b then x1a else x2a),\n  upf_fun x2 (y @ p [\\<oplus>] (if b then x1a else x2a))),\nx1b \\<or> F, x2b(y \\<mapsto> p))) \\<bind>\n                                 (\\<lambda>x. return_spmf (fst x))))", "apply(simp split: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>length x2a = length x1a; prf_clen = length x1a;\n        msg10 = (x1a, x2a); Dbad = (x1b, x2b); key = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> spmf_of_set prf_domain \\<bind>\n                         (\\<lambda>y.\n                             map_spmf\n                              (([\\<oplus>])\n                                (if b then fst msg10 else snd msg10))\n                              (spmf_of_set\n                                (nlists UNIV (length x1a))) \\<bind>\n                             (\\<lambda>ya.\n                                 return_spmf\n                                  (Some (y, ya, upf_fun x2 (y @ ya))))) =\n                         spmf_of_set prf_domain \\<bind>\n                         (\\<lambda>y.\n                             spmf_of_set (nlists UNIV (length x1a)) \\<bind>\n                             (\\<lambda>ya.\n                                 (case case x2b y of\n None \\<Rightarrow> (ya, False) | Some r \\<Rightarrow> (ya, True) of\n                                  (p, F) \\<Rightarrow>\n                                    return_spmf\n                                     (Some\n (y, p [\\<oplus>] (if b then x1a else x2a),\n  upf_fun x2 (y @ p [\\<oplus>] (if b then x1a else x2a))),\nx1b \\<or> F, x2b(y \\<mapsto> p))) \\<bind>\n                                 (\\<lambda>x. return_spmf (fst x))))", "apply(simp add: bind_map_spmf o_def option.case_distrib case_option_collapse xor_list_commute split_def cong del: option.case_cong_weak if_weak_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_spmf fst (oracle_encrypt4 key () msg10) =\n  map_spmf fst (oracle_encrypt3 key b Dbad msg10)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       S xb yb \\<Longrightarrow>\n       rel_spmf (rel_prod (=) S) (oracle_encrypt4 y xb yc)\n        (oracle_encrypt3 y ya yb yc)", "then"], ["proof (chain)\npicking this:\n  map_spmf fst (oracle_encrypt4 key () msg10) =\n  map_spmf fst (oracle_encrypt3 key b Dbad msg10)", "show \"rel_spmf (rel_prod (=) S) (oracle_encrypt4 key unit msg10) (oracle_encrypt3 key b Dbad msg10)\""], ["proof (prove)\nusing this:\n  map_spmf fst (oracle_encrypt4 key () msg10) =\n  map_spmf fst (oracle_encrypt3 key b Dbad msg10)\n\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (=) S) (oracle_encrypt4 key unit msg10)\n     (oracle_encrypt3 key b Dbad msg10)", "by(auto simp add: spmf_rel_eq[symmetric] spmf_rel_map S_def elim: rel_spmf_mono)"], ["proof (state)\nthis:\n  rel_spmf (rel_prod (=) S) (oracle_encrypt4 key unit msg10)\n   (oracle_encrypt3 key b Dbad msg10)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((=) ===> (=) ===> S ===> (=) ===> rel_spmf (rel_prod (=) S))\n   (\\<lambda>key b. oracle_encrypt4 key) oracle_encrypt3\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = game4 \\<A>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = game4 \\<A>", "unfolding game3_def game4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf fst\n     (key_gen \\<bind>\n      (\\<lambda>key.\n          coin_spmf \\<bind>\n          (\\<lambda>b.\n              exec_gpv\n               (oracle_encrypt3 key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n               \\<A> (False, Map_empty) \\<bind>\n              (\\<lambda>(b', bad, D). return_spmf (b = b', bad))))) =\n    key_gen \\<bind>\n    (\\<lambda>key.\n        exec_gpv (oracle_encrypt4 key \\<oplus>\\<^sub>O oracle_decrypt2 key)\n         \\<A> () \\<bind>\n        (\\<lambda>(b', uu_). map_spmf ((=) b') coin_spmf))", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf fst\n     (key_gen \\<bind>\n      (\\<lambda>key.\n          coin_spmf \\<bind>\n          (\\<lambda>b.\n              exec_gpv\n               (oracle_encrypt3 key b \\<oplus>\\<^sub>O oracle_decrypt2 key)\n               \\<A> (False, Map_empty) \\<bind>\n              (\\<lambda>(b', bad, D). return_spmf (b = b', bad))))) =\n    key_gen \\<bind>\n    (\\<lambda>key.\n        exec_gpv (oracle_encrypt4 key \\<oplus>\\<^sub>O oracle_decrypt2 key)\n         \\<A> () \\<bind>\n        (\\<lambda>(b', uu_). map_spmf ((=) b') coin_spmf))", "by (simp add: map_spmf_bind_spmf o_def split_def map_spmf_conv_bind_spmf initial3_def[symmetric] eq_commute)\n         transfer_prover"], ["proof (state)\nthis:\n  map_spmf fst (game3 \\<A>) = game4 \\<A>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_spmf fst (game3 \\<A>) = game4 \\<A>\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = coin_spmf", "also"], ["proof (state)\nthis:\n  map_spmf fst (game3 \\<A>) = game4 \\<A>\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = coin_spmf", "have \"\\<dots> = coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. game4 \\<A> = coin_spmf", "by(simp add: map_eq_const_coin_spmf game4_def bind_spmf_const split_def lossless_exec_gpv[OF assms] lossless_weight_spmfD)"], ["proof (state)\nthis:\n  game4 \\<A> = coin_spmf\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = coin_spmf", "finally"], ["proof (chain)\npicking this:\n  map_spmf fst (game3 \\<A>) = coin_spmf", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf fst (game3 \\<A>) = coin_spmf\n\ngoal (1 subgoal):\n 1. map_spmf fst (game3 \\<A>) = coin_spmf", "."], ["proof (state)\nthis:\n  map_spmf fst (game3 \\<A>) = coin_spmf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma game3_bad:\n  assumes \"interaction_bounded_by isl \\<A> q\"\n  shows \"measure (measure_spmf (game3 \\<A>)) {(b, bad). bad} \\<le> q / card prf_domain * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n    \\<le> real q / real (card prf_domain) * real q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n    \\<le> real q / real (card prf_domain) * real q", "have \"measure (measure_spmf (game3 \\<A>)) {(b, bad). bad} = spmf (map_spmf snd (game3 \\<A>)) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad} =\n    spmf (map_spmf snd (game3 \\<A>)) True", "by (simp add: spmf_conv_measure_spmf measure_map_spmf vimage_def snd_def)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad} =\n  spmf (map_spmf snd (game3 \\<A>)) True\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n    \\<le> real q / real (card prf_domain) * real q", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad} =\n  spmf (map_spmf snd (game3 \\<A>)) True\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n    \\<le> real q / real (card prf_domain) * real q", "have \"spmf (map_spmf (fst \\<circ> snd) (exec_gpv (oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) \\<A> (False, Map.empty))) True \\<le> q / card prf_domain * q\"\n    (is \"spmf (map_spmf _ (exec_gpv ?oracle _ _)) _ \\<le>  _\")\n    if k: \"k \\<in> set_spmf key_gen\" for k b"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       (exec_gpv (oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k)\n         \\<A> (False, Map.empty)))\n     True\n    \\<le> real q / real (card prf_domain) * real q", "proof(rule callee_invariant_on.interaction_bounded_by'_exec_gpv_bad_count)"], ["proof (state)\ngoal (10 subgoals):\n 1. callee_invariant_on\n     (oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) ?I ?\\<I>\n 2. interaction_bounded_by' ?consider \\<A> q\n 3. ?I (False, Map.empty)\n 4. \\<not> fst (False, Map.empty)\n 5. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> Suc (?count s)\n 6. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> ?count s\n 7. \\<And>s' x.\n       \\<lbrakk>?I s'; \\<not> fst s';\n        ?count s' < q + ?count (False, Map.empty); ?consider x;\n        x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf (fst \\<circ> snd)\n                            ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                              oracle_decrypt2 k)\n                              s' x))\n                          True\n                         \\<le> real q / real (card prf_domain)\n 8. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> fst s; fst s'; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?consider x\n 9. 0 \\<le> real q / real (card prf_domain)\n 10. ?\\<I> \\<turnstile>g \\<A> \\<surd>", "obtain k_prf k_upf where k: \"k = (k_prf, k_upf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k_prf k_upf.\n        k = (k_prf, k_upf) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases k)"], ["proof (state)\nthis:\n  k = (k_prf, k_upf)\n\ngoal (10 subgoals):\n 1. callee_invariant_on\n     (oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) ?I ?\\<I>\n 2. interaction_bounded_by' ?consider \\<A> q\n 3. ?I (False, Map.empty)\n 4. \\<not> fst (False, Map.empty)\n 5. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> Suc (?count s)\n 6. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> ?count s\n 7. \\<And>s' x.\n       \\<lbrakk>?I s'; \\<not> fst s';\n        ?count s' < q + ?count (False, Map.empty); ?consider x;\n        x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf (fst \\<circ> snd)\n                            ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                              oracle_decrypt2 k)\n                              s' x))\n                          True\n                         \\<le> real q / real (card prf_domain)\n 8. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> fst s; fst s'; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?consider x\n 9. 0 \\<le> real q / real (card prf_domain)\n 10. ?\\<I> \\<turnstile>g \\<A> \\<surd>", "let ?I = \"\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain\""], ["proof (state)\ngoal (10 subgoals):\n 1. callee_invariant_on\n     (oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) ?I ?\\<I>\n 2. interaction_bounded_by' ?consider \\<A> q\n 3. ?I (False, Map.empty)\n 4. \\<not> fst (False, Map.empty)\n 5. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> Suc (?count s)\n 6. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> ?count s\n 7. \\<And>s' x.\n       \\<lbrakk>?I s'; \\<not> fst s';\n        ?count s' < q + ?count (False, Map.empty); ?consider x;\n        x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf (fst \\<circ> snd)\n                            ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                              oracle_decrypt2 k)\n                              s' x))\n                          True\n                         \\<le> real q / real (card prf_domain)\n 8. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> fst s; fst s'; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?consider x\n 9. 0 \\<le> real q / real (card prf_domain)\n 10. ?\\<I> \\<turnstile>g \\<A> \\<surd>", "have \"callee_invariant (oracle_encrypt3 k b) ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant (oracle_encrypt3 k b)\n     (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)", "by unfold_locales(clarsimp simp add: prf_domain_finite oracle_encrypt3_def Let_def split_def split: bool.splits)+"], ["proof (state)\nthis:\n  callee_invariant (oracle_encrypt3 k b)\n   (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)\n\ngoal (10 subgoals):\n 1. callee_invariant_on\n     (oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) ?I ?\\<I>\n 2. interaction_bounded_by' ?consider \\<A> q\n 3. ?I (False, Map.empty)\n 4. \\<not> fst (False, Map.empty)\n 5. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> Suc (?count s)\n 6. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> ?count s\n 7. \\<And>s' x.\n       \\<lbrakk>?I s'; \\<not> fst s';\n        ?count s' < q + ?count (False, Map.empty); ?consider x;\n        x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf (fst \\<circ> snd)\n                            ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                              oracle_decrypt2 k)\n                              s' x))\n                          True\n                         \\<le> real q / real (card prf_domain)\n 8. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> fst s; fst s'; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?consider x\n 9. 0 \\<le> real q / real (card prf_domain)\n 10. ?\\<I> \\<turnstile>g \\<A> \\<surd>", "moreover"], ["proof (state)\nthis:\n  callee_invariant (oracle_encrypt3 k b)\n   (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)\n\ngoal (10 subgoals):\n 1. callee_invariant_on\n     (oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) ?I ?\\<I>\n 2. interaction_bounded_by' ?consider \\<A> q\n 3. ?I (False, Map.empty)\n 4. \\<not> fst (False, Map.empty)\n 5. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> Suc (?count s)\n 6. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> ?count s\n 7. \\<And>s' x.\n       \\<lbrakk>?I s'; \\<not> fst s';\n        ?count s' < q + ?count (False, Map.empty); ?consider x;\n        x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf (fst \\<circ> snd)\n                            ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                              oracle_decrypt2 k)\n                              s' x))\n                          True\n                         \\<le> real q / real (card prf_domain)\n 8. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> fst s; fst s'; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?consider x\n 9. 0 \\<le> real q / real (card prf_domain)\n 10. ?\\<I> \\<turnstile>g \\<A> \\<surd>", "have \"callee_invariant (oracle_decrypt2 k) ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant (oracle_decrypt2 k)\n     (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)", "by unfold_locales (clarsimp simp add: prf_domain_finite oracle_decrypt2_def)+"], ["proof (state)\nthis:\n  callee_invariant (oracle_decrypt2 k)\n   (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)\n\ngoal (10 subgoals):\n 1. callee_invariant_on\n     (oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) ?I ?\\<I>\n 2. interaction_bounded_by' ?consider \\<A> q\n 3. ?I (False, Map.empty)\n 4. \\<not> fst (False, Map.empty)\n 5. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> Suc (?count s)\n 6. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> ?consider x; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> ?count s\n 7. \\<And>s' x.\n       \\<lbrakk>?I s'; \\<not> fst s';\n        ?count s' < q + ?count (False, Map.empty); ?consider x;\n        x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf (fst \\<circ> snd)\n                            ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                              oracle_decrypt2 k)\n                              s' x))\n                          True\n                         \\<le> real q / real (card prf_domain)\n 8. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        ?I s; \\<not> fst s; fst s'; x \\<in> outs_\\<I> ?\\<I>\\<rbrakk>\n       \\<Longrightarrow> ?consider x\n 9. 0 \\<le> real q / real (card prf_domain)\n 10. ?\\<I> \\<turnstile>g \\<A> \\<surd>", "ultimately"], ["proof (chain)\npicking this:\n  callee_invariant (oracle_encrypt3 k b)\n   (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)\n  callee_invariant (oracle_decrypt2 k)\n   (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)", "show \"callee_invariant ?oracle ?I\""], ["proof (prove)\nusing this:\n  callee_invariant (oracle_encrypt3 k b)\n   (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)\n  callee_invariant (oracle_decrypt2 k)\n   (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)\n\ngoal (1 subgoal):\n 1. callee_invariant\n     (oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k)\n     (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)", "by simp"], ["proof (state)\nthis:\n  callee_invariant (oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k)\n   (\\<lambda>(bad, D). finite (dom D) \\<and> dom D \\<subseteq> prf_domain)\n\ngoal (9 subgoals):\n 1. interaction_bounded_by' ?consider \\<A> q\n 2. case (False, Map.empty) of\n    (bad, D) \\<Rightarrow>\n      finite (dom D) \\<and> dom D \\<subseteq> prf_domain\n 3. \\<not> fst (False, Map.empty)\n 4. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        ?consider x; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> Suc (?count s)\n 5. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> ?consider x; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> ?count s\n 6. \\<And>s' x.\n       \\<lbrakk>case s' of\n                (bad, D) \\<Rightarrow>\n                  finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> fst s'; ?count s' < q + ?count (False, Map.empty);\n        ?consider x; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf (fst \\<circ> snd)\n                            ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                              oracle_decrypt2 k)\n                              s' x))\n                          True\n                         \\<le> real q / real (card prf_domain)\n 7. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> fst s; fst s'; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> ?consider x\n 8. 0 \\<le> real q / real (card prf_domain)\n 9. \\<I>_full \\<turnstile>g \\<A> \\<surd>", "let ?count = \"\\<lambda>(bad, D). card (dom D)\""], ["proof (state)\ngoal (9 subgoals):\n 1. interaction_bounded_by' ?consider \\<A> q\n 2. case (False, Map.empty) of\n    (bad, D) \\<Rightarrow>\n      finite (dom D) \\<and> dom D \\<subseteq> prf_domain\n 3. \\<not> fst (False, Map.empty)\n 4. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        ?consider x; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> Suc (?count s)\n 5. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> ?consider x; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> ?count s' \\<le> ?count s\n 6. \\<And>s' x.\n       \\<lbrakk>case s' of\n                (bad, D) \\<Rightarrow>\n                  finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> fst s'; ?count s' < q + ?count (False, Map.empty);\n        ?consider x; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf (fst \\<circ> snd)\n                            ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                              oracle_decrypt2 k)\n                              s' x))\n                          True\n                         \\<le> real q / real (card prf_domain)\n 7. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> fst s; fst s'; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> ?consider x\n 8. 0 \\<le> real q / real (card prf_domain)\n 9. \\<I>_full \\<turnstile>g \\<A> \\<surd>", "show \"\\<And>s x y s'. \\<lbrakk> (y, s') \\<in> set_spmf (?oracle s x); ?I s; isl x \\<rbrakk> \\<Longrightarrow> ?count s' \\<le> Suc (?count s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        isl x\\<rbrakk>\n       \\<Longrightarrow> (case s' of (bad, D) \\<Rightarrow> card (dom D))\n                         \\<le> Suc (case s of\n                                    (bad, D) \\<Rightarrow> card (dom D))", "by(clarsimp simp add: isl_def oracle_encrypt3_def split_def Let_def card_insert_if split: bool.splits)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y5, ?s'5)\n           \\<in> set_spmf\n                  ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k)\n                    ?s5 ?x5);\n   case ?s5 of\n   (bad, D) \\<Rightarrow>\n     finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n   isl ?x5\\<rbrakk>\n  \\<Longrightarrow> (case ?s'5 of (bad, D) \\<Rightarrow> card (dom D))\n                    \\<le> Suc (case ?s5 of\n                               (bad, D) \\<Rightarrow> card (dom D))\n\ngoal (8 subgoals):\n 1. interaction_bounded_by' isl \\<A> q\n 2. case (False, Map.empty) of\n    (bad, D) \\<Rightarrow>\n      finite (dom D) \\<and> dom D \\<subseteq> prf_domain\n 3. \\<not> fst (False, Map.empty)\n 4. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> isl x; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> (case s' of (bad, D) \\<Rightarrow> card (dom D))\n                         \\<le> (case s of\n                                (bad, D) \\<Rightarrow> card (dom D))\n 5. \\<And>s' x.\n       \\<lbrakk>case s' of\n                (bad, D) \\<Rightarrow>\n                  finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> fst s';\n        (case s' of (bad, D) \\<Rightarrow> card (dom D))\n        < q +\n          (case (False, Map.empty) of (bad, D) \\<Rightarrow> card (dom D));\n        isl x; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf (fst \\<circ> snd)\n                            ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                              oracle_decrypt2 k)\n                              s' x))\n                          True\n                         \\<le> real q / real (card prf_domain)\n 6. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> fst s; fst s'; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> isl x\n 7. 0 \\<le> real q / real (card prf_domain)\n 8. \\<I>_full \\<turnstile>g \\<A> \\<surd>", "show \"\\<lbrakk> (y, s') \\<in> set_spmf (?oracle s x); ?I s; \\<not> isl x \\<rbrakk> \\<Longrightarrow> ?count s' \\<le> ?count s\" for s x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, s')\n             \\<in> set_spmf\n                    ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                      oracle_decrypt2 k)\n                      s x);\n     case s of\n     (bad, D) \\<Rightarrow>\n       finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n     \\<not> isl x\\<rbrakk>\n    \\<Longrightarrow> (case s' of (bad, D) \\<Rightarrow> card (dom D))\n                      \\<le> (case s of (bad, D) \\<Rightarrow> card (dom D))", "by(cases x)(simp_all add: oracle_decrypt2_def)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y5, ?s'5)\n           \\<in> set_spmf\n                  ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k)\n                    ?s5 ?x5);\n   case ?s5 of\n   (bad, D) \\<Rightarrow>\n     finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n   \\<not> isl ?x5\\<rbrakk>\n  \\<Longrightarrow> (case ?s'5 of (bad, D) \\<Rightarrow> card (dom D))\n                    \\<le> (case ?s5 of (bad, D) \\<Rightarrow> card (dom D))\n\ngoal (7 subgoals):\n 1. interaction_bounded_by' isl \\<A> q\n 2. case (False, Map.empty) of\n    (bad, D) \\<Rightarrow>\n      finite (dom D) \\<and> dom D \\<subseteq> prf_domain\n 3. \\<not> fst (False, Map.empty)\n 4. \\<And>s' x.\n       \\<lbrakk>case s' of\n                (bad, D) \\<Rightarrow>\n                  finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> fst s';\n        (case s' of (bad, D) \\<Rightarrow> card (dom D))\n        < q +\n          (case (False, Map.empty) of (bad, D) \\<Rightarrow> card (dom D));\n        isl x; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf (fst \\<circ> snd)\n                            ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                              oracle_decrypt2 k)\n                              s' x))\n                          True\n                         \\<le> real q / real (card prf_domain)\n 5. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> fst s; fst s'; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> isl x\n 6. 0 \\<le> real q / real (card prf_domain)\n 7. \\<I>_full \\<turnstile>g \\<A> \\<surd>", "show \"spmf (map_spmf (fst \\<circ> snd) (?oracle s' x)) True \\<le> q / card prf_domain\"\n      if I: \"?I s'\" and bad: \"\\<not> fst s'\" and count: \"?count s' < q + ?count (False, Map.empty)\" \n      and x: \"isl x\"\n      for s' x"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "obtain bad D where s' [simp]: \"s' = (bad, D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bad D. s' = (bad, D) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s')"], ["proof (state)\nthis:\n  s' = (bad, D)\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "from x"], ["proof (chain)\npicking this:\n  isl x", "obtain m1 m0 where x [simp]: \"x = Inl (m1, m0)\""], ["proof (prove)\nusing this:\n  isl x\n\ngoal (1 subgoal):\n 1. (\\<And>m1 m0.\n        x = Inl (m1, m0) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim: islE)"], ["proof (state)\nthis:\n  x = Inl (m1, m0)\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "have *: \"(case D x of None \\<Rightarrow> False | Some x \\<Rightarrow> True) \\<longleftrightarrow> x \\<in> dom D\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case D x of None \\<Rightarrow> False | Some x \\<Rightarrow> True) =\n    (x \\<in> dom D)", "by(auto split: option.split)"], ["proof (state)\nthis:\n  (case D ?x5 of None \\<Rightarrow> False | Some x \\<Rightarrow> True) =\n  (?x5 \\<in> dom D)\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "proof(cases \"length m1 = prf_clen \\<and> length m0 = prf_clen\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length m1 = prf_clen \\<and> length m0 = prf_clen \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)\n 2. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "case True"], ["proof (state)\nthis:\n  length m1 = prf_clen \\<and> length m0 = prf_clen\n\ngoal (2 subgoals):\n 1. length m1 = prf_clen \\<and> length m0 = prf_clen \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)\n 2. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "with bad"], ["proof (chain)\npicking this:\n  \\<not> fst s'\n  length m1 = prf_clen \\<and> length m0 = prf_clen", "have \"spmf (map_spmf (fst \\<circ> snd) (?oracle s' x)) True = pmf (bernoulli_pmf (card (dom D \\<inter> prf_domain) / card prf_domain)) True\""], ["proof (prove)\nusing this:\n  \\<not> fst s'\n  length m1 = prf_clen \\<and> length m0 = prf_clen\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True =\n    pmf (bernoulli_pmf\n          (real (card (dom D \\<inter> prf_domain)) /\n           real (card prf_domain)))\n     True", "by(simp add: spmf.map_comp o_def oracle_encrypt3_def k * bool.case_distrib[where h=\"\\<lambda>p. spmf (map_spmf _ p) _\"] option.case_distrib[where h=snd] map_spmf_bind_spmf Let_def split_beta bind_spmf_const cong: bool.case_cong option.case_cong split del: if_split split: bool.split)\n            (simp add: map_spmf_conv_bind_spmf[symmetric] map_mem_spmf_of_set prf_domain_finite prf_domain_nonempty)"], ["proof (state)\nthis:\n  spmf\n   (map_spmf (fst \\<circ> snd)\n     ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n   True =\n  pmf (bernoulli_pmf\n        (real (card (dom D \\<inter> prf_domain)) / real (card prf_domain)))\n   True\n\ngoal (2 subgoals):\n 1. length m1 = prf_clen \\<and> length m0 = prf_clen \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)\n 2. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "also"], ["proof (state)\nthis:\n  spmf\n   (map_spmf (fst \\<circ> snd)\n     ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n   True =\n  pmf (bernoulli_pmf\n        (real (card (dom D \\<inter> prf_domain)) / real (card prf_domain)))\n   True\n\ngoal (2 subgoals):\n 1. length m1 = prf_clen \\<and> length m0 = prf_clen \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)\n 2. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "have \"\\<dots> = card (dom D \\<inter> prf_domain) / card prf_domain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (bernoulli_pmf\n          (real (card (dom D \\<inter> prf_domain)) /\n           real (card prf_domain)))\n     True =\n    real (card (dom D \\<inter> prf_domain)) / real (card prf_domain)", "by(rule pmf_bernoulli_True)(auto simp add: field_simps prf_domain_finite prf_domain_nonempty card_gt_0_iff card_mono)"], ["proof (state)\nthis:\n  pmf (bernoulli_pmf\n        (real (card (dom D \\<inter> prf_domain)) / real (card prf_domain)))\n   True =\n  real (card (dom D \\<inter> prf_domain)) / real (card prf_domain)\n\ngoal (2 subgoals):\n 1. length m1 = prf_clen \\<and> length m0 = prf_clen \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)\n 2. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "also"], ["proof (state)\nthis:\n  pmf (bernoulli_pmf\n        (real (card (dom D \\<inter> prf_domain)) / real (card prf_domain)))\n   True =\n  real (card (dom D \\<inter> prf_domain)) / real (card prf_domain)\n\ngoal (2 subgoals):\n 1. length m1 = prf_clen \\<and> length m0 = prf_clen \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)\n 2. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "have \"dom D \\<inter> prf_domain = dom D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom D \\<inter> prf_domain = dom D", "using I"], ["proof (prove)\nusing this:\n  case s' of\n  (bad, D) \\<Rightarrow> finite (dom D) \\<and> dom D \\<subseteq> prf_domain\n\ngoal (1 subgoal):\n 1. dom D \\<inter> prf_domain = dom D", "by auto"], ["proof (state)\nthis:\n  dom D \\<inter> prf_domain = dom D\n\ngoal (2 subgoals):\n 1. length m1 = prf_clen \\<and> length m0 = prf_clen \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)\n 2. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "also"], ["proof (state)\nthis:\n  dom D \\<inter> prf_domain = dom D\n\ngoal (2 subgoals):\n 1. length m1 = prf_clen \\<and> length m0 = prf_clen \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)\n 2. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "have \"card (dom D) \\<le> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom D) \\<le> q", "using count"], ["proof (prove)\nusing this:\n  (case s' of (bad, D) \\<Rightarrow> card (dom D))\n  < q + (case (False, Map.empty) of (bad, D) \\<Rightarrow> card (dom D))\n\ngoal (1 subgoal):\n 1. card (dom D) \\<le> q", "by simp"], ["proof (state)\nthis:\n  card (dom D) \\<le> q\n\ngoal (2 subgoals):\n 1. length m1 = prf_clen \\<and> length m0 = prf_clen \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)\n 2. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      real x / real (card prf_domain)\n      \\<le> real y / real (card prf_domain)) \\<Longrightarrow>\n  spmf\n   (map_spmf (fst \\<circ> snd)\n     ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n   True\n  \\<le> real q / real (card prf_domain)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      real x / real (card prf_domain)\n      \\<le> real y / real (card prf_domain)) \\<Longrightarrow>\n  spmf\n   (map_spmf (fst \\<circ> snd)\n     ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n   True\n  \\<le> real q / real (card prf_domain)\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "by(simp add: divide_right_mono o_def)"], ["proof (state)\nthis:\n  spmf\n   (map_spmf (fst \\<circ> snd)\n     ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n   True\n  \\<le> real q / real (card prf_domain)\n\ngoal (1 subgoal):\n 1. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "case False"], ["proof (state)\nthis:\n  \\<not> (length m1 = prf_clen \\<and> length m0 = prf_clen)\n\ngoal (1 subgoal):\n 1. \\<not> (length m1 = prf_clen \\<and>\n            length m0 = prf_clen) \\<Longrightarrow>\n    spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (length m1 = prf_clen \\<and> length m0 = prf_clen)\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "using bad"], ["proof (prove)\nusing this:\n  \\<not> (length m1 = prf_clen \\<and> length m0 = prf_clen)\n  \\<not> fst s'\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (fst \\<circ> snd)\n       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n     True\n    \\<le> real q / real (card prf_domain)", "by(auto simp add: spmf.map_comp o_def oracle_encrypt3_def k split: bool.split)"], ["proof (state)\nthis:\n  spmf\n   (map_spmf (fst \\<circ> snd)\n     ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n   True\n  \\<le> real q / real (card prf_domain)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spmf\n   (map_spmf (fst \\<circ> snd)\n     ((oracle_encrypt3 k b \\<oplus>\\<^sub>O oracle_decrypt2 k) s' x))\n   True\n  \\<le> real q / real (card prf_domain)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>case ?s'5 of\n           (bad, D) \\<Rightarrow>\n             finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n   \\<not> fst ?s'5;\n   (case ?s'5 of (bad, D) \\<Rightarrow> card (dom D))\n   < q + (case (False, Map.empty) of (bad, D) \\<Rightarrow> card (dom D));\n   isl ?x5\\<rbrakk>\n  \\<Longrightarrow> spmf\n                     (map_spmf (fst \\<circ> snd)\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         ?s'5 ?x5))\n                     True\n                    \\<le> real q / real (card prf_domain)\n\ngoal (6 subgoals):\n 1. interaction_bounded_by' isl \\<A> q\n 2. case (False, Map.empty) of\n    (bad, D) \\<Rightarrow>\n      finite (dom D) \\<and> dom D \\<subseteq> prf_domain\n 3. \\<not> fst (False, Map.empty)\n 4. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((oracle_encrypt3 k b \\<oplus>\\<^sub>O\n                         oracle_decrypt2 k)\n                         s x);\n        case s of\n        (bad, D) \\<Rightarrow>\n          finite (dom D) \\<and> dom D \\<subseteq> prf_domain;\n        \\<not> fst s; fst s'; x \\<in> outs_\\<I> \\<I>_full\\<rbrakk>\n       \\<Longrightarrow> isl x\n 5. 0 \\<le> real q / real (card prf_domain)\n 6. \\<I>_full \\<turnstile>g \\<A> \\<surd>", "qed(auto split: plus_oracle_split_asm simp add: oracle_decrypt2_def assms)"], ["proof (state)\nthis:\n  ?k2 \\<in> set_spmf key_gen \\<Longrightarrow>\n  spmf\n   (map_spmf (fst \\<circ> snd)\n     (exec_gpv\n       (oracle_encrypt3 ?k2 ?b2 \\<oplus>\\<^sub>O oracle_decrypt2 ?k2) \\<A>\n       (False, Map.empty)))\n   True\n  \\<le> real q / real (card prf_domain) * real q\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n    \\<le> real q / real (card prf_domain) * real q", "then"], ["proof (chain)\npicking this:\n  ?k2 \\<in> set_spmf key_gen \\<Longrightarrow>\n  spmf\n   (map_spmf (fst \\<circ> snd)\n     (exec_gpv\n       (oracle_encrypt3 ?k2 ?b2 \\<oplus>\\<^sub>O oracle_decrypt2 ?k2) \\<A>\n       (False, Map.empty)))\n   True\n  \\<le> real q / real (card prf_domain) * real q", "have \"spmf (map_spmf snd (game3 \\<A>)) True \\<le> q / card prf_domain * q\""], ["proof (prove)\nusing this:\n  ?k2 \\<in> set_spmf key_gen \\<Longrightarrow>\n  spmf\n   (map_spmf (fst \\<circ> snd)\n     (exec_gpv\n       (oracle_encrypt3 ?k2 ?b2 \\<oplus>\\<^sub>O oracle_decrypt2 ?k2) \\<A>\n       (False, Map.empty)))\n   True\n  \\<le> real q / real (card prf_domain) * real q\n\ngoal (1 subgoal):\n 1. spmf (map_spmf snd (game3 \\<A>)) True\n    \\<le> real q / real (card prf_domain) * real q", "by(auto 4 3 simp add: game3_def map_spmf_bind_spmf o_def split_def map_spmf_conv_bind_spmf intro: spmf_bind_leI)"], ["proof (state)\nthis:\n  spmf (map_spmf snd (game3 \\<A>)) True\n  \\<le> real q / real (card prf_domain) * real q\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n    \\<le> real q / real (card prf_domain) * real q", "finally"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n  \\<le> real q / real (card prf_domain) * real q", "show ?thesis"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n  \\<le> real q / real (card prf_domain) * real q\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n    \\<le> real q / real (card prf_domain) * real q", "."], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n  \\<le> real q / real (card prf_domain) * real q\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem security:\n  assumes lossless: \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\"\n  and bound: \"interaction_bounded_by isl \\<A> q\"\n  shows \"ind_cca.advantage \\<A> \\<le> \n    PRF.advantage (reduction_prf \\<A>) + UPF.advantage (reduction_upf \\<A>) +\n    real q / real (card prf_domain) * real q\" (is \"?LHS \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "have \"?LHS \\<le> \\<bar>spmf (ind_cca.game \\<A>) True - spmf (ind_cca'.game \\<A>) True\\<bar> + \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>\"\n    (is \"_ \\<le> ?round1 + ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> \\<bar>spmf (local.ind_cca.game \\<A>) True -\n                spmf (ind_cca'.game \\<A>) True\\<bar> +\n          \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>", "using abs_triangle_ineq"], ["proof (prove)\nusing this:\n  \\<bar>?a + ?b\\<bar> \\<le> \\<bar>?a\\<bar> + \\<bar>?b\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> \\<bar>spmf (local.ind_cca.game \\<A>) True -\n                spmf (ind_cca'.game \\<A>) True\\<bar> +\n          \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>", "by(simp add: ind_cca.advantage_def)"], ["proof (state)\nthis:\n  local.ind_cca.advantage \\<A>\n  \\<le> \\<bar>spmf (local.ind_cca.game \\<A>) True -\n              spmf (ind_cca'.game \\<A>) True\\<bar> +\n        \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "also"], ["proof (state)\nthis:\n  local.ind_cca.advantage \\<A>\n  \\<le> \\<bar>spmf (local.ind_cca.game \\<A>) True -\n              spmf (ind_cca'.game \\<A>) True\\<bar> +\n        \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "have \"?round1 \\<le> UPF.advantage (reduction_upf \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "using lossless"], ["proof (prove)\nusing this:\n  lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.ind_cca.game \\<A>) True -\n          spmf (ind_cca'.game \\<A>) True\\<bar>\n    \\<le> UPF.advantage (reduction_upf \\<A>)", "by(rule round_1)"], ["proof (state)\nthis:\n  \\<bar>spmf (local.ind_cca.game \\<A>) True -\n        spmf (ind_cca'.game \\<A>) True\\<bar>\n  \\<le> UPF.advantage (reduction_upf \\<A>)\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "also"], ["proof (state)\nthis:\n  \\<bar>spmf (local.ind_cca.game \\<A>) True -\n        spmf (ind_cca'.game \\<A>) True\\<bar>\n  \\<le> UPF.advantage (reduction_upf \\<A>)\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "have \"?rest \\<le> \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> + \\<bar>spmf (game2 \\<A>) True - 1 / 2\\<bar>\"\n    (is \"_ \\<le> ?round2 + ?rest\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>\n    \\<le> \\<bar>spmf (ind_cca'.game \\<A>) True -\n                spmf (game2 \\<A>) True\\<bar> +\n          \\<bar>spmf (game2 \\<A>) True - 1 / 2\\<bar>", "using abs_triangle_ineq"], ["proof (prove)\nusing this:\n  \\<bar>?a + ?b\\<bar> \\<le> \\<bar>?a\\<bar> + \\<bar>?b\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>\n    \\<le> \\<bar>spmf (ind_cca'.game \\<A>) True -\n                spmf (game2 \\<A>) True\\<bar> +\n          \\<bar>spmf (game2 \\<A>) True - 1 / 2\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>\n  \\<le> \\<bar>spmf (ind_cca'.game \\<A>) True -\n              spmf (game2 \\<A>) True\\<bar> +\n        \\<bar>spmf (game2 \\<A>) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "also"], ["proof (state)\nthis:\n  \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>\n  \\<le> \\<bar>spmf (ind_cca'.game \\<A>) True -\n              spmf (game2 \\<A>) True\\<bar> +\n        \\<bar>spmf (game2 \\<A>) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "have \"?round2 = PRF.advantage (reduction_prf \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n    PRF.advantage (reduction_prf \\<A>)", "by(rule round_2)"], ["proof (state)\nthis:\n  \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n  PRF.advantage (reduction_prf \\<A>)\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "also"], ["proof (state)\nthis:\n  \\<bar>spmf (ind_cca'.game \\<A>) True - spmf (game2 \\<A>) True\\<bar> =\n  PRF.advantage (reduction_prf \\<A>)\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "have \"?rest \\<le> \\<bar>measure (measure_spmf (game3 \\<A>)) {(b, bad). b} - spmf (game2 \\<A>) True\\<bar> +\n       \\<bar>measure (measure_spmf (game3 \\<A>)) {(b, bad). b} - 1 / 2\\<bar>\" \n    (is \"_ \\<le> ?round3 + _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (game2 \\<A>) True - 1 / 2\\<bar>\n    \\<le> \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n                 {(b, bad). b} -\n                spmf (game2 \\<A>) True\\<bar> +\n          \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n                 {(b, bad). b} -\n                1 / 2\\<bar>", "using abs_triangle_ineq"], ["proof (prove)\nusing this:\n  \\<bar>?a + ?b\\<bar> \\<le> \\<bar>?a\\<bar> + \\<bar>?b\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (game2 \\<A>) True - 1 / 2\\<bar>\n    \\<le> \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n                 {(b, bad). b} -\n                spmf (game2 \\<A>) True\\<bar> +\n          \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n                 {(b, bad). b} -\n                1 / 2\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>spmf (game2 \\<A>) True - 1 / 2\\<bar>\n  \\<le> \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n               {(b, bad). b} -\n              spmf (game2 \\<A>) True\\<bar> +\n        \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n               {(b, bad). b} -\n              1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "also"], ["proof (state)\nthis:\n  \\<bar>spmf (game2 \\<A>) True - 1 / 2\\<bar>\n  \\<le> \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n               {(b, bad). b} -\n              spmf (game2 \\<A>) True\\<bar> +\n        \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n               {(b, bad). b} -\n              1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "have \"?round3 \\<le> measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "using round_3[OF lossless]"], ["proof (prove)\nusing this:\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n        spmf (game2 \\<A>) True\\<bar>\n  \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n\ngoal (1 subgoal):\n 1. \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n          spmf (game2 \\<A>) True\\<bar>\n    \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}", "."], ["proof (state)\nthis:\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n        spmf (game2 \\<A>) True\\<bar>\n  \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "also"], ["proof (state)\nthis:\n  \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} -\n        spmf (game2 \\<A>) True\\<bar>\n  \\<le> Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "have \"\\<dots> \\<le> q / card prf_domain * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n    \\<le> real q / real (card prf_domain) * real q", "using bound"], ["proof (prove)\nusing this:\n  interaction_bounded_by' isl \\<A> q\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n    \\<le> real q / real (card prf_domain) * real q", "by(rule game3_bad)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n  \\<le> real q / real (card prf_domain) * real q\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). bad}\n  \\<le> real q / real (card prf_domain) * real q\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "have \"measure (measure_spmf (game3 \\<A>)) {(b, bad). b} = spmf coin_spmf True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} =\n    spmf coin_spmf True", "using round_4[OF lossless, symmetric]"], ["proof (prove)\nusing this:\n  coin_spmf = map_spmf fst (game3 \\<A>)\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} =\n    spmf coin_spmf True", "by(simp add: spmf_conv_measure_spmf measure_map_spmf vimage_def fst_def)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} =\n  spmf coin_spmf True\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (game3 \\<A>)) {(b, bad). b} =\n  spmf coin_spmf True\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "have \"\\<bar>\\<dots> - 1 / 2\\<bar> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf coin_spmf True - 1 / 2\\<bar> = 0", "by(simp add: spmf_of_set)"], ["proof (state)\nthis:\n  \\<bar>spmf coin_spmf True - 1 / 2\\<bar> = 0\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>\n              \\<le> y + \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      UPF.advantage (reduction_upf \\<A>) + x\n      \\<le> UPF.advantage (reduction_upf \\<A>) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      UPF.advantage (reduction_upf \\<A>) +\n      (PRF.advantage (reduction_prf \\<A>) + x)\n      \\<le> UPF.advantage (reduction_upf \\<A>) +\n            (PRF.advantage (reduction_prf \\<A>) + y);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      UPF.advantage (reduction_upf \\<A>) +\n      (PRF.advantage (reduction_prf \\<A>) +\n       (x +\n        \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n               {a. case a of (b, bad) \\<Rightarrow> b} -\n              1 / 2\\<bar>))\n      \\<le> UPF.advantage (reduction_upf \\<A>) +\n            (PRF.advantage (reduction_prf \\<A>) +\n             (y +\n              \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n                     {a. case a of (b, bad) \\<Rightarrow> b} -\n                    1 / 2\\<bar>));\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      UPF.advantage (reduction_upf \\<A>) +\n      (PRF.advantage (reduction_prf \\<A>) +\n       (x +\n        \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n               {a. case a of (b, bad) \\<Rightarrow> b} -\n              1 / 2\\<bar>))\n      \\<le> UPF.advantage (reduction_upf \\<A>) +\n            (PRF.advantage (reduction_prf \\<A>) +\n             (y +\n              \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n                     {a. case a of (b, bad) \\<Rightarrow> b} -\n                    1 / 2\\<bar>))\\<rbrakk>\n  \\<Longrightarrow> local.ind_cca.advantage \\<A>\n                    \\<le> UPF.advantage (reduction_upf \\<A>) +\n                          (PRF.advantage (reduction_prf \\<A>) +\n                           (real q / real (card prf_domain) * real q + 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>\n              \\<le> y + \\<bar>spmf (ind_cca'.game \\<A>) True - 1 / 2\\<bar>;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      UPF.advantage (reduction_upf \\<A>) + x\n      \\<le> UPF.advantage (reduction_upf \\<A>) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      UPF.advantage (reduction_upf \\<A>) +\n      (PRF.advantage (reduction_prf \\<A>) + x)\n      \\<le> UPF.advantage (reduction_upf \\<A>) +\n            (PRF.advantage (reduction_prf \\<A>) + y);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      UPF.advantage (reduction_upf \\<A>) +\n      (PRF.advantage (reduction_prf \\<A>) +\n       (x +\n        \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n               {a. case a of (b, bad) \\<Rightarrow> b} -\n              1 / 2\\<bar>))\n      \\<le> UPF.advantage (reduction_upf \\<A>) +\n            (PRF.advantage (reduction_prf \\<A>) +\n             (y +\n              \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n                     {a. case a of (b, bad) \\<Rightarrow> b} -\n                    1 / 2\\<bar>));\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      UPF.advantage (reduction_upf \\<A>) +\n      (PRF.advantage (reduction_prf \\<A>) +\n       (x +\n        \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n               {a. case a of (b, bad) \\<Rightarrow> b} -\n              1 / 2\\<bar>))\n      \\<le> UPF.advantage (reduction_upf \\<A>) +\n            (PRF.advantage (reduction_prf \\<A>) +\n             (y +\n              \\<bar>Sigma_Algebra.measure (measure_spmf (game3 \\<A>))\n                     {a. case a of (b, bad) \\<Rightarrow> b} -\n                    1 / 2\\<bar>))\\<rbrakk>\n  \\<Longrightarrow> local.ind_cca.advantage \\<A>\n                    \\<le> UPF.advantage (reduction_upf \\<A>) +\n                          (PRF.advantage (reduction_prf \\<A>) +\n                           (real q / real (card prf_domain) * real q + 0))\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "by(simp)"], ["proof (state)\nthis:\n  local.ind_cca.advantage \\<A>\n  \\<le> PRF.advantage (reduction_prf \\<A>) +\n        UPF.advantage (reduction_upf \\<A>) +\n        real q / real (card prf_domain) * real q\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem security1:\n  assumes lossless: \"lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\"\n  assumes q: \"interaction_bounded_by isl \\<A> q\"\n  and q': \"interaction_bounded_by (Not \\<circ> isl) \\<A> q'\"\n  shows \"ind_cca.advantage \\<A> \\<le> \n    PRF.advantage (reduction_prf \\<A>) +\n    UPF.advantage1 (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>) ()) * q' +\n    real q * real q / real (card prf_domain)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage1\n           (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n             ()) *\n          real q' +\n          real q * real q / real (card prf_domain)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage1\n           (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n             ()) *\n          real q' +\n          real q * real q / real (card prf_domain)", "have \"ind_cca.advantage \\<A> \\<le> \n    PRF.advantage (reduction_prf \\<A>) + UPF.advantage (reduction_upf \\<A>) +\n    real q / real (card prf_domain) * real q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "using lossless q"], ["proof (prove)\nusing this:\n  lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<A>\n  interaction_bounded_by' isl \\<A> q\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage (reduction_upf \\<A>) +\n          real q / real (card prf_domain) * real q", "by(rule security)"], ["proof (state)\nthis:\n  local.ind_cca.advantage \\<A>\n  \\<le> PRF.advantage (reduction_prf \\<A>) +\n        UPF.advantage (reduction_upf \\<A>) +\n        real q / real (card prf_domain) * real q\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage1\n           (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n             ()) *\n          real q' +\n          real q * real q / real (card prf_domain)", "also"], ["proof (state)\nthis:\n  local.ind_cca.advantage \\<A>\n  \\<le> PRF.advantage (reduction_prf \\<A>) +\n        UPF.advantage (reduction_upf \\<A>) +\n        real q / real (card prf_domain) * real q\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage1\n           (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n             ()) *\n          real q' +\n          real q * real q / real (card prf_domain)", "note q'[interaction_bound]"], ["proof (state)\nthis:\n  interaction_bounded_by' (Not \\<circ> isl) \\<A> q'\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage1\n           (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n             ()) *\n          real q' +\n          real q * real q / real (card prf_domain)", "have \"interaction_bounded_by (Not \\<circ> isl) (reduction_upf \\<A>) q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by' (Not \\<circ> isl) (reduction_upf \\<A>) q'", "unfolding reduction_upf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by' (Not \\<circ> isl)\n     (lift_spmf prf_key_gen \\<bind>\n      (\\<lambda>k.\n          lift_spmf coin_spmf \\<bind>\n          (\\<lambda>b.\n              inline (intercept_upf k b) \\<A> ({}, {}) \\<bind>\n              (\\<lambda>(uu_, L, D).\n                  Generative_Probabilistic_Value.Done ()))))\n     q'", "by(interaction_bound)(simp_all add: SUP_le_iff)"], ["proof (state)\nthis:\n  interaction_bounded_by' (Not \\<circ> isl) (reduction_upf \\<A>) q'\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage1\n           (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n             ()) *\n          real q' +\n          real q * real q / real (card prf_domain)", "then"], ["proof (chain)\npicking this:\n  interaction_bounded_by' (Not \\<circ> isl) (reduction_upf \\<A>) q'", "have \"UPF.advantage (reduction_upf \\<A>) \\<le> UPF.advantage1 (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>) ()) * q'\""], ["proof (prove)\nusing this:\n  interaction_bounded_by' (Not \\<circ> isl) (reduction_upf \\<A>) q'\n\ngoal (1 subgoal):\n 1. UPF.advantage (reduction_upf \\<A>)\n    \\<le> UPF.advantage1\n           (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n             ()) *\n          real q'", "by(rule UPF.advantage_advantage1)"], ["proof (state)\nthis:\n  UPF.advantage (reduction_upf \\<A>)\n  \\<le> UPF.advantage1\n         (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n           ()) *\n        real q'\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage1\n           (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n             ()) *\n          real q' +\n          real q * real q / real (card prf_domain)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      PRF.advantage (reduction_prf \\<A>) + x +\n      real q / real (card prf_domain) * real q\n      \\<le> PRF.advantage (reduction_prf \\<A>) + y +\n            real q / real (card prf_domain) * real q) \\<Longrightarrow>\n  local.ind_cca.advantage \\<A>\n  \\<le> PRF.advantage (reduction_prf \\<A>) +\n        UPF.advantage1\n         (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n           ()) *\n        real q' +\n        real q / real (card prf_domain) * real q", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      PRF.advantage (reduction_prf \\<A>) + x +\n      real q / real (card prf_domain) * real q\n      \\<le> PRF.advantage (reduction_prf \\<A>) + y +\n            real q / real (card prf_domain) * real q) \\<Longrightarrow>\n  local.ind_cca.advantage \\<A>\n  \\<le> PRF.advantage (reduction_prf \\<A>) +\n        UPF.advantage1\n         (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n           ()) *\n        real q' +\n        real q / real (card prf_domain) * real q\n\ngoal (1 subgoal):\n 1. local.ind_cca.advantage \\<A>\n    \\<le> PRF.advantage (reduction_prf \\<A>) +\n          UPF.advantage1\n           (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n             ()) *\n          real q' +\n          real q * real q / real (card prf_domain)", "by(simp)"], ["proof (state)\nthis:\n  local.ind_cca.advantage \\<A>\n  \\<le> PRF.advantage (reduction_prf \\<A>) +\n        UPF.advantage1\n         (guessing_many_one.reduction q' (\\<lambda>_. reduction_upf \\<A>)\n           ()) *\n        real q' +\n        real q * real q / real (card prf_domain)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "locale simple_cipher' = \n  fixes prf_key_gen :: \"security \\<Rightarrow> 'prf_key spmf\"\n  and prf_fun :: \"security \\<Rightarrow> 'prf_key \\<Rightarrow> bitstring \\<Rightarrow> bitstring\"\n  and prf_domain :: \"security \\<Rightarrow> bitstring set\"\n  and prf_range :: \"security \\<Rightarrow> bitstring set\"\n  and prf_dlen :: \"security \\<Rightarrow> nat\"\n  and prf_clen :: \"security \\<Rightarrow> nat\"\n  and upf_key_gen :: \"security \\<Rightarrow> 'upf_key spmf\"\n  and upf_fun :: \"security \\<Rightarrow> 'upf_key \\<Rightarrow> bitstring \\<Rightarrow> 'hash\"\n  assumes simple_cipher: \"\\<And>\\<eta>. simple_cipher (prf_key_gen \\<eta>) (prf_fun \\<eta>) (prf_domain \\<eta>) (prf_dlen \\<eta>) (prf_clen \\<eta>) (upf_key_gen \\<eta>)\"\nbegin"], ["", "sublocale simple_cipher \n  \"prf_key_gen \\<eta>\" \"prf_fun \\<eta>\" \"prf_domain \\<eta>\" \"prf_range \\<eta>\" \"prf_dlen \\<eta>\" \"prf_clen \\<eta>\" \"upf_key_gen \\<eta>\" \"upf_fun \\<eta>\"\n  for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_cipher (prf_key_gen \\<eta>) (prf_fun \\<eta>) (prf_domain \\<eta>)\n     (prf_dlen \\<eta>) (prf_clen \\<eta>) (upf_key_gen \\<eta>)", "by(rule simple_cipher)"], ["", "theorem security_asymptotic:\n  fixes q q' :: \"security \\<Rightarrow> nat\"\n  assumes lossless: \"\\<And>\\<eta>. lossless_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) (\\<A> \\<eta>)\"\n  and bound: \"\\<And>\\<eta>. interaction_bounded_by isl (\\<A> \\<eta>) (q \\<eta>)\"\n  and bound': \"\\<And>\\<eta>. interaction_bounded_by (Not \\<circ> isl) (\\<A> \\<eta>) (q' \\<eta>)\"\n  and [negligible_intros]:\n    \"polynomial q'\" \"polynomial q\"\n    \"negligible (\\<lambda>\\<eta>. PRF.advantage \\<eta> (reduction_prf \\<eta> (\\<A> \\<eta>)))\"\n    \"negligible (\\<lambda>\\<eta>. UPF.advantage1 \\<eta> (guessing_many_one.reduction (q' \\<eta>) (\\<lambda>_. reduction_upf \\<eta> (\\<A> \\<eta>)) ()))\"\n    \"negligible (\\<lambda>\\<eta>. 1 / card (prf_domain \\<eta>))\"\n  shows \"negligible (\\<lambda>\\<eta>. ind_cca.advantage \\<eta> (\\<A> \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible\n     (\\<lambda>\\<eta>. local.ind_cca.advantage \\<eta> (\\<A> \\<eta>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. negligible\n     (\\<lambda>\\<eta>. local.ind_cca.advantage \\<eta> (\\<A> \\<eta>))", "have \"negligible (\\<lambda>\\<eta>. PRF.advantage \\<eta> (reduction_prf \\<eta> (\\<A> \\<eta>)) +\n    UPF.advantage1 \\<eta> (guessing_many_one.reduction (q' \\<eta>) (\\<lambda>_. reduction_upf \\<eta> (\\<A> \\<eta>)) ()) * q' \\<eta> +\n    real (q \\<eta>) / real (card (prf_domain \\<eta>)) * real (q \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible\n     (\\<lambda>\\<eta>.\n         PRF.advantage \\<eta> (reduction_prf \\<eta> (\\<A> \\<eta>)) +\n         UPF.advantage1 \\<eta>\n          (guessing_many_one.reduction (q' \\<eta>)\n            (\\<lambda>_. reduction_upf \\<eta> (\\<A> \\<eta>)) ()) *\n         real (q' \\<eta>) +\n         real (q \\<eta>) / real (card (prf_domain \\<eta>)) *\n         real (q \\<eta>))", "by(rule negligible_intros)+"], ["proof (state)\nthis:\n  negligible\n   (\\<lambda>\\<eta>.\n       PRF.advantage \\<eta> (reduction_prf \\<eta> (\\<A> \\<eta>)) +\n       UPF.advantage1 \\<eta>\n        (guessing_many_one.reduction (q' \\<eta>)\n          (\\<lambda>_. reduction_upf \\<eta> (\\<A> \\<eta>)) ()) *\n       real (q' \\<eta>) +\n       real (q \\<eta>) / real (card (prf_domain \\<eta>)) * real (q \\<eta>))\n\ngoal (1 subgoal):\n 1. negligible\n     (\\<lambda>\\<eta>. local.ind_cca.advantage \\<eta> (\\<A> \\<eta>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  negligible\n   (\\<lambda>\\<eta>.\n       PRF.advantage \\<eta> (reduction_prf \\<eta> (\\<A> \\<eta>)) +\n       UPF.advantage1 \\<eta>\n        (guessing_many_one.reduction (q' \\<eta>)\n          (\\<lambda>_. reduction_upf \\<eta> (\\<A> \\<eta>)) ()) *\n       real (q' \\<eta>) +\n       real (q \\<eta>) / real (card (prf_domain \\<eta>)) * real (q \\<eta>))\n\ngoal (1 subgoal):\n 1. negligible\n     (\\<lambda>\\<eta>. local.ind_cca.advantage \\<eta> (\\<A> \\<eta>))", "by(rule negligible_le)(simp add: security1[OF lossless bound bound'] ind_cca.advantage_nonneg)"], ["proof (state)\nthis:\n  negligible (\\<lambda>\\<eta>. local.ind_cca.advantage \\<eta> (\\<A> \\<eta>))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}