{"file_name": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto/IND_CCA2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto", "problem_names": ["lemma ekey_oracle_conv:\n  \"ekey_oracle \\<eta> \\<sigma> x =\n  (case \\<sigma> of None \\<Rightarrow> map_spmf (\\<lambda>(ekey, dkey). (ekey, Some (ekey, dkey, []))) (key_gen \\<eta>) \n   | Some (ekey, rest) \\<Rightarrow> return_spmf (ekey, Some (ekey, rest)))\"", "lemma oracle\\<^sub>1_simps [simp]:\n  \"oracle\\<^sub>1 b \\<eta> s (Inl x) = map_spmf (apfst Inl) (ekey_oracle \\<eta> s x)\"\n  \"oracle\\<^sub>1 b \\<eta> s (Inr (Inl y)) = map_spmf (apfst (Inr \\<circ> Inl)) (decrypt_oracle \\<eta> s y)\"\n  \"oracle\\<^sub>1 b \\<eta> s (Inr (Inr z)) = map_spmf (apfst (Inr \\<circ> Inr)) (encrypt_oracle b \\<eta> s z)\"", "lemma advantage\\<^sub>1_nonneg: \"advantage\\<^sub>1 \\<A> \\<eta> \\<ge> 0\"", "lemma lossless_decrypt_oracle [simp]: \"lossless_spmf (decrypt_oracle \\<eta> \\<sigma> cipher)\"", "lemma lossless_ekey_oracle [simp]:\n  \"lossless_spmf (ekey_oracle \\<eta> \\<sigma> x) \\<longleftrightarrow> (\\<sigma> = None \\<longrightarrow> lossless_spmf (key_gen \\<eta>))\"", "lemma lossless_encrypt_oracle [simp]:\n  \"\\<lbrakk> \\<sigma> = None \\<Longrightarrow> lossless_spmf (key_gen \\<eta>);\n    \\<And>ekey m. valid_plain \\<eta> m \\<Longrightarrow> lossless_spmf (encrypt \\<eta> ekey m) \\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (encrypt_oracle b \\<eta> \\<sigma> (m0, m1)) \\<longleftrightarrow> valid_plain \\<eta> m0 \\<and> valid_plain \\<eta> m1\"", "lemma oracle\\<^sub>n_apply [simp]:\n  \"oracle\\<^sub>n b \\<eta> s (i, x) = map_spmf (apsnd (fun_upd s i)) (oracle\\<^sub>1 b \\<eta> (s i) x)\"", "lemma advantage\\<^sub>n_nonneg: \"advantage\\<^sub>n \\<A> \\<eta> \\<ge> 0\"", "lemma cipher_queriesI:\n  \"\\<lbrakk> ose n = Some (ek, dk, ciphers); x \\<in> set ciphers \\<rbrakk> \\<Longrightarrow> x \\<in> cipher_queries ose\"", "lemma cipher_queriesE:\n  assumes \"x \\<in> cipher_queries ose\"\n  obtains (cipher_queries) n ek dk ciphers where \"ose n = Some (ek, dk, ciphers)\" \"x \\<in> set ciphers\"", "lemma cipher_queries_updE:\n  assumes \"x \\<in> cipher_queries (ose(n \\<mapsto> (ek, dk, ciphers)))\"\n  obtains (old) \"x \\<in> cipher_queries ose\" \"x \\<notin> set ciphers\" | (new) \"x \\<in> set ciphers\"", "lemma cipher_queries_empty [simp]: \"cipher_queries Map.empty = {}\""], "translations": [["", "lemma ekey_oracle_conv:\n  \"ekey_oracle \\<eta> \\<sigma> x =\n  (case \\<sigma> of None \\<Rightarrow> map_spmf (\\<lambda>(ekey, dkey). (ekey, Some (ekey, dkey, []))) (key_gen \\<eta>) \n   | Some (ekey, rest) \\<Rightarrow> return_spmf (ekey, Some (ekey, rest)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ekey_oracle \\<eta> \\<sigma> x =\n    (case \\<sigma> of\n     None \\<Rightarrow>\n       map_spmf (\\<lambda>(ekey, dkey). (ekey, Some (ekey, dkey, [])))\n        (key_gen \\<eta>)\n     | Some (ekey, rest) \\<Rightarrow>\n         return_spmf (ekey, Some (ekey, rest)))", "by(cases \\<sigma>)(auto simp add: map_spmf_conv_bind_spmf split_def)"], ["", "context notes bind_spmf_cong[fundef_cong] begin"], ["", "function encrypt_oracle\n  :: \"bool \\<Rightarrow> security \\<Rightarrow> ('ekey, 'dkey, 'cipher) state_oracle \\<Rightarrow> 'plain \\<times> 'plain\n  \\<Rightarrow> ('cipher \\<times> ('ekey, 'dkey, 'cipher) state_oracle) spmf\"\nwhere\n  \"encrypt_oracle b \\<eta> None m01 = do { (_, \\<sigma>) \\<leftarrow> ekey_oracle \\<eta> None (); encrypt_oracle b \\<eta> \\<sigma> m01 }\"\n| \"encrypt_oracle b \\<eta> (Some (ekey, dkey, cstars)) (m0, m1) =\n  (if valid_plain \\<eta> m0 \\<and> valid_plain \\<eta> m1 then do {  \n     let pb = (if b then m0 else m1);\n     cstar \\<leftarrow> encrypt \\<eta> ekey pb;\n     return_spmf (cstar, Some (ekey, dkey, cstar # cstars))\n   } else return_pmf None)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>b \\<eta> m01.\n                   x = (b, \\<eta>, None, m01) \\<Longrightarrow> P;\n        \\<And>b \\<eta> ekey dkey cstars m0 m1.\n           x =\n           (b, \\<eta>, Some (ekey, dkey, cstars), m0, m1) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>b \\<eta> m01 ba \\<eta>' m01a.\n       (b, \\<eta>, None, m01) = (ba, \\<eta>', None, m01a) \\<Longrightarrow>\n       ekey_oracle \\<eta> None () \\<bind>\n       (\\<lambda>(uu_, \\<sigma>).\n           encrypt_oracle_sumC (b, \\<eta>, \\<sigma>, m01)) =\n       ekey_oracle \\<eta>' None () \\<bind>\n       (\\<lambda>(uu_, \\<sigma>).\n           encrypt_oracle_sumC (ba, \\<eta>', \\<sigma>, m01a))\n 3. \\<And>b \\<eta> m01 ba \\<eta>' ekey dkey cstars m0 m1.\n       (b, \\<eta>, None, m01) =\n       (ba, \\<eta>', Some (ekey, dkey, cstars), m0, m1) \\<Longrightarrow>\n       ekey_oracle \\<eta> None () \\<bind>\n       (\\<lambda>(uu_, \\<sigma>).\n           encrypt_oracle_sumC (b, \\<eta>, \\<sigma>, m01)) =\n       (if valid_plain \\<eta>' m0 \\<and> valid_plain \\<eta>' m1\n        then let pb = if ba then m0 else m1\n             in encrypt \\<eta>' ekey pb \\<bind>\n                (\\<lambda>cstar.\n                    return_spmf (cstar, Some (ekey, dkey, cstar # cstars)))\n        else return_pmf None)\n 4. \\<And>b \\<eta> ekey dkey cstars m0 m1 ba \\<eta>' ekeya dkeya cstarsa m0a\n       m1a.\n       (b, \\<eta>, Some (ekey, dkey, cstars), m0, m1) =\n       (ba, \\<eta>', Some (ekeya, dkeya, cstarsa), m0a,\n        m1a) \\<Longrightarrow>\n       (if valid_plain \\<eta> m0 \\<and> valid_plain \\<eta> m1\n        then let pb = if b then m0 else m1\n             in encrypt \\<eta> ekey pb \\<bind>\n                (\\<lambda>cstar.\n                    return_spmf (cstar, Some (ekey, dkey, cstar # cstars)))\n        else return_pmf None) =\n       (if valid_plain \\<eta>' m0a \\<and> valid_plain \\<eta>' m1a\n        then let pb = if ba then m0a else m1a\n             in encrypt \\<eta>' ekeya pb \\<bind>\n                (\\<lambda>cstar.\n                    return_spmf\n                     (cstar, Some (ekeya, dkeya, cstar # cstarsa)))\n        else return_pmf None)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All encrypt_oracle_dom", "by(relation \"Wellfounded.measure (\\<lambda>(b, \\<eta>, \\<sigma>, m01). case \\<sigma> of None \\<Rightarrow> 1 | _ \\<Rightarrow> 0)\") auto"], ["", "end"], ["", "subsubsection \\<open>Single-user setting\\<close>"], ["", "type_synonym ('plain', 'cipher') call\\<^sub>1 = \"unit + 'cipher' + 'plain' \\<times> 'plain'\""], ["", "type_synonym ('ekey', 'plain', 'cipher') ret\\<^sub>1 = \"'ekey' + 'plain' option + 'cipher'\""], ["", "definition oracle\\<^sub>1 :: \"bool \\<Rightarrow> security \n  \\<Rightarrow> (('ekey, 'dkey, 'cipher) state_oracle, ('plain, 'cipher) call\\<^sub>1, ('ekey, 'plain, 'cipher) ret\\<^sub>1) oracle'\"\nwhere \"oracle\\<^sub>1 b \\<eta> = ekey_oracle \\<eta> \\<oplus>\\<^sub>O (decrypt_oracle \\<eta> \\<oplus>\\<^sub>O encrypt_oracle b \\<eta>)\""], ["", "lemma oracle\\<^sub>1_simps [simp]:\n  \"oracle\\<^sub>1 b \\<eta> s (Inl x) = map_spmf (apfst Inl) (ekey_oracle \\<eta> s x)\"\n  \"oracle\\<^sub>1 b \\<eta> s (Inr (Inl y)) = map_spmf (apfst (Inr \\<circ> Inl)) (decrypt_oracle \\<eta> s y)\"\n  \"oracle\\<^sub>1 b \\<eta> s (Inr (Inr z)) = map_spmf (apfst (Inr \\<circ> Inr)) (encrypt_oracle b \\<eta> s z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oracle\\<^sub>1 b \\<eta> s (Inl x) =\n    map_spmf (apfst Inl) (ekey_oracle \\<eta> s x) &&&\n    oracle\\<^sub>1 b \\<eta> s (Inr (Inl y)) =\n    map_spmf (apfst (Inr \\<circ> Inl)) (decrypt_oracle \\<eta> s y) &&&\n    oracle\\<^sub>1 b \\<eta> s (Inr (Inr z)) =\n    map_spmf (apfst (Inr \\<circ> Inr)) (encrypt_oracle b \\<eta> s z)", "by(simp_all add: oracle\\<^sub>1_def spmf.map_comp apfst_compose o_def)"], ["", "type_synonym ('ekey', 'plain', 'cipher') adversary\\<^sub>1' = \n  \"(bool, ('plain', 'cipher') call\\<^sub>1, ('ekey', 'plain', 'cipher') ret\\<^sub>1) gpv\""], ["", "type_synonym ('ekey', 'plain', 'cipher') adversary\\<^sub>1 =\n  \"security \\<Rightarrow> ('ekey', 'plain', 'cipher') adversary\\<^sub>1'\""], ["", "definition ind_cca2\\<^sub>1 :: \"('ekey, 'plain, 'cipher) adversary\\<^sub>1 \\<Rightarrow> security \\<Rightarrow> bool spmf\"\nwhere\n  \"ind_cca2\\<^sub>1 \\<A> \\<eta> = TRY do {\n    b \\<leftarrow> coin_spmf;\n    (guess, s) \\<leftarrow> exec_gpv (oracle\\<^sub>1 b \\<eta>) (\\<A> \\<eta>) None;\n    return_spmf (guess = b)\n  } ELSE coin_spmf\""], ["", "definition advantage\\<^sub>1 :: \"('ekey, 'plain, 'cipher) adversary\\<^sub>1 \\<Rightarrow> advantage\"\nwhere \"advantage\\<^sub>1 \\<A> \\<eta> = \\<bar>spmf (ind_cca2\\<^sub>1 \\<A> \\<eta>) True - 1/2\\<bar>\""], ["", "lemma advantage\\<^sub>1_nonneg: \"advantage\\<^sub>1 \\<A> \\<eta> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> advantage\\<^sub>1 \\<A> \\<eta>", "by(simp add: advantage\\<^sub>1_def)"], ["", "abbreviation secure_for\\<^sub>1 :: \"('ekey, 'plain, 'cipher) adversary\\<^sub>1 \\<Rightarrow> bool\"\nwhere \"secure_for\\<^sub>1 \\<A> \\<equiv> negligible (advantage\\<^sub>1 \\<A>)\""], ["", "definition ibounded_by\\<^sub>1' :: \"('ekey, 'plain, 'cipher) adversary\\<^sub>1' \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere \"ibounded_by\\<^sub>1' \\<A> q = interaction_any_bounded_by \\<A> q\""], ["", "abbreviation ibounded_by\\<^sub>1 :: \"('ekey, 'plain, 'cipher) adversary\\<^sub>1 \\<Rightarrow> (security \\<Rightarrow> nat) \\<Rightarrow> bool\"\nwhere \"ibounded_by\\<^sub>1 \\<equiv> rel_envir ibounded_by\\<^sub>1'\""], ["", "definition lossless\\<^sub>1' :: \"('ekey, 'plain, 'cipher) adversary\\<^sub>1' \\<Rightarrow> bool\"\nwhere \"lossless\\<^sub>1' \\<A> = lossless_gpv \\<I>_full \\<A>\""], ["", "abbreviation lossless\\<^sub>1 :: \"('ekey, 'plain, 'cipher) adversary\\<^sub>1 \\<Rightarrow> bool\"\nwhere \"lossless\\<^sub>1 \\<equiv> pred_envir lossless\\<^sub>1'\""], ["", "lemma lossless_decrypt_oracle [simp]: \"lossless_spmf (decrypt_oracle \\<eta> \\<sigma> cipher)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (decrypt_oracle \\<eta> \\<sigma> cipher)", "by(cases \"(\\<eta>, \\<sigma>, cipher)\" rule: decrypt_oracle.cases) simp_all"], ["", "lemma lossless_ekey_oracle [simp]:\n  \"lossless_spmf (ekey_oracle \\<eta> \\<sigma> x) \\<longleftrightarrow> (\\<sigma> = None \\<longrightarrow> lossless_spmf (key_gen \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (ekey_oracle \\<eta> \\<sigma> x) =\n    (\\<sigma> = None \\<longrightarrow> lossless_spmf (key_gen \\<eta>))", "by(cases \"(\\<eta>, \\<sigma>, x)\" rule: ekey_oracle.cases)(auto)"], ["", "lemma lossless_encrypt_oracle [simp]:\n  \"\\<lbrakk> \\<sigma> = None \\<Longrightarrow> lossless_spmf (key_gen \\<eta>);\n    \\<And>ekey m. valid_plain \\<eta> m \\<Longrightarrow> lossless_spmf (encrypt \\<eta> ekey m) \\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (encrypt_oracle b \\<eta> \\<sigma> (m0, m1)) \\<longleftrightarrow> valid_plain \\<eta> m0 \\<and> valid_plain \\<eta> m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<sigma> = None \\<Longrightarrow>\n             lossless_spmf (key_gen \\<eta>);\n     \\<And>ekey m.\n        valid_plain \\<eta> m \\<Longrightarrow>\n        lossless_spmf (encrypt \\<eta> ekey m)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (encrypt_oracle b \\<eta> \\<sigma> (m0, m1)) =\n                      (valid_plain \\<eta> m0 \\<and> valid_plain \\<eta> m1)", "apply(cases \"(b, \\<eta>, \\<sigma>, (m0, m1))\" rule: encrypt_oracle.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ba \\<eta>' m01.\n       \\<lbrakk>\\<sigma> = None \\<Longrightarrow>\n                lossless_spmf (key_gen \\<eta>);\n        \\<And>ekey m.\n           valid_plain \\<eta> m \\<Longrightarrow>\n           lossless_spmf (encrypt \\<eta> ekey m);\n        (b, \\<eta>, \\<sigma>, m0, m1) = (ba, \\<eta>', None, m01)\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf\n                          (encrypt_oracle b \\<eta> \\<sigma> (m0, m1)) =\n                         (valid_plain \\<eta> m0 \\<and>\n                          valid_plain \\<eta> m1)\n 2. \\<And>ba \\<eta>' ekey dkey cstars m0a m1a.\n       \\<lbrakk>\\<sigma> = None \\<Longrightarrow>\n                lossless_spmf (key_gen \\<eta>);\n        \\<And>ekey m.\n           valid_plain \\<eta> m \\<Longrightarrow>\n           lossless_spmf (encrypt \\<eta> ekey m);\n        (b, \\<eta>, \\<sigma>, m0, m1) =\n        (ba, \\<eta>', Some (ekey, dkey, cstars), m0a, m1a)\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf\n                          (encrypt_oracle b \\<eta> \\<sigma> (m0, m1)) =\n                         (valid_plain \\<eta> m0 \\<and>\n                          valid_plain \\<eta> m1)", "apply(auto simp add: split_beta dest: lossless_spmfD_set_spmf_nonempty split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Multi-user setting\\<close>"], ["", "definition oracle\\<^sub>n :: \"bool \\<Rightarrow> security\n   \\<Rightarrow> ('i \\<Rightarrow> ('ekey, 'dkey, 'cipher) state_oracle, 'i \\<times> ('plain, 'cipher) call\\<^sub>1, ('ekey, 'plain, 'cipher) ret\\<^sub>1) oracle'\"\nwhere \"oracle\\<^sub>n b \\<eta> = family_oracle (\\<lambda>_. oracle\\<^sub>1 b \\<eta>)\""], ["", "lemma oracle\\<^sub>n_apply [simp]:\n  \"oracle\\<^sub>n b \\<eta> s (i, x) = map_spmf (apsnd (fun_upd s i)) (oracle\\<^sub>1 b \\<eta> (s i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oracle\\<^sub>n b \\<eta> s (i, x) =\n    map_spmf (apsnd (fun_upd s i)) (oracle\\<^sub>1 b \\<eta> (s i) x)", "by(simp add: oracle\\<^sub>n_def)"], ["", "type_synonym ('i, 'ekey', 'plain', 'cipher') adversary\\<^sub>n' = \n  \"(bool, 'i \\<times> ('plain', 'cipher') call\\<^sub>1, ('ekey', 'plain', 'cipher') ret\\<^sub>1) gpv\""], ["", "type_synonym ('i, 'ekey', 'plain', 'cipher') adversary\\<^sub>n =\n  \"security \\<Rightarrow> ('i, 'ekey', 'plain', 'cipher') adversary\\<^sub>n'\""], ["", "definition ind_cca2\\<^sub>n :: \"('i, 'ekey, 'plain, 'cipher) adversary\\<^sub>n \\<Rightarrow> security \\<Rightarrow> bool spmf\"\nwhere\n  \"ind_cca2\\<^sub>n \\<A> \\<eta> = TRY do {\n    b \\<leftarrow> coin_spmf;\n    (guess, \\<sigma>) \\<leftarrow> exec_gpv (oracle\\<^sub>n b \\<eta>) (\\<A> \\<eta>) (\\<lambda>_. None);\n    return_spmf (guess = b)\n  } ELSE coin_spmf\""], ["", "definition advantage\\<^sub>n :: \"('i, 'ekey, 'plain, 'cipher) adversary\\<^sub>n \\<Rightarrow> advantage\"\nwhere \"advantage\\<^sub>n \\<A> \\<eta> = \\<bar>spmf (ind_cca2\\<^sub>n \\<A> \\<eta>) True - 1/2\\<bar>\""], ["", "lemma advantage\\<^sub>n_nonneg: \"advantage\\<^sub>n \\<A> \\<eta> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> advantage\\<^sub>n \\<A> \\<eta>", "by(simp add: advantage\\<^sub>n_def)"], ["", "abbreviation secure_for\\<^sub>n :: \"('i, 'ekey, 'plain, 'cipher) adversary\\<^sub>n \\<Rightarrow> bool\"\nwhere \"secure_for\\<^sub>n \\<A> \\<equiv> negligible (advantage\\<^sub>n \\<A>)\""], ["", "definition ibounded_by\\<^sub>n' :: \"('i, 'ekey, 'plain, 'cipher) adversary\\<^sub>n' \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere \"ibounded_by\\<^sub>n' \\<A> q = interaction_any_bounded_by \\<A> q\""], ["", "abbreviation ibounded_by\\<^sub>n :: \"('i, 'ekey, 'plain, 'cipher) adversary\\<^sub>n \\<Rightarrow> (security \\<Rightarrow> nat) \\<Rightarrow> bool\"\nwhere \"ibounded_by\\<^sub>n \\<equiv> rel_envir ibounded_by\\<^sub>n'\""], ["", "definition lossless\\<^sub>n' :: \"('i, 'ekey, 'plain, 'cipher) adversary\\<^sub>n' \\<Rightarrow> bool\"\nwhere \"lossless\\<^sub>n' \\<A> = lossless_gpv \\<I>_full \\<A>\""], ["", "abbreviation lossless\\<^sub>n :: \"('i, 'ekey, 'plain, 'cipher) adversary\\<^sub>n \\<Rightarrow> bool\"\nwhere \"lossless\\<^sub>n \\<equiv> pred_envir lossless\\<^sub>n'\""], ["", "definition cipher_queries :: \"('i \\<Rightarrow> ('ekey, 'dkey, 'cipher) state_oracle) \\<Rightarrow> 'cipher set\"\nwhere \"cipher_queries ose = (\\<Union>(_, _, ciphers)\\<in>ran ose. set ciphers)\""], ["", "lemma cipher_queriesI:\n  \"\\<lbrakk> ose n = Some (ek, dk, ciphers); x \\<in> set ciphers \\<rbrakk> \\<Longrightarrow> x \\<in> cipher_queries ose\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ose n = Some (ek, dk, ciphers); x \\<in> set ciphers\\<rbrakk>\n    \\<Longrightarrow> x \\<in> cipher_queries ose", "by(auto simp add: cipher_queries_def ran_def)"], ["", "lemma cipher_queriesE:\n  assumes \"x \\<in> cipher_queries ose\"\n  obtains (cipher_queries) n ek dk ciphers where \"ose n = Some (ek, dk, ciphers)\" \"x \\<in> set ciphers\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n ek dk ciphers.\n        \\<lbrakk>ose n = Some (ek, dk, ciphers);\n         x \\<in> set ciphers\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> cipher_queries ose\n\ngoal (1 subgoal):\n 1. (\\<And>n ek dk ciphers.\n        \\<lbrakk>ose n = Some (ek, dk, ciphers);\n         x \\<in> set ciphers\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: cipher_queries_def ran_def)"], ["", "lemma cipher_queries_updE:\n  assumes \"x \\<in> cipher_queries (ose(n \\<mapsto> (ek, dk, ciphers)))\"\n  obtains (old) \"x \\<in> cipher_queries ose\" \"x \\<notin> set ciphers\" | (new) \"x \\<in> set ciphers\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x \\<in> cipher_queries ose;\n              x \\<notin> set ciphers\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     x \\<in> set ciphers \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> cipher_queries (ose(n \\<mapsto> (ek, dk, ciphers)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x \\<in> cipher_queries ose;\n              x \\<notin> set ciphers\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     x \\<in> set ciphers \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases \"x \\<in> set ciphers\")(fastforce elim!: cipher_queriesE split: if_split_asm intro: cipher_queriesI)+"], ["", "lemma cipher_queries_empty [simp]: \"cipher_queries Map.empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cipher_queries Map.empty = {}", "by(simp add: cipher_queries_def)"], ["", "end"], ["", "end"]]}