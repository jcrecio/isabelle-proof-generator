{"file_name": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto/PRF_IND_CPA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto", "problem_names": ["lemma encrypt_decrypt_correct:\n  \"\\<lbrakk> length key = len; length plain = len \\<rbrakk>\n  \\<Longrightarrow> encrypt key plain \\<bind> (\\<lambda>cipher. return_spmf (decrypt key cipher)) = return_spmf (Some plain)\"", "lemma interaction_bounded_by_prf_encrypt_oracle [interaction_bound]:\n  \"interaction_any_bounded_by (prf_encrypt_oracle \\<sigma> plain) 1\"", "lemma lossless_prf_encyrpt_oracle [simp]: \"lossless_gpv \\<I>_top (prf_encrypt_oracle s x)\"", "theorem prf_encrypt_advantage:\n  assumes \"ind_cpa.ibounded_by \\<A> q\"\n  and \"lossless_gpv \\<I>_full (fst \\<A>)\"\n  and \"\\<And>cipher \\<sigma>. lossless_gpv \\<I>_full (snd \\<A> cipher \\<sigma>)\"\n  shows \"ind_cpa.advantage \\<A> \\<le> prf.advantage (prf_adversary \\<A>) + q / 2 ^ len\"", "lemma interaction_bounded_prf_adversary: \n  fixes q :: nat\n  assumes \"ind_cpa.ibounded_by \\<A> q\"\n  shows \"prf.ibounded_by (prf_adversary \\<A>) (1 + q)\"", "lemma lossless_prf_adversary: \"ind_cpa.lossless \\<A> \\<Longrightarrow> prf.lossless (prf_adversary \\<A>)\"", "lemma prf_encrypt_secure_for:\n  assumes [negligible_intros]: \"negligible (\\<lambda>\\<eta>. prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)))\"\n  and q: \"\\<And>\\<eta>. ind_cpa.ibounded_by (\\<A> \\<eta>) (q \\<eta>)\" and [negligible_intros]: \"polynomial q\"\n  and lossless: \"\\<And>\\<eta>. ind_cpa.lossless (\\<A> \\<eta>)\"\n  shows \"negligible (\\<lambda>\\<eta>. ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\""], "translations": [["", "lemma encrypt_decrypt_correct:\n  \"\\<lbrakk> length key = len; length plain = len \\<rbrakk>\n  \\<Longrightarrow> encrypt key plain \\<bind> (\\<lambda>cipher. return_spmf (decrypt key cipher)) = return_spmf (Some plain)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length key = len; length plain = len\\<rbrakk>\n    \\<Longrightarrow> encrypt key plain \\<bind>\n                      (\\<lambda>cipher. return_spmf (decrypt key cipher)) =\n                      return_spmf (Some plain)", "by(simp add: encrypt_def zip_map2 o_def split_def bind_eq_return_spmf length_f in_nlists_UNIV xor_list_left_commute)"], ["", "interpretation ind_cpa: ind_cpa key_gen encrypt decrypt valid_plain"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation \"prf\": \"prf\" key_gen f \"spmf_of_set (nlists UNIV len)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition prf_encrypt_oracle :: \"unit \\<Rightarrow> plain \\<Rightarrow> (cipher \\<times> unit, plain, plain) gpv\"\nwhere\n  \"prf_encrypt_oracle x plain = do {\n     r \\<leftarrow> lift_spmf (spmf_of_set (nlists UNIV len));\n     Pause r (\\<lambda>pad. Done ((r, xor_list plain pad), ()))\n  }\""], ["", "lemma interaction_bounded_by_prf_encrypt_oracle [interaction_bound]:\n  \"interaction_any_bounded_by (prf_encrypt_oracle \\<sigma> plain) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_by (prf_encrypt_oracle \\<sigma> plain) 1", "unfolding prf_encrypt_oracle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_by\n     (lift_spmf (spmf_of_set (nlists UNIV len)) \\<bind>\n      (\\<lambda>r.\n          Generative_Probabilistic_Value.Pause r\n           (\\<lambda>pad.\n               Generative_Probabilistic_Value.Done\n                ((r, plain [\\<oplus>] pad), ()))))\n     1", "by simp"], ["", "lemma lossless_prf_encyrpt_oracle [simp]: \"lossless_gpv \\<I>_top (prf_encrypt_oracle s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_gpv \\<I>_top (prf_encrypt_oracle s x)", "by(simp add: prf_encrypt_oracle_def)"], ["", "definition prf_adversary :: \"(plain, cipher, 'state) ind_cpa.adversary \\<Rightarrow> (plain, plain) prf.adversary\"\nwhere\n  \"prf_adversary \\<A> = do {\n     let (\\<A>1, \\<A>2) = \\<A>;\n     (((p1, p2), \\<sigma>), n) \\<leftarrow> inline prf_encrypt_oracle \\<A>1 ();\n     if valid_plain p1 \\<and> valid_plain p2 then do { \n       b \\<leftarrow> lift_spmf coin_spmf;\n       let pb = (if b then p1 else p2);\n       r \\<leftarrow> lift_spmf (spmf_of_set (nlists UNIV len));\n       pad \\<leftarrow> Pause r Done;\n       let c = (r, xor_list pb pad);\n       (b', _) \\<leftarrow> inline prf_encrypt_oracle (\\<A>2 c \\<sigma>) n;\n       Done (b' = b)\n     } else lift_spmf coin_spmf\n  }\""], ["", "theorem prf_encrypt_advantage:\n  assumes \"ind_cpa.ibounded_by \\<A> q\"\n  and \"lossless_gpv \\<I>_full (fst \\<A>)\"\n  and \"\\<And>cipher \\<sigma>. lossless_gpv \\<I>_full (snd \\<A> cipher \\<sigma>)\"\n  shows \"ind_cpa.advantage \\<A> \\<le> prf.advantage (prf_adversary \\<A>) + q / 2 ^ len\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "note [split del] = if_split\n    and [cong del] = if_weak_cong\n    and [simp] =\n      bind_spmf_const map_spmf_bind_spmf bind_map_spmf \n      exec_gpv_bind exec_gpv_inline\n      rel_spmf_bind_reflI rel_spmf_reflI"], ["proof (state)\nthis:\n  ?P (if ?Q then ?x else ?y) =\n  ((?Q \\<longrightarrow> ?P ?x) \\<and> (\\<not> ?Q \\<longrightarrow> ?P ?y))\n  ?b = ?c \\<Longrightarrow>\n  (if ?b then ?x else ?y) = (if ?c then ?x else ?y)\n  ?p \\<bind> (\\<lambda>x. ?q) = scale_spmf (weight_spmf ?p) ?q\n  map_spmf ?f (?p \\<bind> ?g) = ?p \\<bind> map_spmf ?f \\<circ> ?g\n  map_spmf ?f ?p \\<bind> ?g = ?p \\<bind> ?g \\<circ> ?f\n  exec_gpv ?callee (?c \\<bind> ?f) ?s =\n  exec_gpv ?callee ?c ?s \\<bind>\n  (\\<lambda>xa. case xa of (x, s') \\<Rightarrow> exec_gpv ?callee (?f x) s')\n  exec_gpv ?callee (inline ?gpv ?c' ?s') ?s =\n  map_spmf (\\<lambda>(x, s', s). ((x, s'), s))\n   (exec_gpv\n     (\\<lambda>(s', s) y.\n         map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n          (exec_gpv ?callee (?gpv s' y) s))\n     ?c' (?s', ?s))\n  (\\<And>x.\n      x \\<in> set_spmf ?p \\<Longrightarrow>\n      rel_spmf ?P (?f x) (?g x)) \\<Longrightarrow>\n  rel_spmf ?P (?p \\<bind> ?f) (?p \\<bind> ?g)\n  (\\<And>x. x \\<in> set_spmf ?p \\<Longrightarrow> ?P x x) \\<Longrightarrow>\n  rel_spmf ?P ?p ?p\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "obtain \\<A>1 \\<A>2 where \\<A>: \"\\<A> = (\\<A>1, \\<A>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<A>1 \\<A>2.\n        \\<A> = (\\<A>1, \\<A>2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"\\<A>\")"], ["proof (state)\nthis:\n  \\<A> = (\\<A>1, \\<A>2)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "from \\<open>ind_cpa.ibounded_by _ _\\<close>"], ["proof (chain)\npicking this:\n  local.ind_cpa.ibounded_by \\<A> (enat q)", "obtain q1 q2 :: nat\n    where q1: \"interaction_any_bounded_by \\<A>1 q1\"\n    and q2: \"\\<And>cipher \\<sigma>. interaction_any_bounded_by (\\<A>2 cipher \\<sigma>) q2\"\n    and \"q1 + q2 \\<le> q\""], ["proof (prove)\nusing this:\n  local.ind_cpa.ibounded_by \\<A> (enat q)\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>interaction_bounded_by' (\\<lambda>_. True) \\<A>1 q1;\n         \\<And>cipher \\<sigma>.\n            interaction_bounded_by' (\\<lambda>_. True)\n             (\\<A>2 cipher \\<sigma>) q2;\n         q1 + q2 \\<le> q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<A>"], ["proof (prove)\nusing this:\n  local.ind_cpa.ibounded_by (\\<A>1, \\<A>2) (enat q)\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>interaction_bounded_by' (\\<lambda>_. True) \\<A>1 q1;\n         \\<And>cipher \\<sigma>.\n            interaction_bounded_by' (\\<lambda>_. True)\n             (\\<A>2 cipher \\<sigma>) q2;\n         q1 + q2 \\<le> q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule ind_cpa.ibounded_byE)(auto simp add: iadd_le_enat_iff)"], ["proof (state)\nthis:\n  interaction_bounded_by' (\\<lambda>_. True) \\<A>1 q1\n  interaction_bounded_by' (\\<lambda>_. True) (\\<A>2 ?cipher2 ?\\<sigma>2) q2\n  q1 + q2 \\<le> q\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "from \\<A> assms"], ["proof (chain)\npicking this:\n  \\<A> = (\\<A>1, \\<A>2)\n  local.ind_cpa.ibounded_by \\<A> (enat q)\n  lossless_gpv \\<I>_full (fst \\<A>)\n  lossless_gpv \\<I>_full (snd \\<A> ?cipher2 ?\\<sigma>2)", "have lossless1: \"lossless_gpv \\<I>_full \\<A>1\"\n    and lossless2: \"\\<And>cipher \\<sigma>. lossless_gpv \\<I>_full (\\<A>2 cipher \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<A> = (\\<A>1, \\<A>2)\n  local.ind_cpa.ibounded_by \\<A> (enat q)\n  lossless_gpv \\<I>_full (fst \\<A>)\n  lossless_gpv \\<I>_full (snd \\<A> ?cipher2 ?\\<sigma>2)\n\ngoal (1 subgoal):\n 1. lossless_gpv \\<I>_full \\<A>1 &&&\n    (\\<And>cipher \\<sigma>. lossless_gpv \\<I>_full (\\<A>2 cipher \\<sigma>))", "by simp_all"], ["proof (state)\nthis:\n  lossless_gpv \\<I>_full \\<A>1\n  lossless_gpv \\<I>_full (\\<A>2 ?cipher2 ?\\<sigma>2)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have weight1: \"\\<And>oracle s. (\\<And>s x. lossless_spmf (oracle s x)) \n    \\<Longrightarrow> weight_spmf (exec_gpv oracle \\<A>1 s) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>oracle s.\n       (\\<And>s x. lossless_spmf (oracle s x)) \\<Longrightarrow>\n       weight_spmf (exec_gpv oracle \\<A>1 s) = 1", "by(rule lossless_weight_spmfD)(rule lossless_exec_gpv[OF lossless1], simp_all)"], ["proof (state)\nthis:\n  (\\<And>s x. lossless_spmf (?oracle2 s x)) \\<Longrightarrow>\n  weight_spmf (exec_gpv ?oracle2 \\<A>1 ?s2) = 1\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have weight2: \"\\<And>oracle s cipher \\<sigma>. (\\<And>s x. lossless_spmf (oracle s x)) \n    \\<Longrightarrow> weight_spmf (exec_gpv oracle (\\<A>2 cipher \\<sigma>) s) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>oracle s cipher \\<sigma>.\n       (\\<And>s x. lossless_spmf (oracle s x)) \\<Longrightarrow>\n       weight_spmf (exec_gpv oracle (\\<A>2 cipher \\<sigma>) s) = 1", "by(rule lossless_weight_spmfD)(rule lossless_exec_gpv[OF lossless2], simp_all)"], ["proof (state)\nthis:\n  (\\<And>s x. lossless_spmf (?oracle3 s x)) \\<Longrightarrow>\n  weight_spmf (exec_gpv ?oracle3 (\\<A>2 ?cipher3 ?\\<sigma>3) ?s3) = 1\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "let ?oracle1 = \"\\<lambda>key (s', s) y. map_spmf (\\<lambda>((x, s'), s). (x, (), ())) (exec_gpv (prf.prf_oracle key) (prf_encrypt_oracle () y) ())\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have bisim1: \"\\<And>key. rel_spmf (\\<lambda>(x, _) (y, _). x = y)\n          (exec_gpv (ind_cpa.encrypt_oracle key) \\<A>1 ())\n          (exec_gpv (?oracle1 key) \\<A>1 ((), ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>key.\n       rel_spmf (\\<lambda>(x, uu_) (y, uu_). x = y)\n        (exec_gpv (local.ind_cpa.encrypt_oracle key) \\<A>1 ())\n        (exec_gpv\n          (\\<lambda>(s', s) y.\n              map_spmf (\\<lambda>((x, s'), s). (x, (), ()))\n               (exec_gpv (local.prf.prf_oracle key)\n                 (prf_encrypt_oracle () y) ()))\n          \\<A>1 ((), ()))", "using TrueI"], ["proof (prove)\nusing this:\n  True\n\ngoal (1 subgoal):\n 1. \\<And>key.\n       rel_spmf (\\<lambda>(x, uu_) (y, uu_). x = y)\n        (exec_gpv (local.ind_cpa.encrypt_oracle key) \\<A>1 ())\n        (exec_gpv\n          (\\<lambda>(s', s) y.\n              map_spmf (\\<lambda>((x, s'), s). (x, (), ()))\n               (exec_gpv (local.prf.prf_oracle key)\n                 (prf_encrypt_oracle () y) ()))\n          \\<A>1 ((), ()))", "by(rule exec_gpv_oracle_bisim)(auto simp add: encrypt_def prf_encrypt_oracle_def ind_cpa.encrypt_oracle_def prf.prf_oracle_def o_def)"], ["proof (state)\nthis:\n  rel_spmf (\\<lambda>(x, uu_) (y, uu_). x = y)\n   (exec_gpv (local.ind_cpa.encrypt_oracle ?key5) \\<A>1 ())\n   (exec_gpv\n     (\\<lambda>(s', s) y.\n         map_spmf (\\<lambda>((x, s'), s). (x, (), ()))\n          (exec_gpv (local.prf.prf_oracle ?key5) (prf_encrypt_oracle () y)\n            ()))\n     \\<A>1 ((), ()))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have bisim2: \"\\<And>key cipher \\<sigma>. rel_spmf (\\<lambda>(x, _) (y, _). x = y)\n             (exec_gpv (ind_cpa.encrypt_oracle key) (\\<A>2 cipher \\<sigma>) ())\n             (exec_gpv (?oracle1 key) (\\<A>2 cipher \\<sigma>) ((), ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>key cipher \\<sigma>.\n       rel_spmf (\\<lambda>(x, uu_) (y, uu_). x = y)\n        (exec_gpv (local.ind_cpa.encrypt_oracle key) (\\<A>2 cipher \\<sigma>)\n          ())\n        (exec_gpv\n          (\\<lambda>(s', s) y.\n              map_spmf (\\<lambda>((x, s'), s). (x, (), ()))\n               (exec_gpv (local.prf.prf_oracle key)\n                 (prf_encrypt_oracle () y) ()))\n          (\\<A>2 cipher \\<sigma>) ((), ()))", "using TrueI"], ["proof (prove)\nusing this:\n  True\n\ngoal (1 subgoal):\n 1. \\<And>key cipher \\<sigma>.\n       rel_spmf (\\<lambda>(x, uu_) (y, uu_). x = y)\n        (exec_gpv (local.ind_cpa.encrypt_oracle key) (\\<A>2 cipher \\<sigma>)\n          ())\n        (exec_gpv\n          (\\<lambda>(s', s) y.\n              map_spmf (\\<lambda>((x, s'), s). (x, (), ()))\n               (exec_gpv (local.prf.prf_oracle key)\n                 (prf_encrypt_oracle () y) ()))\n          (\\<A>2 cipher \\<sigma>) ((), ()))", "by(rule exec_gpv_oracle_bisim)(auto simp add: encrypt_def prf_encrypt_oracle_def ind_cpa.encrypt_oracle_def prf.prf_oracle_def o_def)"], ["proof (state)\nthis:\n  rel_spmf (\\<lambda>(x, uu_) (y, uu_). x = y)\n   (exec_gpv (local.ind_cpa.encrypt_oracle ?key5)\n     (\\<A>2 ?cipher5 ?\\<sigma>5) ())\n   (exec_gpv\n     (\\<lambda>(s', s) y.\n         map_spmf (\\<lambda>((x, s'), s). (x, (), ()))\n          (exec_gpv (local.prf.prf_oracle ?key5) (prf_encrypt_oracle () y)\n            ()))\n     (\\<A>2 ?cipher5 ?\\<sigma>5) ((), ()))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have ind_cpa_0: \"rel_spmf (=) (ind_cpa.ind_cpa \\<A>) (prf.game_0 (prf_adversary \\<A>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=) (local.ind_cpa.ind_cpa \\<A>)\n     (local.prf.game_0 (prf_adversary \\<A>))", "unfolding IND_CPA.ind_cpa.ind_cpa_def \\<A> key_gen_def Let_def prf_adversary_def Pseudo_Random_Function.prf.game_0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (case (\\<A>1, \\<A>2) of\n      (\\<A>1, \\<A>2) \\<Rightarrow>\n        spmf_of_set (nlists UNIV len) \\<bind>\n        (\\<lambda>key.\n            coin_spmf \\<bind>\n            (\\<lambda>b.\n                exec_gpv (local.ind_cpa.encrypt_oracle key)\n                 (\\<A>1 \\<bind>\n                  (\\<lambda>((m0, m1), \\<sigma>).\n                      if valid_plain m0 \\<and> valid_plain m1\n                      then lift_spmf\n                            (encrypt key (if b then m0 else m1)) \\<bind>\n                           (\\<lambda>cipher. \\<A>2 cipher \\<sigma>)\n                      else lift_spmf coin_spmf))\n                 () \\<bind>\n                (\\<lambda>(guess, uu_). return_spmf (guess = b)))))\n     (spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>key.\n          exec_gpv (local.prf.prf_oracle key)\n           (case (\\<A>1, \\<A>2) of\n            (\\<A>1, \\<A>2) \\<Rightarrow>\n              inline prf_encrypt_oracle \\<A>1 () \\<bind>\n              (\\<lambda>(((p1, p2), \\<sigma>), n).\n                  if valid_plain p1 \\<and> valid_plain p2\n                  then lift_spmf coin_spmf \\<bind>\n                       (\\<lambda>b.\n                           lift_spmf (spmf_of_set (nlists UNIV len)) \\<bind>\n                           (\\<lambda>r.\n                               Generative_Probabilistic_Value.Pause r\n                                Generative_Probabilistic_Value.Done \\<bind>\n                               (\\<lambda>pad.\n                                   inline prf_encrypt_oracle\n                                    (\\<A>2\n(r, (if b then p1 else p2) [\\<oplus>] pad) \\<sigma>)\n                                    n \\<bind>\n                                   (\\<lambda>(b', uu_).\n Generative_Probabilistic_Value.Done (b' = b)))))\n                  else lift_spmf coin_spmf))\n           () \\<bind>\n          (\\<lambda>(b, uu_). return_spmf b)))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>key.\n          coin_spmf \\<bind>\n          (\\<lambda>b.\n              exec_gpv (local.ind_cpa.encrypt_oracle key) \\<A>1 () \\<bind>\n              (\\<lambda>y.\n                  (case y of\n                   (x, xa) \\<Rightarrow>\n                     exec_gpv (local.ind_cpa.encrypt_oracle key)\n                      (case x of\n                       (x, xa) \\<Rightarrow>\n                         (case x of\n                          (m0, m1) \\<Rightarrow>\n                            \\<lambda>\\<sigma>.\n                               if valid_plain m0 \\<and> valid_plain m1\n                               then lift_spmf\n                                     (encrypt key\n (if b then m0 else m1)) \\<bind>\n                                    (\\<lambda>cipher. \\<A>2 cipher \\<sigma>)\n                               else lift_spmf coin_spmf)\n                          xa)\n                      xa) \\<bind>\n                  (\\<lambda>(guess, uu_). return_spmf (guess = b))))))\n     (spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>key.\n          exec_gpv\n           (\\<lambda>(s', s) y.\n               map_spmf (\\<lambda>((x, s'), s). (x, (), ()))\n                (exec_gpv (local.prf.prf_oracle key)\n                  (prf_encrypt_oracle () y) ()))\n           \\<A>1 ((), ()) \\<bind>\n          (\\<lambda>y.\n              (case case y of (x, s', xb) \\<Rightarrow> ((x, ()), xb) of\n               (x, xa) \\<Rightarrow>\n                 exec_gpv (local.prf.prf_oracle key)\n                  (case x of\n                   (x, xa) \\<Rightarrow>\n                     (case x of\n                      (x, xa) \\<Rightarrow>\n                        (case x of\n                         (p1, p2) \\<Rightarrow>\n                           \\<lambda>\\<sigma> n.\n                              if valid_plain p1 \\<and> valid_plain p2\n                              then lift_spmf coin_spmf \\<bind>\n                                   (\\<lambda>b.\n lift_spmf (spmf_of_set (nlists UNIV len)) \\<bind>\n (\\<lambda>r.\n     Generative_Probabilistic_Value.Pause r\n      (\\<lambda>pad.\n          inline prf_encrypt_oracle\n           (\\<A>2 (r, (if b then p1 else p2) [\\<oplus>] pad) \\<sigma>)\n           () \\<bind>\n          (\\<lambda>(b', uu_).\n              Generative_Probabilistic_Value.Done (b' = b)))))\n                              else lift_spmf coin_spmf)\n                         xa)\n                      xa)\n                  xa) \\<bind>\n              (\\<lambda>(b, uu_). return_spmf b))))", "apply(rewrite in \"bind_spmf _ \\<hole>\" bind_commute_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>key.\n          exec_gpv (local.ind_cpa.encrypt_oracle key) \\<A>1 () \\<bind>\n          (\\<lambda>y.\n              coin_spmf \\<bind>\n              (\\<lambda>b.\n                  (case y of\n                   (x, xa) \\<Rightarrow>\n                     exec_gpv (local.ind_cpa.encrypt_oracle key)\n                      (case x of\n                       (x, xa) \\<Rightarrow>\n                         (case x of\n                          (m0, m1) \\<Rightarrow>\n                            \\<lambda>\\<sigma>.\n                               if valid_plain m0 \\<and> valid_plain m1\n                               then lift_spmf\n                                     (encrypt key\n (if b then m0 else m1)) \\<bind>\n                                    (\\<lambda>cipher. \\<A>2 cipher \\<sigma>)\n                               else lift_spmf coin_spmf)\n                          xa)\n                      xa) \\<bind>\n                  (\\<lambda>(guess, uu_). return_spmf (guess = b))))))\n     (spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>key.\n          exec_gpv\n           (\\<lambda>(s', s) y.\n               map_spmf (\\<lambda>((x, s'), s). (x, (), ()))\n                (exec_gpv (local.prf.prf_oracle key)\n                  (prf_encrypt_oracle () y) ()))\n           \\<A>1 ((), ()) \\<bind>\n          (\\<lambda>y.\n              (case case y of (x, s', xb) \\<Rightarrow> ((x, ()), xb) of\n               (x, xa) \\<Rightarrow>\n                 exec_gpv (local.prf.prf_oracle key)\n                  (case x of\n                   (x, xa) \\<Rightarrow>\n                     (case x of\n                      (x, xa) \\<Rightarrow>\n                        (case x of\n                         (p1, p2) \\<Rightarrow>\n                           \\<lambda>\\<sigma> n.\n                              if valid_plain p1 \\<and> valid_plain p2\n                              then lift_spmf coin_spmf \\<bind>\n                                   (\\<lambda>b.\n lift_spmf (spmf_of_set (nlists UNIV len)) \\<bind>\n (\\<lambda>r.\n     Generative_Probabilistic_Value.Pause r\n      (\\<lambda>pad.\n          inline prf_encrypt_oracle\n           (\\<A>2 (r, (if b then p1 else p2) [\\<oplus>] pad) \\<sigma>)\n           () \\<bind>\n          (\\<lambda>(b', uu_).\n              Generative_Probabilistic_Value.Done (b' = b)))))\n                              else lift_spmf coin_spmf)\n                         xa)\n                      xa)\n                  xa) \\<bind>\n              (\\<lambda>(b, uu_). return_spmf b))))", "apply(rule rel_spmf_bind_reflI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_spmf (spmf_of_set (nlists UNIV len)) \\<Longrightarrow>\n       rel_spmf (=)\n        (exec_gpv (local.ind_cpa.encrypt_oracle x) \\<A>1 () \\<bind>\n         (\\<lambda>y.\n             coin_spmf \\<bind>\n             (\\<lambda>b.\n                 (case y of\n                  (xa, xb) \\<Rightarrow>\n                    exec_gpv (local.ind_cpa.encrypt_oracle x)\n                     (case xa of\n                      (xa, xb) \\<Rightarrow>\n                        (case xa of\n                         (m0, m1) \\<Rightarrow>\n                           \\<lambda>\\<sigma>.\n                              if valid_plain m0 \\<and> valid_plain m1\n                              then lift_spmf\n                                    (encrypt x\n(if b then m0 else m1)) \\<bind>\n                                   (\\<lambda>cipher. \\<A>2 cipher \\<sigma>)\n                              else lift_spmf coin_spmf)\n                         xb)\n                     xb) \\<bind>\n                 (\\<lambda>(guess, uu_). return_spmf (guess = b)))))\n        (exec_gpv\n          (\\<lambda>(s', s) y.\n              map_spmf (\\<lambda>((x, s'), s). (x, (), ()))\n               (exec_gpv (local.prf.prf_oracle x) (prf_encrypt_oracle () y)\n                 ()))\n          \\<A>1 ((), ()) \\<bind>\n         (\\<lambda>y.\n             (case case y of (x, s', xb) \\<Rightarrow> ((x, ()), xb) of\n              (xa, xb) \\<Rightarrow>\n                exec_gpv (local.prf.prf_oracle x)\n                 (case xa of\n                  (x, xa) \\<Rightarrow>\n                    (case x of\n                     (x, xa) \\<Rightarrow>\n                       (case x of\n                        (p1, p2) \\<Rightarrow>\n                          \\<lambda>\\<sigma> n.\n                             if valid_plain p1 \\<and> valid_plain p2\n                             then lift_spmf coin_spmf \\<bind>\n                                  (\\<lambda>b.\nlift_spmf (spmf_of_set (nlists UNIV len)) \\<bind>\n(\\<lambda>r.\n    Generative_Probabilistic_Value.Pause r\n     (\\<lambda>pad.\n         inline prf_encrypt_oracle\n          (\\<A>2 (r, (if b then p1 else p2) [\\<oplus>] pad) \\<sigma>)\n          () \\<bind>\n         (\\<lambda>(b', uu_).\n             Generative_Probabilistic_Value.Done (b' = b)))))\n                             else lift_spmf coin_spmf)\n                        xa)\n                     xa)\n                 xb) \\<bind>\n             (\\<lambda>(b, uu_). return_spmf b)))", "apply(rule rel_spmf_bindI[OF bisim1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa y.\n       \\<lbrakk>x \\<in> set_spmf (spmf_of_set (nlists UNIV len));\n        (case xa of (x, uu_) \\<Rightarrow> \\<lambda>(y, uu_). x = y)\n         y\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (=)\n                          (coin_spmf \\<bind>\n                           (\\<lambda>b.\n                               (case xa of\n                                (xa, xb) \\<Rightarrow>\n                                  exec_gpv (local.ind_cpa.encrypt_oracle x)\n                                   (case xa of\n                                    (xa, xb) \\<Rightarrow>\n(case xa of\n (m0, m1) \\<Rightarrow>\n   \\<lambda>\\<sigma>.\n      if valid_plain m0 \\<and> valid_plain m1\n      then lift_spmf (encrypt x (if b then m0 else m1)) \\<bind>\n           (\\<lambda>cipher. \\<A>2 cipher \\<sigma>)\n      else lift_spmf coin_spmf)\n xb)\n                                   xb) \\<bind>\n                               (\\<lambda>(guess, uu_).\n                                   return_spmf (guess = b))))\n                          ((case case y of\n                                 (x, s', xb) \\<Rightarrow> ((x, ()), xb) of\n                            (xa, xb) \\<Rightarrow>\n                              exec_gpv (local.prf.prf_oracle x)\n                               (case xa of\n                                (x, xa) \\<Rightarrow>\n                                  (case x of\n                                   (x, xa) \\<Rightarrow>\n                                     (case x of\n(p1, p2) \\<Rightarrow>\n  \\<lambda>\\<sigma> n.\n     if valid_plain p1 \\<and> valid_plain p2\n     then lift_spmf coin_spmf \\<bind>\n          (\\<lambda>b.\n              lift_spmf (spmf_of_set (nlists UNIV len)) \\<bind>\n              (\\<lambda>r.\n                  Generative_Probabilistic_Value.Pause r\n                   (\\<lambda>pad.\n                       inline prf_encrypt_oracle\n                        (\\<A>2 (r, (if b then p1 else p2) [\\<oplus>] pad)\n                          \\<sigma>)\n                        () \\<bind>\n                       (\\<lambda>(b', uu_).\n                           Generative_Probabilistic_Value.Done (b' = b)))))\n     else lift_spmf coin_spmf)\nxa)\n                                   xa)\n                               xb) \\<bind>\n                           (\\<lambda>(b, uu_). return_spmf b))", "apply(clarsimp simp add: if_distribs bind_coin_spmf_eq_const')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x aa bb bc.\n       \\<lbrakk>x \\<in> nlists UNIV len; valid_plain aa;\n        valid_plain bb\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (=)\n                          (coin_spmf \\<bind>\n                           (\\<lambda>b.\n                               encrypt x (if b then aa else bb) \\<bind>\n                               (\\<lambda>y.\n                                   exec_gpv (local.ind_cpa.encrypt_oracle x)\n                                    (\\<A>2 y bc) () \\<bind>\n                                   (\\<lambda>(guess, uu_).\n return_spmf (guess = b)))))\n                          (coin_spmf \\<bind>\n                           (\\<lambda>y.\n                               spmf_of_set (nlists UNIV len) \\<bind>\n                               (\\<lambda>ya.\n                                   local.prf.prf_oracle x () ya \\<bind>\n                                   (\\<lambda>yaa.\n (case yaa of\n  (xa, s') \\<Rightarrow>\n    exec_gpv\n     (\\<lambda>(s', s) y.\n         map_spmf (\\<lambda>((x, s'), s). (x, (), ()))\n          (exec_gpv (local.prf.prf_oracle x) (prf_encrypt_oracle () y) ()))\n     (\\<A>2 (ya, (if y then aa else bb) [\\<oplus>] xa) bc) ((), ()) \\<bind>\n    (\\<lambda>(xa, ya).\n        exec_gpv (local.prf.prf_oracle x)\n         (case xa of\n          (b', uu_) \\<Rightarrow>\n            Generative_Probabilistic_Value.Done (b' = y))\n         ya) \\<circ>\n    (\\<lambda>(x, s', y). ((x, ()), y))) \\<bind>\n (\\<lambda>(b, uu_). return_spmf b)))))", "apply(auto intro: rel_spmf_bindI[OF bisim2] intro!: rel_spmf_bind_reflI simp add: encrypt_def prf.prf_oracle_def cong del: if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_spmf (=) (local.ind_cpa.ind_cpa \\<A>)\n   (local.prf.game_0 (prf_adversary \\<A>))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "define rf_encrypt where \"rf_encrypt = (\\<lambda>s plain. bind_spmf (spmf_of_set (nlists UNIV len)) (\\<lambda>r :: bool list. \n    bind_spmf (prf.random_oracle s r) (\\<lambda>(pad, s'). \n    return_spmf ((r, xor_list plain pad), s')))\n  )\""], ["proof (state)\nthis:\n  rf_encrypt =\n  (\\<lambda>s plain.\n      spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>r.\n          prf.random_oracle s r \\<bind>\n          (\\<lambda>(pad, s').\n              return_spmf ((r, plain [\\<oplus>] pad), s'))))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "interpret rf_finite: callee_invariant_on rf_encrypt \"\\<lambda>s. finite (dom s)\" \\<I>_full"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant rf_encrypt (\\<lambda>s. finite (dom s))", "by unfold_locales(auto simp add: rf_encrypt_def dest: prf.finite.callee_invariant)"], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have lossless_rf_encrypt [simp]: \"\\<And>s plain. lossless_spmf (rf_encrypt s plain)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s plain. lossless_spmf (rf_encrypt s plain)", "by(auto simp add: rf_encrypt_def)"], ["proof (state)\nthis:\n  lossless_spmf (rf_encrypt ?s5 ?plain5)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "define game2 where \"game2 = do {\n    (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n    if valid_plain p0 \\<and> valid_plain p1 then do {\n      b \\<leftarrow> coin_spmf;\n      let pb = (if b then p0 else p1);\n      (cipher, s2) \\<leftarrow> rf_encrypt s1 pb;\n      (b', s3) \\<leftarrow> exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s2;\n      return_spmf (b' = b)\n    } else coin_spmf\n  }\""], ["proof (state)\nthis:\n  game2 =\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then coin_spmf \\<bind>\n           (\\<lambda>b.\n               let pb = if b then p0 else p1\n               in rf_encrypt s1 pb \\<bind>\n                  (\\<lambda>(cipher, s2).\n                      exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s2 \\<bind>\n                      (\\<lambda>(b', s3). return_spmf (b' = b))))\n      else coin_spmf)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "let ?oracle2 = \"\\<lambda>(s', s) y. map_spmf (\\<lambda>((x, s'), s). (x, (), s)) (exec_gpv prf.random_oracle (prf_encrypt_oracle () y) s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "let ?I = \"\\<lambda>(x, _, s) (y, s'). x = y \\<and> s = s'\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have bisim1: \"rel_spmf ?I (exec_gpv ?oracle2 \\<A>1 ((), Map.empty)) (exec_gpv rf_encrypt \\<A>1 Map.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (\\<lambda>(x, uu_, s) (y, s'). x = y \\<and> s = s')\n     (exec_gpv\n       (\\<lambda>(s', s) y.\n           map_spmf (\\<lambda>((x, s'), s). (x, (), s))\n            (exec_gpv prf.random_oracle (prf_encrypt_oracle () y) s))\n       \\<A>1 ((), Map.empty))\n     (exec_gpv rf_encrypt \\<A>1 Map.empty)", "by(rule exec_gpv_oracle_bisim[where X=\"\\<lambda>(_, s) s'. s = s'\"])\n       (auto simp add: rf_encrypt_def prf_encrypt_oracle_def intro!: rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  rel_spmf (\\<lambda>(x, uu_, s) (y, s'). x = y \\<and> s = s')\n   (exec_gpv\n     (\\<lambda>(s', s) y.\n         map_spmf (\\<lambda>((x, s'), s). (x, (), s))\n          (exec_gpv prf.random_oracle (prf_encrypt_oracle () y) s))\n     \\<A>1 ((), Map.empty))\n   (exec_gpv rf_encrypt \\<A>1 Map.empty)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have bisim2: \"\\<And>cipher \\<sigma> s. rel_spmf ?I (exec_gpv ?oracle2 (\\<A>2 cipher \\<sigma>) ((), s)) (exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cipher \\<sigma> s.\n       rel_spmf (\\<lambda>(x, uu_, s) (y, s'). x = y \\<and> s = s')\n        (exec_gpv\n          (\\<lambda>(s', s) y.\n              map_spmf (\\<lambda>((x, s'), s). (x, (), s))\n               (exec_gpv prf.random_oracle (prf_encrypt_oracle () y) s))\n          (\\<A>2 cipher \\<sigma>) ((), s))\n        (exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s)", "by(rule exec_gpv_oracle_bisim[where X=\"\\<lambda>(_, s) s'. s = s'\"])\n      (auto simp add: prf_encrypt_oracle_def rf_encrypt_def intro!: rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  rel_spmf (\\<lambda>(x, uu_, s) (y, s'). x = y \\<and> s = s')\n   (exec_gpv\n     (\\<lambda>(s', s) y.\n         map_spmf (\\<lambda>((x, s'), s). (x, (), s))\n          (exec_gpv prf.random_oracle (prf_encrypt_oracle () y) s))\n     (\\<A>2 ?cipher7 ?\\<sigma>7) ((), ?s7))\n   (exec_gpv rf_encrypt (\\<A>2 ?cipher7 ?\\<sigma>7) ?s7)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have game1_2 [unfolded spmf_rel_eq]: \"rel_spmf (=) (prf.game_1 (prf_adversary \\<A>)) game2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=) (local.prf.game_1 (prf_adversary \\<A>)) game2", "unfolding prf.game_1_def game2_def prf_adversary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (exec_gpv prf.random_oracle\n       (let (\\<A>1, \\<A>2) = \\<A>\n        in inline prf_encrypt_oracle \\<A>1 () \\<bind>\n           (\\<lambda>(((p1, p2), \\<sigma>), n).\n               if valid_plain p1 \\<and> valid_plain p2\n               then lift_spmf coin_spmf \\<bind>\n                    (\\<lambda>b.\n                        let pb = if b then p1 else p2\n                        in lift_spmf (spmf_of_set (nlists UNIV len)) \\<bind>\n                           (\\<lambda>r.\n                               Generative_Probabilistic_Value.Pause r\n                                Generative_Probabilistic_Value.Done \\<bind>\n                               (\\<lambda>pad.\n                                   let c = (r, pb [\\<oplus>] pad)\n                                   in inline prf_encrypt_oracle\n (\\<A>2 c \\<sigma>) n \\<bind>\n(\\<lambda>(b', uu_). Generative_Probabilistic_Value.Done (b' = b)))))\n               else lift_spmf coin_spmf))\n       Map.empty \\<bind>\n      (\\<lambda>(b, uu_). return_spmf b))\n     (exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          if valid_plain p0 \\<and> valid_plain p1\n          then coin_spmf \\<bind>\n               (\\<lambda>b.\n                   let pb = if b then p0 else p1\n                   in rf_encrypt s1 pb \\<bind>\n                      (\\<lambda>(cipher, s2).\n                          exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                           s2 \\<bind>\n                          (\\<lambda>(b', s3). return_spmf (b' = b))))\n          else coin_spmf))", "by(rewrite in \"if _ then \\<hole> else _\" rf_encrypt_def)\n      (auto simp add: Let_def \\<A> if_distribs intro!: rel_spmf_bindI[OF bisim2] rel_spmf_bind_reflI rel_spmf_bindI[OF bisim1])"], ["proof (state)\nthis:\n  local.prf.game_1 (prf_adversary \\<A>) = game2\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "define game2_a where \"game2_a = do {\n    r \\<leftarrow> spmf_of_set (nlists UNIV len);\n    (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n    let bad = r \\<in> dom s1;\n    if valid_plain p0 \\<and> valid_plain p1 then do {\n      b \\<leftarrow> coin_spmf;\n      let pb = (if b then p0 else p1);\n      (pad, s2) \\<leftarrow> prf.random_oracle s1 r;\n      let cipher = (r, xor_list pb pad);\n      (b', s3) \\<leftarrow> exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s2;\n      return_spmf (b' = b, bad)\n    } else coin_spmf \\<bind> (\\<lambda>b. return_spmf (b, bad))\n  }\""], ["proof (state)\nthis:\n  game2_a =\n  spmf_of_set (nlists UNIV len) \\<bind>\n  (\\<lambda>r.\n      exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          let bad = r \\<in> dom s1\n          in if valid_plain p0 \\<and> valid_plain p1\n             then coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      let pb = if b then p0 else p1\n                      in prf.random_oracle s1 r \\<bind>\n                         (\\<lambda>(pad, s2).\n                             let cipher = (r, pb [\\<oplus>] pad)\n                             in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                 s2 \\<bind>\n                                (\\<lambda>(b', s3).\n                                    return_spmf (b' = b, bad))))\n             else coin_spmf \\<bind> (\\<lambda>b. return_spmf (b, bad))))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "define game2_b where \"game2_b = do {\n    r \\<leftarrow> spmf_of_set (nlists UNIV len);\n    (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n    let bad = r \\<in> dom s1;\n    if valid_plain p0 \\<and> valid_plain p1 then do {\n      b \\<leftarrow> coin_spmf;\n      let pb = (if b then p0 else p1);\n      pad \\<leftarrow> spmf_of_set (nlists UNIV len);\n      let cipher = (r, xor_list pb pad);\n      (b', s3) \\<leftarrow> exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) (s1(r \\<mapsto> pad));\n      return_spmf (b' = b, bad)\n    } else coin_spmf \\<bind> (\\<lambda>b. return_spmf (b, bad))\n  }\""], ["proof (state)\nthis:\n  game2_b =\n  spmf_of_set (nlists UNIV len) \\<bind>\n  (\\<lambda>r.\n      exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          let bad = r \\<in> dom s1\n          in if valid_plain p0 \\<and> valid_plain p1\n             then coin_spmf \\<bind>\n                  (\\<lambda>b.\n                      let pb = if b then p0 else p1\n                      in spmf_of_set (nlists UNIV len) \\<bind>\n                         (\\<lambda>pad.\n                             let cipher = (r, pb [\\<oplus>] pad)\n                             in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                 (s1(r \\<mapsto> pad)) \\<bind>\n                                (\\<lambda>(b', s3).\n                                    return_spmf (b' = b, bad))))\n             else coin_spmf \\<bind> (\\<lambda>b. return_spmf (b, bad))))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"game2 = do {\n      r \\<leftarrow> spmf_of_set (nlists UNIV len);\n      (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n      if valid_plain p0 \\<and> valid_plain p1 then do {\n        b \\<leftarrow> coin_spmf;\n        let pb = (if b then p0 else p1);\n        (pad, s2) \\<leftarrow> prf.random_oracle s1 r;\n        let cipher = (r, xor_list pb pad);\n        (b', s3) \\<leftarrow> exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s2;\n        return_spmf (b' = b)\n      } else coin_spmf\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. game2 =\n    spmf_of_set (nlists UNIV len) \\<bind>\n    (\\<lambda>r.\n        exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n        (\\<lambda>(((p0, p1), \\<sigma>), s1).\n            if valid_plain p0 \\<and> valid_plain p1\n            then coin_spmf \\<bind>\n                 (\\<lambda>b.\n                     let pb = if b then p0 else p1\n                     in prf.random_oracle s1 r \\<bind>\n                        (\\<lambda>(pad, s2).\n                            let cipher = (r, pb [\\<oplus>] pad)\n                            in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                s2 \\<bind>\n                               (\\<lambda>(b', s3). return_spmf (b' = b))))\n            else coin_spmf))", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. game2 =\n    spmf_of_set (nlists UNIV len) \\<bind>\n    (\\<lambda>r.\n        exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n        (\\<lambda>(((p0, p1), \\<sigma>), s1).\n            if valid_plain p0 \\<and> valid_plain p1\n            then coin_spmf \\<bind>\n                 (\\<lambda>b.\n                     let pb = if b then p0 else p1\n                     in prf.random_oracle s1 r \\<bind>\n                        (\\<lambda>(pad, s2).\n                            let cipher = (r, pb [\\<oplus>] pad)\n                            in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                s2 \\<bind>\n                               (\\<lambda>(b', s3). return_spmf (b' = b))))\n            else coin_spmf))", "by(simp add: game2_def split_def rf_encrypt_def Let_def)"], ["proof (state)\nthis:\n  game2 =\n  spmf_of_set (nlists UNIV len) \\<bind>\n  (\\<lambda>r.\n      exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          if valid_plain p0 \\<and> valid_plain p1\n          then coin_spmf \\<bind>\n               (\\<lambda>b.\n                   let pb = if b then p0 else p1\n                   in prf.random_oracle s1 r \\<bind>\n                      (\\<lambda>(pad, s2).\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s2 \\<bind>\n                             (\\<lambda>(b', s3). return_spmf (b' = b))))\n          else coin_spmf))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  game2 =\n  spmf_of_set (nlists UNIV len) \\<bind>\n  (\\<lambda>r.\n      exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          if valid_plain p0 \\<and> valid_plain p1\n          then coin_spmf \\<bind>\n               (\\<lambda>b.\n                   let pb = if b then p0 else p1\n                   in prf.random_oracle s1 r \\<bind>\n                      (\\<lambda>(pad, s2).\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s2 \\<bind>\n                             (\\<lambda>(b', s3). return_spmf (b' = b))))\n          else coin_spmf))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> = map_spmf fst game2_a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf_of_set (nlists UNIV len) \\<bind>\n    (\\<lambda>r.\n        exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n        (\\<lambda>(((p0, p1), \\<sigma>), s1).\n            if valid_plain p0 \\<and> valid_plain p1\n            then coin_spmf \\<bind>\n                 (\\<lambda>b.\n                     let pb = if b then p0 else p1\n                     in prf.random_oracle s1 r \\<bind>\n                        (\\<lambda>(pad, s2).\n                            let cipher = (r, pb [\\<oplus>] pad)\n                            in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                s2 \\<bind>\n                               (\\<lambda>(b', s3). return_spmf (b' = b))))\n            else coin_spmf)) =\n    map_spmf fst game2_a", "unfolding game2_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf_of_set (nlists UNIV len) \\<bind>\n    (\\<lambda>r.\n        exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n        (\\<lambda>(((p0, p1), \\<sigma>), s1).\n            if valid_plain p0 \\<and> valid_plain p1\n            then coin_spmf \\<bind>\n                 (\\<lambda>b.\n                     let pb = if b then p0 else p1\n                     in prf.random_oracle s1 r \\<bind>\n                        (\\<lambda>(pad, s2).\n                            let cipher = (r, pb [\\<oplus>] pad)\n                            in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                s2 \\<bind>\n                               (\\<lambda>(b', s3). return_spmf (b' = b))))\n            else coin_spmf)) =\n    map_spmf fst\n     (spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>r.\n          exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n          (\\<lambda>(((p0, p1), \\<sigma>), s1).\n              let bad = r \\<in> dom s1\n              in if valid_plain p0 \\<and> valid_plain p1\n                 then coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          let pb = if b then p0 else p1\n                          in prf.random_oracle s1 r \\<bind>\n                             (\\<lambda>(pad, s2).\n                                 let cipher = (r, pb [\\<oplus>] pad)\n                                 in exec_gpv rf_encrypt\n                                     (\\<A>2 cipher \\<sigma>) s2 \\<bind>\n                                    (\\<lambda>(b', s3).\n  return_spmf (b' = b, bad))))\n                 else coin_spmf \\<bind>\n                      (\\<lambda>b. return_spmf (b, bad)))))", "by(clarsimp simp add: map_spmf_conv_bind_spmf Let_def if_distribR if_distrib split_def cong: if_cong)"], ["proof (state)\nthis:\n  spmf_of_set (nlists UNIV len) \\<bind>\n  (\\<lambda>r.\n      exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          if valid_plain p0 \\<and> valid_plain p1\n          then coin_spmf \\<bind>\n               (\\<lambda>b.\n                   let pb = if b then p0 else p1\n                   in prf.random_oracle s1 r \\<bind>\n                      (\\<lambda>(pad, s2).\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s2 \\<bind>\n                             (\\<lambda>(b', s3). return_spmf (b' = b))))\n          else coin_spmf)) =\n  map_spmf fst game2_a\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "finally"], ["proof (chain)\npicking this:\n  game2 = map_spmf fst game2_a", "have game2_2a: \"game2 = \\<dots>\""], ["proof (prove)\nusing this:\n  game2 = map_spmf fst game2_a\n\ngoal (1 subgoal):\n 1. game2 = map_spmf fst game2_a", "."], ["proof (state)\nthis:\n  game2 = map_spmf fst game2_a\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"map_spmf snd game2_a = map_spmf snd game2_b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd game2_a = map_spmf snd game2_b", "unfolding game2_a_def game2_b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd\n     (spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>r.\n          exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n          (\\<lambda>(((p0, p1), \\<sigma>), s1).\n              let bad = r \\<in> dom s1\n              in if valid_plain p0 \\<and> valid_plain p1\n                 then coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          let pb = if b then p0 else p1\n                          in prf.random_oracle s1 r \\<bind>\n                             (\\<lambda>(pad, s2).\n                                 let cipher = (r, pb [\\<oplus>] pad)\n                                 in exec_gpv rf_encrypt\n                                     (\\<A>2 cipher \\<sigma>) s2 \\<bind>\n                                    (\\<lambda>(b', s3).\n  return_spmf (b' = b, bad))))\n                 else coin_spmf \\<bind>\n                      (\\<lambda>b. return_spmf (b, bad))))) =\n    map_spmf snd\n     (spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>r.\n          exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n          (\\<lambda>(((p0, p1), \\<sigma>), s1).\n              let bad = r \\<in> dom s1\n              in if valid_plain p0 \\<and> valid_plain p1\n                 then coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          let pb = if b then p0 else p1\n                          in spmf_of_set (nlists UNIV len) \\<bind>\n                             (\\<lambda>pad.\n                                 let cipher = (r, pb [\\<oplus>] pad)\n                                 in exec_gpv rf_encrypt\n                                     (\\<A>2 cipher \\<sigma>)\n                                     (s1(r \\<mapsto> pad)) \\<bind>\n                                    (\\<lambda>(b', s3).\n  return_spmf (b' = b, bad))))\n                 else coin_spmf \\<bind>\n                      (\\<lambda>b. return_spmf (b, bad)))))", "by(auto simp add: o_def Let_def split_def if_distribs weight2 split: option.split intro: bind_spmf_cong[OF refl])"], ["proof (state)\nthis:\n  map_spmf snd game2_a = map_spmf snd game2_b\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "moreover"], ["proof (state)\nthis:\n  map_spmf snd game2_a = map_spmf snd game2_b\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"rel_spmf (=) (map_spmf fst (game2_a \\<upharpoonleft> (snd -` {False}))) (map_spmf fst (game2_b \\<upharpoonleft> (snd -` {False})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=) (map_spmf fst (game2_a \\<upharpoonleft> (snd -` {False})))\n     (map_spmf fst (game2_b \\<upharpoonleft> (snd -` {False})))", "unfolding game2_a_def game2_b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (map_spmf fst\n       ((spmf_of_set (nlists UNIV len) \\<bind>\n         (\\<lambda>r.\n             exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n             (\\<lambda>(((p0, p1), \\<sigma>), s1).\n                 let bad = r \\<in> dom s1\n                 in if valid_plain p0 \\<and> valid_plain p1\n                    then coin_spmf \\<bind>\n                         (\\<lambda>b.\n                             let pb = if b then p0 else p1\n                             in prf.random_oracle s1 r \\<bind>\n                                (\\<lambda>(pad, s2).\n                                    let cipher = (r, pb [\\<oplus>] pad)\n                                    in exec_gpv rf_encrypt\n  (\\<A>2 cipher \\<sigma>) s2 \\<bind>\n (\\<lambda>(b', s3). return_spmf (b' = b, bad))))\n                    else coin_spmf \\<bind>\n                         (\\<lambda>b.\n                             return_spmf (b, bad))))) \\<upharpoonleft>\n        (snd -` {False})))\n     (map_spmf fst\n       ((spmf_of_set (nlists UNIV len) \\<bind>\n         (\\<lambda>r.\n             exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n             (\\<lambda>(((p0, p1), \\<sigma>), s1).\n                 let bad = r \\<in> dom s1\n                 in if valid_plain p0 \\<and> valid_plain p1\n                    then coin_spmf \\<bind>\n                         (\\<lambda>b.\n                             let pb = if b then p0 else p1\n                             in spmf_of_set (nlists UNIV len) \\<bind>\n                                (\\<lambda>pad.\n                                    let cipher = (r, pb [\\<oplus>] pad)\n                                    in exec_gpv rf_encrypt\n  (\\<A>2 cipher \\<sigma>) (s1(r \\<mapsto> pad)) \\<bind>\n (\\<lambda>(b', s3). return_spmf (b' = b, bad))))\n                    else coin_spmf \\<bind>\n                         (\\<lambda>b.\n                             return_spmf (b, bad))))) \\<upharpoonleft>\n        (snd -` {False})))", "by(clarsimp simp add: restrict_bind_spmf o_def Let_def if_distribs split_def restrict_return_spmf prf.random_oracle_def intro!: rel_spmf_bind_reflI split: option.splits)"], ["proof (state)\nthis:\n  rel_spmf (=) (map_spmf fst (game2_a \\<upharpoonleft> (snd -` {False})))\n   (map_spmf fst (game2_b \\<upharpoonleft> (snd -` {False})))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "hence \"spmf game2_a (True, False) = spmf game2_b (True, False)\""], ["proof (prove)\nusing this:\n  rel_spmf (=) (map_spmf fst (game2_a \\<upharpoonleft> (snd -` {False})))\n   (map_spmf fst (game2_b \\<upharpoonleft> (snd -` {False})))\n\ngoal (1 subgoal):\n 1. spmf game2_a (True, False) = spmf game2_b (True, False)", "unfolding spmf_rel_eq"], ["proof (prove)\nusing this:\n  map_spmf fst (game2_a \\<upharpoonleft> (snd -` {False})) =\n  map_spmf fst (game2_b \\<upharpoonleft> (snd -` {False}))\n\ngoal (1 subgoal):\n 1. spmf game2_a (True, False) = spmf game2_b (True, False)", "by(subst (1 2) spmf_map_restrict[symmetric]) simp"], ["proof (state)\nthis:\n  spmf game2_a (True, False) = spmf game2_b (True, False)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "ultimately"], ["proof (chain)\npicking this:\n  map_spmf snd game2_a = map_spmf snd game2_b\n  spmf game2_a (True, False) = spmf game2_b (True, False)", "have game2a_2b: \"\\<bar>spmf (map_spmf fst game2_a) True - spmf (map_spmf fst game2_b) True\\<bar> \\<le> spmf (map_spmf snd game2_a) True\""], ["proof (prove)\nusing this:\n  map_spmf snd game2_a = map_spmf snd game2_b\n  spmf game2_a (True, False) = spmf game2_b (True, False)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_a) True -\n          spmf (map_spmf fst game2_b) True\\<bar>\n    \\<le> spmf (map_spmf snd game2_a) True", "by(subst (1 2) spmf_conv_measure_spmf)(rule identical_until_bad; simp add: spmf.map_id[unfolded id_def] spmf_conv_measure_spmf)"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game2_a) True -\n        spmf (map_spmf fst game2_b) True\\<bar>\n  \\<le> spmf (map_spmf snd game2_a) True\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "define game2_a_bad where \"game2_a_bad = do {\n      r \\<leftarrow> spmf_of_set (nlists UNIV len);\n      (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n      return_spmf (r \\<in> dom s1)\n    }\""], ["proof (state)\nthis:\n  game2_a_bad =\n  spmf_of_set (nlists UNIV len) \\<bind>\n  (\\<lambda>r.\n      exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1). return_spmf (r \\<in> dom s1)))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have game2a_bad: \"map_spmf snd game2_a = game2_a_bad\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd game2_a = game2_a_bad", "unfolding game2_a_def game2_a_bad_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf snd\n     (spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>r.\n          exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n          (\\<lambda>(((p0, p1), \\<sigma>), s1).\n              let bad = r \\<in> dom s1\n              in if valid_plain p0 \\<and> valid_plain p1\n                 then coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          let pb = if b then p0 else p1\n                          in prf.random_oracle s1 r \\<bind>\n                             (\\<lambda>(pad, s2).\n                                 let cipher = (r, pb [\\<oplus>] pad)\n                                 in exec_gpv rf_encrypt\n                                     (\\<A>2 cipher \\<sigma>) s2 \\<bind>\n                                    (\\<lambda>(b', s3).\n  return_spmf (b' = b, bad))))\n                 else coin_spmf \\<bind>\n                      (\\<lambda>b. return_spmf (b, bad))))) =\n    spmf_of_set (nlists UNIV len) \\<bind>\n    (\\<lambda>r.\n        exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n        (\\<lambda>(((p0, p1), \\<sigma>), s1). return_spmf (r \\<in> dom s1)))", "by(auto intro!: bind_spmf_cong[OF refl] simp add: o_def weight2 Let_def split_def split: if_split)"], ["proof (state)\nthis:\n  map_spmf snd game2_a = game2_a_bad\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have card: \"\\<And>B :: bool list set. card (B \\<inter> nlists UNIV len) \\<le> card (nlists UNIV len :: bool list set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B. card (B \\<inter> nlists UNIV len) \\<le> card (nlists UNIV len)", "by(rule card_mono) simp_all"], ["proof (state)\nthis:\n  card (?B7 \\<inter> nlists UNIV len) \\<le> card (nlists UNIV len)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "then"], ["proof (chain)\npicking this:\n  card (?B7 \\<inter> nlists UNIV len) \\<le> card (nlists UNIV len)", "have \"spmf game2_a_bad True = \\<integral>\\<^sup>+ x. card (dom (snd x) \\<inter> nlists UNIV len) / 2 ^ len \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\""], ["proof (prove)\nusing this:\n  card (?B7 \\<inter> nlists UNIV len) \\<le> card (nlists UNIV len)\n\ngoal (1 subgoal):\n 1. ennreal (spmf game2_a_bad True) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (real\n                              (card\n                                (dom (snd x) \\<inter> nlists UNIV len)) /\n                             2 ^ len)\n                       \\<partial>measure_spmf\n                                  (exec_gpv rf_encrypt \\<A>1 Map.empty)", "unfolding game2_a_bad_def"], ["proof (prove)\nusing this:\n  card (?B7 \\<inter> nlists UNIV len) \\<le> card (nlists UNIV len)\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (spmf_of_set (nlists UNIV len) \\<bind>\n        (\\<lambda>r.\n            exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n            (\\<lambda>(((p0, p1), \\<sigma>), s1).\n                return_spmf (r \\<in> dom s1))))\n       True) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (real\n                              (card\n                                (dom (snd x) \\<inter> nlists UNIV len)) /\n                             2 ^ len)\n                       \\<partial>measure_spmf\n                                  (exec_gpv rf_encrypt \\<A>1 Map.empty)", "by(rewrite bind_commute_spmf)(simp add: ennreal_spmf_bind split_def map_mem_spmf_of_set[unfolded map_spmf_conv_bind_spmf] card_nlists)"], ["proof (state)\nthis:\n  ennreal (spmf game2_a_bad True) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (real\n                            (card (dom (snd x) \\<inter> nlists UNIV len)) /\n                           2 ^ len)\n                     \\<partial>measure_spmf\n                                (exec_gpv rf_encrypt \\<A>1 Map.empty)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  ennreal (spmf game2_a_bad True) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (real\n                            (card (dom (snd x) \\<inter> nlists UNIV len)) /\n                           2 ^ len)\n                     \\<partial>measure_spmf\n                                (exec_gpv rf_encrypt \\<A>1 Map.empty)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "{"], ["proof (state)\nthis:\n  ennreal (spmf game2_a_bad True) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (real\n                            (card (dom (snd x) \\<inter> nlists UNIV len)) /\n                           2 ^ len)\n                     \\<partial>measure_spmf\n                                (exec_gpv rf_encrypt \\<A>1 Map.empty)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "fix x s"], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "assume *: \"(x, s) \\<in> set_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\""], ["proof (state)\nthis:\n  (x, s) \\<in> set_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "hence \"finite (dom s)\""], ["proof (prove)\nusing this:\n  (x, s) \\<in> set_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n\ngoal (1 subgoal):\n 1. finite (dom s)", "by(rule rf_finite.exec_gpv_invariant) simp_all"], ["proof (state)\nthis:\n  finite (dom s)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "hence 1: \"card (dom s \\<inter> nlists UNIV len) \\<le> card (dom s)\""], ["proof (prove)\nusing this:\n  finite (dom s)\n\ngoal (1 subgoal):\n 1. card (dom s \\<inter> nlists UNIV len) \\<le> card (dom s)", "by(intro card_mono) simp_all"], ["proof (state)\nthis:\n  card (dom s \\<inter> nlists UNIV len) \\<le> card (dom s)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "moreover"], ["proof (state)\nthis:\n  card (dom s \\<inter> nlists UNIV len) \\<le> card (dom s)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "from q1 *"], ["proof (chain)\npicking this:\n  interaction_bounded_by' (\\<lambda>_. True) \\<A>1 q1\n  (x, s) \\<in> set_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)", "have \"card (dom s) \\<le> q1 + card (dom (Map.empty :: (plain, plain) prf.dict))\""], ["proof (prove)\nusing this:\n  interaction_bounded_by' (\\<lambda>_. True) \\<A>1 q1\n  (x, s) \\<in> set_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n\ngoal (1 subgoal):\n 1. card (dom s) \\<le> q1 + card (dom Map.empty)", "by(rule rf_finite.interaction_bounded_by'_exec_gpv_count)\n        (auto simp add: rf_encrypt_def eSuc_enat prf.random_oracle_def card_insert_if split: option.split_asm if_split)"], ["proof (state)\nthis:\n  card (dom s) \\<le> q1 + card (dom Map.empty)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "ultimately"], ["proof (chain)\npicking this:\n  card (dom s \\<inter> nlists UNIV len) \\<le> card (dom s)\n  card (dom s) \\<le> q1 + card (dom Map.empty)", "have \"card (dom s \\<inter> nlists UNIV len) \\<le> q1\""], ["proof (prove)\nusing this:\n  card (dom s \\<inter> nlists UNIV len) \\<le> card (dom s)\n  card (dom s) \\<le> q1 + card (dom Map.empty)\n\ngoal (1 subgoal):\n 1. card (dom s \\<inter> nlists UNIV len) \\<le> q1", "by(simp)"], ["proof (state)\nthis:\n  card (dom s \\<inter> nlists UNIV len) \\<le> q1\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "}"], ["proof (state)\nthis:\n  (?x9, ?s9)\n  \\<in> set_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty) \\<Longrightarrow>\n  card (dom ?s9 \\<inter> nlists UNIV len) \\<le> q1\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "then"], ["proof (chain)\npicking this:\n  (?x9, ?s9)\n  \\<in> set_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty) \\<Longrightarrow>\n  card (dom ?s9 \\<inter> nlists UNIV len) \\<le> q1", "have \"\\<dots> \\<le>  \\<integral>\\<^sup>+ x. q1 / 2 ^ len \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\""], ["proof (prove)\nusing this:\n  (?x9, ?s9)\n  \\<in> set_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty) \\<Longrightarrow>\n  card (dom ?s9 \\<inter> nlists UNIV len) \\<le> q1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (real\n                              (card\n                                (dom (snd x) \\<inter> nlists UNIV len)) /\n                             2 ^ len)\n                       \\<partial>measure_spmf\n                                  (exec_gpv rf_encrypt \\<A>1 Map.empty)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (real q1 / 2 ^ len)\n                             \\<partial>measure_spmf\n  (exec_gpv rf_encrypt \\<A>1 Map.empty)", "by(intro nn_integral_mono_AE)(clarsimp simp add: field_simps)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (real\n                            (card (dom (snd x) \\<inter> nlists UNIV len)) /\n                           2 ^ len)\n                     \\<partial>measure_spmf\n                                (exec_gpv rf_encrypt \\<A>1 Map.empty)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (real q1 / 2 ^ len)\n                           \\<partial>measure_spmf\n(exec_gpv rf_encrypt \\<A>1 Map.empty)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (real\n                            (card (dom (snd x) \\<inter> nlists UNIV len)) /\n                           2 ^ len)\n                     \\<partial>measure_spmf\n                                (exec_gpv rf_encrypt \\<A>1 Map.empty)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (real q1 / 2 ^ len)\n                           \\<partial>measure_spmf\n(exec_gpv rf_encrypt \\<A>1 Map.empty)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> \\<le> q1 / 2 ^ len\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (real q1 / 2 ^ len)\n                       \\<partial>measure_spmf\n                                  (exec_gpv rf_encrypt \\<A>1 Map.empty)\n    \\<le> ennreal (real q1 / 2 ^ len)", "by(simp add: measure_spmf.emeasure_eq_measure field_simps mult_left_le weight1)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (real q1 / 2 ^ len)\n                     \\<partial>measure_spmf\n                                (exec_gpv rf_encrypt \\<A>1 Map.empty)\n  \\<le> ennreal (real q1 / 2 ^ len)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "finally"], ["proof (chain)\npicking this:\n  ennreal (spmf game2_a_bad True) \\<le> ennreal (real q1 / 2 ^ len)", "have game2a_bad_bound: \"spmf game2_a_bad True \\<le> q1 / 2 ^ len\""], ["proof (prove)\nusing this:\n  ennreal (spmf game2_a_bad True) \\<le> ennreal (real q1 / 2 ^ len)\n\ngoal (1 subgoal):\n 1. spmf game2_a_bad True \\<le> real q1 / 2 ^ len", "by simp"], ["proof (state)\nthis:\n  spmf game2_a_bad True \\<le> real q1 / 2 ^ len\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "define rf_encrypt_bad\n    where \"rf_encrypt_bad = (\\<lambda>secret (s :: (plain, plain) prf.dict, bad) plain. bind_spmf\n     (spmf_of_set (nlists UNIV len)) (\\<lambda>r.\n     bind_spmf (prf.random_oracle s r) (\\<lambda>(pad, s').\n     return_spmf ((r, xor_list plain pad), (s', bad \\<or> r = secret)))))\""], ["proof (state)\nthis:\n  rf_encrypt_bad =\n  (\\<lambda>secret (s, bad) plain.\n      spmf_of_set (nlists UNIV len) \\<bind>\n      (\\<lambda>r.\n          prf.random_oracle s r \\<bind>\n          (\\<lambda>(pad, s').\n              return_spmf\n               ((r, plain [\\<oplus>] pad), s', bad \\<or> r = secret))))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have rf_encrypt_bad_sticky [simp]: \"\\<And>s. callee_invariant (rf_encrypt_bad s) snd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. callee_invariant (rf_encrypt_bad s) snd", "by(unfold_locales)(auto simp add: rf_encrypt_bad_def)"], ["proof (state)\nthis:\n  callee_invariant (rf_encrypt_bad ?s7) snd\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have lossless_rf_encrypt [simp]: \"\\<And>challenge s plain. lossless_spmf (rf_encrypt_bad challenge s plain)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>challenge s plain.\n       lossless_spmf (rf_encrypt_bad challenge s plain)", "by(clarsimp simp add: rf_encrypt_bad_def prf.random_oracle_def split: option.split)"], ["proof (state)\nthis:\n  lossless_spmf (rf_encrypt_bad ?challenge7 ?s7 ?plain7)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "define game2_c where \"game2_c = do {\n    r \\<leftarrow> spmf_of_set (nlists UNIV len);\n    (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n    if valid_plain p0 \\<and> valid_plain p1 then do {\n      b \\<leftarrow> coin_spmf;\n      let pb = (if b then p0 else p1);\n      pad \\<leftarrow> spmf_of_set (nlists UNIV len);\n      let cipher = (r, xor_list pb pad);\n      (b', (s2, bad)) \\<leftarrow> exec_gpv (rf_encrypt_bad r) (\\<A>2 cipher \\<sigma>) (s1(r \\<mapsto> pad), False);\n      return_spmf (b' = b, bad)\n    } else coin_spmf \\<bind> (\\<lambda>b. return_spmf (b, False))\n  }\""], ["proof (state)\nthis:\n  game2_c =\n  spmf_of_set (nlists UNIV len) \\<bind>\n  (\\<lambda>r.\n      exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          if valid_plain p0 \\<and> valid_plain p1\n          then coin_spmf \\<bind>\n               (\\<lambda>b.\n                   let pb = if b then p0 else p1\n                   in spmf_of_set (nlists UNIV len) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv (rf_encrypt_bad r)\n                              (\\<A>2 cipher \\<sigma>)\n                              (s1(r \\<mapsto> pad), False) \\<bind>\n                             (\\<lambda>(b', s2, bad).\n                                 return_spmf (b' = b, bad))))\n          else coin_spmf \\<bind> (\\<lambda>b. return_spmf (b, False))))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have bisim2c_bad: \"\\<And>cipher \\<sigma> s x r. rel_spmf (\\<lambda>(x, _) (y, _). x = y)\n    (exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) (s(x \\<mapsto> r)))\n    (exec_gpv (rf_encrypt_bad x) (\\<A>2 cipher \\<sigma>) (s(x \\<mapsto> r), False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cipher \\<sigma> s x r.\n       rel_spmf (\\<lambda>(x, uu_) (y, uu_). x = y)\n        (exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) (s(x \\<mapsto> r)))\n        (exec_gpv (rf_encrypt_bad x) (\\<A>2 cipher \\<sigma>)\n          (s(x \\<mapsto> r), False))", "by(rule exec_gpv_oracle_bisim[where X=\"\\<lambda>s (s', _). s = s'\"])\n      (auto simp add: rf_encrypt_bad_def rf_encrypt_def intro!: rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  rel_spmf (\\<lambda>(x, uu_) (y, uu_). x = y)\n   (exec_gpv rf_encrypt (\\<A>2 ?cipher7 ?\\<sigma>7)\n     (?s7(?x7 \\<mapsto> ?r7)))\n   (exec_gpv (rf_encrypt_bad ?x7) (\\<A>2 ?cipher7 ?\\<sigma>7)\n     (?s7(?x7 \\<mapsto> ?r7), False))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have game2b_c [unfolded spmf_rel_eq]: \"rel_spmf (=) (map_spmf fst game2_b) (map_spmf fst game2_c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=) (map_spmf fst game2_b) (map_spmf fst game2_c)", "by(auto simp add: game2_b_def game2_c_def o_def split_def Let_def if_distribs intro!: rel_spmf_bind_reflI rel_spmf_bindI[OF bisim2c_bad])"], ["proof (state)\nthis:\n  map_spmf fst game2_b = map_spmf fst game2_c\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "define game2_d where \"game2_d = do {\n    r \\<leftarrow> spmf_of_set (nlists UNIV len);\n    (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n    if valid_plain p0 \\<and> valid_plain p1 then do {\n      b \\<leftarrow> coin_spmf;\n      let pb = (if b then p0 else p1);\n      pad \\<leftarrow> spmf_of_set (nlists UNIV len);\n      let cipher = (r, xor_list pb pad);\n      (b', (s2, bad)) \\<leftarrow> exec_gpv (rf_encrypt_bad r) (\\<A>2 cipher \\<sigma>) (s1, False);\n      return_spmf (b' = b, bad)\n    } else coin_spmf \\<bind> (\\<lambda>b. return_spmf (b, False))\n  }\""], ["proof (state)\nthis:\n  game2_d =\n  spmf_of_set (nlists UNIV len) \\<bind>\n  (\\<lambda>r.\n      exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          if valid_plain p0 \\<and> valid_plain p1\n          then coin_spmf \\<bind>\n               (\\<lambda>b.\n                   let pb = if b then p0 else p1\n                   in spmf_of_set (nlists UNIV len) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv (rf_encrypt_bad r)\n                              (\\<A>2 cipher \\<sigma>) (s1, False) \\<bind>\n                             (\\<lambda>(b', s2, bad).\n                                 return_spmf (b' = b, bad))))\n          else coin_spmf \\<bind> (\\<lambda>b. return_spmf (b, False))))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "{"], ["proof (state)\nthis:\n  game2_d =\n  spmf_of_set (nlists UNIV len) \\<bind>\n  (\\<lambda>r.\n      exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          if valid_plain p0 \\<and> valid_plain p1\n          then coin_spmf \\<bind>\n               (\\<lambda>b.\n                   let pb = if b then p0 else p1\n                   in spmf_of_set (nlists UNIV len) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv (rf_encrypt_bad r)\n                              (\\<A>2 cipher \\<sigma>) (s1, False) \\<bind>\n                             (\\<lambda>(b', s2, bad).\n                                 return_spmf (b' = b, bad))))\n          else coin_spmf \\<bind> (\\<lambda>b. return_spmf (b, False))))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "fix cipher \\<sigma> and x :: plain and s r"], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "let ?I = \"(\\<lambda>(x, s, bad) (y, s', bad'). (bad \\<longleftrightarrow> bad') \\<and> (\\<not> bad' \\<longrightarrow> x \\<longleftrightarrow> y))\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "let ?X = \"\\<lambda>(s, bad) (s', bad'). bad = bad' \\<and> (\\<forall>z. z \\<noteq> x \\<longrightarrow> s z = s' z)\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<And>s1 s2 x'. ?X s1 s2 \\<Longrightarrow> rel_spmf (\\<lambda>(a, s1') (b, s2'). snd s1' = snd s2' \\<and> (\\<not> snd s2' \\<longrightarrow> a = b \\<and> ?X s1' s2'))\n       (rf_encrypt_bad x s1 x') (rf_encrypt_bad x s2 x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2 x'.\n       (case s1 of\n        (s, bad) \\<Rightarrow>\n          \\<lambda>(s', bad').\n             bad = bad' \\<and>\n             (\\<forall>z. z \\<noteq> x \\<longrightarrow> s z = s' z))\n        s2 \\<Longrightarrow>\n       rel_spmf\n        (\\<lambda>(a, s1') (b, s2').\n            snd s1' = snd s2' \\<and>\n            (\\<not> snd s2' \\<longrightarrow>\n             a = b \\<and>\n             (case s1' of\n              (s, bad) \\<Rightarrow>\n                \\<lambda>(s', bad').\n                   bad = bad' \\<and>\n                   (\\<forall>z. z \\<noteq> x \\<longrightarrow> s z = s' z))\n              s2'))\n        (rf_encrypt_bad x s1 x') (rf_encrypt_bad x s2 x')", "by(case_tac \"x = x'\")(clarsimp simp add: rf_encrypt_bad_def prf.random_oracle_def rel_spmf_return_spmf1 rel_spmf_return_spmf2 Let_def split_def bind_UNION intro!: rel_spmf_bind_reflI split: option.split)+"], ["proof (state)\nthis:\n  (case ?s1.9 of\n   (s, bad) \\<Rightarrow>\n     \\<lambda>(s', bad').\n        bad = bad' \\<and>\n        (\\<forall>z. z \\<noteq> x \\<longrightarrow> s z = s' z))\n   ?s2.9 \\<Longrightarrow>\n  rel_spmf\n   (\\<lambda>(a, s1') (b, s2').\n       snd s1' = snd s2' \\<and>\n       (\\<not> snd s2' \\<longrightarrow>\n        a = b \\<and>\n        (case s1' of\n         (s, bad) \\<Rightarrow>\n           \\<lambda>(s', bad').\n              bad = bad' \\<and>\n              (\\<forall>z. z \\<noteq> x \\<longrightarrow> s z = s' z))\n         s2'))\n   (rf_encrypt_bad x ?s1.9 ?x'9) (rf_encrypt_bad x ?s2.9 ?x'9)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "with _ _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  (case ?s1.9 of\n   (s, bad) \\<Rightarrow>\n     \\<lambda>(s', bad').\n        bad = bad' \\<and>\n        (\\<forall>z. z \\<noteq> x \\<longrightarrow> s z = s' z))\n   ?s2.9 \\<Longrightarrow>\n  rel_spmf\n   (\\<lambda>(a, s1') (b, s2').\n       snd s1' = snd s2' \\<and>\n       (\\<not> snd s2' \\<longrightarrow>\n        a = b \\<and>\n        (case s1' of\n         (s, bad) \\<Rightarrow>\n           \\<lambda>(s', bad').\n              bad = bad' \\<and>\n              (\\<forall>z. z \\<noteq> x \\<longrightarrow> s z = s' z))\n         s2'))\n   (rf_encrypt_bad x ?s1.9 ?x'9) (rf_encrypt_bad x ?s2.9 ?x'9)", "have \"rel_spmf ?I\n             (exec_gpv (rf_encrypt_bad x) (\\<A>2 cipher \\<sigma>) (s(x \\<mapsto> r), False))\n             (exec_gpv (rf_encrypt_bad x) (\\<A>2 cipher \\<sigma>) (s, False))\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  (case ?s1.9 of\n   (s, bad) \\<Rightarrow>\n     \\<lambda>(s', bad').\n        bad = bad' \\<and>\n        (\\<forall>z. z \\<noteq> x \\<longrightarrow> s z = s' z))\n   ?s2.9 \\<Longrightarrow>\n  rel_spmf\n   (\\<lambda>(a, s1') (b, s2').\n       snd s1' = snd s2' \\<and>\n       (\\<not> snd s2' \\<longrightarrow>\n        a = b \\<and>\n        (case s1' of\n         (s, bad) \\<Rightarrow>\n           \\<lambda>(s', bad').\n              bad = bad' \\<and>\n              (\\<forall>z. z \\<noteq> x \\<longrightarrow> s z = s' z))\n         s2'))\n   (rf_encrypt_bad x ?s1.9 ?x'9) (rf_encrypt_bad x ?s2.9 ?x'9)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>(x, s, bad) (y, s', bad').\n         bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> x = y))\n     (exec_gpv (rf_encrypt_bad x) (\\<A>2 cipher \\<sigma>)\n       (s(x \\<mapsto> r), False))\n     (exec_gpv (rf_encrypt_bad x) (\\<A>2 cipher \\<sigma>) (s, False))", "by(rule exec_gpv_oracle_bisim_bad_full)(auto simp add: lossless2)"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(x, s, bad) (y, s', bad').\n       bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> x = y))\n   (exec_gpv (rf_encrypt_bad x) (\\<A>2 cipher \\<sigma>)\n     (s(x \\<mapsto> r), False))\n   (exec_gpv (rf_encrypt_bad x) (\\<A>2 cipher \\<sigma>) (s, False))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "}"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(x, s, bad) (y, s', bad').\n       bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> x = y))\n   (exec_gpv (rf_encrypt_bad ?x9) (\\<A>2 ?cipher9 ?\\<sigma>9)\n     (?s9(?x9 \\<mapsto> ?r9), False))\n   (exec_gpv (rf_encrypt_bad ?x9) (\\<A>2 ?cipher9 ?\\<sigma>9) (?s9, False))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "note bisim_bad = this"], ["proof (state)\nthis:\n  rel_spmf\n   (\\<lambda>(x, s, bad) (y, s', bad').\n       bad = bad' \\<and> (\\<not> bad' \\<longrightarrow> x = y))\n   (exec_gpv (rf_encrypt_bad ?x9) (\\<A>2 ?cipher9 ?\\<sigma>9)\n     (?s9(?x9 \\<mapsto> ?r9), False))\n   (exec_gpv (rf_encrypt_bad ?x9) (\\<A>2 ?cipher9 ?\\<sigma>9) (?s9, False))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have game2c_2d_bad [unfolded spmf_rel_eq]: \"rel_spmf (=) (map_spmf snd game2_c) (map_spmf snd game2_d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=) (map_spmf snd game2_c) (map_spmf snd game2_d)", "by(auto simp add: game2_c_def game2_d_def o_def Let_def split_def if_distribs intro!: rel_spmf_bind_reflI rel_spmf_bindI[OF bisim_bad])"], ["proof (state)\nthis:\n  map_spmf snd game2_c = map_spmf snd game2_d\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "moreover"], ["proof (state)\nthis:\n  map_spmf snd game2_c = map_spmf snd game2_d\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"rel_spmf (=) (map_spmf fst (game2_c \\<upharpoonleft> (snd -` {False}))) (map_spmf fst (game2_d \\<upharpoonleft> (snd -` {False})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=) (map_spmf fst (game2_c \\<upharpoonleft> (snd -` {False})))\n     (map_spmf fst (game2_d \\<upharpoonleft> (snd -` {False})))", "unfolding game2_c_def game2_d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (map_spmf fst\n       ((spmf_of_set (nlists UNIV len) \\<bind>\n         (\\<lambda>r.\n             exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n             (\\<lambda>(((p0, p1), \\<sigma>), s1).\n                 if valid_plain p0 \\<and> valid_plain p1\n                 then coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          let pb = if b then p0 else p1\n                          in spmf_of_set (nlists UNIV len) \\<bind>\n                             (\\<lambda>pad.\n                                 let cipher = (r, pb [\\<oplus>] pad)\n                                 in exec_gpv (rf_encrypt_bad r)\n                                     (\\<A>2 cipher \\<sigma>)\n                                     (s1(r \\<mapsto> pad), False) \\<bind>\n                                    (\\<lambda>(b', s2, bad).\n  return_spmf (b' = b, bad))))\n                 else coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          return_spmf (b, False))))) \\<upharpoonleft>\n        (snd -` {False})))\n     (map_spmf fst\n       ((spmf_of_set (nlists UNIV len) \\<bind>\n         (\\<lambda>r.\n             exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n             (\\<lambda>(((p0, p1), \\<sigma>), s1).\n                 if valid_plain p0 \\<and> valid_plain p1\n                 then coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          let pb = if b then p0 else p1\n                          in spmf_of_set (nlists UNIV len) \\<bind>\n                             (\\<lambda>pad.\n                                 let cipher = (r, pb [\\<oplus>] pad)\n                                 in exec_gpv (rf_encrypt_bad r)\n                                     (\\<A>2 cipher \\<sigma>)\n                                     (s1, False) \\<bind>\n                                    (\\<lambda>(b', s2, bad).\n  return_spmf (b' = b, bad))))\n                 else coin_spmf \\<bind>\n                      (\\<lambda>b.\n                          return_spmf (b, False))))) \\<upharpoonleft>\n        (snd -` {False})))", "by(clarsimp simp add: restrict_bind_spmf o_def Let_def if_distribs split_def restrict_return_spmf intro!: rel_spmf_bind_reflI rel_spmf_bindI[OF bisim_bad])"], ["proof (state)\nthis:\n  rel_spmf (=) (map_spmf fst (game2_c \\<upharpoonleft> (snd -` {False})))\n   (map_spmf fst (game2_d \\<upharpoonleft> (snd -` {False})))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "hence \"spmf game2_c (True, False) = spmf game2_d (True, False)\""], ["proof (prove)\nusing this:\n  rel_spmf (=) (map_spmf fst (game2_c \\<upharpoonleft> (snd -` {False})))\n   (map_spmf fst (game2_d \\<upharpoonleft> (snd -` {False})))\n\ngoal (1 subgoal):\n 1. spmf game2_c (True, False) = spmf game2_d (True, False)", "unfolding spmf_rel_eq"], ["proof (prove)\nusing this:\n  map_spmf fst (game2_c \\<upharpoonleft> (snd -` {False})) =\n  map_spmf fst (game2_d \\<upharpoonleft> (snd -` {False}))\n\ngoal (1 subgoal):\n 1. spmf game2_c (True, False) = spmf game2_d (True, False)", "by(subst (1 2) spmf_map_restrict[symmetric]) simp"], ["proof (state)\nthis:\n  spmf game2_c (True, False) = spmf game2_d (True, False)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "ultimately"], ["proof (chain)\npicking this:\n  map_spmf snd game2_c = map_spmf snd game2_d\n  spmf game2_c (True, False) = spmf game2_d (True, False)", "have game2c_2d: \"\\<bar>spmf (map_spmf fst game2_c) True - spmf (map_spmf fst game2_d) True\\<bar> \\<le> spmf (map_spmf snd game2_c) True\""], ["proof (prove)\nusing this:\n  map_spmf snd game2_c = map_spmf snd game2_d\n  spmf game2_c (True, False) = spmf game2_d (True, False)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_c) True -\n          spmf (map_spmf fst game2_d) True\\<bar>\n    \\<le> spmf (map_spmf snd game2_c) True", "apply(subst (1 2) spmf_conv_measure_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map_spmf snd game2_c = map_spmf snd game2_d;\n     spmf game2_c (True, False) = spmf game2_d (True, False)\\<rbrakk>\n    \\<Longrightarrow> \\<bar>Sigma_Algebra.measure\n                             (measure_spmf (map_spmf fst game2_c)) {True} -\n                            Sigma_Algebra.measure\n                             (measure_spmf (map_spmf fst game2_d))\n                             {True}\\<bar>\n                      \\<le> spmf (map_spmf snd game2_c) True", "apply(intro identical_until_bad)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_spmf snd game2_c = map_spmf snd game2_d;\n     spmf game2_c (True, False) = spmf game2_d (True, False)\\<rbrakk>\n    \\<Longrightarrow> map_spmf snd game2_c = map_spmf snd game2_d\n 2. \\<lbrakk>map_spmf snd game2_c = map_spmf snd game2_d;\n     spmf game2_c (True, False) = spmf game2_d (True, False)\\<rbrakk>\n    \\<Longrightarrow> Sigma_Algebra.measure\n                       (measure_spmf\n                         (map_spmf (\\<lambda>x. (fst x, snd x)) game2_c))\n                       ({True} \\<times> {False}) =\n                      Sigma_Algebra.measure\n                       (measure_spmf\n                         (map_spmf (\\<lambda>x. (fst x, snd x)) game2_d))\n                       ({True} \\<times> {False})", "apply(simp_all add: spmf.map_id[unfolded id_def] spmf_conv_measure_spmf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game2_c) True -\n        spmf (map_spmf fst game2_d) True\\<bar>\n  \\<le> spmf (map_spmf snd game2_c) True\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "{"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game2_c) True -\n        spmf (map_spmf fst game2_d) True\\<bar>\n  \\<le> spmf (map_spmf snd game2_c) True\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "fix cipher \\<sigma> and challenge :: plain and s"], ["proof (state)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"card (nlists UNIV len \\<inter> (\\<lambda>x. x = challenge) -` {True}) \\<le> card {challenge}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (nlists UNIV len \\<inter> (\\<lambda>x. x = challenge) -` {True})\n    \\<le> card {challenge}", "by(rule card_mono) auto"], ["proof (state)\nthis:\n  card (nlists UNIV len \\<inter> (\\<lambda>x. x = challenge) -` {True})\n  \\<le> card {challenge}\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "then"], ["proof (chain)\npicking this:\n  card (nlists UNIV len \\<inter> (\\<lambda>x. x = challenge) -` {True})\n  \\<le> card {challenge}", "have \"spmf (map_spmf (snd \\<circ> snd) (exec_gpv (rf_encrypt_bad challenge) (\\<A>2 cipher \\<sigma>) (s, False))) True \\<le> (1 / 2 ^ len) * q2\""], ["proof (prove)\nusing this:\n  card (nlists UNIV len \\<inter> (\\<lambda>x. x = challenge) -` {True})\n  \\<le> card {challenge}\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf (snd \\<circ> snd)\n       (exec_gpv (rf_encrypt_bad challenge) (\\<A>2 cipher \\<sigma>)\n         (s, False)))\n     True\n    \\<le> 1 / 2 ^ len * real q2", "by(intro oi_True.interaction_bounded_by_exec_gpv_bad[OF q2])(simp_all add: rf_encrypt_bad_def o_def split_beta map_spmf_conv_bind_spmf[symmetric] spmf_map measure_spmf_of_set field_simps card_nlists)"], ["proof (state)\nthis:\n  spmf\n   (map_spmf (snd \\<circ> snd)\n     (exec_gpv (rf_encrypt_bad challenge) (\\<A>2 cipher \\<sigma>)\n       (s, False)))\n   True\n  \\<le> 1 / 2 ^ len * real q2\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "hence \"(\\<integral>\\<^sup>+ x. ennreal (indicator {True} x) \\<partial>measure_spmf (map_spmf (snd \\<circ> snd) (exec_gpv (rf_encrypt_bad challenge) (\\<A>2 cipher \\<sigma>) (s, False)))) \\<le> (1 / 2 ^ len) * q2\""], ["proof (prove)\nusing this:\n  spmf\n   (map_spmf (snd \\<circ> snd)\n     (exec_gpv (rf_encrypt_bad challenge) (\\<A>2 cipher \\<sigma>)\n       (s, False)))\n   True\n  \\<le> 1 / 2 ^ len * real q2\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real {True} x)\n                       \\<partial>measure_spmf\n                                  (map_spmf (snd \\<circ> snd)\n                                    (exec_gpv (rf_encrypt_bad challenge)\n(\\<A>2 cipher \\<sigma>) (s, False)))\n    \\<le> ennreal (1 / 2 ^ len * real q2)", "by(simp only: ennreal_indicator nn_integral_indicator sets_measure_spmf sets_count_space Pow_UNIV UNIV_I emeasure_spmf_single) simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real {True} x)\n                     \\<partial>measure_spmf\n                                (map_spmf (snd \\<circ> snd)\n                                  (exec_gpv (rf_encrypt_bad challenge)\n                                    (\\<A>2 cipher \\<sigma>) (s, False)))\n  \\<le> ennreal (1 / 2 ^ len * real q2)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "}"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real {True} x)\n                     \\<partial>measure_spmf\n                                (map_spmf (snd \\<circ> snd)\n                                  (exec_gpv (rf_encrypt_bad ?challenge9)\n                                    (\\<A>2 ?cipher9 ?\\<sigma>9)\n                                    (?s9, False)))\n  \\<le> ennreal (1 / 2 ^ len * real q2)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "then"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real {True} x)\n                     \\<partial>measure_spmf\n                                (map_spmf (snd \\<circ> snd)\n                                  (exec_gpv (rf_encrypt_bad ?challenge9)\n                                    (\\<A>2 ?cipher9 ?\\<sigma>9)\n                                    (?s9, False)))\n  \\<le> ennreal (1 / 2 ^ len * real q2)", "have \"spmf (map_spmf snd game2_d) True \\<le>\n        \\<integral>\\<^sup>+ (r :: plain). \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>), s). (if valid_plain p0 \\<and> valid_plain p1 then\n             \\<integral>\\<^sup>+ b . \\<integral>\\<^sup>+ (pad :: plain). q2 / 2 ^ len \\<partial>measure_spmf (spmf_of_set (nlists UNIV len)) \\<partial>measure_spmf coin_spmf\n              else 0)\n           \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty) \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real {True} x)\n                     \\<partial>measure_spmf\n                                (map_spmf (snd \\<circ> snd)\n                                  (exec_gpv (rf_encrypt_bad ?challenge9)\n                                    (\\<A>2 ?cipher9 ?\\<sigma>9)\n                                    (?s9, False)))\n  \\<le> ennreal (1 / 2 ^ len * real q2)\n\ngoal (1 subgoal):\n 1. ennreal (spmf (map_spmf snd game2_d) True)\n    \\<le> \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>),\n                s).\n                (if valid_plain p0 \\<and> valid_plain p1\n                 then \\<integral>\\<^sup>+ b.\n     \\<integral>\\<^sup>+ x. ennreal (real q2 / 2 ^ len)\n                        \\<partial>measure_spmf\n                                   (spmf_of_set (nlists UNIV len))\n   \\<partial>measure_spmf coin_spmf\n                 else 0)\n              \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                             \\<partial>measure_spmf\n  (spmf_of_set (nlists UNIV len))", "unfolding game2_d_def"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real {True} x)\n                     \\<partial>measure_spmf\n                                (map_spmf (snd \\<circ> snd)\n                                  (exec_gpv (rf_encrypt_bad ?challenge9)\n                                    (\\<A>2 ?cipher9 ?\\<sigma>9)\n                                    (?s9, False)))\n  \\<le> ennreal (1 / 2 ^ len * real q2)\n\ngoal (1 subgoal):\n 1. ennreal\n     (spmf\n       (map_spmf snd\n         (spmf_of_set (nlists UNIV len) \\<bind>\n          (\\<lambda>r.\n              exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n              (\\<lambda>(((p0, p1), \\<sigma>), s1).\n                  if valid_plain p0 \\<and> valid_plain p1\n                  then coin_spmf \\<bind>\n                       (\\<lambda>b.\n                           let pb = if b then p0 else p1\n                           in spmf_of_set (nlists UNIV len) \\<bind>\n                              (\\<lambda>pad.\n                                  let cipher = (r, pb [\\<oplus>] pad)\n                                  in exec_gpv (rf_encrypt_bad r)\n(\\<A>2 cipher \\<sigma>) (s1, False) \\<bind>\n                                     (\\<lambda>(b', s2, bad).\n   return_spmf (b' = b, bad))))\n                  else coin_spmf \\<bind>\n                       (\\<lambda>b. return_spmf (b, False))))))\n       True)\n    \\<le> \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>),\n                s).\n                (if valid_plain p0 \\<and> valid_plain p1\n                 then \\<integral>\\<^sup>+ b.\n     \\<integral>\\<^sup>+ x. ennreal (real q2 / 2 ^ len)\n                        \\<partial>measure_spmf\n                                   (spmf_of_set (nlists UNIV len))\n   \\<partial>measure_spmf coin_spmf\n                 else 0)\n              \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                             \\<partial>measure_spmf\n  (spmf_of_set (nlists UNIV len))", "by(simp add: ennreal_spmf_bind o_def split_def Let_def if_distribs if_distrib[where f=\"\\<lambda>x. ennreal (spmf x _)\"] indicator_single_Some nn_integral_mono if_mono_cong del: nn_integral_const cong: if_cong)"], ["proof (state)\nthis:\n  ennreal (spmf (map_spmf snd game2_d) True)\n  \\<le> \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>),\n              s).\n              (if valid_plain p0 \\<and> valid_plain p1\n               then \\<integral>\\<^sup>+ b.\n   \\<integral>\\<^sup>+ x. ennreal (real q2 / 2 ^ len)\n                      \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\n \\<partial>measure_spmf coin_spmf\n               else 0)\n            \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                           \\<partial>measure_spmf\n(spmf_of_set (nlists UNIV len))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  ennreal (spmf (map_spmf snd game2_d) True)\n  \\<le> \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>),\n              s).\n              (if valid_plain p0 \\<and> valid_plain p1\n               then \\<integral>\\<^sup>+ b.\n   \\<integral>\\<^sup>+ x. ennreal (real q2 / 2 ^ len)\n                      \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\n \\<partial>measure_spmf coin_spmf\n               else 0)\n            \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                           \\<partial>measure_spmf\n(spmf_of_set (nlists UNIV len))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ (r :: plain). \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>), s). (if valid_plain p0 \\<and> valid_plain p1 then ennreal (q2 / 2 ^ len) else q2 / 2 ^ len)\n                   \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty) \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>), s).\n          (if valid_plain p0 \\<and> valid_plain p1\n           then \\<integral>\\<^sup>+ b. \\<integral>\\<^sup>+ x.\n                      ennreal (real q2 / 2 ^ len)\n                    \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\n                                   \\<partial>measure_spmf coin_spmf\n           else 0)\n        \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                       \\<partial>measure_spmf\n                                  (spmf_of_set (nlists UNIV len))\n    \\<le> \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>),\n                s).\n                (if valid_plain p0 \\<and> valid_plain p1\n                 then ennreal (real q2 / 2 ^ len)\n                 else ennreal (real q2 / 2 ^ len))\n              \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                             \\<partial>measure_spmf\n  (spmf_of_set (nlists UNIV len))", "unfolding split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ p.\n          (if valid_plain (fst (fst (fst p))) \\<and>\n              valid_plain (snd (fst (fst p)))\n           then \\<integral>\\<^sup>+ b. \\<integral>\\<^sup>+ x.\n                      ennreal (real q2 / 2 ^ len)\n                    \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\n                                   \\<partial>measure_spmf coin_spmf\n           else 0)\n        \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                       \\<partial>measure_spmf\n                                  (spmf_of_set (nlists UNIV len))\n    \\<le> \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ p.\n                (if valid_plain (fst (fst (fst p))) \\<and>\n                    valid_plain (snd (fst (fst p)))\n                 then ennreal (real q2 / 2 ^ len)\n                 else ennreal (real q2 / 2 ^ len))\n              \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                             \\<partial>measure_spmf\n  (spmf_of_set (nlists UNIV len))", "by(intro nn_integral_mono if_mono_cong)(auto simp add: measure_spmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>), s).\n        (if valid_plain p0 \\<and> valid_plain p1\n         then \\<integral>\\<^sup>+ b. \\<integral>\\<^sup>+ x.\n                    ennreal (real q2 / 2 ^ len)\n                  \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\n                                 \\<partial>measure_spmf coin_spmf\n         else 0)\n      \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                     \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\n  \\<le> \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>),\n              s).\n              (if valid_plain p0 \\<and> valid_plain p1\n               then ennreal (real q2 / 2 ^ len)\n               else ennreal (real q2 / 2 ^ len))\n            \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                           \\<partial>measure_spmf\n(spmf_of_set (nlists UNIV len))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>), s).\n        (if valid_plain p0 \\<and> valid_plain p1\n         then \\<integral>\\<^sup>+ b. \\<integral>\\<^sup>+ x.\n                    ennreal (real q2 / 2 ^ len)\n                  \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\n                                 \\<partial>measure_spmf coin_spmf\n         else 0)\n      \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                     \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\n  \\<le> \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>),\n              s).\n              (if valid_plain p0 \\<and> valid_plain p1\n               then ennreal (real q2 / 2 ^ len)\n               else ennreal (real q2 / 2 ^ len))\n            \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                           \\<partial>measure_spmf\n(spmf_of_set (nlists UNIV len))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> \\<le> q2 / 2 ^ len\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>), s).\n          (if valid_plain p0 \\<and> valid_plain p1\n           then ennreal (real q2 / 2 ^ len)\n           else ennreal (real q2 / 2 ^ len))\n        \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                       \\<partial>measure_spmf\n                                  (spmf_of_set (nlists UNIV len))\n    \\<le> ennreal (real q2 / 2 ^ len)", "by(simp add: split_def weight1 measure_spmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ r. \\<integral>\\<^sup>+ (((p0, p1), \\<sigma>), s).\n        (if valid_plain p0 \\<and> valid_plain p1\n         then ennreal (real q2 / 2 ^ len) else ennreal (real q2 / 2 ^ len))\n      \\<partial>measure_spmf (exec_gpv rf_encrypt \\<A>1 Map.empty)\n                     \\<partial>measure_spmf (spmf_of_set (nlists UNIV len))\n  \\<le> ennreal (real q2 / 2 ^ len)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "finally"], ["proof (chain)\npicking this:\n  ennreal (spmf (map_spmf snd game2_d) True)\n  \\<le> ennreal (real q2 / 2 ^ len)", "have game2_d_bad: \"spmf (map_spmf snd game2_d) True \\<le> q2 / 2 ^ len\""], ["proof (prove)\nusing this:\n  ennreal (spmf (map_spmf snd game2_d) True)\n  \\<le> ennreal (real q2 / 2 ^ len)\n\ngoal (1 subgoal):\n 1. spmf (map_spmf snd game2_d) True \\<le> real q2 / 2 ^ len", "by simp"], ["proof (state)\nthis:\n  spmf (map_spmf snd game2_d) True \\<le> real q2 / 2 ^ len\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "define game3 where \"game3 = do {\n      (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n      if valid_plain p0 \\<and> valid_plain p1 then do {\n        b \\<leftarrow> coin_spmf;\n        let pb = (if b then p0 else p1);\n        r \\<leftarrow> spmf_of_set (nlists UNIV len);\n        pad \\<leftarrow> spmf_of_set (nlists UNIV len);\n        let cipher = (r, xor_list pb pad);\n        (b', s2) \\<leftarrow> exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s1;\n        return_spmf (b' = b)\n      } else coin_spmf\n    }\""], ["proof (state)\nthis:\n  game3 =\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then coin_spmf \\<bind>\n           (\\<lambda>b.\n               let pb = if b then p0 else p1\n               in spmf_of_set (nlists UNIV len) \\<bind>\n                  (\\<lambda>r.\n                      spmf_of_set (nlists UNIV len) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s1 \\<bind>\n                             (\\<lambda>(b', s2). return_spmf (b' = b)))))\n      else coin_spmf)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have bisim2d_3: \"\\<And>cipher \\<sigma> s r. rel_spmf (\\<lambda>(x, _) (y, _). x = y)\n             (exec_gpv (rf_encrypt_bad r) (\\<A>2 cipher \\<sigma>) (s, False))\n             (exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cipher \\<sigma> s r.\n       rel_spmf (\\<lambda>(x, uu_) (y, uu_). x = y)\n        (exec_gpv (rf_encrypt_bad r) (\\<A>2 cipher \\<sigma>) (s, False))\n        (exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s)", "by(rule exec_gpv_oracle_bisim[where X=\"\\<lambda>(s1, _) s2. s1 = s2\"])(auto simp add: rf_encrypt_bad_def rf_encrypt_def intro!: rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  rel_spmf (\\<lambda>(x, uu_) (y, uu_). x = y)\n   (exec_gpv (rf_encrypt_bad ?r7) (\\<A>2 ?cipher7 ?\\<sigma>7) (?s7, False))\n   (exec_gpv rf_encrypt (\\<A>2 ?cipher7 ?\\<sigma>7) ?s7)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have game2d_3: \"rel_spmf (=) (map_spmf fst game2_d) game3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=) (map_spmf fst game2_d) game3", "unfolding game2_d_def game3_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (map_spmf fst\n       (spmf_of_set (nlists UNIV len) \\<bind>\n        (\\<lambda>r.\n            exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n            (\\<lambda>(((p0, p1), \\<sigma>), s1).\n                if valid_plain p0 \\<and> valid_plain p1\n                then coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         spmf_of_set (nlists UNIV len) \\<bind>\n                         (\\<lambda>pad.\n                             exec_gpv (rf_encrypt_bad r)\n                              (\\<A>2\n                                (r, (if b then p0 else p1) [\\<oplus>] pad)\n                                \\<sigma>)\n                              (s1, False) \\<bind>\n                             (\\<lambda>(b', s2, bad).\n                                 return_spmf (b' = b, bad))))\n                else coin_spmf \\<bind>\n                     (\\<lambda>b. return_spmf (b, False))))))\n     (exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          if valid_plain p0 \\<and> valid_plain p1\n          then coin_spmf \\<bind>\n               (\\<lambda>b.\n                   spmf_of_set (nlists UNIV len) \\<bind>\n                   (\\<lambda>r.\n                       spmf_of_set (nlists UNIV len) \\<bind>\n                       (\\<lambda>pad.\n                           exec_gpv rf_encrypt\n                            (\\<A>2\n                              (r, (if b then p0 else p1) [\\<oplus>] pad)\n                              \\<sigma>)\n                            s1 \\<bind>\n                           (\\<lambda>(b', s2). return_spmf (b' = b)))))\n          else coin_spmf))", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (map_spmf fst\n       (spmf_of_set (nlists UNIV len) \\<bind>\n        (\\<lambda>r.\n            exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n            (\\<lambda>(((p0, p1), \\<sigma>), s1).\n                if valid_plain p0 \\<and> valid_plain p1\n                then coin_spmf \\<bind>\n                     (\\<lambda>b.\n                         spmf_of_set (nlists UNIV len) \\<bind>\n                         (\\<lambda>pad.\n                             exec_gpv (rf_encrypt_bad r)\n                              (\\<A>2\n                                (r, (if b then p0 else p1) [\\<oplus>] pad)\n                                \\<sigma>)\n                              (s1, False) \\<bind>\n                             (\\<lambda>(b', s2, bad).\n                                 return_spmf (b' = b, bad))))\n                else coin_spmf \\<bind>\n                     (\\<lambda>b. return_spmf (b, False))))))\n     (exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n      (\\<lambda>(((p0, p1), \\<sigma>), s1).\n          if valid_plain p0 \\<and> valid_plain p1\n          then coin_spmf \\<bind>\n               (\\<lambda>b.\n                   spmf_of_set (nlists UNIV len) \\<bind>\n                   (\\<lambda>r.\n                       spmf_of_set (nlists UNIV len) \\<bind>\n                       (\\<lambda>pad.\n                           exec_gpv rf_encrypt\n                            (\\<A>2\n                              (r, (if b then p0 else p1) [\\<oplus>] pad)\n                              \\<sigma>)\n                            s1 \\<bind>\n                           (\\<lambda>(b', s2). return_spmf (b' = b)))))\n          else coin_spmf))", "by(clarsimp simp add: o_def split_def if_distribs cong: if_cong intro!: rel_spmf_bind_reflI rel_spmf_bindI[OF bisim2d_3])"], ["proof (state)\nthis:\n  rel_spmf (=) (map_spmf fst game2_d) game3\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<bar>spmf game2 True - 1 / 2\\<bar> \\<le>\n    \\<bar>spmf (map_spmf fst game2_a) True - spmf (map_spmf fst game2_b) True\\<bar> + \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf game2 True - 1 / 2\\<bar>\n    \\<le> \\<bar>spmf (map_spmf fst game2_a) True -\n                spmf (map_spmf fst game2_b) True\\<bar> +\n          \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>", "unfolding game2_2a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_a) True - 1 / 2\\<bar>\n    \\<le> \\<bar>spmf (map_spmf fst game2_a) True -\n                spmf (map_spmf fst game2_b) True\\<bar> +\n          \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>", "by(rule abs_diff_triangle_ineq2)"], ["proof (state)\nthis:\n  \\<bar>spmf game2 True - 1 / 2\\<bar>\n  \\<le> \\<bar>spmf (map_spmf fst game2_a) True -\n              spmf (map_spmf fst game2_b) True\\<bar> +\n        \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  \\<bar>spmf game2 True - 1 / 2\\<bar>\n  \\<le> \\<bar>spmf (map_spmf fst game2_a) True -\n              spmf (map_spmf fst game2_b) True\\<bar> +\n        \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> \\<le> q1 / 2 ^ len + \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_a) True -\n          spmf (map_spmf fst game2_b) True\\<bar> +\n    \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n    \\<le> real q1 / 2 ^ len +\n          \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>", "using game2a_2b game2a_bad_bound"], ["proof (prove)\nusing this:\n  \\<bar>spmf (map_spmf fst game2_a) True -\n        spmf (map_spmf fst game2_b) True\\<bar>\n  \\<le> spmf (map_spmf snd game2_a) True\n  spmf game2_a_bad True \\<le> real q1 / 2 ^ len\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_a) True -\n          spmf (map_spmf fst game2_b) True\\<bar> +\n    \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n    \\<le> real q1 / 2 ^ len +\n          \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>", "unfolding game2a_bad"], ["proof (prove)\nusing this:\n  \\<bar>spmf (map_spmf fst game2_a) True -\n        spmf (map_spmf fst game2_b) True\\<bar>\n  \\<le> spmf game2_a_bad True\n  spmf game2_a_bad True \\<le> real q1 / 2 ^ len\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_a) True -\n          spmf (map_spmf fst game2_b) True\\<bar> +\n    \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n    \\<le> real q1 / 2 ^ len +\n          \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>", "by(intro add_right_mono) simp"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game2_a) True -\n        spmf (map_spmf fst game2_b) True\\<bar> +\n  \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n  \\<le> real q1 / 2 ^ len +\n        \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game2_a) True -\n        spmf (map_spmf fst game2_b) True\\<bar> +\n  \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n  \\<le> real q1 / 2 ^ len +\n        \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar> \\<le>\n    \\<bar>spmf (map_spmf fst game2_c) True - spmf (map_spmf fst game2_d) True\\<bar> + \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n    \\<le> \\<bar>spmf (map_spmf fst game2_c) True -\n                spmf (map_spmf fst game2_d) True\\<bar> +\n          \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>", "unfolding game2b_c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_c) True - 1 / 2\\<bar>\n    \\<le> \\<bar>spmf (map_spmf fst game2_c) True -\n                spmf (map_spmf fst game2_d) True\\<bar> +\n          \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>", "by(rule abs_diff_triangle_ineq2)"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n  \\<le> \\<bar>spmf (map_spmf fst game2_c) True -\n              spmf (map_spmf fst game2_d) True\\<bar> +\n        \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also (add_left_mono_trans)"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game2_b) True - 1 / 2\\<bar>\n  \\<le> \\<bar>spmf (map_spmf fst game2_c) True -\n              spmf (map_spmf fst game2_d) True\\<bar> +\n        \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> \\<le> q2 / 2 ^ len + \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_c) True -\n          spmf (map_spmf fst game2_d) True\\<bar> +\n    \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>\n    \\<le> real q2 / 2 ^ len +\n          \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>", "using game2c_2d game2_d_bad"], ["proof (prove)\nusing this:\n  \\<bar>spmf (map_spmf fst game2_c) True -\n        spmf (map_spmf fst game2_d) True\\<bar>\n  \\<le> spmf (map_spmf snd game2_c) True\n  spmf (map_spmf snd game2_d) True \\<le> real q2 / 2 ^ len\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_c) True -\n          spmf (map_spmf fst game2_d) True\\<bar> +\n    \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>\n    \\<le> real q2 / 2 ^ len +\n          \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>", "unfolding game2c_2d_bad"], ["proof (prove)\nusing this:\n  \\<bar>spmf (map_spmf fst game2_c) True -\n        spmf (map_spmf fst game2_d) True\\<bar>\n  \\<le> spmf (map_spmf snd game2_d) True\n  spmf (map_spmf snd game2_d) True \\<le> real q2 / 2 ^ len\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (map_spmf fst game2_c) True -\n          spmf (map_spmf fst game2_d) True\\<bar> +\n    \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>\n    \\<le> real q2 / 2 ^ len +\n          \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>", "by(intro add_right_mono) simp"], ["proof (state)\nthis:\n  \\<bar>spmf (map_spmf fst game2_c) True -\n        spmf (map_spmf fst game2_d) True\\<bar> +\n  \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>\n  \\<le> real q2 / 2 ^ len +\n        \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "finally (add_left_mono_trans)"], ["proof (chain)\npicking this:\n  \\<bar>spmf game2 True - 1 / 2\\<bar>\n  \\<le> real q1 / 2 ^ len +\n        (real q2 / 2 ^ len +\n         \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>)", "have game2: \"\\<bar>spmf game2 True - 1 / 2\\<bar> \\<le> q1 / 2 ^ len + q2 / 2 ^ len +  \\<bar>spmf game3 True - 1 / 2\\<bar>\""], ["proof (prove)\nusing this:\n  \\<bar>spmf game2 True - 1 / 2\\<bar>\n  \\<le> real q1 / 2 ^ len +\n        (real q2 / 2 ^ len +\n         \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf game2 True - 1 / 2\\<bar>\n    \\<le> real q1 / 2 ^ len + real q2 / 2 ^ len +\n          \\<bar>spmf game3 True - 1 / 2\\<bar>", "using game2d_3"], ["proof (prove)\nusing this:\n  \\<bar>spmf game2 True - 1 / 2\\<bar>\n  \\<le> real q1 / 2 ^ len +\n        (real q2 / 2 ^ len +\n         \\<bar>spmf (map_spmf fst game2_d) True - 1 / 2\\<bar>)\n  rel_spmf (=) (map_spmf fst game2_d) game3\n\ngoal (1 subgoal):\n 1. \\<bar>spmf game2 True - 1 / 2\\<bar>\n    \\<le> real q1 / 2 ^ len + real q2 / 2 ^ len +\n          \\<bar>spmf game3 True - 1 / 2\\<bar>", "by(simp add: field_simps spmf_rel_eq)"], ["proof (state)\nthis:\n  \\<bar>spmf game2 True - 1 / 2\\<bar>\n  \\<le> real q1 / 2 ^ len + real q2 / 2 ^ len +\n        \\<bar>spmf game3 True - 1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"game3 = do {\n      (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n      if valid_plain p0 \\<and> valid_plain p1 then do {\n        b \\<leftarrow> coin_spmf;\n        let pb = (if b then p0 else p1);\n        r \\<leftarrow> spmf_of_set (nlists UNIV len);\n        pad \\<leftarrow> map_spmf (xor_list pb) (spmf_of_set (nlists UNIV len));\n        let cipher = (r, xor_list pb pad);\n        (b', s2) \\<leftarrow> exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s1;\n        return_spmf (b' = b)\n      } else coin_spmf\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. game3 =\n    exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n    (\\<lambda>(((p0, p1), \\<sigma>), s1).\n        if valid_plain p0 \\<and> valid_plain p1\n        then coin_spmf \\<bind>\n             (\\<lambda>b.\n                 let pb = if b then p0 else p1\n                 in spmf_of_set (nlists UNIV len) \\<bind>\n                    (\\<lambda>r.\n                        map_spmf (([\\<oplus>]) pb)\n                         (spmf_of_set (nlists UNIV len)) \\<bind>\n                        (\\<lambda>pad.\n                            let cipher = (r, pb [\\<oplus>] pad)\n                            in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                s1 \\<bind>\n                               (\\<lambda>(b', s2). return_spmf (b' = b)))))\n        else coin_spmf)", "by(simp add: valid_plain_def game3_def Let_def one_time_pad del: bind_map_spmf map_spmf_of_set_inj_on cong: bind_spmf_cong_simp if_cong split: if_split)"], ["proof (state)\nthis:\n  game3 =\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then coin_spmf \\<bind>\n           (\\<lambda>b.\n               let pb = if b then p0 else p1\n               in spmf_of_set (nlists UNIV len) \\<bind>\n                  (\\<lambda>r.\n                      map_spmf (([\\<oplus>]) pb)\n                       (spmf_of_set (nlists UNIV len)) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s1 \\<bind>\n                             (\\<lambda>(b', s2). return_spmf (b' = b)))))\n      else coin_spmf)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  game3 =\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then coin_spmf \\<bind>\n           (\\<lambda>b.\n               let pb = if b then p0 else p1\n               in spmf_of_set (nlists UNIV len) \\<bind>\n                  (\\<lambda>r.\n                      map_spmf (([\\<oplus>]) pb)\n                       (spmf_of_set (nlists UNIV len)) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s1 \\<bind>\n                             (\\<lambda>(b', s2). return_spmf (b' = b)))))\n      else coin_spmf)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> = do {\n       (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n       if valid_plain p0 \\<and> valid_plain p1 then do {\n         b \\<leftarrow> coin_spmf;\n         let pb = (if b then p0 else p1);\n         r \\<leftarrow> spmf_of_set (nlists UNIV len);\n         pad \\<leftarrow> spmf_of_set (nlists UNIV len);\n         let cipher = (r, pad);\n         (b', _) \\<leftarrow> exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s1;\n         return_spmf (b' = b)\n       } else coin_spmf\n     }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n    (\\<lambda>(((p0, p1), \\<sigma>), s1).\n        if valid_plain p0 \\<and> valid_plain p1\n        then coin_spmf \\<bind>\n             (\\<lambda>b.\n                 let pb = if b then p0 else p1\n                 in spmf_of_set (nlists UNIV len) \\<bind>\n                    (\\<lambda>r.\n                        map_spmf (([\\<oplus>]) pb)\n                         (spmf_of_set (nlists UNIV len)) \\<bind>\n                        (\\<lambda>pad.\n                            let cipher = (r, pb [\\<oplus>] pad)\n                            in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                s1 \\<bind>\n                               (\\<lambda>(b', s2). return_spmf (b' = b)))))\n        else coin_spmf) =\n    exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n    (\\<lambda>(((p0, p1), \\<sigma>), s1).\n        if valid_plain p0 \\<and> valid_plain p1\n        then coin_spmf \\<bind>\n             (\\<lambda>b.\n                 let pb = if b then p0 else p1\n                 in spmf_of_set (nlists UNIV len) \\<bind>\n                    (\\<lambda>r.\n                        spmf_of_set (nlists UNIV len) \\<bind>\n                        (\\<lambda>pad.\n                            let cipher = (r, pad)\n                            in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                s1 \\<bind>\n                               (\\<lambda>(b', uu_). return_spmf (b' = b)))))\n        else coin_spmf)", "by(simp add: game3_def Let_def valid_plain_def in_nlists_UNIV cong: bind_spmf_cong_simp if_cong split: if_split)"], ["proof (state)\nthis:\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then coin_spmf \\<bind>\n           (\\<lambda>b.\n               let pb = if b then p0 else p1\n               in spmf_of_set (nlists UNIV len) \\<bind>\n                  (\\<lambda>r.\n                      map_spmf (([\\<oplus>]) pb)\n                       (spmf_of_set (nlists UNIV len)) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s1 \\<bind>\n                             (\\<lambda>(b', s2). return_spmf (b' = b)))))\n      else coin_spmf) =\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then coin_spmf \\<bind>\n           (\\<lambda>b.\n               let pb = if b then p0 else p1\n               in spmf_of_set (nlists UNIV len) \\<bind>\n                  (\\<lambda>r.\n                      spmf_of_set (nlists UNIV len) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s1 \\<bind>\n                             (\\<lambda>(b', uu_). return_spmf (b' = b)))))\n      else coin_spmf)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then coin_spmf \\<bind>\n           (\\<lambda>b.\n               let pb = if b then p0 else p1\n               in spmf_of_set (nlists UNIV len) \\<bind>\n                  (\\<lambda>r.\n                      map_spmf (([\\<oplus>]) pb)\n                       (spmf_of_set (nlists UNIV len)) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pb [\\<oplus>] pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s1 \\<bind>\n                             (\\<lambda>(b', s2). return_spmf (b' = b)))))\n      else coin_spmf) =\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then coin_spmf \\<bind>\n           (\\<lambda>b.\n               let pb = if b then p0 else p1\n               in spmf_of_set (nlists UNIV len) \\<bind>\n                  (\\<lambda>r.\n                      spmf_of_set (nlists UNIV len) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s1 \\<bind>\n                             (\\<lambda>(b', uu_). return_spmf (b' = b)))))\n      else coin_spmf)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> = do {\n      (((p0, p1), \\<sigma>), s1) \\<leftarrow> exec_gpv rf_encrypt \\<A>1 Map.empty;\n      if valid_plain p0 \\<and> valid_plain p1 then do {\n        r \\<leftarrow> spmf_of_set (nlists UNIV len);\n        pad \\<leftarrow> spmf_of_set (nlists UNIV len);\n        let cipher = (r, pad);\n        (b', _) \\<leftarrow> exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s1;\n        map_spmf ((=) b') coin_spmf\n      } else coin_spmf\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n    (\\<lambda>(((p0, p1), \\<sigma>), s1).\n        if valid_plain p0 \\<and> valid_plain p1\n        then coin_spmf \\<bind>\n             (\\<lambda>b.\n                 let pb = if b then p0 else p1\n                 in spmf_of_set (nlists UNIV len) \\<bind>\n                    (\\<lambda>r.\n                        spmf_of_set (nlists UNIV len) \\<bind>\n                        (\\<lambda>pad.\n                            let cipher = (r, pad)\n                            in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                s1 \\<bind>\n                               (\\<lambda>(b', uu_). return_spmf (b' = b)))))\n        else coin_spmf) =\n    exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n    (\\<lambda>(((p0, p1), \\<sigma>), s1).\n        if valid_plain p0 \\<and> valid_plain p1\n        then spmf_of_set (nlists UNIV len) \\<bind>\n             (\\<lambda>r.\n                 spmf_of_set (nlists UNIV len) \\<bind>\n                 (\\<lambda>pad.\n                     let cipher = (r, pad)\n                     in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                         s1 \\<bind>\n                        (\\<lambda>(b', uu_). map_spmf ((=) b') coin_spmf)))\n        else coin_spmf)", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n    (\\<lambda>(((p0, p1), \\<sigma>), s1).\n        if valid_plain p0 \\<and> valid_plain p1\n        then coin_spmf \\<bind>\n             (\\<lambda>b.\n                 let pb = if b then p0 else p1\n                 in spmf_of_set (nlists UNIV len) \\<bind>\n                    (\\<lambda>r.\n                        spmf_of_set (nlists UNIV len) \\<bind>\n                        (\\<lambda>pad.\n                            let cipher = (r, pad)\n                            in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                                s1 \\<bind>\n                               (\\<lambda>(b', uu_). return_spmf (b' = b)))))\n        else coin_spmf) =\n    exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n    (\\<lambda>(((p0, p1), \\<sigma>), s1).\n        if valid_plain p0 \\<and> valid_plain p1\n        then spmf_of_set (nlists UNIV len) \\<bind>\n             (\\<lambda>r.\n                 spmf_of_set (nlists UNIV len) \\<bind>\n                 (\\<lambda>pad.\n                     let cipher = (r, pad)\n                     in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                         s1 \\<bind>\n                        (\\<lambda>(b', uu_). map_spmf ((=) b') coin_spmf)))\n        else coin_spmf)", "by(simp add: map_spmf_conv_bind_spmf split_def Let_def)"], ["proof (state)\nthis:\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then coin_spmf \\<bind>\n           (\\<lambda>b.\n               let pb = if b then p0 else p1\n               in spmf_of_set (nlists UNIV len) \\<bind>\n                  (\\<lambda>r.\n                      spmf_of_set (nlists UNIV len) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s1 \\<bind>\n                             (\\<lambda>(b', uu_). return_spmf (b' = b)))))\n      else coin_spmf) =\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then spmf_of_set (nlists UNIV len) \\<bind>\n           (\\<lambda>r.\n               spmf_of_set (nlists UNIV len) \\<bind>\n               (\\<lambda>pad.\n                   let cipher = (r, pad)\n                   in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s1 \\<bind>\n                      (\\<lambda>(b', uu_). map_spmf ((=) b') coin_spmf)))\n      else coin_spmf)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then coin_spmf \\<bind>\n           (\\<lambda>b.\n               let pb = if b then p0 else p1\n               in spmf_of_set (nlists UNIV len) \\<bind>\n                  (\\<lambda>r.\n                      spmf_of_set (nlists UNIV len) \\<bind>\n                      (\\<lambda>pad.\n                          let cipher = (r, pad)\n                          in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                              s1 \\<bind>\n                             (\\<lambda>(b', uu_). return_spmf (b' = b)))))\n      else coin_spmf) =\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then spmf_of_set (nlists UNIV len) \\<bind>\n           (\\<lambda>r.\n               spmf_of_set (nlists UNIV len) \\<bind>\n               (\\<lambda>pad.\n                   let cipher = (r, pad)\n                   in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s1 \\<bind>\n                      (\\<lambda>(b', uu_). map_spmf ((=) b') coin_spmf)))\n      else coin_spmf)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> = coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n    (\\<lambda>(((p0, p1), \\<sigma>), s1).\n        if valid_plain p0 \\<and> valid_plain p1\n        then spmf_of_set (nlists UNIV len) \\<bind>\n             (\\<lambda>r.\n                 spmf_of_set (nlists UNIV len) \\<bind>\n                 (\\<lambda>pad.\n                     let cipher = (r, pad)\n                     in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>)\n                         s1 \\<bind>\n                        (\\<lambda>(b', uu_). map_spmf ((=) b') coin_spmf)))\n        else coin_spmf) =\n    coin_spmf", "by(simp add: map_eq_const_coin_spmf Let_def split_def weight2 weight1)"], ["proof (state)\nthis:\n  exec_gpv rf_encrypt \\<A>1 Map.empty \\<bind>\n  (\\<lambda>(((p0, p1), \\<sigma>), s1).\n      if valid_plain p0 \\<and> valid_plain p1\n      then spmf_of_set (nlists UNIV len) \\<bind>\n           (\\<lambda>r.\n               spmf_of_set (nlists UNIV len) \\<bind>\n               (\\<lambda>pad.\n                   let cipher = (r, pad)\n                   in exec_gpv rf_encrypt (\\<A>2 cipher \\<sigma>) s1 \\<bind>\n                      (\\<lambda>(b', uu_). map_spmf ((=) b') coin_spmf)))\n      else coin_spmf) =\n  coin_spmf\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "finally"], ["proof (chain)\npicking this:\n  game3 = coin_spmf", "have game3: \"game3 = coin_spmf\""], ["proof (prove)\nusing this:\n  game3 = coin_spmf\n\ngoal (1 subgoal):\n 1. game3 = coin_spmf", "."], ["proof (state)\nthis:\n  game3 = coin_spmf\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"ind_cpa.advantage \\<A> \\<le> prf.advantage (prf_adversary \\<A>) + \\<bar>spmf (prf.game_1 (prf_adversary \\<A>)) True - 1 / 2\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) +\n          \\<bar>spmf (local.prf.game_1 (prf_adversary \\<A>)) True -\n                1 / 2\\<bar>", "unfolding ind_cpa.advantage_def prf.advantage_def ind_cpa_0[unfolded spmf_rel_eq]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.prf.game_0 (prf_adversary \\<A>)) True - 1 / 2\\<bar>\n    \\<le> \\<bar>spmf (local.prf.game_0 (prf_adversary \\<A>)) True -\n                spmf (local.prf.game_1 (prf_adversary \\<A>)) True\\<bar> +\n          \\<bar>spmf (local.prf.game_1 (prf_adversary \\<A>)) True -\n                1 / 2\\<bar>", "by(rule abs_diff_triangle_ineq2)"], ["proof (state)\nthis:\n  local.ind_cpa.advantage \\<A>\n  \\<le> local.prf.advantage (prf_adversary \\<A>) +\n        \\<bar>spmf (local.prf.game_1 (prf_adversary \\<A>)) True -\n              1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  local.ind_cpa.advantage \\<A>\n  \\<le> local.prf.advantage (prf_adversary \\<A>) +\n        \\<bar>spmf (local.prf.game_1 (prf_adversary \\<A>)) True -\n              1 / 2\\<bar>\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<bar>spmf (prf.game_1 (prf_adversary \\<A>)) True - 1 / 2\\<bar> \\<le> q1 / 2 ^ len + q2 / 2 ^ len\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.prf.game_1 (prf_adversary \\<A>)) True - 1 / 2\\<bar>\n    \\<le> real q1 / 2 ^ len + real q2 / 2 ^ len", "using game1_2 game2 game3"], ["proof (prove)\nusing this:\n  local.prf.game_1 (prf_adversary \\<A>) = game2\n  \\<bar>spmf game2 True - 1 / 2\\<bar>\n  \\<le> real q1 / 2 ^ len + real q2 / 2 ^ len +\n        \\<bar>spmf game3 True - 1 / 2\\<bar>\n  game3 = coin_spmf\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.prf.game_1 (prf_adversary \\<A>)) True - 1 / 2\\<bar>\n    \\<le> real q1 / 2 ^ len + real q2 / 2 ^ len", "by(simp add: spmf_of_set)"], ["proof (state)\nthis:\n  \\<bar>spmf (local.prf.game_1 (prf_adversary \\<A>)) True - 1 / 2\\<bar>\n  \\<le> real q1 / 2 ^ len + real q2 / 2 ^ len\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  \\<bar>spmf (local.prf.game_1 (prf_adversary \\<A>)) True - 1 / 2\\<bar>\n  \\<le> real q1 / 2 ^ len + real q2 / 2 ^ len\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> = (q1 + q2) / 2 ^ len\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real q1 / 2 ^ len + real q2 / 2 ^ len = real (q1 + q2) / 2 ^ len", "by(simp add: field_simps)"], ["proof (state)\nthis:\n  real q1 / 2 ^ len + real q2 / 2 ^ len = real (q1 + q2) / 2 ^ len\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "also"], ["proof (state)\nthis:\n  real q1 / 2 ^ len + real q2 / 2 ^ len = real (q1 + q2) / 2 ^ len\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "have \"\\<dots> \\<le> q / 2 ^ len\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (q1 + q2) / 2 ^ len \\<le> real q / 2 ^ len", "using \\<open>q1 + q2 \\<le> q\\<close>"], ["proof (prove)\nusing this:\n  q1 + q2 \\<le> q\n\ngoal (1 subgoal):\n 1. real (q1 + q2) / 2 ^ len \\<le> real q / 2 ^ len", "by(simp add: divide_right_mono)"], ["proof (state)\nthis:\n  real (q1 + q2) / 2 ^ len \\<le> real q / 2 ^ len\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              local.prf.advantage (prf_adversary \\<A>) + x\n              \\<le> local.prf.advantage (prf_adversary \\<A>) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      local.prf.advantage (prf_adversary \\<A>) + x\n      \\<le> local.prf.advantage (prf_adversary \\<A>) + y\\<rbrakk>\n  \\<Longrightarrow> local.ind_cpa.advantage \\<A>\n                    \\<le> local.prf.advantage (prf_adversary \\<A>) +\n                          real q / 2 ^ len", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              local.prf.advantage (prf_adversary \\<A>) + x\n              \\<le> local.prf.advantage (prf_adversary \\<A>) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      local.prf.advantage (prf_adversary \\<A>) + x\n      \\<le> local.prf.advantage (prf_adversary \\<A>) + y\\<rbrakk>\n  \\<Longrightarrow> local.ind_cpa.advantage \\<A>\n                    \\<le> local.prf.advantage (prf_adversary \\<A>) +\n                          real q / 2 ^ len\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<A>\n    \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len", "by(simp add: field_simps)"], ["proof (state)\nthis:\n  local.ind_cpa.advantage \\<A>\n  \\<le> local.prf.advantage (prf_adversary \\<A>) + real q / 2 ^ len\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interaction_bounded_prf_adversary: \n  fixes q :: nat\n  assumes \"ind_cpa.ibounded_by \\<A> q\"\n  shows \"prf.ibounded_by (prf_adversary \\<A>) (1 + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by' (\\<lambda>_. True) (prf_adversary \\<A>) (1 + q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. interaction_bounded_by' (\\<lambda>_. True) (prf_adversary \\<A>) (1 + q)", "fix \\<eta>"], ["proof (state)\ngoal (1 subgoal):\n 1. interaction_bounded_by' (\\<lambda>_. True) (prf_adversary \\<A>) (1 + q)", "from assms"], ["proof (chain)\npicking this:\n  local.ind_cpa.ibounded_by \\<A> (enat q)", "have \"ind_cpa.ibounded_by \\<A> q\""], ["proof (prove)\nusing this:\n  local.ind_cpa.ibounded_by \\<A> (enat q)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.ibounded_by \\<A> (enat q)", "by blast"], ["proof (state)\nthis:\n  local.ind_cpa.ibounded_by \\<A> (enat q)\n\ngoal (1 subgoal):\n 1. interaction_bounded_by' (\\<lambda>_. True) (prf_adversary \\<A>) (1 + q)", "then"], ["proof (chain)\npicking this:\n  local.ind_cpa.ibounded_by \\<A> (enat q)", "obtain q1 q2 where q: \"q1 + q2 \\<le> q\"\n    and [interaction_bound]: \"interaction_any_bounded_by (fst \\<A>) q1\"\n       \"\\<And>x \\<sigma>. interaction_any_bounded_by (snd \\<A> x \\<sigma>) q2\""], ["proof (prove)\nusing this:\n  local.ind_cpa.ibounded_by \\<A> (enat q)\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>q1 + q2 \\<le> q;\n         interaction_bounded_by' (\\<lambda>_. True) (fst \\<A>) q1;\n         \\<And>x \\<sigma>.\n            interaction_bounded_by' (\\<lambda>_. True) (snd \\<A> x \\<sigma>)\n             q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ind_cpa.ibounded_by_def"], ["proof (prove)\nusing this:\n  (case \\<A> of\n   (\\<A>1, \\<A>2) \\<Rightarrow>\n     \\<lambda>q.\n        \\<exists>q1 q2.\n           interaction_any_bounded_by \\<A>1 q1 \\<and>\n           (\\<forall>cipher \\<sigma>.\n               interaction_any_bounded_by (\\<A>2 cipher \\<sigma>) q2) \\<and>\n           q1 + q2 \\<le> q)\n   (enat q)\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>q1 + q2 \\<le> q;\n         interaction_bounded_by' (\\<lambda>_. True) (fst \\<A>) q1;\n         \\<And>x \\<sigma>.\n            interaction_bounded_by' (\\<lambda>_. True) (snd \\<A> x \\<sigma>)\n             q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: split_beta iadd_le_enat_iff)"], ["proof (state)\nthis:\n  q1 + q2 \\<le> q\n  interaction_bounded_by' (\\<lambda>_. True) (fst \\<A>) q1\n  interaction_bounded_by' (\\<lambda>_. True) (snd \\<A> ?x2 ?\\<sigma>2) q2\n\ngoal (1 subgoal):\n 1. interaction_bounded_by' (\\<lambda>_. True) (prf_adversary \\<A>) (1 + q)", "show \"prf.ibounded_by (prf_adversary \\<A>) (1 + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by' (\\<lambda>_. True) (prf_adversary \\<A>) (1 + q)", "using q"], ["proof (prove)\nusing this:\n  q1 + q2 \\<le> q\n\ngoal (1 subgoal):\n 1. interaction_bounded_by' (\\<lambda>_. True) (prf_adversary \\<A>) (1 + q)", "apply (simp only: prf_adversary_def Let_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 + q2 \\<le> q \\<Longrightarrow>\n    interaction_bounded_by' (\\<lambda>_. True)\n     (inline prf_encrypt_oracle (fst \\<A>) () \\<bind>\n      (\\<lambda>p.\n          if valid_plain (fst (fst (fst p))) \\<and>\n             valid_plain (snd (fst (fst p)))\n          then lift_spmf coin_spmf \\<bind>\n               (\\<lambda>b.\n                   lift_spmf (spmf_of_set (nlists UNIV len)) \\<bind>\n                   (\\<lambda>r.\n                       Generative_Probabilistic_Value.Pause r\n                        Generative_Probabilistic_Value.Done \\<bind>\n                       (\\<lambda>pad.\n                           inline prf_encrypt_oracle\n                            (snd \\<A>\n                              (r, (if b then fst (fst (fst p))\n                                   else snd (fst (fst p))) [\\<oplus>]\n                                  pad)\n                              (snd (fst p)))\n                            (snd p) \\<bind>\n                           (\\<lambda>p.\n                               Generative_Probabilistic_Value.Done\n                                (fst p = b)))))\n          else lift_spmf coin_spmf))\n     (1 + q)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 + q2 \\<le> q \\<Longrightarrow>\n    interaction_bounded_by' (\\<lambda>_. True)\n     (inline prf_encrypt_oracle (fst \\<A>) () \\<bind>\n      (\\<lambda>p.\n          if valid_plain (fst (fst (fst p))) \\<and>\n             valid_plain (snd (fst (fst p)))\n          then lift_spmf coin_spmf \\<bind>\n               (\\<lambda>b.\n                   lift_spmf (spmf_of_set (nlists UNIV len)) \\<bind>\n                   (\\<lambda>r.\n                       Generative_Probabilistic_Value.Pause r\n                        Generative_Probabilistic_Value.Done \\<bind>\n                       (\\<lambda>pad.\n                           inline prf_encrypt_oracle\n                            (snd \\<A>\n                              (r, (if b then fst (fst (fst p))\n                                   else snd (fst (fst p))) [\\<oplus>]\n                                  pad)\n                              (snd (fst p)))\n                            (snd p) \\<bind>\n                           (\\<lambda>p.\n                               Generative_Probabilistic_Value.Done\n                                (fst p = b)))))\n          else lift_spmf coin_spmf))\n     (1 + q)", "apply interaction_bound"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>q1 + q2 \\<le> q; \\<not> True\\<rbrakk>\n       \\<Longrightarrow> interaction_any_bounded_by (prf_encrypt_oracle s x)\n                          0\n 2. \\<And>x xa xb xc s xd.\n       \\<lbrakk>q1 + q2 \\<le> q;\n        x \\<in> results'_gpv (inline prf_encrypt_oracle (fst \\<A>) ());\n        valid_plain (fst (fst (fst x))) \\<and>\n        valid_plain (snd (fst (fst x)));\n        xa \\<in> results'_gpv (lift_spmf coin_spmf);\n        xb \\<in> results'_gpv (lift_spmf (spmf_of_set (nlists UNIV len)));\n        xc \\<in> results'_gpv\n                  (Generative_Probabilistic_Value.Pause xb\n                    Generative_Probabilistic_Value.Done);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> interaction_any_bounded_by\n                          (prf_encrypt_oracle s xd) 0\n 3. q1 + q2 \\<le> q \\<Longrightarrow>\n    enat q1 * 1 +\n    (\\<Squnion>x\\<in>results'_gpv (inline prf_encrypt_oracle (fst \\<A>) ()).\n        if valid_plain (fst (fst (fst x))) \\<and>\n           valid_plain (snd (fst (fst x)))\n        then 0 +\n             (\\<Squnion>xa\\<in>results'_gpv (lift_spmf coin_spmf).\n                 0 +\n                 (\\<Squnion>xb\\<in>results'_gpv\n                                    (lift_spmf\n(spmf_of_set (nlists UNIV len))).\n                     (if True then 1 + (\\<Squnion>input. 0)\n                      else \\<Squnion>input. 0) +\n                     (\\<Squnion>xc\\<in>results'_gpv\n  (Generative_Probabilistic_Value.Pause xb\n    Generative_Probabilistic_Value.Done).\n                         enat q2 * 1 +\n                         (\\<Squnion>x\\<in>results'_gpv\n     (inline prf_encrypt_oracle\n       (snd \\<A>\n         (xb,\n          (if xa then fst (fst (fst x)) else snd (fst (fst x))) [\\<oplus>]\n          xc)\n         (snd (fst x)))\n       (snd x)).\n                             0))))\n        else 0)\n    \\<le> enat (1 + q)", "apply (auto simp add: iadd_SUP_le_iff SUP_le_iff add.assoc [symmetric] one_enat_def cong del: image_cong_simp cong add: SUP_cong_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  interaction_bounded_by' (\\<lambda>_. True) (prf_adversary \\<A>) (1 + q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lossless_prf_adversary: \"ind_cpa.lossless \\<A> \\<Longrightarrow> prf.lossless (prf_adversary \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ind_cpa.lossless \\<A> \\<Longrightarrow>\n    local.prf.lossless (prf_adversary \\<A>)", "by(fastforce simp add: prf_adversary_def Let_def split_def ind_cpa.lossless_def intro: lossless_inline)"], ["", "end"], ["", "locale otp_\\<eta> =\n  fixes f :: \"security \\<Rightarrow> key \\<Rightarrow> bool list \\<Rightarrow> bool list\"\n  and len :: \"security \\<Rightarrow> nat\"\n  assumes length_f: \"\\<And>\\<eta> xs ys. \\<lbrakk> length xs = len \\<eta>; length ys = len \\<eta> \\<rbrakk> \\<Longrightarrow> length (f \\<eta> xs ys) = len \\<eta>\"\n  and negligible_len [negligible_intros]: \"negligible (\\<lambda>\\<eta>. 1 / 2 ^ (len \\<eta>))\"\nbegin"], ["", "interpretation otp \"f \\<eta>\" \"len \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. otp (f \\<eta>) (len \\<eta>)", "by(unfold_locales)(rule length_f)"], ["", "interpretation ind_cpa: ind_cpa \"key_gen \\<eta>\" \"encrypt \\<eta>\" \"decrypt \\<eta>\" \"valid_plain \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation \"prf\": \"prf\" \"key_gen \\<eta>\" \"f \\<eta>\" \"spmf_of_set (nlists UNIV (len \\<eta>))\" for \\<eta>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma prf_encrypt_secure_for:\n  assumes [negligible_intros]: \"negligible (\\<lambda>\\<eta>. prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)))\"\n  and q: \"\\<And>\\<eta>. ind_cpa.ibounded_by (\\<A> \\<eta>) (q \\<eta>)\" and [negligible_intros]: \"polynomial q\"\n  and lossless: \"\\<And>\\<eta>. ind_cpa.lossless (\\<A> \\<eta>)\"\n  shows \"negligible (\\<lambda>\\<eta>. ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible\n     (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))", "proof(rule negligible_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. negligible ?g\n 2. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(?g)", "show \"negligible (\\<lambda>\\<eta>. prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)) + q \\<eta> / 2 ^ len \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. negligible\n     (\\<lambda>\\<eta>.\n         local.prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n         real (q \\<eta>) / 2 ^ len \\<eta>)", "by(intro negligible_intros)"], ["proof (state)\nthis:\n  negligible\n   (\\<lambda>\\<eta>.\n       local.prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n       real (q \\<eta>) / 2 ^ len \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "{"], ["proof (state)\nthis:\n  negligible\n   (\\<lambda>\\<eta>.\n       local.prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n       real (q \\<eta>) / 2 ^ len \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "fix \\<eta>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "from \\<open>ind_cpa.ibounded_by _ _\\<close>"], ["proof (chain)\npicking this:\n  local.ind_cpa.ibounded_by (\\<A> ?\\<eta>) (enat (q ?\\<eta>))", "have \"ind_cpa.ibounded_by (\\<A> \\<eta>) (q \\<eta>)\""], ["proof (prove)\nusing this:\n  local.ind_cpa.ibounded_by (\\<A> ?\\<eta>) (enat (q ?\\<eta>))\n\ngoal (1 subgoal):\n 1. local.ind_cpa.ibounded_by (\\<A> \\<eta>) (enat (q \\<eta>))", "by blast"], ["proof (state)\nthis:\n  local.ind_cpa.ibounded_by (\\<A> \\<eta>) (enat (q \\<eta>))\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "moreover"], ["proof (state)\nthis:\n  local.ind_cpa.ibounded_by (\\<A> \\<eta>) (enat (q \\<eta>))\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "from lossless"], ["proof (chain)\npicking this:\n  local.ind_cpa.lossless (\\<A> ?\\<eta>1)", "have \"ind_cpa.lossless (\\<A> \\<eta>)\""], ["proof (prove)\nusing this:\n  local.ind_cpa.lossless (\\<A> ?\\<eta>1)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.lossless (\\<A> \\<eta>)", "by blast"], ["proof (state)\nthis:\n  local.ind_cpa.lossless (\\<A> \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "hence \"lossless_gpv \\<I>_full (fst (\\<A> \\<eta>))\" \"\\<And>cipher \\<sigma>. lossless_gpv \\<I>_full (snd (\\<A> \\<eta>) cipher \\<sigma>)\""], ["proof (prove)\nusing this:\n  local.ind_cpa.lossless (\\<A> \\<eta>)\n\ngoal (1 subgoal):\n 1. lossless_gpv \\<I>_full (fst (\\<A> \\<eta>)) &&&\n    (\\<And>cipher \\<sigma>.\n        lossless_gpv \\<I>_full (snd (\\<A> \\<eta>) cipher \\<sigma>))", "by(auto simp add: ind_cpa.lossless_def)"], ["proof (state)\nthis:\n  lossless_gpv \\<I>_full (fst (\\<A> \\<eta>))\n  lossless_gpv \\<I>_full (snd (\\<A> \\<eta>) ?cipher1 ?\\<sigma>1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "ultimately"], ["proof (chain)\npicking this:\n  local.ind_cpa.ibounded_by (\\<A> \\<eta>) (enat (q \\<eta>))\n  lossless_gpv \\<I>_full (fst (\\<A> \\<eta>))\n  lossless_gpv \\<I>_full (snd (\\<A> \\<eta>) ?cipher1 ?\\<sigma>1)", "have \"ind_cpa.advantage \\<eta> (\\<A> \\<eta>) \\<le> prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)) + q \\<eta> / 2 ^ len \\<eta>\""], ["proof (prove)\nusing this:\n  local.ind_cpa.ibounded_by (\\<A> \\<eta>) (enat (q \\<eta>))\n  lossless_gpv \\<I>_full (fst (\\<A> \\<eta>))\n  lossless_gpv \\<I>_full (snd (\\<A> \\<eta>) ?cipher1 ?\\<sigma>1)\n\ngoal (1 subgoal):\n 1. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>)\n    \\<le> local.prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n          real (q \\<eta>) / 2 ^ len \\<eta>", "by(rule prf_encrypt_advantage)"], ["proof (state)\nthis:\n  local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>)\n  \\<le> local.prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n        real (q \\<eta>) / 2 ^ len \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "}"], ["proof (state)\nthis:\n  local.ind_cpa.advantage ?\\<eta>3 (\\<A> ?\\<eta>3)\n  \\<le> local.prf.advantage ?\\<eta>3\n         (prf_adversary ?\\<eta>3 (\\<A> ?\\<eta>3)) +\n        real (q ?\\<eta>3) / 2 ^ len ?\\<eta>3\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "hence \"eventually (\\<lambda>\\<eta>. \\<bar>ind_cpa.advantage \\<eta> (\\<A> \\<eta>)\\<bar> \\<le> 1 * \\<bar>prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)) + q \\<eta> / 2 ^ len \\<eta>\\<bar>) at_top\""], ["proof (prove)\nusing this:\n  local.ind_cpa.advantage ?\\<eta>3 (\\<A> ?\\<eta>3)\n  \\<le> local.prf.advantage ?\\<eta>3\n         (prf_adversary ?\\<eta>3 (\\<A> ?\\<eta>3)) +\n        real (q ?\\<eta>3) / 2 ^ len ?\\<eta>3\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F \\<eta> in sequentially.\n       \\<bar>local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>)\\<bar>\n       \\<le> 1 *\n             \\<bar>local.prf.advantage \\<eta>\n                    (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n                   real (q \\<eta>) / 2 ^ len \\<eta>\\<bar>", "by(simp add: always_eventually ind_cpa.advantage_nonneg prf.advantage_nonneg)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F \\<eta> in sequentially.\n     \\<bar>local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>)\\<bar>\n     \\<le> 1 *\n           \\<bar>local.prf.advantage \\<eta>\n                  (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n                 real (q \\<eta>) / 2 ^ len \\<eta>\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F \\<eta> in sequentially.\n     \\<bar>local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>)\\<bar>\n     \\<le> 1 *\n           \\<bar>local.prf.advantage \\<eta>\n                  (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n                 real (q \\<eta>) / 2 ^ len \\<eta>\\<bar>", "show \"(\\<lambda>\\<eta>. ind_cpa.advantage \\<eta> (\\<A> \\<eta>)) \\<in> O(\\<lambda>\\<eta>. prf.advantage \\<eta> (prf_adversary \\<eta> (\\<A> \\<eta>)) + q \\<eta> / 2 ^ len \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F \\<eta> in sequentially.\n     \\<bar>local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>)\\<bar>\n     \\<le> 1 *\n           \\<bar>local.prf.advantage \\<eta>\n                  (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n                 real (q \\<eta>) / 2 ^ len \\<eta>\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n    \\<in> O(\\<lambda>\\<eta>.\n               local.prf.advantage \\<eta>\n                (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n               real (q \\<eta>) / 2 ^ len \\<eta>)", "by(intro bigoI[where c=1]) simp"], ["proof (state)\nthis:\n  (\\<lambda>\\<eta>. local.ind_cpa.advantage \\<eta> (\\<A> \\<eta>))\n  \\<in> O(\\<lambda>\\<eta>.\n             local.prf.advantage \\<eta>\n              (prf_adversary \\<eta> (\\<A> \\<eta>)) +\n             real (q \\<eta>) / 2 ^ len \\<eta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}