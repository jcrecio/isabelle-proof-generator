{"file_name": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto/Unpredictable_Function.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto", "problem_names": ["lemma advantage_advantage1:\n  assumes bound: \"interaction_bounded_by (Not \\<circ> isl) \\<A> q\"\n  shows \"advantage \\<A> \\<le> advantage1 (guessing_many_one.reduction q (\\<lambda>_ :: unit. \\<A>) ()) * q\""], "translations": [["", "lemma advantage_advantage1:\n  assumes bound: \"interaction_bounded_by (Not \\<circ> isl) \\<A> q\"\n  shows \"advantage \\<A> \\<le> advantage1 (guessing_many_one.reduction q (\\<lambda>_ :: unit. \\<A>) ()) * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (guessing_many_one.reduction q (\\<lambda>_. \\<A>) ()) *\n          real q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (guessing_many_one.reduction q (\\<lambda>_. \\<A>) ()) *\n          real q", "let ?init = \"map_spmf (\\<lambda>key. (key, (), {})) key_gen\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (guessing_many_one.reduction q (\\<lambda>_. \\<A>) ()) *\n          real q", "let ?oracle = \"\\<lambda>key . oracle_hash key\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (guessing_many_one.reduction q (\\<lambda>_. \\<A>) ()) *\n          real q", "let ?eval = \"\\<lambda>key (_ :: unit) L (x, h). return_spmf (h = hash key x \\<and> x \\<notin> L)\""], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (guessing_many_one.reduction q (\\<lambda>_. \\<A>) ()) *\n          real q", "interpret guessing_many_one ?init ?oracle ?eval"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q", "have [simp]: \"oracle_flag key = eval_oracle key ()\" for key"], ["proof (prove)\ngoal (1 subgoal):\n 1. oracle_flag key = eval_oracle key ()", "by(simp add: oracle_flag_def eval_oracle_def fun_eq_iff)"], ["proof (state)\nthis:\n  oracle_flag ?key1 = eval_oracle ?key1 ()\n\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q", "have \"game \\<A> = game_multi (\\<lambda>_. \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. game \\<A> = game_multi (\\<lambda>_. \\<A>)", "by(auto simp add: game_multi_def game_def bind_map_spmf intro!: bind_spmf_cong[OF refl])"], ["proof (state)\nthis:\n  game \\<A> = game_multi (\\<lambda>_. \\<A>)\n\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q", "hence \"advantage \\<A> = advantage_multi (\\<lambda>_. \\<A>)\""], ["proof (prove)\nusing this:\n  game \\<A> = game_multi (\\<lambda>_. \\<A>)\n\ngoal (1 subgoal):\n 1. advantage \\<A> = advantage_multi (\\<lambda>_. \\<A>)", "by(simp add: advantage_def advantage_multi_def)"], ["proof (state)\nthis:\n  advantage \\<A> = advantage_multi (\\<lambda>_. \\<A>)\n\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q", "also"], ["proof (state)\nthis:\n  advantage \\<A> = advantage_multi (\\<lambda>_. \\<A>)\n\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q", "have \"\\<dots> \\<le> advantage_single (reduction q (\\<lambda>_. \\<A>)) * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage_multi (\\<lambda>_. \\<A>)\n    \\<le> advantage_single (reduction q (\\<lambda>_. \\<A>)) * real q", "using bound"], ["proof (prove)\nusing this:\n  interaction_bounded_by' (Not \\<circ> isl) \\<A> q\n\ngoal (1 subgoal):\n 1. advantage_multi (\\<lambda>_. \\<A>)\n    \\<le> advantage_single (reduction q (\\<lambda>_. \\<A>)) * real q", "by(rule many_single_reduction)(auto simp add: oracle_hash_def)"], ["proof (state)\nthis:\n  advantage_multi (\\<lambda>_. \\<A>)\n  \\<le> advantage_single (reduction q (\\<lambda>_. \\<A>)) * real q\n\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q", "also"], ["proof (state)\nthis:\n  advantage_multi (\\<lambda>_. \\<A>)\n  \\<le> advantage_single (reduction q (\\<lambda>_. \\<A>)) * real q\n\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q", "have \"advantage_single (reduction q (\\<lambda>_. \\<A>)) = advantage1 (reduction q (\\<lambda>_. \\<A>) ())\" for \\<A>"], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage_single (reduction q (\\<lambda>_. \\<A>)) =\n    advantage1 (reduction q (\\<lambda>_. \\<A>) ())", "unfolding advantage1_def advantage_single_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (game_single (reduction q (\\<lambda>_. \\<A>))) True =\n    spmf (game1 (reduction q (\\<lambda>_. \\<A>) ())) True", "by(auto simp add: game1_def game_single_def bind_map_spmf o_def intro!: bind_spmf_cong[OF refl] arg_cong2[where f=spmf])"], ["proof (state)\nthis:\n  advantage_single (reduction q (\\<lambda>_. ?\\<A>1)) =\n  advantage1 (reduction q (\\<lambda>_. ?\\<A>1) ())\n\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q", "finally"], ["proof (chain)\npicking this:\n  advantage \\<A>\n  \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q", "show ?thesis"], ["proof (prove)\nusing this:\n  advantage \\<A>\n  \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q\n\ngoal (1 subgoal):\n 1. advantage \\<A>\n    \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q", "."], ["proof (state)\nthis:\n  advantage \\<A>\n  \\<le> advantage1 (reduction q (\\<lambda>_. \\<A>) ()) * real q\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}