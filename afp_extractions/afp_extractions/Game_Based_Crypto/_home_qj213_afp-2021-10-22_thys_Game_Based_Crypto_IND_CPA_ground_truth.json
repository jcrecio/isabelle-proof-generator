{"file_name": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto/IND_CPA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Game_Based_Crypto", "problem_names": ["lemma advantage_nonneg: \"advantage \\<A> \\<ge> 0\"", "lemma ibounded_byE [consumes 1, case_names ibounded_by, elim?]:\n  assumes \"ibounded_by (\\<A>1, \\<A>2) q\"\n  obtains q1 q2\n  where \"q1 + q2 \\<le> q\"\n  and \"interaction_any_bounded_by \\<A>1 q1\"\n  and \"\\<And>cipher \\<sigma>. interaction_any_bounded_by (\\<A>2 cipher \\<sigma>) q2\"", "lemma ibounded_byI [intro?]:\n  \"\\<lbrakk> interaction_any_bounded_by \\<A>1 q1; \\<And>cipher \\<sigma>. interaction_any_bounded_by (\\<A>2 cipher \\<sigma>) q2; q1 + q2 \\<le> q \\<rbrakk>\n  \\<Longrightarrow> ibounded_by (\\<A>1, \\<A>2) q\""], "translations": [["", "lemma advantage_nonneg: \"advantage \\<A> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> advantage \\<A>", "by(simp add: advantage_def)"], ["", "definition ibounded_by :: \"('plain, 'cipher, 'state) adversary \\<Rightarrow> enat \\<Rightarrow> bool\"\nwhere \n  \"ibounded_by = (\\<lambda>(\\<A>1, \\<A>2) q. \n  (\\<exists>q1 q2. interaction_any_bounded_by \\<A>1 q1 \\<and> (\\<forall>cipher \\<sigma>. interaction_any_bounded_by (\\<A>2 cipher \\<sigma>) q2) \\<and> q1 + q2 \\<le> q))\""], ["", "lemma ibounded_byE [consumes 1, case_names ibounded_by, elim?]:\n  assumes \"ibounded_by (\\<A>1, \\<A>2) q\"\n  obtains q1 q2\n  where \"q1 + q2 \\<le> q\"\n  and \"interaction_any_bounded_by \\<A>1 q1\"\n  and \"\\<And>cipher \\<sigma>. interaction_any_bounded_by (\\<A>2 cipher \\<sigma>) q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>q1 + q2 \\<le> q; interaction_any_bounded_by \\<A>1 q1;\n         \\<And>cipher \\<sigma>.\n            interaction_any_bounded_by (\\<A>2 cipher \\<sigma>) q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ibounded_by (\\<A>1, \\<A>2) q\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>q1 + q2 \\<le> q; interaction_any_bounded_by \\<A>1 q1;\n         \\<And>cipher \\<sigma>.\n            interaction_any_bounded_by (\\<A>2 cipher \\<sigma>) q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: ibounded_by_def)"], ["", "lemma ibounded_byI [intro?]:\n  \"\\<lbrakk> interaction_any_bounded_by \\<A>1 q1; \\<And>cipher \\<sigma>. interaction_any_bounded_by (\\<A>2 cipher \\<sigma>) q2; q1 + q2 \\<le> q \\<rbrakk>\n  \\<Longrightarrow> ibounded_by (\\<A>1, \\<A>2) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interaction_any_bounded_by \\<A>1 q1;\n     \\<And>cipher \\<sigma>.\n        interaction_any_bounded_by (\\<A>2 cipher \\<sigma>) q2;\n     q1 + q2 \\<le> q\\<rbrakk>\n    \\<Longrightarrow> ibounded_by (\\<A>1, \\<A>2) q", "by(auto simp add: ibounded_by_def)"], ["", "definition lossless :: \"('plain, 'cipher, 'state) adversary \\<Rightarrow> bool\"\nwhere \"lossless = (\\<lambda>(\\<A>1, \\<A>2). lossless_gpv \\<I>_full \\<A>1 \\<and> (\\<forall>cipher \\<sigma>. lossless_gpv \\<I>_full (\\<A>2 cipher \\<sigma>)))\""], ["", "end"], ["", "end"]]}