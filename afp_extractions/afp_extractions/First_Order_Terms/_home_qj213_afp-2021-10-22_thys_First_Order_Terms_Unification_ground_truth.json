{"file_name": "/home/qj213/afp-2021-10-22/thys/First_Order_Terms/Unification.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/First_Order_Terms", "problem_names": ["lemma decompose_Some [dest]:\n  \"decompose (Fun f ss) (Fun g ts) = Some E \\<Longrightarrow>\n    f = g \\<and> length ss = length ts \\<and> E = zip ss ts\"", "lemma decompose_None [dest]:\n  \"decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow> f \\<noteq> g \\<or> length ss \\<noteq> length ts\"", "lemma mset_subst_list [simp]:\n  \"mset (subst_list (subst x t) ys) = subst_mset (subst x t) (mset ys)\"", "lemma subst_list_append:\n  \"subst_list \\<sigma> (xs @ ys) = subst_list \\<sigma> xs @ subst_list \\<sigma> ys\"", "lemma subst_of_simps [simp]:\n  \"subst_of [] = Var\"\n  \"subst_of ((x, Var x) # ss) = subst_of ss\"\n  \"subst_of (b # ss) = subst_of ss \\<circ>\\<^sub>s subst (fst b) (snd b)\"", "lemma subst_of_append [simp]:\n  \"subst_of (ss @ ts) = subst_of ts \\<circ>\\<^sub>s subst_of ss\"", "lemma unify_Some_UNIF:\n  assumes \"unify E bs = Some cs\"\n  shows \"\\<exists>ds ss. cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#}\"", "lemma unify_sound:\n  assumes \"unify E [] = Some cs\"\n  shows \"is_imgu (subst_of cs) (set E)\"", "lemma unify_None:\n  assumes \"unify E ss = None\"\n  shows \"\\<exists>E'. E' \\<noteq> {#} \\<and> (mset E, E') \\<in> unif\\<^sup>!\"", "lemma unify_complete:\n  assumes \"unify E bs = None\"\n  shows \"unifiers (set E) = {}\"", "lemma mgu_complete:\n  \"mgu s t = None \\<Longrightarrow> unifiers {(s, t)} = {}\"", "lemma finite_subst_domain_subst_of:\n  \"finite (subst_domain (subst_of xs))\"", "lemma mgu_subst_domain:\n  assumes \"mgu s t = Some \\<sigma>\"\n  shows \"subst_domain \\<sigma> \\<subseteq> vars_term s \\<union> vars_term t\"", "lemma mgu_finite_subst_domain:\n  \"mgu s t = Some \\<sigma> \\<Longrightarrow> finite (subst_domain \\<sigma>)\"", "lemma mgu_sound:\n  assumes \"mgu s t = Some \\<sigma>\"\n  shows \"is_imgu \\<sigma> {(s, t)}\""], "translations": [["", "lemma decompose_Some [dest]:\n  \"decompose (Fun f ss) (Fun g ts) = Some E \\<Longrightarrow>\n    f = g \\<and> length ss = length ts \\<and> E = zip ss ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose (Fun f ss) (Fun g ts) = Some E \\<Longrightarrow>\n    f = g \\<and> length ss = length ts \\<and> E = zip ss ts", "by (cases \"f = g\") (auto simp: decompose_def)"], ["", "lemma decompose_None [dest]:\n  \"decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow> f \\<noteq> g \\<or> length ss \\<noteq> length ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow>\n    f \\<noteq> g \\<or> length ss \\<noteq> length ts", "by (cases \"f = g\") (auto simp: decompose_def)"], ["", "text \\<open>Applying a substitution to a list of equations.\\<close>"], ["", "definition\n  subst_list :: \"('f, 'v) subst \\<Rightarrow> ('f, 'v) equation list \\<Rightarrow> ('f, 'v) equation list\"\n  where\n    \"subst_list \\<sigma> ys = map (\\<lambda>p. (fst p \\<cdot> \\<sigma>, snd p \\<cdot> \\<sigma>)) ys\""], ["", "lemma mset_subst_list [simp]:\n  \"mset (subst_list (subst x t) ys) = subst_mset (subst x t) (mset ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (subst_list (subst x t) ys) = subst_mset (subst x t) (mset ys)", "by (auto simp: subst_mset_def subst_list_def)"], ["", "lemma subst_list_append:\n  \"subst_list \\<sigma> (xs @ ys) = subst_list \\<sigma> xs @ subst_list \\<sigma> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_list \\<sigma> (xs @ ys) =\n    subst_list \\<sigma> xs @ subst_list \\<sigma> ys", "by (auto simp: subst_list_def)"], ["", "function (sequential)\n  unify ::\n    \"('f, 'v) equation list \\<Rightarrow> ('v \\<times> ('f, 'v) term) list \\<Rightarrow> ('v \\<times> ('f, 'v) term) list option\"\nwhere\n  \"unify [] bs = Some bs\"\n| \"unify ((Fun f ss, Fun g ts) # E) bs =\n    (case decompose (Fun f ss) (Fun g ts) of\n      None \\<Rightarrow> None\n    | Some us \\<Rightarrow> unify (us @ E) bs)\"\n| \"unify ((Var x, t) # E) bs =\n    (if t = Var x then unify E bs\n    else if x \\<in> vars_term t then None\n    else unify (subst_list (subst x t) E) ((x, t) # bs))\"\n| \"unify ((t, Var x) # E) bs =\n    (if x \\<in> vars_term t then None\n    else unify (subst_list (subst x t) E) ((x, t) # bs))\""], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>bs. x = ([], bs) \\<Longrightarrow> P;\n        \\<And>f ss g ts E bs.\n           x = ((Fun f ss, Fun g ts) # E, bs) \\<Longrightarrow> P;\n        \\<And>xa t E bs. x = ((Var xa, t) # E, bs) \\<Longrightarrow> P;\n        \\<And>v va xa E bs.\n           x = ((Fun v va, Var xa) # E, bs) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>bs bsa. ([], bs) = ([], bsa) \\<Longrightarrow> Some bs = Some bsa\n 3. \\<And>bs f ss g ts E bsa.\n       ([], bs) = ((Fun f ss, Fun g ts) # E, bsa) \\<Longrightarrow>\n       Some bs =\n       (case decompose (Fun f ss) (Fun g ts) of None \\<Rightarrow> None\n        | Some us \\<Rightarrow> unify_sumC (us @ E, bsa))\n 4. \\<And>bs x t E bsa.\n       ([], bs) = ((Var x, t) # E, bsa) \\<Longrightarrow>\n       Some bs =\n       (if t = Var x then unify_sumC (E, bsa)\n        else if x \\<in> vars_term t then None\n             else unify_sumC (subst_list (subst x t) E, (x, t) # bsa))\n 5. \\<And>bs v va x E bsa.\n       ([], bs) = ((Fun v va, Var x) # E, bsa) \\<Longrightarrow>\n       Some bs =\n       (if x \\<in> vars_term (Fun v va) then None\n        else unify_sumC\n              (subst_list (subst x (Fun v va)) E, (x, Fun v va) # bsa))\n 6. \\<And>f ss g ts E bs fa ssa ga tsa Ea bsa.\n       ((Fun f ss, Fun g ts) # E, bs) =\n       ((Fun fa ssa, Fun ga tsa) # Ea, bsa) \\<Longrightarrow>\n       (case decompose (Fun f ss) (Fun g ts) of None \\<Rightarrow> None\n        | Some us \\<Rightarrow> unify_sumC (us @ E, bs)) =\n       (case decompose (Fun fa ssa) (Fun ga tsa) of None \\<Rightarrow> None\n        | Some us \\<Rightarrow> unify_sumC (us @ Ea, bsa))\n 7. \\<And>f ss g ts E bs x t Ea bsa.\n       ((Fun f ss, Fun g ts) # E, bs) =\n       ((Var x, t) # Ea, bsa) \\<Longrightarrow>\n       (case decompose (Fun f ss) (Fun g ts) of None \\<Rightarrow> None\n        | Some us \\<Rightarrow> unify_sumC (us @ E, bs)) =\n       (if t = Var x then unify_sumC (Ea, bsa)\n        else if x \\<in> vars_term t then None\n             else unify_sumC (subst_list (subst x t) Ea, (x, t) # bsa))\n 8. \\<And>f ss g ts E bs v va x Ea bsa.\n       ((Fun f ss, Fun g ts) # E, bs) =\n       ((Fun v va, Var x) # Ea, bsa) \\<Longrightarrow>\n       (case decompose (Fun f ss) (Fun g ts) of None \\<Rightarrow> None\n        | Some us \\<Rightarrow> unify_sumC (us @ E, bs)) =\n       (if x \\<in> vars_term (Fun v va) then None\n        else unify_sumC\n              (subst_list (subst x (Fun v va)) Ea, (x, Fun v va) # bsa))\n 9. \\<And>x t E bs xa ta Ea bsa.\n       ((Var x, t) # E, bs) = ((Var xa, ta) # Ea, bsa) \\<Longrightarrow>\n       (if t = Var x then unify_sumC (E, bs)\n        else if x \\<in> vars_term t then None\n             else unify_sumC (subst_list (subst x t) E, (x, t) # bs)) =\n       (if ta = Var xa then unify_sumC (Ea, bsa)\n        else if xa \\<in> vars_term ta then None\n             else unify_sumC (subst_list (subst xa ta) Ea, (xa, ta) # bsa))\n 10. \\<And>x t E bs v va xa Ea bsa.\n        ((Var x, t) # E, bs) =\n        ((Fun v va, Var xa) # Ea, bsa) \\<Longrightarrow>\n        (if t = Var x then unify_sumC (E, bs)\n         else if x \\<in> vars_term t then None\n              else unify_sumC (subst_list (subst x t) E, (x, t) # bs)) =\n        (if xa \\<in> vars_term (Fun v va) then None\n         else unify_sumC\n               (subst_list (subst xa (Fun v va)) Ea, (xa, Fun v va) # bsa))\nA total of 11 subgoals...", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All unify_dom", "by (standard, rule wf_inv_image [of \"unif\\<inverse>\" \"mset \\<circ> fst\", OF wf_converse_unif])\n     (force intro: UNIF1.intros simp: unif_def union_commute)+"], ["", "definition subst_of :: \"('v \\<times> ('f, 'v) term) list \\<Rightarrow> ('f, 'v) subst\"\n  where\n    \"subst_of ss = List.foldr (\\<lambda>(x, t) \\<sigma>. \\<sigma> \\<circ>\\<^sub>s subst x t) ss Var\""], ["", "text \\<open>Computing the mgu of two terms.\\<close>"], ["", "fun mgu :: \"('f, 'v) term \\<Rightarrow> ('f, 'v) term \\<Rightarrow> ('f, 'v) subst option\" where\n  \"mgu s t =\n    (case unify [(s, t)] [] of\n      None \\<Rightarrow> None\n    | Some res \\<Rightarrow> Some (subst_of res))\""], ["", "lemma subst_of_simps [simp]:\n  \"subst_of [] = Var\"\n  \"subst_of ((x, Var x) # ss) = subst_of ss\"\n  \"subst_of (b # ss) = subst_of ss \\<circ>\\<^sub>s subst (fst b) (snd b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_of [] = Var &&&\n    subst_of ((x, Var x) # ss) = subst_of ss &&&\n    subst_of (b # ss) = subst_of ss \\<circ>\\<^sub>s subst (fst b) (snd b)", "by (simp_all add: subst_of_def split: prod.splits)"], ["", "lemma subst_of_append [simp]:\n  \"subst_of (ss @ ts) = subst_of ts \\<circ>\\<^sub>s subst_of ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_of (ss @ ts) = subst_of ts \\<circ>\\<^sub>s subst_of ss", "by (induct ss) (auto simp: ac_simps)"], ["", "text \\<open>The concrete algorithm \\<open>unify\\<close> can be simulated by the inference\n  rules of \\<open>UNIF\\<close>.\\<close>"], ["", "lemma unify_Some_UNIF:\n  assumes \"unify E bs = Some cs\"\n  shows \"\\<exists>ds ss. cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset E) {#}", "using assms"], ["proof (prove)\nusing this:\n  unify E bs = Some cs\n\ngoal (1 subgoal):\n 1. \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset E) {#}", "proof (induction E bs arbitrary: cs rule: unify.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>f ss g ts E bs cs.\n       \\<lbrakk>\\<And>x2 cs.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and>\n  subst_of ds = compose ss \\<and> UNIF ss (mset (x2 @ E)) {#};\n        unify ((Fun f ss, Fun g ts) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ssa.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ssa \\<and>\n                            UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}\n 3. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 4. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "case (2 f ss g ts E bs)"], ["proof (state)\nthis:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?x2.0;\n   unify (?x2.0 @ E) bs = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ bs \\<and>\n                       subst_of ds = compose ss \\<and>\n                       UNIF ss (mset (?x2.0 @ E)) {#}\n  unify ((Fun f ss, Fun g ts) # E) bs = Some cs\n\ngoal (4 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>f ss g ts E bs cs.\n       \\<lbrakk>\\<And>x2 cs.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and>\n  subst_of ds = compose ss \\<and> UNIF ss (mset (x2 @ E)) {#};\n        unify ((Fun f ss, Fun g ts) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ssa.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ssa \\<and>\n                            UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}\n 3. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 4. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?x2.0;\n   unify (?x2.0 @ E) bs = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ bs \\<and>\n                       subst_of ds = compose ss \\<and>\n                       UNIF ss (mset (?x2.0 @ E)) {#}\n  unify ((Fun f ss, Fun g ts) # E) bs = Some cs", "obtain us where \"decompose (Fun f ss) (Fun g ts) = Some us\"\n    and [simp]: \"f = g\" \"length ss = length ts\" \"us = zip ss ts\"\n    and \"unify (us @ E) bs = Some cs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?x2.0;\n   unify (?x2.0 @ E) bs = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ bs \\<and>\n                       subst_of ds = compose ss \\<and>\n                       UNIF ss (mset (?x2.0 @ E)) {#}\n  unify ((Fun f ss, Fun g ts) # E) bs = Some cs\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some us; f = g;\n         length ss = length ts; us = zip ss ts;\n         unify (us @ E) bs = Some cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  decompose (Fun f ss) (Fun g ts) = Some us\n  f = g\n  length ss = length ts\n  us = zip ss ts\n  unify (us @ E) bs = Some cs\n\ngoal (4 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>f ss g ts E bs cs.\n       \\<lbrakk>\\<And>x2 cs.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and>\n  subst_of ds = compose ss \\<and> UNIF ss (mset (x2 @ E)) {#};\n        unify ((Fun f ss, Fun g ts) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ssa.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ssa \\<and>\n                            UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}\n 3. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 4. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "from \"2.IH\" [OF this(1, 5)]"], ["proof (chain)\npicking this:\n  \\<exists>ds ss.\n     cs = ds @ bs \\<and>\n     subst_of ds = compose ss \\<and> UNIF ss (mset (us @ E)) {#}", "obtain xs ys\n    where \"cs = xs @ bs\"\n    and [simp]: \"subst_of xs = compose ys\"\n    and *: \"UNIF ys (mset (us @ E)) {#}\""], ["proof (prove)\nusing this:\n  \\<exists>ds ss.\n     cs = ds @ bs \\<and>\n     subst_of ds = compose ss \\<and> UNIF ss (mset (us @ E)) {#}\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>cs = xs @ bs; subst_of xs = compose ys;\n         UNIF ys (mset (us @ E)) {#}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cs = xs @ bs\n  subst_of xs = compose ys\n  UNIF ys (mset (us @ E)) {#}\n\ngoal (4 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>f ss g ts E bs cs.\n       \\<lbrakk>\\<And>x2 cs.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and>\n  subst_of ds = compose ss \\<and> UNIF ss (mset (x2 @ E)) {#};\n        unify ((Fun f ss, Fun g ts) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ssa.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ssa \\<and>\n                            UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}\n 3. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 4. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "then"], ["proof (chain)\npicking this:\n  cs = xs @ bs\n  subst_of xs = compose ys\n  UNIF ys (mset (us @ E)) {#}", "have \"UNIF (Var # ys) (mset ((Fun f ss, Fun g ts) # E)) {#}\""], ["proof (prove)\nusing this:\n  cs = xs @ bs\n  subst_of xs = compose ys\n  UNIF ys (mset (us @ E)) {#}\n\ngoal (1 subgoal):\n 1. UNIF (Var # ys) (mset ((Fun f ss, Fun g ts) # E)) {#}", "by (force intro: UNIF1.decomp simp: ac_simps)"], ["proof (state)\nthis:\n  UNIF (Var # ys) (mset ((Fun f ss, Fun g ts) # E)) {#}\n\ngoal (4 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>f ss g ts E bs cs.\n       \\<lbrakk>\\<And>x2 cs.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and>\n  subst_of ds = compose ss \\<and> UNIF ss (mset (x2 @ E)) {#};\n        unify ((Fun f ss, Fun g ts) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ssa.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ssa \\<and>\n                            UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}\n 3. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 4. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "moreover"], ["proof (state)\nthis:\n  UNIF (Var # ys) (mset ((Fun f ss, Fun g ts) # E)) {#}\n\ngoal (4 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>f ss g ts E bs cs.\n       \\<lbrakk>\\<And>x2 cs.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and>\n  subst_of ds = compose ss \\<and> UNIF ss (mset (x2 @ E)) {#};\n        unify ((Fun f ss, Fun g ts) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ssa.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ssa \\<and>\n                            UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}\n 3. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 4. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "have \"cs = xs @ bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs = xs @ bs", "by fact"], ["proof (state)\nthis:\n  cs = xs @ bs\n\ngoal (4 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>f ss g ts E bs cs.\n       \\<lbrakk>\\<And>x2 cs.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and>\n  subst_of ds = compose ss \\<and> UNIF ss (mset (x2 @ E)) {#};\n        unify ((Fun f ss, Fun g ts) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ssa.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ssa \\<and>\n                            UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}\n 3. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 4. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "moreover"], ["proof (state)\nthis:\n  cs = xs @ bs\n\ngoal (4 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>f ss g ts E bs cs.\n       \\<lbrakk>\\<And>x2 cs.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and>\n  subst_of ds = compose ss \\<and> UNIF ss (mset (x2 @ E)) {#};\n        unify ((Fun f ss, Fun g ts) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ssa.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ssa \\<and>\n                            UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}\n 3. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 4. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "have \"subst_of xs = compose (Var # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_of xs = compose (Var # ys)", "by simp"], ["proof (state)\nthis:\n  subst_of xs = compose (Var # ys)\n\ngoal (4 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>f ss g ts E bs cs.\n       \\<lbrakk>\\<And>x2 cs.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and>\n  subst_of ds = compose ss \\<and> UNIF ss (mset (x2 @ E)) {#};\n        unify ((Fun f ss, Fun g ts) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ssa.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ssa \\<and>\n                            UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}\n 3. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 4. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "ultimately"], ["proof (chain)\npicking this:\n  UNIF (Var # ys) (mset ((Fun f ss, Fun g ts) # E)) {#}\n  cs = xs @ bs\n  subst_of xs = compose (Var # ys)", "show ?case"], ["proof (prove)\nusing this:\n  UNIF (Var # ys) (mset ((Fun f ss, Fun g ts) # E)) {#}\n  cs = xs @ bs\n  subst_of xs = compose (Var # ys)\n\ngoal (1 subgoal):\n 1. \\<exists>ds ssa.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ssa \\<and>\n       UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}", "by blast"], ["proof (state)\nthis:\n  \\<exists>ds ssa.\n     cs = ds @ bs \\<and>\n     subst_of ds = compose ssa \\<and>\n     UNIF ssa (mset ((Fun f ss, Fun g ts) # E)) {#}\n\ngoal (3 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 3. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 3. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "case (3 x t E bs)"], ["proof (state)\nthis:\n  \\<lbrakk>t = Var x; unify E bs = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ bs \\<and>\n                       subst_of ds = compose ss \\<and> UNIF ss (mset E) {#}\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n   unify (subst_list (subst x t) E) ((x, t) # bs) = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ (x, t) # bs \\<and>\n                       subst_of ds = compose ss \\<and>\n                       UNIF ss (mset (subst_list (subst x t) E)) {#}\n  unify ((Var x, t) # E) bs = Some cs\n\ngoal (3 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>x t E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>t = Var x; unify E bs = Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ bs \\<and> subst_of ds = compose ss \\<and> UNIF ss (mset E) {#};\n        \\<And>cs.\n           \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n            unify (subst_list (subst x t) E) ((x, t) # bs) =\n            Some cs\\<rbrakk>\n           \\<Longrightarrow> \\<exists>ds ss.\n                                cs = ds @ (x, t) # bs \\<and>\n                                subst_of ds = compose ss \\<and>\n                                UNIF ss (mset (subst_list (subst x t) E))\n                                 {#};\n        unify ((Var x, t) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Var x, t) # E)) {#}\n 3. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "proof (cases \"t = Var x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}\n 2. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "assume \"t = Var x\""], ["proof (state)\nthis:\n  t = Var x\n\ngoal (2 subgoals):\n 1. t = Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}\n 2. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "then"], ["proof (chain)\npicking this:\n  t = Var x", "show ?case"], ["proof (prove)\nusing this:\n  t = Var x\n\ngoal (1 subgoal):\n 1. \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "using 3"], ["proof (prove)\nusing this:\n  t = Var x\n  \\<lbrakk>t = Var x; unify E bs = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ bs \\<and>\n                       subst_of ds = compose ss \\<and> UNIF ss (mset E) {#}\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n   unify (subst_list (subst x t) E) ((x, t) # bs) = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ (x, t) # bs \\<and>\n                       subst_of ds = compose ss \\<and>\n                       UNIF ss (mset (subst_list (subst x t) E)) {#}\n  unify ((Var x, t) # E) bs = Some cs\n\ngoal (1 subgoal):\n 1. \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "by auto (metis UNIF.step compose_simps(2) UNIF1.trivial)"], ["proof (state)\nthis:\n  \\<exists>ds ss.\n     cs = ds @ bs \\<and>\n     subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}\n\ngoal (1 subgoal):\n 1. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "assume \"t \\<noteq> Var x\""], ["proof (state)\nthis:\n  t \\<noteq> Var x\n\ngoal (1 subgoal):\n 1. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "with 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>t = Var x; unify E bs = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ bs \\<and>\n                       subst_of ds = compose ss \\<and> UNIF ss (mset E) {#}\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n   unify (subst_list (subst x t) E) ((x, t) # bs) = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ (x, t) # bs \\<and>\n                       subst_of ds = compose ss \\<and>\n                       UNIF ss (mset (subst_list (subst x t) E)) {#}\n  unify ((Var x, t) # E) bs = Some cs\n  t \\<noteq> Var x", "obtain xs ys\n      where [simp]: \"cs = (ys @ [(x, t)]) @ bs\"\n      and [simp]: \"subst_of ys = compose xs\"\n      and \"x \\<notin> vars_term t\"\n      and \"UNIF xs (mset (subst_list (subst x t) E)) {#}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Var x; unify E bs = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ bs \\<and>\n                       subst_of ds = compose ss \\<and> UNIF ss (mset E) {#}\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n   unify (subst_list (subst x t) E) ((x, t) # bs) = Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ss.\n                       ?cs = ds @ (x, t) # bs \\<and>\n                       subst_of ds = compose ss \\<and>\n                       UNIF ss (mset (subst_list (subst x t) E)) {#}\n  unify ((Var x, t) # E) bs = Some cs\n  t \\<noteq> Var x\n\ngoal (1 subgoal):\n 1. (\\<And>ys xs.\n        \\<lbrakk>cs = (ys @ [(x, t)]) @ bs; subst_of ys = compose xs;\n         x \\<notin> vars_term t;\n         UNIF xs (mset (subst_list (subst x t) E)) {#}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"x \\<in> vars_term t\") force+"], ["proof (state)\nthis:\n  cs = (ys @ [(x, t)]) @ bs\n  subst_of ys = compose xs\n  x \\<notin> vars_term t\n  UNIF xs (mset (subst_list (subst x t) E)) {#}\n\ngoal (1 subgoal):\n 1. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "then"], ["proof (chain)\npicking this:\n  cs = (ys @ [(x, t)]) @ bs\n  subst_of ys = compose xs\n  x \\<notin> vars_term t\n  UNIF xs (mset (subst_list (subst x t) E)) {#}", "have \"UNIF (subst x t # xs) (mset ((Var x, t) # E)) {#}\""], ["proof (prove)\nusing this:\n  cs = (ys @ [(x, t)]) @ bs\n  subst_of ys = compose xs\n  x \\<notin> vars_term t\n  UNIF xs (mset (subst_list (subst x t) E)) {#}\n\ngoal (1 subgoal):\n 1. UNIF (subst x t # xs) (mset ((Var x, t) # E)) {#}", "by (force intro: UNIF1.Var_left simp: ac_simps)"], ["proof (state)\nthis:\n  UNIF (subst x t # xs) (mset ((Var x, t) # E)) {#}\n\ngoal (1 subgoal):\n 1. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "moreover"], ["proof (state)\nthis:\n  UNIF (subst x t # xs) (mset ((Var x, t) # E)) {#}\n\ngoal (1 subgoal):\n 1. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "have \"cs = (ys @ [(x, t)]) @ bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs = (ys @ [(x, t)]) @ bs", "by simp"], ["proof (state)\nthis:\n  cs = (ys @ [(x, t)]) @ bs\n\ngoal (1 subgoal):\n 1. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "moreover"], ["proof (state)\nthis:\n  cs = (ys @ [(x, t)]) @ bs\n\ngoal (1 subgoal):\n 1. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "have \"subst_of (ys @ [(x, t)]) = compose (subst x t # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_of (ys @ [(x, t)]) = compose (subst x t # xs)", "by simp"], ["proof (state)\nthis:\n  subst_of (ys @ [(x, t)]) = compose (subst x t # xs)\n\ngoal (1 subgoal):\n 1. t \\<noteq> Var x \\<Longrightarrow>\n    \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "ultimately"], ["proof (chain)\npicking this:\n  UNIF (subst x t # xs) (mset ((Var x, t) # E)) {#}\n  cs = (ys @ [(x, t)]) @ bs\n  subst_of (ys @ [(x, t)]) = compose (subst x t # xs)", "show ?case"], ["proof (prove)\nusing this:\n  UNIF (subst x t # xs) (mset ((Var x, t) # E)) {#}\n  cs = (ys @ [(x, t)]) @ bs\n  subst_of (ys @ [(x, t)]) = compose (subst x t # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>ds ss.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}", "by blast"], ["proof (state)\nthis:\n  \\<exists>ds ss.\n     cs = ds @ bs \\<and>\n     subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ds ss.\n     cs = ds @ bs \\<and>\n     subst_of ds = compose ss \\<and> UNIF ss (mset ((Var x, t) # E)) {#}\n\ngoal (2 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "case (4 f ss x E bs)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> vars_term (Fun f ss);\n   unify (subst_list (subst x (Fun f ss)) E) ((x, Fun f ss) # bs) =\n   Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ssa.\n                       ?cs = ds @ (x, Fun f ss) # bs \\<and>\n                       subst_of ds = compose ssa \\<and>\n                       UNIF ssa (mset (subst_list (subst x (Fun f ss)) E))\n                        {#}\n  unify ((Fun f ss, Var x) # E) bs = Some cs\n\ngoal (2 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "with 4"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<notin> vars_term (Fun f ss);\n   unify (subst_list (subst x (Fun f ss)) E) ((x, Fun f ss) # bs) =\n   Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ssa.\n                       ?cs = ds @ (x, Fun f ss) # bs \\<and>\n                       subst_of ds = compose ssa \\<and>\n                       UNIF ssa (mset (subst_list (subst x (Fun f ss)) E))\n                        {#}\n  unify ((Fun f ss, Var x) # E) bs = Some cs\n  \\<lbrakk>x \\<notin> vars_term (Fun f ss);\n   unify (subst_list (subst x (Fun f ss)) E) ((x, Fun f ss) # bs) =\n   Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ssa.\n                       ?cs = ds @ (x, Fun f ss) # bs \\<and>\n                       subst_of ds = compose ssa \\<and>\n                       UNIF ssa (mset (subst_list (subst x (Fun f ss)) E))\n                        {#}\n  unify ((Fun f ss, Var x) # E) bs = Some cs", "obtain xs ys\n    where [simp]: \"cs = (ys @ [(x, Fun f ss)]) @ bs\"\n    and [simp]: \"subst_of ys = compose xs\"\n    and \"x \\<notin> vars_term (Fun f ss)\"\n    and \"UNIF xs (mset (subst_list (subst x (Fun f ss)) E)) {#}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<notin> vars_term (Fun f ss);\n   unify (subst_list (subst x (Fun f ss)) E) ((x, Fun f ss) # bs) =\n   Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ssa.\n                       ?cs = ds @ (x, Fun f ss) # bs \\<and>\n                       subst_of ds = compose ssa \\<and>\n                       UNIF ssa (mset (subst_list (subst x (Fun f ss)) E))\n                        {#}\n  unify ((Fun f ss, Var x) # E) bs = Some cs\n  \\<lbrakk>x \\<notin> vars_term (Fun f ss);\n   unify (subst_list (subst x (Fun f ss)) E) ((x, Fun f ss) # bs) =\n   Some ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds ssa.\n                       ?cs = ds @ (x, Fun f ss) # bs \\<and>\n                       subst_of ds = compose ssa \\<and>\n                       UNIF ssa (mset (subst_list (subst x (Fun f ss)) E))\n                        {#}\n  unify ((Fun f ss, Var x) # E) bs = Some cs\n\ngoal (1 subgoal):\n 1. (\\<And>ys xs.\n        \\<lbrakk>cs = (ys @ [(x, Fun f ss)]) @ bs; subst_of ys = compose xs;\n         x \\<notin> vars_term (Fun f ss);\n         UNIF xs (mset (subst_list (subst x (Fun f ss)) E)) {#}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"x \\<in> vars_term (Fun f ss)\") force+"], ["proof (state)\nthis:\n  cs = (ys @ [(x, Fun f ss)]) @ bs\n  subst_of ys = compose xs\n  x \\<notin> vars_term (Fun f ss)\n  UNIF xs (mset (subst_list (subst x (Fun f ss)) E)) {#}\n\ngoal (2 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "then"], ["proof (chain)\npicking this:\n  cs = (ys @ [(x, Fun f ss)]) @ bs\n  subst_of ys = compose xs\n  x \\<notin> vars_term (Fun f ss)\n  UNIF xs (mset (subst_list (subst x (Fun f ss)) E)) {#}", "have \"UNIF (subst x (Fun f ss) # xs) (mset ((Fun f ss, Var x) # E)) {#}\""], ["proof (prove)\nusing this:\n  cs = (ys @ [(x, Fun f ss)]) @ bs\n  subst_of ys = compose xs\n  x \\<notin> vars_term (Fun f ss)\n  UNIF xs (mset (subst_list (subst x (Fun f ss)) E)) {#}\n\ngoal (1 subgoal):\n 1. UNIF (subst x (Fun f ss) # xs) (mset ((Fun f ss, Var x) # E)) {#}", "by (force intro: UNIF1.Var_right simp: ac_simps)"], ["proof (state)\nthis:\n  UNIF (subst x (Fun f ss) # xs) (mset ((Fun f ss, Var x) # E)) {#}\n\ngoal (2 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "moreover"], ["proof (state)\nthis:\n  UNIF (subst x (Fun f ss) # xs) (mset ((Fun f ss, Var x) # E)) {#}\n\ngoal (2 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "have \"cs = (ys @ [(x, Fun f ss)]) @ bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs = (ys @ [(x, Fun f ss)]) @ bs", "by simp"], ["proof (state)\nthis:\n  cs = (ys @ [(x, Fun f ss)]) @ bs\n\ngoal (2 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "moreover"], ["proof (state)\nthis:\n  cs = (ys @ [(x, Fun f ss)]) @ bs\n\ngoal (2 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "have \"subst_of (ys @ [(x, Fun f ss)]) = compose (subst x (Fun f ss) # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_of (ys @ [(x, Fun f ss)]) = compose (subst x (Fun f ss) # xs)", "by simp"], ["proof (state)\nthis:\n  subst_of (ys @ [(x, Fun f ss)]) = compose (subst x (Fun f ss) # xs)\n\ngoal (2 subgoals):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}\n 2. \\<And>v va x E bs cs.\n       \\<lbrakk>\\<And>cs.\n                   \\<lbrakk>x \\<notin> vars_term (Fun v va);\n                    unify (subst_list (subst x (Fun v va)) E)\n                     ((x, Fun v va) # bs) =\n                    Some cs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ds ss.\n  cs = ds @ (x, Fun v va) # bs \\<and>\n  subst_of ds = compose ss \\<and>\n  UNIF ss (mset (subst_list (subst x (Fun v va)) E)) {#};\n        unify ((Fun v va, Var x) # E) bs = Some cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ds ss.\n                            cs = ds @ bs \\<and>\n                            subst_of ds = compose ss \\<and>\n                            UNIF ss (mset ((Fun v va, Var x) # E)) {#}", "ultimately"], ["proof (chain)\npicking this:\n  UNIF (subst x (Fun f ss) # xs) (mset ((Fun f ss, Var x) # E)) {#}\n  cs = (ys @ [(x, Fun f ss)]) @ bs\n  subst_of (ys @ [(x, Fun f ss)]) = compose (subst x (Fun f ss) # xs)", "show ?case"], ["proof (prove)\nusing this:\n  UNIF (subst x (Fun f ss) # xs) (mset ((Fun f ss, Var x) # E)) {#}\n  cs = (ys @ [(x, Fun f ss)]) @ bs\n  subst_of (ys @ [(x, Fun f ss)]) = compose (subst x (Fun f ss) # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>ds ssa.\n       cs = ds @ bs \\<and>\n       subst_of ds = compose ssa \\<and>\n       UNIF ssa (mset ((Fun f ss, Var x) # E)) {#}", "by blast"], ["proof (state)\nthis:\n  \\<exists>ds ssa.\n     cs = ds @ bs \\<and>\n     subst_of ds = compose ssa \\<and>\n     UNIF ssa (mset ((Fun f ss, Var x) # E)) {#}\n\ngoal (1 subgoal):\n 1. \\<And>bs cs.\n       unify [] bs = Some cs \\<Longrightarrow>\n       \\<exists>ds ss.\n          cs = ds @ bs \\<and>\n          subst_of ds = compose ss \\<and> UNIF ss (mset []) {#}", "qed force"], ["", "lemma unify_sound:\n  assumes \"unify E [] = Some cs\"\n  shows \"is_imgu (subst_of cs) (set E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_imgu (subst_of cs) (set E)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_imgu (subst_of cs) (set E)", "from unify_Some_UNIF [OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>ds ss.\n     cs = ds @ [] \\<and>\n     subst_of ds = compose ss \\<and> UNIF ss (mset E) {#}", "obtain ss\n    where \"subst_of cs = compose ss\"\n    and \"UNIF ss (mset E) {#}\""], ["proof (prove)\nusing this:\n  \\<exists>ds ss.\n     cs = ds @ [] \\<and>\n     subst_of ds = compose ss \\<and> UNIF ss (mset E) {#}\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>subst_of cs = compose ss; UNIF ss (mset E) {#}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subst_of cs = compose ss\n  UNIF ss (mset E) {#}\n\ngoal (1 subgoal):\n 1. is_imgu (subst_of cs) (set E)", "with UNIF_empty_imp_is_mgu_compose [OF this(2)]\n    and UNIF_idemp [OF this(2)]"], ["proof (chain)\npicking this:\n  is_mgu (compose ss) (set_mset (mset E))\n  compose ss \\<circ>\\<^sub>s compose ss = compose ss\n  subst_of cs = compose ss\n  UNIF ss (mset E) {#}", "show ?thesis"], ["proof (prove)\nusing this:\n  is_mgu (compose ss) (set_mset (mset E))\n  compose ss \\<circ>\\<^sub>s compose ss = compose ss\n  subst_of cs = compose ss\n  UNIF ss (mset E) {#}\n\ngoal (1 subgoal):\n 1. is_imgu (subst_of cs) (set E)", "by (auto simp add: is_imgu_def is_mgu_def)\n         (metis subst_compose_assoc)"], ["proof (state)\nthis:\n  is_imgu (subst_of cs) (set E)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If \\<open>unify\\<close> gives up, then the given set of equations\n  cannot be reduced to the empty set by \\<open>UNIF\\<close>.\\<close>"], ["", "lemma unify_None:\n  assumes \"unify E ss = None\"\n  shows \"\\<exists>E'. E' \\<noteq> {#} \\<and> (mset E, E') \\<in> unif\\<^sup>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E'. E' \\<noteq> {#} \\<and> (mset E, E') \\<in> unif\\<^sup>!", "using assms"], ["proof (prove)\nusing this:\n  unify E ss = None\n\ngoal (1 subgoal):\n 1. \\<exists>E'. E' \\<noteq> {#} \\<and> (mset E, E') \\<in> unif\\<^sup>!", "proof (induction E ss rule: unify.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>bs.\n       unify [] bs = None \\<Longrightarrow>\n       \\<exists>E'. E' \\<noteq> {#} \\<and> (mset [], E') \\<in> unif\\<^sup>!\n 2. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 3. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 4. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "case (1 bs)"], ["proof (state)\nthis:\n  unify [] bs = None\n\ngoal (4 subgoals):\n 1. \\<And>bs.\n       unify [] bs = None \\<Longrightarrow>\n       \\<exists>E'. E' \\<noteq> {#} \\<and> (mset [], E') \\<in> unif\\<^sup>!\n 2. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 3. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 4. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  unify [] bs = None", "show ?case"], ["proof (prove)\nusing this:\n  unify [] bs = None\n\ngoal (1 subgoal):\n 1. \\<exists>E'. E' \\<noteq> {#} \\<and> (mset [], E') \\<in> unif\\<^sup>!", "by simp"], ["proof (state)\nthis:\n  \\<exists>E'. E' \\<noteq> {#} \\<and> (mset [], E') \\<in> unif\\<^sup>!\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "case (2 f ss g ts E bs)"], ["proof (state)\nthis:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?x2.0;\n   unify (?x2.0 @ E) bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (?x2.0 @ E), E') \\<in> unif\\<^sup>!\n  unify ((Fun f ss, Fun g ts) # E) bs = None\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?x2.0;\n   unify (?x2.0 @ E) bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (?x2.0 @ E), E') \\<in> unif\\<^sup>!\n  unify ((Fun f ss, Fun g ts) # E) bs = None\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "{"], ["proof (state)\nthis:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?x2.0;\n   unify (?x2.0 @ E) bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (?x2.0 @ E), E') \\<in> unif\\<^sup>!\n  unify ((Fun f ss, Fun g ts) # E) bs = None\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "assume *: \"decompose (Fun f ss) (Fun g ts) = None\""], ["proof (state)\nthis:\n  decompose (Fun f ss) (Fun g ts) = None\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "proof (cases \"unifiable (set E)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "case True"], ["proof (state)\nthis:\n  unifiable (set E)\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  unifiable (set E)", "have \"(mset E, {#}) \\<in> unif\\<^sup>*\""], ["proof (prove)\nusing this:\n  unifiable (set E)\n\ngoal (1 subgoal):\n 1. (mset E, {#}) \\<in> unif\\<^sup>*", "by (simp add: unifiable_imp_empty)"], ["proof (state)\nthis:\n  (mset E, {#}) \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "from unif_rtrancl_mono [OF this, of \"{#(Fun f ss, Fun g ts)#}\"]"], ["proof (chain)\npicking this:\n  \\<exists>\\<sigma>.\n     (mset E + {#(Fun f ss, Fun g ts)#},\n      {#} + subst_mset \\<sigma> {#(Fun f ss, Fun g ts)#})\n     \\<in> unif\\<^sup>*", "obtain \\<sigma>\n        where \"(mset E + {#(Fun f ss, Fun g ts)#}, {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#}) \\<in> unif\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>.\n     (mset E + {#(Fun f ss, Fun g ts)#},\n      {#} + subst_mset \\<sigma> {#(Fun f ss, Fun g ts)#})\n     \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        (mset E + {#(Fun f ss, Fun g ts)#},\n         {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#})\n        \\<in> unif\\<^sup>* \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: subst_mset_def)"], ["proof (state)\nthis:\n  (mset E + {#(Fun f ss, Fun g ts)#},\n   {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  (mset E + {#(Fun f ss, Fun g ts)#},\n   {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "have \"{#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#} \\<in> NF unif\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#} \\<in> NF unif", "using decompose_None [OF *]"], ["proof (prove)\nusing this:\n  f \\<noteq> g \\<or> length ss \\<noteq> length ts\n\ngoal (1 subgoal):\n 1. {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#} \\<in> NF unif", "by (auto simp: single_is_union NF_def unif_def elim!: UNIF1.cases)\n           (metis length_map)"], ["proof (state)\nthis:\n  {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#} \\<in> NF unif\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  (mset E + {#(Fun f ss, Fun g ts)#},\n   {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n  {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#} \\<in> NF unif", "show ?thesis"], ["proof (prove)\nusing this:\n  (mset E + {#(Fun f ss, Fun g ts)#},\n   {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n  {#(Fun f ss \\<cdot> \\<sigma>, Fun g ts \\<cdot> \\<sigma>)#} \\<in> NF unif\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "by auto (metis normalizability_I add_mset_not_empty)"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "case False"], ["proof (state)\nthis:\n  \\<not> unifiable (set E)\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  \\<not> unifiable (set E)\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "have \"\\<not> unifiable {(Fun f ss, Fun g ts)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unifiable {(Fun f ss, Fun g ts)}", "using *"], ["proof (prove)\nusing this:\n  decompose (Fun f ss) (Fun g ts) = None\n\ngoal (1 subgoal):\n 1. \\<not> unifiable {(Fun f ss, Fun g ts)}", "by (auto simp: unifiable_def)"], ["proof (state)\nthis:\n  \\<not> unifiable {(Fun f ss, Fun g ts)}\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> unifiable (set E)\n  \\<not> unifiable {(Fun f ss, Fun g ts)}", "have \"\\<not> unifiable (set ((Fun f ss, Fun g ts) # E))\""], ["proof (prove)\nusing this:\n  \\<not> unifiable (set E)\n  \\<not> unifiable {(Fun f ss, Fun g ts)}\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set ((Fun f ss, Fun g ts) # E))", "by (auto simp: unifiable_def unifiers_def)"], ["proof (state)\nthis:\n  \\<not> unifiable (set ((Fun f ss, Fun g ts) # E))\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  \\<not> unifiable (set ((Fun f ss, Fun g ts) # E))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> unifiable (set ((Fun f ss, Fun g ts) # E))\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "by (simp add: not_unifiable_imp_not_empty_NF)"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "}"], ["proof (state)\nthis:\n  decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "{"], ["proof (state)\nthis:\n  decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "fix us"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "assume *: \"decompose (Fun f ss) (Fun g ts) = Some us\"\n      and \"unify (us @ E) bs = None\""], ["proof (state)\nthis:\n  decompose (Fun f ss) (Fun g ts) = Some us\n  unify (us @ E) bs = None\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "from \"2.IH\" [OF this]"], ["proof (chain)\npicking this:\n  \\<exists>E'. E' \\<noteq> {#} \\<and> (mset (us @ E), E') \\<in> unif\\<^sup>!", "obtain E'\n      where \"E' \\<noteq> {#}\" and \"(mset (us @ E), E') \\<in> unif\\<^sup>!\""], ["proof (prove)\nusing this:\n  \\<exists>E'. E' \\<noteq> {#} \\<and> (mset (us @ E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#};\n         (mset (us @ E), E') \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  (mset (us @ E), E') \\<in> unif\\<^sup>!\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  (mset (us @ E), E') \\<in> unif\\<^sup>!\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "have \"(mset ((Fun f ss, Fun g ts) # E), mset (us @ E)) \\<in> unif\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset ((Fun f ss, Fun g ts) # E), mset (us @ E)) \\<in> unif", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mset ((Fun f ss, Fun g ts) # E), mset (us @ E)) \\<in> unif", "have \"g = f\" and \"length ss = length ts\" and \"us = zip ss ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = f &&& length ss = length ts &&& us = zip ss ts", "using *"], ["proof (prove)\nusing this:\n  decompose (Fun f ss) (Fun g ts) = Some us\n\ngoal (1 subgoal):\n 1. g = f &&& length ss = length ts &&& us = zip ss ts", "by auto"], ["proof (state)\nthis:\n  g = f\n  length ss = length ts\n  us = zip ss ts\n\ngoal (1 subgoal):\n 1. (mset ((Fun f ss, Fun g ts) # E), mset (us @ E)) \\<in> unif", "then"], ["proof (chain)\npicking this:\n  g = f\n  length ss = length ts\n  us = zip ss ts", "show ?thesis"], ["proof (prove)\nusing this:\n  g = f\n  length ss = length ts\n  us = zip ss ts\n\ngoal (1 subgoal):\n 1. (mset ((Fun f ss, Fun g ts) # E), mset (us @ E)) \\<in> unif", "by (auto intro: UNIF1.decomp simp: unif_def ac_simps)"], ["proof (state)\nthis:\n  (mset ((Fun f ss, Fun g ts) # E), mset (us @ E)) \\<in> unif\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mset ((Fun f ss, Fun g ts) # E), mset (us @ E)) \\<in> unif\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  E' \\<noteq> {#}\n  (mset (us @ E), E') \\<in> unif\\<^sup>!\n  (mset ((Fun f ss, Fun g ts) # E), mset (us @ E)) \\<in> unif", "have ?case"], ["proof (prove)\nusing this:\n  E' \\<noteq> {#}\n  (mset (us @ E), E') \\<in> unif\\<^sup>!\n  (mset ((Fun f ss, Fun g ts) # E), mset (us @ E)) \\<in> unif\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "by auto"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?us2;\n   unify (?us2 @ E) bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Fun f ss, Fun g ts) # E), E')\n                       \\<in> unif\\<^sup>!\n\ngoal (3 subgoals):\n 1. \\<And>f ss g ts E bs.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    unify (x2 @ E) bs = None\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>E'.\n  E' \\<noteq> {#} \\<and> (mset (x2 @ E), E') \\<in> unif\\<^sup>!;\n        unify ((Fun f ss, Fun g ts) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun f ss, Fun g ts) # E), E')\n                            \\<in> unif\\<^sup>!\n 2. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 3. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?x2.0;\n   unify (?x2.0 @ E) bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (?x2.0 @ E), E') \\<in> unif\\<^sup>!\n  unify ((Fun f ss, Fun g ts) # E) bs = None\n  decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?us2;\n   unify (?us2 @ E) bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Fun f ss, Fun g ts) # E), E')\n                       \\<in> unif\\<^sup>!", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?x2.0;\n   unify (?x2.0 @ E) bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (?x2.0 @ E), E') \\<in> unif\\<^sup>!\n  unify ((Fun f ss, Fun g ts) # E) bs = None\n  decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?us2;\n   unify (?us2 @ E) bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Fun f ss, Fun g ts) # E), E')\n                       \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Fun g ts) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "case (3 x t E bs)"], ["proof (state)\nthis:\n  \\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset E, E') \\<in> unif\\<^sup>!\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n   unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (subst_list (subst x t) E), E')\n                       \\<in> unif\\<^sup>!\n  unify ((Var x, t) # E) bs = None\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "{"], ["proof (state)\nthis:\n  \\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset E, E') \\<in> unif\\<^sup>!\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n   unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (subst_list (subst x t) E), E')\n                       \\<in> unif\\<^sup>!\n  unify ((Var x, t) # E) bs = None\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "assume [simp]: \"t = Var x\""], ["proof (state)\nthis:\n  t = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "obtain E' where \"E' \\<noteq> {#}\" and \"(mset E, E') \\<in> unif\\<^sup>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#}; (mset E, E') \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset E, E') \\<in> unif\\<^sup>!\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n   unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (subst_list (subst x t) E), E')\n                       \\<in> unif\\<^sup>!\n  unify ((Var x, t) # E) bs = None\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#}; (mset E, E') \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  (mset E, E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  (mset E, E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "have \"(mset ((Var x, t) # E), mset E) \\<in> unif\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset ((Var x, t) # E), mset E) \\<in> unif", "by (auto intro: UNIF1.trivial simp: unif_def)"], ["proof (state)\nthis:\n  (mset ((Var x, t) # E), mset E) \\<in> unif\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  E' \\<noteq> {#}\n  (mset E, E') \\<in> unif\\<^sup>!\n  (mset ((Var x, t) # E), mset E) \\<in> unif", "have ?case"], ["proof (prove)\nusing this:\n  E' \\<noteq> {#}\n  (mset E, E') \\<in> unif\\<^sup>!\n  (mset ((Var x, t) # E), mset E) \\<in> unif\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "by auto"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "}"], ["proof (state)\nthis:\n  t = Var x \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  t = Var x \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "{"], ["proof (state)\nthis:\n  t = Var x \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "assume *: \"t \\<noteq> Var x\" \"x \\<notin> vars_term t\""], ["proof (state)\nthis:\n  t \\<noteq> Var x\n  x \\<notin> vars_term t\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  t \\<noteq> Var x\n  x \\<notin> vars_term t", "obtain E' where \"E' \\<noteq> {#}\"\n      and \"(mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\""], ["proof (prove)\nusing this:\n  t \\<noteq> Var x\n  x \\<notin> vars_term t\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#};\n         (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 3"], ["proof (prove)\nusing this:\n  t \\<noteq> Var x\n  x \\<notin> vars_term t\n  \\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset E, E') \\<in> unif\\<^sup>!\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n   unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (subst_list (subst x t) E), E')\n                       \\<in> unif\\<^sup>!\n  unify ((Var x, t) # E) bs = None\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#};\n         (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "have \"(mset ((Var x, t) # E), mset (subst_list (subst x t) E)) \\<in> unif\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset ((Var x, t) # E), mset (subst_list (subst x t) E)) \\<in> unif", "using *"], ["proof (prove)\nusing this:\n  t \\<noteq> Var x\n  x \\<notin> vars_term t\n\ngoal (1 subgoal):\n 1. (mset ((Var x, t) # E), mset (subst_list (subst x t) E)) \\<in> unif", "by (auto intro: UNIF1.Var_left simp: unif_def)"], ["proof (state)\nthis:\n  (mset ((Var x, t) # E), mset (subst_list (subst x t) E)) \\<in> unif\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  E' \\<noteq> {#}\n  (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\n  (mset ((Var x, t) # E), mset (subst_list (subst x t) E)) \\<in> unif", "have ?case"], ["proof (prove)\nusing this:\n  E' \\<noteq> {#}\n  (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\n  (mset ((Var x, t) # E), mset (subst_list (subst x t) E)) \\<in> unif\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "by auto"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "{"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "assume *: \"t \\<noteq> Var x\" \"x \\<in> vars_term t\""], ["proof (state)\nthis:\n  t \\<noteq> Var x\n  x \\<in> vars_term t\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  t \\<noteq> Var x\n  x \\<in> vars_term t", "have \"x \\<in> vars_term t\" \"is_Fun t\""], ["proof (prove)\nusing this:\n  t \\<noteq> Var x\n  x \\<in> vars_term t\n\ngoal (1 subgoal):\n 1. x \\<in> vars_term t &&& is_Fun t", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars_term t\n  is_Fun t\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars_term t\n  is_Fun t", "have \"\\<not> unifiable {(Var x, t)}\""], ["proof (prove)\nusing this:\n  x \\<in> vars_term t\n  is_Fun t\n\ngoal (1 subgoal):\n 1. \\<not> unifiable {(Var x, t)}", "by (rule in_vars_is_Fun_not_unifiable)"], ["proof (state)\nthis:\n  \\<not> unifiable {(Var x, t)}\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  \\<not> unifiable {(Var x, t)}", "have **: \"\\<not> unifiable {(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)}\" for \\<sigma> :: \"('b, 'a) subst\""], ["proof (prove)\nusing this:\n  \\<not> unifiable {(Var x, t)}\n\ngoal (1 subgoal):\n 1. \\<not> unifiable {(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)}", "using subst_set_reflects_unifiable [of \\<sigma> \"{(Var x, t)}\"]"], ["proof (prove)\nusing this:\n  \\<not> unifiable {(Var x, t)}\n  unifiable (subst_set \\<sigma> {(Var x, t)}) \\<Longrightarrow>\n  unifiable {(Var x, t)}\n\ngoal (1 subgoal):\n 1. \\<not> unifiable {(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)}", "by (auto simp: subst_set_def)"], ["proof (state)\nthis:\n  \\<not> unifiable {(Var x \\<cdot> ?\\<sigma>, t \\<cdot> ?\\<sigma>)}\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "proof (cases \"unifiable (set E)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "case True"], ["proof (state)\nthis:\n  unifiable (set E)\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  unifiable (set E)", "have \"(mset E, {#}) \\<in> unif\\<^sup>*\""], ["proof (prove)\nusing this:\n  unifiable (set E)\n\ngoal (1 subgoal):\n 1. (mset E, {#}) \\<in> unif\\<^sup>*", "by (simp add: unifiable_imp_empty)"], ["proof (state)\nthis:\n  (mset E, {#}) \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "from unif_rtrancl_mono [OF this, of \"{#(Var x, t)#}\"]"], ["proof (chain)\npicking this:\n  \\<exists>\\<sigma>.\n     (mset E + {#(Var x, t)#}, {#} + subst_mset \\<sigma> {#(Var x, t)#})\n     \\<in> unif\\<^sup>*", "obtain \\<sigma>\n        where \"(mset E + {#(Var x, t)#}, {#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#}) \\<in> unif\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>.\n     (mset E + {#(Var x, t)#}, {#} + subst_mset \\<sigma> {#(Var x, t)#})\n     \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        (mset E + {#(Var x, t)#},\n         {#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#})\n        \\<in> unif\\<^sup>* \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: subst_mset_def)"], ["proof (state)\nthis:\n  (mset E + {#(Var x, t)#},\n   {#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  (mset E + {#(Var x, t)#},\n   {#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "obtain E' where \"E' \\<noteq> {#}\"\n        and \"({#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#}, E') \\<in> unif\\<^sup>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#};\n         ({#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#}, E')\n         \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_unifiable_imp_not_empty_NF and **"], ["proof (prove)\nusing this:\n  \\<not> unifiable (set_mset ?E) \\<Longrightarrow>\n  \\<exists>E'. E' \\<noteq> {#} \\<and> (?E, E') \\<in> unif\\<^sup>!\n  \\<not> unifiable {(Var x \\<cdot> ?\\<sigma>, t \\<cdot> ?\\<sigma>)}\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#};\n         ({#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#}, E')\n         \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis set_mset_single)"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  ({#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#}, E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  (mset E + {#(Var x, t)#},\n   {#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n  E' \\<noteq> {#}\n  ({#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#}, E') \\<in> unif\\<^sup>!", "show ?thesis"], ["proof (prove)\nusing this:\n  (mset E + {#(Var x, t)#},\n   {#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n  E' \\<noteq> {#}\n  ({#(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)#}, E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "by auto"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "case False"], ["proof (state)\nthis:\n  \\<not> unifiable (set E)\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  \\<not> unifiable (set E)\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "have \"\\<not> unifiable {(Var x, t)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unifiable {(Var x, t)}", "using *"], ["proof (prove)\nusing this:\n  t \\<noteq> Var x\n  x \\<in> vars_term t\n\ngoal (1 subgoal):\n 1. \\<not> unifiable {(Var x, t)}", "by (force simp: unifiable_def)"], ["proof (state)\nthis:\n  \\<not> unifiable {(Var x, t)}\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> unifiable (set E)\n  \\<not> unifiable {(Var x, t)}", "have \"\\<not> unifiable (set ((Var x, t) # E))\""], ["proof (prove)\nusing this:\n  \\<not> unifiable (set E)\n  \\<not> unifiable {(Var x, t)}\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set ((Var x, t) # E))", "by (auto simp: unifiable_def unifiers_def)"], ["proof (state)\nthis:\n  \\<not> unifiable (set ((Var x, t) # E))\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  \\<not> unifiable (set ((Var x, t) # E))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> unifiable (set ((Var x, t) # E))\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "by (simp add: not_unifiable_imp_not_empty_NF)"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<noteq> Var x; x \\<in> vars_term t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. \\<And>x t E bs.\n       \\<lbrakk>\\<lbrakk>t = Var x; unify E bs = None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset E, E') \\<in> unif\\<^sup>!;\n        \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t;\n         unify (subst_list (subst x t) E) ((x, t) # bs) = None\\<rbrakk>\n        \\<Longrightarrow> \\<exists>E'.\n                             E' \\<noteq> {#} \\<and>\n                             (mset (subst_list (subst x t) E), E')\n                             \\<in> unif\\<^sup>!;\n        unify ((Var x, t) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n 2. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  t = Var x \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n  \\<lbrakk>t \\<noteq> Var x; x \\<in> vars_term t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "show ?case"], ["proof (prove)\nusing this:\n  t = Var x \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n  \\<lbrakk>t \\<noteq> Var x; x \\<notin> vars_term t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n  \\<lbrakk>t \\<noteq> Var x; x \\<in> vars_term t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!", "by blast"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and> (mset ((Var x, t) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "case (4 f ss x E bs)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> vars_term (Fun f ss);\n   unify (subst_list (subst x (Fun f ss)) E) ((x, Fun f ss) # bs) =\n   None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (subst_list (subst x (Fun f ss)) E), E')\n                       \\<in> unif\\<^sup>!\n  unify ((Fun f ss, Var x) # E) bs = None\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "define t where \"t = Fun f ss\""], ["proof (state)\nthis:\n  t = Fun f ss\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "{"], ["proof (state)\nthis:\n  t = Fun f ss\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "assume *: \"x \\<notin> vars_term t\""], ["proof (state)\nthis:\n  x \\<notin> vars_term t\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  x \\<notin> vars_term t", "obtain E' where \"E' \\<noteq> {#}\"\n      and \"(mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\""], ["proof (prove)\nusing this:\n  x \\<notin> vars_term t\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#};\n         (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 4"], ["proof (prove)\nusing this:\n  x \\<notin> vars_term t\n  \\<lbrakk>x \\<notin> vars_term (Fun f ss);\n   unify (subst_list (subst x (Fun f ss)) E) ((x, Fun f ss) # bs) =\n   None\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E'.\n                       E' \\<noteq> {#} \\<and>\n                       (mset (subst_list (subst x (Fun f ss)) E), E')\n                       \\<in> unif\\<^sup>!\n  unify ((Fun f ss, Var x) # E) bs = None\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#};\n         (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: t_def)"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "have \"(mset ((t, Var x) # E), mset (subst_list (subst x t) E)) \\<in> unif\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset ((t, Var x) # E), mset (subst_list (subst x t) E)) \\<in> unif", "using *"], ["proof (prove)\nusing this:\n  x \\<notin> vars_term t\n\ngoal (1 subgoal):\n 1. (mset ((t, Var x) # E), mset (subst_list (subst x t) E)) \\<in> unif", "by (auto intro: UNIF1.Var_right simp: unif_def)"], ["proof (state)\nthis:\n  (mset ((t, Var x) # E), mset (subst_list (subst x t) E)) \\<in> unif\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  E' \\<noteq> {#}\n  (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\n  (mset ((t, Var x) # E), mset (subst_list (subst x t) E)) \\<in> unif", "have ?case"], ["proof (prove)\nusing this:\n  E' \\<noteq> {#}\n  (mset (subst_list (subst x t) E), E') \\<in> unif\\<^sup>!\n  (mset ((t, Var x) # E), mset (subst_list (subst x t) E)) \\<in> unif\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "by (auto simp: t_def)"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "}"], ["proof (state)\nthis:\n  x \\<notin> vars_term t \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  x \\<notin> vars_term t \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "{"], ["proof (state)\nthis:\n  x \\<notin> vars_term t \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "assume \"x \\<in> vars_term t\""], ["proof (state)\nthis:\n  x \\<in> vars_term t\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars_term t", "have *: \"x \\<in> vars_term t\" \"t \\<noteq> Var x\""], ["proof (prove)\nusing this:\n  x \\<in> vars_term t\n\ngoal (1 subgoal):\n 1. x \\<in> vars_term t &&& t \\<noteq> Var x", "by (auto simp: t_def)"], ["proof (state)\nthis:\n  x \\<in> vars_term t\n  t \\<noteq> Var x\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars_term t\n  t \\<noteq> Var x", "have \"x \\<in> vars_term t\" \"is_Fun t\""], ["proof (prove)\nusing this:\n  x \\<in> vars_term t\n  t \\<noteq> Var x\n\ngoal (1 subgoal):\n 1. x \\<in> vars_term t &&& is_Fun t", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars_term t\n  is_Fun t\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars_term t\n  is_Fun t", "have \"\\<not> unifiable {(Var x, t)}\""], ["proof (prove)\nusing this:\n  x \\<in> vars_term t\n  is_Fun t\n\ngoal (1 subgoal):\n 1. \\<not> unifiable {(Var x, t)}", "by (rule in_vars_is_Fun_not_unifiable)"], ["proof (state)\nthis:\n  \\<not> unifiable {(Var x, t)}\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  \\<not> unifiable {(Var x, t)}", "have **: \"\\<not> unifiable {(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)}\" for \\<sigma> :: \"('b, 'a) subst\""], ["proof (prove)\nusing this:\n  \\<not> unifiable {(Var x, t)}\n\ngoal (1 subgoal):\n 1. \\<not> unifiable {(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)}", "using subst_set_reflects_unifiable [of \\<sigma> \"{(Var x, t)}\"]"], ["proof (prove)\nusing this:\n  \\<not> unifiable {(Var x, t)}\n  unifiable (subst_set \\<sigma> {(Var x, t)}) \\<Longrightarrow>\n  unifiable {(Var x, t)}\n\ngoal (1 subgoal):\n 1. \\<not> unifiable {(Var x \\<cdot> \\<sigma>, t \\<cdot> \\<sigma>)}", "by (auto simp: subst_set_def)"], ["proof (state)\nthis:\n  \\<not> unifiable {(Var x \\<cdot> ?\\<sigma>, t \\<cdot> ?\\<sigma>)}\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "proof (cases \"unifiable (set E)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "case True"], ["proof (state)\nthis:\n  unifiable (set E)\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  unifiable (set E)", "have \"(mset E, {#}) \\<in> unif\\<^sup>*\""], ["proof (prove)\nusing this:\n  unifiable (set E)\n\ngoal (1 subgoal):\n 1. (mset E, {#}) \\<in> unif\\<^sup>*", "by (simp add: unifiable_imp_empty)"], ["proof (state)\nthis:\n  (mset E, {#}) \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "from unif_rtrancl_mono [OF this, of \"{#(t, Var x)#}\"]"], ["proof (chain)\npicking this:\n  \\<exists>\\<sigma>.\n     (mset E + {#(t, Var x)#}, {#} + subst_mset \\<sigma> {#(t, Var x)#})\n     \\<in> unif\\<^sup>*", "obtain \\<sigma>\n        where \"(mset E + {#(t, Var x)#}, {#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#}) \\<in> unif\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>.\n     (mset E + {#(t, Var x)#}, {#} + subst_mset \\<sigma> {#(t, Var x)#})\n     \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        (mset E + {#(t, Var x)#},\n         {#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#})\n        \\<in> unif\\<^sup>* \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: subst_mset_def)"], ["proof (state)\nthis:\n  (mset E + {#(t, Var x)#},\n   {#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  (mset E + {#(t, Var x)#},\n   {#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "obtain E' where \"E' \\<noteq> {#}\"\n        and \"({#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#}, E') \\<in> unif\\<^sup>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#};\n         ({#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#}, E')\n         \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_unifiable_imp_not_empty_NF and **"], ["proof (prove)\nusing this:\n  \\<not> unifiable (set_mset ?E) \\<Longrightarrow>\n  \\<exists>E'. E' \\<noteq> {#} \\<and> (?E, E') \\<in> unif\\<^sup>!\n  \\<not> unifiable {(Var x \\<cdot> ?\\<sigma>, t \\<cdot> ?\\<sigma>)}\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#};\n         ({#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#}, E')\n         \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis unifiable_insert_swap set_mset_single)"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  ({#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#}, E') \\<in> unif\\<^sup>!\n\ngoal (2 subgoals):\n 1. unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n 2. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  (mset E + {#(t, Var x)#},\n   {#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n  E' \\<noteq> {#}\n  ({#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#}, E') \\<in> unif\\<^sup>!", "show ?thesis"], ["proof (prove)\nusing this:\n  (mset E + {#(t, Var x)#},\n   {#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#})\n  \\<in> unif\\<^sup>*\n  E' \\<noteq> {#}\n  ({#(t \\<cdot> \\<sigma>, Var x \\<cdot> \\<sigma>)#}, E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "by (auto simp: t_def)"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "case False"], ["proof (state)\nthis:\n  \\<not> unifiable (set E)\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "moreover"], ["proof (state)\nthis:\n  \\<not> unifiable (set E)\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "have \"\\<not> unifiable {(t, Var x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unifiable {(t, Var x)}", "using *"], ["proof (prove)\nusing this:\n  x \\<in> vars_term t\n  t \\<noteq> Var x\n\ngoal (1 subgoal):\n 1. \\<not> unifiable {(t, Var x)}", "by (simp add: unifiable_def)"], ["proof (state)\nthis:\n  \\<not> unifiable {(t, Var x)}\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> unifiable (set E)\n  \\<not> unifiable {(t, Var x)}", "have \"\\<not> unifiable (set ((t, Var x) # E))\""], ["proof (prove)\nusing this:\n  \\<not> unifiable (set E)\n  \\<not> unifiable {(t, Var x)}\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set ((t, Var x) # E))", "by (auto simp: unifiable_def unifiers_def)"], ["proof (state)\nthis:\n  \\<not> unifiable (set ((t, Var x) # E))\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E) \\<Longrightarrow>\n    \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "then"], ["proof (chain)\npicking this:\n  \\<not> unifiable (set ((t, Var x) # E))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> unifiable (set ((t, Var x) # E))\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "by (simp add: not_unifiable_imp_not_empty_NF t_def)"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "}"], ["proof (state)\nthis:\n  x \\<in> vars_term t \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>v va x E bs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> vars_term (Fun v va);\n                 unify (subst_list (subst x (Fun v va)) E)\n                  ((x, Fun v va) # bs) =\n                 None\\<rbrakk>\n                \\<Longrightarrow> \\<exists>E'.\n                                     E' \\<noteq> {#} \\<and>\n                                     (mset\n (subst_list (subst x (Fun v va)) E),\nE')\n                                     \\<in> unif\\<^sup>!;\n        unify ((Fun v va, Var x) # E) bs = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>E'.\n                            E' \\<noteq> {#} \\<and>\n                            (mset ((Fun v va, Var x) # E), E')\n                            \\<in> unif\\<^sup>!", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> vars_term t \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n  x \\<in> vars_term t \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "show ?case"], ["proof (prove)\nusing this:\n  x \\<notin> vars_term t \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n  x \\<in> vars_term t \\<Longrightarrow>\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<exists>E'.\n       E' \\<noteq> {#} \\<and>\n       (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!", "by blast"], ["proof (state)\nthis:\n  \\<exists>E'.\n     E' \\<noteq> {#} \\<and>\n     (mset ((Fun f ss, Var x) # E), E') \\<in> unif\\<^sup>!\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unify_complete:\n  assumes \"unify E bs = None\"\n  shows \"unifiers (set E) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unifiers (set E) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unifiers (set E) = {}", "from unify_None [OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>E'. E' \\<noteq> {#} \\<and> (mset E, E') \\<in> unif\\<^sup>!", "obtain E'\n    where \"E' \\<noteq> {#}\" and \"(mset E, E') \\<in> unif\\<^sup>!\""], ["proof (prove)\nusing this:\n  \\<exists>E'. E' \\<noteq> {#} \\<and> (mset E, E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        \\<lbrakk>E' \\<noteq> {#}; (mset E, E') \\<in> unif\\<^sup>!\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  E' \\<noteq> {#}\n  (mset E, E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. unifiers (set E) = {}", "then"], ["proof (chain)\npicking this:\n  E' \\<noteq> {#}\n  (mset E, E') \\<in> unif\\<^sup>!", "have \"\\<not> unifiable (set E)\""], ["proof (prove)\nusing this:\n  E' \\<noteq> {#}\n  (mset E, E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E)", "using irreducible_reachable_imp_not_unifiable"], ["proof (prove)\nusing this:\n  E' \\<noteq> {#}\n  (mset E, E') \\<in> unif\\<^sup>!\n  \\<lbrakk>(?E, ?E') \\<in> unif\\<^sup>!; ?E' \\<noteq> {#}\\<rbrakk>\n  \\<Longrightarrow> \\<not> unifiable (set_mset ?E)\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set E)", "by force"], ["proof (state)\nthis:\n  \\<not> unifiable (set E)\n\ngoal (1 subgoal):\n 1. unifiers (set E) = {}", "then"], ["proof (chain)\npicking this:\n  \\<not> unifiable (set E)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> unifiable (set E)\n\ngoal (1 subgoal):\n 1. unifiers (set E) = {}", "by (auto simp: unifiable_def)"], ["proof (state)\nthis:\n  unifiers (set E) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mgu_complete:\n  \"mgu s t = None \\<Longrightarrow> unifiers {(s, t)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mgu s t = None \\<Longrightarrow> unifiers {(s, t)} = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mgu s t = None \\<Longrightarrow> unifiers {(s, t)} = {}", "assume \"mgu s t = None\""], ["proof (state)\nthis:\n  mgu s t = None\n\ngoal (1 subgoal):\n 1. mgu s t = None \\<Longrightarrow> unifiers {(s, t)} = {}", "then"], ["proof (chain)\npicking this:\n  mgu s t = None", "have \"unify [(s, t)] [] = None\""], ["proof (prove)\nusing this:\n  mgu s t = None\n\ngoal (1 subgoal):\n 1. unify [(s, t)] [] = None", "by (cases \"unify [(s, t)] []\", auto)"], ["proof (state)\nthis:\n  unify [(s, t)] [] = None\n\ngoal (1 subgoal):\n 1. mgu s t = None \\<Longrightarrow> unifiers {(s, t)} = {}", "then"], ["proof (chain)\npicking this:\n  unify [(s, t)] [] = None", "have \"unifiers (set [(s, t)]) = {}\""], ["proof (prove)\nusing this:\n  unify [(s, t)] [] = None\n\ngoal (1 subgoal):\n 1. unifiers (set [(s, t)]) = {}", "by (rule unify_complete)"], ["proof (state)\nthis:\n  unifiers (set [(s, t)]) = {}\n\ngoal (1 subgoal):\n 1. mgu s t = None \\<Longrightarrow> unifiers {(s, t)} = {}", "then"], ["proof (chain)\npicking this:\n  unifiers (set [(s, t)]) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  unifiers (set [(s, t)]) = {}\n\ngoal (1 subgoal):\n 1. unifiers {(s, t)} = {}", "by simp"], ["proof (state)\nthis:\n  unifiers {(s, t)} = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_subst_domain_subst_of:\n  \"finite (subst_domain (subst_of xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (subst_domain (subst_of xs))", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (subst_domain (subst_of []))\n 2. \\<And>a xs.\n       finite (subst_domain (subst_of xs)) \\<Longrightarrow>\n       finite (subst_domain (subst_of (a # xs)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  finite (subst_domain (subst_of xs))\n\ngoal (2 subgoals):\n 1. finite (subst_domain (subst_of []))\n 2. \\<And>a xs.\n       finite (subst_domain (subst_of xs)) \\<Longrightarrow>\n       finite (subst_domain (subst_of (a # xs)))", "moreover"], ["proof (state)\nthis:\n  finite (subst_domain (subst_of xs))\n\ngoal (2 subgoals):\n 1. finite (subst_domain (subst_of []))\n 2. \\<And>a xs.\n       finite (subst_domain (subst_of xs)) \\<Longrightarrow>\n       finite (subst_domain (subst_of (a # xs)))", "have \"finite (subst_domain (subst (fst x) (snd x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (subst_domain (subst (fst x) (snd x)))", "by (metis finite_subst_domain_subst)"], ["proof (state)\nthis:\n  finite (subst_domain (subst (fst x) (snd x)))\n\ngoal (2 subgoals):\n 1. finite (subst_domain (subst_of []))\n 2. \\<And>a xs.\n       finite (subst_domain (subst_of xs)) \\<Longrightarrow>\n       finite (subst_domain (subst_of (a # xs)))", "ultimately"], ["proof (chain)\npicking this:\n  finite (subst_domain (subst_of xs))\n  finite (subst_domain (subst (fst x) (snd x)))", "show ?case"], ["proof (prove)\nusing this:\n  finite (subst_domain (subst_of xs))\n  finite (subst_domain (subst (fst x) (snd x)))\n\ngoal (1 subgoal):\n 1. finite (subst_domain (subst_of (x # xs)))", "using subst_domain_compose [of \"subst_of xs\" \"subst (fst x) (snd x)\"]"], ["proof (prove)\nusing this:\n  finite (subst_domain (subst_of xs))\n  finite (subst_domain (subst (fst x) (snd x)))\n  subst_domain (subst_of xs \\<circ>\\<^sub>s subst (fst x) (snd x))\n  \\<subseteq> subst_domain (subst_of xs) \\<union>\n              subst_domain (subst (fst x) (snd x))\n\ngoal (1 subgoal):\n 1. finite (subst_domain (subst_of (x # xs)))", "by (simp del: subst_subst_domain) (metis finite_subset infinite_Un)"], ["proof (state)\nthis:\n  finite (subst_domain (subst_of (x # xs)))\n\ngoal (1 subgoal):\n 1. finite (subst_domain (subst_of []))", "qed simp"], ["", "lemma mgu_subst_domain:\n  assumes \"mgu s t = Some \\<sigma>\"\n  shows \"subst_domain \\<sigma> \\<subseteq> vars_term s \\<union> vars_term t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<subseteq> vars_term s \\<union> vars_term t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<subseteq> vars_term s \\<union> vars_term t", "obtain xs where *: \"unify [(s, t)] [] = Some xs\" and [simp]: \"subst_of xs = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>unify [(s, t)] [] = Some xs;\n         subst_of xs = \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  mgu s t = Some \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>unify [(s, t)] [] = Some xs;\n         subst_of xs = \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp split: option.splits)"], ["proof (state)\nthis:\n  unify [(s, t)] [] = Some xs\n  subst_of xs = \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<subseteq> vars_term s \\<union> vars_term t", "from unify_Some_UNIF [OF *]"], ["proof (chain)\npicking this:\n  \\<exists>ds ss.\n     xs = ds @ [] \\<and>\n     subst_of ds = compose ss \\<and> UNIF ss (mset [(s, t)]) {#}", "obtain ss\n    where \"compose ss = \\<sigma>\" and \"UNIF ss {#(s, t)#} {#}\""], ["proof (prove)\nusing this:\n  \\<exists>ds ss.\n     xs = ds @ [] \\<and>\n     subst_of ds = compose ss \\<and> UNIF ss (mset [(s, t)]) {#}\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>compose ss = \\<sigma>; UNIF ss {#(s, t)#} {#}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  compose ss = \\<sigma>\n  UNIF ss {#(s, t)#} {#}\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<subseteq> vars_term s \\<union> vars_term t", "with UNIF_subst_domain_subset [of ss \"{#(s, t)#}\" \"{#}\"]"], ["proof (chain)\npicking this:\n  UNIF ss {#(s, t)#} {#} \\<Longrightarrow>\n  subst_domain (compose ss) \\<subseteq> vars_mset {#(s, t)#}\n  compose ss = \\<sigma>\n  UNIF ss {#(s, t)#} {#}", "show ?thesis"], ["proof (prove)\nusing this:\n  UNIF ss {#(s, t)#} {#} \\<Longrightarrow>\n  subst_domain (compose ss) \\<subseteq> vars_mset {#(s, t)#}\n  compose ss = \\<sigma>\n  UNIF ss {#(s, t)#} {#}\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<subseteq> vars_term s \\<union> vars_term t", "using vars_mset_singleton"], ["proof (prove)\nusing this:\n  UNIF ss {#(s, t)#} {#} \\<Longrightarrow>\n  subst_domain (compose ss) \\<subseteq> vars_mset {#(s, t)#}\n  compose ss = \\<sigma>\n  UNIF ss {#(s, t)#} {#}\n  vars_mset {#?p#} = vars_term (fst ?p) \\<union> vars_term (snd ?p)\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<subseteq> vars_term s \\<union> vars_term t", "by fastforce"], ["proof (state)\nthis:\n  subst_domain \\<sigma> \\<subseteq> vars_term s \\<union> vars_term t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mgu_finite_subst_domain:\n  \"mgu s t = Some \\<sigma> \\<Longrightarrow> finite (subst_domain \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mgu s t = Some \\<sigma> \\<Longrightarrow> finite (subst_domain \\<sigma>)", "by (cases \"unify [(s, t)] []\")\n    (auto simp: finite_subst_domain_subst_of)"], ["", "lemma mgu_sound:\n  assumes \"mgu s t = Some \\<sigma>\"\n  shows \"is_imgu \\<sigma> {(s, t)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_imgu \\<sigma> {(s, t)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_imgu \\<sigma> {(s, t)}", "obtain ss where \"unify [(s, t)] [] = Some ss\"\n    and \"\\<sigma> = subst_of ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>unify [(s, t)] [] = Some ss;\n         \\<sigma> = subst_of ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  mgu s t = Some \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>unify [(s, t)] [] = Some ss;\n         \\<sigma> = subst_of ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  unify [(s, t)] [] = Some ss\n  \\<sigma> = subst_of ss\n\ngoal (1 subgoal):\n 1. is_imgu \\<sigma> {(s, t)}", "then"], ["proof (chain)\npicking this:\n  unify [(s, t)] [] = Some ss\n  \\<sigma> = subst_of ss", "have \"is_imgu \\<sigma> (set [(s, t)])\""], ["proof (prove)\nusing this:\n  unify [(s, t)] [] = Some ss\n  \\<sigma> = subst_of ss\n\ngoal (1 subgoal):\n 1. is_imgu \\<sigma> (set [(s, t)])", "by (metis unify_sound)"], ["proof (state)\nthis:\n  is_imgu \\<sigma> (set [(s, t)])\n\ngoal (1 subgoal):\n 1. is_imgu \\<sigma> {(s, t)}", "then"], ["proof (chain)\npicking this:\n  is_imgu \\<sigma> (set [(s, t)])", "show ?thesis"], ["proof (prove)\nusing this:\n  is_imgu \\<sigma> (set [(s, t)])\n\ngoal (1 subgoal):\n 1. is_imgu \\<sigma> {(s, t)}", "by simp"], ["proof (state)\nthis:\n  is_imgu \\<sigma> {(s, t)}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}