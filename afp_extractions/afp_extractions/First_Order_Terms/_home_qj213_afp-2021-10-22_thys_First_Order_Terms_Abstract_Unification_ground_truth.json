{"file_name": "/home/qj213/afp-2021-10-22/thys/First_Order_Terms/Abstract_Unification.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/First_Order_Terms", "problem_names": ["lemma foldr_assoc:\n  assumes \"\\<And>f g h. b (b f g) h = b f (b g h)\"\n  shows \"foldr b xs (b y z) = b (foldr b xs y) z\"", "lemma union_commutes:\n  \"M + {#x#} + N = M + N + {#x#}\"\n  \"M + mset xs + N = M + N + mset xs\"", "lemma unif_UNIF1_conv:\n  \"(E, E') \\<in> unif \\<longleftrightarrow> (\\<exists>\\<sigma>. UNIF1 \\<sigma> E E')\"", "lemma UNIF1_unifD:\n  \"UNIF1 \\<sigma> E E' \\<Longrightarrow> (E, E') \\<in> unif\"", "lemma wf_unifless:\n  \"wf unifless\"", "lemma UNIF1_vars_mset_leq:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"vars_mset E' \\<subseteq> vars_mset E\"", "lemma vars_mset_subset_size_mset_uniflessI [intro]:\n  \"vars_mset M \\<subseteq> vars_mset N \\<Longrightarrow> size_mset M < size_mset N \\<Longrightarrow> (M, N) \\<in> unifless\"", "lemma vars_mset_psubset_uniflessI [intro]:\n  \"vars_mset M \\<subset> vars_mset N \\<Longrightarrow> (M, N) \\<in> unifless\"", "lemma UNIF1_unifless:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"(E', E) \\<in> unifless\"", "lemma converse_unif_subset_unifless:\n  \"unif\\<inverse> \\<subseteq> unifless\"", "lemma wf_converse_unif:\n  \"wf (unif\\<inverse>)\"", "lemma unif_rtrancl_UNIF_conv:\n  \"(E, E') \\<in> unif\\<^sup>* \\<longleftrightarrow> (\\<exists>ss. UNIF ss E E')\"", "lemma compose_simps [simp]:\n  \"compose [] = Var\"\n  \"compose (Var # ss) = compose ss\"\n  \"compose (\\<sigma> # ss) = \\<sigma> \\<circ>\\<^sub>s compose ss\"", "lemma compose_append [simp]:\n  \"compose (ss @ ts) = compose ss \\<circ>\\<^sub>s compose ts\"", "lemma set_mset_subst_mset [simp]:\n  \"set_mset (subst_mset \\<sigma> E) = subst_set \\<sigma> (set_mset E)\"", "lemma UNIF1_subst_domain_Int:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"subst_domain \\<sigma> \\<inter> vars_mset E' = {}\"", "lemma UNIF1_subst_domain_subset:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"subst_domain \\<sigma> \\<subseteq> vars_mset E\"", "lemma UNIF_subst_domain_subset:\n  assumes \"UNIF ss E E'\"\n  shows \"subst_domain (compose ss) \\<subseteq> vars_mset E\"", "lemma UNIF1_range_vars_subset:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"range_vars \\<sigma> \\<subseteq> vars_mset E\"", "lemma UNIF1_subst_domain_range_vars_Int:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\"", "lemma UNIF_range_vars_subset:\n  assumes \"UNIF ss E E'\"\n  shows \"range_vars (compose ss) \\<subseteq> vars_mset E\"", "lemma UNIF_subst_domain_range_vars_Int:\n  assumes \"UNIF ss E E'\"\n  shows \"subst_domain (compose ss) \\<inter> range_vars (compose ss) = {}\"", "lemma UNIF_idemp:\n  assumes \"UNIF ss E E'\"\n  shows \"compose ss \\<circ>\\<^sub>s compose ss = compose ss\"", "lemma UNIF1_mono:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"UNIF1 \\<sigma> (E + M) (E' + subst_mset \\<sigma> M)\"", "lemma unif_mono:\n  assumes \"(E, E') \\<in> unif\"\n  shows \"\\<exists>\\<sigma>. (E + M, E' + subst_mset \\<sigma> M) \\<in> unif\"", "lemma unif_rtrancl_mono:\n  assumes \"(E, E') \\<in> unif\\<^sup>*\"\n  shows \"\\<exists>\\<sigma>. (E + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*\"", "lemma UNIF_empty_imp_is_mgu_compose:\n  fixes E :: \"('f, 'v) equation multiset\"\n  assumes \"UNIF ss E {#}\"\n  shows \"is_mgu (compose ss) (set_mset E)\"", "lemma UNIF1_singleton_decomp [intro]:\n  assumes \"length ss = length ts\"\n  shows \"UNIF1 Var {#(Fun f ss, Fun f ts)#} (mset (zip ss ts))\"", "lemma UNIF1_singleton_Var_left [intro]:\n  \"x \\<notin> vars_term t \\<Longrightarrow> UNIF1 (subst x t) {#(Var x, t)#} {#}\"", "lemma UNIF1_singleton_Var_right [intro]:\n  \"x \\<notin> vars_term t \\<Longrightarrow> UNIF1 (subst x t) {#(t, Var x)#} {#}\"", "lemma not_UNIF1_singleton_Var_right [dest]:\n  \"\\<not> UNIF1 Var {#(Var x, Var y)#} {#} \\<Longrightarrow> x \\<noteq> y\"\n  \"\\<not> UNIF1 (subst x (Var y)) {#(Var x, Var y)#} {#} \\<Longrightarrow> x = y\"", "lemma not_unifD:\n  assumes \"\\<not> (\\<exists>E'. ({#e#}, E') \\<in> unif)\"\n  shows \"(\\<exists>x t. (e = (Var x, t) \\<or> e = (t, Var x)) \\<and> x \\<in> vars_term t \\<and> is_Fun t) \\<or>\n    (\\<exists>f g ss ts. e = (Fun f ss, Fun g ts) \\<and> (f \\<noteq> g \\<or> length ss \\<noteq> length ts))\"", "lemma unifiable_imp_unif:\n  assumes \"unifiable {e}\"\n  shows \"\\<exists>E'. ({#e#}, E') \\<in> unif\"", "lemma unifiable_imp_empty_or_unif:\n  assumes \"unifiable (set_mset E)\"\n  shows \"E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\"", "lemma UNIF1_preserves_unifiers:\n  assumes \"UNIF1 \\<sigma> E E'\" and \"\\<tau> \\<in> unifiers (set_mset E)\"\n  shows \"(\\<sigma> \\<circ>\\<^sub>s \\<tau>) \\<in> unifiers (set_mset E')\"", "lemma unif_preserves_unifiable:\n  assumes \"(E, E') \\<in> unif\" and \"unifiable (set_mset E)\"\n  shows \"unifiable (set_mset E')\"", "lemma unif_imp_converse_unifless [dest]:\n  \"(x, y) \\<in> unif \\<Longrightarrow> (y, x) \\<in> unifless\"", "lemma unifiable_imp_empty:\n  assumes \"unifiable (set_mset E)\"\n  shows \"(E, {#}) \\<in> unif\\<^sup>*\"", "lemma unif_rtrancl_empty_imp_unifiable:\n  assumes \"(E, {#}) \\<in> unif\\<^sup>*\"\n  shows \"unifiable (set_mset E)\"", "lemma not_unifiable_imp_not_empty_NF:\n  assumes \"\\<not> unifiable (set_mset E)\"\n  shows \"\\<exists>E'. E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>!\"", "lemma unif_rtrancl_preserves_unifiable:\n  assumes \"(E, E') \\<in> unif\\<^sup>*\" and \"unifiable (set_mset E)\"\n  shows \"unifiable (set_mset E')\"", "lemma empty_not_reachable_imp_not_unifiable:\n  assumes \"(E, {#}) \\<notin> unif\\<^sup>*\"\n  shows \"\\<not> unifiable (set_mset E)\"", "lemma irreducible_reachable_imp_not_unifiable:\n  assumes \"(E, E') \\<in> unif\\<^sup>!\" and \"E' \\<noteq> {#}\"\n  shows \"\\<not> unifiable (set_mset E)\""], "translations": [["", "lemma foldr_assoc:\n  assumes \"\\<And>f g h. b (b f g) h = b f (b g h)\"\n  shows \"foldr b xs (b y z) = b (foldr b xs y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr b xs (b y z) = b (foldr b xs y) z", "using assms"], ["proof (prove)\nusing this:\n  b (b ?f ?g) ?h = b ?f (b ?g ?h)\n\ngoal (1 subgoal):\n 1. foldr b xs (b y z) = b (foldr b xs y) z", "by (induct xs) simp_all"], ["", "(*TODO: move*)"], ["", "lemma union_commutes:\n  \"M + {#x#} + N = M + N + {#x#}\"\n  \"M + mset xs + N = M + N + mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M + {#x#} + N = M + N + {#x#} &&& M + mset xs + N = M + N + mset xs", "by (auto simp: ac_simps)"], ["", "subsubsection \\<open>Inference Rules\\<close>"], ["", "text \\<open>Inference rules with explicit substitutions.\\<close>"], ["", "inductive\n  UNIF1 :: \"('f, 'v) subst \\<Rightarrow> ('f, 'v) equation multiset \\<Rightarrow> ('f, 'v) equation multiset \\<Rightarrow> bool\"\nwhere\n  trivial [simp]: \"UNIF1 Var (add_mset (t, t) E) E\" |\n  decomp: \"\\<lbrakk>length ss = length ts\\<rbrakk> \\<Longrightarrow>\n    UNIF1 Var (add_mset (Fun f ss, Fun f ts) E) (E + mset (zip ss ts))\" |\n  Var_left: \"\\<lbrakk>x \\<notin> vars_term t\\<rbrakk> \\<Longrightarrow>\n    UNIF1 (subst x t) (add_mset (Var x, t) E) (subst_mset (subst x t) E)\" |\n  Var_right: \"\\<lbrakk>x \\<notin> vars_term t\\<rbrakk> \\<Longrightarrow>\n    UNIF1 (subst x t) (add_mset (t, Var x) E) (subst_mset (subst x t) E)\""], ["", "text \\<open>Relation version of @{const UNIF1} with implicit substitutions.\\<close>"], ["", "definition \"unif = {(x, y). \\<exists>\\<sigma>. UNIF1 \\<sigma> x y}\""], ["", "lemma unif_UNIF1_conv:\n  \"(E, E') \\<in> unif \\<longleftrightarrow> (\\<exists>\\<sigma>. UNIF1 \\<sigma> E E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((E, E') \\<in> unif) = (\\<exists>\\<sigma>. UNIF1 \\<sigma> E E')", "by (auto simp: unif_def)"], ["", "lemma UNIF1_unifD:\n  \"UNIF1 \\<sigma> E E' \\<Longrightarrow> (E, E') \\<in> unif\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIF1 \\<sigma> E E' \\<Longrightarrow> (E, E') \\<in> unif", "by (auto simp: unif_def)"], ["", "text \\<open>A termination order for @{const UNIF1}.\\<close>"], ["", "definition unifless :: \"(('f, 'v) equation multiset \\<times> ('f, 'v) equation multiset) set\" where\n  \"unifless = inv_image (finite_psubset <*lex*> measure size_mset) (\\<lambda>x. (vars_mset x, x))\""], ["", "lemma wf_unifless:\n  \"wf unifless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf unifless", "by (auto simp: unifless_def)"], ["", "lemma UNIF1_vars_mset_leq:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"vars_mset E' \\<subseteq> vars_mset E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_mset E' \\<subseteq> vars_mset E", "using assms"], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> E E'\n\ngoal (1 subgoal):\n 1. vars_mset E' \\<subseteq> vars_mset E", "by (cases) (auto dest: mem_vars_mset_subst_mset)"], ["", "lemma vars_mset_subset_size_mset_uniflessI [intro]:\n  \"vars_mset M \\<subseteq> vars_mset N \\<Longrightarrow> size_mset M < size_mset N \\<Longrightarrow> (M, N) \\<in> unifless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vars_mset M \\<subseteq> vars_mset N;\n     size_mset M < size_mset N\\<rbrakk>\n    \\<Longrightarrow> (M, N) \\<in> unifless", "by (auto simp: unifless_def finite_vars_mset)"], ["", "lemma vars_mset_psubset_uniflessI [intro]:\n  \"vars_mset M \\<subset> vars_mset N \\<Longrightarrow> (M, N) \\<in> unifless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_mset M \\<subset> vars_mset N \\<Longrightarrow>\n    (M, N) \\<in> unifless", "by (auto simp: unifless_def finite_vars_mset)"], ["", "lemma UNIF1_unifless:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"(E', E) \\<in> unifless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (E', E) \\<in> unifless", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (E', E) \\<in> unifless", "have \"vars_mset E' \\<subseteq> vars_mset E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_mset E' \\<subseteq> vars_mset E", "using UNIF1_vars_mset_leq [OF assms]"], ["proof (prove)\nusing this:\n  vars_mset E' \\<subseteq> vars_mset E\n\ngoal (1 subgoal):\n 1. vars_mset E' \\<subseteq> vars_mset E", "."], ["proof (state)\nthis:\n  vars_mset E' \\<subseteq> vars_mset E\n\ngoal (1 subgoal):\n 1. (E', E) \\<in> unifless", "with assms"], ["proof (chain)\npicking this:\n  UNIF1 \\<sigma> E E'\n  vars_mset E' \\<subseteq> vars_mset E", "show ?thesis"], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> E E'\n  vars_mset E' \\<subseteq> vars_mset E\n\ngoal (1 subgoal):\n 1. (E', E) \\<in> unifless", "apply cases"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>vars_mset E' \\<subseteq> vars_mset E; \\<sigma> = Var;\n        E = add_mset (t, t) E'\\<rbrakk>\n       \\<Longrightarrow> (E', E) \\<in> unifless\n 2. \\<And>ss ts f Ea.\n       \\<lbrakk>vars_mset E' \\<subseteq> vars_mset E; \\<sigma> = Var;\n        E = add_mset (Fun f ss, Fun f ts) Ea; E' = Ea + mset (zip ss ts);\n        length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> (E', E) \\<in> unifless\n 3. \\<And>x t Ea.\n       \\<lbrakk>vars_mset E' \\<subseteq> vars_mset E; \\<sigma> = subst x t;\n        E = add_mset (Var x, t) Ea; E' = subst_mset (subst x t) Ea;\n        x \\<notin> vars_term t\\<rbrakk>\n       \\<Longrightarrow> (E', E) \\<in> unifless\n 4. \\<And>x t Ea.\n       \\<lbrakk>vars_mset E' \\<subseteq> vars_mset E; \\<sigma> = subst x t;\n        E = add_mset (t, Var x) Ea; E' = subst_mset (subst x t) Ea;\n        x \\<notin> vars_term t\\<rbrakk>\n       \\<Longrightarrow> (E', E) \\<in> unifless", "apply (auto simp: pair_size_def intro!: Var_left_vars_mset_less Var_right_vars_mset_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ss ts f Ea.\n       \\<lbrakk>\\<sigma> = Var; E = add_mset (Fun f ss, Fun f ts) Ea;\n        E' = Ea + mset (zip ss ts); length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> (Ea + mset (zip ss ts),\n                          add_mset (Fun f ss, Fun f ts) Ea)\n                         \\<in> unifless", "apply (rule vars_mset_subset_size_mset_uniflessI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ss ts f Ea.\n       \\<lbrakk>\\<sigma> = Var; E = add_mset (Fun f ss, Fun f ts) Ea;\n        E' = Ea + mset (zip ss ts); length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> vars_mset (Ea + mset (zip ss ts))\n                         \\<subseteq> vars_mset\n(add_mset (Fun f ss, Fun f ts) Ea)\n 2. \\<And>ss ts f Ea.\n       \\<lbrakk>\\<sigma> = Var; E = add_mset (Fun f ss, Fun f ts) Ea;\n        E' = Ea + mset (zip ss ts); length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> size_mset (Ea + mset (zip ss ts))\n                         < size_mset (add_mset (Fun f ss, Fun f ts) Ea)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ss ts f Ea.\n       \\<lbrakk>\\<sigma> = Var; E = add_mset (Fun f ss, Fun f ts) Ea;\n        E' = Ea + mset (zip ss ts); length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> size_mset (mset (zip ss ts))\n                         < pair_size (Fun f ss, Fun f ts)", "using size_mset_Fun_less"], ["proof (prove)\nusing this:\n  size_mset (mset (zip ?ss ?ts)) < size_mset {#(Fun ?f ?ss, Fun ?g ?ts)#}\n\ngoal (1 subgoal):\n 1. \\<And>ss ts f Ea.\n       \\<lbrakk>\\<sigma> = Var; E = add_mset (Fun f ss, Fun f ts) Ea;\n        E' = Ea + mset (zip ss ts); length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> size_mset (mset (zip ss ts))\n                         < pair_size (Fun f ss, Fun f ts)", "by fastforce"], ["proof (state)\nthis:\n  (E', E) \\<in> unifless\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma converse_unif_subset_unifless:\n  \"unif\\<inverse> \\<subseteq> unifless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unif\\<inverse> \\<subseteq> unifless", "using UNIF1_unifless"], ["proof (prove)\nusing this:\n  UNIF1 ?\\<sigma> ?E ?E' \\<Longrightarrow> (?E', ?E) \\<in> unifless\n\ngoal (1 subgoal):\n 1. unif\\<inverse> \\<subseteq> unifless", "by (auto simp: unif_def)"], ["", "subsubsection \\<open>Termination of the Inference Rules\\<close>"], ["", "lemma wf_converse_unif:\n  \"wf (unif\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (unif\\<inverse>)", "by (rule wf_subset [OF wf_unifless converse_unif_subset_unifless])"], ["", "text \\<open>Reflexive and transitive closure of @{const UNIF1} collecting substitutions\nproduced by single steps.\\<close>"], ["", "inductive\n  UNIF :: \"('f, 'v) subst list \\<Rightarrow> ('f, 'v) equation multiset \\<Rightarrow> ('f, 'v) equation multiset \\<Rightarrow> bool\"\nwhere\n  empty [simp, intro!]: \"UNIF [] E E\" |\n  step [intro]: \"UNIF1 \\<sigma> E E' \\<Longrightarrow> UNIF ss E' E'' \\<Longrightarrow> UNIF (\\<sigma> # ss) E E''\""], ["", "lemma unif_rtrancl_UNIF_conv:\n  \"(E, E') \\<in> unif\\<^sup>* \\<longleftrightarrow> (\\<exists>ss. UNIF ss E E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((E, E') \\<in> unif\\<^sup>*) = (\\<exists>ss. UNIF ss E E')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (E, E') \\<in> unif\\<^sup>* \\<Longrightarrow> \\<exists>ss. UNIF ss E E'\n 2. \\<exists>ss. UNIF ss E E' \\<Longrightarrow> (E, E') \\<in> unif\\<^sup>*", "assume \"(E, E') \\<in> unif\\<^sup>*\""], ["proof (state)\nthis:\n  (E, E') \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. (E, E') \\<in> unif\\<^sup>* \\<Longrightarrow> \\<exists>ss. UNIF ss E E'\n 2. \\<exists>ss. UNIF ss E E' \\<Longrightarrow> (E, E') \\<in> unif\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (E, E') \\<in> unif\\<^sup>*", "show \"\\<exists>ss. UNIF ss E E'\""], ["proof (prove)\nusing this:\n  (E, E') \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>ss. UNIF ss E E'", "by (induct rule: converse_rtrancl_induct) (auto simp: unif_UNIF1_conv)"], ["proof (state)\nthis:\n  \\<exists>ss. UNIF ss E E'\n\ngoal (1 subgoal):\n 1. \\<exists>ss. UNIF ss E E' \\<Longrightarrow> (E, E') \\<in> unif\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ss. UNIF ss E E' \\<Longrightarrow> (E, E') \\<in> unif\\<^sup>*", "assume \"\\<exists>ss. UNIF ss E E'\""], ["proof (state)\nthis:\n  \\<exists>ss. UNIF ss E E'\n\ngoal (1 subgoal):\n 1. \\<exists>ss. UNIF ss E E' \\<Longrightarrow> (E, E') \\<in> unif\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  \\<exists>ss. UNIF ss E E'", "obtain ss where \"UNIF ss E E'\""], ["proof (prove)\nusing this:\n  \\<exists>ss. UNIF ss E E'\n\ngoal (1 subgoal):\n 1. (\\<And>ss. UNIF ss E E' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  UNIF ss E E'\n\ngoal (1 subgoal):\n 1. \\<exists>ss. UNIF ss E E' \\<Longrightarrow> (E, E') \\<in> unif\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  UNIF ss E E'", "show \"(E, E') \\<in> unif\\<^sup>*\""], ["proof (prove)\nusing this:\n  UNIF ss E E'\n\ngoal (1 subgoal):\n 1. (E, E') \\<in> unif\\<^sup>*", "by (induct) (auto dest: UNIF1_unifD)"], ["proof (state)\nthis:\n  (E, E') \\<in> unif\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Compose a list of substitutions.\\<close>"], ["", "definition compose :: \"('f, 'v) subst list \\<Rightarrow> ('f, 'v) subst\"\n  where\n    \"compose ss = List.foldr (\\<circ>\\<^sub>s) ss Var\""], ["", "lemma compose_simps [simp]:\n  \"compose [] = Var\"\n  \"compose (Var # ss) = compose ss\"\n  \"compose (\\<sigma> # ss) = \\<sigma> \\<circ>\\<^sub>s compose ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose [] = Var &&&\n    compose (Var # ss) = compose ss &&&\n    compose (\\<sigma> # ss) = \\<sigma> \\<circ>\\<^sub>s compose ss", "by (simp_all add: compose_def)"], ["", "lemma compose_append [simp]:\n  \"compose (ss @ ts) = compose ss \\<circ>\\<^sub>s compose ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose (ss @ ts) = compose ss \\<circ>\\<^sub>s compose ts", "using foldr_assoc [of \"(\\<circ>\\<^sub>s)\" ss Var \"foldr (\\<circ>\\<^sub>s) ts Var\"]"], ["proof (prove)\nusing this:\n  (\\<And>f g h.\n      f \\<circ>\\<^sub>s g \\<circ>\\<^sub>s h =\n      f \\<circ>\\<^sub>s (g \\<circ>\\<^sub>s h)) \\<Longrightarrow>\n  foldr (\\<circ>\\<^sub>s) ss\n   (Var \\<circ>\\<^sub>s foldr (\\<circ>\\<^sub>s) ts Var) =\n  foldr (\\<circ>\\<^sub>s) ss Var \\<circ>\\<^sub>s\n  foldr (\\<circ>\\<^sub>s) ts Var\n\ngoal (1 subgoal):\n 1. compose (ss @ ts) = compose ss \\<circ>\\<^sub>s compose ts", "by (simp add: compose_def ac_simps)"], ["", "lemma set_mset_subst_mset [simp]:\n  \"set_mset (subst_mset \\<sigma> E) = subst_set \\<sigma> (set_mset E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (subst_mset \\<sigma> E) = subst_set \\<sigma> (set_mset E)", "by (auto simp: subst_set_def subst_mset_def)"], ["", "lemma UNIF1_subst_domain_Int:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"subst_domain \\<sigma> \\<inter> vars_mset E' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> vars_mset E' = {}", "using assms"], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> E E'\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> vars_mset E' = {}", "by (cases) simp+"], ["", "lemma UNIF1_subst_domain_subset:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"subst_domain \\<sigma> \\<subseteq> vars_mset E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<subseteq> vars_mset E", "using assms"], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> E E'\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<subseteq> vars_mset E", "by (cases) simp+"], ["", "lemma UNIF_subst_domain_subset:\n  assumes \"UNIF ss E E'\"\n  shows \"subst_domain (compose ss) \\<subseteq> vars_mset E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_domain (compose ss) \\<subseteq> vars_mset E", "using assms"], ["proof (prove)\nusing this:\n  UNIF ss E E'\n\ngoal (1 subgoal):\n 1. subst_domain (compose ss) \\<subseteq> vars_mset E", "by (induct)\n     (auto dest: UNIF1_subst_domain_subset UNIF1_vars_mset_leq simp: subst_domain_subst_compose)"], ["", "lemma UNIF1_range_vars_subset:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"range_vars \\<sigma> \\<subseteq> vars_mset E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range_vars \\<sigma> \\<subseteq> vars_mset E", "using assms"], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> E E'\n\ngoal (1 subgoal):\n 1. range_vars \\<sigma> \\<subseteq> vars_mset E", "by (cases) (auto simp: range_vars_def)"], ["", "lemma UNIF1_subst_domain_range_vars_Int:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}", "using assms"], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> E E'\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}", "by (cases) auto"], ["", "lemma UNIF_range_vars_subset:\n  assumes \"UNIF ss E E'\"\n  shows \"range_vars (compose ss) \\<subseteq> vars_mset E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range_vars (compose ss) \\<subseteq> vars_mset E", "using assms"], ["proof (prove)\nusing this:\n  UNIF ss E E'\n\ngoal (1 subgoal):\n 1. range_vars (compose ss) \\<subseteq> vars_mset E", "by (induct)\n     (auto dest: UNIF1_range_vars_subset UNIF1_vars_mset_leq\n           dest!: range_vars_subst_compose_subset [THEN subsetD])"], ["", "lemma UNIF_subst_domain_range_vars_Int:\n  assumes \"UNIF ss E E'\"\n  shows \"subst_domain (compose ss) \\<inter> range_vars (compose ss) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_domain (compose ss) \\<inter> range_vars (compose ss) = {}", "using assms"], ["proof (prove)\nusing this:\n  UNIF ss E E'\n\ngoal (1 subgoal):\n 1. subst_domain (compose ss) \\<inter> range_vars (compose ss) = {}", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>E. subst_domain (compose []) \\<inter> range_vars (compose []) = {}\n 2. \\<And>\\<sigma> E E' ss E''.\n       \\<lbrakk>UNIF1 \\<sigma> E E'; UNIF ss E' E'';\n        subst_domain (compose ss) \\<inter> range_vars (compose ss) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> subst_domain (compose (\\<sigma> # ss)) \\<inter>\n                         range_vars (compose (\\<sigma> # ss)) =\n                         {}", "case (step \\<sigma> E E' ss E'')"], ["proof (state)\nthis:\n  UNIF1 \\<sigma> E E'\n  UNIF ss E' E''\n  subst_domain (compose ss) \\<inter> range_vars (compose ss) = {}\n\ngoal (2 subgoals):\n 1. \\<And>E. subst_domain (compose []) \\<inter> range_vars (compose []) = {}\n 2. \\<And>\\<sigma> E E' ss E''.\n       \\<lbrakk>UNIF1 \\<sigma> E E'; UNIF ss E' E'';\n        subst_domain (compose ss) \\<inter> range_vars (compose ss) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> subst_domain (compose (\\<sigma> # ss)) \\<inter>\n                         range_vars (compose (\\<sigma> # ss)) =\n                         {}", "from UNIF1_subst_domain_Int [OF step(1)]\n    and UNIF_subst_domain_subset [OF step(2)]\n    and UNIF1_subst_domain_range_vars_Int [OF step(1)]\n    and UNIF_range_vars_subset [OF step(2)]"], ["proof (chain)\npicking this:\n  subst_domain \\<sigma> \\<inter> vars_mset E' = {}\n  subst_domain (compose ss) \\<subseteq> vars_mset E'\n  subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n  range_vars (compose ss) \\<subseteq> vars_mset E'", "have \"subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\"\n      and \"subst_domain (compose ss) \\<inter> subst_domain \\<sigma> = {}\"\n      and \"subst_domain \\<sigma> \\<inter> range_vars (compose ss) = {}\""], ["proof (prove)\nusing this:\n  subst_domain \\<sigma> \\<inter> vars_mset E' = {}\n  subst_domain (compose ss) \\<subseteq> vars_mset E'\n  subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n  range_vars (compose ss) \\<subseteq> vars_mset E'\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {} &&&\n    subst_domain (compose ss) \\<inter> subst_domain \\<sigma> = {} &&&\n    subst_domain \\<sigma> \\<inter> range_vars (compose ss) = {}", "by blast+"], ["proof (state)\nthis:\n  subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n  subst_domain (compose ss) \\<inter> subst_domain \\<sigma> = {}\n  subst_domain \\<sigma> \\<inter> range_vars (compose ss) = {}\n\ngoal (2 subgoals):\n 1. \\<And>E. subst_domain (compose []) \\<inter> range_vars (compose []) = {}\n 2. \\<And>\\<sigma> E E' ss E''.\n       \\<lbrakk>UNIF1 \\<sigma> E E'; UNIF ss E' E'';\n        subst_domain (compose ss) \\<inter> range_vars (compose ss) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> subst_domain (compose (\\<sigma> # ss)) \\<inter>\n                         range_vars (compose (\\<sigma> # ss)) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n  subst_domain (compose ss) \\<inter> subst_domain \\<sigma> = {}\n  subst_domain \\<sigma> \\<inter> range_vars (compose ss) = {}", "have \"(subst_domain \\<sigma> \\<union> subst_domain (compose ss)) \\<inter>\n    ((range_vars \\<sigma> - subst_domain (compose ss)) \\<union> range_vars (compose ss)) = {}\""], ["proof (prove)\nusing this:\n  subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n  subst_domain (compose ss) \\<inter> subst_domain \\<sigma> = {}\n  subst_domain \\<sigma> \\<inter> range_vars (compose ss) = {}\n\ngoal (1 subgoal):\n 1. (subst_domain \\<sigma> \\<union> subst_domain (compose ss)) \\<inter>\n    (range_vars \\<sigma> - subst_domain (compose ss) \\<union>\n     range_vars (compose ss)) =\n    {}", "using step(3)"], ["proof (prove)\nusing this:\n  subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n  subst_domain (compose ss) \\<inter> subst_domain \\<sigma> = {}\n  subst_domain \\<sigma> \\<inter> range_vars (compose ss) = {}\n  subst_domain (compose ss) \\<inter> range_vars (compose ss) = {}\n\ngoal (1 subgoal):\n 1. (subst_domain \\<sigma> \\<union> subst_domain (compose ss)) \\<inter>\n    (range_vars \\<sigma> - subst_domain (compose ss) \\<union>\n     range_vars (compose ss)) =\n    {}", "by auto"], ["proof (state)\nthis:\n  (subst_domain \\<sigma> \\<union> subst_domain (compose ss)) \\<inter>\n  (range_vars \\<sigma> - subst_domain (compose ss) \\<union>\n   range_vars (compose ss)) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>E. subst_domain (compose []) \\<inter> range_vars (compose []) = {}\n 2. \\<And>\\<sigma> E E' ss E''.\n       \\<lbrakk>UNIF1 \\<sigma> E E'; UNIF ss E' E'';\n        subst_domain (compose ss) \\<inter> range_vars (compose ss) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> subst_domain (compose (\\<sigma> # ss)) \\<inter>\n                         range_vars (compose (\\<sigma> # ss)) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  (subst_domain \\<sigma> \\<union> subst_domain (compose ss)) \\<inter>\n  (range_vars \\<sigma> - subst_domain (compose ss) \\<union>\n   range_vars (compose ss)) =\n  {}", "show ?case"], ["proof (prove)\nusing this:\n  (subst_domain \\<sigma> \\<union> subst_domain (compose ss)) \\<inter>\n  (range_vars \\<sigma> - subst_domain (compose ss) \\<union>\n   range_vars (compose ss)) =\n  {}\n\ngoal (1 subgoal):\n 1. subst_domain (compose (\\<sigma> # ss)) \\<inter>\n    range_vars (compose (\\<sigma> # ss)) =\n    {}", "using subst_domain_subst_compose [of \\<sigma> \"compose ss\"]\n    and range_vars_subst_compose_subset [of \\<sigma> \"compose ss\"]"], ["proof (prove)\nusing this:\n  (subst_domain \\<sigma> \\<union> subst_domain (compose ss)) \\<inter>\n  (range_vars \\<sigma> - subst_domain (compose ss) \\<union>\n   range_vars (compose ss)) =\n  {}\n  subst_domain (\\<sigma> \\<circ>\\<^sub>s compose ss) =\n  subst_domain \\<sigma> -\n  {x. \\<exists>y. \\<sigma> x = Var y \\<and> compose ss y = Var x} \\<union>\n  (subst_domain (compose ss) - subst_domain \\<sigma>)\n  range_vars (\\<sigma> \\<circ>\\<^sub>s compose ss)\n  \\<subseteq> range_vars \\<sigma> - subst_domain (compose ss) \\<union>\n              range_vars (compose ss)\n\ngoal (1 subgoal):\n 1. subst_domain (compose (\\<sigma> # ss)) \\<inter>\n    range_vars (compose (\\<sigma> # ss)) =\n    {}", "by (auto)"], ["proof (state)\nthis:\n  subst_domain (compose (\\<sigma> # ss)) \\<inter>\n  range_vars (compose (\\<sigma> # ss)) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>E. subst_domain (compose []) \\<inter> range_vars (compose []) = {}", "qed simp"], ["", "text \\<open>The inference rules generate idempotent substitutions.\\<close>"], ["", "lemma UNIF_idemp:\n  assumes \"UNIF ss E E'\"\n  shows \"compose ss \\<circ>\\<^sub>s compose ss = compose ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose ss \\<circ>\\<^sub>s compose ss = compose ss", "using UNIF_subst_domain_range_vars_Int [OF assms]"], ["proof (prove)\nusing this:\n  subst_domain (compose ss) \\<inter> range_vars (compose ss) = {}\n\ngoal (1 subgoal):\n 1. compose ss \\<circ>\\<^sub>s compose ss = compose ss", "by (simp only: subst_idemp_iff)"], ["", "lemma UNIF1_mono:\n  assumes \"UNIF1 \\<sigma> E E'\"\n  shows \"UNIF1 \\<sigma> (E + M) (E' + subst_mset \\<sigma> M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIF1 \\<sigma> (E + M) (E' + subst_mset \\<sigma> M)", "using assms"], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> E E'\n\ngoal (1 subgoal):\n 1. UNIF1 \\<sigma> (E + M) (E' + subst_mset \\<sigma> M)", "by (cases) (auto intro: UNIF1.intros simp: union_commutes subst_mset_union [symmetric])"], ["", "lemma unif_mono:\n  assumes \"(E, E') \\<in> unif\"\n  shows \"\\<exists>\\<sigma>. (E + M, E' + subst_mset \\<sigma> M) \\<in> unif\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. (E + M, E' + subst_mset \\<sigma> M) \\<in> unif", "using assms"], ["proof (prove)\nusing this:\n  (E, E') \\<in> unif\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. (E + M, E' + subst_mset \\<sigma> M) \\<in> unif", "by (auto simp: unif_UNIF1_conv intro: UNIF1_mono)"], ["", "lemma unif_rtrancl_mono:\n  assumes \"(E, E') \\<in> unif\\<^sup>*\"\n  shows \"\\<exists>\\<sigma>. (E + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>.\n       (E + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  (E, E') \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>.\n       (E + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*", "proof (induction arbitrary: M rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<exists>\\<sigma>.\n          (E' + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*\n 2. \\<And>y z M.\n       \\<lbrakk>(y, z) \\<in> unif; (z, E') \\<in> unif\\<^sup>*;\n        \\<And>M.\n           \\<exists>\\<sigma>.\n              (z + M, E' + subst_mset \\<sigma> M)\n              \\<in> unif\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            (y + M, E' + subst_mset \\<sigma> M)\n                            \\<in> unif\\<^sup>*", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<exists>\\<sigma>.\n          (E' + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*\n 2. \\<And>y z M.\n       \\<lbrakk>(y, z) \\<in> unif; (z, E') \\<in> unif\\<^sup>*;\n        \\<And>M.\n           \\<exists>\\<sigma>.\n              (z + M, E' + subst_mset \\<sigma> M)\n              \\<in> unif\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            (y + M, E' + subst_mset \\<sigma> M)\n                            \\<in> unif\\<^sup>*", "have \"(E' + M, E' + subst_mset Var M) \\<in> unif\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (E' + M, E' + subst_mset Var M) \\<in> unif\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (E' + M, E' + subst_mset Var M) \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<exists>\\<sigma>.\n          (E' + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*\n 2. \\<And>y z M.\n       \\<lbrakk>(y, z) \\<in> unif; (z, E') \\<in> unif\\<^sup>*;\n        \\<And>M.\n           \\<exists>\\<sigma>.\n              (z + M, E' + subst_mset \\<sigma> M)\n              \\<in> unif\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            (y + M, E' + subst_mset \\<sigma> M)\n                            \\<in> unif\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (E' + M, E' + subst_mset Var M) \\<in> unif\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  (E' + M, E' + subst_mset Var M) \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>.\n       (E' + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>. (E' + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z M.\n       \\<lbrakk>(y, z) \\<in> unif; (z, E') \\<in> unif\\<^sup>*;\n        \\<And>M.\n           \\<exists>\\<sigma>.\n              (z + M, E' + subst_mset \\<sigma> M)\n              \\<in> unif\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            (y + M, E' + subst_mset \\<sigma> M)\n                            \\<in> unif\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z M.\n       \\<lbrakk>(y, z) \\<in> unif; (z, E') \\<in> unif\\<^sup>*;\n        \\<And>M.\n           \\<exists>\\<sigma>.\n              (z + M, E' + subst_mset \\<sigma> M)\n              \\<in> unif\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            (y + M, E' + subst_mset \\<sigma> M)\n                            \\<in> unif\\<^sup>*", "case (step E F)"], ["proof (state)\nthis:\n  (E, F) \\<in> unif\n  (F, E') \\<in> unif\\<^sup>*\n  \\<exists>\\<sigma>.\n     (F + ?M, E' + subst_mset \\<sigma> ?M) \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z M.\n       \\<lbrakk>(y, z) \\<in> unif; (z, E') \\<in> unif\\<^sup>*;\n        \\<And>M.\n           \\<exists>\\<sigma>.\n              (z + M, E' + subst_mset \\<sigma> M)\n              \\<in> unif\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            (y + M, E' + subst_mset \\<sigma> M)\n                            \\<in> unif\\<^sup>*", "obtain \\<sigma> where \"(E + M, F + subst_mset \\<sigma> M) \\<in> unif\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        (E + M, F + subst_mset \\<sigma> M) \\<in> unif \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using unif_mono [OF \\<open>(E, F) \\<in> unif\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>. (E + ?M, F + subst_mset \\<sigma> ?M) \\<in> unif\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        (E + M, F + subst_mset \\<sigma> M) \\<in> unif \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (E + M, F + subst_mset \\<sigma> M) \\<in> unif\n\ngoal (1 subgoal):\n 1. \\<And>y z M.\n       \\<lbrakk>(y, z) \\<in> unif; (z, E') \\<in> unif\\<^sup>*;\n        \\<And>M.\n           \\<exists>\\<sigma>.\n              (z + M, E' + subst_mset \\<sigma> M)\n              \\<in> unif\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            (y + M, E' + subst_mset \\<sigma> M)\n                            \\<in> unif\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (E + M, F + subst_mset \\<sigma> M) \\<in> unif\n\ngoal (1 subgoal):\n 1. \\<And>y z M.\n       \\<lbrakk>(y, z) \\<in> unif; (z, E') \\<in> unif\\<^sup>*;\n        \\<And>M.\n           \\<exists>\\<sigma>.\n              (z + M, E' + subst_mset \\<sigma> M)\n              \\<in> unif\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            (y + M, E' + subst_mset \\<sigma> M)\n                            \\<in> unif\\<^sup>*", "obtain \\<tau>\n    where \"(F + subst_mset \\<sigma> M, E' + subst_mset \\<tau> (subst_mset \\<sigma> M)) \\<in> unif\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>.\n        (F + subst_mset \\<sigma> M,\n         E' + subst_mset \\<tau> (subst_mset \\<sigma> M))\n        \\<in> unif\\<^sup>* \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using step.IH"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>.\n     (F + ?M, E' + subst_mset \\<sigma> ?M) \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>.\n        (F + subst_mset \\<sigma> M,\n         E' + subst_mset \\<tau> (subst_mset \\<sigma> M))\n        \\<in> unif\\<^sup>* \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (F + subst_mset \\<sigma> M,\n   E' + subst_mset \\<tau> (subst_mset \\<sigma> M))\n  \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z M.\n       \\<lbrakk>(y, z) \\<in> unif; (z, E') \\<in> unif\\<^sup>*;\n        \\<And>M.\n           \\<exists>\\<sigma>.\n              (z + M, E' + subst_mset \\<sigma> M)\n              \\<in> unif\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            (y + M, E' + subst_mset \\<sigma> M)\n                            \\<in> unif\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (E + M, F + subst_mset \\<sigma> M) \\<in> unif\n  (F + subst_mset \\<sigma> M,\n   E' + subst_mset \\<tau> (subst_mset \\<sigma> M))\n  \\<in> unif\\<^sup>*", "have \"(E + M, E' + subst_mset (\\<sigma> \\<circ>\\<^sub>s \\<tau>) M) \\<in> unif\\<^sup>*\""], ["proof (prove)\nusing this:\n  (E + M, F + subst_mset \\<sigma> M) \\<in> unif\n  (F + subst_mset \\<sigma> M,\n   E' + subst_mset \\<tau> (subst_mset \\<sigma> M))\n  \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. (E + M, E' + subst_mset (\\<sigma> \\<circ>\\<^sub>s \\<tau>) M)\n    \\<in> unif\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (E + M, E' + subst_mset (\\<sigma> \\<circ>\\<^sub>s \\<tau>) M)\n  \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z M.\n       \\<lbrakk>(y, z) \\<in> unif; (z, E') \\<in> unif\\<^sup>*;\n        \\<And>M.\n           \\<exists>\\<sigma>.\n              (z + M, E' + subst_mset \\<sigma> M)\n              \\<in> unif\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            (y + M, E' + subst_mset \\<sigma> M)\n                            \\<in> unif\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (E + M, E' + subst_mset (\\<sigma> \\<circ>\\<^sub>s \\<tau>) M)\n  \\<in> unif\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  (E + M, E' + subst_mset (\\<sigma> \\<circ>\\<^sub>s \\<tau>) M)\n  \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>.\n       (E + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>. (E + M, E' + subst_mset \\<sigma> M) \\<in> unif\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Soundness of the Inference Rules\\<close>"], ["", "text \\<open>The inference rules of unification are sound in the sense that\n  when the empty set of equations is reached, a most general unifier\n  is obtained.\\<close>"], ["", "lemma UNIF_empty_imp_is_mgu_compose:\n  fixes E :: \"('f, 'v) equation multiset\"\n  assumes \"UNIF ss E {#}\"\n  shows \"is_mgu (compose ss) (set_mset E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_mgu (compose ss) (set_mset E)", "using assms"], ["proof (prove)\nusing this:\n  UNIF ss E {#}\n\ngoal (1 subgoal):\n 1. is_mgu (compose ss) (set_mset E)", "proof (induct ss E \"{#}::('f, 'v) equation multiset\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_mgu (compose []) (set_mset {#})\n 2. \\<And>\\<sigma> E E' ss.\n       \\<lbrakk>UNIF1 \\<sigma> E E'; UNIF ss E' {#};\n        is_mgu (compose ss) (set_mset E')\\<rbrakk>\n       \\<Longrightarrow> is_mgu (compose (\\<sigma> # ss)) (set_mset E)", "case (step \\<sigma> E E' ss)"], ["proof (state)\nthis:\n  UNIF1 \\<sigma> E E'\n  UNIF ss E' {#}\n  is_mgu (compose ss) (set_mset E')\n\ngoal (2 subgoals):\n 1. is_mgu (compose []) (set_mset {#})\n 2. \\<And>\\<sigma> E E' ss.\n       \\<lbrakk>UNIF1 \\<sigma> E E'; UNIF ss E' {#};\n        is_mgu (compose ss) (set_mset E')\\<rbrakk>\n       \\<Longrightarrow> is_mgu (compose (\\<sigma> # ss)) (set_mset E)", "then"], ["proof (chain)\npicking this:\n  UNIF1 \\<sigma> E E'\n  UNIF ss E' {#}\n  is_mgu (compose ss) (set_mset E')", "show ?case"], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> E E'\n  UNIF ss E' {#}\n  is_mgu (compose ss) (set_mset E')\n\ngoal (1 subgoal):\n 1. is_mgu (compose (\\<sigma> # ss)) (set_mset E)", "by (cases) (auto simp: is_mgu_subst_set_subst)"], ["proof (state)\nthis:\n  is_mgu (compose (\\<sigma> # ss)) (set_mset E)\n\ngoal (1 subgoal):\n 1. is_mgu (compose []) (set_mset {#})", "qed simp"], ["", "subsubsection \\<open>Completeness of the Inference Rules\\<close>"], ["", "lemma UNIF1_singleton_decomp [intro]:\n  assumes \"length ss = length ts\"\n  shows \"UNIF1 Var {#(Fun f ss, Fun f ts)#} (mset (zip ss ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIF1 Var {#(Fun f ss, Fun f ts)#} (mset (zip ss ts))", "using UNIF1.decomp [OF assms, of f \"{#}\"]"], ["proof (prove)\nusing this:\n  UNIF1 Var {#(Fun f ss, Fun f ts)#} ({#} + mset (zip ss ts))\n\ngoal (1 subgoal):\n 1. UNIF1 Var {#(Fun f ss, Fun f ts)#} (mset (zip ss ts))", "by simp"], ["", "lemma UNIF1_singleton_Var_left [intro]:\n  \"x \\<notin> vars_term t \\<Longrightarrow> UNIF1 (subst x t) {#(Var x, t)#} {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars_term t \\<Longrightarrow>\n    UNIF1 (subst x t) {#(Var x, t)#} {#}", "using UNIF1.Var_left [of x t \"{#}\"]"], ["proof (prove)\nusing this:\n  x \\<notin> vars_term t \\<Longrightarrow>\n  UNIF1 (subst x t) {#(Var x, t)#} (subst_mset (subst x t) {#})\n\ngoal (1 subgoal):\n 1. x \\<notin> vars_term t \\<Longrightarrow>\n    UNIF1 (subst x t) {#(Var x, t)#} {#}", "by simp"], ["", "lemma UNIF1_singleton_Var_right [intro]:\n  \"x \\<notin> vars_term t \\<Longrightarrow> UNIF1 (subst x t) {#(t, Var x)#} {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars_term t \\<Longrightarrow>\n    UNIF1 (subst x t) {#(t, Var x)#} {#}", "using UNIF1.Var_right [of x t \"{#}\"]"], ["proof (prove)\nusing this:\n  x \\<notin> vars_term t \\<Longrightarrow>\n  UNIF1 (subst x t) {#(t, Var x)#} (subst_mset (subst x t) {#})\n\ngoal (1 subgoal):\n 1. x \\<notin> vars_term t \\<Longrightarrow>\n    UNIF1 (subst x t) {#(t, Var x)#} {#}", "by simp"], ["", "lemma not_UNIF1_singleton_Var_right [dest]:\n  \"\\<not> UNIF1 Var {#(Var x, Var y)#} {#} \\<Longrightarrow> x \\<noteq> y\"\n  \"\\<not> UNIF1 (subst x (Var y)) {#(Var x, Var y)#} {#} \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> UNIF1 Var {#(Var x, Var y)#} {#} \\<Longrightarrow>\n     x \\<noteq> y) &&&\n    (\\<not> UNIF1 (subst x (Var y)) {#(Var x, Var y)#} {#} \\<Longrightarrow>\n     x = y)", "by auto"], ["", "lemma not_unifD:\n  assumes \"\\<not> (\\<exists>E'. ({#e#}, E') \\<in> unif)\"\n  shows \"(\\<exists>x t. (e = (Var x, t) \\<or> e = (t, Var x)) \\<and> x \\<in> vars_term t \\<and> is_Fun t) \\<or>\n    (\\<exists>f g ss ts. e = (Fun f ss, Fun g ts) \\<and> (f \\<noteq> g \\<or> length ss \\<noteq> length ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x t.\n        (e = (Var x, t) \\<or> e = (t, Var x)) \\<and>\n        x \\<in> vars_term t \\<and> is_Fun t) \\<or>\n    (\\<exists>f g ss ts.\n        e = (Fun f ss, Fun g ts) \\<and>\n        (f \\<noteq> g \\<or> length ss \\<noteq> length ts))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>x t.\n                (e = (Var x, t) \\<or> e = (t, Var x)) \\<and>\n                x \\<in> vars_term t \\<and> is_Fun t) \\<or>\n            (\\<exists>f g ss ts.\n                e = (Fun f ss, Fun g ts) \\<and>\n                (f \\<noteq> g \\<or>\n                 length ss \\<noteq> length ts))) \\<Longrightarrow>\n    False", "assume *: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> ((\\<exists>x t.\n              (e = (Var x, t) \\<or> e = (t, Var x)) \\<and>\n              x \\<in> vars_term t \\<and> is_Fun t) \\<or>\n          (\\<exists>f g ss ts.\n              e = (Fun f ss, Fun g ts) \\<and>\n              (f \\<noteq> g \\<or> length ss \\<noteq> length ts)))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>x t.\n                (e = (Var x, t) \\<or> e = (t, Var x)) \\<and>\n                x \\<in> vars_term t \\<and> is_Fun t) \\<or>\n            (\\<exists>f g ss ts.\n                e = (Fun f ss, Fun g ts) \\<and>\n                (f \\<noteq> g \\<or>\n                 length ss \\<noteq> length ts))) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> False", "case (Pair s t)"], ["proof (state)\nthis:\n  e = (s, t)\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> False", "with assms and *"], ["proof (chain)\npicking this:\n  \\<nexists>E'. ({#e#}, E') \\<in> unif\n  \\<not> ((\\<exists>x t.\n              (e = (Var x, t) \\<or> e = (t, Var x)) \\<and>\n              x \\<in> vars_term t \\<and> is_Fun t) \\<or>\n          (\\<exists>f g ss ts.\n              e = (Fun f ss, Fun g ts) \\<and>\n              (f \\<noteq> g \\<or> length ss \\<noteq> length ts)))\n  e = (s, t)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>E'. ({#e#}, E') \\<in> unif\n  \\<not> ((\\<exists>x t.\n              (e = (Var x, t) \\<or> e = (t, Var x)) \\<and>\n              x \\<in> vars_term t \\<and> is_Fun t) \\<or>\n          (\\<exists>f g ss ts.\n              e = (Fun f ss, Fun g ts) \\<and>\n              (f \\<noteq> g \\<or> length ss \\<noteq> length ts)))\n  e = (s, t)\n\ngoal (1 subgoal):\n 1. False", "by (cases s) (cases t, auto simp: unif_def simp del: term.simps, (blast | succeed))+"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unifiable_imp_unif:\n  assumes \"unifiable {e}\"\n  shows \"\\<exists>E'. ({#e#}, E') \\<in> unif\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E'. ({#e#}, E') \\<in> unif", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>E'. ({#e#}, E') \\<in> unif \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>E'. ({#e#}, E') \\<in> unif\n\ngoal (1 subgoal):\n 1. \\<nexists>E'. ({#e#}, E') \\<in> unif \\<Longrightarrow> False", "from not_unifD [OF this] and assms"], ["proof (chain)\npicking this:\n  (\\<exists>x t.\n      (e = (Var x, t) \\<or> e = (t, Var x)) \\<and>\n      x \\<in> vars_term t \\<and> is_Fun t) \\<or>\n  (\\<exists>f g ss ts.\n      e = (Fun f ss, Fun g ts) \\<and>\n      (f \\<noteq> g \\<or> length ss \\<noteq> length ts))\n  unifiable {e}", "show False"], ["proof (prove)\nusing this:\n  (\\<exists>x t.\n      (e = (Var x, t) \\<or> e = (t, Var x)) \\<and>\n      x \\<in> vars_term t \\<and> is_Fun t) \\<or>\n  (\\<exists>f g ss ts.\n      e = (Fun f ss, Fun g ts) \\<and>\n      (f \\<noteq> g \\<or> length ss \\<noteq> length ts))\n  unifiable {e}\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: unifiable_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unifiable_imp_empty_or_unif:\n  assumes \"unifiable (set_mset E)\"\n  shows \"E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)", "proof (cases E)"], ["proof (state)\ngoal (2 subgoals):\n 1. E = {#} \\<Longrightarrow>\n    E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\n 2. \\<And>x N.\n       E = add_mset x N \\<Longrightarrow>\n       E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)", "case [simp]: (add e E')"], ["proof (state)\nthis:\n  E = add_mset e E'\n\ngoal (2 subgoals):\n 1. E = {#} \\<Longrightarrow>\n    E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\n 2. \\<And>x N.\n       E = add_mset x N \\<Longrightarrow>\n       E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)", "from assms"], ["proof (chain)\npicking this:\n  unifiable (set_mset E)", "have \"unifiable {e}\""], ["proof (prove)\nusing this:\n  unifiable (set_mset E)\n\ngoal (1 subgoal):\n 1. unifiable {e}", "by (auto simp: unifiable_def unifiers_insert)"], ["proof (state)\nthis:\n  unifiable {e}\n\ngoal (2 subgoals):\n 1. E = {#} \\<Longrightarrow>\n    E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\n 2. \\<And>x N.\n       E = add_mset x N \\<Longrightarrow>\n       E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)", "from unifiable_imp_unif [OF this]"], ["proof (chain)\npicking this:\n  \\<exists>E'. ({#e#}, E') \\<in> unif", "obtain E'' where \"({#e#}, E'') \\<in> unif\""], ["proof (prove)\nusing this:\n  \\<exists>E'. ({#e#}, E') \\<in> unif\n\ngoal (1 subgoal):\n 1. (\\<And>E''.\n        ({#e#}, E'') \\<in> unif \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  ({#e#}, E'') \\<in> unif\n\ngoal (2 subgoals):\n 1. E = {#} \\<Longrightarrow>\n    E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\n 2. \\<And>x N.\n       E = add_mset x N \\<Longrightarrow>\n       E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)", "then"], ["proof (chain)\npicking this:\n  ({#e#}, E'') \\<in> unif", "obtain \\<sigma> where \"UNIF1 \\<sigma> {#e#} E''\""], ["proof (prove)\nusing this:\n  ({#e#}, E'') \\<in> unif\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        UNIF1 \\<sigma> {#e#} E'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: unif_UNIF1_conv)"], ["proof (state)\nthis:\n  UNIF1 \\<sigma> {#e#} E''\n\ngoal (2 subgoals):\n 1. E = {#} \\<Longrightarrow>\n    E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\n 2. \\<And>x N.\n       E = add_mset x N \\<Longrightarrow>\n       E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)", "from UNIF1_mono [OF this]"], ["proof (chain)\npicking this:\n  UNIF1 \\<sigma> ({#e#} + ?M) (E'' + subst_mset \\<sigma> ?M)", "have \"UNIF1 \\<sigma> E (E'' + subst_mset \\<sigma> E')\""], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> ({#e#} + ?M) (E'' + subst_mset \\<sigma> ?M)\n\ngoal (1 subgoal):\n 1. UNIF1 \\<sigma> E (E'' + subst_mset \\<sigma> E')", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  UNIF1 \\<sigma> E (E'' + subst_mset \\<sigma> E')\n\ngoal (2 subgoals):\n 1. E = {#} \\<Longrightarrow>\n    E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\n 2. \\<And>x N.\n       E = add_mset x N \\<Longrightarrow>\n       E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)", "then"], ["proof (chain)\npicking this:\n  UNIF1 \\<sigma> E (E'' + subst_mset \\<sigma> E')", "show ?thesis"], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> E (E'' + subst_mset \\<sigma> E')\n\ngoal (1 subgoal):\n 1. E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)", "by (auto simp: unif_UNIF1_conv)"], ["proof (state)\nthis:\n  E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\n\ngoal (1 subgoal):\n 1. E = {#} \\<Longrightarrow>\n    E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)", "qed simp"], ["", "lemma UNIF1_preserves_unifiers:\n  assumes \"UNIF1 \\<sigma> E E'\" and \"\\<tau> \\<in> unifiers (set_mset E)\"\n  shows \"(\\<sigma> \\<circ>\\<^sub>s \\<tau>) \\<in> unifiers (set_mset E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<tau> \\<in> unifiers (set_mset E')", "using assms"], ["proof (prove)\nusing this:\n  UNIF1 \\<sigma> E E'\n  \\<tau> \\<in> unifiers (set_mset E)\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<tau> \\<in> unifiers (set_mset E')", "by (cases) (auto simp: unifiers_def subst_mset_def)"], ["", "lemma unif_preserves_unifiable:\n  assumes \"(E, E') \\<in> unif\" and \"unifiable (set_mset E)\"\n  shows \"unifiable (set_mset E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unifiable (set_mset E')", "using UNIF1_preserves_unifiers [of _ E E'] and assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>UNIF1 ?\\<sigma> E E';\n   ?\\<tau> \\<in> unifiers (set_mset E)\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma> \\<circ>\\<^sub>s ?\\<tau>\n                    \\<in> unifiers (set_mset E')\n  (E, E') \\<in> unif\n  unifiable (set_mset E)\n\ngoal (1 subgoal):\n 1. unifiable (set_mset E')", "by (auto simp: unif_UNIF1_conv unifiable_def)"], ["", "lemma unif_imp_converse_unifless [dest]:\n  \"(x, y) \\<in> unif \\<Longrightarrow> (y, x) \\<in> unifless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> unif \\<Longrightarrow> (y, x) \\<in> unifless", "by (metis UNIF1_unifless unif_UNIF1_conv)"], ["", "text \\<open>Every unifiable set of equations can be reduced to the empty\n  set by applying the inference rules of unification.\\<close>"], ["", "lemma unifiable_imp_empty:\n  assumes \"unifiable (set_mset E)\"\n  shows \"(E, {#}) \\<in> unif\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (E, {#}) \\<in> unif\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  unifiable (set_mset E)\n\ngoal (1 subgoal):\n 1. (E, {#}) \\<in> unif\\<^sup>*", "proof (induct E rule: wf_induct [OF wf_unifless])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> unifless \\<longrightarrow>\n                   unifiable (set_mset y) \\<longrightarrow>\n                   (y, {#}) \\<in> unif\\<^sup>*;\n        unifiable (set_mset x)\\<rbrakk>\n       \\<Longrightarrow> (x, {#}) \\<in> unif\\<^sup>*", "fix E :: \"('f, 'v) equation multiset\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> unifless \\<longrightarrow>\n                   unifiable (set_mset y) \\<longrightarrow>\n                   (y, {#}) \\<in> unif\\<^sup>*;\n        unifiable (set_mset x)\\<rbrakk>\n       \\<Longrightarrow> (x, {#}) \\<in> unif\\<^sup>*", "presume IH: \"\\<And>E'. \\<lbrakk>(E', E) \\<in> unifless; unifiable (set_mset E')\\<rbrakk> \\<Longrightarrow>\n    (E', {#}) \\<in> unif\\<^sup>*\"\n    and *: \"unifiable (set_mset E)\""], ["proof (state)\nthis:\n  \\<lbrakk>(?E', E) \\<in> unifless; unifiable (set_mset ?E')\\<rbrakk>\n  \\<Longrightarrow> (?E', {#}) \\<in> unif\\<^sup>*\n  unifiable (set_mset E)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> unifless \\<longrightarrow>\n                   unifiable (set_mset y) \\<longrightarrow>\n                   (y, {#}) \\<in> unif\\<^sup>*;\n        unifiable (set_mset x)\\<rbrakk>\n       \\<Longrightarrow> (x, {#}) \\<in> unif\\<^sup>*", "show \"(E, {#}) \\<in> unif\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (E, {#}) \\<in> unif\\<^sup>*", "proof (cases \"E = {#}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. E = {#} \\<Longrightarrow> (E, {#}) \\<in> unif\\<^sup>*\n 2. E \\<noteq> {#} \\<Longrightarrow> (E, {#}) \\<in> unif\\<^sup>*", "assume \"E \\<noteq> {#}\""], ["proof (state)\nthis:\n  E \\<noteq> {#}\n\ngoal (2 subgoals):\n 1. E = {#} \\<Longrightarrow> (E, {#}) \\<in> unif\\<^sup>*\n 2. E \\<noteq> {#} \\<Longrightarrow> (E, {#}) \\<in> unif\\<^sup>*", "with unifiable_imp_empty_or_unif [OF *]"], ["proof (chain)\npicking this:\n  E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\n  E \\<noteq> {#}", "obtain E' where \"(E, E') \\<in> unif\""], ["proof (prove)\nusing this:\n  E = {#} \\<or> (\\<exists>E'. (E, E') \\<in> unif)\n  E \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        (E, E') \\<in> unif \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (E, E') \\<in> unif\n\ngoal (2 subgoals):\n 1. E = {#} \\<Longrightarrow> (E, {#}) \\<in> unif\\<^sup>*\n 2. E \\<noteq> {#} \\<Longrightarrow> (E, {#}) \\<in> unif\\<^sup>*", "with *"], ["proof (chain)\npicking this:\n  unifiable (set_mset E)\n  (E, E') \\<in> unif", "have \"(E', E) \\<in> unifless\" and \"unifiable (set_mset E')\""], ["proof (prove)\nusing this:\n  unifiable (set_mset E)\n  (E, E') \\<in> unif\n\ngoal (1 subgoal):\n 1. (E', E) \\<in> unifless &&& unifiable (set_mset E')", "by (auto dest: unif_preserves_unifiable)"], ["proof (state)\nthis:\n  (E', E) \\<in> unifless\n  unifiable (set_mset E')\n\ngoal (2 subgoals):\n 1. E = {#} \\<Longrightarrow> (E, {#}) \\<in> unif\\<^sup>*\n 2. E \\<noteq> {#} \\<Longrightarrow> (E, {#}) \\<in> unif\\<^sup>*", "from IH [OF this] and \\<open>(E, E') \\<in> unif\\<close>"], ["proof (chain)\npicking this:\n  (E', {#}) \\<in> unif\\<^sup>*\n  (E, E') \\<in> unif", "show ?thesis"], ["proof (prove)\nusing this:\n  (E', {#}) \\<in> unif\\<^sup>*\n  (E, E') \\<in> unif\n\ngoal (1 subgoal):\n 1. (E, {#}) \\<in> unif\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (E, {#}) \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. E = {#} \\<Longrightarrow> (E, {#}) \\<in> unif\\<^sup>*", "qed simp"], ["proof (state)\nthis:\n  (E, {#}) \\<in> unif\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>x E'.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> unifless \\<longrightarrow>\n                   unifiable (set_mset y) \\<longrightarrow>\n                   (y, {#}) \\<in> unif\\<^sup>*;\n        unifiable (set_mset x); (E', x) \\<in> unifless;\n        unifiable (set_mset E')\\<rbrakk>\n       \\<Longrightarrow> (E', {#}) \\<in> unif\\<^sup>*\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> unifless \\<longrightarrow>\n                   unifiable (set_mset y) \\<longrightarrow>\n                   (y, {#}) \\<in> unif\\<^sup>*;\n        unifiable (set_mset x)\\<rbrakk>\n       \\<Longrightarrow> unifiable (set_mset x)", "qed simp"], ["", "lemma unif_rtrancl_empty_imp_unifiable:\n  assumes \"(E, {#}) \\<in> unif\\<^sup>*\"\n  shows \"unifiable (set_mset E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unifiable (set_mset E)", "using assms"], ["proof (prove)\nusing this:\n  (E, {#}) \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. unifiable (set_mset E)", "by (auto simp: unif_rtrancl_UNIF_conv unifiable_def is_mgu_def\n           dest!: UNIF_empty_imp_is_mgu_compose)"], ["", "lemma not_unifiable_imp_not_empty_NF:\n  assumes \"\\<not> unifiable (set_mset E)\"\n  shows \"\\<exists>E'. E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>E'. E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>!", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>E'.\n       E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>! \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>E'. E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<nexists>E'.\n       E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>! \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>E'. E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>!", "have *: \"\\<And>E'. (E, E') \\<in> unif\\<^sup>! \\<Longrightarrow> E' = {#}\""], ["proof (prove)\nusing this:\n  \\<nexists>E'. E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>E'. (E, E') \\<in> unif\\<^sup>! \\<Longrightarrow> E' = {#}", "by auto"], ["proof (state)\nthis:\n  (E, ?E') \\<in> unif\\<^sup>! \\<Longrightarrow> ?E' = {#}\n\ngoal (1 subgoal):\n 1. \\<nexists>E'.\n       E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>! \\<Longrightarrow>\n    False", "have \"SN unif\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN unif", "using wf_converse_unif"], ["proof (prove)\nusing this:\n  wf (unif\\<inverse>)\n\ngoal (1 subgoal):\n 1. SN unif", "by (auto simp: SN_iff_wf)"], ["proof (state)\nthis:\n  SN unif\n\ngoal (1 subgoal):\n 1. \\<nexists>E'.\n       E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>! \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  SN unif", "obtain E' where \"(E, E') \\<in> unif\\<^sup>!\""], ["proof (prove)\nusing this:\n  SN unif\n\ngoal (1 subgoal):\n 1. (\\<And>E'.\n        (E, E') \\<in> unif\\<^sup>! \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis SN_imp_WN UNIV_I WN_onE)"], ["proof (state)\nthis:\n  (E, E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<nexists>E'.\n       E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>! \\<Longrightarrow>\n    False", "with *"], ["proof (chain)\npicking this:\n  (E, ?E') \\<in> unif\\<^sup>! \\<Longrightarrow> ?E' = {#}\n  (E, E') \\<in> unif\\<^sup>!", "have \"(E, {#}) \\<in> unif\\<^sup>*\""], ["proof (prove)\nusing this:\n  (E, ?E') \\<in> unif\\<^sup>! \\<Longrightarrow> ?E' = {#}\n  (E, E') \\<in> unif\\<^sup>!\n\ngoal (1 subgoal):\n 1. (E, {#}) \\<in> unif\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (E, {#}) \\<in> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<nexists>E'.\n       E' \\<noteq> {#} \\<and> (E, E') \\<in> unif\\<^sup>! \\<Longrightarrow>\n    False", "from unif_rtrancl_empty_imp_unifiable [OF this] and assms"], ["proof (chain)\npicking this:\n  unifiable (set_mset E)\n  \\<not> unifiable (set_mset E)", "show False"], ["proof (prove)\nusing this:\n  unifiable (set_mset E)\n  \\<not> unifiable (set_mset E)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unif_rtrancl_preserves_unifiable:\n  assumes \"(E, E') \\<in> unif\\<^sup>*\" and \"unifiable (set_mset E)\"\n  shows \"unifiable (set_mset E')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unifiable (set_mset E')", "using assms"], ["proof (prove)\nusing this:\n  (E, E') \\<in> unif\\<^sup>*\n  unifiable (set_mset E)\n\ngoal (1 subgoal):\n 1. unifiable (set_mset E')", "by (induct) (auto simp: unif_preserves_unifiable)"], ["", "text \\<open>The inference rules for unification are complete in the\n  sense that whenever it is not possible to reduce a set of equations\n  @{term E} to the empty set, then @{term E} is not unifiable.\\<close>"], ["", "lemma empty_not_reachable_imp_not_unifiable:\n  assumes \"(E, {#}) \\<notin> unif\\<^sup>*\"\n  shows \"\\<not> unifiable (set_mset E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unifiable (set_mset E)", "using unifiable_imp_empty [of E] and assms"], ["proof (prove)\nusing this:\n  unifiable (set_mset E) \\<Longrightarrow> (E, {#}) \\<in> unif\\<^sup>*\n  (E, {#}) \\<notin> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set_mset E)", "by blast"], ["", "text \\<open>It is enough to reach an irreducible set of equations\n  to conclude non-unifiability.\\<close>"], ["", "lemma irreducible_reachable_imp_not_unifiable:\n  assumes \"(E, E') \\<in> unif\\<^sup>!\" and \"E' \\<noteq> {#}\"\n  shows \"\\<not> unifiable (set_mset E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unifiable (set_mset E)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> unifiable (set_mset E)", "have \"(E, E') \\<in> unif\\<^sup>*\" and \"(E', {#}) \\<notin> unif\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (E, E') \\<in> unif\\<^sup>* &&& (E', {#}) \\<notin> unif\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  (E, E') \\<in> unif\\<^sup>!\n  E' \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (E, E') \\<in> unif\\<^sup>* &&& (E', {#}) \\<notin> unif\\<^sup>*", "by (auto simp: NF_not_suc)"], ["proof (state)\nthis:\n  (E, E') \\<in> unif\\<^sup>*\n  (E', {#}) \\<notin> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set_mset E)", "moreover"], ["proof (state)\nthis:\n  (E, E') \\<in> unif\\<^sup>*\n  (E', {#}) \\<notin> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set_mset E)", "with empty_not_reachable_imp_not_unifiable"], ["proof (chain)\npicking this:\n  (?E, {#}) \\<notin> unif\\<^sup>* \\<Longrightarrow>\n  \\<not> unifiable (set_mset ?E)\n  (E, E') \\<in> unif\\<^sup>*\n  (E', {#}) \\<notin> unif\\<^sup>*", "have \"\\<not> unifiable (set_mset E')\""], ["proof (prove)\nusing this:\n  (?E, {#}) \\<notin> unif\\<^sup>* \\<Longrightarrow>\n  \\<not> unifiable (set_mset ?E)\n  (E, E') \\<in> unif\\<^sup>*\n  (E', {#}) \\<notin> unif\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set_mset E')", "by fast"], ["proof (state)\nthis:\n  \\<not> unifiable (set_mset E')\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set_mset E)", "ultimately"], ["proof (chain)\npicking this:\n  (E, E') \\<in> unif\\<^sup>*\n  (E', {#}) \\<notin> unif\\<^sup>*\n  \\<not> unifiable (set_mset E')", "show ?thesis"], ["proof (prove)\nusing this:\n  (E, E') \\<in> unif\\<^sup>*\n  (E', {#}) \\<notin> unif\\<^sup>*\n  \\<not> unifiable (set_mset E')\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set_mset E)", "using unif_rtrancl_preserves_unifiable"], ["proof (prove)\nusing this:\n  (E, E') \\<in> unif\\<^sup>*\n  (E', {#}) \\<notin> unif\\<^sup>*\n  \\<not> unifiable (set_mset E')\n  \\<lbrakk>(?E, ?E') \\<in> unif\\<^sup>*; unifiable (set_mset ?E)\\<rbrakk>\n  \\<Longrightarrow> unifiable (set_mset ?E')\n\ngoal (1 subgoal):\n 1. \\<not> unifiable (set_mset E)", "by fast"], ["proof (state)\nthis:\n  \\<not> unifiable (set_mset E)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}