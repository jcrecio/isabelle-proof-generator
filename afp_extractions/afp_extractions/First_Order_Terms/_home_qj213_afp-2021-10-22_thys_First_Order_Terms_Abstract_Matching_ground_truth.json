{"file_name": "/home/qj213/afp-2021-10-22/thys/First_Order_Terms/Abstract_Matching.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/First_Order_Terms", "problem_names": ["lemma singleton_eq_union_iff [iff]:\n  \"{#x#} = M + {#y#} \\<longleftrightarrow> M = {#} \\<and> x = y\"", "lemma size_mset_mset_less [simp]:\n  assumes \"length ss = length ts\"\n  shows \"size_mset (mset (zip ss ts)) < 3 + (size_list size ss + size_list size ts)\"", "lemma matchers_vars_term_eq:\n  assumes \"\\<sigma> \\<in> matchers P\" and \"\\<tau> \\<in> matchers P\"\n    and \"(s, t) \\<in> P\"\n  shows \"\\<forall>x\\<in>vars_term s. \\<sigma> x = \\<tau> x\"", "lemma matchers_empty [simp]:\n  \"matchers {} = UNIV\"", "lemma matchers_insert [simp]:\n  \"matchers (insert e P) = {\\<sigma>. fst e \\<cdot> \\<sigma> = snd e} \\<inter> matchers P\"", "lemma matchers_Un [simp]:\n  \"matchers (P \\<union> P') = matchers P \\<inter> matchers P'\"", "lemma matchers_set_zip [simp]:\n  assumes \"length ss = length ts\"\n  shows \"matchers (set (zip ss ts)) = {\\<sigma>. map (\\<lambda>t. t \\<cdot> \\<sigma>) ss = ts}\"", "lemma matchers_map_empty [simp]:\n  \"matchers_map Map.empty = UNIV\"", "lemma matchers_map_upd [simp]:\n  assumes \"\\<sigma> x = None \\<or> \\<sigma> x = Some t\"\n  shows \"matchers_map (\\<lambda>y. if y = x then Some t else \\<sigma> y) =\n    matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}\" (is \"?L = ?R\")", "lemma matchers_map_upd' [simp]:\n  assumes \"\\<sigma> x = None \\<or> \\<sigma> x = Some t\"\n  shows \"matchers_map (\\<sigma> (x \\<mapsto> t)) = matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}\"", "lemma MATCH1_matchers [simp]:\n  assumes \"MATCH1 x y\"\n  shows \"matchers_map (snd x) \\<inter> matchers (set_mset (fst x)) =\n    matchers_map (snd y) \\<inter> matchers (set_mset (fst y))\"", "lemma MATCH1_matchrel_conv:\n  \"MATCH1 x y \\<longleftrightarrow> (x, y) \\<in> matchrel\"", "lemma matchrel_rtrancl_matchers [simp]:\n  assumes \"(x, y) \\<in> matchrel\\<^sup>*\"\n  shows \"matchers_map (snd x) \\<inter> matchers (set_mset (fst x)) =\n    matchers_map (snd y) \\<inter> matchers (set_mset (fst y))\"", "lemma subst_of_map_in_matchers_map [simp]:\n  \"subst_of_map d m \\<in> matchers_map m\"", "lemma matchrel_sound:\n  assumes \"((P, Map.empty), ({#}, \\<sigma>)) \\<in> matchrel\\<^sup>*\"\n  shows \"subst_of_map d \\<sigma> \\<in> matchers (set_mset P)\"", "lemma MATCH1_size_mset:\n  assumes \"MATCH1 x y\"\n  shows \"size_mset (fst x) > size_mset (fst y)\"", "lemma wf_matchless:\n  \"wf matchless\"", "lemma MATCH1_matchless:\n  assumes \"MATCH1 x y\"\n  shows \"(y, x) \\<in> matchless\"", "lemma converse_matchrel_subset_matchless:\n  \"matchrel\\<inverse> \\<subseteq> matchless\"", "lemma wf_converse_matchrel:\n  \"wf (matchrel\\<inverse>)\"", "lemma MATCH1_singleton_Var [intro]:\n  \"\\<sigma> x = None \\<Longrightarrow> MATCH1 ({#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma> (x \\<mapsto> t))\"\n  \"\\<sigma> x = Some t \\<Longrightarrow> MATCH1 ({#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma> (x \\<mapsto> t))\"", "lemma MATCH1_singleton_Fun [intro]:\n  \"length ss = length ts \\<Longrightarrow> MATCH1 ({#(Fun f ss, Fun f ts)#}, \\<sigma>) (mset (zip ss ts), \\<sigma>)\"", "lemma not_MATCH1_singleton_Var [dest]:\n  \"\\<not> MATCH1 ({#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma> (x \\<mapsto> t)) \\<Longrightarrow> \\<sigma> x \\<noteq> None \\<and> \\<sigma> x \\<noteq> Some t\"", "lemma not_matchrelD:\n  assumes \"\\<not> (\\<exists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel)\"\n  shows \"(\\<exists>f ss x. e = (Fun f ss, Var x)) \\<or>\n    (\\<exists>x t. e = (Var x, t) \\<and> \\<sigma> x \\<noteq> None \\<and> \\<sigma> x \\<noteq> Some t) \\<or>\n    (\\<exists>f g ss ts. e = (Fun f ss, Fun g ts) \\<and> (f \\<noteq> g \\<or> length ss \\<noteq> length ts))\"", "lemma ne_matchers_imp_matchrel:\n  assumes \"matchers_map \\<sigma> \\<inter> matchers {e} \\<noteq> {}\"\n  shows \"\\<exists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel\"", "lemma MATCH1_mono:\n  assumes \"MATCH1 (P, \\<sigma>) (P', \\<sigma>')\"\n  shows \"MATCH1 (P + M, \\<sigma>) (P' + M, \\<sigma>')\"", "lemma matchrel_mono:\n  assumes \"(x, y) \\<in> matchrel\"\n  shows \"((fst x + M, snd x), (fst y + M, snd y)) \\<in> matchrel\"", "lemma matchrel_rtrancl_mono:\n  assumes \"(x, y) \\<in> matchrel\\<^sup>*\"\n  shows \"((fst x + M, snd x), (fst y + M, snd y)) \\<in> matchrel\\<^sup>*\"", "lemma ne_matchers_imp_empty_or_matchrel:\n  assumes \"matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\"\n  shows \"P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\"", "lemma matchrel_imp_converse_matchless [dest]:\n  \"(x, y) \\<in> matchrel \\<Longrightarrow> (y, x) \\<in> matchless\"", "lemma ne_matchers_imp_empty:\n  fixes P :: \"(('f, 'v) term \\<times> ('f, 'w) term) multiset\"\n  assumes \"matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\"\n  shows \"\\<exists>\\<sigma>'. ((P, \\<sigma>), ({#}, \\<sigma>')) \\<in> matchrel\\<^sup>*\"", "lemma empty_not_reachable_imp_matchers_empty:\n  assumes \"\\<And>\\<sigma>'. ((P, \\<sigma>), ({#}, \\<sigma>')) \\<notin> matchrel\\<^sup>*\"\n  shows \"matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}\"", "lemma irreducible_reachable_imp_matchers_empty:\n  assumes \"((P, \\<sigma>), y) \\<in> matchrel\\<^sup>!\" and \"fst y \\<noteq> {#}\"\n  shows \"matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}\"", "lemma matchers_map_not_empty [simp]:\n  \"matchers_map \\<sigma> \\<noteq> {}\"\n  \"{} \\<noteq> matchers_map \\<sigma>\"", "lemma matchers_empty_imp_not_empty_NF:\n  assumes \"matchers (set_mset P) = {}\"\n  shows \"\\<exists>y. fst y \\<noteq> {#} \\<and> ((P, Map.empty), y) \\<in> matchrel\\<^sup>!\""], "translations": [["", "lemma singleton_eq_union_iff [iff]:\n  \"{#x#} = M + {#y#} \\<longleftrightarrow> M = {#} \\<and> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#x#} = M + {#y#}) = (M = {#} \\<and> x = y)", "by (metis multi_self_add_other_not_self single_eq_single single_is_union)"], ["", "text \\<open>Turning functional maps into substitutions.\\<close>"], ["", "definition \"subst_of_map d \\<sigma> x =\n  (case \\<sigma> x of\n    None \\<Rightarrow> d x\n  | Some t \\<Rightarrow> t)\""], ["", "lemma size_mset_mset_less [simp]:\n  assumes \"length ss = length ts\"\n  shows \"size_mset (mset (zip ss ts)) < 3 + (size_list size ss + size_list size ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_mset (mset (zip ss ts))\n    < 3 + (size_list size ss + size_list size ts)", "using assms"], ["proof (prove)\nusing this:\n  length ss = length ts\n\ngoal (1 subgoal):\n 1. size_mset (mset (zip ss ts))\n    < 3 + (size_list size ss + size_list size ts)", "by (induct ss ts rule: list_induct2) (auto simp: pair_size_def)"], ["", "definition matchers :: \"(('f, 'v) term \\<times> ('f, 'w) term) set \\<Rightarrow> ('f, 'v, 'w) gsubst set\"\n  where\n    \"matchers P = {\\<sigma>. \\<forall>e\\<in>P. fst e \\<cdot> \\<sigma> = snd e}\""], ["", "lemma matchers_vars_term_eq:\n  assumes \"\\<sigma> \\<in> matchers P\" and \"\\<tau> \\<in> matchers P\"\n    and \"(s, t) \\<in> P\"\n  shows \"\\<forall>x\\<in>vars_term s. \\<sigma> x = \\<tau> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_term s. \\<sigma> x = \\<tau> x", "using assms"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> matchers P\n  \\<tau> \\<in> matchers P\n  (s, t) \\<in> P\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_term s. \\<sigma> x = \\<tau> x", "unfolding term_subst_eq_conv [symmetric]"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> matchers P\n  \\<tau> \\<in> matchers P\n  (s, t) \\<in> P\n\ngoal (1 subgoal):\n 1. s \\<cdot> \\<sigma> = s \\<cdot> \\<tau>", "by (force simp: matchers_def)"], ["", "lemma matchers_empty [simp]:\n  \"matchers {} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers {} = UNIV", "by (simp add: matchers_def)"], ["", "lemma matchers_insert [simp]:\n  \"matchers (insert e P) = {\\<sigma>. fst e \\<cdot> \\<sigma> = snd e} \\<inter> matchers P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers (insert e P) =\n    {\\<sigma>. fst e \\<cdot> \\<sigma> = snd e} \\<inter> matchers P", "by (auto simp: matchers_def)"], ["", "lemma matchers_Un [simp]:\n  \"matchers (P \\<union> P') = matchers P \\<inter> matchers P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers (P \\<union> P') = matchers P \\<inter> matchers P'", "by (auto simp: matchers_def)"], ["", "lemma matchers_set_zip [simp]:\n  assumes \"length ss = length ts\"\n  shows \"matchers (set (zip ss ts)) = {\\<sigma>. map (\\<lambda>t. t \\<cdot> \\<sigma>) ss = ts}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers (set (zip ss ts)) =\n    {\\<sigma>. map (\\<lambda>t. t \\<cdot> \\<sigma>) ss = ts}", "using assms"], ["proof (prove)\nusing this:\n  length ss = length ts\n\ngoal (1 subgoal):\n 1. matchers (set (zip ss ts)) =\n    {\\<sigma>. map (\\<lambda>t. t \\<cdot> \\<sigma>) ss = ts}", "by (induct ss ts rule: list_induct2) auto"], ["", "definition \"matchers_map m = matchers ((\\<lambda>x. (Var x, the (m x))) ` Map.dom m)\""], ["", "lemma matchers_map_empty [simp]:\n  \"matchers_map Map.empty = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers_map Map.empty = UNIV", "by (simp add: matchers_map_def)"], ["", "lemma matchers_map_upd [simp]:\n  assumes \"\\<sigma> x = None \\<or> \\<sigma> x = Some t\"\n  shows \"matchers_map (\\<lambda>y. if y = x then Some t else \\<sigma> y) =\n    matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers_map (\\<lambda>y. if y = x then Some t else \\<sigma> y) =\n    matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. matchers_map (\\<lambda>y. if y = x then Some t else \\<sigma> y)\n    \\<subseteq> matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}\n 2. matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}\n    \\<subseteq> matchers_map\n                 (\\<lambda>y. if y = x then Some t else \\<sigma> y)", "show \"?L \\<supseteq> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}\n    \\<subseteq> matchers_map\n                 (\\<lambda>y. if y = x then Some t else \\<sigma> y)", "by (auto simp: matchers_map_def matchers_def)"], ["proof (state)\nthis:\n  matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}\n  \\<subseteq> matchers_map\n               (\\<lambda>y. if y = x then Some t else \\<sigma> y)\n\ngoal (1 subgoal):\n 1. matchers_map (\\<lambda>y. if y = x then Some t else \\<sigma> y)\n    \\<subseteq> matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. matchers_map (\\<lambda>y. if y = x then Some t else \\<sigma> y)\n    \\<subseteq> matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}", "show \"?L \\<subseteq> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers_map (\\<lambda>y. if y = x then Some t else \\<sigma> y)\n    \\<subseteq> matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}", "by (rule subsetI)\n       (insert assms, auto simp: matchers_map_def matchers_def dom_def)"], ["proof (state)\nthis:\n  matchers_map (\\<lambda>y. if y = x then Some t else \\<sigma> y)\n  \\<subseteq> matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matchers_map_upd' [simp]:\n  assumes \"\\<sigma> x = None \\<or> \\<sigma> x = Some t\"\n  shows \"matchers_map (\\<sigma> (x \\<mapsto> t)) = matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers_map (\\<sigma>(x \\<mapsto> t)) =\n    matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}", "using matchers_map_upd [of \\<sigma> x t, OF assms]"], ["proof (prove)\nusing this:\n  matchers_map (\\<lambda>y. if y = x then Some t else \\<sigma> y) =\n  matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}\n\ngoal (1 subgoal):\n 1. matchers_map (\\<sigma>(x \\<mapsto> t)) =\n    matchers_map \\<sigma> \\<inter> {\\<tau>. \\<tau> x = t}", "by (simp add: matchers_map_def matchers_def dom_def)"], ["", "inductive MATCH1 where\n  Var [intro!, simp]: \"\\<sigma> x = None \\<or> \\<sigma> x = Some t \\<Longrightarrow>\n    MATCH1 (P + {#(Var x, t)#}, \\<sigma>) (P, \\<sigma> (x \\<mapsto> t))\" |\n  Fun [intro]: \"length ss = length ts \\<Longrightarrow>\n    MATCH1 (P + {#(Fun f ss, Fun f ts)#}, \\<sigma>) (P + mset (zip ss ts), \\<sigma>)\""], ["", "lemma MATCH1_matchers [simp]:\n  assumes \"MATCH1 x y\"\n  shows \"matchers_map (snd x) \\<inter> matchers (set_mset (fst x)) =\n    matchers_map (snd y) \\<inter> matchers (set_mset (fst y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers_map (snd x) \\<inter> matchers (set_mset (fst x)) =\n    matchers_map (snd y) \\<inter> matchers (set_mset (fst y))", "using assms"], ["proof (prove)\nusing this:\n  MATCH1 x y\n\ngoal (1 subgoal):\n 1. matchers_map (snd x) \\<inter> matchers (set_mset (fst x)) =\n    matchers_map (snd y) \\<inter> matchers (set_mset (fst y))", "by (induct) (simp_all add: ac_simps)"], ["", "definition \"matchrel = {(x, y). MATCH1 x y}\""], ["", "lemma MATCH1_matchrel_conv:\n  \"MATCH1 x y \\<longleftrightarrow> (x, y) \\<in> matchrel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MATCH1 x y = ((x, y) \\<in> matchrel)", "by (simp add: matchrel_def)"], ["", "lemma matchrel_rtrancl_matchers [simp]:\n  assumes \"(x, y) \\<in> matchrel\\<^sup>*\"\n  shows \"matchers_map (snd x) \\<inter> matchers (set_mset (fst x)) =\n    matchers_map (snd y) \\<inter> matchers (set_mset (fst y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers_map (snd x) \\<inter> matchers (set_mset (fst x)) =\n    matchers_map (snd y) \\<inter> matchers (set_mset (fst y))", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> matchrel\\<^sup>*\n\ngoal (1 subgoal):\n 1. matchers_map (snd x) \\<inter> matchers (set_mset (fst x)) =\n    matchers_map (snd y) \\<inter> matchers (set_mset (fst y))", "by (induct) (simp_all add: matchrel_def)"], ["", "lemma subst_of_map_in_matchers_map [simp]:\n  \"subst_of_map d m \\<in> matchers_map m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_of_map d m \\<in> matchers_map m", "by (auto simp: subst_of_map_def [abs_def] matchers_map_def matchers_def)"], ["", "lemma matchrel_sound:\n  assumes \"((P, Map.empty), ({#}, \\<sigma>)) \\<in> matchrel\\<^sup>*\"\n  shows \"subst_of_map d \\<sigma> \\<in> matchers (set_mset P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_of_map d \\<sigma> \\<in> matchers (set_mset P)", "using matchrel_rtrancl_matchers [OF assms]"], ["proof (prove)\nusing this:\n  matchers_map (snd (P, Map.empty)) \\<inter>\n  matchers (set_mset (fst (P, Map.empty))) =\n  matchers_map (snd ({#}, \\<sigma>)) \\<inter>\n  matchers (set_mset (fst ({#}, \\<sigma>)))\n\ngoal (1 subgoal):\n 1. subst_of_map d \\<sigma> \\<in> matchers (set_mset P)", "by simp"], ["", "lemma MATCH1_size_mset:\n  assumes \"MATCH1 x y\"\n  shows \"size_mset (fst x) > size_mset (fst y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_mset (fst y) < size_mset (fst x)", "using assms"], ["proof (prove)\nusing this:\n  MATCH1 x y\n\ngoal (1 subgoal):\n 1. size_mset (fst y) < size_mset (fst x)", "by (cases) (auto simp: pair_size_def)+"], ["", "definition \"matchless = inv_image (measure size_mset) fst\""], ["", "lemma wf_matchless:\n  \"wf matchless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf matchless", "by (auto simp: matchless_def)"], ["", "lemma MATCH1_matchless:\n  assumes \"MATCH1 x y\"\n  shows \"(y, x) \\<in> matchless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> matchless", "using MATCH1_size_mset [OF assms]"], ["proof (prove)\nusing this:\n  size_mset (fst y) < size_mset (fst x)\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> matchless", "by (simp add: matchless_def)"], ["", "lemma converse_matchrel_subset_matchless:\n  \"matchrel\\<inverse> \\<subseteq> matchless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchrel\\<inverse> \\<subseteq> matchless", "using MATCH1_matchless"], ["proof (prove)\nusing this:\n  MATCH1 ?x ?y \\<Longrightarrow> (?y, ?x) \\<in> matchless\n\ngoal (1 subgoal):\n 1. matchrel\\<inverse> \\<subseteq> matchless", "by (auto simp: matchrel_def)"], ["", "lemma wf_converse_matchrel:\n  \"wf (matchrel\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (matchrel\\<inverse>)", "by (rule wf_subset [OF wf_matchless converse_matchrel_subset_matchless])"], ["", "lemma MATCH1_singleton_Var [intro]:\n  \"\\<sigma> x = None \\<Longrightarrow> MATCH1 ({#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma> (x \\<mapsto> t))\"\n  \"\\<sigma> x = Some t \\<Longrightarrow> MATCH1 ({#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma> (x \\<mapsto> t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> x = None \\<Longrightarrow>\n     MATCH1 ({#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma>(x \\<mapsto> t))) &&&\n    (\\<sigma> x = Some t \\<Longrightarrow>\n     MATCH1 ({#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma>(x \\<mapsto> t)))", "using MATCH1.Var [of \\<sigma> x t \"{#}\"]"], ["proof (prove)\nusing this:\n  \\<sigma> x = None \\<or> \\<sigma> x = Some t \\<Longrightarrow>\n  MATCH1 ({#} + {#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma>(x \\<mapsto> t))\n\ngoal (1 subgoal):\n 1. (\\<sigma> x = None \\<Longrightarrow>\n     MATCH1 ({#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma>(x \\<mapsto> t))) &&&\n    (\\<sigma> x = Some t \\<Longrightarrow>\n     MATCH1 ({#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma>(x \\<mapsto> t)))", "by simp_all"], ["", "lemma MATCH1_singleton_Fun [intro]:\n  \"length ss = length ts \\<Longrightarrow> MATCH1 ({#(Fun f ss, Fun f ts)#}, \\<sigma>) (mset (zip ss ts), \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ss = length ts \\<Longrightarrow>\n    MATCH1 ({#(Fun f ss, Fun f ts)#}, \\<sigma>) (mset (zip ss ts), \\<sigma>)", "using MATCH1.Fun [of ss ts \"{#}\" f \\<sigma>]"], ["proof (prove)\nusing this:\n  length ss = length ts \\<Longrightarrow>\n  MATCH1 ({#} + {#(Fun f ss, Fun f ts)#}, \\<sigma>)\n   ({#} + mset (zip ss ts), \\<sigma>)\n\ngoal (1 subgoal):\n 1. length ss = length ts \\<Longrightarrow>\n    MATCH1 ({#(Fun f ss, Fun f ts)#}, \\<sigma>) (mset (zip ss ts), \\<sigma>)", "by simp"], ["", "lemma not_MATCH1_singleton_Var [dest]:\n  \"\\<not> MATCH1 ({#(Var x, t)#}, \\<sigma>) ({#}, \\<sigma> (x \\<mapsto> t)) \\<Longrightarrow> \\<sigma> x \\<noteq> None \\<and> \\<sigma> x \\<noteq> Some t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> MATCH1 ({#(Var x, t)#}, \\<sigma>)\n            ({#}, \\<sigma>(x \\<mapsto> t)) \\<Longrightarrow>\n    \\<sigma> x \\<noteq> None \\<and> \\<sigma> x \\<noteq> Some t", "by auto"], ["", "lemma not_matchrelD:\n  assumes \"\\<not> (\\<exists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel)\"\n  shows \"(\\<exists>f ss x. e = (Fun f ss, Var x)) \\<or>\n    (\\<exists>x t. e = (Var x, t) \\<and> \\<sigma> x \\<noteq> None \\<and> \\<sigma> x \\<noteq> Some t) \\<or>\n    (\\<exists>f g ss ts. e = (Fun f ss, Fun g ts) \\<and> (f \\<noteq> g \\<or> length ss \\<noteq> length ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f ss x. e = (Fun f ss, Var x)) \\<or>\n    (\\<exists>x t.\n        e = (Var x, t) \\<and>\n        \\<sigma> x \\<noteq> None \\<and> \\<sigma> x \\<noteq> Some t) \\<or>\n    (\\<exists>f g ss ts.\n        e = (Fun f ss, Fun g ts) \\<and>\n        (f \\<noteq> g \\<or> length ss \\<noteq> length ts))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>f ss x. e = (Fun f ss, Var x)) \\<or>\n            (\\<exists>x t.\n                e = (Var x, t) \\<and>\n                \\<sigma> x \\<noteq> None \\<and>\n                \\<sigma> x \\<noteq> Some t) \\<or>\n            (\\<exists>f g ss ts.\n                e = (Fun f ss, Fun g ts) \\<and>\n                (f \\<noteq> g \\<or>\n                 length ss \\<noteq> length ts))) \\<Longrightarrow>\n    False", "assume *: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> ((\\<exists>f ss x. e = (Fun f ss, Var x)) \\<or>\n          (\\<exists>x t.\n              e = (Var x, t) \\<and>\n              \\<sigma> x \\<noteq> None \\<and>\n              \\<sigma> x \\<noteq> Some t) \\<or>\n          (\\<exists>f g ss ts.\n              e = (Fun f ss, Fun g ts) \\<and>\n              (f \\<noteq> g \\<or> length ss \\<noteq> length ts)))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>f ss x. e = (Fun f ss, Var x)) \\<or>\n            (\\<exists>x t.\n                e = (Var x, t) \\<and>\n                \\<sigma> x \\<noteq> None \\<and>\n                \\<sigma> x \\<noteq> Some t) \\<or>\n            (\\<exists>f g ss ts.\n                e = (Fun f ss, Fun g ts) \\<and>\n                (f \\<noteq> g \\<or>\n                 length ss \\<noteq> length ts))) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> False", "case (Pair s t)"], ["proof (state)\nthis:\n  e = (s, t)\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> False", "with assms and *"], ["proof (chain)\npicking this:\n  \\<nexists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel\n  \\<not> ((\\<exists>f ss x. e = (Fun f ss, Var x)) \\<or>\n          (\\<exists>x t.\n              e = (Var x, t) \\<and>\n              \\<sigma> x \\<noteq> None \\<and>\n              \\<sigma> x \\<noteq> Some t) \\<or>\n          (\\<exists>f g ss ts.\n              e = (Fun f ss, Fun g ts) \\<and>\n              (f \\<noteq> g \\<or> length ss \\<noteq> length ts)))\n  e = (s, t)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel\n  \\<not> ((\\<exists>f ss x. e = (Fun f ss, Var x)) \\<or>\n          (\\<exists>x t.\n              e = (Var x, t) \\<and>\n              \\<sigma> x \\<noteq> None \\<and>\n              \\<sigma> x \\<noteq> Some t) \\<or>\n          (\\<exists>f g ss ts.\n              e = (Fun f ss, Fun g ts) \\<and>\n              (f \\<noteq> g \\<or> length ss \\<noteq> length ts)))\n  e = (s, t)\n\ngoal (1 subgoal):\n 1. False", "by (cases s) (cases t, auto simp: matchrel_def)+"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ne_matchers_imp_matchrel:\n  assumes \"matchers_map \\<sigma> \\<inter> matchers {e} \\<noteq> {}\"\n  shows \"\\<exists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel\n\ngoal (1 subgoal):\n 1. \\<nexists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel \\<Longrightarrow>\n    False", "from not_matchrelD [OF this] and assms"], ["proof (chain)\npicking this:\n  (\\<exists>f ss x. e = (Fun f ss, Var x)) \\<or>\n  (\\<exists>x t.\n      e = (Var x, t) \\<and>\n      \\<sigma> x \\<noteq> None \\<and> \\<sigma> x \\<noteq> Some t) \\<or>\n  (\\<exists>f g ss ts.\n      e = (Fun f ss, Fun g ts) \\<and>\n      (f \\<noteq> g \\<or> length ss \\<noteq> length ts))\n  matchers_map \\<sigma> \\<inter> matchers {e} \\<noteq> {}", "show False"], ["proof (prove)\nusing this:\n  (\\<exists>f ss x. e = (Fun f ss, Var x)) \\<or>\n  (\\<exists>x t.\n      e = (Var x, t) \\<and>\n      \\<sigma> x \\<noteq> None \\<and> \\<sigma> x \\<noteq> Some t) \\<or>\n  (\\<exists>f g ss ts.\n      e = (Fun f ss, Fun g ts) \\<and>\n      (f \\<noteq> g \\<or> length ss \\<noteq> length ts))\n  matchers_map \\<sigma> \\<inter> matchers {e} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: matchers_map_def matchers_def dom_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MATCH1_mono:\n  assumes \"MATCH1 (P, \\<sigma>) (P', \\<sigma>')\"\n  shows \"MATCH1 (P + M, \\<sigma>) (P' + M, \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MATCH1 (P + M, \\<sigma>) (P' + M, \\<sigma>')", "using assms"], ["proof (prove)\nusing this:\n  MATCH1 (P, \\<sigma>) (P', \\<sigma>')\n\ngoal (1 subgoal):\n 1. MATCH1 (P + M, \\<sigma>) (P' + M, \\<sigma>')", "apply (cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>P = P' + {#(Var x, t)#};\n        \\<sigma>' = \\<sigma>(x \\<mapsto> t);\n        \\<sigma> x = None \\<or> \\<sigma> x = Some t\\<rbrakk>\n       \\<Longrightarrow> MATCH1 (P + M, \\<sigma>) (P' + M, \\<sigma>')\n 2. \\<And>ss ts Pa f.\n       \\<lbrakk>P = Pa + {#(Fun f ss, Fun f ts)#};\n        P' = Pa + mset (zip ss ts); \\<sigma>' = \\<sigma>;\n        length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> MATCH1 (P + M, \\<sigma>) (P' + M, \\<sigma>')", "apply (auto simp: ac_simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>P = add_mset (Var x, t) P';\n        \\<sigma>' = \\<sigma>(x \\<mapsto> t); \\<sigma> x = None\\<rbrakk>\n       \\<Longrightarrow> MATCH1 (add_mset (Var x, t) (M + P'), \\<sigma>)\n                          (M + P', \\<sigma>(x \\<mapsto> t))\n 2. \\<And>x t.\n       \\<lbrakk>P = add_mset (Var x, t) P';\n        \\<sigma>' = \\<sigma>(x \\<mapsto> t); \\<sigma> x = Some t\\<rbrakk>\n       \\<Longrightarrow> MATCH1 (add_mset (Var x, t) (M + P'), \\<sigma>)\n                          (M + P', \\<sigma>(x \\<mapsto> t))\n 3. \\<And>ss ts Pa f.\n       \\<lbrakk>P = add_mset (Fun f ss, Fun f ts) Pa;\n        P' = Pa + mset (zip ss ts); \\<sigma>' = \\<sigma>;\n        length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> MATCH1\n                          (add_mset (Fun f ss, Fun f ts) (Pa + M), \\<sigma>)\n                          (Pa + (M + mset (zip ss ts)), \\<sigma>)", "using Var"], ["proof (prove)\nusing this:\n  ?\\<sigma> ?x = None \\<or> ?\\<sigma> ?x = Some ?t \\<Longrightarrow>\n  MATCH1 (?P + {#(Var ?x, ?t)#}, ?\\<sigma>) (?P, ?\\<sigma>(?x \\<mapsto> ?t))\n\ngoal (3 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>P = add_mset (Var x, t) P';\n        \\<sigma>' = \\<sigma>(x \\<mapsto> t); \\<sigma> x = None\\<rbrakk>\n       \\<Longrightarrow> MATCH1 (add_mset (Var x, t) (M + P'), \\<sigma>)\n                          (M + P', \\<sigma>(x \\<mapsto> t))\n 2. \\<And>x t.\n       \\<lbrakk>P = add_mset (Var x, t) P';\n        \\<sigma>' = \\<sigma>(x \\<mapsto> t); \\<sigma> x = Some t\\<rbrakk>\n       \\<Longrightarrow> MATCH1 (add_mset (Var x, t) (M + P'), \\<sigma>)\n                          (M + P', \\<sigma>(x \\<mapsto> t))\n 3. \\<And>ss ts Pa f.\n       \\<lbrakk>P = add_mset (Fun f ss, Fun f ts) Pa;\n        P' = Pa + mset (zip ss ts); \\<sigma>' = \\<sigma>;\n        length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> MATCH1\n                          (add_mset (Fun f ss, Fun f ts) (Pa + M), \\<sigma>)\n                          (Pa + (M + mset (zip ss ts)), \\<sigma>)", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>P = add_mset (Var x, t) P';\n        \\<sigma>' = \\<sigma>(x \\<mapsto> t); \\<sigma> x = Some t\\<rbrakk>\n       \\<Longrightarrow> MATCH1 (add_mset (Var x, t) (M + P'), \\<sigma>)\n                          (M + P', \\<sigma>(x \\<mapsto> t))\n 2. \\<And>ss ts Pa f.\n       \\<lbrakk>P = add_mset (Fun f ss, Fun f ts) Pa;\n        P' = Pa + mset (zip ss ts); \\<sigma>' = \\<sigma>;\n        length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> MATCH1\n                          (add_mset (Fun f ss, Fun f ts) (Pa + M), \\<sigma>)\n                          (Pa + (M + mset (zip ss ts)), \\<sigma>)", "using Var"], ["proof (prove)\nusing this:\n  ?\\<sigma> ?x = None \\<or> ?\\<sigma> ?x = Some ?t \\<Longrightarrow>\n  MATCH1 (?P + {#(Var ?x, ?t)#}, ?\\<sigma>) (?P, ?\\<sigma>(?x \\<mapsto> ?t))\n\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>P = add_mset (Var x, t) P';\n        \\<sigma>' = \\<sigma>(x \\<mapsto> t); \\<sigma> x = Some t\\<rbrakk>\n       \\<Longrightarrow> MATCH1 (add_mset (Var x, t) (M + P'), \\<sigma>)\n                          (M + P', \\<sigma>(x \\<mapsto> t))\n 2. \\<And>ss ts Pa f.\n       \\<lbrakk>P = add_mset (Fun f ss, Fun f ts) Pa;\n        P' = Pa + mset (zip ss ts); \\<sigma>' = \\<sigma>;\n        length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> MATCH1\n                          (add_mset (Fun f ss, Fun f ts) (Pa + M), \\<sigma>)\n                          (Pa + (M + mset (zip ss ts)), \\<sigma>)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ss ts Pa f.\n       \\<lbrakk>P = add_mset (Fun f ss, Fun f ts) Pa;\n        P' = Pa + mset (zip ss ts); \\<sigma>' = \\<sigma>;\n        length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> MATCH1\n                          (add_mset (Fun f ss, Fun f ts) (Pa + M), \\<sigma>)\n                          (Pa + (M + mset (zip ss ts)), \\<sigma>)", "using Fun"], ["proof (prove)\nusing this:\n  length ?ss = length ?ts \\<Longrightarrow>\n  MATCH1 (?P + {#(Fun ?f ?ss, Fun ?f ?ts)#}, ?\\<sigma>)\n   (?P + mset (zip ?ss ?ts), ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>ss ts Pa f.\n       \\<lbrakk>P = add_mset (Fun f ss, Fun f ts) Pa;\n        P' = Pa + mset (zip ss ts); \\<sigma>' = \\<sigma>;\n        length ss = length ts\\<rbrakk>\n       \\<Longrightarrow> MATCH1\n                          (add_mset (Fun f ss, Fun f ts) (Pa + M), \\<sigma>)\n                          (Pa + (M + mset (zip ss ts)), \\<sigma>)", "by (metis (no_types, lifting) add.assoc add_mset_add_single)"], ["", "lemma matchrel_mono:\n  assumes \"(x, y) \\<in> matchrel\"\n  shows \"((fst x + M, snd x), (fst y + M, snd y)) \\<in> matchrel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((fst x + M, snd x), fst y + M, snd y) \\<in> matchrel", "using assms and MATCH1_mono [of \"fst x\"]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> matchrel\n  MATCH1 (fst x, ?\\<sigma>) (?P', ?\\<sigma>') \\<Longrightarrow>\n  MATCH1 (fst x + ?M, ?\\<sigma>) (?P' + ?M, ?\\<sigma>')\n\ngoal (1 subgoal):\n 1. ((fst x + M, snd x), fst y + M, snd y) \\<in> matchrel", "by (simp add: MATCH1_matchrel_conv)"], ["", "lemma matchrel_rtrancl_mono:\n  assumes \"(x, y) \\<in> matchrel\\<^sup>*\"\n  shows \"((fst x + M, snd x), (fst y + M, snd y)) \\<in> matchrel\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((fst x + M, snd x), fst y + M, snd y) \\<in> matchrel\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> matchrel\\<^sup>*\n\ngoal (1 subgoal):\n 1. ((fst x + M, snd x), fst y + M, snd y) \\<in> matchrel\\<^sup>*", "by (induct) (auto dest:  matchrel_mono [of _ _ M])"], ["", "lemma ne_matchers_imp_empty_or_matchrel:\n  assumes \"matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\"\n  shows \"P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)", "proof (cases P)"], ["proof (state)\ngoal (2 subgoals):\n 1. P = {#} \\<Longrightarrow>\n    P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\n 2. \\<And>x N.\n       P = add_mset x N \\<Longrightarrow>\n       P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)", "case (add e P')"], ["proof (state)\nthis:\n  P = add_mset e P'\n\ngoal (2 subgoals):\n 1. P = {#} \\<Longrightarrow>\n    P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\n 2. \\<And>x N.\n       P = add_mset x N \\<Longrightarrow>\n       P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)", "then"], ["proof (chain)\npicking this:\n  P = add_mset e P'", "have [simp]: \"P = P' + {#e#}\""], ["proof (prove)\nusing this:\n  P = add_mset e P'\n\ngoal (1 subgoal):\n 1. P = P' + {#e#}", "by simp"], ["proof (state)\nthis:\n  P = P' + {#e#}\n\ngoal (2 subgoals):\n 1. P = {#} \\<Longrightarrow>\n    P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\n 2. \\<And>x N.\n       P = add_mset x N \\<Longrightarrow>\n       P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)", "from assms"], ["proof (chain)\npicking this:\n  matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}", "have \"matchers_map \\<sigma> \\<inter> matchers {e} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> matchers {e} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  matchers_map \\<sigma> \\<inter> matchers {e} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. P = {#} \\<Longrightarrow>\n    P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\n 2. \\<And>x N.\n       P = add_mset x N \\<Longrightarrow>\n       P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)", "from ne_matchers_imp_matchrel [OF this]"], ["proof (chain)\npicking this:\n  \\<exists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel", "obtain P'' \\<sigma>' where \"MATCH1 ({#e#}, \\<sigma>) (P'', \\<sigma>')\""], ["proof (prove)\nusing this:\n  \\<exists>y. (({#e#}, \\<sigma>), y) \\<in> matchrel\n\ngoal (1 subgoal):\n 1. (\\<And>P'' \\<sigma>'.\n        MATCH1 ({#e#}, \\<sigma>) (P'', \\<sigma>') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: matchrel_def)"], ["proof (state)\nthis:\n  MATCH1 ({#e#}, \\<sigma>) (P'', \\<sigma>')\n\ngoal (2 subgoals):\n 1. P = {#} \\<Longrightarrow>\n    P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\n 2. \\<And>x N.\n       P = add_mset x N \\<Longrightarrow>\n       P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)", "from MATCH1_mono [OF this, of P']"], ["proof (chain)\npicking this:\n  MATCH1 ({#e#} + P', \\<sigma>) (P'' + P', \\<sigma>')", "have \"MATCH1 (P, \\<sigma>) (P' + P'', \\<sigma>')\""], ["proof (prove)\nusing this:\n  MATCH1 ({#e#} + P', \\<sigma>) (P'' + P', \\<sigma>')\n\ngoal (1 subgoal):\n 1. MATCH1 (P, \\<sigma>) (P' + P'', \\<sigma>')", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  MATCH1 (P, \\<sigma>) (P' + P'', \\<sigma>')\n\ngoal (2 subgoals):\n 1. P = {#} \\<Longrightarrow>\n    P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\n 2. \\<And>x N.\n       P = add_mset x N \\<Longrightarrow>\n       P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)", "then"], ["proof (chain)\npicking this:\n  MATCH1 (P, \\<sigma>) (P' + P'', \\<sigma>')", "show ?thesis"], ["proof (prove)\nusing this:\n  MATCH1 (P, \\<sigma>) (P' + P'', \\<sigma>')\n\ngoal (1 subgoal):\n 1. P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)", "by (auto simp: matchrel_def)"], ["proof (state)\nthis:\n  P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\n\ngoal (1 subgoal):\n 1. P = {#} \\<Longrightarrow>\n    P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)", "qed simp"], ["", "lemma matchrel_imp_converse_matchless [dest]:\n  \"(x, y) \\<in> matchrel \\<Longrightarrow> (y, x) \\<in> matchless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> matchrel \\<Longrightarrow> (y, x) \\<in> matchless", "using MATCH1_matchless"], ["proof (prove)\nusing this:\n  MATCH1 ?x ?y \\<Longrightarrow> (?y, ?x) \\<in> matchless\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> matchrel \\<Longrightarrow> (y, x) \\<in> matchless", "by (cases x, cases y) (auto simp: matchrel_def)"], ["", "lemma ne_matchers_imp_empty:\n  fixes P :: \"(('f, 'v) term \\<times> ('f, 'w) term) multiset\"\n  assumes \"matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\"\n  shows \"\\<exists>\\<sigma>'. ((P, \\<sigma>), ({#}, \\<sigma>')) \\<in> matchrel\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       ((P, \\<sigma>), {#}, \\<sigma>') \\<in> matchrel\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       ((P, \\<sigma>), {#}, \\<sigma>') \\<in> matchrel\\<^sup>*", "proof (induct P arbitrary: \\<sigma> rule: wf_induct [OF wf_measure [of size_mset]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure size_mset \\<longrightarrow>\n                   (\\<forall>x.\n                       matchers_map x \\<inter>\n                       matchers (set_mset y) \\<noteq>\n                       {} \\<longrightarrow>\n                       (\\<exists>\\<sigma>'.\n                           ((y, x), {#}, \\<sigma>')\n                           \\<in> matchrel\\<^sup>*));\n        matchers_map \\<sigma> \\<inter> matchers (set_mset x) \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            ((x, \\<sigma>), {#}, \\<sigma>')\n                            \\<in> matchrel\\<^sup>*", "fix P :: \"(('f, 'v) term \\<times> ('f, 'w) term) multiset\"\n    and \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure size_mset \\<longrightarrow>\n                   (\\<forall>x.\n                       matchers_map x \\<inter>\n                       matchers (set_mset y) \\<noteq>\n                       {} \\<longrightarrow>\n                       (\\<exists>\\<sigma>'.\n                           ((y, x), {#}, \\<sigma>')\n                           \\<in> matchrel\\<^sup>*));\n        matchers_map \\<sigma> \\<inter> matchers (set_mset x) \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            ((x, \\<sigma>), {#}, \\<sigma>')\n                            \\<in> matchrel\\<^sup>*", "presume IH: \"\\<And>P' \\<sigma>. \\<lbrakk>(P', P) \\<in> measure size_mset; matchers_map \\<sigma> \\<inter> matchers (set_mset P') \\<noteq> {}\\<rbrakk> \\<Longrightarrow>\n    \\<exists>\\<sigma>'. ((P', \\<sigma>), {#}, \\<sigma>') \\<in> matchrel\\<^sup>*\"\n    and *: \"matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<lbrakk>(?P', P) \\<in> measure size_mset;\n   matchers_map ?\\<sigma> \\<inter> matchers (set_mset ?P') \\<noteq>\n   {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<sigma>'.\n                       ((?P', ?\\<sigma>), {#}, \\<sigma>')\n                       \\<in> matchrel\\<^sup>*\n  matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure size_mset \\<longrightarrow>\n                   (\\<forall>x.\n                       matchers_map x \\<inter>\n                       matchers (set_mset y) \\<noteq>\n                       {} \\<longrightarrow>\n                       (\\<exists>\\<sigma>'.\n                           ((y, x), {#}, \\<sigma>')\n                           \\<in> matchrel\\<^sup>*));\n        matchers_map \\<sigma> \\<inter> matchers (set_mset x) \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            ((x, \\<sigma>), {#}, \\<sigma>')\n                            \\<in> matchrel\\<^sup>*", "show \"\\<exists>\\<sigma>'. ((P, \\<sigma>), {#}, \\<sigma>') \\<in> matchrel\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*", "proof (cases \"P = {#}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P = {#} \\<Longrightarrow>\n    \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*\n 2. P \\<noteq> {#} \\<Longrightarrow>\n    \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*", "assume \"P \\<noteq> {#}\""], ["proof (state)\nthis:\n  P \\<noteq> {#}\n\ngoal (2 subgoals):\n 1. P = {#} \\<Longrightarrow>\n    \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*\n 2. P \\<noteq> {#} \\<Longrightarrow>\n    \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*", "with ne_matchers_imp_empty_or_matchrel [OF *]"], ["proof (chain)\npicking this:\n  P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\n  P \\<noteq> {#}", "obtain P' \\<sigma>' where **: \"((P, \\<sigma>), (P', \\<sigma>')) \\<in> matchrel\""], ["proof (prove)\nusing this:\n  P = {#} \\<or> (\\<exists>y. ((P, \\<sigma>), y) \\<in> matchrel)\n  P \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (\\<And>P' \\<sigma>''.\n        ((P, \\<sigma>), P', \\<sigma>'') \\<in> matchrel \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto)"], ["proof (state)\nthis:\n  ((P, \\<sigma>), P', \\<sigma>') \\<in> matchrel\n\ngoal (2 subgoals):\n 1. P = {#} \\<Longrightarrow>\n    \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*\n 2. P \\<noteq> {#} \\<Longrightarrow>\n    \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*", "with *"], ["proof (chain)\npicking this:\n  matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\n  ((P, \\<sigma>), P', \\<sigma>') \\<in> matchrel", "have \"(P', P) \\<in> measure size_mset\"\n      and \"matchers_map \\<sigma>' \\<inter> matchers (set_mset P') \\<noteq> {}\""], ["proof (prove)\nusing this:\n  matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\n  ((P, \\<sigma>), P', \\<sigma>') \\<in> matchrel\n\ngoal (1 subgoal):\n 1. (P', P) \\<in> measure size_mset &&&\n    matchers_map \\<sigma>' \\<inter> matchers (set_mset P') \\<noteq> {}", "using MATCH1_matchers [of \"(P, \\<sigma>)\" \"(P', \\<sigma>')\"]"], ["proof (prove)\nusing this:\n  matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq> {}\n  ((P, \\<sigma>), P', \\<sigma>') \\<in> matchrel\n  MATCH1 (P, \\<sigma>) (P', \\<sigma>') \\<Longrightarrow>\n  matchers_map (snd (P, \\<sigma>)) \\<inter>\n  matchers (set_mset (fst (P, \\<sigma>))) =\n  matchers_map (snd (P', \\<sigma>')) \\<inter>\n  matchers (set_mset (fst (P', \\<sigma>')))\n\ngoal (1 subgoal):\n 1. (P', P) \\<in> measure size_mset &&&\n    matchers_map \\<sigma>' \\<inter> matchers (set_mset P') \\<noteq> {}", "by (auto simp: matchrel_def dest: MATCH1_size_mset)"], ["proof (state)\nthis:\n  (P', P) \\<in> measure size_mset\n  matchers_map \\<sigma>' \\<inter> matchers (set_mset P') \\<noteq> {}\n\ngoal (2 subgoals):\n 1. P = {#} \\<Longrightarrow>\n    \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*\n 2. P \\<noteq> {#} \\<Longrightarrow>\n    \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*", "from IH [OF this] and **"], ["proof (chain)\npicking this:\n  \\<exists>\\<sigma>'.\n     ((P', \\<sigma>'), {#}, \\<sigma>') \\<in> matchrel\\<^sup>*\n  ((P, \\<sigma>), P', \\<sigma>') \\<in> matchrel", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>'.\n     ((P', \\<sigma>'), {#}, \\<sigma>') \\<in> matchrel\\<^sup>*\n  ((P, \\<sigma>), P', \\<sigma>') \\<in> matchrel\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*", "by (auto intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>''.\n     ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*\n\ngoal (1 subgoal):\n 1. P = {#} \\<Longrightarrow>\n    \\<exists>\\<sigma>''.\n       ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*", "qed force"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>''.\n     ((P, \\<sigma>), {#}, \\<sigma>'') \\<in> matchrel\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>x \\<sigma> P' \\<sigma>'.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure size_mset \\<longrightarrow>\n                   (\\<forall>x.\n                       matchers_map x \\<inter>\n                       matchers (set_mset y) \\<noteq>\n                       {} \\<longrightarrow>\n                       (\\<exists>\\<sigma>'.\n                           ((y, x), {#}, \\<sigma>')\n                           \\<in> matchrel\\<^sup>*));\n        matchers_map \\<sigma> \\<inter> matchers (set_mset x) \\<noteq> {};\n        (P', x) \\<in> measure size_mset;\n        matchers_map \\<sigma>' \\<inter> matchers (set_mset P') \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>''.\n                            ((P', \\<sigma>'), {#}, \\<sigma>'')\n                            \\<in> matchrel\\<^sup>*\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure size_mset \\<longrightarrow>\n                   (\\<forall>x.\n                       matchers_map x \\<inter>\n                       matchers (set_mset y) \\<noteq>\n                       {} \\<longrightarrow>\n                       (\\<exists>\\<sigma>'.\n                           ((y, x), {#}, \\<sigma>')\n                           \\<in> matchrel\\<^sup>*));\n        matchers_map \\<sigma> \\<inter> matchers (set_mset x) \\<noteq>\n        {}\\<rbrakk>\n       \\<Longrightarrow> matchers_map \\<sigma> \\<inter>\n                         matchers (set_mset x) \\<noteq>\n                         {}", "qed simp"], ["", "lemma empty_not_reachable_imp_matchers_empty:\n  assumes \"\\<And>\\<sigma>'. ((P, \\<sigma>), ({#}, \\<sigma>')) \\<notin> matchrel\\<^sup>*\"\n  shows \"matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}", "using ne_matchers_imp_empty [of \\<sigma> P] and assms"], ["proof (prove)\nusing this:\n  matchers_map \\<sigma> \\<inter> matchers (set_mset P) \\<noteq>\n  {} \\<Longrightarrow>\n  \\<exists>\\<sigma>'. ((P, \\<sigma>), {#}, \\<sigma>') \\<in> matchrel\\<^sup>*\n  ((P, \\<sigma>), {#}, ?\\<sigma>') \\<notin> matchrel\\<^sup>*\n\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}", "by blast"], ["", "lemma irreducible_reachable_imp_matchers_empty:\n  assumes \"((P, \\<sigma>), y) \\<in> matchrel\\<^sup>!\" and \"fst y \\<noteq> {#}\"\n  shows \"matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}", "have \"((P, \\<sigma>), y) \\<in> matchrel\\<^sup>*\"\n    and \"\\<And>\\<tau>. (y, ({#}, \\<tau>)) \\<notin> matchrel\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P, \\<sigma>), y) \\<in> matchrel\\<^sup>* &&&\n    (\\<And>\\<tau>. (y, {#}, \\<tau>) \\<notin> matchrel\\<^sup>*)", "using assms"], ["proof (prove)\nusing this:\n  ((P, \\<sigma>), y) \\<in> matchrel\\<^sup>!\n  fst y \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. ((P, \\<sigma>), y) \\<in> matchrel\\<^sup>* &&&\n    (\\<And>\\<tau>. (y, {#}, \\<tau>) \\<notin> matchrel\\<^sup>*)", "by  auto (metis NF_not_suc fst_conv normalizability_E)"], ["proof (state)\nthis:\n  ((P, \\<sigma>), y) \\<in> matchrel\\<^sup>*\n  (y, {#}, ?\\<tau>) \\<notin> matchrel\\<^sup>*\n\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}", "moreover"], ["proof (state)\nthis:\n  ((P, \\<sigma>), y) \\<in> matchrel\\<^sup>*\n  (y, {#}, ?\\<tau>) \\<notin> matchrel\\<^sup>*\n\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}", "with empty_not_reachable_imp_matchers_empty"], ["proof (chain)\npicking this:\n  (\\<And>\\<sigma>'.\n      ((?P, ?\\<sigma>), {#}, \\<sigma>')\n      \\<notin> matchrel\\<^sup>*) \\<Longrightarrow>\n  matchers_map ?\\<sigma> \\<inter> matchers (set_mset ?P) = {}\n  ((P, \\<sigma>), y) \\<in> matchrel\\<^sup>*\n  (y, {#}, ?\\<tau>) \\<notin> matchrel\\<^sup>*", "have \"matchers_map (snd y) \\<inter> matchers (set_mset (fst y)) = {}\""], ["proof (prove)\nusing this:\n  (\\<And>\\<sigma>'.\n      ((?P, ?\\<sigma>), {#}, \\<sigma>')\n      \\<notin> matchrel\\<^sup>*) \\<Longrightarrow>\n  matchers_map ?\\<sigma> \\<inter> matchers (set_mset ?P) = {}\n  ((P, \\<sigma>), y) \\<in> matchrel\\<^sup>*\n  (y, {#}, ?\\<tau>) \\<notin> matchrel\\<^sup>*\n\ngoal (1 subgoal):\n 1. matchers_map (snd y) \\<inter> matchers (set_mset (fst y)) = {}", "by (cases y) auto"], ["proof (state)\nthis:\n  matchers_map (snd y) \\<inter> matchers (set_mset (fst y)) = {}\n\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}", "ultimately"], ["proof (chain)\npicking this:\n  ((P, \\<sigma>), y) \\<in> matchrel\\<^sup>*\n  (y, {#}, ?\\<tau>) \\<notin> matchrel\\<^sup>*\n  matchers_map (snd y) \\<inter> matchers (set_mset (fst y)) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ((P, \\<sigma>), y) \\<in> matchrel\\<^sup>*\n  (y, {#}, ?\\<tau>) \\<notin> matchrel\\<^sup>*\n  matchers_map (snd y) \\<inter> matchers (set_mset (fst y)) = {}\n\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}", "using matchrel_rtrancl_matchers [of \"(P, \\<sigma>)\"]"], ["proof (prove)\nusing this:\n  ((P, \\<sigma>), y) \\<in> matchrel\\<^sup>*\n  (y, {#}, ?\\<tau>) \\<notin> matchrel\\<^sup>*\n  matchers_map (snd y) \\<inter> matchers (set_mset (fst y)) = {}\n  ((P, \\<sigma>), ?y) \\<in> matchrel\\<^sup>* \\<Longrightarrow>\n  matchers_map (snd (P, \\<sigma>)) \\<inter>\n  matchers (set_mset (fst (P, \\<sigma>))) =\n  matchers_map (snd ?y) \\<inter> matchers (set_mset (fst ?y))\n\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}", "by simp"], ["proof (state)\nthis:\n  matchers_map \\<sigma> \\<inter> matchers (set_mset P) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matchers_map_not_empty [simp]:\n  \"matchers_map \\<sigma> \\<noteq> {}\"\n  \"{} \\<noteq> matchers_map \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchers_map \\<sigma> \\<noteq> {} &&& {} \\<noteq> matchers_map \\<sigma>", "by (auto simp: matchers_map_def matchers_def)"], ["", "lemma matchers_empty_imp_not_empty_NF:\n  assumes \"matchers (set_mset P) = {}\"\n  shows \"\\<exists>y. fst y \\<noteq> {#} \\<and> ((P, Map.empty), y) \\<in> matchrel\\<^sup>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       fst y \\<noteq> {#} \\<and> ((P, Map.empty), y) \\<in> matchrel\\<^sup>!", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       fst y \\<noteq> {#} \\<and>\n       ((P, Map.empty), y) \\<in> matchrel\\<^sup>! \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<nexists>y.\n     fst y \\<noteq> {#} \\<and> ((P, Map.empty), y) \\<in> matchrel\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       fst y \\<noteq> {#} \\<and>\n       ((P, Map.empty), y) \\<in> matchrel\\<^sup>! \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>y.\n     fst y \\<noteq> {#} \\<and> ((P, Map.empty), y) \\<in> matchrel\\<^sup>!", "have *: \"\\<And>y. ((P, Map.empty), y) \\<in> matchrel\\<^sup>! \\<Longrightarrow> fst y = {#}\""], ["proof (prove)\nusing this:\n  \\<nexists>y.\n     fst y \\<noteq> {#} \\<and> ((P, Map.empty), y) \\<in> matchrel\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       ((P, Map.empty), y) \\<in> matchrel\\<^sup>! \\<Longrightarrow>\n       fst y = {#}", "by auto"], ["proof (state)\nthis:\n  ((P, Map.empty), ?y) \\<in> matchrel\\<^sup>! \\<Longrightarrow> fst ?y = {#}\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       fst y \\<noteq> {#} \\<and>\n       ((P, Map.empty), y) \\<in> matchrel\\<^sup>! \\<Longrightarrow>\n    False", "have \"SN matchrel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN matchrel", "using wf_converse_matchrel"], ["proof (prove)\nusing this:\n  wf (matchrel\\<inverse>)\n\ngoal (1 subgoal):\n 1. SN matchrel", "by (auto simp: SN_iff_wf)"], ["proof (state)\nthis:\n  SN matchrel\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       fst y \\<noteq> {#} \\<and>\n       ((P, Map.empty), y) \\<in> matchrel\\<^sup>! \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  SN matchrel", "obtain y where \"((P, Map.empty), y) \\<in> matchrel\\<^sup>!\""], ["proof (prove)\nusing this:\n  SN matchrel\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        ((P, Map.empty), y) \\<in> matchrel\\<^sup>! \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis SN_imp_WN UNIV_I WN_onE)"], ["proof (state)\nthis:\n  ((P, Map.empty), y) \\<in> matchrel\\<^sup>!\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       fst y \\<noteq> {#} \\<and>\n       ((P, Map.empty), y) \\<in> matchrel\\<^sup>! \\<Longrightarrow>\n    False", "with * [OF this]"], ["proof (chain)\npicking this:\n  fst y = {#}\n  ((P, Map.empty), y) \\<in> matchrel\\<^sup>!", "obtain \\<tau> where \"((P, Map.empty), ({#}, \\<tau>)) \\<in> matchrel\\<^sup>*\""], ["proof (prove)\nusing this:\n  fst y = {#}\n  ((P, Map.empty), y) \\<in> matchrel\\<^sup>!\n\ngoal (1 subgoal):\n 1. (\\<And>\\<tau>.\n        ((P, Map.empty), {#}, \\<tau>)\n        \\<in> matchrel\\<^sup>* \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases y) auto"], ["proof (state)\nthis:\n  ((P, Map.empty), {#}, \\<tau>) \\<in> matchrel\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<nexists>y.\n       fst y \\<noteq> {#} \\<and>\n       ((P, Map.empty), y) \\<in> matchrel\\<^sup>! \\<Longrightarrow>\n    False", "from matchrel_rtrancl_matchers [OF this] and assms"], ["proof (chain)\npicking this:\n  matchers_map (snd (P, Map.empty)) \\<inter>\n  matchers (set_mset (fst (P, Map.empty))) =\n  matchers_map (snd ({#}, \\<tau>)) \\<inter>\n  matchers (set_mset (fst ({#}, \\<tau>)))\n  matchers (set_mset P) = {}", "show False"], ["proof (prove)\nusing this:\n  matchers_map (snd (P, Map.empty)) \\<inter>\n  matchers (set_mset (fst (P, Map.empty))) =\n  matchers_map (snd ({#}, \\<tau>)) \\<inter>\n  matchers (set_mset (fst ({#}, \\<tau>)))\n  matchers (set_mset P) = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}