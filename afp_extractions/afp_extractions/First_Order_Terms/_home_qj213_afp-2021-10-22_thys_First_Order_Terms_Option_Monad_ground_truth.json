{"file_name": "/home/qj213/afp-2021-10-22/thys/First_Order_Terms/Option_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/First_Order_Terms", "problem_names": ["lemma guard_cong [fundef_cong]:\n  \"b = c \\<Longrightarrow> (c \\<Longrightarrow> m = n) \\<Longrightarrow> guard b >> m = guard c >> n\"", "lemma guard_simps:\n  \"guard b = Some x \\<longleftrightarrow> b\"\n  \"guard b = None \\<longleftrightarrow> \\<not> b\"", "lemma guard_elims[elim]:\n  \"guard b = Some x \\<Longrightarrow> (b \\<Longrightarrow> P) \\<Longrightarrow> P\"\n  \"guard b = None \\<Longrightarrow> (\\<not> b \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma guard_intros [intro, simp]:\n  \"b \\<Longrightarrow> guard b = Some ()\"\n  \"\\<not> b \\<Longrightarrow> guard b = None\"", "lemma guard_True [simp]: \"guard True = Some ()\"", "lemma guard_False [simp]: \"guard False = None\"", "lemma guard_and_to_bind: \"guard (a \\<and> b) = guard a \\<bind> (\\<lambda> _. guard b)\"", "lemma zip_induct [case_names Cons_Cons Nil1 Nil2]:\n  assumes \"\\<And>x xs y ys. P xs ys \\<Longrightarrow> P (x # xs) (y # ys)\"\n    and \"\\<And>ys. P [] ys\"\n    and \"\\<And>xs. P xs []\"\n  shows \"P xs ys\"", "lemma zip_option_zip_conv:\n  \"zip_option xs ys = Some zs \\<longleftrightarrow> length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys\"", "lemma zip_option_None:\n  \"zip_option xs ys = None \\<longleftrightarrow> length xs \\<noteq> length ys\"", "lemma zip_option_intros [intro]:\n  \"\\<lbrakk>length ys = length xs; length zs = length xs; zs = zip xs ys\\<rbrakk>\n    \\<Longrightarrow> zip_option xs ys = Some zs\"\n  \"length xs \\<noteq> length ys \\<Longrightarrow> zip_option xs ys = None\"", "lemma zip_option_elims [elim]:\n  \"zip_option xs ys = Some zs\n    \\<Longrightarrow> (\\<lbrakk>length ys = length xs; length zs = length xs; zs = zip xs ys\\<rbrakk> \\<Longrightarrow> P)\n    \\<Longrightarrow> P\"\n  \"zip_option xs ys = None \\<Longrightarrow> (length xs \\<noteq> length ys \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma zip_option_simps [simp]:\n  \"zip_option xs ys = None \\<Longrightarrow> length xs = length ys \\<Longrightarrow> False\"\n  \"zip_option xs ys = None \\<Longrightarrow> length xs \\<noteq> length ys\"\n  \"zip_option xs ys = Some zs \\<Longrightarrow> zs = zip xs ys\"", "lemma mapM_None:\n  \"mapM f xs = None \\<longleftrightarrow> (\\<exists>x\\<in>set xs. f x = None)\"", "lemma mapM_Some:\n  \"mapM f xs = Some ys \\<Longrightarrow> ys = map (\\<lambda>x. the (f x)) xs \\<and> (\\<forall>x\\<in>set xs. f x \\<noteq> None)\"", "lemma mapM_Some_idx:\n  assumes some: \"mapM f xs = Some ys\" and i: \"i < length xs\" \n  shows \"\\<exists>y. f (xs ! i) = Some y \\<and> ys ! i = y\"", "lemma mapM_cong [fundef_cong]:\n  assumes \"xs = ys\" and \"\\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\"\n  shows \"mapM f xs = mapM g ys\"", "lemma mapM_map:\n  \"mapM f xs = (if (\\<forall>x\\<in>set xs. f x \\<noteq> None) then Some (map (\\<lambda>x. the (f x)) xs) else None)\"", "lemma mapM_mono [partial_function_mono]:\n  fixes C :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'c option) \\<Rightarrow> 'd option\"\n  assumes C: \"\\<And>y. mono_option (C y)\"\n  shows \"mono_option (\\<lambda>f. mapM (\\<lambda>y. C y f) B)\""], "translations": [["", "lemma guard_cong [fundef_cong]:\n  \"b = c \\<Longrightarrow> (c \\<Longrightarrow> m = n) \\<Longrightarrow> guard b >> m = guard c >> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b = c; c \\<Longrightarrow> m = n\\<rbrakk>\n    \\<Longrightarrow> guard b \\<bind> (\\<lambda>_. m) =\n                      guard c \\<bind> (\\<lambda>_. n)", "by (simp add: guard_def)"], ["", "lemma guard_simps:\n  \"guard b = Some x \\<longleftrightarrow> b\"\n  \"guard b = None \\<longleftrightarrow> \\<not> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (guard b = Some x) = b &&& (guard b = None) = (\\<not> b)", "by (cases b) (simp_all add: guard_def)"], ["", "lemma guard_elims[elim]:\n  \"guard b = Some x \\<Longrightarrow> (b \\<Longrightarrow> P) \\<Longrightarrow> P\"\n  \"guard b = None \\<Longrightarrow> (\\<not> b \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>guard b = Some x; b \\<Longrightarrow> P\\<rbrakk>\n     \\<Longrightarrow> P) &&&\n    (\\<lbrakk>guard b = None; \\<not> b \\<Longrightarrow> P\\<rbrakk>\n     \\<Longrightarrow> P)", "by (simp_all add: guard_simps)"], ["", "lemma guard_intros [intro, simp]:\n  \"b \\<Longrightarrow> guard b = Some ()\"\n  \"\\<not> b \\<Longrightarrow> guard b = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<Longrightarrow> guard b = Some ()) &&&\n    (\\<not> b \\<Longrightarrow> guard b = None)", "by (simp_all add: guard_simps)"], ["", "lemma guard_True [simp]: \"guard True = Some ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. guard True = Some ()", "by simp"], ["", "lemma guard_False [simp]: \"guard False = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. guard False = None", "by simp"], ["", "lemma guard_and_to_bind: \"guard (a \\<and> b) = guard a \\<bind> (\\<lambda> _. guard b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. guard (a \\<and> b) = guard a \\<bind> (\\<lambda>_. guard b)", "by (cases a; cases b; auto)"], ["", "fun zip_option :: \"'a list \\<Rightarrow> 'b list \\<Rightarrow> ('a \\<times> 'b) list option\"\n  where\n    \"zip_option [] [] = Some []\"\n  | \"zip_option (x#xs) (y#ys) = do { zs \\<leftarrow> zip_option xs ys; Some ((x, y) # zs) }\"\n  | \"zip_option (x#xs) [] = None\"\n  | \"zip_option [] (y#ys) = None\""], ["", "text \\<open>induction scheme for zip\\<close>"], ["", "lemma zip_induct [case_names Cons_Cons Nil1 Nil2]:\n  assumes \"\\<And>x xs y ys. P xs ys \\<Longrightarrow> P (x # xs) (y # ys)\"\n    and \"\\<And>ys. P [] ys\"\n    and \"\\<And>xs. P xs []\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "using assms"], ["proof (prove)\nusing this:\n  P ?xs ?ys \\<Longrightarrow> P (?x # ?xs) (?y # ?ys)\n  P [] ?ys\n  P ?xs []\n\ngoal (1 subgoal):\n 1. P xs ys", "by (induction_schema) (pat_completeness, lexicographic_order)"], ["", "lemma zip_option_zip_conv:\n  \"zip_option xs ys = Some zs \\<longleftrightarrow> length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "assume \"zip_option xs ys = Some zs\""], ["proof (state)\nthis:\n  zip_option xs ys = Some zs\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "hence \"length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys\""], ["proof (prove)\nusing this:\n  zip_option xs ys = Some zs\n\ngoal (1 subgoal):\n 1. length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys", "proof (induct xs ys arbitrary: zs rule: zip_option.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>zs.\n       zip_option [] [] = Some zs \\<Longrightarrow>\n       length [] = length [] \\<and>\n       length zs = length [] \\<and> zs = zip [] []\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   zip_option xs ys = Some zs \\<Longrightarrow>\n                   length ys = length xs \\<and>\n                   length zs = length xs \\<and> zs = zip xs ys;\n        zip_option (x # xs) (y # ys) = Some zs\\<rbrakk>\n       \\<Longrightarrow> length (y # ys) = length (x # xs) \\<and>\n                         length zs = length (x # xs) \\<and>\n                         zs = zip (x # xs) (y # ys)\n 3. \\<And>x xs zs.\n       zip_option (x # xs) [] = Some zs \\<Longrightarrow>\n       length [] = length (x # xs) \\<and>\n       length zs = length (x # xs) \\<and> zs = zip (x # xs) []\n 4. \\<And>y ys zs.\n       zip_option [] (y # ys) = Some zs \\<Longrightarrow>\n       length (y # ys) = length [] \\<and>\n       length zs = length [] \\<and> zs = zip [] (y # ys)", "case (2 x xs y ys)"], ["proof (state)\nthis:\n  zip_option xs ys = Some ?zs \\<Longrightarrow>\n  length ys = length xs \\<and> length ?zs = length xs \\<and> ?zs = zip xs ys\n  zip_option (x # xs) (y # ys) = Some zs\n\ngoal (4 subgoals):\n 1. \\<And>zs.\n       zip_option [] [] = Some zs \\<Longrightarrow>\n       length [] = length [] \\<and>\n       length zs = length [] \\<and> zs = zip [] []\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   zip_option xs ys = Some zs \\<Longrightarrow>\n                   length ys = length xs \\<and>\n                   length zs = length xs \\<and> zs = zip xs ys;\n        zip_option (x # xs) (y # ys) = Some zs\\<rbrakk>\n       \\<Longrightarrow> length (y # ys) = length (x # xs) \\<and>\n                         length zs = length (x # xs) \\<and>\n                         zs = zip (x # xs) (y # ys)\n 3. \\<And>x xs zs.\n       zip_option (x # xs) [] = Some zs \\<Longrightarrow>\n       length [] = length (x # xs) \\<and>\n       length zs = length (x # xs) \\<and> zs = zip (x # xs) []\n 4. \\<And>y ys zs.\n       zip_option [] (y # ys) = Some zs \\<Longrightarrow>\n       length (y # ys) = length [] \\<and>\n       length zs = length [] \\<and> zs = zip [] (y # ys)", "then"], ["proof (chain)\npicking this:\n  zip_option xs ys = Some ?zs \\<Longrightarrow>\n  length ys = length xs \\<and> length ?zs = length xs \\<and> ?zs = zip xs ys\n  zip_option (x # xs) (y # ys) = Some zs", "obtain zs' where \"zip_option xs ys = Some zs'\"\n        and \"zs = (x, y) # zs'\""], ["proof (prove)\nusing this:\n  zip_option xs ys = Some ?zs \\<Longrightarrow>\n  length ys = length xs \\<and> length ?zs = length xs \\<and> ?zs = zip xs ys\n  zip_option (x # xs) (y # ys) = Some zs\n\ngoal (1 subgoal):\n 1. (\\<And>zs'.\n        \\<lbrakk>zip_option xs ys = Some zs'; zs = (x, y) # zs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"zip_option xs ys\") auto"], ["proof (state)\nthis:\n  zip_option xs ys = Some zs'\n  zs = (x, y) # zs'\n\ngoal (4 subgoals):\n 1. \\<And>zs.\n       zip_option [] [] = Some zs \\<Longrightarrow>\n       length [] = length [] \\<and>\n       length zs = length [] \\<and> zs = zip [] []\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   zip_option xs ys = Some zs \\<Longrightarrow>\n                   length ys = length xs \\<and>\n                   length zs = length xs \\<and> zs = zip xs ys;\n        zip_option (x # xs) (y # ys) = Some zs\\<rbrakk>\n       \\<Longrightarrow> length (y # ys) = length (x # xs) \\<and>\n                         length zs = length (x # xs) \\<and>\n                         zs = zip (x # xs) (y # ys)\n 3. \\<And>x xs zs.\n       zip_option (x # xs) [] = Some zs \\<Longrightarrow>\n       length [] = length (x # xs) \\<and>\n       length zs = length (x # xs) \\<and> zs = zip (x # xs) []\n 4. \\<And>y ys zs.\n       zip_option [] (y # ys) = Some zs \\<Longrightarrow>\n       length (y # ys) = length [] \\<and>\n       length zs = length [] \\<and> zs = zip [] (y # ys)", "from 2(1) [OF this(1)] and this(2)"], ["proof (chain)\npicking this:\n  length ys = length xs \\<and> length zs' = length xs \\<and> zs' = zip xs ys\n  zs = (x, y) # zs'", "show ?case"], ["proof (prove)\nusing this:\n  length ys = length xs \\<and> length zs' = length xs \\<and> zs' = zip xs ys\n  zs = (x, y) # zs'\n\ngoal (1 subgoal):\n 1. length (y # ys) = length (x # xs) \\<and>\n    length zs = length (x # xs) \\<and> zs = zip (x # xs) (y # ys)", "by simp"], ["proof (state)\nthis:\n  length (y # ys) = length (x # xs) \\<and>\n  length zs = length (x # xs) \\<and> zs = zip (x # xs) (y # ys)\n\ngoal (3 subgoals):\n 1. \\<And>zs.\n       zip_option [] [] = Some zs \\<Longrightarrow>\n       length [] = length [] \\<and>\n       length zs = length [] \\<and> zs = zip [] []\n 2. \\<And>x xs zs.\n       zip_option (x # xs) [] = Some zs \\<Longrightarrow>\n       length [] = length (x # xs) \\<and>\n       length zs = length (x # xs) \\<and> zs = zip (x # xs) []\n 3. \\<And>y ys zs.\n       zip_option [] (y # ys) = Some zs \\<Longrightarrow>\n       length (y # ys) = length [] \\<and>\n       length zs = length [] \\<and> zs = zip [] (y # ys)", "qed simp_all"], ["proof (state)\nthis:\n  length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "}"], ["proof (state)\nthis:\n  zip_option xs ys = Some zs \\<Longrightarrow>\n  length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "moreover"], ["proof (state)\nthis:\n  zip_option xs ys = Some zs \\<Longrightarrow>\n  length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "{"], ["proof (state)\nthis:\n  zip_option xs ys = Some zs \\<Longrightarrow>\n  length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "assume \"length ys = length xs\" and \"zs = zip xs ys\""], ["proof (state)\nthis:\n  length ys = length xs\n  zs = zip xs ys\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "hence \"zip_option xs ys = Some zs\""], ["proof (prove)\nusing this:\n  length ys = length xs\n  zs = zip xs ys\n\ngoal (1 subgoal):\n 1. zip_option xs ys = Some zs", "by (induct xs ys arbitrary: zs rule: zip_induct) force+"], ["proof (state)\nthis:\n  zip_option xs ys = Some zs\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>length ys = length xs; zs = zip xs ys\\<rbrakk>\n  \\<Longrightarrow> zip_option xs ys = Some zs\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "ultimately"], ["proof (chain)\npicking this:\n  zip_option xs ys = Some zs \\<Longrightarrow>\n  length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys\n  \\<lbrakk>length ys = length xs; zs = zip xs ys\\<rbrakk>\n  \\<Longrightarrow> zip_option xs ys = Some zs", "show ?thesis"], ["proof (prove)\nusing this:\n  zip_option xs ys = Some zs \\<Longrightarrow>\n  length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys\n  \\<lbrakk>length ys = length xs; zs = zip xs ys\\<rbrakk>\n  \\<Longrightarrow> zip_option xs ys = Some zs\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = Some zs) =\n    (length ys = length xs \\<and>\n     length zs = length xs \\<and> zs = zip xs ys)", "by blast"], ["proof (state)\nthis:\n  (zip_option xs ys = Some zs) =\n  (length ys = length xs \\<and> length zs = length xs \\<and> zs = zip xs ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zip_option_None:\n  \"zip_option xs ys = None \\<longleftrightarrow> length xs \\<noteq> length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "assume \"zip_option xs ys = None\""], ["proof (state)\nthis:\n  zip_option xs ys = None\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "have \"length xs \\<noteq> length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<noteq> length ys", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<noteq> length ys \\<Longrightarrow> False", "assume \"\\<not> length xs \\<noteq> length ys\""], ["proof (state)\nthis:\n  \\<not> length xs \\<noteq> length ys\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<noteq> length ys \\<Longrightarrow> False", "hence \"length xs = length ys\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<noteq> length ys\n\ngoal (1 subgoal):\n 1. length xs = length ys", "by simp"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<noteq> length ys \\<Longrightarrow> False", "hence \"zip_option xs ys = Some (zip xs ys)\""], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. zip_option xs ys = Some (zip xs ys)", "by (simp add: zip_option_zip_conv)"], ["proof (state)\nthis:\n  zip_option xs ys = Some (zip xs ys)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<noteq> length ys \\<Longrightarrow> False", "with \\<open>zip_option xs ys = None\\<close>"], ["proof (chain)\npicking this:\n  zip_option xs ys = None\n  zip_option xs ys = Some (zip xs ys)", "show False"], ["proof (prove)\nusing this:\n  zip_option xs ys = None\n  zip_option xs ys = Some (zip xs ys)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length xs \\<noteq> length ys\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "}"], ["proof (state)\nthis:\n  zip_option xs ys = None \\<Longrightarrow> length xs \\<noteq> length ys\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "moreover"], ["proof (state)\nthis:\n  zip_option xs ys = None \\<Longrightarrow> length xs \\<noteq> length ys\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "{"], ["proof (state)\nthis:\n  zip_option xs ys = None \\<Longrightarrow> length xs \\<noteq> length ys\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "assume \"length xs \\<noteq> length ys\""], ["proof (state)\nthis:\n  length xs \\<noteq> length ys\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "hence \"zip_option xs ys = None\""], ["proof (prove)\nusing this:\n  length xs \\<noteq> length ys\n\ngoal (1 subgoal):\n 1. zip_option xs ys = None", "by (induct xs ys rule: zip_option.induct) simp_all"], ["proof (state)\nthis:\n  zip_option xs ys = None\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "}"], ["proof (state)\nthis:\n  length xs \\<noteq> length ys \\<Longrightarrow> zip_option xs ys = None\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "ultimately"], ["proof (chain)\npicking this:\n  zip_option xs ys = None \\<Longrightarrow> length xs \\<noteq> length ys\n  length xs \\<noteq> length ys \\<Longrightarrow> zip_option xs ys = None", "show ?thesis"], ["proof (prove)\nusing this:\n  zip_option xs ys = None \\<Longrightarrow> length xs \\<noteq> length ys\n  length xs \\<noteq> length ys \\<Longrightarrow> zip_option xs ys = None\n\ngoal (1 subgoal):\n 1. (zip_option xs ys = None) = (length xs \\<noteq> length ys)", "by blast"], ["proof (state)\nthis:\n  (zip_option xs ys = None) = (length xs \\<noteq> length ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare zip_option.simps [simp del]"], ["", "lemma zip_option_intros [intro]:\n  \"\\<lbrakk>length ys = length xs; length zs = length xs; zs = zip xs ys\\<rbrakk>\n    \\<Longrightarrow> zip_option xs ys = Some zs\"\n  \"length xs \\<noteq> length ys \\<Longrightarrow> zip_option xs ys = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>length ys = length xs; length zs = length xs;\n      zs = zip xs ys\\<rbrakk>\n     \\<Longrightarrow> zip_option xs ys = Some zs) &&&\n    (length xs \\<noteq> length ys \\<Longrightarrow> zip_option xs ys = None)", "by (simp_all add: zip_option_zip_conv zip_option_None)"], ["", "lemma zip_option_elims [elim]:\n  \"zip_option xs ys = Some zs\n    \\<Longrightarrow> (\\<lbrakk>length ys = length xs; length zs = length xs; zs = zip xs ys\\<rbrakk> \\<Longrightarrow> P)\n    \\<Longrightarrow> P\"\n  \"zip_option xs ys = None \\<Longrightarrow> (length xs \\<noteq> length ys \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>zip_option xs ys = Some zs;\n      \\<lbrakk>length ys = length xs; length zs = length xs;\n       zs = zip xs ys\\<rbrakk>\n      \\<Longrightarrow> P\\<rbrakk>\n     \\<Longrightarrow> P) &&&\n    (\\<lbrakk>zip_option xs ys = None;\n      length xs \\<noteq> length ys \\<Longrightarrow> P\\<rbrakk>\n     \\<Longrightarrow> P)", "by (simp_all add: zip_option_zip_conv zip_option_None)"], ["", "lemma zip_option_simps [simp]:\n  \"zip_option xs ys = None \\<Longrightarrow> length xs = length ys \\<Longrightarrow> False\"\n  \"zip_option xs ys = None \\<Longrightarrow> length xs \\<noteq> length ys\"\n  \"zip_option xs ys = Some zs \\<Longrightarrow> zs = zip xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>zip_option xs ys = None; length xs = length ys\\<rbrakk>\n     \\<Longrightarrow> False) &&&\n    (zip_option xs ys = None \\<Longrightarrow>\n     length xs \\<noteq> length ys) &&&\n    (zip_option xs ys = Some zs \\<Longrightarrow> zs = zip xs ys)", "by (simp_all add: zip_option_None zip_option_zip_conv)"], ["", "fun mapM :: \"('a \\<Rightarrow> 'b option) \\<Rightarrow> 'a list \\<Rightarrow> 'b list option\"\n  where\n    \"mapM f [] = Some []\"\n  | \"mapM f (x#xs) = do {\n      y \\<leftarrow> f x;\n      ys \\<leftarrow> mapM f xs;\n      Some (y # ys)\n    }\""], ["", "lemma mapM_None:\n  \"mapM f xs = None \\<longleftrightarrow> (\\<exists>x\\<in>set xs. f x = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mapM f xs = None) = (\\<exists>x\\<in>set xs. f x = None)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (mapM f [] = None) = (\\<exists>x\\<in>set []. f x = None)\n 2. \\<And>a xs.\n       (mapM f xs = None) =\n       (\\<exists>x\\<in>set xs. f x = None) \\<Longrightarrow>\n       (mapM f (a # xs) = None) = (\\<exists>x\\<in>set (a # xs). f x = None)", "case (Cons x xs)"], ["proof (state)\nthis:\n  (mapM f xs = None) = (\\<exists>x\\<in>set xs. f x = None)\n\ngoal (2 subgoals):\n 1. (mapM f [] = None) = (\\<exists>x\\<in>set []. f x = None)\n 2. \\<And>a xs.\n       (mapM f xs = None) =\n       (\\<exists>x\\<in>set xs. f x = None) \\<Longrightarrow>\n       (mapM f (a # xs) = None) = (\\<exists>x\\<in>set (a # xs). f x = None)", "thus ?case"], ["proof (prove)\nusing this:\n  (mapM f xs = None) = (\\<exists>x\\<in>set xs. f x = None)\n\ngoal (1 subgoal):\n 1. (mapM f (x # xs) = None) = (\\<exists>x\\<in>set (x # xs). f x = None)", "by (cases \"f x\", simp, cases \"mapM f xs\", auto)"], ["proof (state)\nthis:\n  (mapM f (x # xs) = None) = (\\<exists>x\\<in>set (x # xs). f x = None)\n\ngoal (1 subgoal):\n 1. (mapM f [] = None) = (\\<exists>x\\<in>set []. f x = None)", "qed simp"], ["", "lemma mapM_Some:\n  \"mapM f xs = Some ys \\<Longrightarrow> ys = map (\\<lambda>x. the (f x)) xs \\<and> (\\<forall>x\\<in>set xs. f x \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapM f xs = Some ys \\<Longrightarrow>\n    ys = map (\\<lambda>x. the (f x)) xs \\<and>\n    (\\<forall>x\\<in>set xs. f x \\<noteq> None)", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       mapM f [] = Some ys \\<Longrightarrow>\n       ys = map (\\<lambda>x. the (f x)) [] \\<and>\n       (\\<forall>x\\<in>set []. f x \\<noteq> None)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   mapM f xs = Some ys \\<Longrightarrow>\n                   ys = map (\\<lambda>x. the (f x)) xs \\<and>\n                   (\\<forall>x\\<in>set xs. f x \\<noteq> None);\n        mapM f (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> ys = map (\\<lambda>x. the (f x)) (a # xs) \\<and>\n                         (\\<forall>x\\<in>set (a # xs). f x \\<noteq> None)", "case (Cons x xs ys)"], ["proof (state)\nthis:\n  mapM f xs = Some ?ys \\<Longrightarrow>\n  ?ys = map (\\<lambda>x. the (f x)) xs \\<and>\n  (\\<forall>x\\<in>set xs. f x \\<noteq> None)\n  mapM f (x # xs) = Some ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       mapM f [] = Some ys \\<Longrightarrow>\n       ys = map (\\<lambda>x. the (f x)) [] \\<and>\n       (\\<forall>x\\<in>set []. f x \\<noteq> None)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   mapM f xs = Some ys \\<Longrightarrow>\n                   ys = map (\\<lambda>x. the (f x)) xs \\<and>\n                   (\\<forall>x\\<in>set xs. f x \\<noteq> None);\n        mapM f (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> ys = map (\\<lambda>x. the (f x)) (a # xs) \\<and>\n                         (\\<forall>x\\<in>set (a # xs). f x \\<noteq> None)", "thus ?case"], ["proof (prove)\nusing this:\n  mapM f xs = Some ?ys \\<Longrightarrow>\n  ?ys = map (\\<lambda>x. the (f x)) xs \\<and>\n  (\\<forall>x\\<in>set xs. f x \\<noteq> None)\n  mapM f (x # xs) = Some ys\n\ngoal (1 subgoal):\n 1. ys = map (\\<lambda>x. the (f x)) (x # xs) \\<and>\n    (\\<forall>x\\<in>set (x # xs). f x \\<noteq> None)", "by (cases \"f x\", simp, cases \"mapM f xs\", auto)"], ["proof (state)\nthis:\n  ys = map (\\<lambda>x. the (f x)) (x # xs) \\<and>\n  (\\<forall>x\\<in>set (x # xs). f x \\<noteq> None)\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       mapM f [] = Some ys \\<Longrightarrow>\n       ys = map (\\<lambda>x. the (f x)) [] \\<and>\n       (\\<forall>x\\<in>set []. f x \\<noteq> None)", "qed simp"], ["", "lemma mapM_Some_idx:\n  assumes some: \"mapM f xs = Some ys\" and i: \"i < length xs\" \n  shows \"\\<exists>y. f (xs ! i) = Some y \\<and> ys ! i = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Some y \\<and> ys ! i = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Some y \\<and> ys ! i = y", "note m = mapM_Some [OF some]"], ["proof (state)\nthis:\n  ys = map (\\<lambda>x. the (f x)) xs \\<and>\n  (\\<forall>x\\<in>set xs. f x \\<noteq> None)\n\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Some y \\<and> ys ! i = y", "from m[unfolded set_conv_nth] i"], ["proof (chain)\npicking this:\n  ys = map (\\<lambda>x. the (f x)) xs \\<and>\n  (\\<forall>x\\<in>{xs ! i |i. i < length xs}. f x \\<noteq> None)\n  i < length xs", "have \"f (xs ! i) \\<noteq> None\""], ["proof (prove)\nusing this:\n  ys = map (\\<lambda>x. the (f x)) xs \\<and>\n  (\\<forall>x\\<in>{xs ! i |i. i < length xs}. f x \\<noteq> None)\n  i < length xs\n\ngoal (1 subgoal):\n 1. f (xs ! i) \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  f (xs ! i) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Some y \\<and> ys ! i = y", "then"], ["proof (chain)\npicking this:\n  f (xs ! i) \\<noteq> None", "obtain y where \"f (xs ! i) = Some y\""], ["proof (prove)\nusing this:\n  f (xs ! i) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        f (xs ! i) = Some y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f (xs ! i) = Some y\n\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Some y \\<and> ys ! i = y", "then"], ["proof (chain)\npicking this:\n  f (xs ! i) = Some y", "have \"f (xs ! i) = Some y \\<and> ys ! i = y\""], ["proof (prove)\nusing this:\n  f (xs ! i) = Some y\n\ngoal (1 subgoal):\n 1. f (xs ! i) = Some y \\<and> ys ! i = y", "unfolding m [THEN conjunct1]"], ["proof (prove)\nusing this:\n  f (xs ! i) = Some y\n\ngoal (1 subgoal):\n 1. f (xs ! i) = Some y \\<and> map (\\<lambda>x. the (f x)) xs ! i = y", "using i"], ["proof (prove)\nusing this:\n  f (xs ! i) = Some y\n  i < length xs\n\ngoal (1 subgoal):\n 1. f (xs ! i) = Some y \\<and> map (\\<lambda>x. the (f x)) xs ! i = y", "by auto"], ["proof (state)\nthis:\n  f (xs ! i) = Some y \\<and> ys ! i = y\n\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Some y \\<and> ys ! i = y", "then"], ["proof (chain)\npicking this:\n  f (xs ! i) = Some y \\<and> ys ! i = y", "show ?thesis"], ["proof (prove)\nusing this:\n  f (xs ! i) = Some y \\<and> ys ! i = y\n\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Some y \\<and> ys ! i = y", ".."], ["proof (state)\nthis:\n  \\<exists>y. f (xs ! i) = Some y \\<and> ys ! i = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mapM_cong [fundef_cong]:\n  assumes \"xs = ys\" and \"\\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\"\n  shows \"mapM f xs = mapM g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapM f xs = mapM g ys", "unfolding assms(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mapM f ys = mapM g ys", "using assms(2)"], ["proof (prove)\nusing this:\n  ?x \\<in> set ys \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. mapM f ys = mapM g ys", "by (induct ys) auto"], ["", "lemma mapM_map:\n  \"mapM f xs = (if (\\<forall>x\\<in>set xs. f x \\<noteq> None) then Some (map (\\<lambda>x. the (f x)) xs) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapM f xs =\n    (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n     then Some (map (\\<lambda>x. the (f x)) xs) else None)", "proof (cases \"mapM f xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mapM f xs = None \\<Longrightarrow>\n    mapM f xs =\n    (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n     then Some (map (\\<lambda>x. the (f x)) xs) else None)\n 2. \\<And>a.\n       mapM f xs = Some a \\<Longrightarrow>\n       mapM f xs =\n       (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n        then Some (map (\\<lambda>x. the (f x)) xs) else None)", "case None"], ["proof (state)\nthis:\n  mapM f xs = None\n\ngoal (2 subgoals):\n 1. mapM f xs = None \\<Longrightarrow>\n    mapM f xs =\n    (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n     then Some (map (\\<lambda>x. the (f x)) xs) else None)\n 2. \\<And>a.\n       mapM f xs = Some a \\<Longrightarrow>\n       mapM f xs =\n       (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n        then Some (map (\\<lambda>x. the (f x)) xs) else None)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mapM f xs = None\n\ngoal (1 subgoal):\n 1. mapM f xs =\n    (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n     then Some (map (\\<lambda>x. the (f x)) xs) else None)", "using mapM_None"], ["proof (prove)\nusing this:\n  mapM f xs = None\n  (mapM ?f ?xs = None) = (\\<exists>x\\<in>set ?xs. ?f x = None)\n\ngoal (1 subgoal):\n 1. mapM f xs =\n    (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n     then Some (map (\\<lambda>x. the (f x)) xs) else None)", "by auto"], ["proof (state)\nthis:\n  mapM f xs =\n  (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n   then Some (map (\\<lambda>x. the (f x)) xs) else None)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       mapM f xs = Some a \\<Longrightarrow>\n       mapM f xs =\n       (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n        then Some (map (\\<lambda>x. the (f x)) xs) else None)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       mapM f xs = Some a \\<Longrightarrow>\n       mapM f xs =\n       (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n        then Some (map (\\<lambda>x. the (f x)) xs) else None)", "case (Some ys)"], ["proof (state)\nthis:\n  mapM f xs = Some ys\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       mapM f xs = Some a \\<Longrightarrow>\n       mapM f xs =\n       (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n        then Some (map (\\<lambda>x. the (f x)) xs) else None)", "with mapM_Some [OF Some]"], ["proof (chain)\npicking this:\n  ys = map (\\<lambda>x. the (f x)) xs \\<and>\n  (\\<forall>x\\<in>set xs. f x \\<noteq> None)\n  mapM f xs = Some ys", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = map (\\<lambda>x. the (f x)) xs \\<and>\n  (\\<forall>x\\<in>set xs. f x \\<noteq> None)\n  mapM f xs = Some ys\n\ngoal (1 subgoal):\n 1. mapM f xs =\n    (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n     then Some (map (\\<lambda>x. the (f x)) xs) else None)", "by auto"], ["proof (state)\nthis:\n  mapM f xs =\n  (if \\<forall>x\\<in>set xs. f x \\<noteq> None\n   then Some (map (\\<lambda>x. the (f x)) xs) else None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mapM_mono [partial_function_mono]:\n  fixes C :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'c option) \\<Rightarrow> 'd option\"\n  assumes C: \"\\<And>y. mono_option (C y)\"\n  shows \"mono_option (\\<lambda>f. mapM (\\<lambda>y. C y f) B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option.le_fun option_ord\n     (\\<lambda>f. mapM (\\<lambda>y. C y f) B)", "proof (induct B)"], ["proof (state)\ngoal (2 subgoals):\n 1. monotone option.le_fun option_ord\n     (\\<lambda>f. mapM (\\<lambda>y. C y f) [])\n 2. \\<And>a B.\n       monotone option.le_fun option_ord\n        (\\<lambda>f. mapM (\\<lambda>y. C y f) B) \\<Longrightarrow>\n       monotone option.le_fun option_ord\n        (\\<lambda>f. mapM (\\<lambda>y. C y f) (a # B))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. monotone option.le_fun option_ord\n     (\\<lambda>f. mapM (\\<lambda>y. C y f) [])\n 2. \\<And>a B.\n       monotone option.le_fun option_ord\n        (\\<lambda>f. mapM (\\<lambda>y. C y f) B) \\<Longrightarrow>\n       monotone option.le_fun option_ord\n        (\\<lambda>f. mapM (\\<lambda>y. C y f) (a # B))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option.le_fun option_ord\n     (\\<lambda>f. mapM (\\<lambda>y. C y f) [])", "unfolding mapM.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option.le_fun option_ord (\\<lambda>f. Some [])", "by (rule option.const_mono)"], ["proof (state)\nthis:\n  monotone option.le_fun option_ord\n   (\\<lambda>f. mapM (\\<lambda>y. C y f) [])\n\ngoal (1 subgoal):\n 1. \\<And>a B.\n       monotone option.le_fun option_ord\n        (\\<lambda>f. mapM (\\<lambda>y. C y f) B) \\<Longrightarrow>\n       monotone option.le_fun option_ord\n        (\\<lambda>f. mapM (\\<lambda>y. C y f) (a # B))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a B.\n       monotone option.le_fun option_ord\n        (\\<lambda>f. mapM (\\<lambda>y. C y f) B) \\<Longrightarrow>\n       monotone option.le_fun option_ord\n        (\\<lambda>f. mapM (\\<lambda>y. C y f) (a # B))", "case (Cons b B)"], ["proof (state)\nthis:\n  monotone option.le_fun option_ord (\\<lambda>f. mapM (\\<lambda>y. C y f) B)\n\ngoal (1 subgoal):\n 1. \\<And>a B.\n       monotone option.le_fun option_ord\n        (\\<lambda>f. mapM (\\<lambda>y. C y f) B) \\<Longrightarrow>\n       monotone option.le_fun option_ord\n        (\\<lambda>f. mapM (\\<lambda>y. C y f) (a # B))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option.le_fun option_ord\n     (\\<lambda>f. mapM (\\<lambda>y. C y f) (b # B))", "unfolding mapM.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option.le_fun option_ord\n     (\\<lambda>f.\n         C b f \\<bind>\n         (\\<lambda>y.\n             mapM (\\<lambda>y. C y f) B \\<bind>\n             (\\<lambda>ys. Some (y # ys))))", "by (rule bind_mono [OF C bind_mono [OF Cons option.const_mono]])"], ["proof (state)\nthis:\n  monotone option.le_fun option_ord\n   (\\<lambda>f. mapM (\\<lambda>y. C y f) (b # B))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}