{"file_name": "/home/qj213/afp-2021-10-22/thys/First_Order_Terms/Term.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/First_Order_Terms", "problem_names": ["lemma is_VarE [elim]:\n  \"is_Var t \\<Longrightarrow> (\\<And>x. t = Var x \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma is_FunE [elim]:\n  \"is_Fun t \\<Longrightarrow> (\\<And>f ts. t = Fun f ts \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma finite_vars_term [simp]:\n  \"finite (vars_term t)\"", "lemma finite_Union_vars_term:\n  \"finite (\\<Union>t \\<in> set ts. vars_term t)\"", "lemma subst_subst_compose [simp]:\n  \"t \\<cdot> (\\<sigma> \\<circ>\\<^sub>s \\<tau>) = t \\<cdot> \\<sigma> \\<cdot> \\<tau>\"", "lemma subst_compose_assoc:\n  \"\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu> = \\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)\"", "lemma subst_apply_term_empty [simp]:\n  \"t \\<cdot> Var = t\"", "lemma term_subst_eq:\n  assumes \"\\<And>x. x \\<in> vars_term t \\<Longrightarrow> \\<sigma> x = \\<tau> x\"\n  shows \"t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>\"", "lemma term_subst_eq_rev:\n  \"t \\<cdot> \\<sigma> = t \\<cdot> \\<tau> \\<Longrightarrow> \\<forall>x \\<in> vars_term t. \\<sigma> x = \\<tau> x\"", "lemma term_subst_eq_conv:\n  \"t \\<cdot> \\<sigma> = t \\<cdot> \\<tau> \\<longleftrightarrow> (\\<forall>x \\<in> vars_term t. \\<sigma> x = \\<tau> x)\"", "lemma subst_term_eqI:\n  assumes \"(\\<And>t. t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>)\"\n  shows \"\\<sigma> = \\<tau>\"", "lemma vars_term_subst:\n  \"vars_term (t \\<cdot> \\<sigma>) = \\<Union>(vars_term ` \\<sigma> ` vars_term t)\"", "lemma range_varsE [elim]:\n  assumes \"x \\<in> range_vars \\<sigma>\"\n    and \"\\<And>t. x \\<in> vars_term t \\<Longrightarrow> t \\<in> subst_range \\<sigma> \\<Longrightarrow> P\"\n  shows \"P\"", "lemma range_vars_subst_compose_subset:\n  \"range_vars (\\<sigma> \\<circ>\\<^sub>s \\<tau>) \\<subseteq> (range_vars \\<sigma> - subst_domain \\<tau>) \\<union> range_vars \\<tau>\" (is \"?L \\<subseteq> ?R\")", "lemma subst_simps [simp]:\n  \"subst x t x = t\"\n  \"subst x (Var x) = Var\"", "lemma subst_subst_domain [simp]:\n  \"subst_domain (subst x t) = (if t = Var x then {} else {x})\"", "lemma subst_subst_range [simp]:\n  \"subst_range (subst x t) = (if t = Var x then {} else {t})\"", "lemma subst_apply_left_idemp [simp]:\n  assumes \"\\<sigma> x = t \\<cdot> \\<sigma>\"\n  shows \"s \\<cdot> subst x t \\<cdot> \\<sigma> = s \\<cdot> \\<sigma>\"", "lemma subst_compose_left_idemp [simp]:\n  assumes \"\\<sigma> x = t \\<cdot> \\<sigma>\"\n  shows \"subst x t \\<circ>\\<^sub>s \\<sigma> = \\<sigma>\"", "lemma subst_ident [simp]:\n  assumes \"x \\<notin> vars_term t\"\n  shows \"t \\<cdot> subst x u = t\"", "lemma subst_self_idemp [simp]:\n  \"x \\<notin> vars_term t \\<Longrightarrow> subst x t \\<circ>\\<^sub>s subst x t = subst x t\"", "lemma subst_compose: \"(\\<sigma> \\<circ>\\<^sub>s \\<tau>) x = \\<sigma> x \\<cdot> \\<tau>\"", "lemmas subst_subst = subst_subst_compose [symmetric]", "lemma subst_domain_Var [simp]:\n  \"subst_domain Var = {}\"", "lemma subst_apply_eq_Var:\n  assumes \"s \\<cdot> \\<sigma> = Var x\"\n  obtains y where \"s = Var y\" and \"\\<sigma> y = Var x\"", "lemma subst_domain_subst_compose:\n  \"subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>) =\n    (subst_domain \\<sigma> - {x. \\<exists>y. \\<sigma> x = Var y \\<and> \\<tau> y = Var x}) \\<union>\n    (subst_domain \\<tau> - subst_domain \\<sigma>)\"", "lemma subst_idemp_iff:\n  \"\\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<longleftrightarrow> subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\"", "lemma num_funs_0:\n  assumes \"num_funs t = 0\"\n  obtains x where \"t = Var x\"", "lemma num_funs_subst:\n  \"num_funs (t \\<cdot> \\<sigma>) \\<ge> num_funs t\"", "lemma sum_list_map_num_funs_subst:\n  assumes \"sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) = sum_list (map num_funs ts)\"\n  shows \"\\<forall>i < length ts. num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i)\"", "lemma is_Fun_num_funs_less:\n  assumes \"x \\<in> vars_term t\" and \"is_Fun t\"\n  shows \"num_funs (\\<sigma> x) < num_funs (t \\<cdot> \\<sigma>)\"", "lemma finite_subst_domain_subst:\n  \"finite (subst_domain (subst x y))\"", "lemma subst_domain_compose:\n  \"subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>) \\<subseteq> subst_domain \\<sigma> \\<union> subst_domain \\<tau>\"", "lemma vars_term_disjoint_imp_unifier:\n  fixes \\<sigma> :: \"('f, 'v, 'w) gsubst\"\n  assumes \"vars_term s \\<inter> vars_term t = {}\"\n    and \"s \\<cdot> \\<sigma> = t \\<cdot> \\<tau>\"\n  shows \"\\<exists>\\<mu> :: ('f, 'v, 'w) gsubst. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>\"", "lemma vars_term_subset_subst_eq:\n  assumes \"vars_term t \\<subseteq> vars_term s\"\n    and \"s \\<cdot> \\<sigma> = s \\<cdot> \\<tau>\"\n  shows \"t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>\""], "translations": [["", "lemma is_VarE [elim]:\n  \"is_Var t \\<Longrightarrow> (\\<And>x. t = Var x \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_Var t; \\<And>x. t = Var x \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases t) auto"], ["", "lemma is_FunE [elim]:\n  \"is_Fun t \\<Longrightarrow> (\\<And>f ts. t = Fun f ts \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_Fun t; \\<And>f ts. t = Fun f ts \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases t) auto"], ["", "text \\<open>Reorient equations of the form @{term \"Var x = t\"} and @{term \"Fun f ss = t\"} to facilitate\n  simplification.\\<close>"], ["", "setup \\<open>\n  Reorient_Proc.add\n    (fn Const (@{const_name Var}, _) $ _ => true | _ => false)\n  #> Reorient_Proc.add\n    (fn Const (@{const_name Fun}, _) $ _ $ _ => true | _ => false)\n\\<close>"], ["", "simproc_setup reorient_Var (\"Var x = t\") = Reorient_Proc.proc"], ["", "simproc_setup reorient_Fun (\"Fun f ss = t\") = Reorient_Proc.proc"], ["", "text \\<open>The \\emph{root symbol} of a term is defined by:\\<close>"], ["", "fun root :: \"('f, 'v) term \\<Rightarrow> ('f \\<times> nat) option\"\nwhere\n  \"root (Var x) = None\" |\n  \"root (Fun f ts) = Some (f, length ts)\""], ["", "lemma finite_vars_term [simp]:\n  \"finite (vars_term t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (vars_term t)", "by (induct t) simp_all"], ["", "lemma finite_Union_vars_term:\n  \"finite (\\<Union>t \\<in> set ts. vars_term t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (vars_term ` set ts))", "by auto"], ["", "text \\<open>A substitution is a mapping \\<open>\\<sigma>\\<close> from variables to terms. We call a substitution that\n  alters the type of variables a generalized substitution, since it does not have all properties\n  that are expected of (standard) substitutions (e.g., there is no empty substitution).\\<close>"], ["", "type_synonym ('f, 'v, 'w) gsubst = \"'v \\<Rightarrow> ('f, 'w) term\""], ["", "type_synonym ('f, 'v) subst  = \"('f, 'v, 'v) gsubst\""], ["", "fun subst_apply_term :: \"('f, 'v) term \\<Rightarrow> ('f, 'v, 'w) gsubst \\<Rightarrow> ('f, 'w) term\" (infixl \"\\<cdot>\" 67)\n  where\n    \"Var x \\<cdot> \\<sigma> = \\<sigma> x\"\n  | \"Fun f ss \\<cdot> \\<sigma> = Fun f (map (\\<lambda>t. t \\<cdot> \\<sigma>) ss)\""], ["", "definition\n  subst_compose :: \"('f, 'u, 'v) gsubst \\<Rightarrow> ('f, 'v, 'w) gsubst \\<Rightarrow> ('f, 'u, 'w) gsubst\"\n  (infixl \"\\<circ>\\<^sub>s\" 75)\n  where\n    \"\\<sigma> \\<circ>\\<^sub>s \\<tau> = (\\<lambda>x. (\\<sigma> x) \\<cdot> \\<tau>)\""], ["", "lemma subst_subst_compose [simp]:\n  \"t \\<cdot> (\\<sigma> \\<circ>\\<^sub>s \\<tau>) = t \\<cdot> \\<sigma> \\<cdot> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<cdot> \\<sigma> \\<circ>\\<^sub>s \\<tau> =\n    t \\<cdot> \\<sigma> \\<cdot> \\<tau>", "by (induct t \\<sigma> rule: subst_apply_term.induct) (simp_all add: subst_compose_def)"], ["", "lemma subst_compose_assoc:\n  \"\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu> = \\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu> =\n    \\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n       (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n       (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x", "show \"(\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x = (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n    (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n    (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x", "have \"(\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x = \\<sigma>(x) \\<cdot> \\<tau> \\<cdot> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n    \\<sigma> x \\<cdot> \\<tau> \\<cdot> \\<mu>", "by (simp add: subst_compose_def)"], ["proof (state)\nthis:\n  (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n  \\<sigma> x \\<cdot> \\<tau> \\<cdot> \\<mu>\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n    (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x", "also"], ["proof (state)\nthis:\n  (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n  \\<sigma> x \\<cdot> \\<tau> \\<cdot> \\<mu>\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n    (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x", "have \"\\<dots> = \\<sigma>(x) \\<cdot> (\\<tau> \\<circ>\\<^sub>s \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> x \\<cdot> \\<tau> \\<cdot> \\<mu> =\n    \\<sigma> x \\<cdot> \\<tau> \\<circ>\\<^sub>s \\<mu>", "by simp"], ["proof (state)\nthis:\n  \\<sigma> x \\<cdot> \\<tau> \\<cdot> \\<mu> =\n  \\<sigma> x \\<cdot> \\<tau> \\<circ>\\<^sub>s \\<mu>\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n    (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x", "finally"], ["proof (chain)\npicking this:\n  (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n  \\<sigma> x \\<cdot> \\<tau> \\<circ>\\<^sub>s \\<mu>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n  \\<sigma> x \\<cdot> \\<tau> \\<circ>\\<^sub>s \\<mu>\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n    (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x", "by (simp add: subst_compose_def)"], ["proof (state)\nthis:\n  (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n  (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<sigma> \\<circ>\\<^sub>s \\<tau> \\<circ>\\<^sub>s \\<mu>) x =\n  (\\<sigma> \\<circ>\\<^sub>s (\\<tau> \\<circ>\\<^sub>s \\<mu>)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_apply_term_empty [simp]:\n  \"t \\<cdot> Var = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<cdot> Var = t", "proof (induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<cdot> Var = Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<cdot> Var = x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<cdot> Var = Fun x1a x2", "case (Fun f ts)"], ["proof (state)\nthis:\n  ?x2a \\<in> set ts \\<Longrightarrow> ?x2a \\<cdot> Var = ?x2a\n\ngoal (2 subgoals):\n 1. \\<And>x. Var x \\<cdot> Var = Var x\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           x2a \\<cdot> Var = x2a) \\<Longrightarrow>\n       Fun x1a x2 \\<cdot> Var = Fun x1a x2", "from map_ext [rule_format, of ts _ id, OF Fun]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x \\<in> set ts \\<Longrightarrow> id x \\<in> set ts) \\<Longrightarrow>\n  map (\\<lambda>x. id x \\<cdot> Var) ts = map id ts", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> set ts \\<Longrightarrow> id x \\<in> set ts) \\<Longrightarrow>\n  map (\\<lambda>x. id x \\<cdot> Var) ts = map id ts\n\ngoal (1 subgoal):\n 1. Fun f ts \\<cdot> Var = Fun f ts", "by simp"], ["proof (state)\nthis:\n  Fun f ts \\<cdot> Var = Fun f ts\n\ngoal (1 subgoal):\n 1. \\<And>x. Var x \\<cdot> Var = Var x", "qed simp"], ["", "interpretation subst_monoid_mult: monoid_mult \"Var\" \"(\\<circ>\\<^sub>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_mult Var (\\<circ>\\<^sub>s)", "by (unfold_locales) (simp add: subst_compose_assoc, simp_all add: subst_compose_def)"], ["", "lemma term_subst_eq:\n  assumes \"\\<And>x. x \\<in> vars_term t \\<Longrightarrow> \\<sigma> x = \\<tau> x\"\n  shows \"t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> vars_term t \\<Longrightarrow> \\<sigma> ?x = \\<tau> ?x\n\ngoal (1 subgoal):\n 1. t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>", "by (induct t) (auto)"], ["", "lemma term_subst_eq_rev:\n  \"t \\<cdot> \\<sigma> = t \\<cdot> \\<tau> \\<Longrightarrow> \\<forall>x \\<in> vars_term t. \\<sigma> x = \\<tau> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<cdot> \\<sigma> = t \\<cdot> \\<tau> \\<Longrightarrow>\n    \\<forall>x\\<in>vars_term t. \\<sigma> x = \\<tau> x", "by (induct t) simp_all"], ["", "lemma term_subst_eq_conv:\n  \"t \\<cdot> \\<sigma> = t \\<cdot> \\<tau> \\<longleftrightarrow> (\\<forall>x \\<in> vars_term t. \\<sigma> x = \\<tau> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>) =\n    (\\<forall>x\\<in>vars_term t. \\<sigma> x = \\<tau> x)", "using term_subst_eq [of t \\<sigma> \\<tau>] and term_subst_eq_rev [of t \\<sigma> \\<tau>]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> vars_term t \\<Longrightarrow>\n      \\<sigma> x = \\<tau> x) \\<Longrightarrow>\n  t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>\n  t \\<cdot> \\<sigma> = t \\<cdot> \\<tau> \\<Longrightarrow>\n  \\<forall>x\\<in>vars_term t. \\<sigma> x = \\<tau> x\n\ngoal (1 subgoal):\n 1. (t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>) =\n    (\\<forall>x\\<in>vars_term t. \\<sigma> x = \\<tau> x)", "by auto"], ["", "lemma subst_term_eqI:\n  assumes \"(\\<And>t. t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>)\"\n  shows \"\\<sigma> = \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = \\<tau>", "using assms [of \"Var x\" for x]"], ["proof (prove)\nusing this:\n  Var ?x2 \\<cdot> \\<sigma> = Var ?x2 \\<cdot> \\<tau>\n\ngoal (1 subgoal):\n 1. \\<sigma> = \\<tau>", "by (intro ext) simp"], ["", "definition subst_domain :: \"('f, 'v) subst \\<Rightarrow> 'v set\"\n  where\n    \"subst_domain \\<sigma> = {x. \\<sigma> x \\<noteq> Var x}\""], ["", "fun subst_range :: \"('f, 'v) subst \\<Rightarrow> ('f, 'v) term set\"\n  where\n    \"subst_range \\<sigma> = \\<sigma> ` subst_domain \\<sigma>\""], ["", "text \\<open>The variables introduced by a substitution.\\<close>"], ["", "definition range_vars :: \"('f, 'v) subst \\<Rightarrow> 'v set\"\nwhere\n  \"range_vars \\<sigma> = \\<Union>(vars_term ` subst_range \\<sigma>)\""], ["", "definition is_renaming :: \"('f, 'v) subst \\<Rightarrow> bool\"\n  where\n    \"is_renaming \\<sigma> \\<longleftrightarrow> (\\<forall>x. is_Var (\\<sigma> x)) \\<and> inj_on \\<sigma> (subst_domain \\<sigma>)\""], ["", "lemma vars_term_subst:\n  \"vars_term (t \\<cdot> \\<sigma>) = \\<Union>(vars_term ` \\<sigma> ` vars_term t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_term (t \\<cdot> \\<sigma>) =\n    \\<Union> (vars_term ` \\<sigma> ` vars_term t)", "by (induct t) simp_all"], ["", "lemma range_varsE [elim]:\n  assumes \"x \\<in> range_vars \\<sigma>\"\n    and \"\\<And>t. x \\<in> vars_term t \\<Longrightarrow> t \\<in> subst_range \\<sigma> \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> range_vars \\<sigma>\n  \\<lbrakk>x \\<in> vars_term ?t; ?t \\<in> subst_range \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (auto simp: range_vars_def)"], ["", "lemma range_vars_subst_compose_subset:\n  \"range_vars (\\<sigma> \\<circ>\\<^sub>s \\<tau>) \\<subseteq> (range_vars \\<sigma> - subst_domain \\<tau>) \\<union> range_vars \\<tau>\" (is \"?L \\<subseteq> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. range_vars (\\<sigma> \\<circ>\\<^sub>s \\<tau>)\n    \\<subseteq> range_vars \\<sigma> - subst_domain \\<tau> \\<union>\n                range_vars \\<tau>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range_vars\n                (\\<sigma> \\<circ>\\<^sub>s \\<tau>) \\<Longrightarrow>\n       x \\<in> range_vars \\<sigma> - subst_domain \\<tau> \\<union>\n               range_vars \\<tau>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range_vars\n                (\\<sigma> \\<circ>\\<^sub>s \\<tau>) \\<Longrightarrow>\n       x \\<in> range_vars \\<sigma> - subst_domain \\<tau> \\<union>\n               range_vars \\<tau>", "assume \"x \\<in> ?L\""], ["proof (state)\nthis:\n  x \\<in> range_vars (\\<sigma> \\<circ>\\<^sub>s \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range_vars\n                (\\<sigma> \\<circ>\\<^sub>s \\<tau>) \\<Longrightarrow>\n       x \\<in> range_vars \\<sigma> - subst_domain \\<tau> \\<union>\n               range_vars \\<tau>", "then"], ["proof (chain)\npicking this:\n  x \\<in> range_vars (\\<sigma> \\<circ>\\<^sub>s \\<tau>)", "obtain y where \"y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>)\"\n    and \"x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)\""], ["proof (prove)\nusing this:\n  x \\<in> range_vars (\\<sigma> \\<circ>\\<^sub>s \\<tau>)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>);\n         x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: range_vars_def)"], ["proof (state)\nthis:\n  y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>)\n  x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range_vars\n                (\\<sigma> \\<circ>\\<^sub>s \\<tau>) \\<Longrightarrow>\n       x \\<in> range_vars \\<sigma> - subst_domain \\<tau> \\<union>\n               range_vars \\<tau>", "then"], ["proof (chain)\npicking this:\n  y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>)\n  x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)", "show \"x \\<in> ?R\""], ["proof (prove)\nusing this:\n  y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>)\n  x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)\n\ngoal (1 subgoal):\n 1. x \\<in> range_vars \\<sigma> - subst_domain \\<tau> \\<union>\n            range_vars \\<tau>", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>);\n     x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y); ?P2\\<rbrakk>\n    \\<Longrightarrow> x \\<in> range_vars \\<sigma> -\n                              subst_domain \\<tau> \\<union>\n                              range_vars \\<tau>\n 2. \\<lbrakk>y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>);\n     x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y);\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> x \\<in> range_vars \\<sigma> -\n                              subst_domain \\<tau> \\<union>\n                              range_vars \\<tau>", "assume \"y \\<in> subst_domain \\<sigma>\" and \"x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)\""], ["proof (state)\nthis:\n  y \\<in> subst_domain \\<sigma>\n  x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>);\n     x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y); ?P2\\<rbrakk>\n    \\<Longrightarrow> x \\<in> range_vars \\<sigma> -\n                              subst_domain \\<tau> \\<union>\n                              range_vars \\<tau>\n 2. \\<lbrakk>y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>);\n     x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y);\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> x \\<in> range_vars \\<sigma> -\n                              subst_domain \\<tau> \\<union>\n                              range_vars \\<tau>", "moreover"], ["proof (state)\nthis:\n  y \\<in> subst_domain \\<sigma>\n  x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>);\n     x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y); ?P2\\<rbrakk>\n    \\<Longrightarrow> x \\<in> range_vars \\<sigma> -\n                              subst_domain \\<tau> \\<union>\n                              range_vars \\<tau>\n 2. \\<lbrakk>y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>);\n     x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y);\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> x \\<in> range_vars \\<sigma> -\n                              subst_domain \\<tau> \\<union>\n                              range_vars \\<tau>", "then"], ["proof (chain)\npicking this:\n  y \\<in> subst_domain \\<sigma>\n  x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)", "obtain v where \"v \\<in> vars_term (\\<sigma> y)\"\n      and \"x \\<in> vars_term (\\<tau> v)\""], ["proof (prove)\nusing this:\n  y \\<in> subst_domain \\<sigma>\n  x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> vars_term (\\<sigma> y);\n         x \\<in> vars_term (\\<tau> v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: subst_compose_def vars_term_subst)"], ["proof (state)\nthis:\n  v \\<in> vars_term (\\<sigma> y)\n  x \\<in> vars_term (\\<tau> v)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>);\n     x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y); ?P2\\<rbrakk>\n    \\<Longrightarrow> x \\<in> range_vars \\<sigma> -\n                              subst_domain \\<tau> \\<union>\n                              range_vars \\<tau>\n 2. \\<lbrakk>y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>);\n     x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y);\n     \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> x \\<in> range_vars \\<sigma> -\n                              subst_domain \\<tau> \\<union>\n                              range_vars \\<tau>", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> subst_domain \\<sigma>\n  x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)\n  v \\<in> vars_term (\\<sigma> y)\n  x \\<in> vars_term (\\<tau> v)", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> subst_domain \\<sigma>\n  x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y)\n  v \\<in> vars_term (\\<sigma> y)\n  x \\<in> vars_term (\\<tau> v)\n\ngoal (1 subgoal):\n 1. x \\<in> range_vars \\<sigma> - subst_domain \\<tau> \\<union>\n            range_vars \\<tau>", "by (cases \"v \\<in> subst_domain \\<tau>\") (auto simp: range_vars_def subst_domain_def)"], ["proof (state)\nthis:\n  x \\<in> range_vars \\<sigma> - subst_domain \\<tau> \\<union>\n          range_vars \\<tau>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>);\n     x \\<in> vars_term ((\\<sigma> \\<circ>\\<^sub>s \\<tau>) y);\n     y \\<notin> subst_domain \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> x \\<in> range_vars \\<sigma> -\n                              subst_domain \\<tau> \\<union>\n                              range_vars \\<tau>", "qed (auto simp: range_vars_def subst_compose_def subst_domain_def)"], ["proof (state)\nthis:\n  x \\<in> range_vars \\<sigma> - subst_domain \\<tau> \\<union>\n          range_vars \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"subst x t = Var (x := t)\""], ["", "lemma subst_simps [simp]:\n  \"subst x t x = t\"\n  \"subst x (Var x) = Var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst x t x = t &&& subst x (Var x) = Var", "by (auto simp: subst_def)"], ["", "lemma subst_subst_domain [simp]:\n  \"subst_domain (subst x t) = (if t = Var x then {} else {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_domain (subst x t) = (if t = Var x then {} else {x})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_domain (subst x t) = (if t = Var x then {} else {x})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_domain (subst x t) = (if t = Var x then {} else {x})", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_domain (subst x t) = (if t = Var x then {} else {x})", "have \"y \\<in> {y. subst x t y \\<noteq> Var y} \\<longleftrightarrow> y \\<in> (if t = Var x then {} else {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> {y. subst x t y \\<noteq> Var y}) =\n    (y \\<in> (if t = Var x then {} else {x}))", "by (cases \"x = y\", auto simp: subst_def)"], ["proof (state)\nthis:\n  (y \\<in> {y. subst x t y \\<noteq> Var y}) =\n  (y \\<in> (if t = Var x then {} else {x}))\n\ngoal (1 subgoal):\n 1. subst_domain (subst x t) = (if t = Var x then {} else {x})", "}"], ["proof (state)\nthis:\n  (?y2 \\<in> {y. subst x t y \\<noteq> Var y}) =\n  (?y2 \\<in> (if t = Var x then {} else {x}))\n\ngoal (1 subgoal):\n 1. subst_domain (subst x t) = (if t = Var x then {} else {x})", "then"], ["proof (chain)\npicking this:\n  (?y2 \\<in> {y. subst x t y \\<noteq> Var y}) =\n  (?y2 \\<in> (if t = Var x then {} else {x}))", "show ?thesis"], ["proof (prove)\nusing this:\n  (?y2 \\<in> {y. subst x t y \\<noteq> Var y}) =\n  (?y2 \\<in> (if t = Var x then {} else {x}))\n\ngoal (1 subgoal):\n 1. subst_domain (subst x t) = (if t = Var x then {} else {x})", "by (simp add: subst_domain_def)"], ["proof (state)\nthis:\n  subst_domain (subst x t) = (if t = Var x then {} else {x})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_subst_range [simp]:\n  \"subst_range (subst x t) = (if t = Var x then {} else {t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_range (subst x t) = (if t = Var x then {} else {t})", "by (cases \"t = Var x\") (auto simp: subst_domain_def subst_def)"], ["", "lemma subst_apply_left_idemp [simp]:\n  assumes \"\\<sigma> x = t \\<cdot> \\<sigma>\"\n  shows \"s \\<cdot> subst x t \\<cdot> \\<sigma> = s \\<cdot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<cdot> subst x t \\<cdot> \\<sigma> = s \\<cdot> \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  \\<sigma> x = t \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. s \\<cdot> subst x t \\<cdot> \\<sigma> = s \\<cdot> \\<sigma>", "by (induct s) (auto simp: subst_def)"], ["", "lemma subst_compose_left_idemp [simp]:\n  assumes \"\\<sigma> x = t \\<cdot> \\<sigma>\"\n  shows \"subst x t \\<circ>\\<^sub>s \\<sigma> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst x t \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "by (rule subst_term_eqI) (simp add: assms)"], ["", "lemma subst_ident [simp]:\n  assumes \"x \\<notin> vars_term t\"\n  shows \"t \\<cdot> subst x u = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<cdot> subst x u = t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<cdot> subst x u = t", "have \"t \\<cdot> subst x u = t \\<cdot> Var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<cdot> subst x u = t \\<cdot> Var", "by (rule term_subst_eq) (auto simp: assms subst_def)"], ["proof (state)\nthis:\n  t \\<cdot> subst x u = t \\<cdot> Var\n\ngoal (1 subgoal):\n 1. t \\<cdot> subst x u = t", "then"], ["proof (chain)\npicking this:\n  t \\<cdot> subst x u = t \\<cdot> Var", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<cdot> subst x u = t \\<cdot> Var\n\ngoal (1 subgoal):\n 1. t \\<cdot> subst x u = t", "by simp"], ["proof (state)\nthis:\n  t \\<cdot> subst x u = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_self_idemp [simp]:\n  \"x \\<notin> vars_term t \\<Longrightarrow> subst x t \\<circ>\\<^sub>s subst x t = subst x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> vars_term t \\<Longrightarrow>\n    subst x t \\<circ>\\<^sub>s subst x t = subst x t", "by (metis subst_simps(1) subst_compose_left_idemp subst_ident)"], ["", "type_synonym ('f, 'v) terms = \"('f, 'v) term set\""], ["", "text \\<open>Applying a substitution to every term of a given set.\\<close>"], ["", "abbreviation\n  subst_apply_set :: \"('f, 'v) terms \\<Rightarrow> ('f, 'v, 'w) gsubst \\<Rightarrow> ('f, 'w) terms\" (infixl \"\\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t\" 60)\n  where\n    \"T \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma> \\<equiv> (\\<lambda>t. t \\<cdot> \\<sigma>) ` T\""], ["", "text \\<open>Composition of substitutions\\<close>"], ["", "lemma subst_compose: \"(\\<sigma> \\<circ>\\<^sub>s \\<tau>) x = \\<sigma> x \\<cdot> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<circ>\\<^sub>s \\<tau>) x = \\<sigma> x \\<cdot> \\<tau>", "by (auto simp: subst_compose_def)"], ["", "lemmas subst_subst = subst_subst_compose [symmetric]"], ["", "lemma subst_domain_Var [simp]:\n  \"subst_domain Var = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_domain Var = {}", "by (simp add: subst_domain_def)"], ["", "lemma subst_apply_eq_Var:\n  assumes \"s \\<cdot> \\<sigma> = Var x\"\n  obtains y where \"s = Var y\" and \"\\<sigma> y = Var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>s = Var y; \\<sigma> y = Var x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  s \\<cdot> \\<sigma> = Var x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>s = Var y; \\<sigma> y = Var x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induct s) auto"], ["", "lemma subst_domain_subst_compose:\n  \"subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>) =\n    (subst_domain \\<sigma> - {x. \\<exists>y. \\<sigma> x = Var y \\<and> \\<tau> y = Var x}) \\<union>\n    (subst_domain \\<tau> - subst_domain \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>) =\n    subst_domain \\<sigma> -\n    {x. \\<exists>y. \\<sigma> x = Var y \\<and> \\<tau> y = Var x} \\<union>\n    (subst_domain \\<tau> - subst_domain \\<sigma>)", "by (auto simp: subst_domain_def subst_compose_def elim: subst_apply_eq_Var)"], ["", "text \\<open>A substitution is idempotent iff the variables in its range are disjoint from its domain.\n  (See also \"Term Rewriting and All That\" \\cite[Lemma 4.5.7]{AllThat}.)\\<close>"], ["", "lemma subst_idemp_iff:\n  \"\\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<longleftrightarrow> subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>) =\n    (subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<Longrightarrow>\n    subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n 2. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "assume \"\\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>\""], ["proof (state)\nthis:\n  \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<Longrightarrow>\n    subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n 2. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "have \"\\<And>x. \\<sigma> x \\<cdot> \\<sigma> = \\<sigma> x \\<cdot> Var\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<sigma> x \\<cdot> \\<sigma> = \\<sigma> x \\<cdot> Var", "by simp (metis subst_compose_def)"], ["proof (state)\nthis:\n  \\<sigma> ?x \\<cdot> \\<sigma> = \\<sigma> ?x \\<cdot> Var\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<Longrightarrow>\n    subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n 2. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<sigma> ?x \\<cdot> \\<sigma> = \\<sigma> ?x \\<cdot> Var", "have *: \"\\<And>x. \\<forall>y\\<in>vars_term (\\<sigma> x). \\<sigma> y = Var y\""], ["proof (prove)\nusing this:\n  \\<sigma> ?x \\<cdot> \\<sigma> = \\<sigma> ?x \\<cdot> Var\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>y\\<in>vars_term (\\<sigma> x). \\<sigma> y = Var y", "unfolding term_subst_eq_conv"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars_term (\\<sigma> ?x). \\<sigma> x = Var x\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>y\\<in>vars_term (\\<sigma> x). \\<sigma> y = Var y", "by simp"], ["proof (state)\nthis:\n  \\<forall>y\\<in>vars_term (\\<sigma> ?x). \\<sigma> y = Var y\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<Longrightarrow>\n    subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n 2. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "{"], ["proof (state)\nthis:\n  \\<forall>y\\<in>vars_term (\\<sigma> ?x). \\<sigma> y = Var y\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<Longrightarrow>\n    subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n 2. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<Longrightarrow>\n    subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n 2. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "assume \"\\<sigma> x \\<noteq> Var x\" and \"x \\<in> vars_term (\\<sigma> y)\""], ["proof (state)\nthis:\n  \\<sigma> x \\<noteq> Var x\n  x \\<in> vars_term (\\<sigma> y)\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<Longrightarrow>\n    subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n 2. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "with * [of y]"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>vars_term (\\<sigma> y). \\<sigma> y = Var y\n  \\<sigma> x \\<noteq> Var x\n  x \\<in> vars_term (\\<sigma> y)", "have False"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>vars_term (\\<sigma> y). \\<sigma> y = Var y\n  \\<sigma> x \\<noteq> Var x\n  x \\<in> vars_term (\\<sigma> y)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<Longrightarrow>\n    subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n 2. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<sigma> ?x2 \\<noteq> Var ?x2;\n   ?x2 \\<in> vars_term (\\<sigma> ?y2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma> \\<Longrightarrow>\n    subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n 2. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<sigma> ?x2 \\<noteq> Var ?x2;\n   ?x2 \\<in> vars_term (\\<sigma> ?y2)\\<rbrakk>\n  \\<Longrightarrow> False", "show \"subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<sigma> ?x2 \\<noteq> Var ?x2;\n   ?x2 \\<in> vars_term (\\<sigma> ?y2)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}", "by (auto simp: subst_domain_def range_vars_def)"], ["proof (state)\nthis:\n  subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "assume \"subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\""], ["proof (state)\nthis:\n  subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "then"], ["proof (chain)\npicking this:\n  subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}", "have *: \"\\<And>x y. \\<sigma> x = Var x \\<or> \\<sigma> y = Var y \\<or> x \\<notin> vars_term (\\<sigma> y)\""], ["proof (prove)\nusing this:\n  subst_domain \\<sigma> \\<inter> range_vars \\<sigma> = {}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<sigma> x = Var x \\<or>\n       \\<sigma> y = Var y \\<or> x \\<notin> vars_term (\\<sigma> y)", "by (auto simp: subst_domain_def range_vars_def)"], ["proof (state)\nthis:\n  \\<sigma> ?x = Var ?x \\<or>\n  \\<sigma> ?y = Var ?y \\<or> ?x \\<notin> vars_term (\\<sigma> ?y)\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "have \"\\<And>x. \\<forall>y\\<in>vars_term (\\<sigma> x). \\<sigma> y = Var y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>y\\<in>vars_term (\\<sigma> x). \\<sigma> y = Var y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       y \\<in> vars_term (\\<sigma> x) \\<Longrightarrow> \\<sigma> y = Var y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       y \\<in> vars_term (\\<sigma> x) \\<Longrightarrow> \\<sigma> y = Var y", "assume \"y \\<in> vars_term (\\<sigma> x)\""], ["proof (state)\nthis:\n  y \\<in> vars_term (\\<sigma> x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       y \\<in> vars_term (\\<sigma> x) \\<Longrightarrow> \\<sigma> y = Var y", "with * [of y x]"], ["proof (chain)\npicking this:\n  \\<sigma> y = Var y \\<or>\n  \\<sigma> x = Var x \\<or> y \\<notin> vars_term (\\<sigma> x)\n  y \\<in> vars_term (\\<sigma> x)", "show \"\\<sigma> y = Var y\""], ["proof (prove)\nusing this:\n  \\<sigma> y = Var y \\<or>\n  \\<sigma> x = Var x \\<or> y \\<notin> vars_term (\\<sigma> x)\n  y \\<in> vars_term (\\<sigma> x)\n\ngoal (1 subgoal):\n 1. \\<sigma> y = Var y", "by auto"], ["proof (state)\nthis:\n  \\<sigma> y = Var y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y\\<in>vars_term (\\<sigma> ?x). \\<sigma> y = Var y\n\ngoal (1 subgoal):\n 1. subst_domain \\<sigma> \\<inter> range_vars \\<sigma> =\n    {} \\<Longrightarrow>\n    \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>vars_term (\\<sigma> ?x). \\<sigma> y = Var y", "show \"\\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>vars_term (\\<sigma> ?x). \\<sigma> y = Var y\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>", "by (simp add: subst_compose_def term_subst_eq_conv [symmetric])"], ["proof (state)\nthis:\n  \\<sigma> \\<circ>\\<^sub>s \\<sigma> = \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "fun num_funs :: \"('f, 'v) term \\<Rightarrow> nat\"\n  where\n    \"num_funs (Var x) = 0\" |\n    \"num_funs (Fun f ts) = Suc (sum_list (map num_funs ts))\""], ["", "lemma num_funs_0:\n  assumes \"num_funs t = 0\"\n  obtains x where \"t = Var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. t = Var x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  num_funs t = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x. t = Var x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (induct t) auto"], ["", "lemma num_funs_subst:\n  \"num_funs (t \\<cdot> \\<sigma>) \\<ge> num_funs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_funs t \\<le> num_funs (t \\<cdot> \\<sigma>)", "by (induct t) (simp_all, metis comp_apply sum_list_mono)"], ["", "lemma sum_list_map_num_funs_subst:\n  assumes \"sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) = sum_list (map num_funs ts)\"\n  shows \"\\<forall>i < length ts. num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length ts.\n       num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i)", "using assms"], ["proof (prove)\nusing this:\n  sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n  sum_list (map num_funs ts)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ts.\n       num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i)", "proof (induct ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) []) =\n    sum_list (map num_funs []) \\<Longrightarrow>\n    \\<forall>i<length [].\n       num_funs ([] ! i \\<cdot> \\<sigma>) = num_funs ([] ! i)\n 2. \\<And>a ts.\n       \\<lbrakk>sum_list\n                 (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n                   ts) =\n                sum_list (map num_funs ts) \\<Longrightarrow>\n                \\<forall>i<length ts.\n                   num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i);\n        sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n           (a # ts)) =\n        sum_list (map num_funs (a # ts))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ts).\n                            num_funs ((a # ts) ! i \\<cdot> \\<sigma>) =\n                            num_funs ((a # ts) ! i)", "case (Cons t ts)"], ["proof (state)\nthis:\n  sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n  sum_list (map num_funs ts) \\<Longrightarrow>\n  \\<forall>i<length ts.\n     num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i)\n  sum_list\n   (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) (t # ts)) =\n  sum_list (map num_funs (t # ts))\n\ngoal (2 subgoals):\n 1. sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) []) =\n    sum_list (map num_funs []) \\<Longrightarrow>\n    \\<forall>i<length [].\n       num_funs ([] ! i \\<cdot> \\<sigma>) = num_funs ([] ! i)\n 2. \\<And>a ts.\n       \\<lbrakk>sum_list\n                 (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n                   ts) =\n                sum_list (map num_funs ts) \\<Longrightarrow>\n                \\<forall>i<length ts.\n                   num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i);\n        sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n           (a # ts)) =\n        sum_list (map num_funs (a # ts))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ts).\n                            num_funs ((a # ts) ! i \\<cdot> \\<sigma>) =\n                            num_funs ((a # ts) ! i)", "then"], ["proof (chain)\npicking this:\n  sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n  sum_list (map num_funs ts) \\<Longrightarrow>\n  \\<forall>i<length ts.\n     num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i)\n  sum_list\n   (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) (t # ts)) =\n  sum_list (map num_funs (t # ts))", "have \"num_funs (t \\<cdot> \\<sigma>) + sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)\n    = num_funs t + sum_list (map num_funs ts)\""], ["proof (prove)\nusing this:\n  sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n  sum_list (map num_funs ts) \\<Longrightarrow>\n  \\<forall>i<length ts.\n     num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i)\n  sum_list\n   (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) (t # ts)) =\n  sum_list (map num_funs (t # ts))\n\ngoal (1 subgoal):\n 1. num_funs (t \\<cdot> \\<sigma>) +\n    sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n    num_funs t + sum_list (map num_funs ts)", "by (simp add: o_def)"], ["proof (state)\nthis:\n  num_funs (t \\<cdot> \\<sigma>) +\n  sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n  num_funs t + sum_list (map num_funs ts)\n\ngoal (2 subgoals):\n 1. sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) []) =\n    sum_list (map num_funs []) \\<Longrightarrow>\n    \\<forall>i<length [].\n       num_funs ([] ! i \\<cdot> \\<sigma>) = num_funs ([] ! i)\n 2. \\<And>a ts.\n       \\<lbrakk>sum_list\n                 (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n                   ts) =\n                sum_list (map num_funs ts) \\<Longrightarrow>\n                \\<forall>i<length ts.\n                   num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i);\n        sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n           (a # ts)) =\n        sum_list (map num_funs (a # ts))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ts).\n                            num_funs ((a # ts) ! i \\<cdot> \\<sigma>) =\n                            num_funs ((a # ts) ! i)", "moreover"], ["proof (state)\nthis:\n  num_funs (t \\<cdot> \\<sigma>) +\n  sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n  num_funs t + sum_list (map num_funs ts)\n\ngoal (2 subgoals):\n 1. sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) []) =\n    sum_list (map num_funs []) \\<Longrightarrow>\n    \\<forall>i<length [].\n       num_funs ([] ! i \\<cdot> \\<sigma>) = num_funs ([] ! i)\n 2. \\<And>a ts.\n       \\<lbrakk>sum_list\n                 (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n                   ts) =\n                sum_list (map num_funs ts) \\<Longrightarrow>\n                \\<forall>i<length ts.\n                   num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i);\n        sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n           (a # ts)) =\n        sum_list (map num_funs (a # ts))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ts).\n                            num_funs ((a # ts) ! i \\<cdot> \\<sigma>) =\n                            num_funs ((a # ts) ! i)", "have \"num_funs (t \\<cdot> \\<sigma>) \\<ge> num_funs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_funs t \\<le> num_funs (t \\<cdot> \\<sigma>)", "by (metis num_funs_subst)"], ["proof (state)\nthis:\n  num_funs t \\<le> num_funs (t \\<cdot> \\<sigma>)\n\ngoal (2 subgoals):\n 1. sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) []) =\n    sum_list (map num_funs []) \\<Longrightarrow>\n    \\<forall>i<length [].\n       num_funs ([] ! i \\<cdot> \\<sigma>) = num_funs ([] ! i)\n 2. \\<And>a ts.\n       \\<lbrakk>sum_list\n                 (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n                   ts) =\n                sum_list (map num_funs ts) \\<Longrightarrow>\n                \\<forall>i<length ts.\n                   num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i);\n        sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n           (a # ts)) =\n        sum_list (map num_funs (a # ts))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ts).\n                            num_funs ((a # ts) ! i \\<cdot> \\<sigma>) =\n                            num_funs ((a # ts) ! i)", "moreover"], ["proof (state)\nthis:\n  num_funs t \\<le> num_funs (t \\<cdot> \\<sigma>)\n\ngoal (2 subgoals):\n 1. sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) []) =\n    sum_list (map num_funs []) \\<Longrightarrow>\n    \\<forall>i<length [].\n       num_funs ([] ! i \\<cdot> \\<sigma>) = num_funs ([] ! i)\n 2. \\<And>a ts.\n       \\<lbrakk>sum_list\n                 (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n                   ts) =\n                sum_list (map num_funs ts) \\<Longrightarrow>\n                \\<forall>i<length ts.\n                   num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i);\n        sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n           (a # ts)) =\n        sum_list (map num_funs (a # ts))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ts).\n                            num_funs ((a # ts) ! i \\<cdot> \\<sigma>) =\n                            num_funs ((a # ts) ! i)", "have \"sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) \\<ge> sum_list (map num_funs ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map num_funs ts)\n    \\<le> sum_list\n           (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)", "using num_funs_subst [of _ \\<sigma>]"], ["proof (prove)\nusing this:\n  num_funs ?t \\<le> num_funs (?t \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. sum_list (map num_funs ts)\n    \\<le> sum_list\n           (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)", "by (induct ts) (auto intro: add_mono)"], ["proof (state)\nthis:\n  sum_list (map num_funs ts)\n  \\<le> sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)\n\ngoal (2 subgoals):\n 1. sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) []) =\n    sum_list (map num_funs []) \\<Longrightarrow>\n    \\<forall>i<length [].\n       num_funs ([] ! i \\<cdot> \\<sigma>) = num_funs ([] ! i)\n 2. \\<And>a ts.\n       \\<lbrakk>sum_list\n                 (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n                   ts) =\n                sum_list (map num_funs ts) \\<Longrightarrow>\n                \\<forall>i<length ts.\n                   num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i);\n        sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>))\n           (a # ts)) =\n        sum_list (map num_funs (a # ts))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (a # ts).\n                            num_funs ((a # ts) ! i \\<cdot> \\<sigma>) =\n                            num_funs ((a # ts) ! i)", "ultimately"], ["proof (chain)\npicking this:\n  num_funs (t \\<cdot> \\<sigma>) +\n  sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n  num_funs t + sum_list (map num_funs ts)\n  num_funs t \\<le> num_funs (t \\<cdot> \\<sigma>)\n  sum_list (map num_funs ts)\n  \\<le> sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)", "show ?case"], ["proof (prove)\nusing this:\n  num_funs (t \\<cdot> \\<sigma>) +\n  sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n  num_funs t + sum_list (map num_funs ts)\n  num_funs t \\<le> num_funs (t \\<cdot> \\<sigma>)\n  sum_list (map num_funs ts)\n  \\<le> sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (t # ts).\n       num_funs ((t # ts) ! i \\<cdot> \\<sigma>) = num_funs ((t # ts) ! i)", "using Cons"], ["proof (prove)\nusing this:\n  num_funs (t \\<cdot> \\<sigma>) +\n  sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n  num_funs t + sum_list (map num_funs ts)\n  num_funs t \\<le> num_funs (t \\<cdot> \\<sigma>)\n  sum_list (map num_funs ts)\n  \\<le> sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)\n  sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts) =\n  sum_list (map num_funs ts) \\<Longrightarrow>\n  \\<forall>i<length ts.\n     num_funs (ts ! i \\<cdot> \\<sigma>) = num_funs (ts ! i)\n  sum_list\n   (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) (t # ts)) =\n  sum_list (map num_funs (t # ts))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (t # ts).\n       num_funs ((t # ts) ! i \\<cdot> \\<sigma>) = num_funs ((t # ts) ! i)", "by (auto) (case_tac i, auto)"], ["proof (state)\nthis:\n  \\<forall>i<length (t # ts).\n     num_funs ((t # ts) ! i \\<cdot> \\<sigma>) = num_funs ((t # ts) ! i)\n\ngoal (1 subgoal):\n 1. sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) []) =\n    sum_list (map num_funs []) \\<Longrightarrow>\n    \\<forall>i<length [].\n       num_funs ([] ! i \\<cdot> \\<sigma>) = num_funs ([] ! i)", "qed simp"], ["", "lemma is_Fun_num_funs_less:\n  assumes \"x \\<in> vars_term t\" and \"is_Fun t\"\n  shows \"num_funs (\\<sigma> x) < num_funs (t \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_funs (\\<sigma> x) < num_funs (t \\<cdot> \\<sigma>)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> vars_term t\n  is_Fun t\n\ngoal (1 subgoal):\n 1. num_funs (\\<sigma> x) < num_funs (t \\<cdot> \\<sigma>)", "proof (induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> vars_term (Var xa); is_Fun (Var xa)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Var xa \\<cdot> \\<sigma>)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; x \\<in> vars_term x2a;\n                    is_Fun x2a\\<rbrakk>\n                   \\<Longrightarrow> num_funs (\\<sigma> x)\n                                     < num_funs (x2a \\<cdot> \\<sigma>);\n        x \\<in> vars_term (Fun x1a x2); is_Fun (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Fun x1a x2 \\<cdot> \\<sigma>)", "case (Fun f ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set ts; x \\<in> vars_term ?x2a; is_Fun ?x2a\\<rbrakk>\n  \\<Longrightarrow> num_funs (\\<sigma> x) < num_funs (?x2a \\<cdot> \\<sigma>)\n  x \\<in> vars_term (Fun f ts)\n  is_Fun (Fun f ts)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> vars_term (Var xa); is_Fun (Var xa)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Var xa \\<cdot> \\<sigma>)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; x \\<in> vars_term x2a;\n                    is_Fun x2a\\<rbrakk>\n                   \\<Longrightarrow> num_funs (\\<sigma> x)\n                                     < num_funs (x2a \\<cdot> \\<sigma>);\n        x \\<in> vars_term (Fun x1a x2); is_Fun (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Fun x1a x2 \\<cdot> \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set ts; x \\<in> vars_term ?x2a; is_Fun ?x2a\\<rbrakk>\n  \\<Longrightarrow> num_funs (\\<sigma> x) < num_funs (?x2a \\<cdot> \\<sigma>)\n  x \\<in> vars_term (Fun f ts)\n  is_Fun (Fun f ts)", "obtain u where u: \"u \\<in> set ts\" \"x \\<in> vars_term u\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set ts; x \\<in> vars_term ?x2a; is_Fun ?x2a\\<rbrakk>\n  \\<Longrightarrow> num_funs (\\<sigma> x) < num_funs (?x2a \\<cdot> \\<sigma>)\n  x \\<in> vars_term (Fun f ts)\n  is_Fun (Fun f ts)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> set ts; x \\<in> vars_term u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> set ts\n  x \\<in> vars_term u\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> vars_term (Var xa); is_Fun (Var xa)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Var xa \\<cdot> \\<sigma>)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; x \\<in> vars_term x2a;\n                    is_Fun x2a\\<rbrakk>\n                   \\<Longrightarrow> num_funs (\\<sigma> x)\n                                     < num_funs (x2a \\<cdot> \\<sigma>);\n        x \\<in> vars_term (Fun x1a x2); is_Fun (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Fun x1a x2 \\<cdot> \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  u \\<in> set ts\n  x \\<in> vars_term u", "have \"num_funs (u \\<cdot> \\<sigma>) \\<le> sum_list (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)\""], ["proof (prove)\nusing this:\n  u \\<in> set ts\n  x \\<in> vars_term u\n\ngoal (1 subgoal):\n 1. num_funs (u \\<cdot> \\<sigma>)\n    \\<le> sum_list\n           (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)", "by (intro member_le_sum_list) simp"], ["proof (state)\nthis:\n  num_funs (u \\<cdot> \\<sigma>)\n  \\<le> sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> vars_term (Var xa); is_Fun (Var xa)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Var xa \\<cdot> \\<sigma>)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; x \\<in> vars_term x2a;\n                    is_Fun x2a\\<rbrakk>\n                   \\<Longrightarrow> num_funs (\\<sigma> x)\n                                     < num_funs (x2a \\<cdot> \\<sigma>);\n        x \\<in> vars_term (Fun x1a x2); is_Fun (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Fun x1a x2 \\<cdot> \\<sigma>)", "moreover"], ["proof (state)\nthis:\n  num_funs (u \\<cdot> \\<sigma>)\n  \\<le> sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> vars_term (Var xa); is_Fun (Var xa)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Var xa \\<cdot> \\<sigma>)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; x \\<in> vars_term x2a;\n                    is_Fun x2a\\<rbrakk>\n                   \\<Longrightarrow> num_funs (\\<sigma> x)\n                                     < num_funs (x2a \\<cdot> \\<sigma>);\n        x \\<in> vars_term (Fun x1a x2); is_Fun (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Fun x1a x2 \\<cdot> \\<sigma>)", "have \"num_funs (\\<sigma> x) \\<le> num_funs (u \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_funs (\\<sigma> x) \\<le> num_funs (u \\<cdot> \\<sigma>)", "using Fun.hyps [OF u] and u"], ["proof (prove)\nusing this:\n  is_Fun u \\<Longrightarrow>\n  num_funs (\\<sigma> x) < num_funs (u \\<cdot> \\<sigma>)\n  u \\<in> set ts\n  x \\<in> vars_term u\n\ngoal (1 subgoal):\n 1. num_funs (\\<sigma> x) \\<le> num_funs (u \\<cdot> \\<sigma>)", "by (cases u; simp)"], ["proof (state)\nthis:\n  num_funs (\\<sigma> x) \\<le> num_funs (u \\<cdot> \\<sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> vars_term (Var xa); is_Fun (Var xa)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Var xa \\<cdot> \\<sigma>)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; x \\<in> vars_term x2a;\n                    is_Fun x2a\\<rbrakk>\n                   \\<Longrightarrow> num_funs (\\<sigma> x)\n                                     < num_funs (x2a \\<cdot> \\<sigma>);\n        x \\<in> vars_term (Fun x1a x2); is_Fun (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Fun x1a x2 \\<cdot> \\<sigma>)", "ultimately"], ["proof (chain)\npicking this:\n  num_funs (u \\<cdot> \\<sigma>)\n  \\<le> sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)\n  num_funs (\\<sigma> x) \\<le> num_funs (u \\<cdot> \\<sigma>)", "show ?case"], ["proof (prove)\nusing this:\n  num_funs (u \\<cdot> \\<sigma>)\n  \\<le> sum_list\n         (map (num_funs \\<circ> (\\<lambda>t. t \\<cdot> \\<sigma>)) ts)\n  num_funs (\\<sigma> x) \\<le> num_funs (u \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. num_funs (\\<sigma> x) < num_funs (Fun f ts \\<cdot> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  num_funs (\\<sigma> x) < num_funs (Fun f ts \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> vars_term (Var xa); is_Fun (Var xa)\\<rbrakk>\n       \\<Longrightarrow> num_funs (\\<sigma> x)\n                         < num_funs (Var xa \\<cdot> \\<sigma>)", "qed simp"], ["", "lemma finite_subst_domain_subst:\n  \"finite (subst_domain (subst x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (subst_domain (subst x y))", "by simp"], ["", "lemma subst_domain_compose:\n  \"subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>) \\<subseteq> subst_domain \\<sigma> \\<union> subst_domain \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_domain (\\<sigma> \\<circ>\\<^sub>s \\<tau>)\n    \\<subseteq> subst_domain \\<sigma> \\<union> subst_domain \\<tau>", "by (auto simp: subst_domain_def subst_compose_def)"], ["", "lemma vars_term_disjoint_imp_unifier:\n  fixes \\<sigma> :: \"('f, 'v, 'w) gsubst\"\n  assumes \"vars_term s \\<inter> vars_term t = {}\"\n    and \"s \\<cdot> \\<sigma> = t \\<cdot> \\<tau>\"\n  shows \"\\<exists>\\<mu> :: ('f, 'v, 'w) gsubst. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<mu>. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<mu>. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>", "let ?\\<mu> = \"\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<mu>. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>", "have \"s \\<cdot> \\<sigma> = s \\<cdot> ?\\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<cdot> \\<sigma> =\n    s \\<cdot>\n    (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)", "unfolding term_subst_eq_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_term s.\n       \\<sigma> x = (if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)", "by (induct s) (simp_all)"], ["proof (state)\nthis:\n  s \\<cdot> \\<sigma> =\n  s \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<mu>. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>", "moreover"], ["proof (state)\nthis:\n  s \\<cdot> \\<sigma> =\n  s \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<mu>. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>", "have \"t \\<cdot> \\<tau> = t \\<cdot> ?\\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<cdot> \\<tau> =\n    t \\<cdot>\n    (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)", "using assms(1)"], ["proof (prove)\nusing this:\n  vars_term s \\<inter> vars_term t = {}\n\ngoal (1 subgoal):\n 1. t \\<cdot> \\<tau> =\n    t \\<cdot>\n    (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)", "unfolding term_subst_eq_conv"], ["proof (prove)\nusing this:\n  vars_term s \\<inter> vars_term t = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_term t.\n       \\<tau> x = (if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)", "by (induct s arbitrary: t) (auto)"], ["proof (state)\nthis:\n  t \\<cdot> \\<tau> =\n  t \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<mu>. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>", "ultimately"], ["proof (chain)\npicking this:\n  s \\<cdot> \\<sigma> =\n  s \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)\n  t \\<cdot> \\<tau> =\n  t \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)", "have \"s \\<cdot> ?\\<mu> = t \\<cdot> ?\\<mu>\""], ["proof (prove)\nusing this:\n  s \\<cdot> \\<sigma> =\n  s \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)\n  t \\<cdot> \\<tau> =\n  t \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)\n\ngoal (1 subgoal):\n 1. s \\<cdot>\n    (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x) =\n    t \\<cdot>\n    (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)", "using assms(2)"], ["proof (prove)\nusing this:\n  s \\<cdot> \\<sigma> =\n  s \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)\n  t \\<cdot> \\<tau> =\n  t \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)\n  s \\<cdot> \\<sigma> = t \\<cdot> \\<tau>\n\ngoal (1 subgoal):\n 1. s \\<cdot>\n    (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x) =\n    t \\<cdot>\n    (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)", "by simp"], ["proof (state)\nthis:\n  s \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x) =\n  t \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<mu>. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>", "then"], ["proof (chain)\npicking this:\n  s \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x) =\n  t \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x) =\n  t \\<cdot>\n  (\\<lambda>x. if x \\<in> vars_term s then \\<sigma> x else \\<tau> x)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<mu>. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<mu>. s \\<cdot> \\<mu> = t \\<cdot> \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_term_subset_subst_eq:\n  assumes \"vars_term t \\<subseteq> vars_term s\"\n    and \"s \\<cdot> \\<sigma> = s \\<cdot> \\<tau>\"\n  shows \"t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>", "using assms"], ["proof (prove)\nusing this:\n  vars_term t \\<subseteq> vars_term s\n  s \\<cdot> \\<sigma> = s \\<cdot> \\<tau>\n\ngoal (1 subgoal):\n 1. t \\<cdot> \\<sigma> = t \\<cdot> \\<tau>", "by (induct t) (induct s, auto)"], ["", "end"]]}