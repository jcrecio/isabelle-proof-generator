{"file_name": "/home/qj213/afp-2021-10-22/thys/Randomised_Social_Choice/Stochastic_Dominance.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Randomised_Social_Choice", "problem_names": ["lemma SD_empty [simp]: \"SD (\\<lambda>_ _. False) = (\\<lambda>_ _. False)\"", "lemma SD_refl: \"p \\<preceq>[SD(R)] p \\<longleftrightarrow> p \\<in> lotteries_on {x. R x x}\"", "lemma SD_trans [simp, trans]: \"p \\<preceq>[SD(R)] q \\<Longrightarrow> q \\<preceq>[SD(R)] r \\<Longrightarrow> p \\<preceq>[SD(R)] r\"", "lemma SD_is_preorder: \"preorder_on (lotteries_on {x. R x x}) (SD R)\"", "lemma SD_preorder:\n   \"p \\<succeq>[SD(le)] q \\<longleftrightarrow> p \\<in> lotteries_on carrier \\<and> q \\<in> lotteries_on carrier \\<and>\n      (\\<forall>x\\<in>carrier. measure_pmf.prob p (preferred_alts le x) \\<ge>\n                     measure_pmf.prob q (preferred_alts le x))\"", "lemma SD_preorderI [intro?]:\n  assumes \"p \\<in> lotteries_on carrier\" \"q \\<in> lotteries_on carrier\"\n  assumes \"\\<And>x. x \\<in> carrier \\<Longrightarrow>\n             measure_pmf.prob p (preferred_alts le x) \\<ge> measure_pmf.prob q (preferred_alts le x)\"\n  shows   \"p \\<succeq>[SD(le)] q\"", "lemma SD_preorderD:\n  assumes \"p \\<succeq>[SD(le)] q\"\n  shows   \"p \\<in> lotteries_on carrier\" \"q \\<in> lotteries_on carrier\"\n  and      \"\\<And>x. x \\<in> carrier \\<Longrightarrow>\n             measure_pmf.prob p (preferred_alts le x) \\<ge> measure_pmf.prob q (preferred_alts le x)\"", "lemma SD_refl' [simp]: \"p \\<preceq>[SD(le)] p \\<longleftrightarrow> p \\<in> lotteries_on carrier\"", "lemma SD_is_preorder': \"preorder_on (lotteries_on carrier) (SD(le))\"", "lemma SD_singleton_left:\n  assumes \"x \\<in> carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"return_pmf x \\<preceq>[SD(le)] q \\<longleftrightarrow> (\\<forall>y\\<in>set_pmf q. x \\<preceq>[le] y)\"", "lemma SD_singleton_right:\n  assumes x: \"x \\<in> carrier\" and q: \"q \\<in> lotteries_on carrier\"\n  shows   \"q \\<preceq>[SD(le)] return_pmf x \\<longleftrightarrow> (\\<forall>y\\<in>set_pmf q. y \\<preceq>[le] x)\"", "lemma SD_strict_singleton_left:\n  assumes \"x \\<in> carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"return_pmf x \\<prec>[SD(le)] q \\<longleftrightarrow> (\\<forall>y\\<in>set_pmf q. x \\<preceq>[le] y) \\<and> (\\<exists>y\\<in>set_pmf q. (x \\<prec>[le] y))\"", "lemma SD_strict_singleton_right:\n  assumes \"x \\<in> carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"q \\<prec>[SD(le)] return_pmf x \\<longleftrightarrow> (\\<forall>y\\<in>set_pmf q. y \\<preceq>[le] x) \\<and> (\\<exists>y\\<in>set_pmf q. (y \\<prec>[le] x))\"", "lemma SD_singleton [simp]:\n  \"x \\<in> carrier \\<Longrightarrow> y \\<in> carrier \\<Longrightarrow> return_pmf x \\<preceq>[SD(le)] return_pmf y \\<longleftrightarrow> x \\<preceq>[le] y\"", "lemma SD_strict_singleton [simp]:\n  \"x \\<in> carrier \\<Longrightarrow> y \\<in> carrier \\<Longrightarrow> return_pmf x \\<prec>[SD(le)] return_pmf y \\<longleftrightarrow> x \\<prec>[le] y\"", "lemmas SD_singleton_left = Ri.SD_singleton_left", "lemmas SD_singleton_right = Ri.SD_singleton_right", "lemmas SD_strict_singleton_left = Ri.SD_strict_singleton_left", "lemmas SD_strict_singleton_right = Ri.SD_strict_singleton_right", "lemmas SD_singleton = Ri.SD_singleton", "lemmas SD_strict_singleton = Ri.SD_strict_singleton", "lemmas (in pref_profile_wf) [simp] = SD_singleton SD_strict_singleton", "lemma SD_pref_profile:\n  assumes \"i \\<in> agents\"\n  shows   \"p \\<succeq>[SD(R i)] q \\<longleftrightarrow> p \\<in> lotteries_on alts \\<and> q \\<in> lotteries_on alts \\<and>\n             (\\<forall>x\\<in>alts. measure_pmf.prob p (preferred_alts (R i) x) \\<ge>\n                         measure_pmf.prob q (preferred_alts (R i) x))\"", "lemma SD_pref_profileI [intro?]:\n  assumes \"i \\<in> agents\" \"p \\<in> lotteries_on alts\" \"q \\<in> lotteries_on alts\"\n  assumes \"\\<And>x. x \\<in> alts \\<Longrightarrow>\n             measure_pmf.prob p (preferred_alts (R i) x) \\<ge>\n             measure_pmf.prob q (preferred_alts (R i) x)\"\n  shows   \"p \\<succeq>[SD(R i)] q\"", "lemma SD_pref_profileD:\n  assumes \"i \\<in> agents\" \"p \\<succeq>[SD(R i)] q\"\n  shows   \"p \\<in> lotteries_on alts\" \"q \\<in> lotteries_on alts\"\n  and     \"\\<And>x. x \\<in> alts \\<Longrightarrow>\n             measure_pmf.prob p (preferred_alts (R i) x) \\<ge>\n             measure_pmf.prob q (preferred_alts (R i) x)\"", "lemma SD_efficient_def:\n  \"SD_efficient R p \\<longleftrightarrow> \\<not>(\\<exists>q\\<in>lotteries_on alts. q \\<succ>[Pareto (SD \\<circ> R)] p)\"", "lemma SD_efficient_def':\n  \"SD_efficient R p \\<longleftrightarrow>\n     \\<not>(\\<exists>q\\<in>lotteries_on alts. (\\<forall>i\\<in>agents. q \\<succeq>[SD(R i)] p) \\<and> (\\<exists>i\\<in>agents. q \\<succ>[SD(R i)] p))\"", "lemma SD_inefficientI:\n  assumes \"q \\<in> lotteries_on alts\" \"\\<And>i. i \\<in> agents \\<Longrightarrow> q \\<succeq>[SD(R i)] p\"\n          \"i \\<in> agents\" \"q \\<succ>[SD(R i)] p\"\n  shows   \"\\<not>SD_efficient R p\"", "lemma SD_inefficientI':\n  assumes \"q \\<in> lotteries_on alts\" \"\\<And>i. i \\<in> agents \\<Longrightarrow> q \\<succeq>[SD(R i)] p\"\n          \"\\<exists>i \\<in> agents. q \\<succ>[SD(R i)] p\"\n  shows   \"\\<not>SD_efficient R p\"", "lemma SD_inefficientE:\n  assumes \"\\<not>SD_efficient R p\"\n  obtains q i where\n    \"q \\<in> lotteries_on alts\" \"\\<And>i. i \\<in> agents \\<Longrightarrow> q \\<succeq>[SD(R i)] p\"\n    \"i \\<in> agents\" \"q \\<succ>[SD(R i)] p\"", "lemma SD_efficientD:\n  assumes \"SD_efficient R p\" \"q \\<in> lotteries_on alts\"\n      and \"\\<And>i. i \\<in> agents \\<Longrightarrow> q \\<succeq>[SD(R i)] p\" \"\\<exists>i\\<in>agents. \\<not>(q \\<preceq>[SD(R i)] p)\"\n  shows False", "lemma SD_efficient_singleton_iff:\n  assumes [simp]: \"x \\<in> alts\"\n  shows   \"SD_efficient R (return_pmf x) \\<longleftrightarrow> x \\<notin> pareto_losers R\"", "lemma utility_weak_ranking_index:\n  \"is_vnm_utility (\\<lambda>x. real (length (weak_ranking le) - weak_ranking_index x))\"", "lemma SD_iff_expected_utilities_le:\n  assumes \"p \\<in> lotteries_on carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"p \\<preceq>[SD(le)] q \\<longleftrightarrow>\n             (\\<forall>u. is_vnm_utility u \\<longrightarrow> measure_pmf.expectation p u \\<le> measure_pmf.expectation q u)\"", "lemma not_strict_SD_iff:\n  assumes \"p \\<in> lotteries_on carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"\\<not>(p \\<prec>[SD(le)] q) \\<longleftrightarrow>\n             (\\<exists>u. is_vnm_utility u \\<and> measure_pmf.expectation q u \\<le> measure_pmf.expectation p u)\"", "lemma strict_SD_iff:\n  assumes \"p \\<in> lotteries_on carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"(p \\<prec>[SD(le)] q) \\<longleftrightarrow>\n             (\\<forall>u. is_vnm_utility u \\<longrightarrow> measure_pmf.expectation p u < measure_pmf.expectation q u)\""], "translations": [["", "lemma SD_empty [simp]: \"SD (\\<lambda>_ _. False) = (\\<lambda>_ _. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD (\\<lambda>_ _. False) = (\\<lambda>_ _. False)", "by (auto simp: fun_eq_iff SD_def lotteries_on_def set_pmf_not_empty)"], ["", "text \\<open>\n  Stochastic dominance over any relation is a preorder.\n\\<close>"], ["", "lemma SD_refl: \"p \\<preceq>[SD(R)] p \\<longleftrightarrow> p \\<in> lotteries_on {x. R x x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD R p p = (p \\<in> lotteries_on {x. R x x})", "by (simp add: SD_def)"], ["", "lemma SD_trans [simp, trans]: \"p \\<preceq>[SD(R)] q \\<Longrightarrow> q \\<preceq>[SD(R)] r \\<Longrightarrow> p \\<preceq>[SD(R)] r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SD R p q; SD R q r\\<rbrakk> \\<Longrightarrow> SD R p r", "unfolding SD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> lotteries_on {x. R x x} \\<and>\n             p \\<in> lotteries_on {x. R x x} \\<and>\n             (\\<forall>x.\n                 R x x \\<longrightarrow>\n                 measure_pmf.prob p (Collect (R x))\n                 \\<le> measure_pmf.prob q (Collect (R x)));\n     r \\<in> lotteries_on {x. R x x} \\<and>\n     q \\<in> lotteries_on {x. R x x} \\<and>\n     (\\<forall>x.\n         R x x \\<longrightarrow>\n         measure_pmf.prob q (Collect (R x))\n         \\<le> measure_pmf.prob r (Collect (R x)))\\<rbrakk>\n    \\<Longrightarrow> r \\<in> lotteries_on {x. R x x} \\<and>\n                      p \\<in> lotteries_on {x. R x x} \\<and>\n                      (\\<forall>x.\n                          R x x \\<longrightarrow>\n                          measure_pmf.prob p (Collect (R x))\n                          \\<le> measure_pmf.prob r (Collect (R x)))", "by (auto intro: order.trans)"], ["", "lemma SD_is_preorder: \"preorder_on (lotteries_on {x. R x x}) (SD R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Order_Predicates.preorder_on (lotteries_on {x. R x x}) (SD R)", "by unfold_locales (auto simp: SD_def intro: order.trans)"], ["", "context preorder_on\nbegin"], ["", "lemma SD_preorder:\n   \"p \\<succeq>[SD(le)] q \\<longleftrightarrow> p \\<in> lotteries_on carrier \\<and> q \\<in> lotteries_on carrier \\<and>\n      (\\<forall>x\\<in>carrier. measure_pmf.prob p (preferred_alts le x) \\<ge>\n                     measure_pmf.prob q (preferred_alts le x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD le q p =\n    (p \\<in> lotteries_on carrier \\<and>\n     q \\<in> lotteries_on carrier \\<and>\n     (\\<forall>x\\<in>carrier.\n         measure_pmf.prob q (preferred_alts le x)\n         \\<le> measure_pmf.prob p (preferred_alts le x)))", "by (simp add: SD_def preferred_alts_def carrier_eq)"], ["", "lemma SD_preorderI [intro?]:\n  assumes \"p \\<in> lotteries_on carrier\" \"q \\<in> lotteries_on carrier\"\n  assumes \"\\<And>x. x \\<in> carrier \\<Longrightarrow>\n             measure_pmf.prob p (preferred_alts le x) \\<ge> measure_pmf.prob q (preferred_alts le x)\"\n  shows   \"p \\<succeq>[SD(le)] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD le q p", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  ?x \\<in> carrier \\<Longrightarrow>\n  measure_pmf.prob q (preferred_alts le ?x)\n  \\<le> measure_pmf.prob p (preferred_alts le ?x)\n\ngoal (1 subgoal):\n 1. SD le q p", "by (simp add: SD_preorder)"], ["", "lemma SD_preorderD:\n  assumes \"p \\<succeq>[SD(le)] q\"\n  shows   \"p \\<in> lotteries_on carrier\" \"q \\<in> lotteries_on carrier\"\n  and      \"\\<And>x. x \\<in> carrier \\<Longrightarrow>\n             measure_pmf.prob p (preferred_alts le x) \\<ge> measure_pmf.prob q (preferred_alts le x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<in> lotteries_on carrier &&& q \\<in> lotteries_on carrier) &&&\n    (\\<And>x.\n        x \\<in> carrier \\<Longrightarrow>\n        measure_pmf.prob q (preferred_alts le x)\n        \\<le> measure_pmf.prob p (preferred_alts le x))", "using assms"], ["proof (prove)\nusing this:\n  SD le q p\n\ngoal (1 subgoal):\n 1. (p \\<in> lotteries_on carrier &&& q \\<in> lotteries_on carrier) &&&\n    (\\<And>x.\n        x \\<in> carrier \\<Longrightarrow>\n        measure_pmf.prob q (preferred_alts le x)\n        \\<le> measure_pmf.prob p (preferred_alts le x))", "unfolding SD_preorder"], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier \\<and>\n  q \\<in> lotteries_on carrier \\<and>\n  (\\<forall>x\\<in>carrier.\n      measure_pmf.prob q (preferred_alts le x)\n      \\<le> measure_pmf.prob p (preferred_alts le x))\n\ngoal (1 subgoal):\n 1. (p \\<in> lotteries_on carrier &&& q \\<in> lotteries_on carrier) &&&\n    (\\<And>x.\n        x \\<in> carrier \\<Longrightarrow>\n        measure_pmf.prob q (preferred_alts le x)\n        \\<le> measure_pmf.prob p (preferred_alts le x))", "by simp_all"], ["", "lemma SD_refl' [simp]: \"p \\<preceq>[SD(le)] p \\<longleftrightarrow> p \\<in> lotteries_on carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD le p p = (p \\<in> lotteries_on carrier)", "by (simp add: SD_def carrier_eq)"], ["", "lemma SD_is_preorder': \"preorder_on (lotteries_on carrier) (SD(le))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Order_Predicates.preorder_on (lotteries_on carrier) (SD le)", "using SD_is_preorder[of le]"], ["proof (prove)\nusing this:\n  Order_Predicates.preorder_on (lotteries_on {x. le x x}) (SD le)\n\ngoal (1 subgoal):\n 1. Order_Predicates.preorder_on (lotteries_on carrier) (SD le)", "by (simp add: carrier_eq)"], ["", "lemma SD_singleton_left:\n  assumes \"x \\<in> carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"return_pmf x \\<preceq>[SD(le)] q \\<longleftrightarrow> (\\<forall>y\\<in>set_pmf q. x \\<preceq>[le] y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD le (return_pmf x) q = (\\<forall>y\\<in>set_pmf q. le x y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. SD le (return_pmf x) q \\<Longrightarrow>\n    \\<forall>y\\<in>set_pmf q. le x y\n 2. \\<forall>y\\<in>set_pmf q. le x y \\<Longrightarrow>\n    SD le (return_pmf x) q", "assume SD: \"return_pmf x \\<preceq>[SD(le)] q\""], ["proof (state)\nthis:\n  SD le (return_pmf x) q\n\ngoal (2 subgoals):\n 1. SD le (return_pmf x) q \\<Longrightarrow>\n    \\<forall>y\\<in>set_pmf q. le x y\n 2. \\<forall>y\\<in>set_pmf q. le x y \\<Longrightarrow>\n    SD le (return_pmf x) q", "from assms SD_preorderD(3)[OF SD, of x]"], ["proof (chain)\npicking this:\n  x \\<in> carrier\n  q \\<in> lotteries_on carrier\n  x \\<in> carrier \\<Longrightarrow>\n  measure_pmf.prob (return_pmf x) (preferred_alts le x)\n  \\<le> measure_pmf.prob q (preferred_alts le x)", "have \"measure_pmf.prob (return_pmf x) (preferred_alts le x) \\<le>\n            measure_pmf.prob q (preferred_alts le x)\""], ["proof (prove)\nusing this:\n  x \\<in> carrier\n  q \\<in> lotteries_on carrier\n  x \\<in> carrier \\<Longrightarrow>\n  measure_pmf.prob (return_pmf x) (preferred_alts le x)\n  \\<le> measure_pmf.prob q (preferred_alts le x)\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (return_pmf x) (preferred_alts le x)\n    \\<le> measure_pmf.prob q (preferred_alts le x)", "by simp"], ["proof (state)\nthis:\n  measure_pmf.prob (return_pmf x) (preferred_alts le x)\n  \\<le> measure_pmf.prob q (preferred_alts le x)\n\ngoal (2 subgoals):\n 1. SD le (return_pmf x) q \\<Longrightarrow>\n    \\<forall>y\\<in>set_pmf q. le x y\n 2. \\<forall>y\\<in>set_pmf q. le x y \\<Longrightarrow>\n    SD le (return_pmf x) q", "also"], ["proof (state)\nthis:\n  measure_pmf.prob (return_pmf x) (preferred_alts le x)\n  \\<le> measure_pmf.prob q (preferred_alts le x)\n\ngoal (2 subgoals):\n 1. SD le (return_pmf x) q \\<Longrightarrow>\n    \\<forall>y\\<in>set_pmf q. le x y\n 2. \\<forall>y\\<in>set_pmf q. le x y \\<Longrightarrow>\n    SD le (return_pmf x) q", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> carrier\n  q \\<in> lotteries_on carrier", "have \"measure_pmf.prob (return_pmf x) (preferred_alts le x) = 1\""], ["proof (prove)\nusing this:\n  x \\<in> carrier\n  q \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (return_pmf x) (preferred_alts le x) = 1", "by (simp add: indicator_def)"], ["proof (state)\nthis:\n  measure_pmf.prob (return_pmf x) (preferred_alts le x) = 1\n\ngoal (2 subgoals):\n 1. SD le (return_pmf x) q \\<Longrightarrow>\n    \\<forall>y\\<in>set_pmf q. le x y\n 2. \\<forall>y\\<in>set_pmf q. le x y \\<Longrightarrow>\n    SD le (return_pmf x) q", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> measure_pmf.prob q (preferred_alts le x)", "have \"AE y in q. y \\<succeq>[le] x\""], ["proof (prove)\nusing this:\n  1 \\<le> measure_pmf.prob q (preferred_alts le x)\n\ngoal (1 subgoal):\n 1. almost_everywhere (measure_pmf q) (le x)", "by (simp add: measure_pmf.measure_ge_1_iff measure_pmf.prob_eq_1 preferred_alts_def)"], ["proof (state)\nthis:\n  almost_everywhere (measure_pmf q) (le x)\n\ngoal (2 subgoals):\n 1. SD le (return_pmf x) q \\<Longrightarrow>\n    \\<forall>y\\<in>set_pmf q. le x y\n 2. \\<forall>y\\<in>set_pmf q. le x y \\<Longrightarrow>\n    SD le (return_pmf x) q", "thus \"\\<forall>y\\<in>set_pmf q. y \\<succeq>[le] x\""], ["proof (prove)\nusing this:\n  almost_everywhere (measure_pmf q) (le x)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set_pmf q. le x y", "by (simp add: AE_measure_pmf_iff)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set_pmf q. le x y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set_pmf q. le x y \\<Longrightarrow>\n    SD le (return_pmf x) q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set_pmf q. le x y \\<Longrightarrow>\n    SD le (return_pmf x) q", "assume A: \"\\<forall>y\\<in>set_pmf q. x \\<preceq>[le] y\""], ["proof (state)\nthis:\n  \\<forall>y\\<in>set_pmf q. le x y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set_pmf q. le x y \\<Longrightarrow>\n    SD le (return_pmf x) q", "show \"return_pmf x \\<preceq>[SD(le)] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD le (return_pmf x) q", "proof (rule SD_preorderI)"], ["proof (state)\ngoal (3 subgoals):\n 1. q \\<in> lotteries_on carrier\n 2. return_pmf x \\<in> lotteries_on carrier\n 3. \\<And>xa.\n       xa \\<in> carrier \\<Longrightarrow>\n       measure_pmf.prob (return_pmf x) (preferred_alts le xa)\n       \\<le> measure_pmf.prob q (preferred_alts le xa)", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. q \\<in> lotteries_on carrier\n 2. return_pmf x \\<in> lotteries_on carrier\n 3. \\<And>xa.\n       xa \\<in> carrier \\<Longrightarrow>\n       measure_pmf.prob (return_pmf x) (preferred_alts le xa)\n       \\<le> measure_pmf.prob q (preferred_alts le xa)", "assume y: \"y \\<in> carrier\""], ["proof (state)\nthis:\n  y \\<in> carrier\n\ngoal (3 subgoals):\n 1. q \\<in> lotteries_on carrier\n 2. return_pmf x \\<in> lotteries_on carrier\n 3. \\<And>xa.\n       xa \\<in> carrier \\<Longrightarrow>\n       measure_pmf.prob (return_pmf x) (preferred_alts le xa)\n       \\<le> measure_pmf.prob q (preferred_alts le xa)", "show \"measure_pmf.prob (return_pmf x) (preferred_alts le y)\n              \\<le> measure_pmf.prob q (preferred_alts le y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob (return_pmf x) (preferred_alts le y)\n    \\<le> measure_pmf.prob q (preferred_alts le y)", "proof (cases \"y \\<preceq>[le] x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. le y x \\<Longrightarrow>\n    measure_pmf.prob (return_pmf x) (preferred_alts le y)\n    \\<le> measure_pmf.prob q (preferred_alts le y)\n 2. \\<not> le y x \\<Longrightarrow>\n    measure_pmf.prob (return_pmf x) (preferred_alts le y)\n    \\<le> measure_pmf.prob q (preferred_alts le y)", "case True"], ["proof (state)\nthis:\n  le y x\n\ngoal (2 subgoals):\n 1. le y x \\<Longrightarrow>\n    measure_pmf.prob (return_pmf x) (preferred_alts le y)\n    \\<le> measure_pmf.prob q (preferred_alts le y)\n 2. \\<not> le y x \\<Longrightarrow>\n    measure_pmf.prob (return_pmf x) (preferred_alts le y)\n    \\<le> measure_pmf.prob q (preferred_alts le y)", "from True A"], ["proof (chain)\npicking this:\n  le y x\n  \\<forall>y\\<in>set_pmf q. le x y", "have \"measure_pmf.prob q (preferred_alts le y) = 1\""], ["proof (prove)\nusing this:\n  le y x\n  \\<forall>y\\<in>set_pmf q. le x y\n\ngoal (1 subgoal):\n 1. measure_pmf.prob q (preferred_alts le y) = 1", "by (auto simp: AE_measure_pmf_iff measure_pmf.prob_eq_1 preferred_alts_def intro: trans)"], ["proof (state)\nthis:\n  measure_pmf.prob q (preferred_alts le y) = 1\n\ngoal (2 subgoals):\n 1. le y x \\<Longrightarrow>\n    measure_pmf.prob (return_pmf x) (preferred_alts le y)\n    \\<le> measure_pmf.prob q (preferred_alts le y)\n 2. \\<not> le y x \\<Longrightarrow>\n    measure_pmf.prob (return_pmf x) (preferred_alts le y)\n    \\<le> measure_pmf.prob q (preferred_alts le y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.prob q (preferred_alts le y) = 1\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (return_pmf x) (preferred_alts le y)\n    \\<le> measure_pmf.prob q (preferred_alts le y)", "by simp"], ["proof (state)\nthis:\n  measure_pmf.prob (return_pmf x) (preferred_alts le y)\n  \\<le> measure_pmf.prob q (preferred_alts le y)\n\ngoal (1 subgoal):\n 1. \\<not> le y x \\<Longrightarrow>\n    measure_pmf.prob (return_pmf x) (preferred_alts le y)\n    \\<le> measure_pmf.prob q (preferred_alts le y)", "qed (simp_all add: preferred_alts_def indicator_def measure_nonneg)"], ["proof (state)\nthis:\n  measure_pmf.prob (return_pmf x) (preferred_alts le y)\n  \\<le> measure_pmf.prob q (preferred_alts le y)\n\ngoal (2 subgoals):\n 1. q \\<in> lotteries_on carrier\n 2. return_pmf x \\<in> lotteries_on carrier", "qed (insert assms, simp_all add: lotteries_on_def)"], ["proof (state)\nthis:\n  SD le (return_pmf x) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SD_singleton_right:\n  assumes x: \"x \\<in> carrier\" and q: \"q \\<in> lotteries_on carrier\"\n  shows   \"q \\<preceq>[SD(le)] return_pmf x \\<longleftrightarrow> (\\<forall>y\\<in>set_pmf q. y \\<preceq>[le] x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD le q (return_pmf x) = (\\<forall>y\\<in>set_pmf q. le y x)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>SD le q (return_pmf x); y \\<in> set_pmf q\\<rbrakk>\n       \\<Longrightarrow> le y x\n 2. \\<forall>y\\<in>set_pmf q. le y x \\<Longrightarrow>\n    SD le q (return_pmf x)", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>SD le q (return_pmf x); y \\<in> set_pmf q\\<rbrakk>\n       \\<Longrightarrow> le y x\n 2. \\<forall>y\\<in>set_pmf q. le y x \\<Longrightarrow>\n    SD le q (return_pmf x)", "assume SD: \"q \\<preceq>[SD(le)] return_pmf x\" and y: \"y \\<in> set_pmf q\""], ["proof (state)\nthis:\n  SD le q (return_pmf x)\n  y \\<in> set_pmf q\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>SD le q (return_pmf x); y \\<in> set_pmf q\\<rbrakk>\n       \\<Longrightarrow> le y x\n 2. \\<forall>y\\<in>set_pmf q. le y x \\<Longrightarrow>\n    SD le q (return_pmf x)", "from y assms"], ["proof (chain)\npicking this:\n  y \\<in> set_pmf q\n  x \\<in> carrier\n  q \\<in> lotteries_on carrier", "have [simp]: \"y \\<in> carrier\""], ["proof (prove)\nusing this:\n  y \\<in> set_pmf q\n  x \\<in> carrier\n  q \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. y \\<in> carrier", "by (auto simp: lotteries_on_def)"], ["proof (state)\nthis:\n  y \\<in> carrier\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>SD le q (return_pmf x); y \\<in> set_pmf q\\<rbrakk>\n       \\<Longrightarrow> le y x\n 2. \\<forall>y\\<in>set_pmf q. le y x \\<Longrightarrow>\n    SD le q (return_pmf x)", "from y"], ["proof (chain)\npicking this:\n  y \\<in> set_pmf q", "have \"0 < measure_pmf.prob q (preferred_alts le y)\""], ["proof (prove)\nusing this:\n  y \\<in> set_pmf q\n\ngoal (1 subgoal):\n 1. 0 < measure_pmf.prob q (preferred_alts le y)", "by (rule measure_pmf_posI) simp_all"], ["proof (state)\nthis:\n  0 < measure_pmf.prob q (preferred_alts le y)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>SD le q (return_pmf x); y \\<in> set_pmf q\\<rbrakk>\n       \\<Longrightarrow> le y x\n 2. \\<forall>y\\<in>set_pmf q. le y x \\<Longrightarrow>\n    SD le q (return_pmf x)", "also"], ["proof (state)\nthis:\n  0 < measure_pmf.prob q (preferred_alts le y)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>SD le q (return_pmf x); y \\<in> set_pmf q\\<rbrakk>\n       \\<Longrightarrow> le y x\n 2. \\<forall>y\\<in>set_pmf q. le y x \\<Longrightarrow>\n    SD le q (return_pmf x)", "have \"\\<dots> \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob q (preferred_alts le y)\n    \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)", "by (rule SD_preorderD(3)[OF SD]) simp_all"], ["proof (state)\nthis:\n  measure_pmf.prob q (preferred_alts le y)\n  \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>SD le q (return_pmf x); y \\<in> set_pmf q\\<rbrakk>\n       \\<Longrightarrow> le y x\n 2. \\<forall>y\\<in>set_pmf q. le y x \\<Longrightarrow>\n    SD le q (return_pmf x)", "finally"], ["proof (chain)\npicking this:\n  0 < measure_pmf.prob (return_pmf x) (preferred_alts le y)", "show \"y \\<preceq>[le] x\""], ["proof (prove)\nusing this:\n  0 < measure_pmf.prob (return_pmf x) (preferred_alts le y)\n\ngoal (1 subgoal):\n 1. le y x", "by (auto simp: indicator_def preferred_alts_def split: if_splits)"], ["proof (state)\nthis:\n  le y x\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set_pmf q. le y x \\<Longrightarrow>\n    SD le q (return_pmf x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set_pmf q. le y x \\<Longrightarrow>\n    SD le q (return_pmf x)", "assume A: \"\\<forall>y\\<in>set_pmf q. y \\<preceq>[le] x\""], ["proof (state)\nthis:\n  \\<forall>y\\<in>set_pmf q. le y x\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set_pmf q. le y x \\<Longrightarrow>\n    SD le q (return_pmf x)", "show \"q \\<preceq>[SD(le)] return_pmf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD le q (return_pmf x)", "proof (rule SD_preorderI)"], ["proof (state)\ngoal (3 subgoals):\n 1. return_pmf x \\<in> lotteries_on carrier\n 2. q \\<in> lotteries_on carrier\n 3. \\<And>xa.\n       xa \\<in> carrier \\<Longrightarrow>\n       measure_pmf.prob q (preferred_alts le xa)\n       \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le xa)", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. return_pmf x \\<in> lotteries_on carrier\n 2. q \\<in> lotteries_on carrier\n 3. \\<And>xa.\n       xa \\<in> carrier \\<Longrightarrow>\n       measure_pmf.prob q (preferred_alts le xa)\n       \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le xa)", "assume y: \"y \\<in> carrier\""], ["proof (state)\nthis:\n  y \\<in> carrier\n\ngoal (3 subgoals):\n 1. return_pmf x \\<in> lotteries_on carrier\n 2. q \\<in> lotteries_on carrier\n 3. \\<And>xa.\n       xa \\<in> carrier \\<Longrightarrow>\n       measure_pmf.prob q (preferred_alts le xa)\n       \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le xa)", "show \"measure_pmf.prob q (preferred_alts le y) \\<le>\n            measure_pmf.prob (return_pmf x) (preferred_alts le y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob q (preferred_alts le y)\n    \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)", "proof (cases \"y \\<preceq>[le] x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. le y x \\<Longrightarrow>\n    measure_pmf.prob q (preferred_alts le y)\n    \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)\n 2. \\<not> le y x \\<Longrightarrow>\n    measure_pmf.prob q (preferred_alts le y)\n    \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)", "case False"], ["proof (state)\nthis:\n  \\<not> le y x\n\ngoal (2 subgoals):\n 1. le y x \\<Longrightarrow>\n    measure_pmf.prob q (preferred_alts le y)\n    \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)\n 2. \\<not> le y x \\<Longrightarrow>\n    measure_pmf.prob q (preferred_alts le y)\n    \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)", "with A"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set_pmf q. le y x\n  \\<not> le y x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set_pmf q. le y x\n  \\<not> le y x\n\ngoal (1 subgoal):\n 1. measure_pmf.prob q (preferred_alts le y)\n    \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)", "by (auto simp: preferred_alts_def indicator_def measure_le_0_iff\n                       measure_pmf.prob_eq_0 AE_measure_pmf_iff intro: trans)"], ["proof (state)\nthis:\n  measure_pmf.prob q (preferred_alts le y)\n  \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)\n\ngoal (1 subgoal):\n 1. le y x \\<Longrightarrow>\n    measure_pmf.prob q (preferred_alts le y)\n    \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)", "qed (simp_all add: indicator_def preferred_alts_def)"], ["proof (state)\nthis:\n  measure_pmf.prob q (preferred_alts le y)\n  \\<le> measure_pmf.prob (return_pmf x) (preferred_alts le y)\n\ngoal (2 subgoals):\n 1. return_pmf x \\<in> lotteries_on carrier\n 2. q \\<in> lotteries_on carrier", "qed (insert assms, simp_all add: lotteries_on_def)"], ["proof (state)\nthis:\n  SD le q (return_pmf x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SD_strict_singleton_left:\n  assumes \"x \\<in> carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"return_pmf x \\<prec>[SD(le)] q \\<longleftrightarrow> (\\<forall>y\\<in>set_pmf q. x \\<preceq>[le] y) \\<and> (\\<exists>y\\<in>set_pmf q. (x \\<prec>[le] y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf x \\<prec>[SD le] q =\n    ((\\<forall>y\\<in>set_pmf q. le x y) \\<and>\n     (\\<exists>y\\<in>set_pmf q. x \\<prec>[le] y))", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> carrier\n  q \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. return_pmf x \\<prec>[SD le] q =\n    ((\\<forall>y\\<in>set_pmf q. le x y) \\<and>\n     (\\<exists>y\\<in>set_pmf q. x \\<prec>[le] y))", "by (auto simp add: strongly_preferred_def SD_singleton_left SD_singleton_right)"], ["", "lemma SD_strict_singleton_right:\n  assumes \"x \\<in> carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"q \\<prec>[SD(le)] return_pmf x \\<longleftrightarrow> (\\<forall>y\\<in>set_pmf q. y \\<preceq>[le] x) \\<and> (\\<exists>y\\<in>set_pmf q. (y \\<prec>[le] x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<prec>[SD le] return_pmf x =\n    ((\\<forall>y\\<in>set_pmf q. le y x) \\<and>\n     (\\<exists>y\\<in>set_pmf q. y \\<prec>[le] x))", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> carrier\n  q \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. q \\<prec>[SD le] return_pmf x =\n    ((\\<forall>y\\<in>set_pmf q. le y x) \\<and>\n     (\\<exists>y\\<in>set_pmf q. y \\<prec>[le] x))", "by (auto simp add: strongly_preferred_def SD_singleton_left SD_singleton_right)"], ["", "lemma SD_singleton [simp]:\n  \"x \\<in> carrier \\<Longrightarrow> y \\<in> carrier \\<Longrightarrow> return_pmf x \\<preceq>[SD(le)] return_pmf y \\<longleftrightarrow> x \\<preceq>[le] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n    \\<Longrightarrow> SD le (return_pmf x) (return_pmf y) = le x y", "by (subst SD_singleton_left) (simp_all add: lotteries_on_def)"], ["", "lemma SD_strict_singleton [simp]:\n  \"x \\<in> carrier \\<Longrightarrow> y \\<in> carrier \\<Longrightarrow> return_pmf x \\<prec>[SD(le)] return_pmf y \\<longleftrightarrow> x \\<prec>[le] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n    \\<Longrightarrow> return_pmf x \\<prec>[SD le] return_pmf y =\n                      x \\<prec>[le] y", "by (simp add: strongly_preferred_def)"], ["", "end"], ["", "context pref_profile_wf\nbegin"], ["", "context\nfixes i assumes i: \"i \\<in> agents\"\nbegin"], ["", "interpretation Ri: preorder_on alts \"R i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Order_Predicates.preorder_on alts (R i)", "by (simp add: i)"], ["", "lemmas SD_singleton_left = Ri.SD_singleton_left"], ["", "lemmas SD_singleton_right = Ri.SD_singleton_right"], ["", "lemmas SD_strict_singleton_left = Ri.SD_strict_singleton_left"], ["", "lemmas SD_strict_singleton_right = Ri.SD_strict_singleton_right"], ["", "lemmas SD_singleton = Ri.SD_singleton"], ["", "lemmas SD_strict_singleton = Ri.SD_strict_singleton"], ["", "end"], ["", "end"], ["", "lemmas (in pref_profile_wf) [simp] = SD_singleton SD_strict_singleton"], ["", "subsection \\<open>Stochastic Dominance for preference profiles\\<close>"], ["", "context pref_profile_wf\nbegin"], ["", "lemma SD_pref_profile:\n  assumes \"i \\<in> agents\"\n  shows   \"p \\<succeq>[SD(R i)] q \\<longleftrightarrow> p \\<in> lotteries_on alts \\<and> q \\<in> lotteries_on alts \\<and>\n             (\\<forall>x\\<in>alts. measure_pmf.prob p (preferred_alts (R i) x) \\<ge>\n                         measure_pmf.prob q (preferred_alts (R i) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD (R i) q p =\n    (p \\<in> lotteries_on alts \\<and>\n     q \\<in> lotteries_on alts \\<and>\n     (\\<forall>x\\<in>alts.\n         measure_pmf.prob q (preferred_alts (R i) x)\n         \\<le> measure_pmf.prob p (preferred_alts (R i) x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SD (R i) q p =\n    (p \\<in> lotteries_on alts \\<and>\n     q \\<in> lotteries_on alts \\<and>\n     (\\<forall>x\\<in>alts.\n         measure_pmf.prob q (preferred_alts (R i) x)\n         \\<le> measure_pmf.prob p (preferred_alts (R i) x)))", "from assms"], ["proof (chain)\npicking this:\n  i \\<in> agents", "interpret total_preorder_on alts \"R i\""], ["proof (prove)\nusing this:\n  i \\<in> agents\n\ngoal (1 subgoal):\n 1. total_preorder_on alts (R i)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. SD (R i) q p =\n    (p \\<in> lotteries_on alts \\<and>\n     q \\<in> lotteries_on alts \\<and>\n     (\\<forall>x\\<in>alts.\n         measure_pmf.prob q (preferred_alts (R i) x)\n         \\<le> measure_pmf.prob p (preferred_alts (R i) x)))", "have \"preferred_alts (R i) x = {y. y \\<succeq>[R i] x}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. preferred_alts (R i) x = {y. R i x y}", "using not_outside"], ["proof (prove)\nusing this:\n  R i ?x ?y \\<Longrightarrow> ?x \\<in> alts\n  R i ?x ?y \\<Longrightarrow> ?y \\<in> alts\n\ngoal (1 subgoal):\n 1. preferred_alts (R i) x = {y. R i x y}", "by (auto simp: preferred_alts_def)"], ["proof (state)\nthis:\n  preferred_alts (R i) ?x = {y. R i ?x y}\n\ngoal (1 subgoal):\n 1. SD (R i) q p =\n    (p \\<in> lotteries_on alts \\<and>\n     q \\<in> lotteries_on alts \\<and>\n     (\\<forall>x\\<in>alts.\n         measure_pmf.prob q (preferred_alts (R i) x)\n         \\<le> measure_pmf.prob p (preferred_alts (R i) x)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  preferred_alts (R i) ?x = {y. R i ?x y}\n\ngoal (1 subgoal):\n 1. SD (R i) q p =\n    (p \\<in> lotteries_on alts \\<and>\n     q \\<in> lotteries_on alts \\<and>\n     (\\<forall>x\\<in>alts.\n         measure_pmf.prob q (preferred_alts (R i) x)\n         \\<le> measure_pmf.prob p (preferred_alts (R i) x)))", "by (simp add: SD_preorder preferred_alts_def)"], ["proof (state)\nthis:\n  SD (R i) q p =\n  (p \\<in> lotteries_on alts \\<and>\n   q \\<in> lotteries_on alts \\<and>\n   (\\<forall>x\\<in>alts.\n       measure_pmf.prob q (preferred_alts (R i) x)\n       \\<le> measure_pmf.prob p (preferred_alts (R i) x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SD_pref_profileI [intro?]:\n  assumes \"i \\<in> agents\" \"p \\<in> lotteries_on alts\" \"q \\<in> lotteries_on alts\"\n  assumes \"\\<And>x. x \\<in> alts \\<Longrightarrow>\n             measure_pmf.prob p (preferred_alts (R i) x) \\<ge>\n             measure_pmf.prob q (preferred_alts (R i) x)\"\n  shows   \"p \\<succeq>[SD(R i)] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD (R i) q p", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> agents\n  p \\<in> lotteries_on alts\n  q \\<in> lotteries_on alts\n  ?x \\<in> alts \\<Longrightarrow>\n  measure_pmf.prob q (preferred_alts (R i) ?x)\n  \\<le> measure_pmf.prob p (preferred_alts (R i) ?x)\n\ngoal (1 subgoal):\n 1. SD (R i) q p", "by (simp add: SD_pref_profile)"], ["", "lemma SD_pref_profileD:\n  assumes \"i \\<in> agents\" \"p \\<succeq>[SD(R i)] q\"\n  shows   \"p \\<in> lotteries_on alts\" \"q \\<in> lotteries_on alts\"\n  and     \"\\<And>x. x \\<in> alts \\<Longrightarrow>\n             measure_pmf.prob p (preferred_alts (R i) x) \\<ge>\n             measure_pmf.prob q (preferred_alts (R i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<in> lotteries_on alts &&& q \\<in> lotteries_on alts) &&&\n    (\\<And>x.\n        x \\<in> alts \\<Longrightarrow>\n        measure_pmf.prob q (preferred_alts (R i) x)\n        \\<le> measure_pmf.prob p (preferred_alts (R i) x))", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> agents\n  SD (R i) q p\n\ngoal (1 subgoal):\n 1. (p \\<in> lotteries_on alts &&& q \\<in> lotteries_on alts) &&&\n    (\\<And>x.\n        x \\<in> alts \\<Longrightarrow>\n        measure_pmf.prob q (preferred_alts (R i) x)\n        \\<le> measure_pmf.prob p (preferred_alts (R i) x))", "by (simp_all add: SD_pref_profile)"], ["", "end"], ["", "subsection \\<open>SD efficient lotteries\\<close>"], ["", "definition SD_efficient :: \"('agent, 'alt) pref_profile \\<Rightarrow> 'alt lottery \\<Rightarrow> bool\" where\n  SD_efficient_auxdef:\n    \"SD_efficient R p \\<longleftrightarrow> \\<not>(\\<exists>q\\<in>lotteries_on {x. \\<exists>i. R i x x}. q \\<succ>[Pareto (SD \\<circ> R)] p)\""], ["", "context pref_profile_wf\nbegin"], ["", "sublocale SD: preorder_family agents \"lotteries_on alts\" \"SD \\<circ> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_family agents (lotteries_on alts) (SD \\<circ> R)", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_family agents (lotteries_on alts) (\\<lambda>x. SD (R x))", "by (intro preorder_family.intro SD_is_preorder)\n     (simp_all add: preorder_on.SD_is_preorder' prefs_undefined')"], ["", "text \\<open>\n  A lottery is considered SD-efficient if there is no other lottery such that\n  all agents weakly prefer the other lottery (w.r.t. stochastic dominance) and at least\n  one agent strongly prefers the other lottery.\n\\<close>"], ["", "lemma SD_efficient_def:\n  \"SD_efficient R p \\<longleftrightarrow> \\<not>(\\<exists>q\\<in>lotteries_on alts. q \\<succ>[Pareto (SD \\<circ> R)] p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD_efficient R p =\n    (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n                p \\<prec>[Pareto (SD \\<circ> R)] q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SD_efficient R p =\n    (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n                p \\<prec>[Pareto (SD \\<circ> R)] q))", "have \"SD_efficient R p \\<longleftrightarrow> \\<not>(\\<exists>q\\<in>lotteries_on {x. \\<exists>i. R i x x}. q \\<succ>[Pareto (SD \\<circ> R)] p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD_efficient R p =\n    (\\<not> (\\<exists>q\\<in>lotteries_on {x. \\<exists>i. R i x x}.\n                p \\<prec>[Pareto (SD \\<circ> R)] q))", "unfolding SD_efficient_auxdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> Bex (lotteries_on {x. \\<exists>i. R i x x})\n             (strongly_preferred p (Pareto (SD \\<circ> R)))) =\n    (\\<not> (\\<exists>q\\<in>lotteries_on {x. \\<exists>i. R i x x}.\n                p \\<prec>[Pareto (SD \\<circ> R)] q))", ".."], ["proof (state)\nthis:\n  SD_efficient R p =\n  (\\<not> (\\<exists>q\\<in>lotteries_on {x. \\<exists>i. R i x x}.\n              p \\<prec>[Pareto (SD \\<circ> R)] q))\n\ngoal (1 subgoal):\n 1. SD_efficient R p =\n    (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n                p \\<prec>[Pareto (SD \\<circ> R)] q))", "also"], ["proof (state)\nthis:\n  SD_efficient R p =\n  (\\<not> (\\<exists>q\\<in>lotteries_on {x. \\<exists>i. R i x x}.\n              p \\<prec>[Pareto (SD \\<circ> R)] q))\n\ngoal (1 subgoal):\n 1. SD_efficient R p =\n    (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n                p \\<prec>[Pareto (SD \\<circ> R)] q))", "from nonempty_agents"], ["proof (chain)\npicking this:\n  agents \\<noteq> {}", "obtain i where i: \"i \\<in> agents\""], ["proof (prove)\nusing this:\n  agents \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> agents \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<in> agents\n\ngoal (1 subgoal):\n 1. SD_efficient R p =\n    (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n                p \\<prec>[Pareto (SD \\<circ> R)] q))", "with preorder_on.refl[of alts \"R i\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Order_Predicates.preorder_on alts (R i); ?x \\<in> alts\\<rbrakk>\n  \\<Longrightarrow> R i ?x ?x\n  i \\<in> agents", "have \"{x. \\<exists>i. R i x x} = alts\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Order_Predicates.preorder_on alts (R i); ?x \\<in> alts\\<rbrakk>\n  \\<Longrightarrow> R i ?x ?x\n  i \\<in> agents\n\ngoal (1 subgoal):\n 1. {x. \\<exists>i. R i x x} = alts", "by (auto intro!: exI[of _ i] not_outside)"], ["proof (state)\nthis:\n  {x. \\<exists>i. R i x x} = alts\n\ngoal (1 subgoal):\n 1. SD_efficient R p =\n    (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n                p \\<prec>[Pareto (SD \\<circ> R)] q))", "finally"], ["proof (chain)\npicking this:\n  SD_efficient R p =\n  (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n              p \\<prec>[Pareto (SD \\<circ> R)] q))", "show ?thesis"], ["proof (prove)\nusing this:\n  SD_efficient R p =\n  (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n              p \\<prec>[Pareto (SD \\<circ> R)] q))\n\ngoal (1 subgoal):\n 1. SD_efficient R p =\n    (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n                p \\<prec>[Pareto (SD \\<circ> R)] q))", "."], ["proof (state)\nthis:\n  SD_efficient R p =\n  (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n              p \\<prec>[Pareto (SD \\<circ> R)] q))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SD_efficient_def':\n  \"SD_efficient R p \\<longleftrightarrow>\n     \\<not>(\\<exists>q\\<in>lotteries_on alts. (\\<forall>i\\<in>agents. q \\<succeq>[SD(R i)] p) \\<and> (\\<exists>i\\<in>agents. q \\<succ>[SD(R i)] p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD_efficient R p =\n    (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n                (\\<forall>i\\<in>agents. SD (R i) p q) \\<and>\n                (\\<exists>i\\<in>agents. p \\<prec>[SD (R i)] q)))", "unfolding SD_efficient_def SD.Pareto_iff strongly_preferred_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (\\<exists>b\\<in>lotteries_on alts.\n                (\\<forall>i\\<in>agents. (SD \\<circ> R) i p b) \\<and>\n                \\<not> (\\<forall>i\\<in>agents. (SD \\<circ> R) i b p))) =\n    (\\<not> (\\<exists>q\\<in>lotteries_on alts.\n                (\\<forall>i\\<in>agents. SD (R i) p q) \\<and>\n                (\\<exists>i\\<in>agents.\n                    SD (R i) p q \\<and> \\<not> SD (R i) q p)))", "by auto"], ["", "lemma SD_inefficientI:\n  assumes \"q \\<in> lotteries_on alts\" \"\\<And>i. i \\<in> agents \\<Longrightarrow> q \\<succeq>[SD(R i)] p\"\n          \"i \\<in> agents\" \"q \\<succ>[SD(R i)] p\"\n  shows   \"\\<not>SD_efficient R p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> SD_efficient R p", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) p q\n  i \\<in> agents\n  p \\<prec>[SD (R i)] q\n\ngoal (1 subgoal):\n 1. \\<not> SD_efficient R p", "unfolding SD_efficient_def'"], ["proof (prove)\nusing this:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) p q\n  i \\<in> agents\n  p \\<prec>[SD (R i)] q\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<exists>q\\<in>lotteries_on alts.\n                      (\\<forall>i\\<in>agents. SD (R i) p q) \\<and>\n                      (\\<exists>i\\<in>agents. p \\<prec>[SD (R i)] q))", "by blast"], ["", "lemma SD_inefficientI':\n  assumes \"q \\<in> lotteries_on alts\" \"\\<And>i. i \\<in> agents \\<Longrightarrow> q \\<succeq>[SD(R i)] p\"\n          \"\\<exists>i \\<in> agents. q \\<succ>[SD(R i)] p\"\n  shows   \"\\<not>SD_efficient R p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> SD_efficient R p", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) p q\n  \\<exists>i\\<in>agents. p \\<prec>[SD (R i)] q\n\ngoal (1 subgoal):\n 1. \\<not> SD_efficient R p", "unfolding SD_efficient_def'"], ["proof (prove)\nusing this:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) p q\n  \\<exists>i\\<in>agents. p \\<prec>[SD (R i)] q\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<exists>q\\<in>lotteries_on alts.\n                      (\\<forall>i\\<in>agents. SD (R i) p q) \\<and>\n                      (\\<exists>i\\<in>agents. p \\<prec>[SD (R i)] q))", "by blast"], ["", "lemma SD_inefficientE:\n  assumes \"\\<not>SD_efficient R p\"\n  obtains q i where\n    \"q \\<in> lotteries_on alts\" \"\\<And>i. i \\<in> agents \\<Longrightarrow> q \\<succeq>[SD(R i)] p\"\n    \"i \\<in> agents\" \"q \\<succ>[SD(R i)] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        \\<lbrakk>q \\<in> lotteries_on alts;\n         \\<And>i. i \\<in> agents \\<Longrightarrow> SD (R i) p q;\n         i \\<in> agents; p \\<prec>[SD (R i)] q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> SD_efficient R p\n\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        \\<lbrakk>q \\<in> lotteries_on alts;\n         \\<And>i. i \\<in> agents \\<Longrightarrow> SD (R i) p q;\n         i \\<in> agents; p \\<prec>[SD (R i)] q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding SD_efficient_def'"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<exists>q\\<in>lotteries_on alts.\n                    (\\<forall>i\\<in>agents. SD (R i) p q) \\<and>\n                    (\\<exists>i\\<in>agents. p \\<prec>[SD (R i)] q))\n\ngoal (1 subgoal):\n 1. (\\<And>q i.\n        \\<lbrakk>q \\<in> lotteries_on alts;\n         \\<And>i. i \\<in> agents \\<Longrightarrow> SD (R i) p q;\n         i \\<in> agents; p \\<prec>[SD (R i)] q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma SD_efficientD:\n  assumes \"SD_efficient R p\" \"q \\<in> lotteries_on alts\"\n      and \"\\<And>i. i \\<in> agents \\<Longrightarrow> q \\<succeq>[SD(R i)] p\" \"\\<exists>i\\<in>agents. \\<not>(q \\<preceq>[SD(R i)] p)\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  SD_efficient R p\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) p q\n  \\<exists>i\\<in>agents. \\<not> SD (R i) q p\n\ngoal (1 subgoal):\n 1. False", "unfolding SD_efficient_def' strongly_preferred_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>q\\<in>lotteries_on alts.\n             (\\<forall>i\\<in>agents. SD (R i) p q) \\<and>\n             (\\<exists>i\\<in>agents.\n                 SD (R i) p q \\<and> \\<not> SD (R i) q p))\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) p q\n  \\<exists>i\\<in>agents. \\<not> SD (R i) q p\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["", "lemma SD_efficient_singleton_iff:\n  assumes [simp]: \"x \\<in> alts\"\n  shows   \"SD_efficient R (return_pmf x) \\<longleftrightarrow> x \\<notin> pareto_losers R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "assume x: \"x \\<in> pareto_losers R\""], ["proof (state)\nthis:\n  x \\<in> pareto_losers R\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "from pareto_losersE[OF x]"], ["proof (chain)\npicking this:\n  (\\<And>y.\n      \\<lbrakk>y \\<in> alts; x \\<prec>[Pareto R] y\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess y"], ["proof (prove)\nusing this:\n  (\\<And>y.\n      \\<lbrakk>y \\<in> alts; x \\<prec>[Pareto R] y\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  y \\<in> alts\n  x \\<prec>[Pareto R] y\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "note y = this"], ["proof (state)\nthis:\n  y \\<in> alts\n  x \\<prec>[Pareto R] y\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "from y"], ["proof (chain)\npicking this:\n  y \\<in> alts\n  x \\<prec>[Pareto R] y", "have \"\\<not>SD_efficient R (return_pmf x)\""], ["proof (prove)\nusing this:\n  y \\<in> alts\n  x \\<prec>[Pareto R] y\n\ngoal (1 subgoal):\n 1. \\<not> SD_efficient R (return_pmf x)", "by (intro SD_inefficientI'[of \"return_pmf y\"]) (force simp: Pareto_strict_iff)+"], ["proof (state)\nthis:\n  \\<not> SD_efficient R (return_pmf x)\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "}"], ["proof (state)\nthis:\n  x \\<in> pareto_losers R \\<Longrightarrow>\n  \\<not> SD_efficient R (return_pmf x)\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "moreover"], ["proof (state)\nthis:\n  x \\<in> pareto_losers R \\<Longrightarrow>\n  \\<not> SD_efficient R (return_pmf x)\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "{"], ["proof (state)\nthis:\n  x \\<in> pareto_losers R \\<Longrightarrow>\n  \\<not> SD_efficient R (return_pmf x)\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "assume \"\\<not>SD_efficient R (return_pmf x)\""], ["proof (state)\nthis:\n  \\<not> SD_efficient R (return_pmf x)\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "from SD_inefficientE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>q i.\n      \\<lbrakk>q \\<in> lotteries_on alts;\n       \\<And>i. i \\<in> agents \\<Longrightarrow> SD (R i) (return_pmf x) q;\n       i \\<in> agents; return_pmf x \\<prec>[SD (R i)] q\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess q i"], ["proof (prove)\nusing this:\n  (\\<And>q i.\n      \\<lbrakk>q \\<in> lotteries_on alts;\n       \\<And>i. i \\<in> agents \\<Longrightarrow> SD (R i) (return_pmf x) q;\n       i \\<in> agents; return_pmf x \\<prec>[SD (R i)] q\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) (return_pmf x) q\n  i \\<in> agents\n  return_pmf x \\<prec>[SD (R i)] q\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "note q = this"], ["proof (state)\nthis:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) (return_pmf x) q\n  i \\<in> agents\n  return_pmf x \\<prec>[SD (R i)] q\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "moreover"], ["proof (state)\nthis:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) (return_pmf x) q\n  i \\<in> agents\n  return_pmf x \\<prec>[SD (R i)] q\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "from q"], ["proof (chain)\npicking this:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) (return_pmf x) q\n  i \\<in> agents\n  return_pmf x \\<prec>[SD (R i)] q", "obtain y where \"y \\<in> set_pmf q\" \"y \\<succ>[R i] x\""], ["proof (prove)\nusing this:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) (return_pmf x) q\n  i \\<in> agents\n  return_pmf x \\<prec>[SD (R i)] q\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set_pmf q; x \\<prec>[R i] y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SD_strict_singleton_left)"], ["proof (state)\nthis:\n  y \\<in> set_pmf q\n  x \\<prec>[R i] y\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "ultimately"], ["proof (chain)\npicking this:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) (return_pmf x) q\n  i \\<in> agents\n  return_pmf x \\<prec>[SD (R i)] q\n  y \\<in> set_pmf q\n  x \\<prec>[R i] y", "have \"y \\<succ>[Pareto(R)] x\""], ["proof (prove)\nusing this:\n  q \\<in> lotteries_on alts\n  ?i \\<in> agents \\<Longrightarrow> SD (R ?i) (return_pmf x) q\n  i \\<in> agents\n  return_pmf x \\<prec>[SD (R i)] q\n  y \\<in> set_pmf q\n  x \\<prec>[R i] y\n\ngoal (1 subgoal):\n 1. x \\<prec>[Pareto R] y", "by (fastforce simp: Pareto_strict_iff SD_singleton_left)"], ["proof (state)\nthis:\n  x \\<prec>[Pareto R] y\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "hence \"x \\<in> pareto_losers R\""], ["proof (prove)\nusing this:\n  x \\<prec>[Pareto R] y\n\ngoal (1 subgoal):\n 1. x \\<in> pareto_losers R", "by simp"], ["proof (state)\nthis:\n  x \\<in> pareto_losers R\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "}"], ["proof (state)\nthis:\n  \\<not> SD_efficient R (return_pmf x) \\<Longrightarrow>\n  x \\<in> pareto_losers R\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> pareto_losers R \\<Longrightarrow>\n  \\<not> SD_efficient R (return_pmf x)\n  \\<not> SD_efficient R (return_pmf x) \\<Longrightarrow>\n  x \\<in> pareto_losers R", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> pareto_losers R \\<Longrightarrow>\n  \\<not> SD_efficient R (return_pmf x)\n  \\<not> SD_efficient R (return_pmf x) \\<Longrightarrow>\n  x \\<in> pareto_losers R\n\ngoal (1 subgoal):\n 1. SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)", "by blast"], ["proof (state)\nthis:\n  SD_efficient R (return_pmf x) = (x \\<notin> pareto_losers R)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Equivalence proof\\<close>"], ["", "text \\<open>\n  We now show that a lottery is preferred w.r.t. Stochastic Dominance iff\n  it yields more expected utility for all compatible utility functions.\n\\<close>"], ["", "context finite_total_preorder_on\nbegin"], ["", "abbreviation \"is_vnm_utility \\<equiv> vnm_utility carrier le\""], ["", "lemma utility_weak_ranking_index:\n  \"is_vnm_utility (\\<lambda>x. real (length (weak_ranking le) - weak_ranking_index x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vnm_utility\n     (\\<lambda>x. real (length (weak_ranking le) - weak_ranking_index x))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> (real\n                           (length (weak_ranking le) - weak_ranking_index x)\n                          \\<le> real\n                                 (length (weak_ranking le) -\n                                  weak_ranking_index y)) =\n                         le x y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> (real\n                           (length (weak_ranking le) - weak_ranking_index x)\n                          \\<le> real\n                                 (length (weak_ranking le) -\n                                  weak_ranking_index y)) =\n                         le x y", "assume xy: \"x \\<in> carrier\" \"y \\<in> carrier\""], ["proof (state)\nthis:\n  x \\<in> carrier\n  y \\<in> carrier\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> (real\n                           (length (weak_ranking le) - weak_ranking_index x)\n                          \\<le> real\n                                 (length (weak_ranking le) -\n                                  weak_ranking_index y)) =\n                         le x y", "with this[THEN nth_weak_ranking_index(1)] this[THEN nth_weak_ranking_index(2)]"], ["proof (chain)\npicking this:\n  weak_ranking_index x < length (weak_ranking le)\n  weak_ranking_index y < length (weak_ranking le)\n  x \\<in> weak_ranking le ! weak_ranking_index x\n  y \\<in> weak_ranking le ! weak_ranking_index y\n  x \\<in> carrier\n  y \\<in> carrier", "show \"(real (length (weak_ranking le) - weak_ranking_index x)\n            \\<le> real (length (weak_ranking le) - weak_ranking_index y)) \\<longleftrightarrow> le x y\""], ["proof (prove)\nusing this:\n  weak_ranking_index x < length (weak_ranking le)\n  weak_ranking_index y < length (weak_ranking le)\n  x \\<in> weak_ranking le ! weak_ranking_index x\n  y \\<in> weak_ranking le ! weak_ranking_index y\n  x \\<in> carrier\n  y \\<in> carrier\n\ngoal (1 subgoal):\n 1. (real (length (weak_ranking le) - weak_ranking_index x)\n     \\<le> real (length (weak_ranking le) - weak_ranking_index y)) =\n    le x y", "by (simp add: le_diff_iff')"], ["proof (state)\nthis:\n  (real (length (weak_ranking le) - weak_ranking_index x)\n   \\<le> real (length (weak_ranking le) - weak_ranking_index y)) =\n  le x y\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  TODO: one direction could probably be generalised to weakly consistent\n  utility functions\n*)"], ["", "lemma SD_iff_expected_utilities_le:\n  assumes \"p \\<in> lotteries_on carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"p \\<preceq>[SD(le)] q \\<longleftrightarrow>\n             (\\<forall>u. is_vnm_utility u \\<longrightarrow> measure_pmf.expectation p u \\<le> measure_pmf.expectation q u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SD le p q =\n    (\\<forall>u.\n        is_vnm_utility u \\<longrightarrow>\n        measure_pmf.expectation p u \\<le> measure_pmf.expectation q u)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "assume SD: \"p \\<preceq>[SD(le)] q\" and is_utility: \"is_vnm_utility u\""], ["proof (state)\nthis:\n  SD le p q\n  is_vnm_utility u\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "from is_utility"], ["proof (chain)\npicking this:\n  is_vnm_utility u", "interpret vnm_utility carrier le u"], ["proof (prove)\nusing this:\n  is_vnm_utility u\n\ngoal (1 subgoal):\n 1. is_vnm_utility u", "."], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "define xs where \"xs = weak_ranking le\""], ["proof (state)\nthis:\n  xs = weak_ranking le\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "have le: \"is_weak_ranking xs\" \"le = of_weak_ranking xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_weak_ranking xs &&& le = of_weak_ranking xs", "by (simp_all add: xs_def weak_ranking_total_preorder)"], ["proof (state)\nthis:\n  is_weak_ranking xs\n  le = of_weak_ranking xs\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "let ?pref = \"\\<lambda>p x. measure_pmf.prob p {y. x \\<preceq>[le] y}\" and\n      ?pref' = \"\\<lambda>p x. measure_pmf.prob p {y. x \\<prec>[le] y}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "define f where \"f i = (SOME x. x \\<in> xs ! i)\" for i"], ["proof (state)\nthis:\n  f ?i = (SOME x. x \\<in> xs ! ?i)\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "have xs_wf: \"is_weak_ranking xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_weak_ranking xs", "by (simp add: xs_def weak_ranking_total_preorder)"], ["proof (state)\nthis:\n  is_weak_ranking xs\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "hence f: \"f i \\<in> xs ! i\" if \"i < length xs\" for i"], ["proof (prove)\nusing this:\n  is_weak_ranking xs\n\ngoal (1 subgoal):\n 1. f i \\<in> xs ! i", "using that"], ["proof (prove)\nusing this:\n  is_weak_ranking xs\n  i < length xs\n\ngoal (1 subgoal):\n 1. f i \\<in> xs ! i", "unfolding f_def is_weak_ranking_def"], ["proof (prove)\nusing this:\n  {} \\<notin> set xs \\<and>\n  (\\<forall>i j.\n      i < length xs \\<and>\n      j < length xs \\<and> i \\<noteq> j \\<longrightarrow>\n      xs ! i \\<inter> xs ! j = {})\n  i < length xs\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> xs ! i) \\<in> xs ! i", "by (intro someI_ex[of \"\\<lambda>x. x \\<in> xs ! i\"]) (auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow> f ?i \\<in> xs ! ?i\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "have f': \"f i \\<in> carrier\" if \"i < length xs\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<in> carrier", "using that f weak_ranking_Union"], ["proof (prove)\nusing this:\n  i < length xs\n  ?i < length xs \\<Longrightarrow> f ?i \\<in> xs ! ?i\n  \\<Union> (set (weak_ranking le)) = carrier\n\ngoal (1 subgoal):\n 1. f i \\<in> carrier", "unfolding xs_def"], ["proof (prove)\nusing this:\n  i < length (weak_ranking le)\n  ?i < length (weak_ranking le) \\<Longrightarrow>\n  f ?i \\<in> weak_ranking le ! ?i\n  \\<Union> (set (weak_ranking le)) = carrier\n\ngoal (1 subgoal):\n 1. f i \\<in> carrier", "by (auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow> f ?i \\<in> carrier\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "define n where \"n = length xs - 1\""], ["proof (state)\nthis:\n  n = length xs - 1\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "from assms weak_ranking_Union"], ["proof (chain)\npicking this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  \\<Union> (set (weak_ranking le)) = carrier", "have carrier_nonempty: \"carrier \\<noteq> {}\" and \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  \\<Union> (set (weak_ranking le)) = carrier\n\ngoal (1 subgoal):\n 1. carrier \\<noteq> {} &&& xs \\<noteq> []", "by (auto simp: xs_def lotteries_on_def set_pmf_not_empty)"], ["proof (state)\nthis:\n  carrier \\<noteq> {}\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "hence n: \"length xs = Suc n\" and xs_nonempty: \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  carrier \\<noteq> {}\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. length xs = Suc n &&& xs \\<noteq> []", "by (auto simp add: n_def)"], ["proof (state)\nthis:\n  length xs = Suc n\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "have SD': \"?pref p (f i) \\<le> ?pref q (f i)\" if \"i < length xs\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob p {y. le (f i) y}\n    \\<le> measure_pmf.prob q {y. le (f i) y}", "using f'[OF that] SD"], ["proof (prove)\nusing this:\n  f i \\<in> carrier\n  SD le p q\n\ngoal (1 subgoal):\n 1. measure_pmf.prob p {y. le (f i) y}\n    \\<le> measure_pmf.prob q {y. le (f i) y}", "by (auto simp: SD_preorder preferred_alts_def)"], ["proof (state)\nthis:\n  ?i < length xs \\<Longrightarrow>\n  measure_pmf.prob p {y. le (f ?i) y}\n  \\<le> measure_pmf.prob q {y. le (f ?i) y}\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "have f_le: \"le (f i) (f j) \\<longleftrightarrow> i \\<ge> j\" if \"i < length xs\" \"j < length xs\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. le (f i) (f j) = (j \\<le> i)", "using that weak_ranking_index_unique[OF xs_wf that(1) _ f]\n               weak_ranking_index_unique[OF xs_wf that(2) _ f]"], ["proof (prove)\nusing this:\n  i < length xs\n  j < length xs\n  \\<lbrakk>?j < length xs; i < length xs; f i \\<in> xs ! ?j\\<rbrakk>\n  \\<Longrightarrow> i = ?j\n  \\<lbrakk>?j < length xs; j < length xs; f j \\<in> xs ! ?j\\<rbrakk>\n  \\<Longrightarrow> j = ?j\n\ngoal (1 subgoal):\n 1. le (f i) (f j) = (j \\<le> i)", "by (auto simp add: le intro: f elim!: of_weak_ranking.cases intro!: of_weak_ranking.intros)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xs; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> le (f ?i) (f ?j) = (?j \\<le> ?i)\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "have \"measure_pmf.expectation p u =\n          (\\<Sum>i<n. (u (f i) - u (f (Suc i))) * ?pref p (f i)) + u (f n)\"\n    if p: \"p \\<in> lotteries_on carrier\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "from p"], ["proof (chain)\npicking this:\n  p \\<in> lotteries_on carrier", "have \"measure_pmf.expectation p u =\n                   (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p (xs ! i))\""], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p (xs ! i))", "by (simp add: f_def expected_utility_weak_ranking xs_def sum_list_sum_nth atLeast0LessThan)"], ["proof (state)\nthis:\n  measure_pmf.expectation p u =\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p (xs ! i))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation p u =\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p (xs ! i))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "have \"\\<dots> = (\\<Sum>i<length xs. u (f i) * (?pref p (f i) - ?pref' p (f i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p (xs ! i)) =\n    (\\<Sum>i<length xs.\n        u (f i) *\n        (measure_pmf.prob p {y. le (f i) y} -\n         measure_pmf.prob p {y. f i \\<prec>[le] y}))", "proof (intro sum.cong HOL.refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xs} \\<Longrightarrow>\n       u (f x) * measure_pmf.prob p (xs ! x) =\n       u (f x) *\n       (measure_pmf.prob p {y. le (f x) y} -\n        measure_pmf.prob p {y. f x \\<prec>[le] y})", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xs} \\<Longrightarrow>\n       u (f x) * measure_pmf.prob p (xs ! x) =\n       u (f x) *\n       (measure_pmf.prob p {y. le (f x) y} -\n        measure_pmf.prob p {y. f x \\<prec>[le] y})", "assume i: \"i \\<in> {..<length xs}\""], ["proof (state)\nthis:\n  i \\<in> {..<length xs}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xs} \\<Longrightarrow>\n       u (f x) * measure_pmf.prob p (xs ! x) =\n       u (f x) *\n       (measure_pmf.prob p {y. le (f x) y} -\n        measure_pmf.prob p {y. f x \\<prec>[le] y})", "have \"?pref p (f i) - ?pref' p (f i) =\n              measure_pmf.prob p ({y. f i \\<preceq>[le] y} - {y. f i \\<prec>[le] y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob p {y. le (f i) y} -\n    measure_pmf.prob p {y. f i \\<prec>[le] y} =\n    measure_pmf.prob p ({y. le (f i) y} - {y. f i \\<prec>[le] y})", "by (subst measure_pmf.finite_measure_Diff [symmetric])\n           (auto simp: strongly_preferred_def)"], ["proof (state)\nthis:\n  measure_pmf.prob p {y. le (f i) y} -\n  measure_pmf.prob p {y. f i \\<prec>[le] y} =\n  measure_pmf.prob p ({y. le (f i) y} - {y. f i \\<prec>[le] y})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xs} \\<Longrightarrow>\n       u (f x) * measure_pmf.prob p (xs ! x) =\n       u (f x) *\n       (measure_pmf.prob p {y. le (f x) y} -\n        measure_pmf.prob p {y. f x \\<prec>[le] y})", "also"], ["proof (state)\nthis:\n  measure_pmf.prob p {y. le (f i) y} -\n  measure_pmf.prob p {y. f i \\<prec>[le] y} =\n  measure_pmf.prob p ({y. le (f i) y} - {y. f i \\<prec>[le] y})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xs} \\<Longrightarrow>\n       u (f x) * measure_pmf.prob p (xs ! x) =\n       u (f x) *\n       (measure_pmf.prob p {y. le (f x) y} -\n        measure_pmf.prob p {y. f x \\<prec>[le] y})", "have \"{y. f i \\<preceq>[le] y} - {y. f i \\<prec>[le] y} =\n                   {y. f i \\<preceq>[le] y \\<and> y \\<preceq>[le] f i}\" (is \"_ = ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. le (f i) y} - {y. f i \\<prec>[le] y} =\n    {y. le (f i) y \\<and> le y (f i)}", "by (auto simp: strongly_preferred_def)"], ["proof (state)\nthis:\n  {y. le (f i) y} - {y. f i \\<prec>[le] y} =\n  {y. le (f i) y \\<and> le y (f i)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xs} \\<Longrightarrow>\n       u (f x) * measure_pmf.prob p (xs ! x) =\n       u (f x) *\n       (measure_pmf.prob p {y. le (f x) y} -\n        measure_pmf.prob p {y. f x \\<prec>[le] y})", "also"], ["proof (state)\nthis:\n  {y. le (f i) y} - {y. f i \\<prec>[le] y} =\n  {y. le (f i) y \\<and> le y (f i)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xs} \\<Longrightarrow>\n       u (f x) * measure_pmf.prob p (xs ! x) =\n       u (f x) *\n       (measure_pmf.prob p {y. le (f x) y} -\n        measure_pmf.prob p {y. f x \\<prec>[le] y})", "have \"\\<dots> = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. le (f i) y \\<and> le y (f i)} = xs ! i", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>le (f i) x; le x (f i)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> xs ! i\n 2. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le (f i) x\n 3. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le x (f i)", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>le (f i) x; le x (f i)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> xs ! i\n 2. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le (f i) x\n 3. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le x (f i)", "assume le: \"le (f i) x\" \"le x (f i)\""], ["proof (state)\nthis:\n  le (f i) x\n  le x (f i)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>le (f i) x; le x (f i)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> xs ! i\n 2. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le (f i) x\n 3. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le x (f i)", "from i f"], ["proof (chain)\npicking this:\n  i \\<in> {..<length xs}\n  ?i < length xs \\<Longrightarrow> f ?i \\<in> xs ! ?i", "show \"x \\<in> xs ! i\""], ["proof (prove)\nusing this:\n  i \\<in> {..<length xs}\n  ?i < length xs \\<Longrightarrow> f ?i \\<in> xs ! ?i\n\ngoal (1 subgoal):\n 1. x \\<in> xs ! i", "by (intro weak_ranking_eqclass2[OF _ _ le]) (auto simp: xs_def)"], ["proof (state)\nthis:\n  x \\<in> xs ! i\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le (f i) x\n 2. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le x (f i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le (f i) x\n 2. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le x (f i)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le (f i) x\n 2. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le x (f i)", "assume \"x \\<in> xs ! i\""], ["proof (state)\nthis:\n  x \\<in> xs ! i\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le (f i) x\n 2. \\<And>x. x \\<in> xs ! i \\<Longrightarrow> le x (f i)", "from weak_ranking_eqclass1[OF _ this f] weak_ranking_eqclass1[OF _ f this] i"], ["proof (chain)\npicking this:\n  \\<lbrakk>xs ! i \\<in> set (weak_ranking le); i < length xs\\<rbrakk>\n  \\<Longrightarrow> le x (f i)\n  \\<lbrakk>xs ! i \\<in> set (weak_ranking le); i < length xs\\<rbrakk>\n  \\<Longrightarrow> le (f i) x\n  i \\<in> {..<length xs}", "show \"le x (f i)\" \"le (f i) x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>xs ! i \\<in> set (weak_ranking le); i < length xs\\<rbrakk>\n  \\<Longrightarrow> le x (f i)\n  \\<lbrakk>xs ! i \\<in> set (weak_ranking le); i < length xs\\<rbrakk>\n  \\<Longrightarrow> le (f i) x\n  i \\<in> {..<length xs}\n\ngoal (1 subgoal):\n 1. le x (f i) &&& le (f i) x", "by (simp_all add: xs_def)"], ["proof (state)\nthis:\n  le x (f i)\n  le (f i) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {y. le (f i) y \\<and> le y (f i)} = xs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<length xs} \\<Longrightarrow>\n       u (f x) * measure_pmf.prob p (xs ! x) =\n       u (f x) *\n       (measure_pmf.prob p {y. le (f x) y} -\n        measure_pmf.prob p {y. f x \\<prec>[le] y})", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.prob p {y. le (f i) y} -\n  measure_pmf.prob p {y. f i \\<prec>[le] y} =\n  measure_pmf.prob p (xs ! i)", "show \"u (f i) * measure_pmf.prob p (xs ! i) =\n                      u (f i) * (?pref p (f i) - ?pref' p (f i))\""], ["proof (prove)\nusing this:\n  measure_pmf.prob p {y. le (f i) y} -\n  measure_pmf.prob p {y. f i \\<prec>[le] y} =\n  measure_pmf.prob p (xs ! i)\n\ngoal (1 subgoal):\n 1. u (f i) * measure_pmf.prob p (xs ! i) =\n    u (f i) *\n    (measure_pmf.prob p {y. le (f i) y} -\n     measure_pmf.prob p {y. f i \\<prec>[le] y})", "by simp"], ["proof (state)\nthis:\n  u (f i) * measure_pmf.prob p (xs ! i) =\n  u (f i) *\n  (measure_pmf.prob p {y. le (f i) y} -\n   measure_pmf.prob p {y. f i \\<prec>[le] y})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p (xs ! i)) =\n  (\\<Sum>i<length xs.\n      u (f i) *\n      (measure_pmf.prob p {y. le (f i) y} -\n       measure_pmf.prob p {y. f i \\<prec>[le] y}))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p (xs ! i)) =\n  (\\<Sum>i<length xs.\n      u (f i) *\n      (measure_pmf.prob p {y. le (f i) y} -\n       measure_pmf.prob p {y. f i \\<prec>[le] y}))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "have \"\\<dots> = (\\<Sum>i<length xs. u (f i) * ?pref p (f i)) -\n                      (\\<Sum>i<length xs. u (f i) * ?pref' p (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xs.\n        u (f i) *\n        (measure_pmf.prob p {y. le (f i) y} -\n         measure_pmf.prob p {y. f i \\<prec>[le] y})) =\n    (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. le (f i) y}) -\n    (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. f i \\<prec>[le] y})", "by (simp add: sum_subtractf ring_distribs)"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs.\n      u (f i) *\n      (measure_pmf.prob p {y. le (f i) y} -\n       measure_pmf.prob p {y. f i \\<prec>[le] y})) =\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. le (f i) y}) -\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. f i \\<prec>[le] y})\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs.\n      u (f i) *\n      (measure_pmf.prob p {y. le (f i) y} -\n       measure_pmf.prob p {y. f i \\<prec>[le] y})) =\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. le (f i) y}) -\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. f i \\<prec>[le] y})\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "have \"(\\<Sum>i<length xs. u (f i) * ?pref p (f i)) =\n                 (\\<Sum>i<n. u (f i) * ?pref p (f i)) + u (f n) * ?pref p (f n)\" (is \"_ = ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. le (f i) y}) =\n    (\\<Sum>i<n. u (f i) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n) * measure_pmf.prob p {y. le (f n) y}", "by (simp add: n)"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. le (f i) y}) =\n  (\\<Sum>i<n. u (f i) * measure_pmf.prob p {y. le (f i) y}) +\n  u (f n) * measure_pmf.prob p {y. le (f n) y}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. le (f i) y}) =\n  (\\<Sum>i<n. u (f i) * measure_pmf.prob p {y. le (f i) y}) +\n  u (f n) * measure_pmf.prob p {y. le (f n) y}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "have \"(\\<Sum>i<length xs. u (f i) * ?pref' p (f i)) =\n                 (\\<Sum>i<n. u (f (Suc i)) * ?pref' p (f (Suc i))) + u (f 0) * ?pref' p (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xs.\n        u (f i) * measure_pmf.prob p {y. f i \\<prec>[le] y}) =\n    (\\<Sum>i<n.\n        u (f (Suc i)) * measure_pmf.prob p {y. f (Suc i) \\<prec>[le] y}) +\n    u (f 0) * measure_pmf.prob p {y. f 0 \\<prec>[le] y}", "unfolding n sum.lessThan_Suc_shift"], ["proof (prove)\ngoal (1 subgoal):\n 1. u (f 0) * measure_pmf.prob p (Collect (strongly_preferred (f 0) le)) +\n    (\\<Sum>i<n.\n        u (f (Suc i)) *\n        measure_pmf.prob p (Collect (strongly_preferred (f (Suc i)) le))) =\n    (\\<Sum>i<n.\n        u (f (Suc i)) * measure_pmf.prob p {y. f (Suc i) \\<prec>[le] y}) +\n    u (f 0) * measure_pmf.prob p {y. f 0 \\<prec>[le] y}", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. f i \\<prec>[le] y}) =\n  (\\<Sum>i<n.\n      u (f (Suc i)) * measure_pmf.prob p {y. f (Suc i) \\<prec>[le] y}) +\n  u (f 0) * measure_pmf.prob p {y. f 0 \\<prec>[le] y}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs. u (f i) * measure_pmf.prob p {y. f i \\<prec>[le] y}) =\n  (\\<Sum>i<n.\n      u (f (Suc i)) * measure_pmf.prob p {y. f (Suc i) \\<prec>[le] y}) +\n  u (f 0) * measure_pmf.prob p {y. f 0 \\<prec>[le] y}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "have \"(\\<Sum>i<n. u (f (Suc i)) * ?pref' p (f (Suc i))) =\n                 (\\<Sum>i<n. u (f (Suc i)) * ?pref p (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        u (f (Suc i)) * measure_pmf.prob p {y. f (Suc i) \\<prec>[le] y}) =\n    (\\<Sum>i<n. u (f (Suc i)) * measure_pmf.prob p {y. le (f i) y})", "proof (intro sum.cong HOL.refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       u (f (Suc x)) * measure_pmf.prob p {y. f (Suc x) \\<prec>[le] y} =\n       u (f (Suc x)) * measure_pmf.prob p {y. le (f x) y}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       u (f (Suc x)) * measure_pmf.prob p {y. f (Suc x) \\<prec>[le] y} =\n       u (f (Suc x)) * measure_pmf.prob p {y. le (f x) y}", "assume i: \"i \\<in> {..<n}\""], ["proof (state)\nthis:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       u (f (Suc x)) * measure_pmf.prob p {y. f (Suc x) \\<prec>[le] y} =\n       u (f (Suc x)) * measure_pmf.prob p {y. le (f x) y}", "have \"f (Suc i) \\<prec>[le] y \\<longleftrightarrow> f i \\<preceq>[le] y\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc i) \\<prec>[le] y = le (f i) y", "proof (cases \"y \\<in> carrier\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> carrier \\<Longrightarrow> f (Suc i) \\<prec>[le] y = le (f i) y\n 2. y \\<notin> carrier \\<Longrightarrow>\n    f (Suc i) \\<prec>[le] y = le (f i) y", "assume \"y \\<in> carrier\""], ["proof (state)\nthis:\n  y \\<in> carrier\n\ngoal (2 subgoals):\n 1. y \\<in> carrier \\<Longrightarrow> f (Suc i) \\<prec>[le] y = le (f i) y\n 2. y \\<notin> carrier \\<Longrightarrow>\n    f (Suc i) \\<prec>[le] y = le (f i) y", "with weak_ranking_Union"], ["proof (chain)\npicking this:\n  \\<Union> (set (weak_ranking le)) = carrier\n  y \\<in> carrier", "obtain j where j: \"j < length xs\" \"y \\<in> xs ! j\""], ["proof (prove)\nusing this:\n  \\<Union> (set (weak_ranking le)) = carrier\n  y \\<in> carrier\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length xs; y \\<in> xs ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: set_conv_nth xs_def)"], ["proof (state)\nthis:\n  j < length xs\n  y \\<in> xs ! j\n\ngoal (2 subgoals):\n 1. y \\<in> carrier \\<Longrightarrow> f (Suc i) \\<prec>[le] y = le (f i) y\n 2. y \\<notin> carrier \\<Longrightarrow>\n    f (Suc i) \\<prec>[le] y = le (f i) y", "with weak_ranking_eqclass1[OF _ f j(2)] weak_ranking_eqclass1[OF _ j(2) f]"], ["proof (chain)\npicking this:\n  \\<lbrakk>xs ! j \\<in> set (weak_ranking le); j < length xs\\<rbrakk>\n  \\<Longrightarrow> le (f j) y\n  \\<lbrakk>xs ! j \\<in> set (weak_ranking le); j < length xs\\<rbrakk>\n  \\<Longrightarrow> le y (f j)\n  j < length xs\n  y \\<in> xs ! j", "have iff: \"le y z \\<longleftrightarrow> le (f j) z\" \"le z y \\<longleftrightarrow> le z (f j)\" for z"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs ! j \\<in> set (weak_ranking le); j < length xs\\<rbrakk>\n  \\<Longrightarrow> le (f j) y\n  \\<lbrakk>xs ! j \\<in> set (weak_ranking le); j < length xs\\<rbrakk>\n  \\<Longrightarrow> le y (f j)\n  j < length xs\n  y \\<in> xs ! j\n\ngoal (1 subgoal):\n 1. le y z = le (f j) z &&& le z y = le z (f j)", "by (auto intro: trans simp: xs_def)"], ["proof (state)\nthis:\n  le y ?z = le (f j) ?z\n  le ?z y = le ?z (f j)\n\ngoal (2 subgoals):\n 1. y \\<in> carrier \\<Longrightarrow> f (Suc i) \\<prec>[le] y = le (f i) y\n 2. y \\<notin> carrier \\<Longrightarrow>\n    f (Suc i) \\<prec>[le] y = le (f i) y", "thus ?thesis"], ["proof (prove)\nusing this:\n  le y ?z = le (f j) ?z\n  le ?z y = le ?z (f j)\n\ngoal (1 subgoal):\n 1. f (Suc i) \\<prec>[le] y = le (f i) y", "using i j"], ["proof (prove)\nusing this:\n  le y ?z = le (f j) ?z\n  le ?z y = le ?z (f j)\n  i \\<in> {..<n}\n  j < length xs\n  y \\<in> xs ! j\n\ngoal (1 subgoal):\n 1. f (Suc i) \\<prec>[le] y = le (f i) y", "unfolding n_def"], ["proof (prove)\nusing this:\n  le y ?z = le (f j) ?z\n  le ?z y = le ?z (f j)\n  i \\<in> {..<length xs - 1}\n  j < length xs\n  y \\<in> xs ! j\n\ngoal (1 subgoal):\n 1. f (Suc i) \\<prec>[le] y = le (f i) y", "by (auto simp: iff f_le strongly_preferred_def)"], ["proof (state)\nthis:\n  f (Suc i) \\<prec>[le] y = le (f i) y\n\ngoal (1 subgoal):\n 1. y \\<notin> carrier \\<Longrightarrow>\n    f (Suc i) \\<prec>[le] y = le (f i) y", "qed (insert not_outside, auto simp: strongly_preferred_def)"], ["proof (state)\nthis:\n  f (Suc i) \\<prec>[le] ?y = le (f i) ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       u (f (Suc x)) * measure_pmf.prob p {y. f (Suc x) \\<prec>[le] y} =\n       u (f (Suc x)) * measure_pmf.prob p {y. le (f x) y}", "thus \"u (f (Suc i)) * ?pref' p (f (Suc i)) = u (f (Suc i)) * ?pref p (f i)\""], ["proof (prove)\nusing this:\n  f (Suc i) \\<prec>[le] ?y = le (f i) ?y\n\ngoal (1 subgoal):\n 1. u (f (Suc i)) * measure_pmf.prob p {y. f (Suc i) \\<prec>[le] y} =\n    u (f (Suc i)) * measure_pmf.prob p {y. le (f i) y}", "by simp"], ["proof (state)\nthis:\n  u (f (Suc i)) * measure_pmf.prob p {y. f (Suc i) \\<prec>[le] y} =\n  u (f (Suc i)) * measure_pmf.prob p {y. le (f i) y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      u (f (Suc i)) * measure_pmf.prob p {y. f (Suc i) \\<prec>[le] y}) =\n  (\\<Sum>i<n. u (f (Suc i)) * measure_pmf.prob p {y. le (f i) y})\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      u (f (Suc i)) * measure_pmf.prob p {y. f (Suc i) \\<prec>[le] y}) =\n  (\\<Sum>i<n. u (f (Suc i)) * measure_pmf.prob p {y. le (f i) y})\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "have \"?sum - (\\<dots> + u (f 0) * ?pref' p (f 0)) =\n      (\\<Sum>i<n. (u (f i) - u (f (Suc i))) * ?pref p (f i)) -\n       u (f 0) * ?pref' p (f 0) + u (f n) * ?pref p (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. u (f i) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n) * measure_pmf.prob p {y. le (f n) y} -\n    ((\\<Sum>i<n. u (f (Suc i)) * measure_pmf.prob p {y. le (f i) y}) +\n     u (f 0) * measure_pmf.prob p {y. f 0 \\<prec>[le] y}) =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) -\n    u (f 0) * measure_pmf.prob p {y. f 0 \\<prec>[le] y} +\n    u (f n) * measure_pmf.prob p {y. le (f n) y}", "by (simp add: ring_distribs sum_subtractf)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. u (f i) * measure_pmf.prob p {y. le (f i) y}) +\n  u (f n) * measure_pmf.prob p {y. le (f n) y} -\n  ((\\<Sum>i<n. u (f (Suc i)) * measure_pmf.prob p {y. le (f i) y}) +\n   u (f 0) * measure_pmf.prob p {y. f 0 \\<prec>[le] y}) =\n  (\\<Sum>i<n.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) -\n  u (f 0) * measure_pmf.prob p {y. f 0 \\<prec>[le] y} +\n  u (f n) * measure_pmf.prob p {y. le (f n) y}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. u (f i) * measure_pmf.prob p {y. le (f i) y}) +\n  u (f n) * measure_pmf.prob p {y. le (f n) y} -\n  ((\\<Sum>i<n. u (f (Suc i)) * measure_pmf.prob p {y. le (f i) y}) +\n   u (f 0) * measure_pmf.prob p {y. f 0 \\<prec>[le] y}) =\n  (\\<Sum>i<n.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) -\n  u (f 0) * measure_pmf.prob p {y. f 0 \\<prec>[le] y} +\n  u (f n) * measure_pmf.prob p {y. le (f n) y}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "have \"{y. f 0 \\<prec>[le] y} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. f 0 \\<prec>[le] y} = {}", "using hd_weak_ranking[of \"f 0\"] xs_nonempty f not_outside"], ["proof (prove)\nusing this:\n  \\<lbrakk>f 0 \\<in> hd (weak_ranking le); ?y \\<in> carrier\\<rbrakk>\n  \\<Longrightarrow> le ?y (f 0)\n  xs \\<noteq> []\n  ?i < length xs \\<Longrightarrow> f ?i \\<in> xs ! ?i\n  le ?x ?y \\<Longrightarrow> ?x \\<in> carrier\n  le ?x ?y \\<Longrightarrow> ?y \\<in> carrier\n\ngoal (1 subgoal):\n 1. {y. f 0 \\<prec>[le] y} = {}", "by (auto simp: hd_conv_nth xs_def strongly_preferred_def)"], ["proof (state)\nthis:\n  {y. f 0 \\<prec>[le] y} = {}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "also"], ["proof (state)\nthis:\n  {y. f 0 \\<prec>[le] y} = {}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "have \"{y. le (f n) y} = carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. le (f n) y} = carrier", "using last_weak_ranking[of \"f n\"] xs_nonempty f not_outside"], ["proof (prove)\nusing this:\n  \\<lbrakk>f n \\<in> last (weak_ranking le); ?y \\<in> carrier\\<rbrakk>\n  \\<Longrightarrow> le (f n) ?y\n  xs \\<noteq> []\n  ?i < length xs \\<Longrightarrow> f ?i \\<in> xs ! ?i\n  le ?x ?y \\<Longrightarrow> ?x \\<in> carrier\n  le ?x ?y \\<Longrightarrow> ?y \\<in> carrier\n\ngoal (1 subgoal):\n 1. {y. le (f n) y} = carrier", "by (auto simp: last_conv_nth xs_def n_def)"], ["proof (state)\nthis:\n  {y. le (f n) y} = carrier\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "also"], ["proof (state)\nthis:\n  {y. le (f n) y} = carrier\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "from p"], ["proof (chain)\npicking this:\n  p \\<in> lotteries_on carrier", "have \"measure_pmf.prob p carrier = 1\""], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. measure_pmf.prob p carrier = 1", "by (subst measure_pmf.prob_eq_1)\n         (auto simp: AE_measure_pmf_iff lotteries_on_def)"], ["proof (state)\nthis:\n  measure_pmf.prob p carrier = 1\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation p u =\n  (\\<Sum>i<n.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) -\n  u (f 0) * measure_pmf.prob p {} +\n  u (f n) * 1", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.expectation p u =\n  (\\<Sum>i<n.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) -\n  u (f 0) * measure_pmf.prob p {} +\n  u (f n) * 1\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>i<n.\n        (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n    u (f n)", "by simp"], ["proof (state)\nthis:\n  measure_pmf.expectation p u =\n  (\\<Sum>i<n.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n  u (f n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p \\<in> lotteries_on carrier \\<Longrightarrow>\n  measure_pmf.expectation ?p u =\n  (\\<Sum>i<n.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob ?p {y. le (f i) y}) +\n  u (f n)\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>SD le p q; is_vnm_utility u\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation p u\n                         \\<le> measure_pmf.expectation q u\n 2. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "from assms[THEN this]"], ["proof (chain)\npicking this:\n  measure_pmf.expectation p u =\n  (\\<Sum>i<n.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n  u (f n)\n  measure_pmf.expectation q u =\n  (\\<Sum>i<n.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob q {y. le (f i) y}) +\n  u (f n)", "show \"measure_pmf.expectation p u \\<le> measure_pmf.expectation q u\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation p u =\n  (\\<Sum>i<n.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n  u (f n)\n  measure_pmf.expectation q u =\n  (\\<Sum>i<n.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob q {y. le (f i) y}) +\n  u (f n)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u \\<le> measure_pmf.expectation q u", "unfolding SD_preorder n_def"], ["proof (prove)\nusing this:\n  measure_pmf.expectation p u =\n  (\\<Sum>i<length xs - 1.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n  u (f (length xs - 1))\n  measure_pmf.expectation q u =\n  (\\<Sum>i<length xs - 1.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob q {y. le (f i) y}) +\n  u (f (length xs - 1))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u \\<le> measure_pmf.expectation q u", "using f'"], ["proof (prove)\nusing this:\n  measure_pmf.expectation p u =\n  (\\<Sum>i<length xs - 1.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob p {y. le (f i) y}) +\n  u (f (length xs - 1))\n  measure_pmf.expectation q u =\n  (\\<Sum>i<length xs - 1.\n      (u (f i) - u (f (Suc i))) * measure_pmf.prob q {y. le (f i) y}) +\n  u (f (length xs - 1))\n  ?i < length xs \\<Longrightarrow> f ?i \\<in> carrier\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u \\<le> measure_pmf.expectation q u", "by (auto intro!: sum_mono mult_left_mono SD' simp: utility_le_iff f_le)"], ["proof (state)\nthis:\n  measure_pmf.expectation p u \\<le> measure_pmf.expectation q u\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "assume \"\\<forall>u. is_vnm_utility u \\<longrightarrow> measure_pmf.expectation p u \\<le> measure_pmf.expectation q u\""], ["proof (state)\nthis:\n  \\<forall>u.\n     is_vnm_utility u \\<longrightarrow>\n     measure_pmf.expectation p u \\<le> measure_pmf.expectation q u\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "hence expected_utility_le: \"measure_pmf.expectation p u \\<le> measure_pmf.expectation q u\"\n    if \"is_vnm_utility u\" for u"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     is_vnm_utility u \\<longrightarrow>\n     measure_pmf.expectation p u \\<le> measure_pmf.expectation q u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u \\<le> measure_pmf.expectation q u", "using that"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     is_vnm_utility u \\<longrightarrow>\n     measure_pmf.expectation p u \\<le> measure_pmf.expectation q u\n  is_vnm_utility u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u \\<le> measure_pmf.expectation q u", "by blast"], ["proof (state)\nthis:\n  is_vnm_utility ?u \\<Longrightarrow>\n  measure_pmf.expectation p ?u \\<le> measure_pmf.expectation q ?u\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "define xs where \"xs = weak_ranking le\""], ["proof (state)\nthis:\n  xs = weak_ranking le\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "have le: \"le = of_weak_ranking xs\" and [simp]: \"is_weak_ranking xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le = of_weak_ranking xs &&& is_weak_ranking xs", "by (simp_all add: xs_def weak_ranking_total_preorder)"], ["proof (state)\nthis:\n  le = of_weak_ranking xs\n  is_weak_ranking xs\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "have carrier: \"carrier = \\<Union>(set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier = \\<Union> (set xs)", "by (simp add: xs_def weak_ranking_Union)"], ["proof (state)\nthis:\n  carrier = \\<Union> (set xs)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier", "have carrier_nonempty: \"carrier \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. carrier \\<noteq> {}", "by (auto simp: lotteries_on_def set_pmf_not_empty)"], ["proof (state)\nthis:\n  carrier \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "{"], ["proof (state)\nthis:\n  carrier \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "assume x: \"x \\<in> carrier\""], ["proof (state)\nthis:\n  x \\<in> carrier\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "let ?idx = \"\\<lambda>y. length xs - weak_ranking_index y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "have preferred_subset_carrier: \"{y. le x y} \\<subseteq> carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. le x y} \\<subseteq> carrier", "using not_outside x"], ["proof (prove)\nusing this:\n  le ?x ?y \\<Longrightarrow> ?x \\<in> carrier\n  le ?x ?y \\<Longrightarrow> ?y \\<in> carrier\n  x \\<in> carrier\n\ngoal (1 subgoal):\n 1. {y. le x y} \\<subseteq> carrier", "by auto"], ["proof (state)\nthis:\n  {y. le x y} \\<subseteq> carrier\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "have \"measure_pmf.prob p {y. le x y} / real (length xs) \\<le>\n             measure_pmf.prob q {y. le x y} / real (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob p {y. le x y} / real (length xs)\n    \\<le> measure_pmf.prob q {y. le x y} / real (length xs)", "proof (rule field_le_epsilon)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "fix \\<epsilon> :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "assume \\<epsilon>: \"\\<epsilon> > 0\""], ["proof (state)\nthis:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "define u where \"u y = indicator {y. y \\<succeq>[le] x} y + \\<epsilon> * ?idx y\" for y"], ["proof (state)\nthis:\n  u ?y =\n  indicat_real {y. le x y} ?y +\n  \\<epsilon> * real (length xs - weak_ranking_index ?y)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "have is_utility: \"is_vnm_utility u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vnm_utility u", "unfolding u_def xs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vnm_utility\n     (\\<lambda>y.\n         indicat_real (Collect (le x)) y +\n         \\<epsilon> *\n         real (length (weak_ranking le) - weak_ranking_index y))", "proof (intro vnm_utility.add_left vnm_utility.scaled utility_weak_ranking_index)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < \\<epsilon>\n 2. \\<And>y ya.\n       le y ya \\<Longrightarrow>\n       indicat_real (Collect (le x)) y\n       \\<le> indicat_real (Collect (le x)) ya", "fix y z"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < \\<epsilon>\n 2. \\<And>y ya.\n       le y ya \\<Longrightarrow>\n       indicat_real (Collect (le x)) y\n       \\<le> indicat_real (Collect (le x)) ya", "assume \"le y z\""], ["proof (state)\nthis:\n  le y z\n\ngoal (2 subgoals):\n 1. 0 < \\<epsilon>\n 2. \\<And>y ya.\n       le y ya \\<Longrightarrow>\n       indicat_real (Collect (le x)) y\n       \\<le> indicat_real (Collect (le x)) ya", "thus \"indicator {y. y \\<succeq>[le] x} y \\<le> (indicator {y. y \\<succeq>[le] x} z :: real)\""], ["proof (prove)\nusing this:\n  le y z\n\ngoal (1 subgoal):\n 1. indicat_real {y. le x y} y \\<le> indicat_real {y. le x y} z", "by (auto intro: trans simp: indicator_def split: if_splits)"], ["proof (state)\nthis:\n  indicat_real {y. le x y} y \\<le> indicat_real {y. le x y} z\n\ngoal (1 subgoal):\n 1. 0 < \\<epsilon>", "qed fact+"], ["proof (state)\nthis:\n  is_vnm_utility u\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "have \"(\\<Sum>y|le x y. pmf p y) \\<le>\n              (\\<Sum>y|le x y. pmf p y) + \\<epsilon> * (\\<Sum>y\\<in>carrier. ?idx y * pmf p y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y | le x y. pmf p y)\n    \\<le> (\\<Sum>y | le x y. pmf p y) +\n          \\<epsilon> *\n          (\\<Sum>y\\<in>carrier.\n             real (length xs - weak_ranking_index y) * pmf p y)", "using \\<epsilon>"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<Sum>y | le x y. pmf p y)\n    \\<le> (\\<Sum>y | le x y. pmf p y) +\n          \\<epsilon> *\n          (\\<Sum>y\\<in>carrier.\n             real (length xs - weak_ranking_index y) * pmf p y)", "by (auto intro!: mult_nonneg_nonneg sum_nonneg pmf_nonneg)"], ["proof (state)\nthis:\n  (\\<Sum>y | le x y. pmf p y)\n  \\<le> (\\<Sum>y | le x y. pmf p y) +\n        \\<epsilon> *\n        (\\<Sum>y\\<in>carrier.\n           real (length xs - weak_ranking_index y) * pmf p y)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "also"], ["proof (state)\nthis:\n  (\\<Sum>y | le x y. pmf p y)\n  \\<le> (\\<Sum>y | le x y. pmf p y) +\n        \\<epsilon> *\n        (\\<Sum>y\\<in>carrier.\n           real (length xs - weak_ranking_index y) * pmf p y)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "from expected_utility_le is_utility"], ["proof (chain)\npicking this:\n  is_vnm_utility ?u \\<Longrightarrow>\n  measure_pmf.expectation p ?u \\<le> measure_pmf.expectation q ?u\n  is_vnm_utility u", "have\n        \"measure_pmf.expectation p u \\<le> measure_pmf.expectation q u\""], ["proof (prove)\nusing this:\n  is_vnm_utility ?u \\<Longrightarrow>\n  measure_pmf.expectation p ?u \\<le> measure_pmf.expectation q ?u\n  is_vnm_utility u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u \\<le> measure_pmf.expectation q u", "."], ["proof (state)\nthis:\n  measure_pmf.expectation p u \\<le> measure_pmf.expectation q u\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "with assms"], ["proof (chain)\npicking this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  measure_pmf.expectation p u \\<le> measure_pmf.expectation q u", "have \"(\\<Sum>a\\<in>carrier. u a * pmf p a) \\<le> (\\<Sum>a\\<in>carrier. u a * pmf q a)\""], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  measure_pmf.expectation p u \\<le> measure_pmf.expectation q u\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>carrier. u a * pmf p a)\n    \\<le> (\\<Sum>a\\<in>carrier. u a * pmf q a)", "by (subst (asm) (1 2) integral_measure_pmf[OF finite_carrier])\n           (auto simp: lotteries_on_def set_pmf_eq ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>carrier. u a * pmf p a)\n  \\<le> (\\<Sum>a\\<in>carrier. u a * pmf q a)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "hence \"(\\<Sum>y|le x y. pmf p y) + \\<epsilon> * (\\<Sum>y\\<in>carrier. ?idx y * pmf p y) \\<le>\n             (\\<Sum>y|le x y. pmf q y) + \\<epsilon> * (\\<Sum>y\\<in>carrier. ?idx y * pmf q y)\""], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>carrier. u a * pmf p a)\n  \\<le> (\\<Sum>a\\<in>carrier. u a * pmf q a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y | le x y. pmf p y) +\n    \\<epsilon> *\n    (\\<Sum>y\\<in>carrier. real (length xs - weak_ranking_index y) * pmf p y)\n    \\<le> (\\<Sum>y | le x y. pmf q y) +\n          \\<epsilon> *\n          (\\<Sum>y\\<in>carrier.\n             real (length xs - weak_ranking_index y) * pmf q y)", "using x preferred_subset_carrier not_outside"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>carrier. u a * pmf p a)\n  \\<le> (\\<Sum>a\\<in>carrier. u a * pmf q a)\n  x \\<in> carrier\n  {y. le x y} \\<subseteq> carrier\n  le ?x ?y \\<Longrightarrow> ?x \\<in> carrier\n  le ?x ?y \\<Longrightarrow> ?y \\<in> carrier\n\ngoal (1 subgoal):\n 1. (\\<Sum>y | le x y. pmf p y) +\n    \\<epsilon> *\n    (\\<Sum>y\\<in>carrier. real (length xs - weak_ranking_index y) * pmf p y)\n    \\<le> (\\<Sum>y | le x y. pmf q y) +\n          \\<epsilon> *\n          (\\<Sum>y\\<in>carrier.\n             real (length xs - weak_ranking_index y) * pmf q y)", "by (simp add: u_def sum.distrib finite_carrier algebra_simps sum_distrib_left Int_absorb1 cong: rev_conj_cong)"], ["proof (state)\nthis:\n  (\\<Sum>y | le x y. pmf p y) +\n  \\<epsilon> *\n  (\\<Sum>y\\<in>carrier. real (length xs - weak_ranking_index y) * pmf p y)\n  \\<le> (\\<Sum>y | le x y. pmf q y) +\n        \\<epsilon> *\n        (\\<Sum>y\\<in>carrier.\n           real (length xs - weak_ranking_index y) * pmf q y)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "also"], ["proof (state)\nthis:\n  (\\<Sum>y | le x y. pmf p y) +\n  \\<epsilon> *\n  (\\<Sum>y\\<in>carrier. real (length xs - weak_ranking_index y) * pmf p y)\n  \\<le> (\\<Sum>y | le x y. pmf q y) +\n        \\<epsilon> *\n        (\\<Sum>y\\<in>carrier.\n           real (length xs - weak_ranking_index y) * pmf q y)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "have \"(\\<Sum>y\\<in>carrier. ?idx y * pmf q y) \\<le> (\\<Sum>y\\<in>carrier. length xs * pmf q y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>carrier. real (length xs - weak_ranking_index y) * pmf q y)\n    \\<le> (\\<Sum>y\\<in>carrier. real (length xs) * pmf q y)", "by (intro sum_mono mult_right_mono) (simp_all add: pmf_nonneg)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>carrier. real (length xs - weak_ranking_index y) * pmf q y)\n  \\<le> (\\<Sum>y\\<in>carrier. real (length xs) * pmf q y)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>carrier. real (length xs - weak_ranking_index y) * pmf q y)\n  \\<le> (\\<Sum>y\\<in>carrier. real (length xs) * pmf q y)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "have \"\\<dots> = measure_pmf.expectation q (\\<lambda>_. length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>carrier. real (length xs) * pmf q y) =\n    measure_pmf.expectation q (\\<lambda>x. real (length xs))", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>carrier. real (length xs) * pmf q y) =\n    measure_pmf.expectation q (\\<lambda>x. real (length xs))", "by (subst integral_measure_pmf[OF finite_carrier])\n                       (auto simp: lotteries_on_def set_pmf_eq ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>carrier. real (length xs) * pmf q y) =\n  measure_pmf.expectation q (\\<lambda>x. real (length xs))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>carrier. real (length xs) * pmf q y) =\n  measure_pmf.expectation q (\\<lambda>x. real (length xs))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "have \"\\<dots> = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation q (\\<lambda>x. real (length xs)) =\n    real (length xs)", "by simp"], ["proof (state)\nthis:\n  measure_pmf.expectation q (\\<lambda>x. real (length xs)) =\n  real (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation q (\\<lambda>x. real (length xs)) =\n  real (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "have \"(\\<Sum>y | le x y. pmf p y) = measure_pmf.prob p {y. le x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y | le x y. pmf p y) = measure_pmf.prob p {y. le x y}", "using finite_subset[OF preferred_subset_carrier finite_carrier]"], ["proof (prove)\nusing this:\n  finite {y. le x y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y | le x y. pmf p y) = measure_pmf.prob p {y. le x y}", "by (simp add: measure_measure_pmf_finite)"], ["proof (state)\nthis:\n  (\\<Sum>y | le x y. pmf p y) = measure_pmf.prob p {y. le x y}\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "also"], ["proof (state)\nthis:\n  (\\<Sum>y | le x y. pmf p y) = measure_pmf.prob p {y. le x y}\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "have \"(\\<Sum>y | le x y. pmf q y) = measure_pmf.prob q {y. le x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y | le x y. pmf q y) = measure_pmf.prob q {y. le x y}", "using finite_subset[OF preferred_subset_carrier finite_carrier]"], ["proof (prove)\nusing this:\n  finite {y. le x y}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y | le x y. pmf q y) = measure_pmf.prob q {y. le x y}", "by (simp add: measure_measure_pmf_finite)"], ["proof (state)\nthis:\n  (\\<Sum>y | le x y. pmf q y) = measure_pmf.prob q {y. le x y}\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob p {y. le x y} / real (length xs)\n       \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + e", "finally"], ["proof (chain)\npicking this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      (\\<Sum>y | le x y. pmf q y) + \\<epsilon> * xa\n      \\<le> (\\<Sum>y | le x y. pmf q y) + \\<epsilon> * y) \\<Longrightarrow>\n  measure_pmf.prob p {y. le x y}\n  \\<le> measure_pmf.prob q {y. le x y} + \\<epsilon> * real (length xs)", "show \"measure_pmf.prob p {y. le x y} / length xs \\<le>\n                      measure_pmf.prob q {y. le x y} / length xs + \\<epsilon>\""], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      (\\<Sum>y | le x y. pmf q y) + \\<epsilon> * xa\n      \\<le> (\\<Sum>y | le x y. pmf q y) + \\<epsilon> * y) \\<Longrightarrow>\n  measure_pmf.prob p {y. le x y}\n  \\<le> measure_pmf.prob q {y. le x y} + \\<epsilon> * real (length xs)\n\ngoal (1 subgoal):\n 1. measure_pmf.prob p {y. le x y} / real (length xs)\n    \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + \\<epsilon>", "using \\<epsilon>"], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      (\\<Sum>y | le x y. pmf q y) + \\<epsilon> * xa\n      \\<le> (\\<Sum>y | le x y. pmf q y) + \\<epsilon> * y) \\<Longrightarrow>\n  measure_pmf.prob p {y. le x y}\n  \\<le> measure_pmf.prob q {y. le x y} + \\<epsilon> * real (length xs)\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. measure_pmf.prob p {y. le x y} / real (length xs)\n    \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + \\<epsilon>", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  measure_pmf.prob p {y. le x y} / real (length xs)\n  \\<le> measure_pmf.prob q {y. le x y} / real (length xs) + \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  measure_pmf.prob p {y. le x y} / real (length xs)\n  \\<le> measure_pmf.prob q {y. le x y} / real (length xs)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "moreover"], ["proof (state)\nthis:\n  measure_pmf.prob p {y. le x y} / real (length xs)\n  \\<le> measure_pmf.prob q {y. le x y} / real (length xs)\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "from carrier_nonempty carrier"], ["proof (chain)\npicking this:\n  carrier \\<noteq> {}\n  carrier = \\<Union> (set xs)", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  carrier \\<noteq> {}\n  carrier = \\<Union> (set xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "ultimately"], ["proof (chain)\npicking this:\n  measure_pmf.prob p {y. le x y} / real (length xs)\n  \\<le> measure_pmf.prob q {y. le x y} / real (length xs)\n  xs \\<noteq> []", "have \"measure_pmf.prob p {y. le x y} \\<le>\n                       measure_pmf.prob q {y. le x y}\""], ["proof (prove)\nusing this:\n  measure_pmf.prob p {y. le x y} / real (length xs)\n  \\<le> measure_pmf.prob q {y. le x y} / real (length xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. measure_pmf.prob p {y. le x y} \\<le> measure_pmf.prob q {y. le x y}", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  measure_pmf.prob p {y. le x y} \\<le> measure_pmf.prob q {y. le x y}\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> carrier \\<Longrightarrow>\n  measure_pmf.prob p {y. le ?x2 y} \\<le> measure_pmf.prob q {y. le ?x2 y}\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       is_vnm_utility u \\<longrightarrow>\n       measure_pmf.expectation p u\n       \\<le> measure_pmf.expectation q u \\<Longrightarrow>\n    SD le p q", "with assms"], ["proof (chain)\npicking this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  ?x2 \\<in> carrier \\<Longrightarrow>\n  measure_pmf.prob p {y. le ?x2 y} \\<le> measure_pmf.prob q {y. le ?x2 y}", "show \"p \\<preceq>[SD(le)] q\""], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  ?x2 \\<in> carrier \\<Longrightarrow>\n  measure_pmf.prob p {y. le ?x2 y} \\<le> measure_pmf.prob q {y. le ?x2 y}\n\ngoal (1 subgoal):\n 1. SD le p q", "unfolding SD_preorder preferred_alts_def"], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  ?x2 \\<in> carrier \\<Longrightarrow>\n  measure_pmf.prob p {y. le ?x2 y} \\<le> measure_pmf.prob q {y. le ?x2 y}\n\ngoal (1 subgoal):\n 1. q \\<in> lotteries_on carrier \\<and>\n    p \\<in> lotteries_on carrier \\<and>\n    (\\<forall>x\\<in>carrier.\n        measure_pmf.prob p (Collect (le x))\n        \\<le> measure_pmf.prob q (Collect (le x)))", "by blast"], ["proof (state)\nthis:\n  SD le p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_strict_SD_iff:\n  assumes \"p \\<in> lotteries_on carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"\\<not>(p \\<prec>[SD(le)] q) \\<longleftrightarrow>\n             (\\<exists>u. is_vnm_utility u \\<and> measure_pmf.expectation q u \\<le> measure_pmf.expectation p u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> p \\<prec>[SD le] q) =\n    (\\<exists>u.\n        is_vnm_utility u \\<and>\n        measure_pmf.expectation q u \\<le> measure_pmf.expectation p u)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> p \\<prec>[SD le] q \\<Longrightarrow>\n    \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n 2. \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u\n       \\<le> measure_pmf.expectation p u \\<Longrightarrow>\n    \\<not> p \\<prec>[SD le] q", "let ?E = \"measure_pmf.expectation :: 'a pmf \\<Rightarrow> _ \\<Rightarrow> real\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> p \\<prec>[SD le] q \\<Longrightarrow>\n    \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n 2. \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u\n       \\<le> measure_pmf.expectation p u \\<Longrightarrow>\n    \\<not> p \\<prec>[SD le] q", "assume \"\\<exists>u. is_vnm_utility u \\<and> ?E p u \\<ge> ?E q u\""], ["proof (state)\nthis:\n  \\<exists>u.\n     is_vnm_utility u \\<and>\n     measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n\ngoal (2 subgoals):\n 1. \\<not> p \\<prec>[SD le] q \\<Longrightarrow>\n    \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n 2. \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u\n       \\<le> measure_pmf.expectation p u \\<Longrightarrow>\n    \\<not> p \\<prec>[SD le] q", "then"], ["proof (chain)\npicking this:\n  \\<exists>u.\n     is_vnm_utility u \\<and>\n     measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "obtain u where u: \"is_vnm_utility u\" \"?E p u \\<ge> ?E q u\""], ["proof (prove)\nusing this:\n  \\<exists>u.\n     is_vnm_utility u \\<and>\n     measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>is_vnm_utility u;\n         measure_pmf.expectation q u\n         \\<le> measure_pmf.expectation p u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_vnm_utility u\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n\ngoal (2 subgoals):\n 1. \\<not> p \\<prec>[SD le] q \\<Longrightarrow>\n    \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n 2. \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u\n       \\<le> measure_pmf.expectation p u \\<Longrightarrow>\n    \\<not> p \\<prec>[SD le] q", "interpret u: vnm_utility carrier le u"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vnm_utility u", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> p \\<prec>[SD le] q \\<Longrightarrow>\n    \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n 2. \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u\n       \\<le> measure_pmf.expectation p u \\<Longrightarrow>\n    \\<not> p \\<prec>[SD le] q", "show \"\\<not> p \\<prec>[SD le] q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p \\<prec>[SD le] q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "assume less: \"p \\<prec>[SD le] q\""], ["proof (state)\nthis:\n  p \\<prec>[SD le] q\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  p \\<prec>[SD le] q", "have pq: \"?E p u \\<le> ?E q u\" if \"is_vnm_utility u\" for u"], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  p \\<prec>[SD le] q\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u \\<le> measure_pmf.expectation q u", "using that"], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  p \\<prec>[SD le] q\n  is_vnm_utility u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u \\<le> measure_pmf.expectation q u", "by (auto simp: SD_iff_expected_utilities_le strongly_preferred_def)"], ["proof (state)\nthis:\n  is_vnm_utility ?u \\<Longrightarrow>\n  measure_pmf.expectation p ?u \\<le> measure_pmf.expectation q ?u\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "with u"], ["proof (chain)\npicking this:\n  is_vnm_utility u\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n  is_vnm_utility ?u \\<Longrightarrow>\n  measure_pmf.expectation p ?u \\<le> measure_pmf.expectation q ?u", "have u_eq: \"?E p u = ?E q u\""], ["proof (prove)\nusing this:\n  is_vnm_utility u\n  measure_pmf.expectation q u \\<le> measure_pmf.expectation p u\n  is_vnm_utility ?u \\<Longrightarrow>\n  measure_pmf.expectation p ?u \\<le> measure_pmf.expectation q ?u\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u = measure_pmf.expectation q u", "by (intro antisym) simp_all"], ["proof (state)\nthis:\n  measure_pmf.expectation p u = measure_pmf.expectation q u\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "from less assms"], ["proof (chain)\npicking this:\n  p \\<prec>[SD le] q\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier", "obtain u' where u': \"is_vnm_utility u'\" \"?E p u' < ?E q u'\""], ["proof (prove)\nusing this:\n  p \\<prec>[SD le] q\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>is_vnm_utility u';\n         measure_pmf.expectation p u'\n         < measure_pmf.expectation q u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SD_iff_expected_utilities_le strongly_preferred_def not_le)"], ["proof (state)\nthis:\n  is_vnm_utility u'\n  measure_pmf.expectation p u' < measure_pmf.expectation q u'\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "interpret u': vnm_utility carrier le u'"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vnm_utility u'", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "have \"\\<exists>\\<epsilon>>0. is_vnm_utility (\\<lambda>x. u x - \\<epsilon> * u' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       is_vnm_utility (\\<lambda>x. u x - \\<epsilon> * u' x)", "by (intro u.diff_epsilon antisym u'.utility_le)"], ["proof (state)\nthis:\n  \\<exists>\\<epsilon>>0.\n     is_vnm_utility (\\<lambda>x. u x - \\<epsilon> * u' x)\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<epsilon>>0.\n     is_vnm_utility (\\<lambda>x. u x - \\<epsilon> * u' x)", "guess \\<epsilon>"], ["proof (prove)\nusing this:\n  \\<exists>\\<epsilon>>0.\n     is_vnm_utility (\\<lambda>x. u x - \\<epsilon> * u' x)\n\ngoal (1 subgoal):\n 1. thesis", "by (elim exE conjE)"], ["proof (state)\nthis:\n  0 < \\<epsilon>\n  is_vnm_utility (\\<lambda>x. u x - \\<epsilon> * u' x)\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "note \\<epsilon> = this"], ["proof (state)\nthis:\n  0 < \\<epsilon>\n  is_vnm_utility (\\<lambda>x. u x - \\<epsilon> * u' x)\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "define u'' where \"u'' x = u x - \\<epsilon> * u' x\" for x"], ["proof (state)\nthis:\n  u'' ?x = u ?x - \\<epsilon> * u' ?x\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "interpret u'': vnm_utility carrier le u''"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vnm_utility u''", "unfolding u''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_vnm_utility (\\<lambda>x. u x - \\<epsilon> * u' x)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "have exp_u'': \"?E p u'' = ?E p u - \\<epsilon> * ?E p u'\" if \"p \\<in> lotteries_on carrier\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u'' =\n    measure_pmf.expectation p u - \\<epsilon> * measure_pmf.expectation p u'", "using that"], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u'' =\n    measure_pmf.expectation p u - \\<epsilon> * measure_pmf.expectation p u'", "by (subst (1 2 3) integral_measure_pmf[of carrier])\n         (auto simp: lotteries_on_def u''_def algebra_simps sum_subtractf sum_distrib_left)"], ["proof (state)\nthis:\n  ?p \\<in> lotteries_on carrier \\<Longrightarrow>\n  measure_pmf.expectation ?p u'' =\n  measure_pmf.expectation ?p u - \\<epsilon> * measure_pmf.expectation ?p u'\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "from assms \\<epsilon>"], ["proof (chain)\npicking this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  0 < \\<epsilon>\n  is_vnm_utility (\\<lambda>x. u x - \\<epsilon> * u' x)", "have \"?E p u'' > ?E q u''\""], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n  q \\<in> lotteries_on carrier\n  0 < \\<epsilon>\n  is_vnm_utility (\\<lambda>x. u x - \\<epsilon> * u' x)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation q u'' < measure_pmf.expectation p u''", "by (simp_all add: exp_u'' algebra_simps u_eq u')"], ["proof (state)\nthis:\n  measure_pmf.expectation q u'' < measure_pmf.expectation p u''\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q \\<Longrightarrow> False", "with pq[OF u''.vnm_utility_axioms]"], ["proof (chain)\npicking this:\n  measure_pmf.expectation p u'' \\<le> measure_pmf.expectation q u''\n  measure_pmf.expectation q u'' < measure_pmf.expectation p u''", "show False"], ["proof (prove)\nusing this:\n  measure_pmf.expectation p u'' \\<le> measure_pmf.expectation q u''\n  measure_pmf.expectation q u'' < measure_pmf.expectation p u''\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> p \\<prec>[SD le] q\n\ngoal (1 subgoal):\n 1. \\<not> p \\<prec>[SD le] q \\<Longrightarrow>\n    \\<exists>u.\n       is_vnm_utility u \\<and>\n       measure_pmf.expectation q u \\<le> measure_pmf.expectation p u", "qed (insert assms utility_weak_ranking_index,\n     auto simp: strongly_preferred_def SD_iff_expected_utilities_le not_le not_less intro: antisym)"], ["", "lemma strict_SD_iff:\n  assumes \"p \\<in> lotteries_on carrier\" \"q \\<in> lotteries_on carrier\"\n  shows   \"(p \\<prec>[SD(le)] q) \\<longleftrightarrow>\n             (\\<forall>u. is_vnm_utility u \\<longrightarrow> measure_pmf.expectation p u < measure_pmf.expectation q u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q =\n    (\\<forall>u.\n        is_vnm_utility u \\<longrightarrow>\n        measure_pmf.expectation p u < measure_pmf.expectation q u)", "using not_strict_SD_iff[OF assms]"], ["proof (prove)\nusing this:\n  (\\<not> p \\<prec>[SD le] q) =\n  (\\<exists>u.\n      is_vnm_utility u \\<and>\n      measure_pmf.expectation q u \\<le> measure_pmf.expectation p u)\n\ngoal (1 subgoal):\n 1. p \\<prec>[SD le] q =\n    (\\<forall>u.\n        is_vnm_utility u \\<longrightarrow>\n        measure_pmf.expectation p u < measure_pmf.expectation q u)", "by auto"], ["", "end"], ["", "end"]]}