{"file_name": "/home/qj213/afp-2021-10-22/thys/Randomised_Social_Choice/Utility_Functions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Randomised_Social_Choice", "problem_names": ["lemma utility_le: \"x \\<preceq>[le] y \\<Longrightarrow> u x \\<le> u y\"", "lemma utility_less_iff:\n  \"x \\<in> carrier \\<Longrightarrow> y \\<in> carrier \\<Longrightarrow> u x < u y \\<longleftrightarrow> x \\<prec>[le] y\"", "lemma utility_less: \"x \\<prec>[le] y \\<Longrightarrow> u x < u y\"", "lemma expected_utility_weak_ranking:\n  assumes \"p \\<in> lotteries_on carrier\"\n  shows   \"measure_pmf.expectation p u =\n             (\\<Sum>A\\<leftarrow>weak_ranking le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)\"", "lemma scaled: \"c > 0 \\<Longrightarrow> vnm_utility carrier le (\\<lambda>x. c * u x)\"", "lemma add_right:\n  assumes \"\\<And>x y. le x y \\<Longrightarrow> f x \\<le> f y\"\n  shows   \"vnm_utility carrier le (\\<lambda>x. u x + f x)\"", "lemma add_left:\n  \"(\\<And>x y. le x y \\<Longrightarrow> f x \\<le> f y) \\<Longrightarrow> vnm_utility carrier le (\\<lambda>x. f x + u x)\"", "lemma add_epsilon:\n  assumes A: \"\\<And>x y. le x y \\<Longrightarrow> le y x \\<Longrightarrow> f x = f y\"\n  shows \"\\<exists>\\<epsilon>>0. vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)\"", "lemma diff_epsilon:\n  assumes \"\\<And>x y. le x y \\<Longrightarrow> le y x \\<Longrightarrow> f x = f y\"\n  shows \"\\<exists>\\<epsilon>>0. vnm_utility carrier le (\\<lambda>x. u x - \\<epsilon> * f x)\""], "translations": [["", "lemma utility_le: \"x \\<preceq>[le] y \\<Longrightarrow> u x \\<le> u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le x y \\<Longrightarrow> u x \\<le> u y", "using not_outside[of x y] utility_le_iff"], ["proof (prove)\nusing this:\n  le x y \\<Longrightarrow> x \\<in> carrier\n  le x y \\<Longrightarrow> y \\<in> carrier\n  \\<lbrakk>?x \\<in> carrier; ?y \\<in> carrier\\<rbrakk>\n  \\<Longrightarrow> (u ?x \\<le> u ?y) = le ?x ?y\n\ngoal (1 subgoal):\n 1. le x y \\<Longrightarrow> u x \\<le> u y", "by simp"], ["", "lemma utility_less_iff:\n  \"x \\<in> carrier \\<Longrightarrow> y \\<in> carrier \\<Longrightarrow> u x < u y \\<longleftrightarrow> x \\<prec>[le] y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n    \\<Longrightarrow> (u x < u y) = x \\<prec>[le] y", "using utility_le_iff[of x y] utility_le_iff[of y x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n  \\<Longrightarrow> (u x \\<le> u y) = le x y\n  \\<lbrakk>y \\<in> carrier; x \\<in> carrier\\<rbrakk>\n  \\<Longrightarrow> (u y \\<le> u x) = le y x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n    \\<Longrightarrow> (u x < u y) = x \\<prec>[le] y", "by (auto simp: strongly_preferred_def)"], ["", "lemma utility_less: \"x \\<prec>[le] y \\<Longrightarrow> u x < u y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<prec>[le] y \\<Longrightarrow> u x < u y", "using not_outside[of x y] utility_less_iff"], ["proof (prove)\nusing this:\n  le x y \\<Longrightarrow> x \\<in> carrier\n  le x y \\<Longrightarrow> y \\<in> carrier\n  \\<lbrakk>?x \\<in> carrier; ?y \\<in> carrier\\<rbrakk>\n  \\<Longrightarrow> (u ?x < u ?y) = ?x \\<prec>[le] ?y\n\ngoal (1 subgoal):\n 1. x \\<prec>[le] y \\<Longrightarrow> u x < u y", "by (simp add: strongly_preferred_def)"], ["", "text \\<open>\n  The following lemma allows us to compute the expected utility by summing\n  over all indifference classes, using the fact that alternatives in the same\n  indifference class must have the same utility.\n\\<close>"], ["", "lemma expected_utility_weak_ranking:\n  assumes \"p \\<in> lotteries_on carrier\"\n  shows   \"measure_pmf.expectation p u =\n             (\\<Sum>A\\<leftarrow>weak_ranking le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> lotteries_on carrier", "have \"measure_pmf.expectation p u = (\\<Sum>a\\<in>carrier. u a * pmf p a)\""], ["proof (prove)\nusing this:\n  p \\<in> lotteries_on carrier\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u = (\\<Sum>a\\<in>carrier. u a * pmf p a)", "by (subst integral_measure_pmf[OF finite_carrier])\n       (auto simp: lotteries_on_def ac_simps)"], ["proof (state)\nthis:\n  measure_pmf.expectation p u = (\\<Sum>a\\<in>carrier. u a * pmf p a)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation p u = (\\<Sum>a\\<in>carrier. u a * pmf p a)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "have carrier: \"carrier = \\<Union>(set (weak_ranking le))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier = \\<Union> (set (weak_ranking le))", "by (simp add: weak_ranking_Union)"], ["proof (state)\nthis:\n  carrier = \\<Union> (set (weak_ranking le))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "also"], ["proof (state)\nthis:\n  carrier = \\<Union> (set (weak_ranking le))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "from carrier"], ["proof (chain)\npicking this:\n  carrier = \\<Union> (set (weak_ranking le))", "have finite: \"finite A\" if \"A \\<in> set (weak_ranking le)\" for A"], ["proof (prove)\nusing this:\n  carrier = \\<Union> (set (weak_ranking le))\n\ngoal (1 subgoal):\n 1. finite A", "using that"], ["proof (prove)\nusing this:\n  carrier = \\<Union> (set (weak_ranking le))\n  A \\<in> set (weak_ranking le)\n\ngoal (1 subgoal):\n 1. finite A", "by (blast intro!: finite_subset[OF _ finite_carrier, of A])"], ["proof (state)\nthis:\n  ?A \\<in> set (weak_ranking le) \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "hence \"(\\<Sum>a\\<in>\\<Union>(set (weak_ranking le)). u a * pmf p a) =\n           (\\<Sum>A\\<leftarrow>weak_ranking le. \\<Sum>a\\<in>A. u a * pmf p a)\" (is \"_ = sum_list ?xs\")"], ["proof (prove)\nusing this:\n  ?A \\<in> set (weak_ranking le) \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>\\<Union> (set (weak_ranking le)). u a * pmf p a) =\n    sum_list (map (sum (\\<lambda>a. u a * pmf p a)) (weak_ranking le))", "using weak_ranking_total_preorder"], ["proof (prove)\nusing this:\n  ?A \\<in> set (weak_ranking le) \\<Longrightarrow> finite ?A\n  is_weak_ranking (weak_ranking le)\n  of_weak_ranking (weak_ranking le) = le\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>\\<Union> (set (weak_ranking le)). u a * pmf p a) =\n    sum_list (map (sum (\\<lambda>a. u a * pmf p a)) (weak_ranking le))", "by (subst sum.Union_disjoint)\n       (auto simp: is_weak_ranking_iff disjoint_def sum.distinct_set_conv_list)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>\\<Union> (set (weak_ranking le)). u a * pmf p a) =\n  sum_list (map (sum (\\<lambda>a. u a * pmf p a)) (weak_ranking le))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>\\<Union> (set (weak_ranking le)). u a * pmf p a) =\n  sum_list (map (sum (\\<lambda>a. u a * pmf p a)) (weak_ranking le))\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "have \"?xs  = map (\\<lambda>A. \\<Sum>a\\<in>A. u (SOME a. a\\<in>A) * pmf p a) (weak_ranking le)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sum (\\<lambda>a. u a * pmf p a)) (weak_ranking le) =\n    map (\\<lambda>A. \\<Sum>a\\<in>A. u (SOME a. a \\<in> A) * pmf p a)\n     (weak_ranking le)", "proof (intro map_cong HOL.refl sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set (weak_ranking le); xa \\<in> x\\<rbrakk>\n       \\<Longrightarrow> u xa * pmf p xa = u (SOME a. a \\<in> x) * pmf p xa", "fix x A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set (weak_ranking le); xa \\<in> x\\<rbrakk>\n       \\<Longrightarrow> u xa * pmf p xa = u (SOME a. a \\<in> x) * pmf p xa", "assume x: \"x \\<in> A\" and A: \"A \\<in> set (weak_ranking le)\""], ["proof (state)\nthis:\n  x \\<in> A\n  A \\<in> set (weak_ranking le)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set (weak_ranking le); xa \\<in> x\\<rbrakk>\n       \\<Longrightarrow> u xa * pmf p xa = u (SOME a. a \\<in> x) * pmf p xa", "have \"(SOME x. x \\<in> A) \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> A) \\<in> A", "by (rule someI_ex) (insert x, blast)"], ["proof (state)\nthis:\n  (SOME x. x \\<in> A) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set (weak_ranking le); xa \\<in> x\\<rbrakk>\n       \\<Longrightarrow> u xa * pmf p xa = u (SOME a. a \\<in> x) * pmf p xa", "from weak_ranking_eqclass1[OF A x this] weak_ranking_eqclass1[OF A this x] x this A"], ["proof (chain)\npicking this:\n  le x (SOME x. x \\<in> A)\n  le (SOME x. x \\<in> A) x\n  x \\<in> A\n  (SOME x. x \\<in> A) \\<in> A\n  A \\<in> set (weak_ranking le)", "have \"u x = u (SOME x. x \\<in> A)\""], ["proof (prove)\nusing this:\n  le x (SOME x. x \\<in> A)\n  le (SOME x. x \\<in> A) x\n  x \\<in> A\n  (SOME x. x \\<in> A) \\<in> A\n  A \\<in> set (weak_ranking le)\n\ngoal (1 subgoal):\n 1. u x = u (SOME x. x \\<in> A)", "by (intro antisym; subst utility_le_iff) (auto simp: carrier)"], ["proof (state)\nthis:\n  u x = u (SOME x. x \\<in> A)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set (weak_ranking le); xa \\<in> x\\<rbrakk>\n       \\<Longrightarrow> u xa * pmf p xa = u (SOME a. a \\<in> x) * pmf p xa", "thus \"u x * pmf p x = u (SOME x. x \\<in> A) * pmf p x\""], ["proof (prove)\nusing this:\n  u x = u (SOME x. x \\<in> A)\n\ngoal (1 subgoal):\n 1. u x * pmf p x = u (SOME x. x \\<in> A) * pmf p x", "by simp"], ["proof (state)\nthis:\n  u x * pmf p x = u (SOME x. x \\<in> A) * pmf p x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (sum (\\<lambda>a. u a * pmf p a)) (weak_ranking le) =\n  map (\\<lambda>A. \\<Sum>a\\<in>A. u (SOME a. a \\<in> A) * pmf p a)\n   (weak_ranking le)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "also"], ["proof (state)\nthis:\n  map (sum (\\<lambda>a. u a * pmf p a)) (weak_ranking le) =\n  map (\\<lambda>A. \\<Sum>a\\<in>A. u (SOME a. a \\<in> A) * pmf p a)\n   (weak_ranking le)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "have \"\\<dots> = map (\\<lambda>A. u (SOME a. a \\<in> A) * measure_pmf.prob p A) (weak_ranking le)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>A. \\<Sum>a\\<in>A. u (SOME a. a \\<in> A) * pmf p a)\n     (weak_ranking le) =\n    map (\\<lambda>A. u (SOME a. a \\<in> A) * measure_pmf.prob p A)\n     (weak_ranking le)", "using finite"], ["proof (prove)\nusing this:\n  ?A \\<in> set (weak_ranking le) \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. map (\\<lambda>A. \\<Sum>a\\<in>A. u (SOME a. a \\<in> A) * pmf p a)\n     (weak_ranking le) =\n    map (\\<lambda>A. u (SOME a. a \\<in> A) * measure_pmf.prob p A)\n     (weak_ranking le)", "by (intro map_cong HOL.refl)\n                    (auto simp: sum_distrib_left measure_measure_pmf_finite)"], ["proof (state)\nthis:\n  map (\\<lambda>A. \\<Sum>a\\<in>A. u (SOME a. a \\<in> A) * pmf p a)\n   (weak_ranking le) =\n  map (\\<lambda>A. u (SOME a. a \\<in> A) * measure_pmf.prob p A)\n   (weak_ranking le)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation p u =\n  (\\<Sum>A\\<leftarrow>weak_ranking\n                       le. u (SOME a. a \\<in> A) * measure_pmf.prob p A)", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.expectation p u =\n  (\\<Sum>A\\<leftarrow>weak_ranking\n                       le. u (SOME a. a \\<in> A) * measure_pmf.prob p A)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation p u =\n    (\\<Sum>A\\<leftarrow>weak_ranking\n                         le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)", "."], ["proof (state)\nthis:\n  measure_pmf.expectation p u =\n  (\\<Sum>A\\<leftarrow>weak_ranking\n                       le. u (SOME x. x \\<in> A) * measure_pmf.prob p A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scaled: \"c > 0 \\<Longrightarrow> vnm_utility carrier le (\\<lambda>x. c * u x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow> vnm_utility carrier le (\\<lambda>x. c * u x)", "by unfold_locales (insert utility_le_iff, auto)"], ["", "lemma add_right:\n  assumes \"\\<And>x y. le x y \\<Longrightarrow> f x \\<le> f y\"\n  shows   \"vnm_utility carrier le (\\<lambda>x. u x + f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vnm_utility carrier le (\\<lambda>x. u x + f x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> (u x + f x \\<le> u y + f y) = le x y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> (u x + f x \\<le> u y + f y) = le x y", "assume xy: \"x \\<in> carrier\" \"y \\<in> carrier\""], ["proof (state)\nthis:\n  x \\<in> carrier\n  y \\<in> carrier\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> (u x + f x \\<le> u y + f y) = le x y", "from assms[of x y] utility_le_iff[OF xy] assms[of y x] utility_le_iff[OF xy(2,1)]"], ["proof (chain)\npicking this:\n  le x y \\<Longrightarrow> f x \\<le> f y\n  (u x \\<le> u y) = le x y\n  le y x \\<Longrightarrow> f y \\<le> f x\n  (u y \\<le> u x) = le y x", "show \"(u x + f x \\<le> u y + f y) = le x y\""], ["proof (prove)\nusing this:\n  le x y \\<Longrightarrow> f x \\<le> f y\n  (u x \\<le> u y) = le x y\n  le y x \\<Longrightarrow> f y \\<le> f x\n  (u y \\<le> u x) = le y x\n\ngoal (1 subgoal):\n 1. (u x + f x \\<le> u y + f y) = le x y", "by auto"], ["proof (state)\nthis:\n  (u x + f x \\<le> u y + f y) = le x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_left:\n  \"(\\<And>x y. le x y \\<Longrightarrow> f x \\<le> f y) \\<Longrightarrow> vnm_utility carrier le (\\<lambda>x. f x + u x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. le x y \\<Longrightarrow> f x \\<le> f y) \\<Longrightarrow>\n    vnm_utility carrier le (\\<lambda>x. f x + u x)", "by (subst add.commute) (rule add_right)"], ["", "text \\<open>\n  Given a consistent utility function, any function that assigns equal values to\n  equivalent alternatives can be added to it (scaled with a sufficiently small @{term \"\\<epsilon>\"}),\n  again yielding a consistent utility function.\n\\<close>"], ["", "lemma add_epsilon:\n  assumes A: \"\\<And>x y. le x y \\<Longrightarrow> le y x \\<Longrightarrow> f x = f y\"\n  shows \"\\<exists>\\<epsilon>>0. vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "let ?A = \"{(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f x > f y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "have \"?A = (\\<lambda>(x,y). (u y - u x) / (f x - f y)) ` {(x,y) |x y. x \\<prec>[le] y \\<and> f x > f y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x} =\n    (\\<lambda>(x, y). (u y - u x) / (f x - f y)) `\n    {(x, y) |x y. x \\<prec>[le] y \\<and> f y < f x}", "by auto"], ["proof (state)\nthis:\n  {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x} =\n  (\\<lambda>(x, y). (u y - u x) / (f x - f y)) `\n  {(x, y) |x y. x \\<prec>[le] y \\<and> f y < f x}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "also"], ["proof (state)\nthis:\n  {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x} =\n  (\\<lambda>(x, y). (u y - u x) / (f x - f y)) `\n  {(x, y) |x y. x \\<prec>[le] y \\<and> f y < f x}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "have \"finite {(x,y) |x y. x \\<prec>[le] y \\<and> f x > f y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(x, y) |x y. x \\<prec>[le] y \\<and> f y < f x}", "by (rule finite_subset[of _ \"carrier \\<times> carrier\"])\n       (insert not_outside, auto simp: strongly_preferred_def)"], ["proof (state)\nthis:\n  finite {(x, y) |x y. x \\<prec>[le] y \\<and> f y < f x}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "hence \"finite ((\\<lambda>(x,y). (u y - u x) / (f x - f y)) ` {(x,y) |x y. x \\<prec>[le] y \\<and> f x > f y})\""], ["proof (prove)\nusing this:\n  finite {(x, y) |x y. x \\<prec>[le] y \\<and> f y < f x}\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(x, y). (u y - u x) / (f x - f y)) `\n      {(x, y) |x y. x \\<prec>[le] y \\<and> f y < f x})", "by simp"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(x, y). (u y - u x) / (f x - f y)) `\n    {(x, y) |x y. x \\<prec>[le] y \\<and> f y < f x})\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "finally"], ["proof (chain)\npicking this:\n  finite {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x}", "have finite: \"finite ?A\""], ["proof (prove)\nusing this:\n  finite {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x}\n\ngoal (1 subgoal):\n 1. finite\n     {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x}", "."], ["proof (state)\nthis:\n  finite {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "define \\<epsilon> where \"\\<epsilon> = Min (insert 1 ?A) / 2\""], ["proof (state)\nthis:\n  \\<epsilon> =\n  Min (insert 1\n        {(u y - u x) / (f x - f y) |x y.\n         x \\<prec>[le] y \\<and> f y < f x}) /\n  2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "from finite"], ["proof (chain)\npicking this:\n  finite {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x}", "have \"Min (insert 1 ?A) > 0\""], ["proof (prove)\nusing this:\n  finite {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x}\n\ngoal (1 subgoal):\n 1. 0 < Min (insert 1\n              {(u y - u x) / (f x - f y) |x y.\n               x \\<prec>[le] y \\<and> f y < f x})", "by (auto intro!: divide_pos_pos simp: utility_less)"], ["proof (state)\nthis:\n  0 < Min (insert 1\n            {(u y - u x) / (f x - f y) |x y.\n             x \\<prec>[le] y \\<and> f y < f x})\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "hence \\<epsilon>: \"\\<epsilon> > 0\""], ["proof (prove)\nusing this:\n  0 < Min (insert 1\n            {(u y - u x) / (f x - f y) |x y.\n             x \\<prec>[le] y \\<and> f y < f x})\n\ngoal (1 subgoal):\n 1. 0 < \\<epsilon>", "unfolding \\<epsilon>_def"], ["proof (prove)\nusing this:\n  0 < Min (insert 1\n            {(u y - u x) / (f x - f y) |x y.\n             x \\<prec>[le] y \\<and> f y < f x})\n\ngoal (1 subgoal):\n 1. 0 < Min (insert 1\n              {(u y - u x) / (f x - f y) |x y.\n               x \\<prec>[le] y \\<and> f y < f x}) /\n        2", "by simp"], ["proof (state)\nthis:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "have mono: \"u x + \\<epsilon> * f x < u y + \\<epsilon> * f y\" if xy: \"x \\<prec>[le] y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "proof (cases \"f x > f y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y\n 2. \\<not> f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "assume less: \"f x > f y\""], ["proof (state)\nthis:\n  f y < f x\n\ngoal (2 subgoals):\n 1. f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y\n 2. \\<not> f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "from \\<epsilon>"], ["proof (chain)\npicking this:\n  0 < \\<epsilon>", "have \"\\<epsilon> < Min (insert 1 ?A)\""], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<epsilon>\n    < Min (insert 1\n            {(u y - u x) / (f x - f y) |x y.\n             x \\<prec>[le] y \\<and> f y < f x})", "unfolding \\<epsilon>_def"], ["proof (prove)\nusing this:\n  0 < Min (insert 1\n            {(u y - u x) / (f x - f y) |x y.\n             x \\<prec>[le] y \\<and> f y < f x}) /\n      2\n\ngoal (1 subgoal):\n 1. Min (insert 1\n          {(u y - u x) / (f x - f y) |x y.\n           x \\<prec>[le] y \\<and> f y < f x}) /\n    2\n    < Min (insert 1\n            {(u y - u x) / (f x - f y) |x y.\n             x \\<prec>[le] y \\<and> f y < f x})", "by linarith"], ["proof (state)\nthis:\n  \\<epsilon>\n  < Min (insert 1\n          {(u y - u x) / (f x - f y) |x y.\n           x \\<prec>[le] y \\<and> f y < f x})\n\ngoal (2 subgoals):\n 1. f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y\n 2. \\<not> f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "also"], ["proof (state)\nthis:\n  \\<epsilon>\n  < Min (insert 1\n          {(u y - u x) / (f x - f y) |x y.\n           x \\<prec>[le] y \\<and> f y < f x})\n\ngoal (2 subgoals):\n 1. f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y\n 2. \\<not> f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "from less xy finite"], ["proof (chain)\npicking this:\n  f y < f x\n  x \\<prec>[le] y\n  finite {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x}", "have \"Min (insert 1 ?A) \\<le> (u y - u x) / (f x - f y)\""], ["proof (prove)\nusing this:\n  f y < f x\n  x \\<prec>[le] y\n  finite {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x}\n\ngoal (1 subgoal):\n 1. Min (insert 1\n          {(u y - u x) / (f x - f y) |x y.\n           x \\<prec>[le] y \\<and> f y < f x})\n    \\<le> (u y - u x) / (f x - f y)", "unfolding \\<epsilon>_def"], ["proof (prove)\nusing this:\n  f y < f x\n  x \\<prec>[le] y\n  finite {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x}\n\ngoal (1 subgoal):\n 1. Min (insert 1\n          {(u y - u x) / (f x - f y) |x y.\n           x \\<prec>[le] y \\<and> f y < f x})\n    \\<le> (u y - u x) / (f x - f y)", "by (intro Min_le) auto"], ["proof (state)\nthis:\n  Min (insert 1\n        {(u y - u x) / (f x - f y) |x y. x \\<prec>[le] y \\<and> f y < f x})\n  \\<le> (u y - u x) / (f x - f y)\n\ngoal (2 subgoals):\n 1. f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y\n 2. \\<not> f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "finally"], ["proof (chain)\npicking this:\n  \\<epsilon> < (u y - u x) / (f x - f y)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<epsilon> < (u y - u x) / (f x - f y)\n\ngoal (1 subgoal):\n 1. u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "using less"], ["proof (prove)\nusing this:\n  \\<epsilon> < (u y - u x) / (f x - f y)\n  f y < f x\n\ngoal (1 subgoal):\n 1. u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  u x + \\<epsilon> * f x < u y + \\<epsilon> * f y\n\ngoal (1 subgoal):\n 1. \\<not> f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "assume \"\\<not>f x > f y\""], ["proof (state)\nthis:\n  \\<not> f y < f x\n\ngoal (1 subgoal):\n 1. \\<not> f y < f x \\<Longrightarrow>\n    u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "with utility_less[OF xy] \\<epsilon>"], ["proof (chain)\npicking this:\n  u x < u y\n  0 < \\<epsilon>\n  \\<not> f y < f x", "show ?thesis"], ["proof (prove)\nusing this:\n  u x < u y\n  0 < \\<epsilon>\n  \\<not> f y < f x\n\ngoal (1 subgoal):\n 1. u x + \\<epsilon> * f x < u y + \\<epsilon> * f y", "by (simp add: algebra_simps not_less add_less_le_mono)"], ["proof (state)\nthis:\n  u x + \\<epsilon> * f x < u y + \\<epsilon> * f y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<prec>[le] ?y \\<Longrightarrow>\n  u ?x + \\<epsilon> * f ?x < u ?y + \\<epsilon> * f ?y\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "have eq: \"u x + \\<epsilon> * f x = u y + \\<epsilon> * f y\" if xy: \"x \\<preceq>[le] y\" \"y \\<preceq>[le] x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. u x + \\<epsilon> * f x = u y + \\<epsilon> * f y", "using xy[THEN utility_le] A[OF xy]"], ["proof (prove)\nusing this:\n  u x \\<le> u y\n  u y \\<le> u x\n  f x = f y\n\ngoal (1 subgoal):\n 1. u x + \\<epsilon> * f x = u y + \\<epsilon> * f y", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>le ?x ?y; le ?y ?x\\<rbrakk>\n  \\<Longrightarrow> u ?x + \\<epsilon> * f ?x = u ?y + \\<epsilon> * f ?y\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "have \"vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> (u x + \\<epsilon> * f x\n                          \\<le> u y + \\<epsilon> * f y) =\n                         le x y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> (u x + \\<epsilon> * f x\n                          \\<le> u y + \\<epsilon> * f y) =\n                         le x y", "assume xy: \"x \\<in> carrier\" \"y \\<in> carrier\""], ["proof (state)\nthis:\n  x \\<in> carrier\n  y \\<in> carrier\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier; y \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> (u x + \\<epsilon> * f x\n                          \\<le> u y + \\<epsilon> * f y) =\n                         le x y", "show \"(u x + \\<epsilon> * f x \\<le> u y + \\<epsilon> * f y) \\<longleftrightarrow> le x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u x + \\<epsilon> * f x \\<le> u y + \\<epsilon> * f y) = le x y", "using total[OF xy] mono[of x y] mono[of y x] eq[of x y]"], ["proof (prove)\nusing this:\n  le x y \\<or> le y x\n  x \\<prec>[le] y \\<Longrightarrow>\n  u x + \\<epsilon> * f x < u y + \\<epsilon> * f y\n  y \\<prec>[le] x \\<Longrightarrow>\n  u y + \\<epsilon> * f y < u x + \\<epsilon> * f x\n  \\<lbrakk>le x y; le y x\\<rbrakk>\n  \\<Longrightarrow> u x + \\<epsilon> * f x = u y + \\<epsilon> * f y\n\ngoal (1 subgoal):\n 1. (u x + \\<epsilon> * f x \\<le> u y + \\<epsilon> * f y) = le x y", "by (cases \"le x y\"; cases \"le y x\") (auto simp: strongly_preferred_def)"], ["proof (state)\nthis:\n  (u x + \\<epsilon> * f x \\<le> u y + \\<epsilon> * f y) = le x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "from \\<epsilon> this"], ["proof (chain)\npicking this:\n  0 < \\<epsilon>\n  vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n  vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<epsilon>>0.\n     vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diff_epsilon:\n  assumes \"\\<And>x y. le x y \\<Longrightarrow> le y x \\<Longrightarrow> f x = f y\"\n  shows \"\\<exists>\\<epsilon>>0. vnm_utility carrier le (\\<lambda>x. u x - \\<epsilon> * f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x - \\<epsilon> * f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x - \\<epsilon> * f x)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>le ?x ?y; le ?y ?x\\<rbrakk> \\<Longrightarrow> f ?x = f ?y", "have \"\\<exists>\\<epsilon>>0. vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * -f x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>le ?x ?y; le ?y ?x\\<rbrakk> \\<Longrightarrow> f ?x = f ?y\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * - f x)", "by (intro add_epsilon) (subst neg_equal_iff_equal)"], ["proof (state)\nthis:\n  \\<exists>\\<epsilon>>0.\n     vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * - f x)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x - \\<epsilon> * f x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>\\<epsilon>>0.\n     vnm_utility carrier le (\\<lambda>x. u x + \\<epsilon> * - f x)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<epsilon>>0.\n       vnm_utility carrier le (\\<lambda>x. u x - \\<epsilon> * f x)", "by simp"], ["proof (state)\nthis:\n  \\<exists>\\<epsilon>>0.\n     vnm_utility carrier le (\\<lambda>x. u x - \\<epsilon> * f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}