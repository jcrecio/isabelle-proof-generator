{"file_name": "/home/qj213/afp-2021-10-22/thys/Adaptive_State_Counting/ATC/ATC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Adaptive_State_Counting", "problem_names": ["lemma atc_reaction_empty[simp] :\n  assumes \"atc_reaction M q t []\"\n  shows \"t = Leaf\"", "lemma atc_reaction_nonempty_no_leaf :\n  assumes \"atc_reaction M q t (Cons a io)\"\n  shows \"t \\<noteq> Leaf\"", "lemma atc_reaction_nonempty[elim] :\n  assumes \"atc_reaction M q1 t (Cons (x,y) io)\"\n  obtains q2 f \n  where \"t = Node x f\" \"q2 \\<in> succ M (x,y) q1\"  \"atc_reaction M q2 (f y) io\"", "lemma atc_reaction_path_ex : \n  assumes \"atc_reaction M q1 t io\"\n  shows \"\\<exists> tr . path M (io || tr) q1 \\<and> length io = length tr\"", "lemma atc_reaction_path[elim] : \n  assumes \"atc_reaction M q1 t io\"\nobtains tr\n  where \"path M (io || tr) q1\" \"length io = length tr\"", "lemma accp_subtest : \"Wellfounded.accp subtest t\"", "lemma subtest_rel_altdef: \"subtest_rel = {(s, t) |s t. subtest s t}\"", "lemma subtest_relI [intro]: \"t \\<in> range f \\<Longrightarrow> (t, Node x f) \\<in> subtest_rel\"", "lemma subtest_relI' [intro]: \"t = f y \\<Longrightarrow> (t, Node x f) \\<in> subtest_rel\"", "lemma wf_subtest_rel [simp, intro]: \"wf subtest_rel\"", "lemma applicable_subtest :\n  assumes \"applicable M (Node x f)\"\nshows \"applicable M (f y)\"", "lemma IO_language : \"IO M q t \\<subseteq> language_state M q\"", "lemma IO_leaf[simp] : \"IO M q Leaf = {[]}\"", "lemma IO_applicable_nonempty :\n  assumes \"applicable M t\"\n  and     \"completely_specified M\"\n  and     \"q1 \\<in> nodes M\"\n  shows \"IO M q1 t \\<noteq> {}\"", "lemma IO_in_language :\n  \"IO M q t \\<subseteq> LS M q\"", "lemma IO_set_in_language :\n  \"IO_set M q \\<Omega> \\<subseteq> LS M q\"", "lemma r_dist_dist :\n  assumes \"applicable M t\"\n  and     \"completely_specified M\"\n  and     \"r_dist M t q1 q2\"\n  and     \"q1 \\<in> nodes M\"\nshows   \"q1 \\<noteq> q2\"", "lemma r_dist_set_dist :\n  assumes \"applicable_set M \\<Omega>\"\n  and     \"completely_specified M\"\n  and     \"r_dist_set M \\<Omega> q1 q2\"\n  and     \"q1 \\<in> nodes M\"\nshows   \"q1 \\<noteq> q2\"", "lemma r_dist_set_dist_disjoint :\n  assumes \"applicable_set M \\<Omega>\"\n  and     \"completely_specified M\"\n  and     \"\\<forall> t1 \\<in> T1 . \\<forall> t2 \\<in> T2 . r_dist_set M \\<Omega> t1 t2\"\n  and     \"T1 \\<subseteq> nodes M\"\nshows \"T1 \\<inter> T2 = {}\"", "lemma B_dist' :\n  assumes df: \"B M io1 \\<Omega> \\<noteq> B M io2 \\<Omega>\"\n  shows   \"(io_targets M (initial M) io1) \\<noteq> (io_targets M (initial M) io2)\"", "lemma B_dist :\n  assumes \"io_targets M (initial M) io1 = {q1}\"\n  and     \"io_targets M (initial M) io2 = {q2}\"\n  and     \"B M io1 \\<Omega> \\<noteq> B M io2 \\<Omega>\"\nshows   \"q1 \\<noteq> q2\"", "lemma D_bound :\n  assumes wf: \"well_formed M\"\n  and     ob: \"observable M\"\n  and     fi: \"finite ISeqs\"\n  shows \"finite (D M ISeqs \\<Omega>)\" \"card (D M ISeqs \\<Omega>) \\<le> card (nodes M)\"", "lemma append_io_B_in_language :\n  \"append_io_B M io \\<Omega> \\<subseteq> L M\"", "lemma append_io_B_nonempty :\n  assumes \"applicable_set M \\<Omega>\"\n  and     \"completely_specified M\"\n  and     \"io \\<in> language_state M (initial M)\"\n  and     \"\\<Omega> \\<noteq> {}\"\nshows \"append_io_B M io \\<Omega> \\<noteq> {}\"", "lemma append_io_B_prefix_in_language :\n  assumes \"append_io_B M io \\<Omega> \\<noteq> {}\"\n  shows \"io \\<in> L M\"", "lemma atc_rdist_dist[intro] :\n  assumes wf2   : \"well_formed M2\"\n  and     cs2   : \"completely_specified M2\"\n  and     ap2   : \"applicable_set M2 \\<Omega>\"\n  and     el_t1 : \"t1 \\<in> nodes M2\"\n  and     red1  : \"atc_reduction M2 t1 M1 s1 \\<Omega>\"\n  and     red2  : \"atc_reduction M2 t2 M1 s2 \\<Omega>\"\n  and     rdist : \"r_dist_set M1 \\<Omega> s1 s2\"\n  and             \"t1 \\<in> nodes M2\"\nshows \"r_dist_set M2 \\<Omega> t1 t2\"", "lemma io_reduction_from_atc_io_reduction :\n  assumes \"atc_io_reduction_on_sets M1 T \\<Omega> M2\"\n  and     \"finite T\"\n  shows \"io_reduction_on M1 T M2\"", "lemma atc_io_reduction_on_subset :\n  assumes \"atc_io_reduction_on_sets M1 T \\<Omega> M2\"\n  and     \"T' \\<subseteq> T\"\nshows \"atc_io_reduction_on_sets M1 T' \\<Omega> M2\"", "lemma atc_reaction_reduction[intro] :\n  assumes ls : \"language_state M1 q1 \\<subseteq> language_state M2 q2\"\n  and     el1 : \"q1 \\<in> nodes M1\"\n  and     el2 : \"q2 \\<in> nodes M2\"\n  and     rct : \"atc_reaction M1 q1 t io\"\n  and     ob2 : \"observable M2\"\n  and     ob1 : \"observable M1\"\nshows \"atc_reaction M2 q2 t io\"", "lemma IO_reduction :\n  assumes ls : \"language_state M1 q1 \\<subseteq> language_state M2 q2\"\n  and     el1 : \"q1 \\<in> nodes M1\"\n  and     el2 : \"q2 \\<in> nodes M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"IO M1 q1 t \\<subseteq> IO M2 q2 t\"", "lemma IO_set_reduction :\n  assumes ls : \"language_state M1 q1 \\<subseteq> language_state M2 q2\"\n  and     el1 : \"q1 \\<in> nodes M1\"\n  and     el2 : \"q2 \\<in> nodes M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"IO_set M1 q1 \\<Omega> \\<subseteq> IO_set M2 q2 \\<Omega>\"", "lemma B_reduction :\n  assumes red : \"M1 \\<preceq> M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>\"", "lemma append_io_B_reduction :\n  assumes red : \"M1 \\<preceq> M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"append_io_B M1 io \\<Omega> \\<subseteq> append_io_B M2 io \\<Omega>\"", "lemma atc_io_reduction_on_reduction[intro] :\n  assumes red : \"M1 \\<preceq> M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"atc_io_reduction_on M1 M2 iseq \\<Omega>\"", "lemma atc_io_reduction_on_sets_reduction[intro] :\n  assumes red : \"M1 \\<preceq> M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"atc_io_reduction_on_sets M1 TS \\<Omega> M2\"", "lemma atc_io_reduction_on_sets_via_LS\\<^sub>i\\<^sub>n : \n  assumes \"atc_io_reduction_on_sets M1 TS \\<Omega> M2\"\n  shows \"(L\\<^sub>i\\<^sub>n M1 TS \\<union> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)) \n          \\<subseteq> (L\\<^sub>i\\<^sub>n M2 TS \\<union> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>))\""], "translations": [["", "lemma atc_reaction_empty[simp] :\n  assumes \"atc_reaction M q t []\"\n  shows \"t = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = Leaf", "using assms atc_reaction.simps"], ["proof (prove)\nusing this:\n  atc_reaction M q t []\n  atc_reaction ?a1.0 ?a2.0 ?a3.0 ?a4.0 =\n  ((\\<exists>M q1.\n       ?a1.0 = M \\<and>\n       ?a2.0 = q1 \\<and> ?a3.0 = Leaf \\<and> ?a4.0 = []) \\<or>\n   (\\<exists>q2 M x y q1 f io.\n       ?a1.0 = M \\<and>\n       ?a2.0 = q1 \\<and>\n       ?a3.0 = Node x f \\<and>\n       ?a4.0 = (x, y) # io \\<and>\n       q2 \\<in> succ M (x, y) q1 \\<and> atc_reaction M q2 (f y) io))\n\ngoal (1 subgoal):\n 1. t = Leaf", "by force"], ["", "lemma atc_reaction_nonempty_no_leaf :\n  assumes \"atc_reaction M q t (Cons a io)\"\n  shows \"t \\<noteq> Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> Leaf", "using assms"], ["proof (prove)\nusing this:\n  atc_reaction M q t (a # io)\n\ngoal (1 subgoal):\n 1. t \\<noteq> Leaf", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atc_reaction M q t (a # io) \\<Longrightarrow> t \\<noteq> Leaf", "have \"\\<And>f c a ps. \\<not> atc_reaction f (c::'c) (a::('a, 'b) ATC) ps \\<or> a \\<noteq> Leaf \\<or> a \\<noteq> Leaf \\<or> ps = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f c a ps.\n       \\<not> atc_reaction f c a ps \\<or>\n       a \\<noteq> Leaf \\<or> a \\<noteq> Leaf \\<or> ps = []", "using atc_reaction.simps"], ["proof (prove)\nusing this:\n  atc_reaction ?a1.0 ?a2.0 ?a3.0 ?a4.0 =\n  ((\\<exists>M q1.\n       ?a1.0 = M \\<and>\n       ?a2.0 = q1 \\<and> ?a3.0 = Leaf \\<and> ?a4.0 = []) \\<or>\n   (\\<exists>q2 M x y q1 f io.\n       ?a1.0 = M \\<and>\n       ?a2.0 = q1 \\<and>\n       ?a3.0 = Node x f \\<and>\n       ?a4.0 = (x, y) # io \\<and>\n       q2 \\<in> succ M (x, y) q1 \\<and> atc_reaction M q2 (f y) io))\n\ngoal (1 subgoal):\n 1. \\<And>f c a ps.\n       \\<not> atc_reaction f c a ps \\<or>\n       a \\<noteq> Leaf \\<or> a \\<noteq> Leaf \\<or> ps = []", "by fastforce"], ["proof (state)\nthis:\n  \\<not> atc_reaction ?f ?c ?a ?ps \\<or>\n  ?a \\<noteq> Leaf \\<or> ?a \\<noteq> Leaf \\<or> ?ps = []\n\ngoal (1 subgoal):\n 1. atc_reaction M q t (a # io) \\<Longrightarrow> t \\<noteq> Leaf", "then"], ["proof (chain)\npicking this:\n  \\<not> atc_reaction ?f ?c ?a ?ps \\<or>\n  ?a \\<noteq> Leaf \\<or> ?a \\<noteq> Leaf \\<or> ?ps = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> atc_reaction ?f ?c ?a ?ps \\<or>\n  ?a \\<noteq> Leaf \\<or> ?a \\<noteq> Leaf \\<or> ?ps = []\n\ngoal (1 subgoal):\n 1. t \\<noteq> Leaf", "using assms"], ["proof (prove)\nusing this:\n  \\<not> atc_reaction ?f ?c ?a ?ps \\<or>\n  ?a \\<noteq> Leaf \\<or> ?a \\<noteq> Leaf \\<or> ?ps = []\n  atc_reaction M q t (a # io)\n\ngoal (1 subgoal):\n 1. t \\<noteq> Leaf", "by blast"], ["proof (state)\nthis:\n  t \\<noteq> Leaf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atc_reaction_nonempty[elim] :\n  assumes \"atc_reaction M q1 t (Cons (x,y) io)\"\n  obtains q2 f \n  where \"t = Node x f\" \"q2 \\<in> succ M (x,y) q1\"  \"atc_reaction M q2 (f y) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f q2.\n        \\<lbrakk>t = Node x f; q2 \\<in> succ M (x, y) q1;\n         atc_reaction M q2 (f y) io\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f q2.\n        \\<lbrakk>t = Node x f; q2 \\<in> succ M (x, y) q1;\n         atc_reaction M q2 (f y) io\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain x2 f where \"t = Node x2 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x2 f. t = Node x2 f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  atc_reaction M q1 t ((x, y) # io)\n\ngoal (1 subgoal):\n 1. (\\<And>x2 f. t = Node x2 f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ATC.exhaust atc_reaction_nonempty_no_leaf)"], ["proof (state)\nthis:\n  t = Node x2 f\n\ngoal (1 subgoal):\n 1. (\\<And>f q2.\n        \\<lbrakk>t = Node x f; q2 \\<in> succ M (x, y) q1;\n         atc_reaction M q2 (f y) io\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  t = Node x2 f\n\ngoal (1 subgoal):\n 1. (\\<And>f q2.\n        \\<lbrakk>t = Node x f; q2 \\<in> succ M (x, y) q1;\n         atc_reaction M q2 (f y) io\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"x = x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x2", "using assms calculation atc_reaction.cases"], ["proof (prove)\nusing this:\n  atc_reaction M q1 t ((x, y) # io)\n  t = Node x2 f\n  \\<lbrakk>atc_reaction ?a1.0 ?a2.0 ?a3.0 ?a4.0;\n   \\<And>M q1.\n      \\<lbrakk>?a1.0 = M; ?a2.0 = q1; ?a3.0 = Leaf; ?a4.0 = []\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>q2 M x y q1 f io.\n      \\<lbrakk>?a1.0 = M; ?a2.0 = q1; ?a3.0 = Node x f; ?a4.0 = (x, y) # io;\n       q2 \\<in> succ M (x, y) q1; atc_reaction M q2 (f y) io\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. x = x2", "by fastforce"], ["proof (state)\nthis:\n  x = x2\n\ngoal (1 subgoal):\n 1. (\\<And>f q2.\n        \\<lbrakk>t = Node x f; q2 \\<in> succ M (x, y) q1;\n         atc_reaction M q2 (f y) io\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  t = Node x2 f\n  x = x2", "show ?thesis"], ["proof (prove)\nusing this:\n  t = Node x2 f\n  x = x2\n\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  t = Node x2 f\n  x = x2\n  atc_reaction M q1 t ((x, y) # io)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  t = Node x2 f\n  x = x2\n  atc_reaction M q1 t ((x, y) # io)\n  \\<lbrakk>t = Node x ?f; ?q2.0 \\<in> succ M (x, y) q1;\n   atc_reaction M ?q2.0 (?f y) io\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atc_reaction_path_ex : \n  assumes \"atc_reaction M q1 t io\"\n  shows \"\\<exists> tr . path M (io || tr) q1 \\<and> length io = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tr. path M (io || tr) q1 \\<and> length io = length tr", "using assms"], ["proof (prove)\nusing this:\n  atc_reaction M q1 t io\n\ngoal (1 subgoal):\n 1. \\<exists>tr. path M (io || tr) q1 \\<and> length io = length tr", "proof (induction io arbitrary: q1 t rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q1 t.\n       atc_reaction M q1 t [] \\<Longrightarrow>\n       \\<exists>tr. path M ([] || tr) q1 \\<and> length [] = length tr\n 2. \\<And>x1 x2 q1 t.\n       \\<lbrakk>\\<And>q1 t.\n                   atc_reaction M q1 t x2 \\<Longrightarrow>\n                   \\<exists>tr.\n                      path M (x2 || tr) q1 \\<and> length x2 = length tr;\n        atc_reaction M q1 t (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr.\n                            path M (x1 # x2 || tr) q1 \\<and>\n                            length (x1 # x2) = length tr", "case Nil"], ["proof (state)\nthis:\n  atc_reaction M q1 t []\n\ngoal (2 subgoals):\n 1. \\<And>q1 t.\n       atc_reaction M q1 t [] \\<Longrightarrow>\n       \\<exists>tr. path M ([] || tr) q1 \\<and> length [] = length tr\n 2. \\<And>x1 x2 q1 t.\n       \\<lbrakk>\\<And>q1 t.\n                   atc_reaction M q1 t x2 \\<Longrightarrow>\n                   \\<exists>tr.\n                      path M (x2 || tr) q1 \\<and> length x2 = length tr;\n        atc_reaction M q1 t (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr.\n                            path M (x1 # x2 || tr) q1 \\<and>\n                            length (x1 # x2) = length tr", "then"], ["proof (chain)\npicking this:\n  atc_reaction M q1 t []", "show ?case"], ["proof (prove)\nusing this:\n  atc_reaction M q1 t []\n\ngoal (1 subgoal):\n 1. \\<exists>tr. path M ([] || tr) q1 \\<and> length [] = length tr", "by (simp add: FSM.nil)"], ["proof (state)\nthis:\n  \\<exists>tr. path M ([] || tr) q1 \\<and> length [] = length tr\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 t.\n       \\<lbrakk>\\<And>q1 t.\n                   atc_reaction M q1 t x2 \\<Longrightarrow>\n                   \\<exists>tr.\n                      path M (x2 || tr) q1 \\<and> length x2 = length tr;\n        atc_reaction M q1 t (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr.\n                            path M (x1 # x2 || tr) q1 \\<and>\n                            length (x1 # x2) = length tr", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 t.\n       \\<lbrakk>\\<And>q1 t.\n                   atc_reaction M q1 t x2 \\<Longrightarrow>\n                   \\<exists>tr.\n                      path M (x2 || tr) q1 \\<and> length x2 = length tr;\n        atc_reaction M q1 t (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr.\n                            path M (x1 # x2 || tr) q1 \\<and>\n                            length (x1 # x2) = length tr", "case (Cons io_hd io_tl)"], ["proof (state)\nthis:\n  atc_reaction M ?q1.0 ?t io_tl \\<Longrightarrow>\n  \\<exists>tr. path M (io_tl || tr) ?q1.0 \\<and> length io_tl = length tr\n  atc_reaction M q1 t (io_hd # io_tl)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 t.\n       \\<lbrakk>\\<And>q1 t.\n                   atc_reaction M q1 t x2 \\<Longrightarrow>\n                   \\<exists>tr.\n                      path M (x2 || tr) q1 \\<and> length x2 = length tr;\n        atc_reaction M q1 t (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr.\n                            path M (x1 # x2 || tr) q1 \\<and>\n                            length (x1 # x2) = length tr", "then"], ["proof (chain)\npicking this:\n  atc_reaction M ?q1.0 ?t io_tl \\<Longrightarrow>\n  \\<exists>tr. path M (io_tl || tr) ?q1.0 \\<and> length io_tl = length tr\n  atc_reaction M q1 t (io_hd # io_tl)", "obtain x y where io_hd_def : \"io_hd = (x,y)\""], ["proof (prove)\nusing this:\n  atc_reaction M ?q1.0 ?t io_tl \\<Longrightarrow>\n  \\<exists>tr. path M (io_tl || tr) ?q1.0 \\<and> length io_tl = length tr\n  atc_reaction M q1 t (io_hd # io_tl)\n\ngoal (1 subgoal):\n 1. (\\<And>x y. io_hd = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  io_hd = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 t.\n       \\<lbrakk>\\<And>q1 t.\n                   atc_reaction M q1 t x2 \\<Longrightarrow>\n                   \\<exists>tr.\n                      path M (x2 || tr) q1 \\<and> length x2 = length tr;\n        atc_reaction M q1 t (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr.\n                            path M (x1 # x2 || tr) q1 \\<and>\n                            length (x1 # x2) = length tr", "then"], ["proof (chain)\npicking this:\n  io_hd = (x, y)", "obtain f where f_def : \"t = (Node x f)\""], ["proof (prove)\nusing this:\n  io_hd = (x, y)\n\ngoal (1 subgoal):\n 1. (\\<And>f. t = Node x f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons atc_reaction_nonempty"], ["proof (prove)\nusing this:\n  io_hd = (x, y)\n  atc_reaction M ?q1.0 ?t io_tl \\<Longrightarrow>\n  \\<exists>tr. path M (io_tl || tr) ?q1.0 \\<and> length io_tl = length tr\n  atc_reaction M q1 t (io_hd # io_tl)\n  \\<lbrakk>atc_reaction ?M ?q1.0 ?t ((?x, ?y) # ?io);\n   \\<And>q2 f.\n      \\<lbrakk>?t = Node ?x f; q2 \\<in> succ ?M (?x, ?y) ?q1.0;\n       atc_reaction ?M q2 (f ?y) ?io\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f. t = Node x f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  t = Node x f\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 t.\n       \\<lbrakk>\\<And>q1 t.\n                   atc_reaction M q1 t x2 \\<Longrightarrow>\n                   \\<exists>tr.\n                      path M (x2 || tr) q1 \\<and> length x2 = length tr;\n        atc_reaction M q1 t (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr.\n                            path M (x1 # x2 || tr) q1 \\<and>\n                            length (x1 # x2) = length tr", "then"], ["proof (chain)\npicking this:\n  t = Node x f", "obtain q2 where q2_def : \"q2 \\<in> succ M (x,y) q1\" \"atc_reaction M q2 (f y) io_tl\""], ["proof (prove)\nusing this:\n  t = Node x f\n\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        \\<lbrakk>q2 \\<in> succ M (x, y) q1;\n         atc_reaction M q2 (f y) io_tl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons io_hd_def atc_reaction_nonempty"], ["proof (prove)\nusing this:\n  t = Node x f\n  atc_reaction M ?q1.0 ?t io_tl \\<Longrightarrow>\n  \\<exists>tr. path M (io_tl || tr) ?q1.0 \\<and> length io_tl = length tr\n  atc_reaction M q1 t (io_hd # io_tl)\n  io_hd = (x, y)\n  \\<lbrakk>atc_reaction ?M ?q1.0 ?t ((?x, ?y) # ?io);\n   \\<And>q2 f.\n      \\<lbrakk>?t = Node ?x f; q2 \\<in> succ ?M (?x, ?y) ?q1.0;\n       atc_reaction ?M q2 (f ?y) ?io\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        \\<lbrakk>q2 \\<in> succ M (x, y) q1;\n         atc_reaction M q2 (f y) io_tl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q2 \\<in> succ M (x, y) q1\n  atc_reaction M q2 (f y) io_tl\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 t.\n       \\<lbrakk>\\<And>q1 t.\n                   atc_reaction M q1 t x2 \\<Longrightarrow>\n                   \\<exists>tr.\n                      path M (x2 || tr) q1 \\<and> length x2 = length tr;\n        atc_reaction M q1 t (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr.\n                            path M (x1 # x2 || tr) q1 \\<and>\n                            length (x1 # x2) = length tr", "then"], ["proof (chain)\npicking this:\n  q2 \\<in> succ M (x, y) q1\n  atc_reaction M q2 (f y) io_tl", "obtain tr_tl where tr_tl_def :  \"path M (io_tl || tr_tl) q2\" \"length io_tl = length tr_tl\""], ["proof (prove)\nusing this:\n  q2 \\<in> succ M (x, y) q1\n  atc_reaction M q2 (f y) io_tl\n\ngoal (1 subgoal):\n 1. (\\<And>tr_tl.\n        \\<lbrakk>path M (io_tl || tr_tl) q2;\n         length io_tl = length tr_tl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.IH[of q2 \"f y\"]"], ["proof (prove)\nusing this:\n  q2 \\<in> succ M (x, y) q1\n  atc_reaction M q2 (f y) io_tl\n  atc_reaction M q2 (f y) io_tl \\<Longrightarrow>\n  \\<exists>tr. path M (io_tl || tr) q2 \\<and> length io_tl = length tr\n\ngoal (1 subgoal):\n 1. (\\<And>tr_tl.\n        \\<lbrakk>path M (io_tl || tr_tl) q2;\n         length io_tl = length tr_tl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path M (io_tl || tr_tl) q2\n  length io_tl = length tr_tl\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 t.\n       \\<lbrakk>\\<And>q1 t.\n                   atc_reaction M q1 t x2 \\<Longrightarrow>\n                   \\<exists>tr.\n                      path M (x2 || tr) q1 \\<and> length x2 = length tr;\n        atc_reaction M q1 t (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr.\n                            path M (x1 # x2 || tr) q1 \\<and>\n                            length (x1 # x2) = length tr", "then"], ["proof (chain)\npicking this:\n  path M (io_tl || tr_tl) q2\n  length io_tl = length tr_tl", "have \"path M (io_hd # io_tl || q2 # tr_tl) q1\""], ["proof (prove)\nusing this:\n  path M (io_tl || tr_tl) q2\n  length io_tl = length tr_tl\n\ngoal (1 subgoal):\n 1. path M (io_hd # io_tl || q2 # tr_tl) q1", "using Cons q2_def"], ["proof (prove)\nusing this:\n  path M (io_tl || tr_tl) q2\n  length io_tl = length tr_tl\n  atc_reaction M ?q1.0 ?t io_tl \\<Longrightarrow>\n  \\<exists>tr. path M (io_tl || tr) ?q1.0 \\<and> length io_tl = length tr\n  atc_reaction M q1 t (io_hd # io_tl)\n  q2 \\<in> succ M (x, y) q1\n  atc_reaction M q2 (f y) io_tl\n\ngoal (1 subgoal):\n 1. path M (io_hd # io_tl || q2 # tr_tl) q1", "by (simp add: FSM.path.intros(2) io_hd_def)"], ["proof (state)\nthis:\n  path M (io_hd # io_tl || q2 # tr_tl) q1\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1 t.\n       \\<lbrakk>\\<And>q1 t.\n                   atc_reaction M q1 t x2 \\<Longrightarrow>\n                   \\<exists>tr.\n                      path M (x2 || tr) q1 \\<and> length x2 = length tr;\n        atc_reaction M q1 t (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr.\n                            path M (x1 # x2 || tr) q1 \\<and>\n                            length (x1 # x2) = length tr", "then"], ["proof (chain)\npicking this:\n  path M (io_hd # io_tl || q2 # tr_tl) q1", "show ?case"], ["proof (prove)\nusing this:\n  path M (io_hd # io_tl || q2 # tr_tl) q1\n\ngoal (1 subgoal):\n 1. \\<exists>tr.\n       path M (io_hd # io_tl || tr) q1 \\<and>\n       length (io_hd # io_tl) = length tr", "using tr_tl_def"], ["proof (prove)\nusing this:\n  path M (io_hd # io_tl || q2 # tr_tl) q1\n  path M (io_tl || tr_tl) q2\n  length io_tl = length tr_tl\n\ngoal (1 subgoal):\n 1. \\<exists>tr.\n       path M (io_hd # io_tl || tr) q1 \\<and>\n       length (io_hd # io_tl) = length tr", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>tr.\n     path M (io_hd # io_tl || tr) q1 \\<and>\n     length (io_hd # io_tl) = length tr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atc_reaction_path[elim] : \n  assumes \"atc_reaction M q1 t io\"\nobtains tr\n  where \"path M (io || tr) q1\" \"length io = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>path M (io || tr) q1; length io = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson assms atc_reaction_path_ex)"], ["", "subsection \\<open> Applicability \\<close>"], ["", "text \\<open> \nAn ATC can be applied to an FSM if each node-label is contained in the input alphabet of the FSM.\n\\<close>"], ["", "inductive subtest :: \"('in, 'out) ATC \\<Rightarrow> ('in, 'out) ATC \\<Rightarrow> bool\" where\n  \"t \\<in> range f \\<Longrightarrow> subtest t (Node x f)\""], ["", "lemma accp_subtest : \"Wellfounded.accp subtest t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Wellfounded.accp subtest t", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. Wellfounded.accp subtest Leaf\n 2. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> range x2 \\<Longrightarrow>\n           Wellfounded.accp subtest x2a) \\<Longrightarrow>\n       Wellfounded.accp subtest (Node x1 x2)", "case Leaf"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Wellfounded.accp subtest Leaf\n 2. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> range x2 \\<Longrightarrow>\n           Wellfounded.accp subtest x2a) \\<Longrightarrow>\n       Wellfounded.accp subtest (Node x1 x2)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Wellfounded.accp subtest Leaf", "by (meson ATC.distinct(1) accp.simps subtest.cases)"], ["proof (state)\nthis:\n  Wellfounded.accp subtest Leaf\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> range x2 \\<Longrightarrow>\n           Wellfounded.accp subtest x2a) \\<Longrightarrow>\n       Wellfounded.accp subtest (Node x1 x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> range x2 \\<Longrightarrow>\n           Wellfounded.accp subtest x2a) \\<Longrightarrow>\n       Wellfounded.accp subtest (Node x1 x2)", "case (Node x f)"], ["proof (state)\nthis:\n  ?x2a \\<in> range f \\<Longrightarrow> Wellfounded.accp subtest ?x2a\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> range x2 \\<Longrightarrow>\n           Wellfounded.accp subtest x2a) \\<Longrightarrow>\n       Wellfounded.accp subtest (Node x1 x2)", "have IH: \"Wellfounded.accp subtest t\" if \"t \\<in> range f\" for \"t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Wellfounded.accp subtest t", "using Node[of t] and that"], ["proof (prove)\nusing this:\n  t \\<in> range f \\<Longrightarrow> Wellfounded.accp subtest t\n  t \\<in> range f\n\ngoal (1 subgoal):\n 1. Wellfounded.accp subtest t", "by (auto simp: eq_commute)"], ["proof (state)\nthis:\n  ?t \\<in> range f \\<Longrightarrow> Wellfounded.accp subtest ?t\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> range x2 \\<Longrightarrow>\n           Wellfounded.accp subtest x2a) \\<Longrightarrow>\n       Wellfounded.accp subtest (Node x1 x2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Wellfounded.accp subtest (Node x f)", "by (rule accpI) (auto intro: IH elim!: subtest.cases)"], ["proof (state)\nthis:\n  Wellfounded.accp subtest (Node x f)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition subtest_rel where \"subtest_rel = {(t, Node x f) |f x t. t \\<in> range f}\""], ["", "lemma subtest_rel_altdef: \"subtest_rel = {(s, t) |s t. subtest s t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtest_rel = {(s, t) |s t. subtest s t}", "by (auto simp: subtest_rel_def subtest.simps)"], ["", "lemma subtest_relI [intro]: \"t \\<in> range f \\<Longrightarrow> (t, Node x f) \\<in> subtest_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> range f \\<Longrightarrow> (t, Node x f) \\<in> subtest_rel", "by (simp add: subtest_rel_def)"], ["", "lemma subtest_relI' [intro]: \"t = f y \\<Longrightarrow> (t, Node x f) \\<in> subtest_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = f y \\<Longrightarrow> (t, Node x f) \\<in> subtest_rel", "by (auto simp: subtest_rel_def ran_def)"], ["", "lemma wf_subtest_rel [simp, intro]: \"wf subtest_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf subtest_rel", "using accp_subtest"], ["proof (prove)\nusing this:\n  Wellfounded.accp subtest ?t\n\ngoal (1 subgoal):\n 1. wf subtest_rel", "unfolding subtest_rel_altdef accp_eq_acc wf_acc_iff"], ["proof (prove)\nusing this:\n  ?t \\<in> Wellfounded.acc {(x, y). subtest x y}\n\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<in> Wellfounded.acc {(s, t) |s t. subtest s t}", "by auto"], ["", "function inputs_atc :: \"('a,'b) ATC \\<Rightarrow> 'a set\" where\n  \"inputs_atc Leaf = {}\" |\n  \"inputs_atc (Node x f) = insert x (\\<Union> (image inputs_atc (range f)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = Leaf \\<Longrightarrow> P;\n        \\<And>xa f. x = Node xa f \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. Leaf = Leaf \\<Longrightarrow> {} = {}\n 3. \\<And>x f.\n       Leaf = Node x f \\<Longrightarrow>\n       {} = insert x (\\<Union> (inputs_atc_sumC ` range f))\n 4. \\<And>x f xa fa.\n       Node x f = Node xa fa \\<Longrightarrow>\n       insert x (\\<Union> (inputs_atc_sumC ` range f)) =\n       insert xa (\\<Union> (inputs_atc_sumC ` range fa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All inputs_atc_dom", "by (relation subtest_rel) auto"], ["", "fun applicable :: \"('in, 'out, 'state) FSM \\<Rightarrow> ('in, 'out) ATC \\<Rightarrow> bool\" where\n  \"applicable M t = (inputs_atc t \\<subseteq> inputs M)\""], ["", "fun applicable_set :: \"('in, 'out, 'state) FSM \\<Rightarrow> ('in, 'out) ATC set \\<Rightarrow> bool\" where\n  \"applicable_set M \\<Omega> = (\\<forall> t \\<in> \\<Omega> . applicable M t)\""], ["", "lemma applicable_subtest :\n  assumes \"applicable M (Node x f)\"\nshows \"applicable M (f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applicable M (f y)", "using assms inputs_atc.simps"], ["proof (prove)\nusing this:\n  applicable M (Node x f)\n  inputs_atc Leaf = {}\n  inputs_atc (Node ?x ?f) = insert ?x (\\<Union> (inputs_atc ` range ?f))\n\ngoal (1 subgoal):\n 1. applicable M (f y)", "by (simp add: Sup_le_iff)"], ["", "subsection \\<open> Application function IO \\<close>"], ["", "text \\<open>\nFunction @{verbatim IO} collects all ATC-reactions of some FSM to some ATC.\n\\<close>"], ["", "fun IO :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \\<Rightarrow> ('in, 'out) ATC \\<Rightarrow> ('in \\<times> 'out) list set\" where\n  \"IO M q t = { tr . atc_reaction M q t tr }\""], ["", "fun IO_set :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \\<Rightarrow> ('in, 'out) ATC set \\<Rightarrow> ('in \\<times> 'out) list set\" \n  where\n  \"IO_set M q \\<Omega> = \\<Union> {IO M q t | t . t \\<in> \\<Omega>}\""], ["", "lemma IO_language : \"IO M q t \\<subseteq> language_state M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO M q t \\<subseteq> LS M q", "by (metis atc_reaction_path IO.elims language_state mem_Collect_eq subsetI)"], ["", "lemma IO_leaf[simp] : \"IO M q Leaf = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO M q Leaf = {[]}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. IO M q Leaf \\<subseteq> {[]}\n 2. {[]} \\<subseteq> IO M q Leaf", "show \"IO M q Leaf \\<subseteq> {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO M q Leaf \\<subseteq> {[]}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> IO M q Leaf \\<subseteq> {[]} \\<Longrightarrow> False", "assume assm : \"\\<not> IO M q Leaf \\<subseteq> {[]}\""], ["proof (state)\nthis:\n  \\<not> IO M q Leaf \\<subseteq> {[]}\n\ngoal (1 subgoal):\n 1. \\<not> IO M q Leaf \\<subseteq> {[]} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> IO M q Leaf \\<subseteq> {[]}", "obtain io_hd io_tl where elem_ex : \"Cons io_hd io_tl \\<in> IO M q Leaf\""], ["proof (prove)\nusing this:\n  \\<not> IO M q Leaf \\<subseteq> {[]}\n\ngoal (1 subgoal):\n 1. (\\<And>io_hd io_tl.\n        io_hd # io_tl \\<in> IO M q Leaf \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, hide_lams) insertI1 neq_Nil_conv subset_eq)"], ["proof (state)\nthis:\n  io_hd # io_tl \\<in> IO M q Leaf\n\ngoal (1 subgoal):\n 1. \\<not> IO M q Leaf \\<subseteq> {[]} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io_hd # io_tl \\<in> IO M q Leaf", "show \"False\""], ["proof (prove)\nusing this:\n  io_hd # io_tl \\<in> IO M q Leaf\n\ngoal (1 subgoal):\n 1. False", "using atc_reaction_nonempty_no_leaf assm"], ["proof (prove)\nusing this:\n  io_hd # io_tl \\<in> IO M q Leaf\n  atc_reaction ?M ?q ?t (?a # ?io) \\<Longrightarrow> ?t \\<noteq> Leaf\n  \\<not> IO M q Leaf \\<subseteq> {[]}\n\ngoal (1 subgoal):\n 1. False", "by (metis IO.simps mem_Collect_eq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IO M q Leaf \\<subseteq> {[]}\n\ngoal (1 subgoal):\n 1. {[]} \\<subseteq> IO M q Leaf", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {[]} \\<subseteq> IO M q Leaf", "show \"{[]} \\<subseteq> IO M q Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {[]} \\<subseteq> IO M q Leaf", "by auto"], ["proof (state)\nthis:\n  {[]} \\<subseteq> IO M q Leaf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IO_applicable_nonempty :\n  assumes \"applicable M t\"\n  and     \"completely_specified M\"\n  and     \"q1 \\<in> nodes M\"\n  shows \"IO M q1 t \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO M q1 t \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  applicable M t\n  completely_specified M\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. IO M q1 t \\<noteq> {}", "proof (induction t arbitrary: q1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q1.\n       \\<lbrakk>applicable M Leaf; completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 Leaf \\<noteq> {}\n 2. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "case Leaf"], ["proof (state)\nthis:\n  applicable M Leaf\n  completely_specified M\n  q1 \\<in> nodes M\n\ngoal (2 subgoals):\n 1. \\<And>q1.\n       \\<lbrakk>applicable M Leaf; completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 Leaf \\<noteq> {}\n 2. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  applicable M Leaf\n  completely_specified M\n  q1 \\<in> nodes M", "show ?case"], ["proof (prove)\nusing this:\n  applicable M Leaf\n  completely_specified M\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. IO M q1 Leaf \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  IO M q1 Leaf \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "case (Node x f)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> range f; applicable M ?x2a; completely_specified M;\n   ?q1.0 \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> IO M ?q1.0 ?x2a \\<noteq> {}\n  applicable M (Node x f)\n  completely_specified M\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> range f; applicable M ?x2a; completely_specified M;\n   ?q1.0 \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> IO M ?q1.0 ?x2a \\<noteq> {}\n  applicable M (Node x f)\n  completely_specified M\n  q1 \\<in> nodes M", "have \"x \\<in> inputs M\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> range f; applicable M ?x2a; completely_specified M;\n   ?q1.0 \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> IO M ?q1.0 ?x2a \\<noteq> {}\n  applicable M (Node x f)\n  completely_specified M\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. x \\<in> inputs M", "by auto"], ["proof (state)\nthis:\n  x \\<in> inputs M\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  x \\<in> inputs M", "obtain y q2  where x_appl : \"q2 \\<in> succ M (x, y) q1\""], ["proof (prove)\nusing this:\n  x \\<in> inputs M\n\ngoal (1 subgoal):\n 1. (\\<And>q2 y.\n        q2 \\<in> succ M (x, y) q1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Node"], ["proof (prove)\nusing this:\n  x \\<in> inputs M\n  \\<lbrakk>?x2a \\<in> range f; applicable M ?x2a; completely_specified M;\n   ?q1.0 \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> IO M ?q1.0 ?x2a \\<noteq> {}\n  applicable M (Node x f)\n  completely_specified M\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. (\\<And>q2 y.\n        q2 \\<in> succ M (x, y) q1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding completely_specified.simps"], ["proof (prove)\nusing this:\n  x \\<in> inputs M\n  \\<lbrakk>?x2a \\<in> range f; applicable M ?x2a;\n   \\<forall>s1\\<in>nodes M.\n      \\<forall>x\\<in>inputs M.\n         \\<exists>y\\<in>outputs M. \\<exists>s2. s2 \\<in> succ M (x, y) s1;\n   ?q1.0 \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> IO M ?q1.0 ?x2a \\<noteq> {}\n  applicable M (Node x f)\n  \\<forall>s1\\<in>nodes M.\n     \\<forall>x\\<in>inputs M.\n        \\<exists>y\\<in>outputs M. \\<exists>s2. s2 \\<in> succ M (x, y) s1\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. (\\<And>q2 y.\n        q2 \\<in> succ M (x, y) q1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q2 \\<in> succ M (x, y) q1\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  q2 \\<in> succ M (x, y) q1", "have \"applicable M (f y)\""], ["proof (prove)\nusing this:\n  q2 \\<in> succ M (x, y) q1\n\ngoal (1 subgoal):\n 1. applicable M (f y)", "using applicable_subtest Node"], ["proof (prove)\nusing this:\n  q2 \\<in> succ M (x, y) q1\n  applicable ?M (Node ?x ?f) \\<Longrightarrow> applicable ?M (?f ?y)\n  \\<lbrakk>?x2a \\<in> range f; applicable M ?x2a; completely_specified M;\n   ?q1.0 \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> IO M ?q1.0 ?x2a \\<noteq> {}\n  applicable M (Node x f)\n  completely_specified M\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. applicable M (f y)", "by metis"], ["proof (state)\nthis:\n  applicable M (f y)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  applicable M (f y)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "have \"q2 \\<in> nodes M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M", "using Node(4) \\<open>q2 \\<in> succ M (x, y) q1\\<close> FSM.nodes.intros(2)[of q1 M \"((x,y),q2)\"]"], ["proof (prove)\nusing this:\n  q1 \\<in> nodes M\n  q2 \\<in> succ M (x, y) q1\n  \\<lbrakk>q1 \\<in> nodes M;\n   snd ((x, y), q2) \\<in> succ M (fst ((x, y), q2)) q1\\<rbrakk>\n  \\<Longrightarrow> snd ((x, y), q2) \\<in> nodes M\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M", "by auto"], ["proof (state)\nthis:\n  q2 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  applicable M (f y)\n  q2 \\<in> nodes M", "have \"IO M q2 (f y) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  applicable M (f y)\n  q2 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. IO M q2 (f y) \\<noteq> {}", "using Node"], ["proof (prove)\nusing this:\n  applicable M (f y)\n  q2 \\<in> nodes M\n  \\<lbrakk>?x2a \\<in> range f; applicable M ?x2a; completely_specified M;\n   ?q1.0 \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> IO M ?q1.0 ?x2a \\<noteq> {}\n  applicable M (Node x f)\n  completely_specified M\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. IO M q2 (f y) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  IO M q2 (f y) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q1.\n       \\<lbrakk>\\<And>x2a q1.\n                   \\<lbrakk>x2a \\<in> range x2; applicable M x2a;\n                    completely_specified M; q1 \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> IO M q1 x2a \\<noteq> {};\n        applicable M (Node x1 x2); completely_specified M;\n        q1 \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> IO M q1 (Node x1 x2) \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  IO M q2 (f y) \\<noteq> {}", "show ?case"], ["proof (prove)\nusing this:\n  IO M q2 (f y) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. IO M q1 (Node x f) \\<noteq> {}", "unfolding IO.simps"], ["proof (prove)\nusing this:\n  Collect (atc_reaction M q2 (f y)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Collect (atc_reaction M q1 (Node x f)) \\<noteq> {}", "using x_appl"], ["proof (prove)\nusing this:\n  Collect (atc_reaction M q2 (f y)) \\<noteq> {}\n  q2 \\<in> succ M (x, y) q1\n\ngoal (1 subgoal):\n 1. Collect (atc_reaction M q1 (Node x f)) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  IO M q1 (Node x f) \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IO_in_language :\n  \"IO M q t \\<subseteq> LS M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO M q t \\<subseteq> LS M q", "unfolding IO.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (atc_reaction M q t) \\<subseteq> LS M q", "by blast"], ["", "lemma IO_set_in_language :\n  \"IO_set M q \\<Omega> \\<subseteq> LS M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO_set M q \\<Omega> \\<subseteq> LS M q", "using IO_in_language[of M q]"], ["proof (prove)\nusing this:\n  IO M q ?t \\<subseteq> LS M q\n\ngoal (1 subgoal):\n 1. IO_set M q \\<Omega> \\<subseteq> LS M q", "unfolding IO_set.simps"], ["proof (prove)\nusing this:\n  IO M q ?t \\<subseteq> LS M q\n\ngoal (1 subgoal):\n 1. \\<Union> {IO M q t |t. t \\<in> \\<Omega>} \\<subseteq> LS M q", "by blast"], ["", "subsection \\<open> R-distinguishability \\<close>"], ["", "text \\<open>\nA non-empty ATC r-distinguishes two states of some FSM if there exists no shared ATC-reaction.\n\\<close>"], ["", "fun r_dist :: \"('in, 'out, 'state) FSM \\<Rightarrow> ('in, 'out) ATC \\<Rightarrow> 'state \\<Rightarrow> 'state \\<Rightarrow> bool\" where\n\"r_dist M t s1 s2 = (t \\<noteq> Leaf \\<and> IO M s1 t \\<inter> IO M s2 t = {})\""], ["", "fun r_dist_set :: \"('in, 'out, 'state) FSM \\<Rightarrow> ('in, 'out) ATC set \\<Rightarrow> 'state \\<Rightarrow> 'state \\<Rightarrow> bool\" where\n\"r_dist_set M T s1 s2 = (\\<exists> t \\<in> T . r_dist M t s1 s2)\""], ["", "lemma r_dist_dist :\n  assumes \"applicable M t\"\n  and     \"completely_specified M\"\n  and     \"r_dist M t q1 q2\"\n  and     \"q1 \\<in> nodes M\"\nshows   \"q1 \\<noteq> q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> q1 \\<noteq> q2 \\<Longrightarrow> False", "assume \"\\<not>(q1 \\<noteq> q2)\""], ["proof (state)\nthis:\n  \\<not> q1 \\<noteq> q2\n\ngoal (1 subgoal):\n 1. \\<not> q1 \\<noteq> q2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> q1 \\<noteq> q2", "have \"q1 = q2\""], ["proof (prove)\nusing this:\n  \\<not> q1 \\<noteq> q2\n\ngoal (1 subgoal):\n 1. q1 = q2", "by simp"], ["proof (state)\nthis:\n  q1 = q2\n\ngoal (1 subgoal):\n 1. \\<not> q1 \\<noteq> q2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  q1 = q2", "have \"IO M q1 t = {}\""], ["proof (prove)\nusing this:\n  q1 = q2\n\ngoal (1 subgoal):\n 1. IO M q1 t = {}", "using assms"], ["proof (prove)\nusing this:\n  q1 = q2\n  applicable M t\n  completely_specified M\n  r_dist M t q1 q2\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. IO M q1 t = {}", "by simp"], ["proof (state)\nthis:\n  IO M q1 t = {}\n\ngoal (1 subgoal):\n 1. \\<not> q1 \\<noteq> q2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  IO M q1 t = {}\n\ngoal (1 subgoal):\n 1. \\<not> q1 \\<noteq> q2 \\<Longrightarrow> False", "have \"IO M q1 t \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO M q1 t \\<noteq> {}", "using assms IO_applicable_nonempty"], ["proof (prove)\nusing this:\n  applicable M t\n  completely_specified M\n  r_dist M t q1 q2\n  q1 \\<in> nodes M\n  \\<lbrakk>applicable ?M ?t; completely_specified ?M;\n   ?q1.0 \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> IO ?M ?q1.0 ?t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. IO M q1 t \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  IO M q1 t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> q1 \\<noteq> q2 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  IO M q1 t = {}\n  IO M q1 t \\<noteq> {}", "show \"False\""], ["proof (prove)\nusing this:\n  IO M q1 t = {}\n  IO M q1 t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_dist_set_dist :\n  assumes \"applicable_set M \\<Omega>\"\n  and     \"completely_specified M\"\n  and     \"r_dist_set M \\<Omega> q1 q2\"\n  and     \"q1 \\<in> nodes M\"\nshows   \"q1 \\<noteq> q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2", "using assms r_dist_dist"], ["proof (prove)\nusing this:\n  applicable_set M \\<Omega>\n  completely_specified M\n  r_dist_set M \\<Omega> q1 q2\n  q1 \\<in> nodes M\n  \\<lbrakk>applicable ?M ?t; completely_specified ?M;\n   r_dist ?M ?t ?q1.0 ?q2.0; ?q1.0 \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> ?q1.0 \\<noteq> ?q2.0\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2", "by (metis applicable_set.elims(2) r_dist_set.elims(2))"], ["", "lemma r_dist_set_dist_disjoint :\n  assumes \"applicable_set M \\<Omega>\"\n  and     \"completely_specified M\"\n  and     \"\\<forall> t1 \\<in> T1 . \\<forall> t2 \\<in> T2 . r_dist_set M \\<Omega> t1 t2\"\n  and     \"T1 \\<subseteq> nodes M\"\nshows \"T1 \\<inter> T2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T1 \\<inter> T2 = {}", "by (metis assms disjoint_iff_not_equal r_dist_set_dist subsetCE)"], ["", "subsection \\<open> Response sets \\<close>"], ["", "text \\<open>\nThe following functions calculate the sets of all ATC-reactions observed by applying some set of \nATCs on every state reached in some FSM using a given set of IO-sequences.\n\\<close>"], ["", "fun B :: \"('in, 'out, 'state) FSM \\<Rightarrow> ('in * 'out) list \\<Rightarrow> ('in, 'out) ATC set \n          \\<Rightarrow> ('in * 'out) list set\" where\n  \"B M io \\<Omega> = \\<Union> (image (\\<lambda> s . IO_set M s \\<Omega>) (io_targets M (initial M) io))\""], ["", "fun D :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'in list set \\<Rightarrow> ('in, 'out) ATC set\n          \\<Rightarrow> ('in * 'out) list set set\" where\n  \"D M ISeqs \\<Omega> = image (\\<lambda> io . B M io \\<Omega>) (LS\\<^sub>i\\<^sub>n M (initial M) ISeqs)\""], ["", "fun append_io_B :: \"('in, 'out, 'state) FSM \\<Rightarrow> ('in * 'out) list \\<Rightarrow> ('in, 'out) ATC set \n                    \\<Rightarrow> ('in * 'out) list set\" where\n  \"append_io_B M io \\<Omega> = { io@res | res . res \\<in> B M io \\<Omega> }\""], ["", "lemma B_dist' :\n  assumes df: \"B M io1 \\<Omega> \\<noteq> B M io2 \\<Omega>\"\n  shows   \"(io_targets M (initial M) io1) \\<noteq> (io_targets M (initial M) io2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M (initial M) io1 \\<noteq> io_targets M (initial M) io2", "using assms"], ["proof (prove)\nusing this:\n  B M io1 \\<Omega> \\<noteq> B M io2 \\<Omega>\n\ngoal (1 subgoal):\n 1. io_targets M (initial M) io1 \\<noteq> io_targets M (initial M) io2", "by force"], ["", "lemma B_dist :\n  assumes \"io_targets M (initial M) io1 = {q1}\"\n  and     \"io_targets M (initial M) io2 = {q2}\"\n  and     \"B M io1 \\<Omega> \\<noteq> B M io2 \\<Omega>\"\nshows   \"q1 \\<noteq> q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2", "using assms"], ["proof (prove)\nusing this:\n  io_targets M (initial M) io1 = {q1}\n  io_targets M (initial M) io2 = {q2}\n  B M io1 \\<Omega> \\<noteq> B M io2 \\<Omega>\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2", "by force"], ["", "lemma D_bound :\n  assumes wf: \"well_formed M\"\n  and     ob: \"observable M\"\n  and     fi: \"finite ISeqs\"\n  shows \"finite (D M ISeqs \\<Omega>)\" \"card (D M ISeqs \\<Omega>) \\<le> card (nodes M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (D M ISeqs \\<Omega>) &&& card (D M ISeqs \\<Omega>) \\<le> |M|", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (D M ISeqs \\<Omega>)\n 2. card (D M ISeqs \\<Omega>) \\<le> |M|", "have \"D M ISeqs \\<Omega> \\<subseteq> image (\\<lambda> s . IO_set M s \\<Omega>) (nodes M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D M ISeqs \\<Omega>\n    \\<subseteq> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D M ISeqs \\<Omega> \\<Longrightarrow>\n       x \\<in> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M", "fix RS"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D M ISeqs \\<Omega> \\<Longrightarrow>\n       x \\<in> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M", "assume RS_def : \"RS \\<in> D M ISeqs \\<Omega>\""], ["proof (state)\nthis:\n  RS \\<in> D M ISeqs \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D M ISeqs \\<Omega> \\<Longrightarrow>\n       x \\<in> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M", "then"], ["proof (chain)\npicking this:\n  RS \\<in> D M ISeqs \\<Omega>", "obtain xs ys where RS_tr : \"RS = B M (xs || ys) \\<Omega>\" \n                                    \"(xs \\<in> ISeqs \\<and> length xs = length ys \n                                        \\<and> (xs || ys) \\<in> language_state M (initial M))\""], ["proof (prove)\nusing this:\n  RS \\<in> D M ISeqs \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>RS = B M (xs || ys) \\<Omega>;\n         xs \\<in> ISeqs \\<and>\n         length xs = length ys \\<and> xs || ys \\<in> L M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  RS = B M (xs || ys) \\<Omega>\n  xs \\<in> ISeqs \\<and> length xs = length ys \\<and> xs || ys \\<in> L M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D M ISeqs \\<Omega> \\<Longrightarrow>\n       x \\<in> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M", "then"], ["proof (chain)\npicking this:\n  RS = B M (xs || ys) \\<Omega>\n  xs \\<in> ISeqs \\<and> length xs = length ys \\<and> xs || ys \\<in> L M", "obtain qx where qx_def : \"io_targets M (initial M) (xs || ys) = { qx }\""], ["proof (prove)\nusing this:\n  RS = B M (xs || ys) \\<Omega>\n  xs \\<in> ISeqs \\<and> length xs = length ys \\<and> xs || ys \\<in> L M\n\ngoal (1 subgoal):\n 1. (\\<And>qx.\n        io_targets M (initial M) (xs || ys) = {qx} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson io_targets_observable_singleton_ex ob)"], ["proof (state)\nthis:\n  io_targets M (initial M) (xs || ys) = {qx}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D M ISeqs \\<Omega> \\<Longrightarrow>\n       x \\<in> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M", "then"], ["proof (chain)\npicking this:\n  io_targets M (initial M) (xs || ys) = {qx}", "have \"RS = IO_set M qx \\<Omega>\""], ["proof (prove)\nusing this:\n  io_targets M (initial M) (xs || ys) = {qx}\n\ngoal (1 subgoal):\n 1. RS = IO_set M qx \\<Omega>", "using RS_tr"], ["proof (prove)\nusing this:\n  io_targets M (initial M) (xs || ys) = {qx}\n  RS = B M (xs || ys) \\<Omega>\n  xs \\<in> ISeqs \\<and> length xs = length ys \\<and> xs || ys \\<in> L M\n\ngoal (1 subgoal):\n 1. RS = IO_set M qx \\<Omega>", "by auto"], ["proof (state)\nthis:\n  RS = IO_set M qx \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D M ISeqs \\<Omega> \\<Longrightarrow>\n       x \\<in> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M", "moreover"], ["proof (state)\nthis:\n  RS = IO_set M qx \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D M ISeqs \\<Omega> \\<Longrightarrow>\n       x \\<in> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M", "have \"qx \\<in> nodes M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qx \\<in> nodes M", "by (metis FSM.nodes.initial io_targets_nodes qx_def singletonI)"], ["proof (state)\nthis:\n  qx \\<in> nodes M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D M ISeqs \\<Omega> \\<Longrightarrow>\n       x \\<in> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M", "ultimately"], ["proof (chain)\npicking this:\n  RS = IO_set M qx \\<Omega>\n  qx \\<in> nodes M", "show \"RS \\<in> image (\\<lambda> s . IO_set M s \\<Omega>) (nodes M)\""], ["proof (prove)\nusing this:\n  RS = IO_set M qx \\<Omega>\n  qx \\<in> nodes M\n\ngoal (1 subgoal):\n 1. RS \\<in> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M", "by auto"], ["proof (state)\nthis:\n  RS \\<in> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D M ISeqs \\<Omega> \\<subseteq> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M\n\ngoal (2 subgoals):\n 1. finite (D M ISeqs \\<Omega>)\n 2. card (D M ISeqs \\<Omega>) \\<le> |M|", "moreover"], ["proof (state)\nthis:\n  D M ISeqs \\<Omega> \\<subseteq> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M\n\ngoal (2 subgoals):\n 1. finite (D M ISeqs \\<Omega>)\n 2. card (D M ISeqs \\<Omega>) \\<le> |M|", "have \"finite (nodes M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M)", "using assms"], ["proof (prove)\nusing this:\n  well_formed M\n  observable M\n  finite ISeqs\n\ngoal (1 subgoal):\n 1. finite (nodes M)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M)\n\ngoal (2 subgoals):\n 1. finite (D M ISeqs \\<Omega>)\n 2. card (D M ISeqs \\<Omega>) \\<le> |M|", "ultimately"], ["proof (chain)\npicking this:\n  D M ISeqs \\<Omega> \\<subseteq> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M\n  finite (nodes M)", "show \"finite (D M ISeqs \\<Omega>)\" \"card (D M ISeqs \\<Omega>) \\<le> card (nodes M)\""], ["proof (prove)\nusing this:\n  D M ISeqs \\<Omega> \\<subseteq> (\\<lambda>s. IO_set M s \\<Omega>) ` nodes M\n  finite (nodes M)\n\ngoal (1 subgoal):\n 1. finite (D M ISeqs \\<Omega>) &&& card (D M ISeqs \\<Omega>) \\<le> |M|", "by (meson  finite_imageI infinite_super surj_card_le)+"], ["proof (state)\nthis:\n  finite (D M ISeqs \\<Omega>)\n  card (D M ISeqs \\<Omega>) \\<le> |M|\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma append_io_B_in_language :\n  \"append_io_B M io \\<Omega> \\<subseteq> L M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<subseteq> L M", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> append_io_B M io \\<Omega> \\<Longrightarrow> x \\<in> L M", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> append_io_B M io \\<Omega> \\<Longrightarrow> x \\<in> L M", "assume \"x \\<in> append_io_B M io \\<Omega>\""], ["proof (state)\nthis:\n  x \\<in> append_io_B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> append_io_B M io \\<Omega> \\<Longrightarrow> x \\<in> L M", "then"], ["proof (chain)\npicking this:\n  x \\<in> append_io_B M io \\<Omega>", "obtain res where \"x = io@res\" \"res \\<in> B M io \\<Omega>\""], ["proof (prove)\nusing this:\n  x \\<in> append_io_B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>res.\n        \\<lbrakk>x = io @ res; res \\<in> B M io \\<Omega>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding append_io_B.simps"], ["proof (prove)\nusing this:\n  x \\<in> {io @ res |res. res \\<in> B M io \\<Omega>}\n\ngoal (1 subgoal):\n 1. (\\<And>res.\n        \\<lbrakk>x = io @ res; res \\<in> B M io \\<Omega>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = io @ res\n  res \\<in> B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> append_io_B M io \\<Omega> \\<Longrightarrow> x \\<in> L M", "then"], ["proof (chain)\npicking this:\n  x = io @ res\n  res \\<in> B M io \\<Omega>", "obtain q where \"q \\<in> io_targets M (initial M) io\"  \"res \\<in> IO_set M q \\<Omega>\""], ["proof (prove)\nusing this:\n  x = io @ res\n  res \\<in> B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> io_targets M (initial M) io;\n         res \\<in> IO_set M q \\<Omega>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding B.simps"], ["proof (prove)\nusing this:\n  x = io @ res\n  res \\<in> (\\<Union>s\\<in>io_targets M (initial M) io. IO_set M s \\<Omega>)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> io_targets M (initial M) io;\n         res \\<in> IO_set M q \\<Omega>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q \\<in> io_targets M (initial M) io\n  res \\<in> IO_set M q \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> append_io_B M io \\<Omega> \\<Longrightarrow> x \\<in> L M", "then"], ["proof (chain)\npicking this:\n  q \\<in> io_targets M (initial M) io\n  res \\<in> IO_set M q \\<Omega>", "have \"res \\<in> LS M q\""], ["proof (prove)\nusing this:\n  q \\<in> io_targets M (initial M) io\n  res \\<in> IO_set M q \\<Omega>\n\ngoal (1 subgoal):\n 1. res \\<in> LS M q", "using IO_set_in_language[of M q \\<Omega>]"], ["proof (prove)\nusing this:\n  q \\<in> io_targets M (initial M) io\n  res \\<in> IO_set M q \\<Omega>\n  IO_set M q \\<Omega> \\<subseteq> LS M q\n\ngoal (1 subgoal):\n 1. res \\<in> LS M q", "by blast"], ["proof (state)\nthis:\n  res \\<in> LS M q\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> append_io_B M io \\<Omega> \\<Longrightarrow> x \\<in> L M", "obtain pIO where \"path M (io || pIO) (initial M)\" \n                   \"length pIO = length io\" \"target (io || pIO) (initial M) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pIO.\n        \\<lbrakk>path M (io || pIO) (initial M); length pIO = length io;\n         target (io || pIO) (initial M) = q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>q \\<in> io_targets M (initial M) io\\<close>"], ["proof (prove)\nusing this:\n  q \\<in> io_targets M (initial M) io\n\ngoal (1 subgoal):\n 1. (\\<And>pIO.\n        \\<lbrakk>path M (io || pIO) (initial M); length pIO = length io;\n         target (io || pIO) (initial M) = q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M (io || pIO) (initial M)\n  length pIO = length io\n  target (io || pIO) (initial M) = q\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> append_io_B M io \\<Omega> \\<Longrightarrow> x \\<in> L M", "moreover"], ["proof (state)\nthis:\n  path M (io || pIO) (initial M)\n  length pIO = length io\n  target (io || pIO) (initial M) = q\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> append_io_B M io \\<Omega> \\<Longrightarrow> x \\<in> L M", "obtain pRes where \"path M (res || pRes) q\" \"length pRes = length res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pRes.\n        \\<lbrakk>path M (res || pRes) q; length pRes = length res\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>res \\<in> LS M q\\<close>"], ["proof (prove)\nusing this:\n  res \\<in> LS M q\n\ngoal (1 subgoal):\n 1. (\\<And>pRes.\n        \\<lbrakk>path M (res || pRes) q; length pRes = length res\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M (res || pRes) q\n  length pRes = length res\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> append_io_B M io \\<Omega> \\<Longrightarrow> x \\<in> L M", "ultimately"], ["proof (chain)\npicking this:\n  path M (io || pIO) (initial M)\n  length pIO = length io\n  target (io || pIO) (initial M) = q\n  path M (res || pRes) q\n  length pRes = length res", "have \"io@res \\<in> L M\""], ["proof (prove)\nusing this:\n  path M (io || pIO) (initial M)\n  length pIO = length io\n  target (io || pIO) (initial M) = q\n  path M (res || pRes) q\n  length pRes = length res\n\ngoal (1 subgoal):\n 1. io @ res \\<in> L M", "using FSM.path_append[of M \"io||pIO\" \"initial M\" \"res||pRes\"]"], ["proof (prove)\nusing this:\n  path M (io || pIO) (initial M)\n  length pIO = length io\n  target (io || pIO) (initial M) = q\n  path M (res || pRes) q\n  length pRes = length res\n  \\<lbrakk>path M (io || pIO) (initial M);\n   path M (res || pRes) (target (io || pIO) (initial M))\\<rbrakk>\n  \\<Longrightarrow> path M ((io || pIO) @ (res || pRes)) (initial M)\n\ngoal (1 subgoal):\n 1. io @ res \\<in> L M", "by (metis language_state length_append zip_append)"], ["proof (state)\nthis:\n  io @ res \\<in> L M\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> append_io_B M io \\<Omega> \\<Longrightarrow> x \\<in> L M", "then"], ["proof (chain)\npicking this:\n  io @ res \\<in> L M", "show \"x \\<in> L M\""], ["proof (prove)\nusing this:\n  io @ res \\<in> L M\n\ngoal (1 subgoal):\n 1. x \\<in> L M", "using \\<open>x = io@res\\<close>"], ["proof (prove)\nusing this:\n  io @ res \\<in> L M\n  x = io @ res\n\ngoal (1 subgoal):\n 1. x \\<in> L M", "by blast"], ["proof (state)\nthis:\n  x \\<in> L M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma append_io_B_nonempty :\n  assumes \"applicable_set M \\<Omega>\"\n  and     \"completely_specified M\"\n  and     \"io \\<in> language_state M (initial M)\"\n  and     \"\\<Omega> \\<noteq> {}\"\nshows \"append_io_B M io \\<Omega> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "obtain t where \"t \\<in> \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. t \\<in> \\<Omega> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(4)"], ["proof (prove)\nusing this:\n  \\<Omega> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t. t \\<in> \\<Omega> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> \\<Omega>\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  t \\<in> \\<Omega>", "have \"applicable M t\""], ["proof (prove)\nusing this:\n  t \\<in> \\<Omega>\n\ngoal (1 subgoal):\n 1. applicable M t", "using assms(1)"], ["proof (prove)\nusing this:\n  t \\<in> \\<Omega>\n  applicable_set M \\<Omega>\n\ngoal (1 subgoal):\n 1. applicable M t", "by simp"], ["proof (state)\nthis:\n  applicable M t\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  applicable M t\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "obtain tr where \"path M (io || tr) (initial M) \\<and> length tr = length io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        path M (io || tr) (initial M) \\<and>\n        length tr = length io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  io \\<in> L M\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        path M (io || tr) (initial M) \\<and>\n        length tr = length io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M (io || tr) (initial M) \\<and> length tr = length io\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  path M (io || tr) (initial M) \\<and> length tr = length io\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "have \"target (io || tr) (initial M) \\<in> nodes M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || tr) (initial M) \\<in> nodes M", "using calculation(2)"], ["proof (prove)\nusing this:\n  path M (io || tr) (initial M) \\<and> length tr = length io\n\ngoal (1 subgoal):\n 1. target (io || tr) (initial M) \\<in> nodes M", "by blast"], ["proof (state)\nthis:\n  target (io || tr) (initial M) \\<in> nodes M\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  applicable M t\n  path M (io || tr) (initial M) \\<and> length tr = length io\n  target (io || tr) (initial M) \\<in> nodes M", "have \"IO M (target (io || tr) (initial M)) t \\<noteq> {}\""], ["proof (prove)\nusing this:\n  applicable M t\n  path M (io || tr) (initial M) \\<and> length tr = length io\n  target (io || tr) (initial M) \\<in> nodes M\n\ngoal (1 subgoal):\n 1. IO M (target (io || tr) (initial M)) t \\<noteq> {}", "using assms(2) IO_applicable_nonempty"], ["proof (prove)\nusing this:\n  applicable M t\n  path M (io || tr) (initial M) \\<and> length tr = length io\n  target (io || tr) (initial M) \\<in> nodes M\n  completely_specified M\n  \\<lbrakk>applicable ?M ?t; completely_specified ?M;\n   ?q1.0 \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> IO ?M ?q1.0 ?t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. IO M (target (io || tr) (initial M)) t \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  IO M (target (io || tr) (initial M)) t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  IO M (target (io || tr) (initial M)) t \\<noteq> {}", "obtain io' where \"io' \\<in> IO M (target (io || tr) (initial M)) t\""], ["proof (prove)\nusing this:\n  IO M (target (io || tr) (initial M)) t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>io'.\n        io' \\<in> IO M (target (io || tr) (initial M)) t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  io' \\<in> IO M (target (io || tr) (initial M)) t\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  io' \\<in> IO M (target (io || tr) (initial M)) t", "have \"io' \\<in> IO_set M (target (io || tr) (initial M)) \\<Omega>\""], ["proof (prove)\nusing this:\n  io' \\<in> IO M (target (io || tr) (initial M)) t\n\ngoal (1 subgoal):\n 1. io' \\<in> IO_set M (target (io || tr) (initial M)) \\<Omega>", "using \\<open>t \\<in> \\<Omega>\\<close>"], ["proof (prove)\nusing this:\n  io' \\<in> IO M (target (io || tr) (initial M)) t\n  t \\<in> \\<Omega>\n\ngoal (1 subgoal):\n 1. io' \\<in> IO_set M (target (io || tr) (initial M)) \\<Omega>", "unfolding IO_set.simps"], ["proof (prove)\nusing this:\n  io' \\<in> IO M (target (io || tr) (initial M)) t\n  t \\<in> \\<Omega>\n\ngoal (1 subgoal):\n 1. io'\n    \\<in> \\<Union>\n           {IO M (target (io || tr) (initial M)) t |t. t \\<in> \\<Omega>}", "by blast"], ["proof (state)\nthis:\n  io' \\<in> IO_set M (target (io || tr) (initial M)) \\<Omega>\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  io' \\<in> IO_set M (target (io || tr) (initial M)) \\<Omega>\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "have \"(target (io || tr) (initial M)) \\<in> io_targets M (initial M) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || tr) (initial M) \\<in> io_targets M (initial M) io", "using \\<open>path M (io || tr) (initial M) \\<and> length tr = length io\\<close>"], ["proof (prove)\nusing this:\n  path M (io || tr) (initial M) \\<and> length tr = length io\n\ngoal (1 subgoal):\n 1. target (io || tr) (initial M) \\<in> io_targets M (initial M) io", "by auto"], ["proof (state)\nthis:\n  target (io || tr) (initial M) \\<in> io_targets M (initial M) io\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  io' \\<in> IO_set M (target (io || tr) (initial M)) \\<Omega>\n  target (io || tr) (initial M) \\<in> io_targets M (initial M) io", "have \"io' \\<in> B M io \\<Omega>\""], ["proof (prove)\nusing this:\n  io' \\<in> IO_set M (target (io || tr) (initial M)) \\<Omega>\n  target (io || tr) (initial M) \\<in> io_targets M (initial M) io\n\ngoal (1 subgoal):\n 1. io' \\<in> B M io \\<Omega>", "unfolding B.simps"], ["proof (prove)\nusing this:\n  io' \\<in> IO_set M (target (io || tr) (initial M)) \\<Omega>\n  target (io || tr) (initial M) \\<in> io_targets M (initial M) io\n\ngoal (1 subgoal):\n 1. io'\n    \\<in> (\\<Union>s\\<in>io_targets M (initial M) io. IO_set M s \\<Omega>)", "by blast"], ["proof (state)\nthis:\n  io' \\<in> B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  io' \\<in> B M io \\<Omega>", "have \"io@io' \\<in> append_io_B M io \\<Omega>\""], ["proof (prove)\nusing this:\n  io' \\<in> B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. io @ io' \\<in> append_io_B M io \\<Omega>", "unfolding append_io_B.simps"], ["proof (prove)\nusing this:\n  io' \\<in> B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. io @ io' \\<in> {io @ res |res. res \\<in> B M io \\<Omega>}", "by blast"], ["proof (state)\nthis:\n  io @ io' \\<in> append_io_B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  io @ io' \\<in> append_io_B M io \\<Omega>", "show ?thesis"], ["proof (prove)\nusing this:\n  io @ io' \\<in> append_io_B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. append_io_B M io \\<Omega> \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  append_io_B M io \\<Omega> \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma append_io_B_prefix_in_language :\n  assumes \"append_io_B M io \\<Omega> \\<noteq> {}\"\n  shows \"io \\<in> L M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> L M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io \\<in> L M", "obtain res where \"io @ res \\<in> append_io_B M io \\<Omega> \\<and> res \\<in> B M io \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>res.\n        io @ res \\<in> append_io_B M io \\<Omega> \\<and>\n        res \\<in> B M io \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  append_io_B M io \\<Omega> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>res.\n        io @ res \\<in> append_io_B M io \\<Omega> \\<and>\n        res \\<in> B M io \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  io @ res \\<in> append_io_B M io \\<Omega> \\<and> res \\<in> B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. io \\<in> L M", "then"], ["proof (chain)\npicking this:\n  io @ res \\<in> append_io_B M io \\<Omega> \\<and> res \\<in> B M io \\<Omega>", "have \"io_targets M (initial M) io \\<noteq> {}\""], ["proof (prove)\nusing this:\n  io @ res \\<in> append_io_B M io \\<Omega> \\<and> res \\<in> B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. io_targets M (initial M) io \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  io_targets M (initial M) io \\<noteq> {}\n\ngoal (1 subgoal):\n 1. io \\<in> L M", "then"], ["proof (chain)\npicking this:\n  io_targets M (initial M) io \\<noteq> {}", "obtain q where \"q \\<in> io_targets M (initial M) io\""], ["proof (prove)\nusing this:\n  io_targets M (initial M) io \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> io_targets M (initial M) io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q \\<in> io_targets M (initial M) io\n\ngoal (1 subgoal):\n 1. io \\<in> L M", "then"], ["proof (chain)\npicking this:\n  q \\<in> io_targets M (initial M) io", "obtain tr where \"target (io || tr) (initial M) = q \\<and> path M (io || tr) (initial M) \n                          \\<and> length tr = length io\""], ["proof (prove)\nusing this:\n  q \\<in> io_targets M (initial M) io\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        target (io || tr) (initial M) = q \\<and>\n        path M (io || tr) (initial M) \\<and>\n        length tr = length io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  target (io || tr) (initial M) = q \\<and>\n  path M (io || tr) (initial M) \\<and> length tr = length io\n\ngoal (1 subgoal):\n 1. io \\<in> L M", "then"], ["proof (chain)\npicking this:\n  target (io || tr) (initial M) = q \\<and>\n  path M (io || tr) (initial M) \\<and> length tr = length io", "show ?thesis"], ["proof (prove)\nusing this:\n  target (io || tr) (initial M) = q \\<and>\n  path M (io || tr) (initial M) \\<and> length tr = length io\n\ngoal (1 subgoal):\n 1. io \\<in> L M", "by auto"], ["proof (state)\nthis:\n  io \\<in> L M\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Characterizing sets \\<close>"], ["", "text \\<open>\nA set of ATCs is a characterizing set for some FSM if for every pair of r-distinguishable states it\ncontains an ATC that r-distinguishes them.\n\\<close>"], ["", "fun characterizing_atc_set :: \"('in, 'out, 'state) FSM \\<Rightarrow> ('in, 'out) ATC set \\<Rightarrow> bool\" where\n\"characterizing_atc_set M \\<Omega> = (applicable_set M \\<Omega> \\<and> (\\<forall> s1 \\<in> (nodes M) . \\<forall> s2 \\<in> (nodes M) . \n    (\\<exists> td . r_dist M td s1 s2) \\<longrightarrow> (\\<exists> tt \\<in> \\<Omega> . r_dist M tt s1 s2)))\""], ["", "subsection \\<open> Reduction over ATCs \\<close>"], ["", "text \\<open>\nSome state is a an ATC-reduction of another over some set of ATCs if for every contained ATC every \nATC-reaction to it of the former state is also an ATC-reaction of the latter state.\n\\<close>"], ["", "fun atc_reduction :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \\<Rightarrow> ('in, 'out, 'state) FSM \\<Rightarrow> 'state \n                      \\<Rightarrow> ('in, 'out) ATC set \\<Rightarrow> bool\" where\n  \"atc_reduction M2 s2 M1 s1 \\<Omega> = (\\<forall> t \\<in> \\<Omega> . IO M2 s2 t \\<subseteq> IO M1 s1 t)\"\n\n\n\n\\<comment> \\<open>r-distinguishability holds for atc-reductions\\<close>"], ["", "lemma atc_rdist_dist[intro] :\n  assumes wf2   : \"well_formed M2\"\n  and     cs2   : \"completely_specified M2\"\n  and     ap2   : \"applicable_set M2 \\<Omega>\"\n  and     el_t1 : \"t1 \\<in> nodes M2\"\n  and     red1  : \"atc_reduction M2 t1 M1 s1 \\<Omega>\"\n  and     red2  : \"atc_reduction M2 t2 M1 s2 \\<Omega>\"\n  and     rdist : \"r_dist_set M1 \\<Omega> s1 s2\"\n  and             \"t1 \\<in> nodes M2\"\nshows \"r_dist_set M2 \\<Omega> t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "obtain td where td_def : \"td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>td.\n        td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using rdist"], ["proof (prove)\nusing this:\n  r_dist_set M1 \\<Omega> s1 s2\n\ngoal (1 subgoal):\n 1. (\\<And>td.\n        td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "then"], ["proof (chain)\npicking this:\n  td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2", "have \"IO M1 s1 td \\<inter> IO M1 s2 td = {}\""], ["proof (prove)\nusing this:\n  td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2\n\ngoal (1 subgoal):\n 1. IO M1 s1 td \\<inter> IO M1 s2 td = {}", "using td_def"], ["proof (prove)\nusing this:\n  td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2\n  td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2\n\ngoal (1 subgoal):\n 1. IO M1 s1 td \\<inter> IO M1 s2 td = {}", "by simp"], ["proof (state)\nthis:\n  IO M1 s1 td \\<inter> IO M1 s2 td = {}\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "moreover"], ["proof (state)\nthis:\n  IO M1 s1 td \\<inter> IO M1 s2 td = {}\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "have \"IO M2 t1 td \\<subseteq> IO M1 s1 td\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO M2 t1 td \\<subseteq> IO M1 s1 td", "using red1 td_def"], ["proof (prove)\nusing this:\n  atc_reduction M2 t1 M1 s1 \\<Omega>\n  td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2\n\ngoal (1 subgoal):\n 1. IO M2 t1 td \\<subseteq> IO M1 s1 td", "by auto"], ["proof (state)\nthis:\n  IO M2 t1 td \\<subseteq> IO M1 s1 td\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "moreover"], ["proof (state)\nthis:\n  IO M2 t1 td \\<subseteq> IO M1 s1 td\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "have \"IO M2 t2 td \\<subseteq> IO M1 s2 td\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO M2 t2 td \\<subseteq> IO M1 s2 td", "using red2 td_def"], ["proof (prove)\nusing this:\n  atc_reduction M2 t2 M1 s2 \\<Omega>\n  td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2\n\ngoal (1 subgoal):\n 1. IO M2 t2 td \\<subseteq> IO M1 s2 td", "by auto"], ["proof (state)\nthis:\n  IO M2 t2 td \\<subseteq> IO M1 s2 td\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "ultimately"], ["proof (chain)\npicking this:\n  IO M1 s1 td \\<inter> IO M1 s2 td = {}\n  IO M2 t1 td \\<subseteq> IO M1 s1 td\n  IO M2 t2 td \\<subseteq> IO M1 s2 td", "have no_inter : \"IO M2 t1 td \\<inter> IO M2 t2 td = {}\""], ["proof (prove)\nusing this:\n  IO M1 s1 td \\<inter> IO M1 s2 td = {}\n  IO M2 t1 td \\<subseteq> IO M1 s1 td\n  IO M2 t2 td \\<subseteq> IO M1 s2 td\n\ngoal (1 subgoal):\n 1. IO M2 t1 td \\<inter> IO M2 t2 td = {}", "by blast"], ["proof (state)\nthis:\n  IO M2 t1 td \\<inter> IO M2 t2 td = {}\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "then"], ["proof (chain)\npicking this:\n  IO M2 t1 td \\<inter> IO M2 t2 td = {}", "have \"td \\<noteq> Leaf\""], ["proof (prove)\nusing this:\n  IO M2 t1 td \\<inter> IO M2 t2 td = {}\n\ngoal (1 subgoal):\n 1. td \\<noteq> Leaf", "by auto"], ["proof (state)\nthis:\n  td \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "then"], ["proof (chain)\npicking this:\n  td \\<noteq> Leaf", "have \"IO M2 t1 td \\<noteq> {}\""], ["proof (prove)\nusing this:\n  td \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. IO M2 t1 td \\<noteq> {}", "by (meson ap2 IO_applicable_nonempty applicable_set.elims(2) cs2 td_def assms(8))"], ["proof (state)\nthis:\n  IO M2 t1 td \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "then"], ["proof (chain)\npicking this:\n  IO M2 t1 td \\<noteq> {}", "have \"IO M2 t1 td \\<noteq> IO M2 t2 td\""], ["proof (prove)\nusing this:\n  IO M2 t1 td \\<noteq> {}\n\ngoal (1 subgoal):\n 1. IO M2 t1 td \\<noteq> IO M2 t2 td", "using no_inter"], ["proof (prove)\nusing this:\n  IO M2 t1 td \\<noteq> {}\n  IO M2 t1 td \\<inter> IO M2 t2 td = {}\n\ngoal (1 subgoal):\n 1. IO M2 t1 td \\<noteq> IO M2 t2 td", "by auto"], ["proof (state)\nthis:\n  IO M2 t1 td \\<noteq> IO M2 t2 td\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "then"], ["proof (chain)\npicking this:\n  IO M2 t1 td \\<noteq> IO M2 t2 td", "show ?thesis"], ["proof (prove)\nusing this:\n  IO M2 t1 td \\<noteq> IO M2 t2 td\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "using no_inter td_def"], ["proof (prove)\nusing this:\n  IO M2 t1 td \\<noteq> IO M2 t2 td\n  IO M2 t1 td \\<inter> IO M2 t2 td = {}\n  td \\<in> \\<Omega> \\<and> r_dist M1 td s1 s2\n\ngoal (1 subgoal):\n 1. r_dist_set M2 \\<Omega> t1 t2", "by auto"], ["proof (state)\nthis:\n  r_dist_set M2 \\<Omega> t1 t2\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Reduction over ATCs applied after input sequences \\<close>"], ["", "text \\<open>\nThe following functions check whether some FSM is a reduction of another over a given set of input\nsequences while furthermore the response sets obtained by applying a set of ATCs after every input\nsequence to the first FSM are subsets of the analogously constructed response sets of the second\nFSM.\n\\<close>"], ["", "fun atc_io_reduction_on :: \"('in, 'out, 'state1) FSM \\<Rightarrow> ('in, 'out, 'state2) FSM \\<Rightarrow> 'in list \n                            \\<Rightarrow> ('in, 'out) ATC set \\<Rightarrow> bool\" where\n  \"atc_io_reduction_on M1 M2 iseq \\<Omega> = (L\\<^sub>i\\<^sub>n M1 {iseq} \\<subseteq> L\\<^sub>i\\<^sub>n M2 {iseq} \n    \\<and> (\\<forall> io \\<in> L\\<^sub>i\\<^sub>n M1 {iseq} . B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>))\""], ["", "fun atc_io_reduction_on_sets :: \"('in, 'out, 'state1) FSM \\<Rightarrow> 'in list set \\<Rightarrow> ('in, 'out) ATC set \n                                  \\<Rightarrow> ('in, 'out, 'state2) FSM \\<Rightarrow> bool\" where\n  \"atc_io_reduction_on_sets M1 TS \\<Omega> M2 = (\\<forall> iseq \\<in> TS . atc_io_reduction_on M1 M2 iseq \\<Omega>)\""], ["", "notation \n  atc_io_reduction_on_sets (\"(_ \\<preceq>\\<lbrakk>_._\\<rbrakk> _)\" [1000,1000,1000,1000])"], ["", "lemma io_reduction_from_atc_io_reduction :\n  assumes \"atc_io_reduction_on_sets M1 T \\<Omega> M2\"\n  and     \"finite T\"\n  shows \"io_reduction_on M1 T M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "using assms(2,1)"], ["proof (prove)\nusing this:\n  finite T\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. M1 \\<preceq>\\<lbrakk>{}.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n    M1 \\<preceq>\\<lbrakk>{}\\<rbrakk> M2\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "case empty"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>{}.\\<Omega>\\<rbrakk> M2\n\ngoal (2 subgoals):\n 1. M1 \\<preceq>\\<lbrakk>{}.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n    M1 \\<preceq>\\<lbrakk>{}\\<rbrakk> M2\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  M1 \\<preceq>\\<lbrakk>{}.\\<Omega>\\<rbrakk> M2", "show ?case"], ["proof (prove)\nusing this:\n  M1 \\<preceq>\\<lbrakk>{}.\\<Omega>\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>{}\\<rbrakk> M2", "by auto"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>{}\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "case (insert t T)"], ["proof (state)\nthis:\n  finite T\n  t \\<notin> T\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n  M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n  M1 \\<preceq>\\<lbrakk>(insert t T).\\<Omega>\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  finite T\n  t \\<notin> T\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n  M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n  M1 \\<preceq>\\<lbrakk>(insert t T).\\<Omega>\\<rbrakk> M2", "have \"atc_io_reduction_on M1 M2 t \\<Omega>\""], ["proof (prove)\nusing this:\n  finite T\n  t \\<notin> T\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n  M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n  M1 \\<preceq>\\<lbrakk>(insert t T).\\<Omega>\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. atc_io_reduction_on M1 M2 t \\<Omega>", "by auto"], ["proof (state)\nthis:\n  atc_io_reduction_on M1 M2 t \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  atc_io_reduction_on M1 M2 t \\<Omega>", "have \"L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 {t}\""], ["proof (prove)\nusing this:\n  atc_io_reduction_on M1 M2 t \\<Omega>\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>{t}\\<rbrakk> M2", "using atc_io_reduction_on.simps"], ["proof (prove)\nusing this:\n  atc_io_reduction_on M1 M2 t \\<Omega>\n  atc_io_reduction_on ?M1.0 ?M2.0 ?iseq ?\\<Omega> =\n  (?M1.0 \\<preceq>\\<lbrakk>{?iseq}\\<rbrakk> ?M2.0 \\<and>\n   (\\<forall>io\\<in>L\\<^sub>i\\<^sub>n ?M1.0 {?iseq}.\n       B ?M1.0 io ?\\<Omega> \\<subseteq> B ?M2.0 io ?\\<Omega>))\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>{t}\\<rbrakk> M2", "by blast"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>{t}\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "have \"L\\<^sub>i\\<^sub>n M1 T \\<subseteq> L\\<^sub>i\\<^sub>n M2 T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "using insert.IH"], ["proof (prove)\nusing this:\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n  M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n     M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2) \\<Longrightarrow>\n    M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "have \"atc_io_reduction_on_sets M1 T \\<Omega> M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2", "by (meson contra_subsetD insert.prems atc_io_reduction_on_sets.simps subset_insertI)"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. (M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n     M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2) \\<Longrightarrow>\n    M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2", "show ?thesis"], ["proof (prove)\nusing this:\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "using insert.IH"], ["proof (prove)\nusing this:\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n  M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "by blast"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "have \"L\\<^sub>i\\<^sub>n M1 T \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\""], ["proof (prove)\nusing this:\n  M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 T \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "by (meson insert_iff language_state_for_inputs_in_language_state \n        language_state_for_inputs_map_fst language_state_for_inputs_map_fst_contained \n        subsetCE subsetI)"], ["proof (state)\nthis:\n  L\\<^sub>i\\<^sub>n M1 T \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "moreover"], ["proof (state)\nthis:\n  L\\<^sub>i\\<^sub>n M1 T \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "have \"L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "obtain pps :: \"('a \\<times> 'b) list set \\<Rightarrow> ('a \\<times> 'b) list set \\<Rightarrow> ('a \\<times> 'b) list\" where\n      \"\\<forall>x0 x1. (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) = (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pps.\n        \\<forall>x0 x1.\n           (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n           (pps x0 x1 \\<in> x1 \\<and>\n            pps x0 x1 \\<notin> x0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)", "have \"\\<forall>P Pa. pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n\ngoal (1 subgoal):\n 1. \\<forall>P Pa.\n       pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa", "by blast"], ["proof (state)\nthis:\n  \\<forall>P Pa.\n     pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "moreover"], ["proof (state)\nthis:\n  \\<forall>P Pa.\n     pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "{"], ["proof (state)\nthis:\n  \\<forall>P Pa.\n     pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "assume \"map fst (pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})) \\<notin> insert t T\""], ["proof (state)\nthis:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t}))\n  \\<notin> insert t T\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "then"], ["proof (chain)\npicking this:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t}))\n  \\<notin> insert t T", "have \"pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t}) \\<notin> L\\<^sub>i\\<^sub>n M1 {t} \n                      \\<or> pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t}) \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\""], ["proof (prove)\nusing this:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t}))\n  \\<notin> insert t T\n\ngoal (1 subgoal):\n 1. pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})\n    \\<notin> L\\<^sub>i\\<^sub>n M1 {t} \\<or>\n    pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})\n    \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)", "by (metis (no_types) insertI1 language_state_for_inputs_map_fst_contained singletonD)"], ["proof (state)\nthis:\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t} \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "}"], ["proof (state)\nthis:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t}))\n  \\<notin> insert t T \\<Longrightarrow>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t} \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>P Pa.\n     pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t}))\n  \\<notin> insert t T \\<Longrightarrow>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t} \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>P Pa.\n     pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t}))\n  \\<notin> insert t T \\<Longrightarrow>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t} \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 {t})\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "by (meson \\<open>L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 {t}\\<close> language_state_for_inputs_in_language_state \n          language_state_for_inputs_map_fst set_rev_mp)"], ["proof (state)\nthis:\n  L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        M1 \\<preceq>\\<lbrakk>F.\\<Omega>\\<rbrakk> M2 \\<Longrightarrow>\n        M1 \\<preceq>\\<lbrakk>F\\<rbrakk> M2;\n        M1 \\<preceq>\\<lbrakk>(insert x F).\\<Omega>\\<rbrakk> M2\\<rbrakk>\n       \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert x F\\<rbrakk> M2", "ultimately"], ["proof (chain)\npicking this:\n  L\\<^sub>i\\<^sub>n M1 T \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\n  L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)", "show ?case"], ["proof (prove)\nusing this:\n  L\\<^sub>i\\<^sub>n M1 T \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\n  L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "have f1: \"\\<forall>ps P Pa. (ps::('a \\<times> 'b) list) \\<notin> P \\<or> \\<not> P \\<subseteq> Pa \\<or> ps \\<in> Pa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps P Pa.\n       ps \\<notin> P \\<or> \\<not> P \\<subseteq> Pa \\<or> ps \\<in> Pa", "by blast"], ["proof (state)\nthis:\n  \\<forall>ps P Pa.\n     ps \\<notin> P \\<or> \\<not> P \\<subseteq> Pa \\<or> ps \\<in> Pa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "obtain pps :: \"('a \\<times> 'b) list set \\<Rightarrow> ('a \\<times> 'b) list set \\<Rightarrow> ('a \\<times> 'b) list\" where\n      \"\\<forall>x0 x1. (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) = (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pps.\n        \\<forall>x0 x1.\n           (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n           (pps x0 x1 \\<in> x1 \\<and>\n            pps x0 x1 \\<notin> x0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "moreover"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "{"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "assume \"pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 (insert t T)) \n              \\<notin> L\\<^sub>i\\<^sub>n M1 {t}\""], ["proof (state)\nthis:\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "moreover"], ["proof (state)\nthis:\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "{"], ["proof (state)\nthis:\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "assume \"map fst (pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 (insert t T))) \n                \\<notin> {t}\""], ["proof (state)\nthis:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T)))\n  \\<notin> {t}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T)))\n  \\<notin> {t}", "have \"map fst (pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) \n                      (L\\<^sub>i\\<^sub>n M1 (insert t T))) \\<noteq> t\""], ["proof (prove)\nusing this:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T)))\n  \\<notin> {t}\n\ngoal (1 subgoal):\n 1. map fst\n     (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n       (L\\<^sub>i\\<^sub>n M1 (insert t T))) \\<noteq>\n    t", "by blast"], ["proof (state)\nthis:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))) \\<noteq>\n  t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))) \\<noteq>\n  t", "have \"pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 (insert t T)) \n                        \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \n                    \\<or> pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 (insert t T)) \n                          \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\""], ["proof (prove)\nusing this:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))) \\<noteq>\n  t\n\ngoal (1 subgoal):\n 1. pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))\n    \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n    pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))\n    \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)", "using f1"], ["proof (prove)\nusing this:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))) \\<noteq>\n  t\n  \\<forall>ps P Pa.\n     ps \\<notin> P \\<or> \\<not> P \\<subseteq> Pa \\<or> ps \\<in> Pa\n\ngoal (1 subgoal):\n 1. pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))\n    \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n    pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))\n    \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)", "by (meson \\<open>L\\<^sub>i\\<^sub>n M1 T \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<close> \n                       insertE language_state_for_inputs_in_language_state \n                       language_state_for_inputs_map_fst \n                       language_state_for_inputs_map_fst_contained)"], ["proof (state)\nthis:\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "}"], ["proof (state)\nthis:\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T)))\n  \\<notin> {t} \\<Longrightarrow>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "ultimately"], ["proof (chain)\npicking this:\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t}\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T)))\n  \\<notin> {t} \\<Longrightarrow>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)", "have \"io_reduction_on M1 (insert t T) M2 \n                        \\<or> pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 (insert t T)) \n                            \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \n                        \\<or> pps (L\\<^sub>i\\<^sub>n M2 (insert t T)) (L\\<^sub>i\\<^sub>n M1 (insert t T)) \n                            \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\""], ["proof (prove)\nusing this:\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t}\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T)))\n  \\<notin> {t} \\<Longrightarrow>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2 \\<or>\n    pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))\n    \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n    pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))\n    \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)", "using f1"], ["proof (prove)\nusing this:\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t}\n  map fst\n   (pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T)))\n  \\<notin> {t} \\<Longrightarrow>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n  \\<forall>ps P Pa.\n     ps \\<notin> P \\<or> \\<not> P \\<subseteq> Pa \\<or> ps \\<in> Pa\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2 \\<or>\n    pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))\n    \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n    pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n     (L\\<^sub>i\\<^sub>n M1 (insert t T))\n    \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)", "by (meson language_state_for_inputs_in_language_state \n                     language_state_for_inputs_map_fst)"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2 \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "}"], ["proof (state)\nthis:\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t} \\<Longrightarrow>\n  M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2 \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L\\<^sub>i\\<^sub>n M1 T\n             \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T);\n     L\\<^sub>i\\<^sub>n M1 {t}\n     \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<rbrakk>\n    \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t} \\<Longrightarrow>\n  M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2 \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t} \\<Longrightarrow>\n  M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2 \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 {t} \\<Longrightarrow>\n  M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2 \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<notin> L\\<^sub>i\\<^sub>n M1 (insert t T) \\<or>\n  pps (L\\<^sub>i\\<^sub>n M2 (insert t T))\n   (L\\<^sub>i\\<^sub>n M1 (insert t T))\n  \\<in> L\\<^sub>i\\<^sub>n M2 (insert t T)\n  \\<forall>ps P Pa.\n     ps \\<notin> P \\<or> \\<not> P \\<subseteq> Pa \\<or> ps \\<in> Pa\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2", "by (meson \\<open>L\\<^sub>i\\<^sub>n M1 {t} \\<subseteq> L\\<^sub>i\\<^sub>n M2 (insert t T)\\<close> subsetI)"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>insert t T\\<rbrakk> M2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atc_io_reduction_on_subset :\n  assumes \"atc_io_reduction_on_sets M1 T \\<Omega> M2\"\n  and     \"T' \\<subseteq> T\"\nshows \"atc_io_reduction_on_sets M1 T' \\<Omega> M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>T'.\\<Omega>\\<rbrakk> M2", "using assms"], ["proof (prove)\nusing this:\n  M1 \\<preceq>\\<lbrakk>T.\\<Omega>\\<rbrakk> M2\n  T' \\<subseteq> T\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>T'.\\<Omega>\\<rbrakk> M2", "unfolding atc_io_reduction_on_sets.simps"], ["proof (prove)\nusing this:\n  \\<forall>iseq\\<in>T. atc_io_reduction_on M1 M2 iseq \\<Omega>\n  T' \\<subseteq> T\n\ngoal (1 subgoal):\n 1. \\<forall>iseq\\<in>T'. atc_io_reduction_on M1 M2 iseq \\<Omega>", "by blast"], ["", "lemma atc_reaction_reduction[intro] :\n  assumes ls : \"language_state M1 q1 \\<subseteq> language_state M2 q2\"\n  and     el1 : \"q1 \\<in> nodes M1\"\n  and     el2 : \"q2 \\<in> nodes M2\"\n  and     rct : \"atc_reaction M1 q1 t io\"\n  and     ob2 : \"observable M2\"\n  and     ob1 : \"observable M1\"\nshows \"atc_reaction M2 q2 t io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atc_reaction M2 q2 t io", "using assms"], ["proof (prove)\nusing this:\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 t io\n  observable M2\n  observable M1\n\ngoal (1 subgoal):\n 1. atc_reaction M2 q2 t io", "proof (induction t arbitrary: io q1 q2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>io q1 q2.\n       \\<lbrakk>LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n        q2 \\<in> nodes M2; atc_reaction M1 q1 Leaf io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 Leaf io\n 2. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "case Leaf"], ["proof (state)\nthis:\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 Leaf io\n  observable M2\n  observable M1\n\ngoal (2 subgoals):\n 1. \\<And>io q1 q2.\n       \\<lbrakk>LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n        q2 \\<in> nodes M2; atc_reaction M1 q1 Leaf io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 Leaf io\n 2. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 Leaf io\n  observable M2\n  observable M1", "have \"io = []\""], ["proof (prove)\nusing this:\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 Leaf io\n  observable M2\n  observable M1\n\ngoal (1 subgoal):\n 1. io = []", "by (metis atc_reaction_nonempty_no_leaf list.exhaust)"], ["proof (state)\nthis:\n  io = []\n\ngoal (2 subgoals):\n 1. \\<And>io q1 q2.\n       \\<lbrakk>LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n        q2 \\<in> nodes M2; atc_reaction M1 q1 Leaf io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 Leaf io\n 2. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  io = []", "show ?case"], ["proof (prove)\nusing this:\n  io = []\n\ngoal (1 subgoal):\n 1. atc_reaction M2 q2 Leaf io", "by (simp add: leaf)"], ["proof (state)\nthis:\n  atc_reaction M2 q2 Leaf io\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "case (Node x f)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> range f; LS M1 ?q1.0 \\<subseteq> LS M2 ?q2.0;\n   ?q1.0 \\<in> nodes M1; ?q2.0 \\<in> nodes M2;\n   atc_reaction M1 ?q1.0 ?x2a ?io; observable M2; observable M1\\<rbrakk>\n  \\<Longrightarrow> atc_reaction M2 ?q2.0 ?x2a ?io\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 (Node x f) io\n  observable M2\n  observable M1\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> range f; LS M1 ?q1.0 \\<subseteq> LS M2 ?q2.0;\n   ?q1.0 \\<in> nodes M1; ?q2.0 \\<in> nodes M2;\n   atc_reaction M1 ?q1.0 ?x2a ?io; observable M2; observable M1\\<rbrakk>\n  \\<Longrightarrow> atc_reaction M2 ?q2.0 ?x2a ?io\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 (Node x f) io\n  observable M2\n  observable M1", "obtain io_hd io_tl where io_split : \"io = io_hd # io_tl\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> range f; LS M1 ?q1.0 \\<subseteq> LS M2 ?q2.0;\n   ?q1.0 \\<in> nodes M1; ?q2.0 \\<in> nodes M2;\n   atc_reaction M1 ?q1.0 ?x2a ?io; observable M2; observable M1\\<rbrakk>\n  \\<Longrightarrow> atc_reaction M2 ?q2.0 ?x2a ?io\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 (Node x f) io\n  observable M2\n  observable M1\n\ngoal (1 subgoal):\n 1. (\\<And>io_hd io_tl.\n        io = io_hd # io_tl \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ATC.distinct(1) atc_reaction_empty list.exhaust)"], ["proof (state)\nthis:\n  io = io_hd # io_tl\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "moreover"], ["proof (state)\nthis:\n  io = io_hd # io_tl\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "obtain y where y_def : \"io_hd = (x,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. io_hd = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Node calculation"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> range f; LS M1 ?q1.0 \\<subseteq> LS M2 ?q2.0;\n   ?q1.0 \\<in> nodes M1; ?q2.0 \\<in> nodes M2;\n   atc_reaction M1 ?q1.0 ?x2a ?io; observable M2; observable M1\\<rbrakk>\n  \\<Longrightarrow> atc_reaction M2 ?q2.0 ?x2a ?io\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 (Node x f) io\n  observable M2\n  observable M1\n  io = io_hd # io_tl\n\ngoal (1 subgoal):\n 1. (\\<And>y. io_hd = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ATC.inject atc_reaction_nonempty surj_pair)"], ["proof (state)\nthis:\n  io_hd = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "ultimately"], ["proof (chain)\npicking this:\n  io = io_hd # io_tl\n  io_hd = (x, y)", "obtain q1x where q1x_def : \"q1x \\<in> succ M1 (x,y) q1\" \"atc_reaction M1 q1x (f y) io_tl\""], ["proof (prove)\nusing this:\n  io = io_hd # io_tl\n  io_hd = (x, y)\n\ngoal (1 subgoal):\n 1. (\\<And>q1x.\n        \\<lbrakk>q1x \\<in> succ M1 (x, y) q1;\n         atc_reaction M1 q1x (f y) io_tl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Node.prems(4)"], ["proof (prove)\nusing this:\n  io = io_hd # io_tl\n  io_hd = (x, y)\n  atc_reaction M1 q1 (Node x f) io\n\ngoal (1 subgoal):\n 1. (\\<And>q1x.\n        \\<lbrakk>q1x \\<in> succ M1 (x, y) q1;\n         atc_reaction M1 q1x (f y) io_tl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q1x \\<in> succ M1 (x, y) q1\n  atc_reaction M1 q1x (f y) io_tl\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  q1x \\<in> succ M1 (x, y) q1\n  atc_reaction M1 q1x (f y) io_tl", "have pt1 : \"path M1 ([(x,y)] || [q1x]) q1\""], ["proof (prove)\nusing this:\n  q1x \\<in> succ M1 (x, y) q1\n  atc_reaction M1 q1x (f y) io_tl\n\ngoal (1 subgoal):\n 1. path M1 ([(x, y)] || [q1x]) q1", "by auto"], ["proof (state)\nthis:\n  path M1 ([(x, y)] || [q1x]) q1\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  path M1 ([(x, y)] || [q1x]) q1", "have ls1 : \"[(x,y)] \\<in> language_state M1 q1\""], ["proof (prove)\nusing this:\n  path M1 ([(x, y)] || [q1x]) q1\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<in> LS M1 q1", "unfolding language_state_def path_def"], ["proof (prove)\nusing this:\n  transition_system.path (\\<lambda>a p. snd a)\n   (\\<lambda>a p. snd a \\<in> succ M1 (fst a) p) ([(x, y)] || [q1x]) q1\n\ngoal (1 subgoal):\n 1. [(x, y)]\n    \\<in> {map fst r |r.\n           transition_system.path (\\<lambda>a p. snd a)\n            (\\<lambda>a p. snd a \\<in> succ M1 (fst a) p) r q1}", "using list.simps(9)"], ["proof (prove)\nusing this:\n  transition_system.path (\\<lambda>a p. snd a)\n   (\\<lambda>a p. snd a \\<in> succ M1 (fst a) p) ([(x, y)] || [q1x]) q1\n  map ?f (?x21.0 # ?x22.0) = ?f ?x21.0 # map ?f ?x22.0\n\ngoal (1 subgoal):\n 1. [(x, y)]\n    \\<in> {map fst r |r.\n           transition_system.path (\\<lambda>a p. snd a)\n            (\\<lambda>a p. snd a \\<in> succ M1 (fst a) p) r q1}", "by force"], ["proof (state)\nthis:\n  [(x, y)] \\<in> LS M1 q1\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "moreover"], ["proof (state)\nthis:\n  [(x, y)] \\<in> LS M1 q1\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "have \"q1x \\<in> io_targets M1 q1 [(x,y)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1x \\<in> io_targets M1 q1 [(x, y)]", "unfolding io_targets.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. q1x\n    \\<in> {target ([(x, y)] || tr) q1 |tr.\n           path M1 ([(x, y)] || tr) q1 \\<and> length [(x, y)] = length tr}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q1x\n    \\<in> {target ([(x, y)] || tr) q1 |tr.\n           path M1 ([(x, y)] || tr) q1 \\<and> length [(x, y)] = length tr}", "have f1: \"length [(x, y)] = length [q1x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [(x, y)] = length [q1x]", "by simp"], ["proof (state)\nthis:\n  length [(x, y)] = length [q1x]\n\ngoal (1 subgoal):\n 1. q1x\n    \\<in> {target ([(x, y)] || tr) q1 |tr.\n           path M1 ([(x, y)] || tr) q1 \\<and> length [(x, y)] = length tr}", "have \"q1x = target ([(x, y)] || [q1x]) q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1x = target ([(x, y)] || [q1x]) q1", "by simp"], ["proof (state)\nthis:\n  q1x = target ([(x, y)] || [q1x]) q1\n\ngoal (1 subgoal):\n 1. q1x\n    \\<in> {target ([(x, y)] || tr) q1 |tr.\n           path M1 ([(x, y)] || tr) q1 \\<and> length [(x, y)] = length tr}", "then"], ["proof (chain)\npicking this:\n  q1x = target ([(x, y)] || [q1x]) q1", "show \"q1x \\<in> {target ([(x, y)] || cs) q1 |cs. path M1 ([(x, y)] || cs) q1 \n                                                      \\<and> length [(x, y)] = length cs}\""], ["proof (prove)\nusing this:\n  q1x = target ([(x, y)] || [q1x]) q1\n\ngoal (1 subgoal):\n 1. q1x\n    \\<in> {target ([(x, y)] || cs) q1 |cs.\n           path M1 ([(x, y)] || cs) q1 \\<and> length [(x, y)] = length cs}", "using f1 pt1"], ["proof (prove)\nusing this:\n  q1x = target ([(x, y)] || [q1x]) q1\n  length [(x, y)] = length [q1x]\n  path M1 ([(x, y)] || [q1x]) q1\n\ngoal (1 subgoal):\n 1. q1x\n    \\<in> {target ([(x, y)] || cs) q1 |cs.\n           path M1 ([(x, y)] || cs) q1 \\<and> length [(x, y)] = length cs}", "by blast"], ["proof (state)\nthis:\n  q1x\n  \\<in> {target ([(x, y)] || cs) q1 |cs.\n         path M1 ([(x, y)] || cs) q1 \\<and> length [(x, y)] = length cs}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q1x \\<in> io_targets M1 q1 [(x, y)]\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "ultimately"], ["proof (chain)\npicking this:\n  [(x, y)] \\<in> LS M1 q1\n  q1x \\<in> io_targets M1 q1 [(x, y)]", "have tgt1 : \"io_targets M1 q1 [(x,y)] = {q1x}\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<in> LS M1 q1\n  q1x \\<in> io_targets M1 q1 [(x, y)]\n\ngoal (1 subgoal):\n 1. io_targets M1 q1 [(x, y)] = {q1x}", "using Node.prems io_targets_observable_singleton_ex q1x_def"], ["proof (prove)\nusing this:\n  [(x, y)] \\<in> LS M1 q1\n  q1x \\<in> io_targets M1 q1 [(x, y)]\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 (Node x f) io\n  observable M2\n  observable M1\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q2. io_targets ?M ?q1.0 ?io = {q2}\n  q1x \\<in> succ M1 (x, y) q1\n  atc_reaction M1 q1x (f y) io_tl\n\ngoal (1 subgoal):\n 1. io_targets M1 q1 [(x, y)] = {q1x}", "by (metis (no_types, lifting) singletonD)"], ["proof (state)\nthis:\n  io_targets M1 q1 [(x, y)] = {q1x}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  io_targets M1 q1 [(x, y)] = {q1x}", "have ls2 : \"[(x,y)] \\<in> language_state M2 q2\""], ["proof (prove)\nusing this:\n  io_targets M1 q1 [(x, y)] = {q1x}\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<in> LS M2 q2", "using Node.prems(1) ls1"], ["proof (prove)\nusing this:\n  io_targets M1 q1 [(x, y)] = {q1x}\n  LS M1 q1 \\<subseteq> LS M2 q2\n  [(x, y)] \\<in> LS M1 q1\n\ngoal (1 subgoal):\n 1. [(x, y)] \\<in> LS M2 q2", "by auto"], ["proof (state)\nthis:\n  [(x, y)] \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  [(x, y)] \\<in> LS M2 q2", "obtain q2x where q2x_def : \"q2x \\<in> succ M2 (x,y) q2\""], ["proof (prove)\nusing this:\n  [(x, y)] \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. (\\<And>q2x.\n        q2x \\<in> succ M2 (x, y) q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding language_state_def path_def"], ["proof (prove)\nusing this:\n  [(x, y)]\n  \\<in> {map fst r |r.\n         transition_system.path (\\<lambda>a p. snd a)\n          (\\<lambda>a p. snd a \\<in> succ M2 (fst a) p) r q2}\n\ngoal (1 subgoal):\n 1. (\\<And>q2x.\n        q2x \\<in> succ M2 (x, y) q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using transition_system.path.cases"], ["proof (prove)\nusing this:\n  [(x, y)]\n  \\<in> {map fst r |r.\n         transition_system.path (\\<lambda>a p. snd a)\n          (\\<lambda>a p. snd a \\<in> succ M2 (fst a) p) r q2}\n  \\<lbrakk>transition_system.path ?execute ?enabled ?a1.0 ?a2.0;\n   \\<And>p. \\<lbrakk>?a1.0 = []; ?a2.0 = p\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>a p r.\n      \\<lbrakk>?a1.0 = a # r; ?a2.0 = p; ?enabled a p;\n       transition_system.path ?execute ?enabled r (?execute a p)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>q2x.\n        q2x \\<in> succ M2 (x, y) q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  q2x \\<in> succ M2 (x, y) q2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  q2x \\<in> succ M2 (x, y) q2", "have pt2 : \"path M2 ([(x,y)] || [q2x]) q2\""], ["proof (prove)\nusing this:\n  q2x \\<in> succ M2 (x, y) q2\n\ngoal (1 subgoal):\n 1. path M2 ([(x, y)] || [q2x]) q2", "by auto"], ["proof (state)\nthis:\n  path M2 ([(x, y)] || [q2x]) q2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  path M2 ([(x, y)] || [q2x]) q2", "have \"q2x \\<in> io_targets M2 q2 [(x,y)]\""], ["proof (prove)\nusing this:\n  path M2 ([(x, y)] || [q2x]) q2\n\ngoal (1 subgoal):\n 1. q2x \\<in> io_targets M2 q2 [(x, y)]", "using ls2"], ["proof (prove)\nusing this:\n  path M2 ([(x, y)] || [q2x]) q2\n  [(x, y)] \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. q2x \\<in> io_targets M2 q2 [(x, y)]", "unfolding io_targets.simps"], ["proof (prove)\nusing this:\n  path M2 ([(x, y)] || [q2x]) q2\n  [(x, y)] \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. q2x\n    \\<in> {target ([(x, y)] || tr) q2 |tr.\n           path M2 ([(x, y)] || tr) q2 \\<and> length [(x, y)] = length tr}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>path M2 ([(x, y)] || [q2x]) q2;\n     [(x, y)] \\<in> LS M2 q2\\<rbrakk>\n    \\<Longrightarrow> q2x\n                      \\<in> {target ([(x, y)] || tr) q2 |tr.\n                             path M2 ([(x, y)] || tr) q2 \\<and>\n                             length [(x, y)] = length tr}", "have f1: \"length [(x, y)] = length [q2x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [(x, y)] = length [q2x]", "by simp"], ["proof (state)\nthis:\n  length [(x, y)] = length [q2x]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M2 ([(x, y)] || [q2x]) q2;\n     [(x, y)] \\<in> LS M2 q2\\<rbrakk>\n    \\<Longrightarrow> q2x\n                      \\<in> {target ([(x, y)] || tr) q2 |tr.\n                             path M2 ([(x, y)] || tr) q2 \\<and>\n                             length [(x, y)] = length tr}", "have \"q2x = target ([(x, y)] || [q2x]) q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2x = target ([(x, y)] || [q2x]) q2", "by simp"], ["proof (state)\nthis:\n  q2x = target ([(x, y)] || [q2x]) q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M2 ([(x, y)] || [q2x]) q2;\n     [(x, y)] \\<in> LS M2 q2\\<rbrakk>\n    \\<Longrightarrow> q2x\n                      \\<in> {target ([(x, y)] || tr) q2 |tr.\n                             path M2 ([(x, y)] || tr) q2 \\<and>\n                             length [(x, y)] = length tr}", "then"], ["proof (chain)\npicking this:\n  q2x = target ([(x, y)] || [q2x]) q2", "show \"q2x \\<in> {target ([(x, y)] || cs) q2 |cs. path M2 ([(x, y)] || cs) q2 \n                                                        \\<and> length [(x, y)] = length cs}\""], ["proof (prove)\nusing this:\n  q2x = target ([(x, y)] || [q2x]) q2\n\ngoal (1 subgoal):\n 1. q2x\n    \\<in> {target ([(x, y)] || cs) q2 |cs.\n           path M2 ([(x, y)] || cs) q2 \\<and> length [(x, y)] = length cs}", "using f1 pt2"], ["proof (prove)\nusing this:\n  q2x = target ([(x, y)] || [q2x]) q2\n  length [(x, y)] = length [q2x]\n  path M2 ([(x, y)] || [q2x]) q2\n\ngoal (1 subgoal):\n 1. q2x\n    \\<in> {target ([(x, y)] || cs) q2 |cs.\n           path M2 ([(x, y)] || cs) q2 \\<and> length [(x, y)] = length cs}", "by blast"], ["proof (state)\nthis:\n  q2x\n  \\<in> {target ([(x, y)] || cs) q2 |cs.\n         path M2 ([(x, y)] || cs) q2 \\<and> length [(x, y)] = length cs}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q2x \\<in> io_targets M2 q2 [(x, y)]\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  q2x \\<in> io_targets M2 q2 [(x, y)]", "have tgt2 : \"io_targets M2 q2 [(x,y)] = {q2x}\""], ["proof (prove)\nusing this:\n  q2x \\<in> io_targets M2 q2 [(x, y)]\n\ngoal (1 subgoal):\n 1. io_targets M2 q2 [(x, y)] = {q2x}", "using Node.prems io_targets_observable_singleton_ex ls2 q2x_def"], ["proof (prove)\nusing this:\n  q2x \\<in> io_targets M2 q2 [(x, y)]\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 (Node x f) io\n  observable M2\n  observable M1\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q2. io_targets ?M ?q1.0 ?io = {q2}\n  [(x, y)] \\<in> LS M2 q2\n  q2x \\<in> succ M2 (x, y) q2\n\ngoal (1 subgoal):\n 1. io_targets M2 q2 [(x, y)] = {q2x}", "by (metis (no_types, lifting) singletonD)"], ["proof (state)\nthis:\n  io_targets M2 q2 [(x, y)] = {q2x}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  io_targets M2 q2 [(x, y)] = {q2x}", "have \"language_state M1 q1x \\<subseteq> language_state M2 q2x\""], ["proof (prove)\nusing this:\n  io_targets M2 q2 [(x, y)] = {q2x}\n\ngoal (1 subgoal):\n 1. LS M1 q1x \\<subseteq> LS M2 q2x", "using language_state_inclusion_of_state_reached_by_same_sequence\n          [of M1 q1 M2 q2 \"[(x,y)]\" q1x q2x] \n          tgt1 tgt2 Node.prems"], ["proof (prove)\nusing this:\n  io_targets M2 q2 [(x, y)] = {q2x}\n  \\<lbrakk>LS M1 q1 \\<subseteq> LS M2 q2; observable M1; observable M2;\n   io_targets M1 q1 [(x, y)] = {q1x};\n   io_targets M2 q2 [(x, y)] = {q2x}\\<rbrakk>\n  \\<Longrightarrow> LS M1 q1x \\<subseteq> LS M2 q2x\n  io_targets M1 q1 [(x, y)] = {q1x}\n  io_targets M2 q2 [(x, y)] = {q2x}\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  atc_reaction M1 q1 (Node x f) io\n  observable M2\n  observable M1\n\ngoal (1 subgoal):\n 1. LS M1 q1x \\<subseteq> LS M2 q2x", "by auto"], ["proof (state)\nthis:\n  LS M1 q1x \\<subseteq> LS M2 q2x\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "moreover"], ["proof (state)\nthis:\n  LS M1 q1x \\<subseteq> LS M2 q2x\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "have \"q1x \\<in> nodes M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1x \\<in> nodes M1", "using q1x_def(1) Node.prems(2)"], ["proof (prove)\nusing this:\n  q1x \\<in> succ M1 (x, y) q1\n  q1 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. q1x \\<in> nodes M1", "by (metis insertI1 io_targets_nodes tgt1)"], ["proof (state)\nthis:\n  q1x \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "moreover"], ["proof (state)\nthis:\n  q1x \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "have \"q2x \\<in> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2x \\<in> nodes M2", "using q2x_def(1) Node.prems(3)"], ["proof (prove)\nusing this:\n  q2x \\<in> succ M2 (x, y) q2\n  q2 \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. q2x \\<in> nodes M2", "by (metis insertI1 io_targets_nodes tgt2)"], ["proof (state)\nthis:\n  q2x \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "ultimately"], ["proof (chain)\npicking this:\n  LS M1 q1x \\<subseteq> LS M2 q2x\n  q1x \\<in> nodes M1\n  q2x \\<in> nodes M2", "have \"q2x \\<in> succ M2 (x,y) q2 \\<and> atc_reaction M2 q2x (f y) io_tl\""], ["proof (prove)\nusing this:\n  LS M1 q1x \\<subseteq> LS M2 q2x\n  q1x \\<in> nodes M1\n  q2x \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. q2x \\<in> succ M2 (x, y) q2 \\<and> atc_reaction M2 q2x (f y) io_tl", "using Node.IH[of \"f y\" q1x q2x io_tl] ob1 ob2 q1x_def(2) q2x_def"], ["proof (prove)\nusing this:\n  LS M1 q1x \\<subseteq> LS M2 q2x\n  q1x \\<in> nodes M1\n  q2x \\<in> nodes M2\n  \\<lbrakk>f y \\<in> range f; LS M1 q1x \\<subseteq> LS M2 q2x;\n   q1x \\<in> nodes M1; q2x \\<in> nodes M2; atc_reaction M1 q1x (f y) io_tl;\n   observable M2; observable M1\\<rbrakk>\n  \\<Longrightarrow> atc_reaction M2 q2x (f y) io_tl\n  observable M1\n  observable M2\n  atc_reaction M1 q1x (f y) io_tl\n  q2x \\<in> succ M2 (x, y) q2\n\ngoal (1 subgoal):\n 1. q2x \\<in> succ M2 (x, y) q2 \\<and> atc_reaction M2 q2x (f y) io_tl", "by blast"], ["proof (state)\nthis:\n  q2x \\<in> succ M2 (x, y) q2 \\<and> atc_reaction M2 q2x (f y) io_tl\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 io q1 q2.\n       \\<lbrakk>\\<And>x2a io q1 q2.\n                   \\<lbrakk>x2a \\<in> range x2;\n                    LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1;\n                    q2 \\<in> nodes M2; atc_reaction M1 q1 x2a io;\n                    observable M2; observable M1\\<rbrakk>\n                   \\<Longrightarrow> atc_reaction M2 q2 x2a io;\n        LS M1 q1 \\<subseteq> LS M2 q2; q1 \\<in> nodes M1; q2 \\<in> nodes M2;\n        atc_reaction M1 q1 (Node x1 x2) io; observable M2;\n        observable M1\\<rbrakk>\n       \\<Longrightarrow> atc_reaction M2 q2 (Node x1 x2) io", "then"], ["proof (chain)\npicking this:\n  q2x \\<in> succ M2 (x, y) q2 \\<and> atc_reaction M2 q2x (f y) io_tl", "show \"atc_reaction M2 q2 (Node x f) io\""], ["proof (prove)\nusing this:\n  q2x \\<in> succ M2 (x, y) q2 \\<and> atc_reaction M2 q2x (f y) io_tl\n\ngoal (1 subgoal):\n 1. atc_reaction M2 q2 (Node x f) io", "using io_split y_def"], ["proof (prove)\nusing this:\n  q2x \\<in> succ M2 (x, y) q2 \\<and> atc_reaction M2 q2x (f y) io_tl\n  io = io_hd # io_tl\n  io_hd = (x, y)\n\ngoal (1 subgoal):\n 1. atc_reaction M2 q2 (Node x f) io", "by blast"], ["proof (state)\nthis:\n  atc_reaction M2 q2 (Node x f) io\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IO_reduction :\n  assumes ls : \"language_state M1 q1 \\<subseteq> language_state M2 q2\"\n  and     el1 : \"q1 \\<in> nodes M1\"\n  and     el2 : \"q2 \\<in> nodes M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"IO M1 q1 t \\<subseteq> IO M2 q2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO M1 q1 t \\<subseteq> IO M2 q2 t", "using assms atc_reaction_reduction"], ["proof (prove)\nusing this:\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  observable M1\n  observable M2\n  \\<lbrakk>LS ?M1.0 ?q1.0 \\<subseteq> LS ?M2.0 ?q2.0;\n   ?q1.0 \\<in> nodes ?M1.0; ?q2.0 \\<in> nodes ?M2.0;\n   atc_reaction ?M1.0 ?q1.0 ?t ?io; observable ?M2.0;\n   observable ?M1.0\\<rbrakk>\n  \\<Longrightarrow> atc_reaction ?M2.0 ?q2.0 ?t ?io\n\ngoal (1 subgoal):\n 1. IO M1 q1 t \\<subseteq> IO M2 q2 t", "unfolding IO.simps"], ["proof (prove)\nusing this:\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  observable M1\n  observable M2\n  \\<lbrakk>LS ?M1.0 ?q1.0 \\<subseteq> LS ?M2.0 ?q2.0;\n   ?q1.0 \\<in> nodes ?M1.0; ?q2.0 \\<in> nodes ?M2.0;\n   atc_reaction ?M1.0 ?q1.0 ?t ?io; observable ?M2.0;\n   observable ?M1.0\\<rbrakk>\n  \\<Longrightarrow> atc_reaction ?M2.0 ?q2.0 ?t ?io\n\ngoal (1 subgoal):\n 1. Collect (atc_reaction M1 q1 t)\n    \\<subseteq> Collect (atc_reaction M2 q2 t)", "by auto"], ["", "lemma IO_set_reduction :\n  assumes ls : \"language_state M1 q1 \\<subseteq> language_state M2 q2\"\n  and     el1 : \"q1 \\<in> nodes M1\"\n  and     el2 : \"q2 \\<in> nodes M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"IO_set M1 q1 \\<Omega> \\<subseteq> IO_set M2 q2 \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO_set M1 q1 \\<Omega> \\<subseteq> IO_set M2 q2 \\<Omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. IO_set M1 q1 \\<Omega> \\<subseteq> IO_set M2 q2 \\<Omega>", "have \"\\<forall> t \\<in> \\<Omega> . IO M1 q1 t \\<subseteq> IO M2 q2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>\\<Omega>. IO M1 q1 t \\<subseteq> IO M2 q2 t", "using assms IO_reduction"], ["proof (prove)\nusing this:\n  LS M1 q1 \\<subseteq> LS M2 q2\n  q1 \\<in> nodes M1\n  q2 \\<in> nodes M2\n  observable M1\n  observable M2\n  \\<lbrakk>LS ?M1.0 ?q1.0 \\<subseteq> LS ?M2.0 ?q2.0;\n   ?q1.0 \\<in> nodes ?M1.0; ?q2.0 \\<in> nodes ?M2.0; observable ?M1.0;\n   observable ?M2.0\\<rbrakk>\n  \\<Longrightarrow> IO ?M1.0 ?q1.0 ?t \\<subseteq> IO ?M2.0 ?q2.0 ?t\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>\\<Omega>. IO M1 q1 t \\<subseteq> IO M2 q2 t", "by metis"], ["proof (state)\nthis:\n  \\<forall>t\\<in>\\<Omega>. IO M1 q1 t \\<subseteq> IO M2 q2 t\n\ngoal (1 subgoal):\n 1. IO_set M1 q1 \\<Omega> \\<subseteq> IO_set M2 q2 \\<Omega>", "then"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>\\<Omega>. IO M1 q1 t \\<subseteq> IO M2 q2 t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>\\<Omega>. IO M1 q1 t \\<subseteq> IO M2 q2 t\n\ngoal (1 subgoal):\n 1. IO_set M1 q1 \\<Omega> \\<subseteq> IO_set M2 q2 \\<Omega>", "unfolding IO_set.simps"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>\\<Omega>. IO M1 q1 t \\<subseteq> IO M2 q2 t\n\ngoal (1 subgoal):\n 1. \\<Union> {IO M1 q1 t |t. t \\<in> \\<Omega>}\n    \\<subseteq> \\<Union> {IO M2 q2 t |t. t \\<in> \\<Omega>}", "by blast"], ["proof (state)\nthis:\n  IO_set M1 q1 \\<Omega> \\<subseteq> IO_set M2 q2 \\<Omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma B_reduction :\n  assumes red : \"M1 \\<preceq> M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "fix xy"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "assume xy_assm : \"xy \\<in> B M1 io \\<Omega>\""], ["proof (state)\nthis:\n  xy \\<in> B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  xy \\<in> B M1 io \\<Omega>", "obtain q1x where q1x_def : \"q1x \\<in> (io_targets M1 (initial M1) io) \\<and> xy \\<in> IO_set M1 q1x \\<Omega>\""], ["proof (prove)\nusing this:\n  xy \\<in> B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>q1x.\n        q1x \\<in> io_targets M1 (initial M1) io \\<and>\n        xy \\<in> IO_set M1 q1x \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding B.simps"], ["proof (prove)\nusing this:\n  xy \\<in> (\\<Union>s\\<in>io_targets M1 (initial M1) io.\n               IO_set M1 s \\<Omega>)\n\ngoal (1 subgoal):\n 1. (\\<And>q1x.\n        q1x \\<in> io_targets M1 (initial M1) io \\<and>\n        xy \\<in> IO_set M1 q1x \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q1x \\<in> io_targets M1 (initial M1) io \\<and>\n  xy \\<in> IO_set M1 q1x \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  q1x \\<in> io_targets M1 (initial M1) io \\<and>\n  xy \\<in> IO_set M1 q1x \\<Omega>", "obtain tr1 where tr1_def : \"path M1 (io || tr1) (initial M1) \\<and> length io = length tr1\""], ["proof (prove)\nusing this:\n  q1x \\<in> io_targets M1 (initial M1) io \\<and>\n  xy \\<in> IO_set M1 q1x \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        path M1 (io || tr1) (initial M1) \\<and>\n        length io = length tr1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M1 (io || tr1) (initial M1) \\<and> length io = length tr1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  path M1 (io || tr1) (initial M1) \\<and> length io = length tr1", "have q1x_ob : \"io_targets M1 (initial M1) io = {q1x}\""], ["proof (prove)\nusing this:\n  path M1 (io || tr1) (initial M1) \\<and> length io = length tr1\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io = {q1x}", "using assms"], ["proof (prove)\nusing this:\n  path M1 (io || tr1) (initial M1) \\<and> length io = length tr1\n  M1 \\<preceq> M2\n  observable M1\n  observable M2\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io = {q1x}", "by (metis io_targets_observable_singleton_ex language_state q1x_def singleton_iff)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) io = {q1x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) io = {q1x}", "have ls1 : \"io \\<in> language_state M1 (initial M1)\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) io = {q1x}\n\ngoal (1 subgoal):\n 1. io \\<in> L M1", "by auto"], ["proof (state)\nthis:\n  io \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M1", "have ls2 : \"io \\<in> language_state M2 (initial M2)\""], ["proof (prove)\nusing this:\n  io \\<in> L M1\n\ngoal (1 subgoal):\n 1. io \\<in> L M2", "using red"], ["proof (prove)\nusing this:\n  io \\<in> L M1\n  M1 \\<preceq> M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M2", "by auto"], ["proof (state)\nthis:\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M2", "obtain tr2 where tr2_def : \"path M2 (io || tr2) (initial M2) \\<and> length io = length tr2\""], ["proof (prove)\nusing this:\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>tr2.\n        path M2 (io || tr2) (initial M2) \\<and>\n        length io = length tr2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M2 (io || tr2) (initial M2) \\<and> length io = length tr2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  path M2 (io || tr2) (initial M2) \\<and> length io = length tr2", "obtain q2x where q2x_def : \"q2x \\<in> (io_targets M2 (initial M2) io)\""], ["proof (prove)\nusing this:\n  path M2 (io || tr2) (initial M2) \\<and> length io = length tr2\n\ngoal (1 subgoal):\n 1. (\\<And>q2x.\n        q2x \\<in> io_targets M2 (initial M2) io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q2x \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  q2x \\<in> io_targets M2 (initial M2) io", "have q2x_ob : \"io_targets M2 (initial M2) io = {q2x}\""], ["proof (prove)\nusing this:\n  q2x \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {q2x}", "using tr2_def assms"], ["proof (prove)\nusing this:\n  q2x \\<in> io_targets M2 (initial M2) io\n  path M2 (io || tr2) (initial M2) \\<and> length io = length tr2\n  M1 \\<preceq> M2\n  observable M1\n  observable M2\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {q2x}", "by (metis io_targets_observable_singleton_ex language_state singleton_iff)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {q2x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) io = {q2x}", "have \"language_state M1 q1x \\<subseteq> language_state M2 q2x\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io = {q2x}\n\ngoal (1 subgoal):\n 1. LS M1 q1x \\<subseteq> LS M2 q2x", "using q1x_ob assms"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io = {q2x}\n  io_targets M1 (initial M1) io = {q1x}\n  M1 \\<preceq> M2\n  observable M1\n  observable M2\n\ngoal (1 subgoal):\n 1. LS M1 q1x \\<subseteq> LS M2 q2x", "unfolding io_reduction.simps"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io = {q2x}\n  io_targets M1 (initial M1) io = {q1x}\n  L M1 \\<subseteq> L M2\n  observable M1\n  observable M2\n\ngoal (1 subgoal):\n 1. LS M1 q1x \\<subseteq> LS M2 q2x", "by (simp add: language_state_inclusion_of_state_reached_by_same_sequence)"], ["proof (state)\nthis:\n  LS M1 q1x \\<subseteq> LS M2 q2x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  LS M1 q1x \\<subseteq> LS M2 q2x", "have \"IO_set M1 q1x \\<Omega> \\<subseteq> IO_set M2 q2x \\<Omega>\""], ["proof (prove)\nusing this:\n  LS M1 q1x \\<subseteq> LS M2 q2x\n\ngoal (1 subgoal):\n 1. IO_set M1 q1x \\<Omega> \\<subseteq> IO_set M2 q2x \\<Omega>", "using assms IO_set_reduction"], ["proof (prove)\nusing this:\n  LS M1 q1x \\<subseteq> LS M2 q2x\n  M1 \\<preceq> M2\n  observable M1\n  observable M2\n  \\<lbrakk>LS ?M1.0 ?q1.0 \\<subseteq> LS ?M2.0 ?q2.0;\n   ?q1.0 \\<in> nodes ?M1.0; ?q2.0 \\<in> nodes ?M2.0; observable ?M1.0;\n   observable ?M2.0\\<rbrakk>\n  \\<Longrightarrow> IO_set ?M1.0 ?q1.0 ?\\<Omega>\n                    \\<subseteq> IO_set ?M2.0 ?q2.0 ?\\<Omega>\n\ngoal (1 subgoal):\n 1. IO_set M1 q1x \\<Omega> \\<subseteq> IO_set M2 q2x \\<Omega>", "by (metis FSM.nodes.initial io_targets_nodes q1x_def q2x_def)"], ["proof (state)\nthis:\n  IO_set M1 q1x \\<Omega> \\<subseteq> IO_set M2 q2x \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "moreover"], ["proof (state)\nthis:\n  IO_set M1 q1x \\<Omega> \\<subseteq> IO_set M2 q2x \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "have \"B M1 io \\<Omega> = IO_set M1 q1x \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B M1 io \\<Omega> = IO_set M1 q1x \\<Omega>", "using q1x_ob"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) io = {q1x}\n\ngoal (1 subgoal):\n 1. B M1 io \\<Omega> = IO_set M1 q1x \\<Omega>", "by auto"], ["proof (state)\nthis:\n  B M1 io \\<Omega> = IO_set M1 q1x \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "moreover"], ["proof (state)\nthis:\n  B M1 io \\<Omega> = IO_set M1 q1x \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "have \"B M2 io \\<Omega> = IO_set M2 q2x \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B M2 io \\<Omega> = IO_set M2 q2x \\<Omega>", "using q2x_ob"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io = {q2x}\n\ngoal (1 subgoal):\n 1. B M2 io \\<Omega> = IO_set M2 q2x \\<Omega>", "by auto"], ["proof (state)\nthis:\n  B M2 io \\<Omega> = IO_set M2 q2x \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "ultimately"], ["proof (chain)\npicking this:\n  IO_set M1 q1x \\<Omega> \\<subseteq> IO_set M2 q2x \\<Omega>\n  B M1 io \\<Omega> = IO_set M1 q1x \\<Omega>\n  B M2 io \\<Omega> = IO_set M2 q2x \\<Omega>", "have \"B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>\""], ["proof (prove)\nusing this:\n  IO_set M1 q1x \\<Omega> \\<subseteq> IO_set M2 q2x \\<Omega>\n  B M1 io \\<Omega> = IO_set M1 q1x \\<Omega>\n  B M2 io \\<Omega> = IO_set M2 q2x \\<Omega>\n\ngoal (1 subgoal):\n 1. B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>", "by simp"], ["proof (state)\nthis:\n  B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B M1 io \\<Omega> \\<Longrightarrow> x \\<in> B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>", "show \"xy \\<in> B M2 io \\<Omega>\""], ["proof (prove)\nusing this:\n  B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>\n\ngoal (1 subgoal):\n 1. xy \\<in> B M2 io \\<Omega>", "using xy_assm"], ["proof (prove)\nusing this:\n  B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>\n  xy \\<in> B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. xy \\<in> B M2 io \\<Omega>", "by blast"], ["proof (state)\nthis:\n  xy \\<in> B M2 io \\<Omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma append_io_B_reduction :\n  assumes red : \"M1 \\<preceq> M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"append_io_B M1 io \\<Omega> \\<subseteq> append_io_B M2 io \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. append_io_B M1 io \\<Omega> \\<subseteq> append_io_B M2 io \\<Omega>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> append_io_B M1 io \\<Omega> \\<Longrightarrow>\n       x \\<in> append_io_B M2 io \\<Omega>", "fix ioR"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> append_io_B M1 io \\<Omega> \\<Longrightarrow>\n       x \\<in> append_io_B M2 io \\<Omega>", "assume ioR_assm : \"ioR \\<in> append_io_B M1 io \\<Omega>\""], ["proof (state)\nthis:\n  ioR \\<in> append_io_B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> append_io_B M1 io \\<Omega> \\<Longrightarrow>\n       x \\<in> append_io_B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  ioR \\<in> append_io_B M1 io \\<Omega>", "obtain res where res_def : \"ioR = io @ res\" \"res \\<in> B M1 io \\<Omega>\""], ["proof (prove)\nusing this:\n  ioR \\<in> append_io_B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>res.\n        \\<lbrakk>ioR = io @ res; res \\<in> B M1 io \\<Omega>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ioR = io @ res\n  res \\<in> B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> append_io_B M1 io \\<Omega> \\<Longrightarrow>\n       x \\<in> append_io_B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  ioR = io @ res\n  res \\<in> B M1 io \\<Omega>", "have \"res \\<in> B M2 io \\<Omega>\""], ["proof (prove)\nusing this:\n  ioR = io @ res\n  res \\<in> B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. res \\<in> B M2 io \\<Omega>", "using assms B_reduction"], ["proof (prove)\nusing this:\n  ioR = io @ res\n  res \\<in> B M1 io \\<Omega>\n  M1 \\<preceq> M2\n  observable M1\n  observable M2\n  \\<lbrakk>?M1.0 \\<preceq> ?M2.0; observable ?M1.0;\n   observable ?M2.0\\<rbrakk>\n  \\<Longrightarrow> B ?M1.0 ?io ?\\<Omega> \\<subseteq> B ?M2.0 ?io ?\\<Omega>\n\ngoal (1 subgoal):\n 1. res \\<in> B M2 io \\<Omega>", "by (metis (no_types, hide_lams) subset_iff)"], ["proof (state)\nthis:\n  res \\<in> B M2 io \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> append_io_B M1 io \\<Omega> \\<Longrightarrow>\n       x \\<in> append_io_B M2 io \\<Omega>", "then"], ["proof (chain)\npicking this:\n  res \\<in> B M2 io \\<Omega>", "show \"ioR \\<in> append_io_B M2 io \\<Omega>\""], ["proof (prove)\nusing this:\n  res \\<in> B M2 io \\<Omega>\n\ngoal (1 subgoal):\n 1. ioR \\<in> append_io_B M2 io \\<Omega>", "using ioR_assm res_def"], ["proof (prove)\nusing this:\n  res \\<in> B M2 io \\<Omega>\n  ioR \\<in> append_io_B M1 io \\<Omega>\n  ioR = io @ res\n  res \\<in> B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. ioR \\<in> append_io_B M2 io \\<Omega>", "by auto"], ["proof (state)\nthis:\n  ioR \\<in> append_io_B M2 io \\<Omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atc_io_reduction_on_reduction[intro] :\n  assumes red : \"M1 \\<preceq> M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"atc_io_reduction_on M1 M2 iseq \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atc_io_reduction_on M1 M2 iseq \\<Omega>", "unfolding atc_io_reduction_on.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2 \\<and>\n    (\\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n        B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2\n 2. \\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n       B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>", "show \"L\\<^sub>i\\<^sub>n M1 {iseq} \\<subseteq> L\\<^sub>i\\<^sub>n M2 {iseq}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2", "using red"], ["proof (prove)\nusing this:\n  M1 \\<preceq> M2\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2", "by auto"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n       B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n       B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>", "show \"\\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n       B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>", "using  B_reduction assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?M1.0 \\<preceq> ?M2.0; observable ?M1.0;\n   observable ?M2.0\\<rbrakk>\n  \\<Longrightarrow> B ?M1.0 ?io ?\\<Omega> \\<subseteq> B ?M2.0 ?io ?\\<Omega>\n  M1 \\<preceq> M2\n  observable M1\n  observable M2\n\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n       B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>", "by blast"], ["proof (state)\nthis:\n  \\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n     B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atc_io_reduction_on_sets_reduction[intro] :\n  assumes red : \"M1 \\<preceq> M2\"\n  and     ob1 : \"observable M1\"\n  and     ob2 : \"observable M2\"\nshows \"atc_io_reduction_on_sets M1 TS \\<Omega> M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>TS.\\<Omega>\\<rbrakk> M2", "using assms atc_io_reduction_on_reduction"], ["proof (prove)\nusing this:\n  M1 \\<preceq> M2\n  observable M1\n  observable M2\n  \\<lbrakk>?M1.0 \\<preceq> ?M2.0; observable ?M1.0;\n   observable ?M2.0\\<rbrakk>\n  \\<Longrightarrow> atc_io_reduction_on ?M1.0 ?M2.0 ?iseq ?\\<Omega>\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>TS.\\<Omega>\\<rbrakk> M2", "by (metis atc_io_reduction_on_sets.elims(3))"], ["", "lemma atc_io_reduction_on_sets_via_LS\\<^sub>i\\<^sub>n : \n  assumes \"atc_io_reduction_on_sets M1 TS \\<Omega> M2\"\n  shows \"(L\\<^sub>i\\<^sub>n M1 TS \\<union> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)) \n          \\<subseteq> (L\\<^sub>i\\<^sub>n M2 TS \\<union> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 TS \\<union>\n    (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n    \\<subseteq> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 TS \\<union>\n    (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n    \\<subseteq> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "have \"\\<forall> iseq \\<in> TS . (L\\<^sub>i\\<^sub>n M1 {iseq} \\<subseteq> L\\<^sub>i\\<^sub>n M2 {iseq} \n                        \\<and> (\\<forall> io \\<in> L\\<^sub>i\\<^sub>n M1 {iseq} . B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>iseq\\<in>TS.\n       M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2 \\<and>\n       (\\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n           B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>)", "using assms"], ["proof (prove)\nusing this:\n  M1 \\<preceq>\\<lbrakk>TS.\\<Omega>\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. \\<forall>iseq\\<in>TS.\n       M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2 \\<and>\n       (\\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n           B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>)", "by auto"], ["proof (state)\nthis:\n  \\<forall>iseq\\<in>TS.\n     M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2 \\<and>\n     (\\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n         B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 TS \\<union>\n    (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n    \\<subseteq> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>iseq\\<in>TS.\n     M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2 \\<and>\n     (\\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n         B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>)", "have \"\\<forall> iseq \\<in> TS . (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>) \n                            \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}. B M2 io \\<Omega>)\""], ["proof (prove)\nusing this:\n  \\<forall>iseq\\<in>TS.\n     M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2 \\<and>\n     (\\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}.\n         B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. \\<forall>iseq\\<in>TS.\n       (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n       \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}.\n                       B M2 io \\<Omega>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>iseq\\<in>TS.\n     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n     \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}.\n                     B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 TS \\<union>\n    (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n    \\<subseteq> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>iseq\\<in>TS.\n     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n     \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}.\n                     B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 TS \\<union>\n    (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n    \\<subseteq> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "have \"\\<forall> iseq \\<in> TS . (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}. B M2 io \\<Omega>) \n                                \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>iseq\\<in>TS.\n       (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}. B M2 io \\<Omega>)\n       \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                       B M2 io \\<Omega>)", "unfolding language_state_for_inputs.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>iseq\\<in>TS.\n       (\\<Union>io\\<in>{xs || ys |xs ys.\n                        xs \\<in> {iseq} \\<and>\n                        length xs = length ys \\<and> xs || ys \\<in> L M2}.\n           B M2 io \\<Omega>)\n       \\<subseteq> (\\<Union>io\\<in>{xs || ys |xs ys.\n                                    xs \\<in> TS \\<and>\n                                    length xs = length ys \\<and>\n                                    xs || ys \\<in> L M2}.\n                       B M2 io \\<Omega>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>iseq\\<in>TS.\n     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}. B M2 io \\<Omega>)\n     \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 TS \\<union>\n    (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n    \\<subseteq> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>iseq\\<in>TS.\n     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n     \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}.\n                     B M2 io \\<Omega>)\n  \\<forall>iseq\\<in>TS.\n     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}. B M2 io \\<Omega>)\n     \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "have elem_subset : \"\\<forall> iseq \\<in> TS . \n                                  (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>) \n                                    \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\""], ["proof (prove)\nusing this:\n  \\<forall>iseq\\<in>TS.\n     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n     \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}.\n                     B M2 io \\<Omega>)\n  \\<forall>iseq\\<in>TS.\n     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 {iseq}. B M2 io \\<Omega>)\n     \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. \\<forall>iseq\\<in>TS.\n       (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n       \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                       B M2 io \\<Omega>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>iseq\\<in>TS.\n     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n     \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 TS \\<union>\n    (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n    \\<subseteq> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 TS \\<union>\n    (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n    \\<subseteq> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n               (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                   B M1 io \\<Omega>) \\<Longrightarrow>\n       x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n               (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n               (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                   B M1 io \\<Omega>) \\<Longrightarrow>\n       x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n               (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "assume \"x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\""], ["proof (state)\nthis:\n  x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n          (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n               (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                   B M1 io \\<Omega>) \\<Longrightarrow>\n       x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n               (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n          (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)", "show \"x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\""], ["proof (prove)\nusing this:\n  x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n          (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n            (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "proof (cases \"x \\<in> L\\<^sub>i\\<^sub>n M1 TS\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<in> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)\n 2. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "case True"], ["proof (state)\nthis:\n  x \\<in> L\\<^sub>i\\<^sub>n M1 TS\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<in> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)\n 2. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> L\\<^sub>i\\<^sub>n M1 TS", "obtain iseq where \"iseq \\<in> TS\" \"x\\<in> L\\<^sub>i\\<^sub>n M1 {iseq}\""], ["proof (prove)\nusing this:\n  x \\<in> L\\<^sub>i\\<^sub>n M1 TS\n\ngoal (1 subgoal):\n 1. (\\<And>iseq.\n        \\<lbrakk>iseq \\<in> TS; x \\<in> L\\<^sub>i\\<^sub>n M1 {iseq}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding language_state_for_inputs.simps"], ["proof (prove)\nusing this:\n  x \\<in> {xs || ys |xs ys.\n           xs \\<in> TS \\<and>\n           length xs = length ys \\<and> xs || ys \\<in> L M1}\n\ngoal (1 subgoal):\n 1. (\\<And>iseq.\n        \\<lbrakk>iseq \\<in> TS;\n         x \\<in> {xs || ys |xs ys.\n                  xs \\<in> {iseq} \\<and>\n                  length xs = length ys \\<and> xs || ys \\<in> L M1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  iseq \\<in> TS\n  x \\<in> L\\<^sub>i\\<^sub>n M1 {iseq}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<in> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)\n 2. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  iseq \\<in> TS\n  x \\<in> L\\<^sub>i\\<^sub>n M1 {iseq}", "have \"atc_io_reduction_on M1 M2 iseq \\<Omega>\""], ["proof (prove)\nusing this:\n  iseq \\<in> TS\n  x \\<in> L\\<^sub>i\\<^sub>n M1 {iseq}\n\ngoal (1 subgoal):\n 1. atc_io_reduction_on M1 M2 iseq \\<Omega>", "using assms"], ["proof (prove)\nusing this:\n  iseq \\<in> TS\n  x \\<in> L\\<^sub>i\\<^sub>n M1 {iseq}\n  M1 \\<preceq>\\<lbrakk>TS.\\<Omega>\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. atc_io_reduction_on M1 M2 iseq \\<Omega>", "by auto"], ["proof (state)\nthis:\n  atc_io_reduction_on M1 M2 iseq \\<Omega>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<in> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)\n 2. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  atc_io_reduction_on M1 M2 iseq \\<Omega>", "have \"L\\<^sub>i\\<^sub>n M1 {iseq} \\<subseteq> L\\<^sub>i\\<^sub>n M2 {iseq}\""], ["proof (prove)\nusing this:\n  atc_io_reduction_on M1 M2 iseq \\<Omega>\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2", "by auto"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<in> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)\n 2. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2", "have \"x \\<in> L\\<^sub>i\\<^sub>n M2 TS\""], ["proof (prove)\nusing this:\n  M1 \\<preceq>\\<lbrakk>{iseq}\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. x \\<in> L\\<^sub>i\\<^sub>n M2 TS", "by (metis (no_types, lifting) UN_I \n            \\<open>\\<And>thesis. (\\<And>iseq. \\<lbrakk>iseq \\<in> TS; x \\<in> L\\<^sub>i\\<^sub>n M1 {iseq}\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close> \n            \\<open>\\<forall>iseq\\<in>TS. L\\<^sub>i\\<^sub>n M1 {iseq} \\<subseteq> L\\<^sub>i\\<^sub>n M2 {iseq} \\<and> (\\<forall>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega> \\<subseteq> B M2 io \\<Omega>)\\<close> \n            language_state_for_input_alt_def language_state_for_inputs_alt_def set_rev_mp)"], ["proof (state)\nthis:\n  x \\<in> L\\<^sub>i\\<^sub>n M2 TS\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<in> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)\n 2. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> L\\<^sub>i\\<^sub>n M2 TS", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> L\\<^sub>i\\<^sub>n M2 TS\n\ngoal (1 subgoal):\n 1. x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n            (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "by blast"], ["proof (state)\nthis:\n  x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n          (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "case False"], ["proof (state)\nthis:\n  x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  x \\<notin> L\\<^sub>i\\<^sub>n M1 TS", "have \"x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\""], ["proof (prove)\nusing this:\n  x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)", "using \\<open>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\n  x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n          (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)", "obtain io where \"io \\<in> L\\<^sub>i\\<^sub>n M1 TS\" \"x \\<in> B M1 io \\<Omega>\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        \\<lbrakk>io \\<in> L\\<^sub>i\\<^sub>n M1 TS;\n         x \\<in> B M1 io \\<Omega>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  io \\<in> L\\<^sub>i\\<^sub>n M1 TS\n  x \\<in> B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  io \\<in> L\\<^sub>i\\<^sub>n M1 TS\n  x \\<in> B M1 io \\<Omega>", "obtain iseq where \"iseq \\<in> TS\" \"io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}\""], ["proof (prove)\nusing this:\n  io \\<in> L\\<^sub>i\\<^sub>n M1 TS\n  x \\<in> B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>iseq.\n        \\<lbrakk>iseq \\<in> TS;\n         io \\<in> L\\<^sub>i\\<^sub>n M1 {iseq}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding language_state_for_inputs.simps"], ["proof (prove)\nusing this:\n  io \\<in> {xs || ys |xs ys.\n            xs \\<in> TS \\<and>\n            length xs = length ys \\<and> xs || ys \\<in> L M1}\n  x \\<in> B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>iseq.\n        \\<lbrakk>iseq \\<in> TS;\n         io \\<in> {xs || ys |xs ys.\n                   xs \\<in> {iseq} \\<and>\n                   length xs = length ys \\<and>\n                   xs || ys \\<in> L M1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  iseq \\<in> TS\n  io \\<in> L\\<^sub>i\\<^sub>n M1 {iseq}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "have \"x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)", "using \\<open>io \\<in> L\\<^sub>i\\<^sub>n M1 {iseq}\\<close> \\<open>x \\<in> B M1 io \\<Omega>\\<close>"], ["proof (prove)\nusing this:\n  io \\<in> L\\<^sub>i\\<^sub>n M1 {iseq}\n  x \\<in> B M1 io \\<Omega>\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)", "have \"x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "using \\<open>iseq \\<in> TS\\<close> elem_subset"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n  iseq \\<in> TS\n  \\<forall>iseq\\<in>TS.\n     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 {iseq}. B M1 io \\<Omega>)\n     \\<subseteq> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> L\\<^sub>i\\<^sub>n M1 TS \\<union>\n                     (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS.\n                         B M1 io \\<Omega>);\n     x \\<notin> L\\<^sub>i\\<^sub>n M1 TS\\<rbrakk>\n    \\<Longrightarrow> x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n                              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS.\n                                  B M2 io \\<Omega>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\n\ngoal (1 subgoal):\n 1. x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n            (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)", "by blast"], ["proof (state)\nthis:\n  x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n          (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n          (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  L\\<^sub>i\\<^sub>n M1 TS \\<union>\n  (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M1 TS. B M1 io \\<Omega>)\n  \\<subseteq> L\\<^sub>i\\<^sub>n M2 TS \\<union>\n              (\\<Union>io\\<in>L\\<^sub>i\\<^sub>n M2 TS. B M2 io \\<Omega>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}