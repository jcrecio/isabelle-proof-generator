{"file_name": "/home/qj213/afp-2021-10-22/thys/Adaptive_State_Counting/ASC/ASC_LB.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Adaptive_State_Counting", "problem_names": ["lemma perm_empty :\n  assumes \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\nshows \"[] \\<in> V''\"", "lemma perm_elem_finite :\n  assumes \"is_det_state_cover M2 V\"\n  and     \"well_formed M2\"\n  and     \"V'' \\<in> Perm V M1\"\n  shows \"finite V''\"", "lemma perm_inputs :\n  assumes \"V'' \\<in> Perm V M\"\n  and     \"vs \\<in> V''\"\nshows \"map fst vs \\<in> V\"", "lemma perm_inputs_diff :\n  assumes \"V'' \\<in> Perm V M\"\n  and     \"vs1 \\<in> V''\"\n  and     \"vs2 \\<in> V''\"\n  and     \"vs1 \\<noteq> vs2\"\nshows \"map fst vs1 \\<noteq> map fst vs2\"", "lemma perm_language :\n  assumes \"V'' \\<in> Perm V M\"\n  and     \"vs \\<in> V''\"\nshows \"vs \\<in> L M\"", "lemma asc_fault_domain_props[elim!] :\n  assumes \"asc_fault_domain M2 M1 m\"\n  shows \"inputs M2 = inputs M1\"\n        \"card (nodes M1) \\<le> m\"", "lemma test_tools_props[elim] :\n  assumes \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"asc_fault_domain M2 M1 m\"\n  shows \"productF M2 M1 FAIL PM\"\n        \"is_det_state_cover M2 V\"\n        \"applicable_set M2 \\<Omega>\"\n        \"applicable_set M1 \\<Omega>\"", "lemma perm_nonempty :\n  assumes \"is_det_state_cover M2 V\"\n  and \"OFSM M1\"\n  and \"OFSM M2\"\n  and \"inputs M1 = inputs M2\"\nshows \"Perm V M1 \\<noteq> {}\"", "lemma perm_elem :\n  assumes \"is_det_state_cover M2 V\"\n  and \"OFSM M1\"\n  and \"OFSM M2\"\n  and \"inputs M1 = inputs M2\"\n  and \"vs \\<in> V\"\n  and \"vs' \\<in> language_state_for_input M1 (initial M1) vs\"\nobtains V''\nwhere \"V'' \\<in> Perm V M1\" \"vs' \\<in> V''\"", "lemma finite_R : \"finite (R M s vs xs)\"", "lemma card_union_of_singletons :\n  assumes \"\\<forall> S \\<in> SS . (\\<exists> t . S = {t})\"\nshows \"card (\\<Union> SS) = card SS\"", "lemma card_union_of_distinct :\n  assumes \"\\<forall> S1 \\<in> SS . \\<forall> S2 \\<in> SS . S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\"\n  and     \"finite SS\"\n  and     \"\\<forall> S \\<in> SS . f S \\<noteq> {}\"\nshows \"card (image f SS) = card SS\"", "lemma R_count :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"s \\<in> nodes M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"distinct (states (xs || tr) (q2,q1))\"\nshows \"card (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))) = card (R M2 s vs xs)\"\n  \\<comment> \\<open>each sequence in the set calculated by R reaches a different state in M1\\<close>", "lemma R_state_component_2 :\n  assumes \"io \\<in> (R M2 s vs xs)\"\n  and     \"observable M2\"\nshows \"io_targets M2 (initial M2) io = {s}\"", "lemma R_union_card_is_suffix_length :\n  assumes \"OFSM M2\"\n  and     \"io@xs \\<in> L M2\"\nshows \"sum (\\<lambda> q . card (R M2 q io xs)) (nodes M2) = length xs\"", "lemma R_state_repetition_via_long_sequence :\n  assumes \"OFSM M\"\n  and     \"card (nodes M) \\<le> m\"\n  and     \"Suc (m * m) \\<le> length xs\"\n  and     \"vs@xs \\<in> L M\"\nshows \"\\<exists> q \\<in> nodes M . card (R M q vs xs) > m\"", "lemma R_state_repetition_distribution :\n  assumes \"OFSM M\"\n  and     \"Suc (card (nodes M) * m) \\<le> length xs\"\n  and     \"vs@xs \\<in> L M\"\nshows \"\\<exists> q \\<in> nodes M . card (R M q vs xs) > m\"", "lemma RP_from_R:\n  assumes \"is_det_state_cover M2 V\"\n  and     \"V'' \\<in> Perm V M1\"\nshows \"RP M2 s vs xs V'' = R M2 s vs xs\n        \\<or> (\\<exists> vs' \\<in> V'' . vs' \\<notin> R M2 s vs xs \\<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\"", "lemma finite_RP :\n  assumes \"is_det_state_cover M2 V\"\n  and     \"V'' \\<in> Perm V M1\"\nshows \"finite (RP M2 s vs xs V'')\"", "lemma RP_count :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"s \\<in> nodes M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"distinct (states (xs || tr) (q2,q1))\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"\\<forall> s' \\<in> set (states (xs || map fst tr) q2) . \\<not> (\\<exists> v \\<in> V . d_reaches M2 (initial M2) v s')\"\nshows \"card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) = card (RP M2 s vs xs V'')\"\n  \\<comment> \\<open>each sequence in the set calculated by RP reaches a different state in M1\\<close>", "lemma RP_state_component_2 :\n  assumes \"io \\<in> (RP M2 s vs xs V'')\"\n  and     \"observable M2\"\nshows \"io_targets M2 (initial M2) io = {s}\"", "lemma RP_io_targets_split :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"io \\<in> RP M2 s vs xs V''\"\nshows \"io_targets PM (initial PM) io\n        = io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\"", "lemma RP_io_targets_finite_M1 :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\nshows \"finite (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))\"", "lemma RP_io_targets_finite_PM :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\nshows \"finite (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s vs xs V'')))\"", "lemma RP_union_card_is_suffix_length :\n  assumes \"OFSM M2\"\n  and     \"io@xs \\<in> L M2\"\n  and     \"is_det_state_cover M2 V\"\n  and     \"V'' \\<in> Perm V M1\"\nshows \"\\<And> q . card (R M2 q io xs) \\<le> card (RP M2 q io xs V'')\"\n      \"sum (\\<lambda> q . card (RP M2 q io xs V'')) (nodes M2) \\<ge> length xs\"", "lemma RP_state_repetition_distribution_productF :\n  assumes \"OFSM M2\"\n  and     \"OFSM M1\"\n  and     \"(card (nodes M2) * m) \\<le> length xs\"\n  and     \"card (nodes M1) \\<le> m\"\n  and     \"vs@xs \\<in> L M2 \\<inter> L M1\"\n  and     \"is_det_state_cover M2 V\"\n  and     \"V'' \\<in> Perm V M1\"\nshows \"\\<exists> q \\<in> nodes M2 . card (RP M2 q vs xs V'') > m\"", "lemma distinctness_via_Rep_Pre :\n  assumes \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\nshows \"distinct (states (xs || tr) (q2, q1))\"", "lemma RP_count_via_Rep_Cov :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"s \\<in> nodes M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"distinct (states (xs || tr) (q2,q1))\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"card (\\<Union>(image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) = card (RP M2 s vs xs V'')\"", "lemma RP_count_alt_def :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"s \\<in> nodes M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"card (\\<Union>(image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) = card (RP M2 s vs xs V'')\"", "lemma LB_count_helper_RP_disjoint_and_cards :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"s1 \\<noteq> s2\"\nshows \"\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))\n        \\<inter> \\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')) = {}\"\n      \"card (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')))\n        = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))\"\n      \"card (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))\n        = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))\"", "lemma LB_count_helper_RP_disjoint_card_M1 :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"s1 \\<noteq> s2\"\nshows \"card (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))\n              \\<union> \\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))\n       = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))\n          + card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))\"", "lemma LB_count_helper_RP_disjoint_M1_pair :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\n  and \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and \"s1 \\<noteq> s2\"\n  and \"s1 \\<in> S\"\n  and \"s2 \\<in> S\"\n  and \"applicable_set M1 \\<Omega>\"\n  and \"completely_specified M1\"\nshows \"card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'')\n        = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))\n          + card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))\"\n      \"\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))\n          \\<inter> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V''))\n        = {}\"", "lemma LB_count_helper_RP_card_union :\n  assumes \"observable M2\"\n  and     \"s1 \\<noteq> s2\"\nshows \"RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' = {}\"", "lemma LB_count_helper_RP_inj :\nobtains f\nwhere \"\\<forall> q \\<in> (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)) .\n          f q \\<in> nodes M1\"\n      \"inj_on f (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S))\"", "lemma LB_count_helper_RP_card_union_sum :\n  assumes \"(vs @ xs) \\<in> L M2 \\<inter> L M1\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"asc_fault_domain M2 M1 m\"\n  and     \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"V'' \\<in> Perm V M1\"\n  and     \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and     \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and     \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"sum (\\<lambda> s . card (RP M2 s vs xs V'')) S\n        = sum (\\<lambda> s . card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))) S\"", "lemma finite_insert_card :\n  assumes \"finite (\\<Union>SS)\"\n  and     \"finite S\"\n  and     \"S \\<inter> (\\<Union>SS) = {}\"\nshows \"card (\\<Union> (insert S SS)) = card (\\<Union>SS) + card S\"", "lemma LB_count_helper_RP_disjoint_M1_union :\n  assumes \"(vs @ xs) \\<in> L M2 \\<inter> L M1\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"asc_fault_domain M2 M1 m\"\n  and     \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"V'' \\<in> Perm V M1\"\n  and     \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and     \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and     \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"sum (\\<lambda> s . card (RP M2 s vs xs V'')) S\n        = card (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S))\"", "lemma LB_count_helper_LB1 :\n  assumes \"(vs @ xs) \\<in> L M2 \\<inter> L M1\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"asc_fault_domain M2 M1 m\"\n  and     \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"V'' \\<in> Perm V M1\"\n  and     \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and     \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and     \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"(sum (\\<lambda> s . card (RP M2 s vs xs V'')) S) \\<le> card (nodes M1)\"", "lemma LB_count_helper_D_states :\n  assumes \"observable M\"\n  and     \"RS \\<in> (D M T \\<Omega>)\"\nobtains q\nwhere \"q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega>\"", "lemma LB_count_helper_LB2 :\n  assumes \"observable M1\"\n  and     \"IO_set M1 q \\<Omega> \\<in> (D M1 T \\<Omega>) - {B M1 xs' \\<Omega> | xs' s' . s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\"\nshows \"q \\<notin> (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S))\"", "lemma LB_count :\nassumes \"(vs @ xs) \\<in> L M1\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"asc_fault_domain M2 M1 m\"\n  and     \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"V'' \\<in> Perm V M1\"\n  and     \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and     \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and     \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|\"", "lemma contradiction_via_LB :\nassumes \"(vs @ xs) \\<in> L M1\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"asc_fault_domain M2 M1 m\"\n  and     \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"V'' \\<in> Perm V M1\"\n  and     \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and     \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and     \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\n  and     \"LB M2 M1 vs xs T S \\<Omega> V'' > m\"\nshows  \"False\""], "translations": [["", "lemma perm_empty :\n  assumes \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\nshows \"[] \\<in> V''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> V''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<in> V''", "have init_seq : \"[] \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> V", "using det_state_cover_empty assms"], ["proof (prove)\nusing this:\n  is_det_state_cover ?M ?V \\<Longrightarrow> [] \\<in> ?V\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "by simp"], ["proof (state)\nthis:\n  [] \\<in> V\n\ngoal (1 subgoal):\n 1. [] \\<in> V''", "obtain f where f_def : \"V'' = image f V\n                                \\<and> (\\<forall> v \\<in> V . f v \\<in> language_state_for_input M1 (initial M1) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        V'' = f ` V \\<and>\n        (\\<forall>v\\<in>V.\n            f v\n            \\<in> language_state_for_input M1 (initial M1)\n                   v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        V'' = f ` V \\<and>\n        (\\<forall>v\\<in>V.\n            f v\n            \\<in> language_state_for_input M1 (initial M1)\n                   v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M1 (initial M1) v)\n\ngoal (1 subgoal):\n 1. [] \\<in> V''", "then"], ["proof (chain)\npicking this:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M1 (initial M1) v)", "have \"f [] = []\""], ["proof (prove)\nusing this:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M1 (initial M1) v)\n\ngoal (1 subgoal):\n 1. f [] = []", "using init_seq"], ["proof (prove)\nusing this:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M1 (initial M1) v)\n  [] \\<in> V\n\ngoal (1 subgoal):\n 1. f [] = []", "by (metis language_state_for_input_empty singleton_iff)"], ["proof (state)\nthis:\n  f [] = []\n\ngoal (1 subgoal):\n 1. [] \\<in> V''", "then"], ["proof (chain)\npicking this:\n  f [] = []", "show ?thesis"], ["proof (prove)\nusing this:\n  f [] = []\n\ngoal (1 subgoal):\n 1. [] \\<in> V''", "using init_seq f_def"], ["proof (prove)\nusing this:\n  f [] = []\n  [] \\<in> V\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M1 (initial M1) v)\n\ngoal (1 subgoal):\n 1. [] \\<in> V''", "by (metis image_eqI)"], ["proof (state)\nthis:\n  [] \\<in> V''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_elem_finite :\n  assumes \"is_det_state_cover M2 V\"\n  and     \"well_formed M2\"\n  and     \"V'' \\<in> Perm V M1\"\n  shows \"finite V''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite V''", "obtain f where \"is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        is_det_state_cover_ass M2 f \\<and>\n        V = f ` d_reachable M2 (initial M2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_det_state_cover M2 V\n  well_formed M2\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        is_det_state_cover_ass M2 f \\<and>\n        V = f ` d_reachable M2 (initial M2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. finite V''", "moreover"], ["proof (state)\nthis:\n  is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. finite V''", "have \"finite (d_reachable M2 (initial M2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (d_reachable M2 (initial M2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (d_reachable M2 (initial M2))", "have \"finite (nodes M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M2)", "using assms"], ["proof (prove)\nusing this:\n  is_det_state_cover M2 V\n  well_formed M2\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. finite (nodes M2)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. finite (d_reachable M2 (initial M2))", "moreover"], ["proof (state)\nthis:\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. finite (d_reachable M2 (initial M2))", "have \"nodes M2 = reachable M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes M2 = reachable M2 (initial M2)", "by auto"], ["proof (state)\nthis:\n  nodes M2 = reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. finite (d_reachable M2 (initial M2))", "ultimately"], ["proof (chain)\npicking this:\n  finite (nodes M2)\n  nodes M2 = reachable M2 (initial M2)", "have \"finite (reachable M2 (initial M2))\""], ["proof (prove)\nusing this:\n  finite (nodes M2)\n  nodes M2 = reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. finite (reachable M2 (initial M2))", "by simp"], ["proof (state)\nthis:\n  finite (reachable M2 (initial M2))\n\ngoal (1 subgoal):\n 1. finite (d_reachable M2 (initial M2))", "moreover"], ["proof (state)\nthis:\n  finite (reachable M2 (initial M2))\n\ngoal (1 subgoal):\n 1. finite (d_reachable M2 (initial M2))", "have \"d_reachable M2 (initial M2) \\<subseteq> reachable M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_reachable M2 (initial M2) \\<subseteq> reachable M2 (initial M2)", "by auto"], ["proof (state)\nthis:\n  d_reachable M2 (initial M2) \\<subseteq> reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. finite (d_reachable M2 (initial M2))", "ultimately"], ["proof (chain)\npicking this:\n  finite (reachable M2 (initial M2))\n  d_reachable M2 (initial M2) \\<subseteq> reachable M2 (initial M2)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (reachable M2 (initial M2))\n  d_reachable M2 (initial M2) \\<subseteq> reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. finite (d_reachable M2 (initial M2))", "using infinite_super"], ["proof (prove)\nusing this:\n  finite (reachable M2 (initial M2))\n  d_reachable M2 (initial M2) \\<subseteq> reachable M2 (initial M2)\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. finite (d_reachable M2 (initial M2))", "by blast"], ["proof (state)\nthis:\n  finite (d_reachable M2 (initial M2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (d_reachable M2 (initial M2))\n\ngoal (1 subgoal):\n 1. finite V''", "ultimately"], ["proof (chain)\npicking this:\n  is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\n  finite (d_reachable M2 (initial M2))", "have \"finite V\""], ["proof (prove)\nusing this:\n  is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\n  finite (d_reachable M2 (initial M2))\n\ngoal (1 subgoal):\n 1. finite V", "by auto"], ["proof (state)\nthis:\n  finite V\n\ngoal (1 subgoal):\n 1. finite V''", "moreover"], ["proof (state)\nthis:\n  finite V\n\ngoal (1 subgoal):\n 1. finite V''", "obtain f'' where \"V'' = image f'' V\n                              \\<and> (\\<forall> v \\<in> V . f'' v \\<in> language_state_for_input M1 (initial M1) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f''.\n        V'' = f'' ` V \\<and>\n        (\\<forall>v\\<in>V.\n            f'' v\n            \\<in> language_state_for_input M1 (initial M1)\n                   v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(3)"], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. (\\<And>f''.\n        V'' = f'' ` V \\<and>\n        (\\<forall>v\\<in>V.\n            f'' v\n            \\<in> language_state_for_input M1 (initial M1)\n                   v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V'' = f'' ` V \\<and>\n  (\\<forall>v\\<in>V. f'' v \\<in> language_state_for_input M1 (initial M1) v)\n\ngoal (1 subgoal):\n 1. finite V''", "ultimately"], ["proof (chain)\npicking this:\n  finite V\n  V'' = f'' ` V \\<and>\n  (\\<forall>v\\<in>V. f'' v \\<in> language_state_for_input M1 (initial M1) v)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite V\n  V'' = f'' ` V \\<and>\n  (\\<forall>v\\<in>V. f'' v \\<in> language_state_for_input M1 (initial M1) v)\n\ngoal (1 subgoal):\n 1. finite V''", "by simp"], ["proof (state)\nthis:\n  finite V''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_inputs :\n  assumes \"V'' \\<in> Perm V M\"\n  and     \"vs \\<in> V''\"\nshows \"map fst vs \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "obtain f where f_def : \"V'' = image f V\n                          \\<and> (\\<forall> v \\<in> V . f v \\<in> language_state_for_input M (initial M) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        V'' = f ` V \\<and>\n        (\\<forall>v\\<in>V.\n            f v\n            \\<in> language_state_for_input M (initial M)\n                   v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M\n  vs \\<in> V''\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        V'' = f ` V \\<and>\n        (\\<forall>v\\<in>V.\n            f v\n            \\<in> language_state_for_input M (initial M)\n                   v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "then"], ["proof (chain)\npicking this:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)", "obtain v where v_def : \"v \\<in> V \\<and> f v = vs\""], ["proof (prove)\nusing this:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> V \\<and> f v = vs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n  V'' \\<in> Perm V M\n  vs \\<in> V''\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> V \\<and> f v = vs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> V \\<and> f v = vs\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "then"], ["proof (chain)\npicking this:\n  v \\<in> V \\<and> f v = vs", "have \"vs \\<in> language_state_for_input M (initial M) v\""], ["proof (prove)\nusing this:\n  v \\<in> V \\<and> f v = vs\n\ngoal (1 subgoal):\n 1. vs \\<in> language_state_for_input M (initial M) v", "using f_def"], ["proof (prove)\nusing this:\n  v \\<in> V \\<and> f v = vs\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n\ngoal (1 subgoal):\n 1. vs \\<in> language_state_for_input M (initial M) v", "by auto"], ["proof (state)\nthis:\n  vs \\<in> language_state_for_input M (initial M) v\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "then"], ["proof (chain)\npicking this:\n  vs \\<in> language_state_for_input M (initial M) v", "show ?thesis"], ["proof (prove)\nusing this:\n  vs \\<in> language_state_for_input M (initial M) v\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "using v_def"], ["proof (prove)\nusing this:\n  vs \\<in> language_state_for_input M (initial M) v\n  v \\<in> V \\<and> f v = vs\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "unfolding language_state_for_input.simps"], ["proof (prove)\nusing this:\n  vs \\<in> {v || ys |ys. length v = length ys \\<and> v || ys \\<in> L M}\n  v \\<in> V \\<and> f v = vs\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "by auto"], ["proof (state)\nthis:\n  map fst vs \\<in> V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_inputs_diff :\n  assumes \"V'' \\<in> Perm V M\"\n  and     \"vs1 \\<in> V''\"\n  and     \"vs2 \\<in> V''\"\n  and     \"vs1 \\<noteq> vs2\"\nshows \"map fst vs1 \\<noteq> map fst vs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst vs1 \\<noteq> map fst vs2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map fst vs1 \\<noteq> map fst vs2", "obtain f where f_def : \"V'' = image f V\n                          \\<and> (\\<forall> v \\<in> V . f v \\<in> language_state_for_input M (initial M) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        V'' = f ` V \\<and>\n        (\\<forall>v\\<in>V.\n            f v\n            \\<in> language_state_for_input M (initial M)\n                   v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M\n  vs1 \\<in> V''\n  vs2 \\<in> V''\n  vs1 \\<noteq> vs2\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        V'' = f ` V \\<and>\n        (\\<forall>v\\<in>V.\n            f v\n            \\<in> language_state_for_input M (initial M)\n                   v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n\ngoal (1 subgoal):\n 1. map fst vs1 \\<noteq> map fst vs2", "then"], ["proof (chain)\npicking this:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)", "obtain v1 v2 where v_def : \"v1 \\<in> V \\<and> f v1 = vs1 \\<and> v2 \\<in> V \\<and> f v2 = vs2\""], ["proof (prove)\nusing this:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        v1 \\<in> V \\<and>\n        f v1 = vs1 \\<and> v2 \\<in> V \\<and> f v2 = vs2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n  V'' \\<in> Perm V M\n  vs1 \\<in> V''\n  vs2 \\<in> V''\n  vs1 \\<noteq> vs2\n\ngoal (1 subgoal):\n 1. (\\<And>v1 v2.\n        v1 \\<in> V \\<and>\n        f v1 = vs1 \\<and> v2 \\<in> V \\<and> f v2 = vs2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v1 \\<in> V \\<and> f v1 = vs1 \\<and> v2 \\<in> V \\<and> f v2 = vs2\n\ngoal (1 subgoal):\n 1. map fst vs1 \\<noteq> map fst vs2", "then"], ["proof (chain)\npicking this:\n  v1 \\<in> V \\<and> f v1 = vs1 \\<and> v2 \\<in> V \\<and> f v2 = vs2", "have \"vs1 \\<in> language_state_for_input M (initial M) v1\"\n            \"vs2 \\<in> language_state_for_input M (initial M) v2\""], ["proof (prove)\nusing this:\n  v1 \\<in> V \\<and> f v1 = vs1 \\<and> v2 \\<in> V \\<and> f v2 = vs2\n\ngoal (1 subgoal):\n 1. vs1 \\<in> language_state_for_input M (initial M) v1 &&&\n    vs2 \\<in> language_state_for_input M (initial M) v2", "using f_def"], ["proof (prove)\nusing this:\n  v1 \\<in> V \\<and> f v1 = vs1 \\<and> v2 \\<in> V \\<and> f v2 = vs2\n  V'' = f ` V \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n\ngoal (1 subgoal):\n 1. vs1 \\<in> language_state_for_input M (initial M) v1 &&&\n    vs2 \\<in> language_state_for_input M (initial M) v2", "by auto"], ["proof (state)\nthis:\n  vs1 \\<in> language_state_for_input M (initial M) v1\n  vs2 \\<in> language_state_for_input M (initial M) v2\n\ngoal (1 subgoal):\n 1. map fst vs1 \\<noteq> map fst vs2", "moreover"], ["proof (state)\nthis:\n  vs1 \\<in> language_state_for_input M (initial M) v1\n  vs2 \\<in> language_state_for_input M (initial M) v2\n\ngoal (1 subgoal):\n 1. map fst vs1 \\<noteq> map fst vs2", "have \"v1 \\<noteq> v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v2", "using v_def assms(4)"], ["proof (prove)\nusing this:\n  v1 \\<in> V \\<and> f v1 = vs1 \\<and> v2 \\<in> V \\<and> f v2 = vs2\n  vs1 \\<noteq> vs2\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v2", "by blast"], ["proof (state)\nthis:\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. map fst vs1 \\<noteq> map fst vs2", "ultimately"], ["proof (chain)\npicking this:\n  vs1 \\<in> language_state_for_input M (initial M) v1\n  vs2 \\<in> language_state_for_input M (initial M) v2\n  v1 \\<noteq> v2", "show ?thesis"], ["proof (prove)\nusing this:\n  vs1 \\<in> language_state_for_input M (initial M) v1\n  vs2 \\<in> language_state_for_input M (initial M) v2\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. map fst vs1 \\<noteq> map fst vs2", "by auto"], ["proof (state)\nthis:\n  map fst vs1 \\<noteq> map fst vs2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_language :\n  assumes \"V'' \\<in> Perm V M\"\n  and     \"vs \\<in> V''\"\nshows \"vs \\<in> L M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> L M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vs \\<in> L M", "obtain f where f_def : \"image f V = V''\n                          \\<and> (\\<forall> v \\<in> V . f v \\<in> language_state_for_input M (initial M) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f ` V = V'' \\<and>\n        (\\<forall>v\\<in>V.\n            f v\n            \\<in> language_state_for_input M (initial M)\n                   v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f ` V = V'' \\<and>\n        (\\<forall>v\\<in>V.\n            f v\n            \\<in> language_state_for_input M (initial M)\n                   v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f ` V = V'' \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n\ngoal (1 subgoal):\n 1. vs \\<in> L M", "then"], ["proof (chain)\npicking this:\n  f ` V = V'' \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)", "have \"\\<exists> v . f v = vs \\<and> f v \\<in> language_state_for_input M (initial M) v\""], ["proof (prove)\nusing this:\n  f ` V = V'' \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       f v = vs \\<and> f v \\<in> language_state_for_input M (initial M) v", "using assms(2)"], ["proof (prove)\nusing this:\n  f ` V = V'' \\<and>\n  (\\<forall>v\\<in>V. f v \\<in> language_state_for_input M (initial M) v)\n  vs \\<in> V''\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       f v = vs \\<and> f v \\<in> language_state_for_input M (initial M) v", "by blast"], ["proof (state)\nthis:\n  \\<exists>v.\n     f v = vs \\<and> f v \\<in> language_state_for_input M (initial M) v\n\ngoal (1 subgoal):\n 1. vs \\<in> L M", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     f v = vs \\<and> f v \\<in> language_state_for_input M (initial M) v", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     f v = vs \\<and> f v \\<in> language_state_for_input M (initial M) v\n\ngoal (1 subgoal):\n 1. vs \\<in> L M", "by auto"], ["proof (state)\nthis:\n  vs \\<in> L M\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Helper predicates \\<close>"], ["", "text \\<open>\nThe following predicates are used to combine often repeated assumption.\n\\<close>"], ["", "abbreviation \"asc_fault_domain M2 M1 m \\<equiv> (inputs M2 = inputs M1 \\<and> card (nodes M1) \\<le> m )\""], ["", "lemma asc_fault_domain_props[elim!] :\n  assumes \"asc_fault_domain M2 M1 m\"\n  shows \"inputs M2 = inputs M1\"\n        \"card (nodes M1) \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputs M2 = inputs M1 &&& |M1| \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  asc_fault_domain M2 M1 m\n\ngoal (1 subgoal):\n 1. inputs M2 = inputs M1 &&& |M1| \\<le> m", "by auto"], ["", "abbreviation\n  \"test_tools M2 M1 FAIL PM V \\<Omega> \\<equiv> (\n      productF M2 M1 FAIL PM\n    \\<and> is_det_state_cover M2 V\n    \\<and> applicable_set M2 \\<Omega>\n   )\""], ["", "lemma test_tools_props[elim] :\n  assumes \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"asc_fault_domain M2 M1 m\"\n  shows \"productF M2 M1 FAIL PM\"\n        \"is_det_state_cover M2 V\"\n        \"applicable_set M2 \\<Omega>\"\n        \"applicable_set M1 \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (productF M2 M1 FAIL PM &&& is_det_state_cover M2 V) &&&\n    applicable_set M2 \\<Omega> &&& applicable_set M1 \\<Omega>", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. productF M2 M1 FAIL PM\n 2. is_det_state_cover M2 V\n 3. applicable_set M2 \\<Omega>\n 4. applicable_set M1 \\<Omega>", "show \"productF M2 M1 FAIL PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. productF M2 M1 FAIL PM", "using assms(1)"], ["proof (prove)\nusing this:\n  test_tools M2 M1 FAIL PM V \\<Omega>\n\ngoal (1 subgoal):\n 1. productF M2 M1 FAIL PM", "by blast"], ["proof (state)\nthis:\n  productF M2 M1 FAIL PM\n\ngoal (3 subgoals):\n 1. is_det_state_cover M2 V\n 2. applicable_set M2 \\<Omega>\n 3. applicable_set M1 \\<Omega>", "show \"is_det_state_cover M2 V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_det_state_cover M2 V", "using assms(1)"], ["proof (prove)\nusing this:\n  test_tools M2 M1 FAIL PM V \\<Omega>\n\ngoal (1 subgoal):\n 1. is_det_state_cover M2 V", "by blast"], ["proof (state)\nthis:\n  is_det_state_cover M2 V\n\ngoal (2 subgoals):\n 1. applicable_set M2 \\<Omega>\n 2. applicable_set M1 \\<Omega>", "show \"applicable_set M2 \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. applicable_set M2 \\<Omega>", "using assms(1)"], ["proof (prove)\nusing this:\n  test_tools M2 M1 FAIL PM V \\<Omega>\n\ngoal (1 subgoal):\n 1. applicable_set M2 \\<Omega>", "by blast"], ["proof (state)\nthis:\n  applicable_set M2 \\<Omega>\n\ngoal (1 subgoal):\n 1. applicable_set M1 \\<Omega>", "then"], ["proof (chain)\npicking this:\n  applicable_set M2 \\<Omega>", "show \"applicable_set M1 \\<Omega>\""], ["proof (prove)\nusing this:\n  applicable_set M2 \\<Omega>\n\ngoal (1 subgoal):\n 1. applicable_set M1 \\<Omega>", "unfolding applicable_set.simps applicable.simps"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>\\<Omega>. inputs_atc t \\<subseteq> inputs M2\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>\\<Omega>. inputs_atc t \\<subseteq> inputs M1", "using asc_fault_domain_props(1)[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>\\<Omega>. inputs_atc t \\<subseteq> inputs M2\n  inputs M2 = inputs M1\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>\\<Omega>. inputs_atc t \\<subseteq> inputs M1", "by simp"], ["proof (state)\nthis:\n  applicable_set M1 \\<Omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_nonempty :\n  assumes \"is_det_state_cover M2 V\"\n  and \"OFSM M1\"\n  and \"OFSM M2\"\n  and \"inputs M1 = inputs M2\"\nshows \"Perm V M1 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Perm V M1 \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Perm V M1 \\<noteq> {}", "have \"finite (nodes M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M2)", "using assms(3)"], ["proof (prove)\nusing this:\n  OFSM M2\n\ngoal (1 subgoal):\n 1. finite (nodes M2)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. Perm V M1 \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. Perm V M1 \\<noteq> {}", "have \"d_reachable M2 (initial M2) \\<subseteq> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_reachable M2 (initial M2) \\<subseteq> nodes M2", "by auto"], ["proof (state)\nthis:\n  d_reachable M2 (initial M2) \\<subseteq> nodes M2\n\ngoal (1 subgoal):\n 1. Perm V M1 \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  finite (nodes M2)\n  d_reachable M2 (initial M2) \\<subseteq> nodes M2", "have \"finite V\""], ["proof (prove)\nusing this:\n  finite (nodes M2)\n  d_reachable M2 (initial M2) \\<subseteq> nodes M2\n\ngoal (1 subgoal):\n 1. finite V", "using det_state_cover_card[OF assms(1)]"], ["proof (prove)\nusing this:\n  finite (nodes M2)\n  d_reachable M2 (initial M2) \\<subseteq> nodes M2\n  finite (nodes M2) \\<Longrightarrow>\n  card (d_reachable M2 (initial M2)) = card V\n\ngoal (1 subgoal):\n 1. finite V", "by (metis assms(1) finite_imageI infinite_super is_det_state_cover.elims(2))"], ["proof (state)\nthis:\n  finite V\n\ngoal (1 subgoal):\n 1. Perm V M1 \\<noteq> {}", "have \"[] \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> V", "using assms(1) det_state_cover_empty"], ["proof (prove)\nusing this:\n  is_det_state_cover M2 V\n  is_det_state_cover ?M ?V \\<Longrightarrow> [] \\<in> ?V\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "by blast"], ["proof (state)\nthis:\n  [] \\<in> V\n\ngoal (1 subgoal):\n 1. Perm V M1 \\<noteq> {}", "have \"\\<And> VS . VS \\<subseteq> V \\<and> VS \\<noteq> {} \\<Longrightarrow> Perm VS M1 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>VS.\n       VS \\<subseteq> V \\<and> VS \\<noteq> {} \\<Longrightarrow>\n       Perm VS M1 \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>VS.\n       VS \\<subseteq> V \\<and> VS \\<noteq> {} \\<Longrightarrow>\n       Perm VS M1 \\<noteq> {}", "fix VS"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>VS.\n       VS \\<subseteq> V \\<and> VS \\<noteq> {} \\<Longrightarrow>\n       Perm VS M1 \\<noteq> {}", "assume \"VS \\<subseteq> V \\<and> VS \\<noteq> {}\""], ["proof (state)\nthis:\n  VS \\<subseteq> V \\<and> VS \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>VS.\n       VS \\<subseteq> V \\<and> VS \\<noteq> {} \\<Longrightarrow>\n       Perm VS M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  VS \\<subseteq> V \\<and> VS \\<noteq> {}", "have \"finite VS\""], ["proof (prove)\nusing this:\n  VS \\<subseteq> V \\<and> VS \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite VS", "using \\<open>finite V\\<close>"], ["proof (prove)\nusing this:\n  VS \\<subseteq> V \\<and> VS \\<noteq> {}\n  finite V\n\ngoal (1 subgoal):\n 1. finite VS", "using infinite_subset"], ["proof (prove)\nusing this:\n  VS \\<subseteq> V \\<and> VS \\<noteq> {}\n  finite V\n  \\<lbrakk>infinite ?A; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> infinite ?B\n\ngoal (1 subgoal):\n 1. finite VS", "by auto"], ["proof (state)\nthis:\n  finite VS\n\ngoal (1 subgoal):\n 1. \\<And>VS.\n       VS \\<subseteq> V \\<and> VS \\<noteq> {} \\<Longrightarrow>\n       Perm VS M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  finite VS", "show \"Perm VS M1 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  finite VS\n\ngoal (1 subgoal):\n 1. Perm VS M1 \\<noteq> {}", "using \\<open>VS \\<subseteq> V \\<and> VS \\<noteq> {}\\<close> \\<open>finite VS\\<close>"], ["proof (prove)\nusing this:\n  finite VS\n  VS \\<subseteq> V \\<and> VS \\<noteq> {}\n  finite VS\n\ngoal (1 subgoal):\n 1. Perm VS M1 \\<noteq> {}", "proof (induction VS)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> V \\<and> {} \\<noteq> {}; finite {}\\<rbrakk>\n    \\<Longrightarrow> Perm {} M1 \\<noteq> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> V \\<and> {} \\<noteq> {}\n  finite {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> V \\<and> {} \\<noteq> {}; finite {}\\<rbrakk>\n    \\<Longrightarrow> Perm {} M1 \\<noteq> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  {} \\<subseteq> V \\<and> {} \\<noteq> {}\n  finite {}", "show ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> V \\<and> {} \\<noteq> {}\n  finite {}\n\ngoal (1 subgoal):\n 1. Perm {} M1 \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Perm {} M1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "case (insert vs F)"], ["proof (state)\nthis:\n  finite F\n  vs \\<notin> F\n  \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n  \\<Longrightarrow> Perm F M1 \\<noteq> {}\n  insert vs F \\<subseteq> V \\<and> insert vs F \\<noteq> {}\n  finite (insert vs F)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  finite F\n  vs \\<notin> F\n  \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n  \\<Longrightarrow> Perm F M1 \\<noteq> {}\n  insert vs F \\<subseteq> V \\<and> insert vs F \\<noteq> {}\n  finite (insert vs F)", "have \"vs \\<in> V\""], ["proof (prove)\nusing this:\n  finite F\n  vs \\<notin> F\n  \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n  \\<Longrightarrow> Perm F M1 \\<noteq> {}\n  insert vs F \\<subseteq> V \\<and> insert vs F \\<noteq> {}\n  finite (insert vs F)\n\ngoal (1 subgoal):\n 1. vs \\<in> V", "by blast"], ["proof (state)\nthis:\n  vs \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "obtain q2 where \"d_reaches M2 (initial M2) vs q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        d_reaches M2 (initial M2) vs q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using det_state_cover_d_reachable[OF assms(1) \\<open>vs \\<in> V\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>q.\n      d_reaches M2 (initial M2) vs q \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        d_reaches M2 (initial M2) vs q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  d_reaches M2 (initial M2) vs q2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  d_reaches M2 (initial M2) vs q2", "obtain vs' vsP where io_path : \"length vs = length vs'\n                                            \\<and> length vs = length vsP\n                                            \\<and> (path M2 ((vs || vs') || vsP) (initial M2))\n                                            \\<and> target ((vs || vs') || vsP) (initial M2) = q2\""], ["proof (prove)\nusing this:\n  d_reaches M2 (initial M2) vs q2\n\ngoal (1 subgoal):\n 1. (\\<And>vs' vsP.\n        length vs = length vs' \\<and>\n        length vs = length vsP \\<and>\n        path M2 ((vs || vs') || vsP) (initial M2) \\<and>\n        target ((vs || vs') || vsP) (initial M2) = q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length vs = length vs' \\<and>\n  length vs = length vsP \\<and>\n  path M2 ((vs || vs') || vsP) (initial M2) \\<and>\n  target ((vs || vs') || vsP) (initial M2) = q2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "have \"well_formed M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_formed M2", "using assms"], ["proof (prove)\nusing this:\n  is_det_state_cover M2 V\n  OFSM M1\n  OFSM M2\n  inputs M1 = inputs M2\n\ngoal (1 subgoal):\n 1. well_formed M2", "by auto"], ["proof (state)\nthis:\n  well_formed M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "have \"map fst (map fst ((vs || vs') || vsP)) = vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map fst ((vs || vs') || vsP)) = vs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map fst (map fst ((vs || vs') || vsP)) = vs", "have \"length (vs || vs') = length vsP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (vs || vs') = length vsP", "using io_path"], ["proof (prove)\nusing this:\n  length vs = length vs' \\<and>\n  length vs = length vsP \\<and>\n  path M2 ((vs || vs') || vsP) (initial M2) \\<and>\n  target ((vs || vs') || vsP) (initial M2) = q2\n\ngoal (1 subgoal):\n 1. length (vs || vs') = length vsP", "by simp"], ["proof (state)\nthis:\n  length (vs || vs') = length vsP\n\ngoal (1 subgoal):\n 1. map fst (map fst ((vs || vs') || vsP)) = vs", "then"], ["proof (chain)\npicking this:\n  length (vs || vs') = length vsP", "show ?thesis"], ["proof (prove)\nusing this:\n  length (vs || vs') = length vsP\n\ngoal (1 subgoal):\n 1. map fst (map fst ((vs || vs') || vsP)) = vs", "using io_path"], ["proof (prove)\nusing this:\n  length (vs || vs') = length vsP\n  length vs = length vs' \\<and>\n  length vs = length vsP \\<and>\n  path M2 ((vs || vs') || vsP) (initial M2) \\<and>\n  target ((vs || vs') || vsP) (initial M2) = q2\n\ngoal (1 subgoal):\n 1. map fst (map fst ((vs || vs') || vsP)) = vs", "by auto"], ["proof (state)\nthis:\n  map fst (map fst ((vs || vs') || vsP)) = vs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map fst (map fst ((vs || vs') || vsP)) = vs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  map fst (map fst ((vs || vs') || vsP)) = vs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "have \"set (map fst (map fst ((vs || vs') || vsP))) \\<subseteq> inputs M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (map fst ((vs || vs') || vsP))) \\<subseteq> inputs M2", "using path_input_containment[OF \\<open>well_formed M2\\<close>, of \"(vs || vs') || vsP\" \"initial M2\"]\n              io_path"], ["proof (prove)\nusing this:\n  path M2 ((vs || vs') || vsP) (initial M2) \\<Longrightarrow>\n  set (map fst (map fst ((vs || vs') || vsP))) \\<subseteq> inputs M2\n  length vs = length vs' \\<and>\n  length vs = length vsP \\<and>\n  path M2 ((vs || vs') || vsP) (initial M2) \\<and>\n  target ((vs || vs') || vsP) (initial M2) = q2\n\ngoal (1 subgoal):\n 1. set (map fst (map fst ((vs || vs') || vsP))) \\<subseteq> inputs M2", "by linarith"], ["proof (state)\nthis:\n  set (map fst (map fst ((vs || vs') || vsP))) \\<subseteq> inputs M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  map fst (map fst ((vs || vs') || vsP)) = vs\n  set (map fst (map fst ((vs || vs') || vsP))) \\<subseteq> inputs M2", "have \"set vs \\<subseteq> inputs M2\""], ["proof (prove)\nusing this:\n  map fst (map fst ((vs || vs') || vsP)) = vs\n  set (map fst (map fst ((vs || vs') || vsP))) \\<subseteq> inputs M2\n\ngoal (1 subgoal):\n 1. set vs \\<subseteq> inputs M2", "by presburger"], ["proof (state)\nthis:\n  set vs \\<subseteq> inputs M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  set vs \\<subseteq> inputs M2", "have \"set vs \\<subseteq> inputs M1\""], ["proof (prove)\nusing this:\n  set vs \\<subseteq> inputs M2\n\ngoal (1 subgoal):\n 1. set vs \\<subseteq> inputs M1", "using assms"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> inputs M2\n  is_det_state_cover M2 V\n  OFSM M1\n  OFSM M2\n  inputs M1 = inputs M2\n\ngoal (1 subgoal):\n 1. set vs \\<subseteq> inputs M1", "by auto"], ["proof (state)\nthis:\n  set vs \\<subseteq> inputs M1\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  set vs \\<subseteq> inputs M1", "have \"L\\<^sub>i\\<^sub>n M1 {vs} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  set vs \\<subseteq> inputs M1\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {vs} \\<noteq> {}", "using assms(2) language_state_for_inputs_nonempty"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> inputs M1\n  OFSM M1\n  \\<lbrakk>set ?xs \\<subseteq> inputs ?M; completely_specified ?M;\n   ?q \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> LS\\<^sub>i\\<^sub>n ?M ?q {?xs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 {vs} \\<noteq> {}", "by (metis FSM.nodes.initial)"], ["proof (state)\nthis:\n  L\\<^sub>i\\<^sub>n M1 {vs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  L\\<^sub>i\\<^sub>n M1 {vs} \\<noteq> {}", "have \"language_state_for_input M1 (initial M1) vs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  L\\<^sub>i\\<^sub>n M1 {vs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. language_state_for_input M1 (initial M1) vs \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  language_state_for_input M1 (initial M1) vs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  language_state_for_input M1 (initial M1) vs \\<noteq> {}", "obtain vs' where \"vs' \\<in> language_state_for_input M1 (initial M1) vs\""], ["proof (prove)\nusing this:\n  language_state_for_input M1 (initial M1) vs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        vs'\n        \\<in> language_state_for_input M1 (initial M1) vs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vs' \\<in> language_state_for_input M1 (initial M1) vs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n        \\<Longrightarrow> Perm F M1 \\<noteq> {};\n        insert x F \\<subseteq> V \\<and> insert x F \\<noteq> {};\n        finite (insert x F)\\<rbrakk>\n       \\<Longrightarrow> Perm (insert x F) M1 \\<noteq> {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Perm (insert vs F) M1 \\<noteq> {}", "proof (cases \"F = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}\n 2. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "case True"], ["proof (state)\nthis:\n  F = {}\n\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}\n 2. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  F = {}\n\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}\n 2. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "obtain f where \"f vs = vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. f vs = vs' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by moura"], ["proof (state)\nthis:\n  f vs = vs'\n\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}\n 2. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  F = {}\n  f vs = vs'", "have \"image f (insert vs F) \\<in> Perm (insert vs F) M1\""], ["proof (prove)\nusing this:\n  F = {}\n  f vs = vs'\n\ngoal (1 subgoal):\n 1. f ` insert vs F \\<in> Perm (insert vs F) M1", "using Perm.simps \\<open>vs' \\<in> language_state_for_input M1 (initial M1) vs\\<close>"], ["proof (prove)\nusing this:\n  F = {}\n  f vs = vs'\n  Perm ?V ?M =\n  {f ` ?V |f.\n   \\<forall>v\\<in>?V. f v \\<in> language_state_for_input ?M (initial ?M) v}\n  vs' \\<in> language_state_for_input M1 (initial M1) vs\n\ngoal (1 subgoal):\n 1. f ` insert vs F \\<in> Perm (insert vs F) M1", "by blast"], ["proof (state)\nthis:\n  f ` insert vs F \\<in> Perm (insert vs F) M1\n\ngoal (2 subgoals):\n 1. F = {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}\n 2. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  f ` insert vs F \\<in> Perm (insert vs F) M1", "show ?thesis"], ["proof (prove)\nusing this:\n  f ` insert vs F \\<in> Perm (insert vs F) M1\n\ngoal (1 subgoal):\n 1. Perm (insert vs F) M1 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  Perm (insert vs F) M1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "case False"], ["proof (state)\nthis:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  F \\<noteq> {}", "obtain F'' where \"F'' \\<in> Perm F M1\""], ["proof (prove)\nusing this:\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>F''.\n        F'' \\<in> Perm F M1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert.IH insert.hyps(1) insert.prems(1)"], ["proof (prove)\nusing this:\n  F \\<noteq> {}\n  \\<lbrakk>F \\<subseteq> V \\<and> F \\<noteq> {}; finite F\\<rbrakk>\n  \\<Longrightarrow> Perm F M1 \\<noteq> {}\n  finite F\n  insert vs F \\<subseteq> V \\<and> insert vs F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>F''.\n        F'' \\<in> Perm F M1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  F'' \\<in> Perm F M1\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  F'' \\<in> Perm F M1", "obtain f where \"F'' = image f F\"\n                            \"(\\<forall> v \\<in> F . f v \\<in> language_state_for_input M1 (initial M1) v)\""], ["proof (prove)\nusing this:\n  F'' \\<in> Perm F M1\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>F'' = f ` F;\n         \\<forall>v\\<in>F.\n            f v \\<in> language_state_for_input M1 (initial M1) v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  F'' = f ` F\n  \\<forall>v\\<in>F. f v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "let ?f = \"f(vs := vs')\""], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "have \"\\<forall> v \\<in> (insert vs F) . ?f v \\<in> language_state_for_input M1 (initial M1) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>insert vs F.\n       (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> insert vs F \\<Longrightarrow>\n       (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> insert vs F \\<Longrightarrow>\n       (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "assume \"v \\<in> insert vs F\""], ["proof (state)\nthis:\n  v \\<in> insert vs F\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> insert vs F \\<Longrightarrow>\n       (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "then"], ["proof (chain)\npicking this:\n  v \\<in> insert vs F", "show \"?f v \\<in> language_state_for_input M1 (initial M1) v\""], ["proof (prove)\nusing this:\n  v \\<in> insert vs F\n\ngoal (1 subgoal):\n 1. (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "proof (cases \"v = vs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> insert vs F; v = vs\\<rbrakk>\n    \\<Longrightarrow> (f(vs := vs')) v\n                      \\<in> language_state_for_input M1 (initial M1) v\n 2. \\<lbrakk>v \\<in> insert vs F; v \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> (f(vs := vs')) v\n                      \\<in> language_state_for_input M1 (initial M1) v", "case True"], ["proof (state)\nthis:\n  v = vs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> insert vs F; v = vs\\<rbrakk>\n    \\<Longrightarrow> (f(vs := vs')) v\n                      \\<in> language_state_for_input M1 (initial M1) v\n 2. \\<lbrakk>v \\<in> insert vs F; v \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> (f(vs := vs')) v\n                      \\<in> language_state_for_input M1 (initial M1) v", "then"], ["proof (chain)\npicking this:\n  v = vs", "show ?thesis"], ["proof (prove)\nusing this:\n  v = vs\n\ngoal (1 subgoal):\n 1. (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "using \\<open>vs' \\<in> language_state_for_input M1 (initial M1) vs\\<close>"], ["proof (prove)\nusing this:\n  v = vs\n  vs' \\<in> language_state_for_input M1 (initial M1) vs\n\ngoal (1 subgoal):\n 1. (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "by auto"], ["proof (state)\nthis:\n  (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> insert vs F; v \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> (f(vs := vs')) v\n                      \\<in> language_state_for_input M1 (initial M1) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> insert vs F; v \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> (f(vs := vs')) v\n                      \\<in> language_state_for_input M1 (initial M1) v", "case False"], ["proof (state)\nthis:\n  v \\<noteq> vs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> insert vs F; v \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> (f(vs := vs')) v\n                      \\<in> language_state_for_input M1 (initial M1) v", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> vs", "have \"v \\<in> F\""], ["proof (prove)\nusing this:\n  v \\<noteq> vs\n\ngoal (1 subgoal):\n 1. v \\<in> F", "using \\<open>v \\<in> insert vs F\\<close>"], ["proof (prove)\nusing this:\n  v \\<noteq> vs\n  v \\<in> insert vs F\n\ngoal (1 subgoal):\n 1. v \\<in> F", "by blast"], ["proof (state)\nthis:\n  v \\<in> F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> insert vs F; v \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> (f(vs := vs')) v\n                      \\<in> language_state_for_input M1 (initial M1) v", "then"], ["proof (chain)\npicking this:\n  v \\<in> F", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> F\n\ngoal (1 subgoal):\n 1. (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "using False \\<open>\\<forall>v\\<in>F. f v \\<in> language_state_for_input M1 (initial M1) v\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> F\n  v \\<noteq> vs\n  \\<forall>v\\<in>F. f v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal (1 subgoal):\n 1. (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "by auto"], ["proof (state)\nthis:\n  (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>v\\<in>insert vs F.\n     (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>insert vs F.\n     (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "have \"image ?f (insert vs F) \\<in> Perm (insert vs F) M1\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>insert vs F.\n     (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal (1 subgoal):\n 1. f(vs := vs') ` insert vs F \\<in> Perm (insert vs F) M1", "using Perm.simps"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>insert vs F.\n     (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v\n  Perm ?V ?M =\n  {f ` ?V |f.\n   \\<forall>v\\<in>?V. f v \\<in> language_state_for_input ?M (initial ?M) v}\n\ngoal (1 subgoal):\n 1. f(vs := vs') ` insert vs F \\<in> Perm (insert vs F) M1", "by blast"], ["proof (state)\nthis:\n  f(vs := vs') ` insert vs F \\<in> Perm (insert vs F) M1\n\ngoal (1 subgoal):\n 1. F \\<noteq> {} \\<Longrightarrow> Perm (insert vs F) M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  f(vs := vs') ` insert vs F \\<in> Perm (insert vs F) M1", "show ?thesis"], ["proof (prove)\nusing this:\n  f(vs := vs') ` insert vs F \\<in> Perm (insert vs F) M1\n\ngoal (1 subgoal):\n 1. Perm (insert vs F) M1 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  Perm (insert vs F) M1 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Perm (insert vs F) M1 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Perm VS M1 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?VS \\<subseteq> V \\<and> ?VS \\<noteq> {} \\<Longrightarrow>\n  Perm ?VS M1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Perm V M1 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  ?VS \\<subseteq> V \\<and> ?VS \\<noteq> {} \\<Longrightarrow>\n  Perm ?VS M1 \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?VS \\<subseteq> V \\<and> ?VS \\<noteq> {} \\<Longrightarrow>\n  Perm ?VS M1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Perm V M1 \\<noteq> {}", "using \\<open>[] \\<in> V\\<close>"], ["proof (prove)\nusing this:\n  ?VS \\<subseteq> V \\<and> ?VS \\<noteq> {} \\<Longrightarrow>\n  Perm ?VS M1 \\<noteq> {}\n  [] \\<in> V\n\ngoal (1 subgoal):\n 1. Perm V M1 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  Perm V M1 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_elem :\n  assumes \"is_det_state_cover M2 V\"\n  and \"OFSM M1\"\n  and \"OFSM M2\"\n  and \"inputs M1 = inputs M2\"\n  and \"vs \\<in> V\"\n  and \"vs' \\<in> language_state_for_input M1 (initial M1) vs\"\nobtains V''\nwhere \"V'' \\<in> Perm V M1\" \"vs' \\<in> V''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        \\<lbrakk>V'' \\<in> Perm V M1; vs' \\<in> V''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        \\<lbrakk>V'' \\<in> Perm V M1; vs' \\<in> V''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain V'' where \"V'' \\<in> Perm V M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        V'' \\<in> Perm V M1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using perm_nonempty[OF assms(1-4)]"], ["proof (prove)\nusing this:\n  Perm V M1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        V'' \\<in> Perm V M1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        \\<lbrakk>V'' \\<in> Perm V M1; vs' \\<in> V''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  V'' \\<in> Perm V M1", "obtain f where \"V'' = image f V\"\n                      \"(\\<forall> v \\<in> V . f v \\<in> language_state_for_input M1 (initial M1) v)\""], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>V'' = f ` V;\n         \\<forall>v\\<in>V.\n            f v \\<in> language_state_for_input M1 (initial M1) v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  V'' = f ` V\n  \\<forall>v\\<in>V. f v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        \\<lbrakk>V'' \\<in> Perm V M1; vs' \\<in> V''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?f = \"f(vs := vs')\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        \\<lbrakk>V'' \\<in> Perm V M1; vs' \\<in> V''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall> v \\<in> V . (?f v) \\<in> (language_state_for_input M1 (initial M1) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V.\n       (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "using \\<open>\\<forall>v\\<in>V. (f v) \\<in> (language_state_for_input M1 (initial M1) v)\\<close> assms(6)"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V. f v \\<in> language_state_for_input M1 (initial M1) v\n  vs' \\<in> language_state_for_input M1 (initial M1) vs\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V.\n       (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V.\n     (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        \\<lbrakk>V'' \\<in> Perm V M1; vs' \\<in> V''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>V.\n     (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v", "have \"(image ?f V) \\<in> Perm V M1\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V.\n     (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal (1 subgoal):\n 1. f(vs := vs') ` V \\<in> Perm V M1", "unfolding Perm.simps"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V.\n     (f(vs := vs')) v \\<in> language_state_for_input M1 (initial M1) v\n\ngoal (1 subgoal):\n 1. f(vs := vs') ` V\n    \\<in> {f ` V |f.\n           \\<forall>v\\<in>V.\n              f v \\<in> language_state_for_input M1 (initial M1) v}", "by blast"], ["proof (state)\nthis:\n  f(vs := vs') ` V \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        \\<lbrakk>V'' \\<in> Perm V M1; vs' \\<in> V''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  f(vs := vs') ` V \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        \\<lbrakk>V'' \\<in> Perm V M1; vs' \\<in> V''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"vs' \\<in> image ?f V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs' \\<in> f(vs := vs') ` V", "by (metis assms(5) fun_upd_same imageI)"], ["proof (state)\nthis:\n  vs' \\<in> f(vs := vs') ` V\n\ngoal (1 subgoal):\n 1. (\\<And>V''.\n        \\<lbrakk>V'' \\<in> Perm V M1; vs' \\<in> V''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  f(vs := vs') ` V \\<in> Perm V M1\n  vs' \\<in> f(vs := vs') ` V", "show ?thesis"], ["proof (prove)\nusing this:\n  f(vs := vs') ` V \\<in> Perm V M1\n  vs' \\<in> f(vs := vs') ` V\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  f(vs := vs') ` V \\<in> Perm V M1\n  vs' \\<in> f(vs := vs') ` V\n  \\<lbrakk>?V'' \\<in> Perm V M1; vs' \\<in> ?V''\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Function R \\<close>"], ["", "text \\<open>\nFunction @{verbatim R} calculates the set of suffixes of a sequence that reach a given state if\napplied after a given other sequence.\n\\<close>"], ["", "fun R :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \\<Rightarrow> ('in \\<times> 'out) list\n          \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> ('in \\<times> 'out) list set\"\n  where\n  \"R M s vs xs = { vs@xs' | xs' . xs' \\<noteq> []\n                                \\<and> prefix xs' xs\n                                \\<and> s \\<in> io_targets M (initial M) (vs@xs') }\""], ["", "lemma finite_R : \"finite (R M s vs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R M s vs xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (R M s vs xs)", "have \"R M s vs xs \\<subseteq> { vs @ xs' | xs' .prefix xs' xs }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R M s vs xs \\<subseteq> {vs @ xs' |xs'. prefix xs' xs}", "by auto"], ["proof (state)\nthis:\n  R M s vs xs \\<subseteq> {vs @ xs' |xs'. prefix xs' xs}\n\ngoal (1 subgoal):\n 1. finite (R M s vs xs)", "then"], ["proof (chain)\npicking this:\n  R M s vs xs \\<subseteq> {vs @ xs' |xs'. prefix xs' xs}", "have \"R M s vs xs \\<subseteq> image (\\<lambda> xs' . vs @ xs') {xs' . prefix xs' xs}\""], ["proof (prove)\nusing this:\n  R M s vs xs \\<subseteq> {vs @ xs' |xs'. prefix xs' xs}\n\ngoal (1 subgoal):\n 1. R M s vs xs \\<subseteq> (@) vs ` {xs'. prefix xs' xs}", "by auto"], ["proof (state)\nthis:\n  R M s vs xs \\<subseteq> (@) vs ` {xs'. prefix xs' xs}\n\ngoal (1 subgoal):\n 1. finite (R M s vs xs)", "moreover"], ["proof (state)\nthis:\n  R M s vs xs \\<subseteq> (@) vs ` {xs'. prefix xs' xs}\n\ngoal (1 subgoal):\n 1. finite (R M s vs xs)", "have \"{xs' . prefix xs' xs} = {take n xs | n . n \\<le> length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs'. prefix xs' xs} = {take n xs |n. n \\<le> length xs}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {xs'. prefix xs' xs} \\<subseteq> {take n xs |n. n \\<le> length xs}\n 2. {take n xs |n. n \\<le> length xs} \\<subseteq> {xs'. prefix xs' xs}", "show \"{xs'. prefix xs' xs} \\<subseteq> {take n xs |n. n \\<le> length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs'. prefix xs' xs} \\<subseteq> {take n xs |n. n \\<le> length xs}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {xs'. prefix xs' xs} \\<Longrightarrow>\n       x \\<in> {take n xs |n. n \\<le> length xs}", "fix xs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {xs'. prefix xs' xs} \\<Longrightarrow>\n       x \\<in> {take n xs |n. n \\<le> length xs}", "assume \"xs' \\<in> {xs'. prefix xs' xs}\""], ["proof (state)\nthis:\n  xs' \\<in> {xs'. prefix xs' xs}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {xs'. prefix xs' xs} \\<Longrightarrow>\n       x \\<in> {take n xs |n. n \\<le> length xs}", "then"], ["proof (chain)\npicking this:\n  xs' \\<in> {xs'. prefix xs' xs}", "obtain zs' where \"xs' @ zs' = xs\""], ["proof (prove)\nusing this:\n  xs' \\<in> {xs'. prefix xs' xs}\n\ngoal (1 subgoal):\n 1. (\\<And>zs'. xs' @ zs' = xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) mem_Collect_eq prefixE)"], ["proof (state)\nthis:\n  xs' @ zs' = xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {xs'. prefix xs' xs} \\<Longrightarrow>\n       x \\<in> {take n xs |n. n \\<le> length xs}", "then"], ["proof (chain)\npicking this:\n  xs' @ zs' = xs", "obtain i where \"xs' = take i xs \\<and> i \\<le> length xs\""], ["proof (prove)\nusing this:\n  xs' @ zs' = xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        xs' = take i xs \\<and> i \\<le> length xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) append_eq_conv_conj le_cases take_all)"], ["proof (state)\nthis:\n  xs' = take i xs \\<and> i \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {xs'. prefix xs' xs} \\<Longrightarrow>\n       x \\<in> {take n xs |n. n \\<le> length xs}", "then"], ["proof (chain)\npicking this:\n  xs' = take i xs \\<and> i \\<le> length xs", "show \"xs' \\<in> {take n xs |n. n \\<le> length xs}\""], ["proof (prove)\nusing this:\n  xs' = take i xs \\<and> i \\<le> length xs\n\ngoal (1 subgoal):\n 1. xs' \\<in> {take n xs |n. n \\<le> length xs}", "by auto"], ["proof (state)\nthis:\n  xs' \\<in> {take n xs |n. n \\<le> length xs}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {xs'. prefix xs' xs} \\<subseteq> {take n xs |n. n \\<le> length xs}\n\ngoal (1 subgoal):\n 1. {take n xs |n. n \\<le> length xs} \\<subseteq> {xs'. prefix xs' xs}", "show \"{take n xs |n. n \\<le> length xs} \\<subseteq> {xs'. prefix xs' xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {take n xs |n. n \\<le> length xs} \\<subseteq> {xs'. prefix xs' xs}", "using take_is_prefix"], ["proof (prove)\nusing this:\n  prefix (take ?n ?xs) ?xs\n\ngoal (1 subgoal):\n 1. {take n xs |n. n \\<le> length xs} \\<subseteq> {xs'. prefix xs' xs}", "by force"], ["proof (state)\nthis:\n  {take n xs |n. n \\<le> length xs} \\<subseteq> {xs'. prefix xs' xs}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {xs'. prefix xs' xs} = {take n xs |n. n \\<le> length xs}\n\ngoal (1 subgoal):\n 1. finite (R M s vs xs)", "moreover"], ["proof (state)\nthis:\n  {xs'. prefix xs' xs} = {take n xs |n. n \\<le> length xs}\n\ngoal (1 subgoal):\n 1. finite (R M s vs xs)", "have \"finite {take n xs | n . n \\<le> length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {take n xs |n. n \\<le> length xs}", "by auto"], ["proof (state)\nthis:\n  finite {take n xs |n. n \\<le> length xs}\n\ngoal (1 subgoal):\n 1. finite (R M s vs xs)", "ultimately"], ["proof (chain)\npicking this:\n  R M s vs xs \\<subseteq> (@) vs ` {xs'. prefix xs' xs}\n  {xs'. prefix xs' xs} = {take n xs |n. n \\<le> length xs}\n  finite {take n xs |n. n \\<le> length xs}", "show ?thesis"], ["proof (prove)\nusing this:\n  R M s vs xs \\<subseteq> (@) vs ` {xs'. prefix xs' xs}\n  {xs'. prefix xs' xs} = {take n xs |n. n \\<le> length xs}\n  finite {take n xs |n. n \\<le> length xs}\n\ngoal (1 subgoal):\n 1. finite (R M s vs xs)", "by auto"], ["proof (state)\nthis:\n  finite (R M s vs xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_union_of_singletons :\n  assumes \"\\<forall> S \\<in> SS . (\\<exists> t . S = {t})\"\nshows \"card (\\<Union> SS) = card SS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> SS) = card SS", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union> SS) = card SS", "let ?f = \"\\<lambda> x . {x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union> SS) = card SS", "have \"bij_betw ?f (\\<Union> SS) SS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. {x}) (\\<Union> SS) SS", "unfolding bij_betw_def inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>\\<Union> SS.\n        \\<forall>y\\<in>\\<Union> SS.\n           {x} = {y} \\<longrightarrow> x = y) \\<and>\n    (\\<lambda>x. {x}) ` \\<Union> SS = SS", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>S\\<in>SS. \\<exists>t. S = {t}\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>\\<Union> SS.\n        \\<forall>y\\<in>\\<Union> SS.\n           {x} = {y} \\<longrightarrow> x = y) \\<and>\n    (\\<lambda>x. {x}) ` \\<Union> SS = SS", "by fastforce"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>x. {x}) (\\<Union> SS) SS\n\ngoal (1 subgoal):\n 1. card (\\<Union> SS) = card SS", "then"], ["proof (chain)\npicking this:\n  bij_betw (\\<lambda>x. {x}) (\\<Union> SS) SS", "show ?thesis"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>x. {x}) (\\<Union> SS) SS\n\ngoal (1 subgoal):\n 1. card (\\<Union> SS) = card SS", "using bij_betw_same_card"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>x. {x}) (\\<Union> SS) SS\n  bij_betw ?f ?A ?B \\<Longrightarrow> card ?A = card ?B\n\ngoal (1 subgoal):\n 1. card (\\<Union> SS) = card SS", "by blast"], ["proof (state)\nthis:\n  card (\\<Union> SS) = card SS\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_union_of_distinct :\n  assumes \"\\<forall> S1 \\<in> SS . \\<forall> S2 \\<in> SS . S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\"\n  and     \"finite SS\"\n  and     \"\\<forall> S \\<in> SS . f S \\<noteq> {}\"\nshows \"card (image f SS) = card SS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f ` SS) = card SS", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (f ` SS) = card SS", "from assms(2)"], ["proof (chain)\npicking this:\n  finite SS", "have \"\\<forall> S1 \\<in> SS . \\<forall> S2 \\<in> SS . S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n                      \\<Longrightarrow> \\<forall> S \\<in> SS . f S \\<noteq> {} \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  finite SS\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>S1\\<in>SS.\n                \\<forall>S2\\<in>SS. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n     \\<forall>S\\<in>SS. f S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> card (f ` SS) = card SS", "proof (induction SS)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>S1\\<in>{}.\n                \\<forall>S2\\<in>{}. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n     \\<forall>S\\<in>{}. f S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> card (f ` {}) = card {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "case empty"], ["proof (state)\nthis:\n  \\<forall>S1\\<in>{}.\n     \\<forall>S2\\<in>{}. S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n  \\<forall>S\\<in>{}. f S \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>S1\\<in>{}.\n                \\<forall>S2\\<in>{}. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n     \\<forall>S\\<in>{}. f S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> card (f ` {}) = card {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "then"], ["proof (chain)\npicking this:\n  \\<forall>S1\\<in>{}.\n     \\<forall>S2\\<in>{}. S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n  \\<forall>S\\<in>{}. f S \\<noteq> {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>S1\\<in>{}.\n     \\<forall>S2\\<in>{}. S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n  \\<forall>S\\<in>{}. f S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (f ` {}) = card {}", "by auto"], ["proof (state)\nthis:\n  card (f ` {}) = card {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<forall>S1\\<in>F.\n              \\<forall>S2\\<in>F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n   \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (f ` F) = card F\n  \\<forall>S1\\<in>insert x F.\n     \\<forall>S2\\<in>insert x F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n  \\<forall>S\\<in>insert x F. f S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<forall>S1\\<in>F.\n              \\<forall>S2\\<in>F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n   \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (f ` F) = card F\n  \\<forall>S1\\<in>insert x F.\n     \\<forall>S2\\<in>insert x F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n  \\<forall>S\\<in>insert x F. f S \\<noteq> {}", "have \"\\<not> (\\<exists> y \\<in> F . f y = f x)\""], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<forall>S1\\<in>F.\n              \\<forall>S2\\<in>F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n   \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (f ` F) = card F\n  \\<forall>S1\\<in>insert x F.\n     \\<forall>S2\\<in>insert x F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n  \\<forall>S\\<in>insert x F. f S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>F. f y = f x)", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<exists>y\\<in>F. f y = f x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>y\\<in>F. f y = f x)", "have \"f x \\<notin> image f F\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>y\\<in>F. f y = f x)\n\ngoal (1 subgoal):\n 1. f x \\<notin> f ` F", "by auto"], ["proof (state)\nthis:\n  f x \\<notin> f ` F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "then"], ["proof (chain)\npicking this:\n  f x \\<notin> f ` F", "have \"card (image f (insert x F)) = Suc (card (image f F))\""], ["proof (prove)\nusing this:\n  f x \\<notin> f ` F\n\ngoal (1 subgoal):\n 1. card (f ` insert x F) = Suc (card (f ` F))", "using insert"], ["proof (prove)\nusing this:\n  f x \\<notin> f ` F\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<forall>S1\\<in>F.\n              \\<forall>S2\\<in>F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n   \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (f ` F) = card F\n  \\<forall>S1\\<in>insert x F.\n     \\<forall>S2\\<in>insert x F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n  \\<forall>S\\<in>insert x F. f S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (f ` insert x F) = Suc (card (f ` F))", "by auto"], ["proof (state)\nthis:\n  card (f ` insert x F) = Suc (card (f ` F))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "moreover"], ["proof (state)\nthis:\n  card (f ` insert x F) = Suc (card (f ` F))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "have \"card (f ` F) = card F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f ` F) = card F", "using insert"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<forall>S1\\<in>F.\n              \\<forall>S2\\<in>F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n   \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (f ` F) = card F\n  \\<forall>S1\\<in>insert x F.\n     \\<forall>S2\\<in>insert x F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n  \\<forall>S\\<in>insert x F. f S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (f ` F) = card F", "by auto"], ["proof (state)\nthis:\n  card (f ` F) = card F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "moreover"], ["proof (state)\nthis:\n  card (f ` F) = card F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "have \"card (insert x F) = Suc (card F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert x F) = Suc (card F)", "using insert"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  \\<lbrakk>\\<forall>S1\\<in>F.\n              \\<forall>S2\\<in>F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n   \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (f ` F) = card F\n  \\<forall>S1\\<in>insert x F.\n     \\<forall>S2\\<in>insert x F. S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n  \\<forall>S\\<in>insert x F. f S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (insert x F) = Suc (card F)", "by auto"], ["proof (state)\nthis:\n  card (insert x F) = Suc (card F)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<forall>S1\\<in>F.\n                    \\<forall>S2\\<in>F.\n                       S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n         \\<forall>S\\<in>F. f S \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> card (f ` F) = card F;\n        \\<forall>S1\\<in>insert x F.\n           \\<forall>S2\\<in>insert x F.\n              S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n        \\<forall>S\\<in>insert x F. f S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> card (f ` insert x F) = card (insert x F)", "ultimately"], ["proof (chain)\npicking this:\n  card (f ` insert x F) = Suc (card (f ` F))\n  card (f ` F) = card F\n  card (insert x F) = Suc (card F)", "show ?case"], ["proof (prove)\nusing this:\n  card (f ` insert x F) = Suc (card (f ` F))\n  card (f ` F) = card F\n  card (insert x F) = Suc (card F)\n\ngoal (1 subgoal):\n 1. card (f ` insert x F) = card (insert x F)", "by simp"], ["proof (state)\nthis:\n  card (f ` insert x F) = card (insert x F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>S1\\<in>SS.\n              \\<forall>S2\\<in>SS. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n   \\<forall>S\\<in>SS. f S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (f ` SS) = card SS\n\ngoal (1 subgoal):\n 1. card (f ` SS) = card SS", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>S1\\<in>SS.\n              \\<forall>S2\\<in>SS. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n   \\<forall>S\\<in>SS. f S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (f ` SS) = card SS", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>S1\\<in>SS.\n              \\<forall>S2\\<in>SS. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n   \\<forall>S\\<in>SS. f S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (f ` SS) = card SS\n\ngoal (1 subgoal):\n 1. card (f ` SS) = card SS", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>S1\\<in>SS.\n              \\<forall>S2\\<in>SS. S1 = S2 \\<or> f S1 \\<inter> f S2 = {};\n   \\<forall>S\\<in>SS. f S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (f ` SS) = card SS\n  \\<forall>S1\\<in>SS.\n     \\<forall>S2\\<in>SS. S1 = S2 \\<or> f S1 \\<inter> f S2 = {}\n  finite SS\n  \\<forall>S\\<in>SS. f S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (f ` SS) = card SS", "by simp"], ["proof (state)\nthis:\n  card (f ` SS) = card SS\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_count :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"s \\<in> nodes M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"distinct (states (xs || tr) (q2,q1))\"\nshows \"card (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))) = card (R M2 s vs xs)\"\n  \\<comment> \\<open>each sequence in the set calculated by R reaches a different state in M1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "proof -\n\n  \\<comment> \\<open>Proof sketch:\n       - states of PM reached by the sequences calculated by R can differ only in their second value\n       - the sequences in the set calculated by R reach different states in PM due to distinctness\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "have obs_PM : \"observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable PM", "using observable_productF assms(2) assms(3) assms(7)"], ["proof (prove)\nusing this:\n  \\<lbrakk>observable ?M1.0; observable ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> observable ?PM\n  observable M1\n  observable M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. observable PM", "by blast"], ["proof (state)\nthis:\n  observable PM\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "have state_component_2 : \"\\<forall> io \\<in> (R M2 s vs xs) . io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "fix io"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "assume \"io \\<in> R M2 s vs xs\""], ["proof (state)\nthis:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "then"], ["proof (chain)\npicking this:\n  io \\<in> R M2 s vs xs", "have \"s \\<in> io_targets M2 (initial M2) io\""], ["proof (prove)\nusing this:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. s \\<in> io_targets M2 (initial M2) io", "by auto"], ["proof (state)\nthis:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "moreover"], ["proof (state)\nthis:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "have \"io \\<in> language_state M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> L M2", "using calculation"], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. io \\<in> L M2", "by auto"], ["proof (state)\nthis:\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2", "show \"io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "using assms(3) io_targets_observable_singleton_ex"], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2\n  observable M2\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q2. io_targets ?M ?q1.0 ?io = {q2}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "by (metis singletonD)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {s}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "moreover"], ["proof (state)\nthis:\n  \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "have \"\\<forall> io \\<in> R M2 s vs xs . io_targets PM (initial PM) io\n                    = io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>R M2 s vs xs.\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "fix io"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "assume io_assm : \"io \\<in> R M2 s vs xs\""], ["proof (state)\nthis:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<in> R M2 s vs xs", "have io_prefix : \"prefix io (vs @ xs)\""], ["proof (prove)\nusing this:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. prefix io (vs @ xs)", "by auto"], ["proof (state)\nthis:\n  prefix io (vs @ xs)\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  prefix io (vs @ xs)", "have io_lang_subs : \"io \\<in> L M1 \\<and> io \\<in> L M2\""], ["proof (prove)\nusing this:\n  prefix io (vs @ xs)\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<and> io \\<in> L M2", "using assms(1)"], ["proof (prove)\nusing this:\n  prefix io (vs @ xs)\n  vs @ xs \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<and> io \\<in> L M2", "unfolding prefix_def"], ["proof (prove)\nusing this:\n  \\<exists>zs. vs @ xs = io @ zs\n  vs @ xs \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<and> io \\<in> L M2", "by (metis IntE language_state language_state_split)"], ["proof (state)\nthis:\n  io \\<in> L M1 \\<and> io \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M1 \\<and> io \\<in> L M2", "have io_lang_inter : \"io \\<in> L M1 \\<inter> L M2\""], ["proof (prove)\nusing this:\n  io \\<in> L M1 \\<and> io \\<in> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<inter> L M2", "by simp"], ["proof (state)\nthis:\n  io \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M1 \\<inter> L M2", "have io_lang_pm : \"io \\<in> L PM\""], ["proof (prove)\nusing this:\n  io \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L PM", "using productF_language assms"], ["proof (prove)\nusing this:\n  io \\<in> L M1 \\<inter> L M2\n  \\<lbrakk>productF ?A ?B ?FAIL ?AB; well_formed ?A; well_formed ?B;\n   ?io \\<in> L ?A \\<inter> L ?B\\<rbrakk>\n  \\<Longrightarrow> ?io \\<in> L ?AB\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n\ngoal (1 subgoal):\n 1. io \\<in> L PM", "by blast"], ["proof (state)\nthis:\n  io \\<in> L PM\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "moreover"], ["proof (state)\nthis:\n  io \\<in> L PM\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "obtain p2 p1 where \"(p2,p1) \\<in> io_targets PM (initial PM) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 p1.\n        (p2, p1) \\<in> io_targets PM (initial PM) io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(2) assms(3) assms(7) calculation insert_absorb insert_ident insert_not_empty\n          io_targets_observable_singleton_ob observable_productF singleton_insert_inj_eq subrelI)"], ["proof (state)\nthis:\n  (p2, p1) \\<in> io_targets PM (initial PM) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "ultimately"], ["proof (chain)\npicking this:\n  io \\<in> L PM\n  (p2, p1) \\<in> io_targets PM (initial PM) io", "have targets_pm : \"io_targets PM (initial PM) io = {(p2,p1)}\""], ["proof (prove)\nusing this:\n  io \\<in> L PM\n  (p2, p1) \\<in> io_targets PM (initial PM) io\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {(p2, p1)}", "using assms io_targets_observable_singleton_ex singletonD"], ["proof (prove)\nusing this:\n  io \\<in> L PM\n  (p2, p1) \\<in> io_targets PM (initial PM) io\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q2. io_targets ?M ?q1.0 ?io = {q2}\n  ?b \\<in> {?a} \\<Longrightarrow> ?b = ?a\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {(p2, p1)}", "by (metis observable_productF)"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io = {(p2, p1)}\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io_targets PM (initial PM) io = {(p2, p1)}", "obtain trP where trP_def : \"target (io || trP) (initial PM) = (p2,p1)\n                                      \\<and> path PM (io || trP) (initial PM)\n                                      \\<and> length io = length trP\""], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io = {(p2, p1)}\n\ngoal (1 subgoal):\n 1. (\\<And>trP.\n        target (io || trP) (initial PM) = (p2, p1) \\<and>\n        path PM (io || trP) (initial PM) \\<and>\n        length io = length trP \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>trP.\n                target (io || trP) (initial PM) = (p2, p1) \\<and>\n                path PM (io || trP) (initial PM) \\<and>\n                length io = length trP \\<Longrightarrow>\n                thesis;\n     io_targets PM (initial PM) io = {(p2, p1)}\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume a1: \"\\<And>trP. target (io || trP) (initial PM) = (p2, p1)\n                            \\<and> path PM (io || trP) (initial PM)\n                            \\<and> length io = length trP \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  target (io || ?trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || ?trP) (initial PM) \\<and>\n  length io = length ?trP \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>trP.\n                target (io || trP) (initial PM) = (p2, p1) \\<and>\n                path PM (io || trP) (initial PM) \\<and>\n                length io = length trP \\<Longrightarrow>\n                thesis;\n     io_targets PM (initial PM) io = {(p2, p1)}\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<exists>ps. target (io || ps) (initial PM) = (p2, p1)\n                    \\<and> path PM (io || ps) (initial PM) \\<and> length io = length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ps.\n       target (io || ps) (initial PM) = (p2, p1) \\<and>\n       path PM (io || ps) (initial PM) \\<and> length io = length ps", "using \\<open>(p2, p1) \\<in> io_targets PM (initial PM) io\\<close>"], ["proof (prove)\nusing this:\n  (p2, p1) \\<in> io_targets PM (initial PM) io\n\ngoal (1 subgoal):\n 1. \\<exists>ps.\n       target (io || ps) (initial PM) = (p2, p1) \\<and>\n       path PM (io || ps) (initial PM) \\<and> length io = length ps", "by auto"], ["proof (state)\nthis:\n  \\<exists>ps.\n     target (io || ps) (initial PM) = (p2, p1) \\<and>\n     path PM (io || ps) (initial PM) \\<and> length io = length ps\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>trP.\n                target (io || trP) (initial PM) = (p2, p1) \\<and>\n                path PM (io || trP) (initial PM) \\<and>\n                length io = length trP \\<Longrightarrow>\n                thesis;\n     io_targets PM (initial PM) io = {(p2, p1)}\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>ps.\n     target (io || ps) (initial PM) = (p2, p1) \\<and>\n     path PM (io || ps) (initial PM) \\<and> length io = length ps", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ps.\n     target (io || ps) (initial PM) = (p2, p1) \\<and>\n     path PM (io || ps) (initial PM) \\<and> length io = length ps\n\ngoal (1 subgoal):\n 1. thesis", "using a1"], ["proof (prove)\nusing this:\n  \\<exists>ps.\n     target (io || ps) (initial PM) = (p2, p1) \\<and>\n     path PM (io || ps) (initial PM) \\<and> length io = length ps\n  target (io || ?trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || ?trP) (initial PM) \\<and>\n  length io = length ?trP \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP", "have trP_unique : \"{ tr . path PM (io || tr) (initial PM) \\<and> length io = length tr }\n                              = { trP }\""], ["proof (prove)\nusing this:\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n\ngoal (1 subgoal):\n 1. {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} =\n    {trP}", "using observable_productF observable_path_unique_ex[of PM io \"initial PM\"]\n              io_lang_pm assms(2) assms(3) assms(7)"], ["proof (prove)\nusing this:\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n  \\<lbrakk>observable ?M1.0; observable ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> observable ?PM\n  \\<lbrakk>observable PM; io \\<in> L PM;\n   \\<And>tr.\n      {t. path PM (io || t) (initial PM) \\<and> length io = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  io \\<in> L PM\n  observable M1\n  observable M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} =\n    {trP}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>target (io || trP) (initial PM) = (p2, p1) \\<and>\n             path PM (io || trP) (initial PM) \\<and> length io = length trP;\n     \\<And>M1 M2 FAIL PM.\n        \\<lbrakk>observable M1; observable M2;\n         productF M2 M1 FAIL PM\\<rbrakk>\n        \\<Longrightarrow> observable PM;\n     \\<And>thesis.\n        \\<lbrakk>observable PM; io \\<in> L PM;\n         \\<And>tr.\n            {t. path PM (io || t) (initial PM) \\<and>\n                length io = length t} =\n            {tr} \\<Longrightarrow>\n            thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     io \\<in> L PM; observable M1; observable M2;\n     productF M2 M1 FAIL PM\\<rbrakk>\n    \\<Longrightarrow> {tr.\n                       path PM (io || tr) (initial PM) \\<and>\n                       length io = length tr} =\n                      {trP}", "obtain pps :: \"('d \\<times> 'c) list\" where\n          f1: \"{ps. path PM (io || ps) (initial PM) \\<and> length io = length ps} = {pps}\n                \\<or> \\<not> observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pps.\n        {ps. path PM (io || ps) (initial PM) \\<and> length io = length ps} =\n        {pps} \\<or>\n        \\<not> observable PM \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types) \\<open>\\<And>thesis. \\<lbrakk>observable PM; io \\<in> L PM; \\<And>tr.\n                                          {t. path PM (io || t) (initial PM)\n                                          \\<and> length io = length t} = {tr} \\<Longrightarrow> thesis\\<rbrakk> \\<Longrightarrow> thesis\\<close>\n              io_lang_pm)"], ["proof (state)\nthis:\n  {ps. path PM (io || ps) (initial PM) \\<and> length io = length ps} =\n  {pps} \\<or>\n  \\<not> observable PM\n\ngoal (1 subgoal):\n 1. \\<lbrakk>target (io || trP) (initial PM) = (p2, p1) \\<and>\n             path PM (io || trP) (initial PM) \\<and> length io = length trP;\n     \\<And>M1 M2 FAIL PM.\n        \\<lbrakk>observable M1; observable M2;\n         productF M2 M1 FAIL PM\\<rbrakk>\n        \\<Longrightarrow> observable PM;\n     \\<And>thesis.\n        \\<lbrakk>observable PM; io \\<in> L PM;\n         \\<And>tr.\n            {t. path PM (io || t) (initial PM) \\<and>\n                length io = length t} =\n            {tr} \\<Longrightarrow>\n            thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     io \\<in> L PM; observable M1; observable M2;\n     productF M2 M1 FAIL PM\\<rbrakk>\n    \\<Longrightarrow> {tr.\n                       path PM (io || tr) (initial PM) \\<and>\n                       length io = length tr} =\n                      {trP}", "have f2: \"observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable PM", "by (meson \\<open>observable M1\\<close> \\<open>observable M2\\<close> \\<open>productF M2 M1 FAIL PM\\<close> observable_productF)"], ["proof (state)\nthis:\n  observable PM\n\ngoal (1 subgoal):\n 1. \\<lbrakk>target (io || trP) (initial PM) = (p2, p1) \\<and>\n             path PM (io || trP) (initial PM) \\<and> length io = length trP;\n     \\<And>M1 M2 FAIL PM.\n        \\<lbrakk>observable M1; observable M2;\n         productF M2 M1 FAIL PM\\<rbrakk>\n        \\<Longrightarrow> observable PM;\n     \\<And>thesis.\n        \\<lbrakk>observable PM; io \\<in> L PM;\n         \\<And>tr.\n            {t. path PM (io || t) (initial PM) \\<and>\n                length io = length t} =\n            {tr} \\<Longrightarrow>\n            thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     io \\<in> L PM; observable M1; observable M2;\n     productF M2 M1 FAIL PM\\<rbrakk>\n    \\<Longrightarrow> {tr.\n                       path PM (io || tr) (initial PM) \\<and>\n                       length io = length tr} =\n                      {trP}", "then"], ["proof (chain)\npicking this:\n  observable PM", "have \"trP \\<in> {pps}\""], ["proof (prove)\nusing this:\n  observable PM\n\ngoal (1 subgoal):\n 1. trP \\<in> {pps}", "using f1 trP_def"], ["proof (prove)\nusing this:\n  observable PM\n  {ps. path PM (io || ps) (initial PM) \\<and> length io = length ps} =\n  {pps} \\<or>\n  \\<not> observable PM\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n\ngoal (1 subgoal):\n 1. trP \\<in> {pps}", "by blast"], ["proof (state)\nthis:\n  trP \\<in> {pps}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>target (io || trP) (initial PM) = (p2, p1) \\<and>\n             path PM (io || trP) (initial PM) \\<and> length io = length trP;\n     \\<And>M1 M2 FAIL PM.\n        \\<lbrakk>observable M1; observable M2;\n         productF M2 M1 FAIL PM\\<rbrakk>\n        \\<Longrightarrow> observable PM;\n     \\<And>thesis.\n        \\<lbrakk>observable PM; io \\<in> L PM;\n         \\<And>tr.\n            {t. path PM (io || t) (initial PM) \\<and>\n                length io = length t} =\n            {tr} \\<Longrightarrow>\n            thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     io \\<in> L PM; observable M1; observable M2;\n     productF M2 M1 FAIL PM\\<rbrakk>\n    \\<Longrightarrow> {tr.\n                       path PM (io || tr) (initial PM) \\<and>\n                       length io = length tr} =\n                      {trP}", "then"], ["proof (chain)\npicking this:\n  trP \\<in> {pps}", "show ?thesis"], ["proof (prove)\nusing this:\n  trP \\<in> {pps}\n\ngoal (1 subgoal):\n 1. {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} =\n    {trP}", "using f2 f1"], ["proof (prove)\nusing this:\n  trP \\<in> {pps}\n  observable PM\n  {ps. path PM (io || ps) (initial PM) \\<and> length io = length ps} =\n  {pps} \\<or>\n  \\<not> observable PM\n\ngoal (1 subgoal):\n 1. {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} =\n    {trP}", "by force"], ["proof (state)\nthis:\n  {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} = {trP}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} = {trP}\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "obtain trIO2 where trIO2_def : \"{tr . path M2 (io||tr) (initial M2) \\<and> length io = length tr}\n                                    = { trIO2 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trIO2.\n        {tr. path M2 (io || tr) (initial M2) \\<and> length io = length tr} =\n        {trIO2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using observable_path_unique_ex[of M2 io \"initial M2\"] io_lang_subs assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>observable M2; io \\<in> L M2;\n   \\<And>tr.\n      {t. path M2 (io || t) (initial M2) \\<and> length io = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  io \\<in> L M1 \\<and> io \\<in> L M2\n  observable M2\n\ngoal (1 subgoal):\n 1. (\\<And>trIO2.\n        {tr. path M2 (io || tr) (initial M2) \\<and> length io = length tr} =\n        {trIO2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  {tr. path M2 (io || tr) (initial M2) \\<and> length io = length tr} =\n  {trIO2}\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "obtain trIO1 where trIO1_def : \"{tr . path M1 (io||tr) (initial M1) \\<and> length io = length tr}\n                                    = { trIO1 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trIO1.\n        {tr. path M1 (io || tr) (initial M1) \\<and> length io = length tr} =\n        {trIO1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using observable_path_unique_ex[of M1 io \"initial M1\"] io_lang_subs assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>observable M1; io \\<in> L M1;\n   \\<And>tr.\n      {t. path M1 (io || t) (initial M1) \\<and> length io = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  io \\<in> L M1 \\<and> io \\<in> L M2\n  observable M1\n\ngoal (1 subgoal):\n 1. (\\<And>trIO1.\n        {tr. path M1 (io || tr) (initial M1) \\<and> length io = length tr} =\n        {trIO1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  {tr. path M1 (io || tr) (initial M1) \\<and> length io = length tr} =\n  {trIO1}\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"path PM (io || trIO2 || trIO1) (initial M2, initial M1)\n          \\<and> length io = length trIO2\n          \\<and> length trIO2 = length trIO1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "have f1: \"path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2", "using trIO2_def"], ["proof (prove)\nusing this:\n  {tr. path M2 (io || tr) (initial M2) \\<and> length io = length tr} =\n  {trIO2}\n\ngoal (1 subgoal):\n 1. path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2", "by auto"], ["proof (state)\nthis:\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "have f2: \"path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "using trIO1_def"], ["proof (prove)\nusing this:\n  {tr. path M1 (io || tr) (initial M1) \\<and> length io = length tr} =\n  {trIO1}\n\ngoal (1 subgoal):\n 1. path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "by auto"], ["proof (state)\nthis:\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "then"], ["proof (chain)\npicking this:\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "have \"length trIO2 = length trIO1\""], ["proof (prove)\nusing this:\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n\ngoal (1 subgoal):\n 1. length trIO2 = length trIO1", "using f1"], ["proof (prove)\nusing this:\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\n\ngoal (1 subgoal):\n 1. length trIO2 = length trIO1", "by presburger"], ["proof (state)\nthis:\n  length trIO2 = length trIO1\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "then"], ["proof (chain)\npicking this:\n  length trIO2 = length trIO1", "show ?thesis"], ["proof (prove)\nusing this:\n  length trIO2 = length trIO1\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "using f2 f1 assms(4) assms(5) assms(7)"], ["proof (prove)\nusing this:\n  length trIO2 = length trIO1\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "by blast"], ["proof (state)\nthis:\n  path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1", "have trP_split : \"path PM (io || trIO2 || trIO1) (initial PM)\n                            \\<and> length io = length trIO2\n                            \\<and> length trIO2 = length trIO1\""], ["proof (prove)\nusing this:\n  path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "using assms(7)"], ["proof (prove)\nusing this:\n  path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "by auto"], ["proof (state)\nthis:\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1", "have trP_zip : \"trIO2 || trIO1 = trP\""], ["proof (prove)\nusing this:\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n\ngoal (1 subgoal):\n 1. trIO2 || trIO1 = trP", "using trP_def trP_unique"], ["proof (prove)\nusing this:\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n  {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} = {trP}\n\ngoal (1 subgoal):\n 1. trIO2 || trIO1 = trP", "using length_zip"], ["proof (prove)\nusing this:\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n  {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} = {trP}\n  length (?xs || ?ys) = min (length ?xs) (length ?ys)\n\ngoal (1 subgoal):\n 1. trIO2 || trIO1 = trP", "by fastforce"], ["proof (state)\nthis:\n  trIO2 || trIO1 = trP\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"target (io || trIO2) (initial M2) = p2\n          \\<and> path M2 (io || trIO2) (initial M2)\n          \\<and> length io = length trIO2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || trIO2) (initial M2) = p2 \\<and>\n    path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2", "using trP_zip trP_split assms(7) trP_def trIO2_def"], ["proof (prove)\nusing this:\n  trIO2 || trIO1 = trP\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n  productF M2 M1 FAIL PM\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n  {tr. path M2 (io || tr) (initial M2) \\<and> length io = length tr} =\n  {trIO2}\n\ngoal (1 subgoal):\n 1. target (io || trIO2) (initial M2) = p2 \\<and>\n    path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2", "by auto"], ["proof (state)\nthis:\n  target (io || trIO2) (initial M2) = p2 \\<and>\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  target (io || trIO2) (initial M2) = p2 \\<and>\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2", "have \"p2 \\<in> io_targets M2 (initial M2) io\""], ["proof (prove)\nusing this:\n  target (io || trIO2) (initial M2) = p2 \\<and>\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\n\ngoal (1 subgoal):\n 1. p2 \\<in> io_targets M2 (initial M2) io", "by auto"], ["proof (state)\nthis:\n  p2 \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  p2 \\<in> io_targets M2 (initial M2) io", "have targets_2 : \"io_targets M2 (initial M2) io = {p2}\""], ["proof (prove)\nusing this:\n  p2 \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {p2}", "by (metis state_component_2 io_assm singletonD)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {p2}\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"target (io || trIO1) (initial M1) = p1\n            \\<and> path M1 (io || trIO1) (initial M1)\n            \\<and> length io = length trIO1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || trIO1) (initial M1) = p1 \\<and>\n    path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "using trP_zip trP_split assms(7) trP_def trIO1_def"], ["proof (prove)\nusing this:\n  trIO2 || trIO1 = trP\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n  productF M2 M1 FAIL PM\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n  {tr. path M1 (io || tr) (initial M1) \\<and> length io = length tr} =\n  {trIO1}\n\ngoal (1 subgoal):\n 1. target (io || trIO1) (initial M1) = p1 \\<and>\n    path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "by auto"], ["proof (state)\nthis:\n  target (io || trIO1) (initial M1) = p1 \\<and>\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  target (io || trIO1) (initial M1) = p1 \\<and>\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "have \"p1 \\<in> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  target (io || trIO1) (initial M1) = p1 \\<and>\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n\ngoal (1 subgoal):\n 1. p1 \\<in> io_targets M1 (initial M1) io", "by auto"], ["proof (state)\nthis:\n  p1 \\<in> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  p1 \\<in> io_targets M1 (initial M1) io", "have targets_1 : \"io_targets M1 (initial M1) io = {p1}\""], ["proof (prove)\nusing this:\n  p1 \\<in> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io = {p1}", "by (metis io_lang_subs assms(2) io_targets_observable_singleton_ex singletonD)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) io = {p1}\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io = {(p2,p1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n    {(p2, p1)}", "using targets_2 targets_1"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io = {p2}\n  io_targets M1 (initial M1) io = {p1}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n    {(p2, p1)}", "by simp"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n  {(p2, p1)}\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n  {(p2, p1)}", "show \"io_targets PM (initial PM) io\n                = io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n  {(p2, p1)}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "using targets_pm"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n  {(p2, p1)}\n  io_targets PM (initial PM) io = {(p2, p1)}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "by simp"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>io\\<in>R M2 s vs xs.\n     io_targets PM (initial PM) io =\n     io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}\n  \\<forall>io\\<in>R M2 s vs xs.\n     io_targets PM (initial PM) io =\n     io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have state_components : \"\\<forall> io \\<in> R M2 s vs xs . io_targets PM (initial PM) io\n                                      = {s} \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}\n  \\<forall>io\\<in>R M2 s vs xs.\n     io_targets PM (initial PM) io =\n     io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>R M2 s vs xs.\n       io_targets PM (initial PM) io =\n       {s} \\<times> io_targets M1 (initial M1) io", "by auto"], ["proof (state)\nthis:\n  \\<forall>io\\<in>R M2 s vs xs.\n     io_targets PM (initial PM) io =\n     {s} \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>io\\<in>R M2 s vs xs.\n     io_targets PM (initial PM) io =\n     {s} \\<times> io_targets M1 (initial M1) io", "have \"\\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs))\n              = \\<Union> (image (\\<lambda> io . {s} \\<times> io_targets M1 (initial M1) io) (R M2 s vs xs))\""], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>R M2 s vs xs.\n     io_targets PM (initial PM) io =\n     {s} \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` R M2 s vs xs) =\n    (\\<Union>io\\<in>R M2 s vs xs.\n        {s} \\<times> io_targets M1 (initial M1) io)", "by auto"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` R M2 s vs xs) =\n  (\\<Union>io\\<in>R M2 s vs xs. {s} \\<times> io_targets M1 (initial M1) io)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "then"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets PM (initial PM) ` R M2 s vs xs) =\n  (\\<Union>io\\<in>R M2 s vs xs. {s} \\<times> io_targets M1 (initial M1) io)", "have \"\\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs))\n              = {s} \\<times> \\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))\""], ["proof (prove)\nusing this:\n  \\<Union> (io_targets PM (initial PM) ` R M2 s vs xs) =\n  (\\<Union>io\\<in>R M2 s vs xs. {s} \\<times> io_targets M1 (initial M1) io)\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` R M2 s vs xs) =\n    {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)", "by auto"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` R M2 s vs xs) =\n  {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "then"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets PM (initial PM) ` R M2 s vs xs) =\n  {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)", "have \"card (\\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs)))\n              = card (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))\""], ["proof (prove)\nusing this:\n  \\<Union> (io_targets PM (initial PM) ` R M2 s vs xs) =\n  {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n    card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))", "by (metis (no_types) card_cartesian_product_singleton)"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "moreover"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "have \"card (\\<Union> (image (io_targets PM (initial PM)) (R M2 s vs xs)))\n                  = card (R M2 s vs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "assume assm : \"card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs) ) \\<noteq> card (R M2 s vs xs)\""], ["proof (state)\nthis:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n  card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"\\<forall> io \\<in> R M2 s vs xs . io \\<in> L PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>R M2 s vs xs. io \\<in> L PM", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io. io \\<in> R M2 s vs xs \\<Longrightarrow> io \\<in> L PM", "fix io"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io. io \\<in> R M2 s vs xs \\<Longrightarrow> io \\<in> L PM", "assume io_assm : \"io \\<in> R M2 s vs xs\""], ["proof (state)\nthis:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. \\<And>io. io \\<in> R M2 s vs xs \\<Longrightarrow> io \\<in> L PM", "then"], ["proof (chain)\npicking this:\n  io \\<in> R M2 s vs xs", "have \"prefix io (vs @ xs)\""], ["proof (prove)\nusing this:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. prefix io (vs @ xs)", "by auto"], ["proof (state)\nthis:\n  prefix io (vs @ xs)\n\ngoal (1 subgoal):\n 1. \\<And>io. io \\<in> R M2 s vs xs \\<Longrightarrow> io \\<in> L PM", "then"], ["proof (chain)\npicking this:\n  prefix io (vs @ xs)", "have \"io \\<in> L M1 \\<and> io \\<in> L M2\""], ["proof (prove)\nusing this:\n  prefix io (vs @ xs)\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<and> io \\<in> L M2", "using assms(1)"], ["proof (prove)\nusing this:\n  prefix io (vs @ xs)\n  vs @ xs \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<and> io \\<in> L M2", "unfolding prefix_def"], ["proof (prove)\nusing this:\n  \\<exists>zs. vs @ xs = io @ zs\n  vs @ xs \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<and> io \\<in> L M2", "by (metis IntE language_state language_state_split)"], ["proof (state)\nthis:\n  io \\<in> L M1 \\<and> io \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<And>io. io \\<in> R M2 s vs xs \\<Longrightarrow> io \\<in> L PM", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M1 \\<and> io \\<in> L M2", "show \"io \\<in> L PM\""], ["proof (prove)\nusing this:\n  io \\<in> L M1 \\<and> io \\<in> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L PM", "using productF_language assms"], ["proof (prove)\nusing this:\n  io \\<in> L M1 \\<and> io \\<in> L M2\n  \\<lbrakk>productF ?A ?B ?FAIL ?AB; well_formed ?A; well_formed ?B;\n   ?io \\<in> L ?A \\<inter> L ?B\\<rbrakk>\n  \\<Longrightarrow> ?io \\<in> L ?AB\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n\ngoal (1 subgoal):\n 1. io \\<in> L PM", "by blast"], ["proof (state)\nthis:\n  io \\<in> L PM\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>io\\<in>R M2 s vs xs. io \\<in> L PM\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>io\\<in>R M2 s vs xs. io \\<in> L PM", "have singletons : \"\\<forall> io \\<in> R M2 s vs xs . (\\<exists> t . io_targets PM (initial PM) io = {t})\""], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>R M2 s vs xs. io \\<in> L PM\n\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>R M2 s vs xs.\n       \\<exists>t. io_targets PM (initial PM) io = {t}", "using io_targets_observable_singleton_ex observable_productF assms"], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>R M2 s vs xs. io \\<in> L PM\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q2. io_targets ?M ?q1.0 ?io = {q2}\n  \\<lbrakk>observable ?M1.0; observable ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> observable ?PM\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>R M2 s vs xs.\n       \\<exists>t. io_targets PM (initial PM) io = {t}", "by metis"], ["proof (state)\nthis:\n  \\<forall>io\\<in>R M2 s vs xs.\n     \\<exists>t. io_targets PM (initial PM) io = {t}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>io\\<in>R M2 s vs xs.\n     \\<exists>t. io_targets PM (initial PM) io = {t}", "have card_targets : \"card (\\<Union>(io_targets PM (initial PM) ` R M2 s vs xs))\n                              = card (image (io_targets PM (initial PM)) (R M2 s vs xs))\""], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>R M2 s vs xs.\n     \\<exists>t. io_targets PM (initial PM) io = {t}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n    card (io_targets PM (initial PM) ` R M2 s vs xs)", "using finite_R card_union_of_singletons\n            [of \"image (io_targets PM (initial PM)) (R M2 s vs xs)\"]"], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>R M2 s vs xs.\n     \\<exists>t. io_targets PM (initial PM) io = {t}\n  finite (R ?M ?s ?vs ?xs)\n  \\<forall>S\\<in>io_targets PM (initial PM) ` R M2 s vs xs.\n     \\<exists>t. S = {t} \\<Longrightarrow>\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (io_targets PM (initial PM) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n    card (io_targets PM (initial PM) ` R M2 s vs xs)", "by simp"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (io_targets PM (initial PM) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (io_targets PM (initial PM) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"card (image (io_targets PM (initial PM)) (R M2 s vs xs)) \\<le> card (R M2 s vs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (io_targets PM (initial PM) ` R M2 s vs xs)\n    \\<le> card (R M2 s vs xs)", "using finite_R"], ["proof (prove)\nusing this:\n  finite (R ?M ?s ?vs ?xs)\n\ngoal (1 subgoal):\n 1. card (io_targets PM (initial PM) ` R M2 s vs xs)\n    \\<le> card (R M2 s vs xs)", "by (metis card_image_le)"], ["proof (state)\nthis:\n  card (io_targets PM (initial PM) ` R M2 s vs xs) \\<le> card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (io_targets PM (initial PM) ` R M2 s vs xs)\n  card (io_targets PM (initial PM) ` R M2 s vs xs) \\<le> card (R M2 s vs xs)", "have card_le : \"card (\\<Union>(io_targets PM (initial PM) ` R M2 s vs xs))\n                                < card (R M2 s vs xs)\""], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (io_targets PM (initial PM) ` R M2 s vs xs)\n  card (io_targets PM (initial PM) ` R M2 s vs xs) \\<le> card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs))\n    < card (R M2 s vs xs)", "using assm"], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (io_targets PM (initial PM) ` R M2 s vs xs)\n  card (io_targets PM (initial PM) ` R M2 s vs xs) \\<le> card (R M2 s vs xs)\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n  card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs))\n    < card (R M2 s vs xs)", "by linarith"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs))\n  < card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"\\<exists> io1 \\<in> (R M2 s vs xs) . \\<exists> io2 \\<in> (R M2 s vs xs) . io1 \\<noteq> io2\n            \\<and> io_targets PM (initial PM) io1 \\<inter> io_targets PM (initial PM) io2 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>io1\\<in>R M2 s vs xs.\n       \\<exists>io2\\<in>R M2 s vs xs.\n          io1 \\<noteq> io2 \\<and>\n          io_targets PM (initial PM) io1 \\<inter>\n          io_targets PM (initial PM) io2 \\<noteq>\n          {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>io1\\<in>R M2 s vs xs.\n               \\<exists>io2\\<in>R M2 s vs xs.\n                  io1 \\<noteq> io2 \\<and>\n                  io_targets PM (initial PM) io1 \\<inter>\n                  io_targets PM (initial PM) io2 \\<noteq>\n                  {}) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>io1\\<in>R M2 s vs xs. \\<exists>io2\\<in>R M2 s vs xs. io1 \\<noteq> io2\n                  \\<and> io_targets PM (initial PM) io1 \\<inter> io_targets PM (initial PM) io2 \\<noteq> {})\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>io1\\<in>R M2 s vs xs.\n             \\<exists>io2\\<in>R M2 s vs xs.\n                io1 \\<noteq> io2 \\<and>\n                io_targets PM (initial PM) io1 \\<inter>\n                io_targets PM (initial PM) io2 \\<noteq>\n                {})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>io1\\<in>R M2 s vs xs.\n               \\<exists>io2\\<in>R M2 s vs xs.\n                  io1 \\<noteq> io2 \\<and>\n                  io_targets PM (initial PM) io1 \\<inter>\n                  io_targets PM (initial PM) io2 \\<noteq>\n                  {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>io1\\<in>R M2 s vs xs.\n             \\<exists>io2\\<in>R M2 s vs xs.\n                io1 \\<noteq> io2 \\<and>\n                io_targets PM (initial PM) io1 \\<inter>\n                io_targets PM (initial PM) io2 \\<noteq>\n                {})", "have \"\\<forall>io1\\<in>R M2 s vs xs. \\<forall>io2\\<in>R M2 s vs xs. io1 = io2\n                  \\<or> io_targets PM (initial PM) io1 \\<inter> io_targets PM (initial PM) io2 = {}\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>io1\\<in>R M2 s vs xs.\n             \\<exists>io2\\<in>R M2 s vs xs.\n                io1 \\<noteq> io2 \\<and>\n                io_targets PM (initial PM) io1 \\<inter>\n                io_targets PM (initial PM) io2 \\<noteq>\n                {})\n\ngoal (1 subgoal):\n 1. \\<forall>io1\\<in>R M2 s vs xs.\n       \\<forall>io2\\<in>R M2 s vs xs.\n          io1 = io2 \\<or>\n          io_targets PM (initial PM) io1 \\<inter>\n          io_targets PM (initial PM) io2 =\n          {}", "by blast"], ["proof (state)\nthis:\n  \\<forall>io1\\<in>R M2 s vs xs.\n     \\<forall>io2\\<in>R M2 s vs xs.\n        io1 = io2 \\<or>\n        io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 =\n        {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>io1\\<in>R M2 s vs xs.\n               \\<exists>io2\\<in>R M2 s vs xs.\n                  io1 \\<noteq> io2 \\<and>\n                  io_targets PM (initial PM) io1 \\<inter>\n                  io_targets PM (initial PM) io2 \\<noteq>\n                  {}) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<forall>io1\\<in>R M2 s vs xs.\n     \\<forall>io2\\<in>R M2 s vs xs.\n        io1 = io2 \\<or>\n        io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 =\n        {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>io1\\<in>R M2 s vs xs.\n               \\<exists>io2\\<in>R M2 s vs xs.\n                  io1 \\<noteq> io2 \\<and>\n                  io_targets PM (initial PM) io1 \\<inter>\n                  io_targets PM (initial PM) io2 \\<noteq>\n                  {}) \\<Longrightarrow>\n    False", "have \"\\<forall>io\\<in>R M2 s vs xs. io_targets PM (initial PM) io \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>R M2 s vs xs. io_targets PM (initial PM) io \\<noteq> {}", "by (metis insert_not_empty singletons)"], ["proof (state)\nthis:\n  \\<forall>io\\<in>R M2 s vs xs. io_targets PM (initial PM) io \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>io1\\<in>R M2 s vs xs.\n               \\<exists>io2\\<in>R M2 s vs xs.\n                  io1 \\<noteq> io2 \\<and>\n                  io_targets PM (initial PM) io1 \\<inter>\n                  io_targets PM (initial PM) io2 \\<noteq>\n                  {}) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>io1\\<in>R M2 s vs xs.\n     \\<forall>io2\\<in>R M2 s vs xs.\n        io1 = io2 \\<or>\n        io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 =\n        {}\n  \\<forall>io\\<in>R M2 s vs xs. io_targets PM (initial PM) io \\<noteq> {}", "have \"card (image (io_targets PM (initial PM)) (R M2 s vs xs))\n                        = card (R M2 s vs xs)\""], ["proof (prove)\nusing this:\n  \\<forall>io1\\<in>R M2 s vs xs.\n     \\<forall>io2\\<in>R M2 s vs xs.\n        io1 = io2 \\<or>\n        io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 =\n        {}\n  \\<forall>io\\<in>R M2 s vs xs. io_targets PM (initial PM) io \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (io_targets PM (initial PM) ` R M2 s vs xs) = card (R M2 s vs xs)", "using finite_R[of M2 s vs xs] card_union_of_distinct\n              [of \"R M2 s vs xs\" \"(io_targets PM (initial PM))\"]"], ["proof (prove)\nusing this:\n  \\<forall>io1\\<in>R M2 s vs xs.\n     \\<forall>io2\\<in>R M2 s vs xs.\n        io1 = io2 \\<or>\n        io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 =\n        {}\n  \\<forall>io\\<in>R M2 s vs xs. io_targets PM (initial PM) io \\<noteq> {}\n  finite (R M2 s vs xs)\n  \\<lbrakk>\\<forall>S1\\<in>R M2 s vs xs.\n              \\<forall>S2\\<in>R M2 s vs xs.\n                 S1 = S2 \\<or>\n                 io_targets PM (initial PM) S1 \\<inter>\n                 io_targets PM (initial PM) S2 =\n                 {};\n   finite (R M2 s vs xs);\n   \\<forall>S\\<in>R M2 s vs xs.\n      io_targets PM (initial PM) S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> card (io_targets PM (initial PM) ` R M2 s vs xs) =\n                    card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (io_targets PM (initial PM) ` R M2 s vs xs) = card (R M2 s vs xs)", "by blast"], ["proof (state)\nthis:\n  card (io_targets PM (initial PM) ` R M2 s vs xs) = card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>io1\\<in>R M2 s vs xs.\n               \\<exists>io2\\<in>R M2 s vs xs.\n                  io1 \\<noteq> io2 \\<and>\n                  io_targets PM (initial PM) io1 \\<inter>\n                  io_targets PM (initial PM) io2 \\<noteq>\n                  {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  card (io_targets PM (initial PM) ` R M2 s vs xs) = card (R M2 s vs xs)", "show \"False\""], ["proof (prove)\nusing this:\n  card (io_targets PM (initial PM) ` R M2 s vs xs) = card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. False", "using card_le card_targets"], ["proof (prove)\nusing this:\n  card (io_targets PM (initial PM) ` R M2 s vs xs) = card (R M2 s vs xs)\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs))\n  < card (R M2 s vs xs)\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (io_targets PM (initial PM) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>io1\\<in>R M2 s vs xs.\n     \\<exists>io2\\<in>R M2 s vs xs.\n        io1 \\<noteq> io2 \\<and>\n        io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 \\<noteq>\n        {}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>io1\\<in>R M2 s vs xs.\n     \\<exists>io2\\<in>R M2 s vs xs.\n        io1 \\<noteq> io2 \\<and>\n        io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 \\<noteq>\n        {}", "have \"\\<exists> io1 io2 . io1 \\<in> (R M2 s vs xs)\n                            \\<and> io2 \\<in> (R M2 s vs xs)\n                            \\<and> io1 \\<noteq> io2\n                            \\<and> io_targets PM (initial PM) io1 \\<inter> io_targets PM (initial PM) io2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<exists>io1\\<in>R M2 s vs xs.\n     \\<exists>io2\\<in>R M2 s vs xs.\n        io1 \\<noteq> io2 \\<and>\n        io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 \\<noteq>\n        {}\n\ngoal (1 subgoal):\n 1. \\<exists>io1 io2.\n       io1 \\<in> R M2 s vs xs \\<and>\n       io2 \\<in> R M2 s vs xs \\<and>\n       io1 \\<noteq> io2 \\<and>\n       io_targets PM (initial PM) io1 \\<inter>\n       io_targets PM (initial PM) io2 \\<noteq>\n       {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>io1 io2.\n     io1 \\<in> R M2 s vs xs \\<and>\n     io2 \\<in> R M2 s vs xs \\<and>\n     io1 \\<noteq> io2 \\<and>\n     io_targets PM (initial PM) io1 \\<inter>\n     io_targets PM (initial PM) io2 \\<noteq>\n     {}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<exists>io1 io2.\n     io1 \\<in> R M2 s vs xs \\<and>\n     io2 \\<in> R M2 s vs xs \\<and>\n     io1 \\<noteq> io2 \\<and>\n     io_targets PM (initial PM) io1 \\<inter>\n     io_targets PM (initial PM) io2 \\<noteq>\n     {}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"\\<forall> io1 io2 . (io1 \\<in> (R M2 s vs xs) \\<and> io2 \\<in> (R M2 s vs xs) \\<and> io1 \\<noteq> io2)\n                                \\<longrightarrow> length io1 \\<noteq> length io2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io1 io2.\n       io1 \\<in> R M2 s vs xs \\<and>\n       io2 \\<in> R M2 s vs xs \\<and> io1 \\<noteq> io2 \\<longrightarrow>\n       length io1 \\<noteq> length io2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>io1 io2.\n               io1 \\<in> R M2 s vs xs \\<and>\n               io2 \\<in> R M2 s vs xs \\<and>\n               io1 \\<noteq> io2 \\<longrightarrow>\n               length io1 \\<noteq> length io2) \\<Longrightarrow>\n    False", "assume \" \\<not> (\\<forall>io1 io2. io1 \\<in> R M2 s vs xs \\<and> io2 \\<in> R M2 s vs xs \\<and> io1 \\<noteq> io2\n                  \\<longrightarrow> length io1 \\<noteq> length io2)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>io1 io2.\n             io1 \\<in> R M2 s vs xs \\<and>\n             io2 \\<in> R M2 s vs xs \\<and>\n             io1 \\<noteq> io2 \\<longrightarrow>\n             length io1 \\<noteq> length io2)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>io1 io2.\n               io1 \\<in> R M2 s vs xs \\<and>\n               io2 \\<in> R M2 s vs xs \\<and>\n               io1 \\<noteq> io2 \\<longrightarrow>\n               length io1 \\<noteq> length io2) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>io1 io2.\n             io1 \\<in> R M2 s vs xs \\<and>\n             io2 \\<in> R M2 s vs xs \\<and>\n             io1 \\<noteq> io2 \\<longrightarrow>\n             length io1 \\<noteq> length io2)", "obtain io1 io2 where io_def : \"io1 \\<in> R M2 s vs xs\n                                          \\<and> io2 \\<in> R M2 s vs xs\n                                          \\<and> io1 \\<noteq> io2\n                                          \\<and> length io1 = length io2\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>io1 io2.\n             io1 \\<in> R M2 s vs xs \\<and>\n             io2 \\<in> R M2 s vs xs \\<and>\n             io1 \\<noteq> io2 \\<longrightarrow>\n             length io1 \\<noteq> length io2)\n\ngoal (1 subgoal):\n 1. (\\<And>io1 io2.\n        io1 \\<in> R M2 s vs xs \\<and>\n        io2 \\<in> R M2 s vs xs \\<and>\n        io1 \\<noteq> io2 \\<and> length io1 = length io2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  io1 \\<in> R M2 s vs xs \\<and>\n  io2 \\<in> R M2 s vs xs \\<and>\n  io1 \\<noteq> io2 \\<and> length io1 = length io2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>io1 io2.\n               io1 \\<in> R M2 s vs xs \\<and>\n               io2 \\<in> R M2 s vs xs \\<and>\n               io1 \\<noteq> io2 \\<longrightarrow>\n               length io1 \\<noteq> length io2) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io1 \\<in> R M2 s vs xs \\<and>\n  io2 \\<in> R M2 s vs xs \\<and>\n  io1 \\<noteq> io2 \\<and> length io1 = length io2", "have \"prefix io1 (vs @ xs) \\<and> prefix io2 (vs @ xs)\""], ["proof (prove)\nusing this:\n  io1 \\<in> R M2 s vs xs \\<and>\n  io2 \\<in> R M2 s vs xs \\<and>\n  io1 \\<noteq> io2 \\<and> length io1 = length io2\n\ngoal (1 subgoal):\n 1. prefix io1 (vs @ xs) \\<and> prefix io2 (vs @ xs)", "by auto"], ["proof (state)\nthis:\n  prefix io1 (vs @ xs) \\<and> prefix io2 (vs @ xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>io1 io2.\n               io1 \\<in> R M2 s vs xs \\<and>\n               io2 \\<in> R M2 s vs xs \\<and>\n               io1 \\<noteq> io2 \\<longrightarrow>\n               length io1 \\<noteq> length io2) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  prefix io1 (vs @ xs) \\<and> prefix io2 (vs @ xs)", "have \"io1 = take (length io1) (vs @ xs) \\<and> io2 = take (length io2) (vs @ xs)\""], ["proof (prove)\nusing this:\n  prefix io1 (vs @ xs) \\<and> prefix io2 (vs @ xs)\n\ngoal (1 subgoal):\n 1. io1 = take (length io1) (vs @ xs) \\<and>\n    io2 = take (length io2) (vs @ xs)", "by (metis append_eq_conv_conj prefixE)"], ["proof (state)\nthis:\n  io1 = take (length io1) (vs @ xs) \\<and> io2 = take (length io2) (vs @ xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>io1 io2.\n               io1 \\<in> R M2 s vs xs \\<and>\n               io2 \\<in> R M2 s vs xs \\<and>\n               io1 \\<noteq> io2 \\<longrightarrow>\n               length io1 \\<noteq> length io2) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io1 = take (length io1) (vs @ xs) \\<and> io2 = take (length io2) (vs @ xs)", "show \"False\""], ["proof (prove)\nusing this:\n  io1 = take (length io1) (vs @ xs) \\<and> io2 = take (length io2) (vs @ xs)\n\ngoal (1 subgoal):\n 1. False", "using io_def"], ["proof (prove)\nusing this:\n  io1 = take (length io1) (vs @ xs) \\<and> io2 = take (length io2) (vs @ xs)\n  io1 \\<in> R M2 s vs xs \\<and>\n  io2 \\<in> R M2 s vs xs \\<and>\n  io1 \\<noteq> io2 \\<and> length io1 = length io2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>io1 io2.\n     io1 \\<in> R M2 s vs xs \\<and>\n     io2 \\<in> R M2 s vs xs \\<and> io1 \\<noteq> io2 \\<longrightarrow>\n     length io1 \\<noteq> length io2\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>io1 io2.\n     io1 \\<in> R M2 s vs xs \\<and>\n     io2 \\<in> R M2 s vs xs \\<and>\n     io1 \\<noteq> io2 \\<and>\n     io_targets PM (initial PM) io1 \\<inter>\n     io_targets PM (initial PM) io2 \\<noteq>\n     {}\n  \\<forall>io1 io2.\n     io1 \\<in> R M2 s vs xs \\<and>\n     io2 \\<in> R M2 s vs xs \\<and> io1 \\<noteq> io2 \\<longrightarrow>\n     length io1 \\<noteq> length io2", "obtain io1 io2 where rep_ios_def :\n      \"io1 \\<in> (R M2 s vs xs)\n        \\<and> io2 \\<in> (R M2 s vs xs)\n        \\<and> length io1 < length io2\n        \\<and> io_targets PM (initial PM) io1 \\<inter> io_targets PM (initial PM) io2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<exists>io1 io2.\n     io1 \\<in> R M2 s vs xs \\<and>\n     io2 \\<in> R M2 s vs xs \\<and>\n     io1 \\<noteq> io2 \\<and>\n     io_targets PM (initial PM) io1 \\<inter>\n     io_targets PM (initial PM) io2 \\<noteq>\n     {}\n  \\<forall>io1 io2.\n     io1 \\<in> R M2 s vs xs \\<and>\n     io2 \\<in> R M2 s vs xs \\<and> io1 \\<noteq> io2 \\<longrightarrow>\n     length io1 \\<noteq> length io2\n\ngoal (1 subgoal):\n 1. (\\<And>io1 io2.\n        io1 \\<in> R M2 s vs xs \\<and>\n        io2 \\<in> R M2 s vs xs \\<and>\n        length io1 < length io2 \\<and>\n        io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 \\<noteq>\n        {} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis inf_sup_aci(1) linorder_neqE_nat)"], ["proof (state)\nthis:\n  io1 \\<in> R M2 s vs xs \\<and>\n  io2 \\<in> R M2 s vs xs \\<and>\n  length io1 < length io2 \\<and>\n  io_targets PM (initial PM) io1 \\<inter>\n  io_targets PM (initial PM) io2 \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "obtain rep where \"(s,rep) \\<in> io_targets PM (initial PM) io1 \\<inter> io_targets PM (initial PM) io2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rep.\n        (s, rep)\n        \\<in> io_targets PM (initial PM) io1 \\<inter>\n              io_targets PM (initial PM) io2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>rep.\n        (s, rep)\n        \\<in> io_targets PM (initial PM) io1 \\<inter>\n              io_targets PM (initial PM) io2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "assume a1: \"\\<And>rep. (s, rep) \\<in> io_targets PM (initial PM) io1 \\<inter> io_targets PM (initial PM) io2\n                        \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  (s, ?rep)\n  \\<in> io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. (\\<And>rep.\n        (s, rep)\n        \\<in> io_targets PM (initial PM) io1 \\<inter>\n              io_targets PM (initial PM) io2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>f. Sigma {s} f \\<inter> (io_targets PM (initial PM) io1 \\<inter> io_targets PM (initial PM) io2)\n                 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       Sigma {s} f \\<inter>\n       (io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2) \\<noteq>\n       {}", "by (metis (no_types) inf.left_idem rep_ios_def state_components)"], ["proof (state)\nthis:\n  \\<exists>f.\n     Sigma {s} f \\<inter>\n     (io_targets PM (initial PM) io1 \\<inter>\n      io_targets PM (initial PM) io2) \\<noteq>\n     {}\n\ngoal (1 subgoal):\n 1. (\\<And>rep.\n        (s, rep)\n        \\<in> io_targets PM (initial PM) io1 \\<inter>\n              io_targets PM (initial PM) io2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     Sigma {s} f \\<inter>\n     (io_targets PM (initial PM) io1 \\<inter>\n      io_targets PM (initial PM) io2) \\<noteq>\n     {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     Sigma {s} f \\<inter>\n     (io_targets PM (initial PM) io1 \\<inter>\n      io_targets PM (initial PM) io2) \\<noteq>\n     {}\n\ngoal (1 subgoal):\n 1. thesis", "using a1"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     Sigma {s} f \\<inter>\n     (io_targets PM (initial PM) io1 \\<inter>\n      io_targets PM (initial PM) io2) \\<noteq>\n     {}\n  (s, ?rep)\n  \\<in> io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2 \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s, rep)\n  \\<in> io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (s, rep)\n  \\<in> io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2", "have rep_state : \"io_targets PM (initial PM) io1 = {(s,rep)}\n                            \\<and> io_targets PM (initial PM) io2 = {(s,rep)}\""], ["proof (prove)\nusing this:\n  (s, rep)\n  \\<in> io_targets PM (initial PM) io1 \\<inter>\n        io_targets PM (initial PM) io2\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io1 = {(s, rep)} \\<and>\n    io_targets PM (initial PM) io2 = {(s, rep)}", "by (metis Int_iff rep_ios_def singletonD singletons)"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io1 = {(s, rep)} \\<and>\n  io_targets PM (initial PM) io2 = {(s, rep)}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "obtain io1X io2X where rep_ios_split : \"io1 = vs @ io1X\n                                            \\<and> prefix io1X xs\n                                            \\<and> io2 = vs @ io2X\n                                            \\<and> prefix io2X xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>io1X io2X.\n        io1 = vs @ io1X \\<and>\n        prefix io1X xs \\<and>\n        io2 = vs @ io2X \\<and> prefix io2X xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using rep_ios_def"], ["proof (prove)\nusing this:\n  io1 \\<in> R M2 s vs xs \\<and>\n  io2 \\<in> R M2 s vs xs \\<and>\n  length io1 < length io2 \\<and>\n  io_targets PM (initial PM) io1 \\<inter>\n  io_targets PM (initial PM) io2 \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>io1X io2X.\n        io1 = vs @ io1X \\<and>\n        prefix io1X xs \\<and>\n        io2 = vs @ io2X \\<and> prefix io2X xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs", "have \"length io1 > length vs\""], ["proof (prove)\nusing this:\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs\n\ngoal (1 subgoal):\n 1. length vs < length io1", "using rep_ios_def"], ["proof (prove)\nusing this:\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs\n  io1 \\<in> R M2 s vs xs \\<and>\n  io2 \\<in> R M2 s vs xs \\<and>\n  length io1 < length io2 \\<and>\n  io_targets PM (initial PM) io1 \\<inter>\n  io_targets PM (initial PM) io2 \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. length vs < length io1", "by auto\n\n\n    \\<comment> \\<open>get a path from (initial PM) to (q2,q1)\\<close>"], ["proof (state)\nthis:\n  length vs < length io1\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"vs@xs \\<in> L PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L PM", "by (metis (no_types) assms(1) assms(4) assms(5) assms(7) inf_commute productF_language)"], ["proof (state)\nthis:\n  vs @ xs \\<in> L PM\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  vs @ xs \\<in> L PM", "have \"vs \\<in> L PM\""], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L PM\n\ngoal (1 subgoal):\n 1. vs \\<in> L PM", "by (meson language_state_prefix)"], ["proof (state)\nthis:\n  vs \\<in> L PM\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  vs \\<in> L PM", "obtain trV where trV_def : \"{tr . path PM (vs || tr) (initial PM) \\<and> length vs = length tr}\n                                      = { trV }\""], ["proof (prove)\nusing this:\n  vs \\<in> L PM\n\ngoal (1 subgoal):\n 1. (\\<And>trV.\n        {tr. path PM (vs || tr) (initial PM) \\<and> length vs = length tr} =\n        {trV} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using observable_path_unique_ex[of PM vs \"initial PM\"]\n            assms(2) assms(3) assms(7) observable_productF"], ["proof (prove)\nusing this:\n  vs \\<in> L PM\n  \\<lbrakk>observable PM; vs \\<in> L PM;\n   \\<And>tr.\n      {t. path PM (vs || t) (initial PM) \\<and> length vs = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  observable M1\n  observable M2\n  productF M2 M1 FAIL PM\n  \\<lbrakk>observable ?M1.0; observable ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> observable ?PM\n\ngoal (1 subgoal):\n 1. (\\<And>trV.\n        {tr. path PM (vs || tr) (initial PM) \\<and> length vs = length tr} =\n        {trV} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  {tr. path PM (vs || tr) (initial PM) \\<and> length vs = length tr} = {trV}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "let ?qv = \"target (vs || trV) (initial PM)\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"?qv \\<in> io_targets PM (initial PM) vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (vs || trV) (initial PM) \\<in> io_targets PM (initial PM) vs", "using trV_def"], ["proof (prove)\nusing this:\n  {tr. path PM (vs || tr) (initial PM) \\<and> length vs = length tr} = {trV}\n\ngoal (1 subgoal):\n 1. target (vs || trV) (initial PM) \\<in> io_targets PM (initial PM) vs", "by auto"], ["proof (state)\nthis:\n  target (vs || trV) (initial PM) \\<in> io_targets PM (initial PM) vs\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  target (vs || trV) (initial PM) \\<in> io_targets PM (initial PM) vs", "have qv_simp[simp] : \"?qv = (q2,q1)\""], ["proof (prove)\nusing this:\n  target (vs || trV) (initial PM) \\<in> io_targets PM (initial PM) vs\n\ngoal (1 subgoal):\n 1. target (vs || trV) (initial PM) = (q2, q1)", "using singletons assms"], ["proof (prove)\nusing this:\n  target (vs || trV) (initial PM) \\<in> io_targets PM (initial PM) vs\n  \\<forall>io\\<in>R M2 s vs xs.\n     \\<exists>t. io_targets PM (initial PM) io = {t}\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n\ngoal (1 subgoal):\n 1. target (vs || trV) (initial PM) = (q2, q1)", "by blast"], ["proof (state)\nthis:\n  target (vs || trV) (initial PM) = (q2, q1)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  target (vs || trV) (initial PM) = (q2, q1)", "have \"?qv \\<in> nodes PM\""], ["proof (prove)\nusing this:\n  target (vs || trV) (initial PM) = (q2, q1)\n\ngoal (1 subgoal):\n 1. target (vs || trV) (initial PM) \\<in> nodes PM", "using trV_def assms"], ["proof (prove)\nusing this:\n  target (vs || trV) (initial PM) = (q2, q1)\n  {tr. path PM (vs || tr) (initial PM) \\<and> length vs = length tr} = {trV}\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n\ngoal (1 subgoal):\n 1. target (vs || trV) (initial PM) \\<in> nodes PM", "by blast\n\n\n    \\<comment> \\<open>get a path using io1X from the state reached by vs in PM\\<close>"], ["proof (state)\nthis:\n  target (vs || trV) (initial PM) \\<in> nodes PM\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "obtain tr1X_all where tr1X_all_def : \"path PM (vs @ io1X || tr1X_all) (initial PM)\n                                          \\<and> length (vs @ io1X) = length tr1X_all\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr1X_all.\n        path PM (vs @ io1X || tr1X_all) (initial PM) \\<and>\n        length (vs @ io1X) = length tr1X_all \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using rep_ios_def rep_ios_split"], ["proof (prove)\nusing this:\n  io1 \\<in> R M2 s vs xs \\<and>\n  io2 \\<in> R M2 s vs xs \\<and>\n  length io1 < length io2 \\<and>\n  io_targets PM (initial PM) io1 \\<inter>\n  io_targets PM (initial PM) io2 \\<noteq>\n  {}\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs\n\ngoal (1 subgoal):\n 1. (\\<And>tr1X_all.\n        path PM (vs @ io1X || tr1X_all) (initial PM) \\<and>\n        length (vs @ io1X) = length tr1X_all \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path PM (vs @ io1X || tr1X_all) (initial PM) \\<and>\n  length (vs @ io1X) = length tr1X_all\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "let ?tr1X = \"drop (length vs) tr1X_all\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"take (length vs) tr1X_all = trV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length vs) tr1X_all = trV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take (length vs) tr1X_all = trV", "have \"path PM (vs || take (length vs) tr1X_all) (initial PM)\n            \\<and> length vs = length (take (length vs) tr1X_all)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (vs || take (length vs) tr1X_all) (initial PM) \\<and>\n    length vs = length (take (length vs) tr1X_all)", "using tr1X_all_def trV_def"], ["proof (prove)\nusing this:\n  path PM (vs @ io1X || tr1X_all) (initial PM) \\<and>\n  length (vs @ io1X) = length tr1X_all\n  {tr. path PM (vs || tr) (initial PM) \\<and> length vs = length tr} = {trV}\n\ngoal (1 subgoal):\n 1. path PM (vs || take (length vs) tr1X_all) (initial PM) \\<and>\n    length vs = length (take (length vs) tr1X_all)", "by (metis (no_types, lifting) FSM.path_append_elim append_eq_conv_conj\n            length_take zip_append1)"], ["proof (state)\nthis:\n  path PM (vs || take (length vs) tr1X_all) (initial PM) \\<and>\n  length vs = length (take (length vs) tr1X_all)\n\ngoal (1 subgoal):\n 1. take (length vs) tr1X_all = trV", "then"], ["proof (chain)\npicking this:\n  path PM (vs || take (length vs) tr1X_all) (initial PM) \\<and>\n  length vs = length (take (length vs) tr1X_all)", "show \"take (length vs) tr1X_all = trV\""], ["proof (prove)\nusing this:\n  path PM (vs || take (length vs) tr1X_all) (initial PM) \\<and>\n  length vs = length (take (length vs) tr1X_all)\n\ngoal (1 subgoal):\n 1. take (length vs) tr1X_all = trV", "using trV_def"], ["proof (prove)\nusing this:\n  path PM (vs || take (length vs) tr1X_all) (initial PM) \\<and>\n  length vs = length (take (length vs) tr1X_all)\n  {tr. path PM (vs || tr) (initial PM) \\<and> length vs = length tr} = {trV}\n\ngoal (1 subgoal):\n 1. take (length vs) tr1X_all = trV", "by blast"], ["proof (state)\nthis:\n  take (length vs) tr1X_all = trV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take (length vs) tr1X_all = trV\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  take (length vs) tr1X_all = trV", "have tr1X_def : \"path PM (io1X || ?tr1X) ?qv \\<and> length io1X = length ?tr1X\""], ["proof (prove)\nusing this:\n  take (length vs) tr1X_all = trV\n\ngoal (1 subgoal):\n 1. path PM (io1X || drop (length vs) tr1X_all)\n     (target (vs || trV) (initial PM)) \\<and>\n    length io1X = length (drop (length vs) tr1X_all)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take (length vs) tr1X_all = trV \\<Longrightarrow>\n    path PM (io1X || drop (length vs) tr1X_all)\n     (target (vs || trV) (initial PM)) \\<and>\n    length io1X = length (drop (length vs) tr1X_all)", "have \"length tr1X_all = length vs + length io1X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length tr1X_all = length vs + length io1X", "using tr1X_all_def"], ["proof (prove)\nusing this:\n  path PM (vs @ io1X || tr1X_all) (initial PM) \\<and>\n  length (vs @ io1X) = length tr1X_all\n\ngoal (1 subgoal):\n 1. length tr1X_all = length vs + length io1X", "by auto"], ["proof (state)\nthis:\n  length tr1X_all = length vs + length io1X\n\ngoal (1 subgoal):\n 1. take (length vs) tr1X_all = trV \\<Longrightarrow>\n    path PM (io1X || drop (length vs) tr1X_all)\n     (target (vs || trV) (initial PM)) \\<and>\n    length io1X = length (drop (length vs) tr1X_all)", "then"], ["proof (chain)\npicking this:\n  length tr1X_all = length vs + length io1X", "have \"length io1X = length tr1X_all - length vs\""], ["proof (prove)\nusing this:\n  length tr1X_all = length vs + length io1X\n\ngoal (1 subgoal):\n 1. length io1X = length tr1X_all - length vs", "by presburger"], ["proof (state)\nthis:\n  length io1X = length tr1X_all - length vs\n\ngoal (1 subgoal):\n 1. take (length vs) tr1X_all = trV \\<Longrightarrow>\n    path PM (io1X || drop (length vs) tr1X_all)\n     (target (vs || trV) (initial PM)) \\<and>\n    length io1X = length (drop (length vs) tr1X_all)", "then"], ["proof (chain)\npicking this:\n  length io1X = length tr1X_all - length vs", "show ?thesis"], ["proof (prove)\nusing this:\n  length io1X = length tr1X_all - length vs\n\ngoal (1 subgoal):\n 1. path PM (io1X || drop (length vs) tr1X_all)\n     (target (vs || trV) (initial PM)) \\<and>\n    length io1X = length (drop (length vs) tr1X_all)", "by (metis (no_types) FSM.path_append_elim \\<open>take (length vs) tr1X_all = trV\\<close>\n            length_drop tr1X_all_def zip_append1)"], ["proof (state)\nthis:\n  path PM (io1X || drop (length vs) tr1X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io1X = length (drop (length vs) tr1X_all)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path PM (io1X || drop (length vs) tr1X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io1X = length (drop (length vs) tr1X_all)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  path PM (io1X || drop (length vs) tr1X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io1X = length (drop (length vs) tr1X_all)", "have io1X_lang : \"io1X \\<in> language_state PM ?qv\""], ["proof (prove)\nusing this:\n  path PM (io1X || drop (length vs) tr1X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io1X = length (drop (length vs) tr1X_all)\n\ngoal (1 subgoal):\n 1. io1X \\<in> LS PM (target (vs || trV) (initial PM))", "by auto"], ["proof (state)\nthis:\n  io1X \\<in> LS PM (target (vs || trV) (initial PM))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io1X \\<in> LS PM (target (vs || trV) (initial PM))", "obtain tr1X' where tr1X'_def : \"{tr . path PM (io1X || tr) ?qv \\<and> length io1X = length tr}\n                                          = { tr1X' }\""], ["proof (prove)\nusing this:\n  io1X \\<in> LS PM (target (vs || trV) (initial PM))\n\ngoal (1 subgoal):\n 1. (\\<And>tr1X'.\n        {tr.\n         path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n         length io1X = length tr} =\n        {tr1X'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using observable_path_unique_ex[of PM io1X ?qv]\n            assms(2) assms(3) assms(7) observable_productF"], ["proof (prove)\nusing this:\n  io1X \\<in> LS PM (target (vs || trV) (initial PM))\n  \\<lbrakk>observable PM;\n   io1X \\<in> LS PM (target (vs || trV) (initial PM));\n   \\<And>tr.\n      {t. path PM (io1X || t) (target (vs || trV) (initial PM)) \\<and>\n          length io1X = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  observable M1\n  observable M2\n  productF M2 M1 FAIL PM\n  \\<lbrakk>observable ?M1.0; observable ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> observable ?PM\n\ngoal (1 subgoal):\n 1. (\\<And>tr1X'.\n        {tr.\n         path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n         length io1X = length tr} =\n        {tr1X'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  {tr.\n   path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n   length io1X = length tr} =\n  {tr1X'}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  {tr.\n   path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n   length io1X = length tr} =\n  {tr1X'}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"?tr1X \\<in> { tr . path PM (io1X || tr) ?qv \\<and> length io1X = length tr }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (length vs) tr1X_all\n    \\<in> {tr.\n           path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n           length io1X = length tr}", "using tr1X_def"], ["proof (prove)\nusing this:\n  path PM (io1X || drop (length vs) tr1X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io1X = length (drop (length vs) tr1X_all)\n\ngoal (1 subgoal):\n 1. drop (length vs) tr1X_all\n    \\<in> {tr.\n           path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n           length io1X = length tr}", "by auto"], ["proof (state)\nthis:\n  drop (length vs) tr1X_all\n  \\<in> {tr.\n         path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n         length io1X = length tr}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  {tr.\n   path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n   length io1X = length tr} =\n  {tr1X'}\n  drop (length vs) tr1X_all\n  \\<in> {tr.\n         path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n         length io1X = length tr}", "have tr1x_unique : \"tr1X' = ?tr1X\""], ["proof (prove)\nusing this:\n  {tr.\n   path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n   length io1X = length tr} =\n  {tr1X'}\n  drop (length vs) tr1X_all\n  \\<in> {tr.\n         path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n         length io1X = length tr}\n\ngoal (1 subgoal):\n 1. tr1X' = drop (length vs) tr1X_all", "by simp\n\n    \\<comment> \\<open>get a path using io2X from the state reached by vs in PM\\<close>"], ["proof (state)\nthis:\n  tr1X' = drop (length vs) tr1X_all\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "obtain tr2X_all where tr2X_all_def : \"path PM (vs @ io2X || tr2X_all) (initial PM)\n                                          \\<and> length (vs @ io2X) = length tr2X_all\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr2X_all.\n        path PM (vs @ io2X || tr2X_all) (initial PM) \\<and>\n        length (vs @ io2X) = length tr2X_all \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using rep_ios_def rep_ios_split"], ["proof (prove)\nusing this:\n  io1 \\<in> R M2 s vs xs \\<and>\n  io2 \\<in> R M2 s vs xs \\<and>\n  length io1 < length io2 \\<and>\n  io_targets PM (initial PM) io1 \\<inter>\n  io_targets PM (initial PM) io2 \\<noteq>\n  {}\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs\n\ngoal (1 subgoal):\n 1. (\\<And>tr2X_all.\n        path PM (vs @ io2X || tr2X_all) (initial PM) \\<and>\n        length (vs @ io2X) = length tr2X_all \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path PM (vs @ io2X || tr2X_all) (initial PM) \\<and>\n  length (vs @ io2X) = length tr2X_all\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "let ?tr2X = \"drop (length vs) tr2X_all\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"take (length vs) tr2X_all = trV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length vs) tr2X_all = trV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take (length vs) tr2X_all = trV", "have \"path PM (vs || take (length vs) tr2X_all) (initial PM)\n            \\<and> length vs = length (take (length vs) tr2X_all)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (vs || take (length vs) tr2X_all) (initial PM) \\<and>\n    length vs = length (take (length vs) tr2X_all)", "using tr2X_all_def trV_def"], ["proof (prove)\nusing this:\n  path PM (vs @ io2X || tr2X_all) (initial PM) \\<and>\n  length (vs @ io2X) = length tr2X_all\n  {tr. path PM (vs || tr) (initial PM) \\<and> length vs = length tr} = {trV}\n\ngoal (1 subgoal):\n 1. path PM (vs || take (length vs) tr2X_all) (initial PM) \\<and>\n    length vs = length (take (length vs) tr2X_all)", "by (metis (no_types, lifting) FSM.path_append_elim append_eq_conv_conj\n            length_take zip_append1)"], ["proof (state)\nthis:\n  path PM (vs || take (length vs) tr2X_all) (initial PM) \\<and>\n  length vs = length (take (length vs) tr2X_all)\n\ngoal (1 subgoal):\n 1. take (length vs) tr2X_all = trV", "then"], ["proof (chain)\npicking this:\n  path PM (vs || take (length vs) tr2X_all) (initial PM) \\<and>\n  length vs = length (take (length vs) tr2X_all)", "show \"take (length vs) tr2X_all = trV\""], ["proof (prove)\nusing this:\n  path PM (vs || take (length vs) tr2X_all) (initial PM) \\<and>\n  length vs = length (take (length vs) tr2X_all)\n\ngoal (1 subgoal):\n 1. take (length vs) tr2X_all = trV", "using trV_def"], ["proof (prove)\nusing this:\n  path PM (vs || take (length vs) tr2X_all) (initial PM) \\<and>\n  length vs = length (take (length vs) tr2X_all)\n  {tr. path PM (vs || tr) (initial PM) \\<and> length vs = length tr} = {trV}\n\ngoal (1 subgoal):\n 1. take (length vs) tr2X_all = trV", "by blast"], ["proof (state)\nthis:\n  take (length vs) tr2X_all = trV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take (length vs) tr2X_all = trV\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  take (length vs) tr2X_all = trV", "have tr2X_def : \"path PM (io2X || ?tr2X) ?qv \\<and> length io2X = length ?tr2X\""], ["proof (prove)\nusing this:\n  take (length vs) tr2X_all = trV\n\ngoal (1 subgoal):\n 1. path PM (io2X || drop (length vs) tr2X_all)\n     (target (vs || trV) (initial PM)) \\<and>\n    length io2X = length (drop (length vs) tr2X_all)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take (length vs) tr2X_all = trV \\<Longrightarrow>\n    path PM (io2X || drop (length vs) tr2X_all)\n     (target (vs || trV) (initial PM)) \\<and>\n    length io2X = length (drop (length vs) tr2X_all)", "have \"length tr2X_all = length vs + length io2X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length tr2X_all = length vs + length io2X", "using tr2X_all_def"], ["proof (prove)\nusing this:\n  path PM (vs @ io2X || tr2X_all) (initial PM) \\<and>\n  length (vs @ io2X) = length tr2X_all\n\ngoal (1 subgoal):\n 1. length tr2X_all = length vs + length io2X", "by auto"], ["proof (state)\nthis:\n  length tr2X_all = length vs + length io2X\n\ngoal (1 subgoal):\n 1. take (length vs) tr2X_all = trV \\<Longrightarrow>\n    path PM (io2X || drop (length vs) tr2X_all)\n     (target (vs || trV) (initial PM)) \\<and>\n    length io2X = length (drop (length vs) tr2X_all)", "then"], ["proof (chain)\npicking this:\n  length tr2X_all = length vs + length io2X", "have \"length io2X = length tr2X_all - length vs\""], ["proof (prove)\nusing this:\n  length tr2X_all = length vs + length io2X\n\ngoal (1 subgoal):\n 1. length io2X = length tr2X_all - length vs", "by presburger"], ["proof (state)\nthis:\n  length io2X = length tr2X_all - length vs\n\ngoal (1 subgoal):\n 1. take (length vs) tr2X_all = trV \\<Longrightarrow>\n    path PM (io2X || drop (length vs) tr2X_all)\n     (target (vs || trV) (initial PM)) \\<and>\n    length io2X = length (drop (length vs) tr2X_all)", "then"], ["proof (chain)\npicking this:\n  length io2X = length tr2X_all - length vs", "show ?thesis"], ["proof (prove)\nusing this:\n  length io2X = length tr2X_all - length vs\n\ngoal (1 subgoal):\n 1. path PM (io2X || drop (length vs) tr2X_all)\n     (target (vs || trV) (initial PM)) \\<and>\n    length io2X = length (drop (length vs) tr2X_all)", "by (metis (no_types) FSM.path_append_elim \\<open>take (length vs) tr2X_all = trV\\<close>\n            length_drop tr2X_all_def zip_append1)"], ["proof (state)\nthis:\n  path PM (io2X || drop (length vs) tr2X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io2X = length (drop (length vs) tr2X_all)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path PM (io2X || drop (length vs) tr2X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io2X = length (drop (length vs) tr2X_all)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  path PM (io2X || drop (length vs) tr2X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io2X = length (drop (length vs) tr2X_all)", "have io2X_lang : \"io2X \\<in> language_state PM ?qv\""], ["proof (prove)\nusing this:\n  path PM (io2X || drop (length vs) tr2X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io2X = length (drop (length vs) tr2X_all)\n\ngoal (1 subgoal):\n 1. io2X \\<in> LS PM (target (vs || trV) (initial PM))", "by auto"], ["proof (state)\nthis:\n  io2X \\<in> LS PM (target (vs || trV) (initial PM))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io2X \\<in> LS PM (target (vs || trV) (initial PM))", "obtain tr2X' where tr2X'_def : \"{tr . path PM (io2X || tr) ?qv \\<and> length io2X = length tr}\n                                          = { tr2X' }\""], ["proof (prove)\nusing this:\n  io2X \\<in> LS PM (target (vs || trV) (initial PM))\n\ngoal (1 subgoal):\n 1. (\\<And>tr2X'.\n        {tr.\n         path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n         length io2X = length tr} =\n        {tr2X'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using observable_path_unique_ex[of PM io2X ?qv] assms(2) assms(3) assms(7) observable_productF"], ["proof (prove)\nusing this:\n  io2X \\<in> LS PM (target (vs || trV) (initial PM))\n  \\<lbrakk>observable PM;\n   io2X \\<in> LS PM (target (vs || trV) (initial PM));\n   \\<And>tr.\n      {t. path PM (io2X || t) (target (vs || trV) (initial PM)) \\<and>\n          length io2X = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  observable M1\n  observable M2\n  productF M2 M1 FAIL PM\n  \\<lbrakk>observable ?M1.0; observable ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> observable ?PM\n\ngoal (1 subgoal):\n 1. (\\<And>tr2X'.\n        {tr.\n         path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n         length io2X = length tr} =\n        {tr2X'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  {tr.\n   path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n   length io2X = length tr} =\n  {tr2X'}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  {tr.\n   path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n   length io2X = length tr} =\n  {tr2X'}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"?tr2X \\<in> { tr . path PM (io2X || tr) ?qv \\<and> length io2X = length tr }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (length vs) tr2X_all\n    \\<in> {tr.\n           path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n           length io2X = length tr}", "using tr2X_def"], ["proof (prove)\nusing this:\n  path PM (io2X || drop (length vs) tr2X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io2X = length (drop (length vs) tr2X_all)\n\ngoal (1 subgoal):\n 1. drop (length vs) tr2X_all\n    \\<in> {tr.\n           path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n           length io2X = length tr}", "by auto"], ["proof (state)\nthis:\n  drop (length vs) tr2X_all\n  \\<in> {tr.\n         path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n         length io2X = length tr}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  {tr.\n   path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n   length io2X = length tr} =\n  {tr2X'}\n  drop (length vs) tr2X_all\n  \\<in> {tr.\n         path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n         length io2X = length tr}", "have tr2x_unique : \"tr2X' = ?tr2X\""], ["proof (prove)\nusing this:\n  {tr.\n   path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n   length io2X = length tr} =\n  {tr2X'}\n  drop (length vs) tr2X_all\n  \\<in> {tr.\n         path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n         length io2X = length tr}\n\ngoal (1 subgoal):\n 1. tr2X' = drop (length vs) tr2X_all", "by simp\n\n    \\<comment> \\<open>both paths reach the same state\\<close>"], ["proof (state)\nthis:\n  tr2X' = drop (length vs) tr2X_all\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"io_targets PM (initial PM) (vs @ io1X) = {(s,rep)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) (vs @ io1X) = {(s, rep)}", "using rep_state rep_ios_split"], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io1 = {(s, rep)} \\<and>\n  io_targets PM (initial PM) io2 = {(s, rep)}\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) (vs @ io1X) = {(s, rep)}", "by auto"], ["proof (state)\nthis:\n  io_targets PM (initial PM) (vs @ io1X) = {(s, rep)}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io_targets PM (initial PM) (vs @ io1X) = {(s, rep)}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"io_targets PM (initial PM) vs = {?qv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}", "using assms(8)"], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) vs = {(q2, q1)}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}", "by auto"], ["proof (state)\nthis:\n  io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  io_targets PM (initial PM) (vs @ io1X) = {(s, rep)}\n  io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}", "have rep_via_1 : \"io_targets PM ?qv io1X = {(s,rep)}\""], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) (vs @ io1X) = {(s, rep)}\n  io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}\n\ngoal (1 subgoal):\n 1. io_targets PM (target (vs || trV) (initial PM)) io1X = {(s, rep)}", "by (meson obs_PM observable_io_targets_split)"], ["proof (state)\nthis:\n  io_targets PM (target (vs || trV) (initial PM)) io1X = {(s, rep)}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets PM (target (vs || trV) (initial PM)) io1X = {(s, rep)}", "have rep_tgt_1 : \"target (io1X || tr1X') ?qv = (s,rep)\""], ["proof (prove)\nusing this:\n  io_targets PM (target (vs || trV) (initial PM)) io1X = {(s, rep)}\n\ngoal (1 subgoal):\n 1. target (io1X || tr1X') (target (vs || trV) (initial PM)) = (s, rep)", "using obs_PM observable_io_target_unique_target[of PM ?qv io1X \"(s,rep)\"] tr1X'_def"], ["proof (prove)\nusing this:\n  io_targets PM (target (vs || trV) (initial PM)) io1X = {(s, rep)}\n  observable PM\n  \\<lbrakk>observable PM;\n   io_targets PM (target (vs || trV) (initial PM)) io1X = {(s, rep)};\n   path PM (io1X || ?tr) (target (vs || trV) (initial PM));\n   length io1X = length ?tr\\<rbrakk>\n  \\<Longrightarrow> target (io1X || ?tr) (target (vs || trV) (initial PM)) =\n                    (s, rep)\n  {tr.\n   path PM (io1X || tr) (target (vs || trV) (initial PM)) \\<and>\n   length io1X = length tr} =\n  {tr1X'}\n\ngoal (1 subgoal):\n 1. target (io1X || tr1X') (target (vs || trV) (initial PM)) = (s, rep)", "by blast"], ["proof (state)\nthis:\n  target (io1X || tr1X') (target (vs || trV) (initial PM)) = (s, rep)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have length_1 : \"length (io1X || tr1X') > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (io1X || tr1X')", "using \\<open>length vs < length io1\\<close> rep_ios_split tr1X_def tr1x_unique"], ["proof (prove)\nusing this:\n  length vs < length io1\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs\n  path PM (io1X || drop (length vs) tr1X_all)\n   (target (vs || trV) (initial PM)) \\<and>\n  length io1X = length (drop (length vs) tr1X_all)\n  tr1X' = drop (length vs) tr1X_all\n\ngoal (1 subgoal):\n 1. 0 < length (io1X || tr1X')", "by auto"], ["proof (state)\nthis:\n  0 < length (io1X || tr1X')\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have tr1X_alt_def : \"tr1X' = take (length io1X) tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr1X' = take (length io1X) tr", "by (metis (no_types) assms(10) assms(9) obs_PM observable_path_prefix qv_simp\n          rep_ios_split tr1X_def tr1x_unique)"], ["proof (state)\nthis:\n  tr1X' = take (length io1X) tr\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  tr1X' = take (length io1X) tr\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"io1X = take (length io1X) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io1X = take (length io1X) xs", "using rep_ios_split"], ["proof (prove)\nusing this:\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs\n\ngoal (1 subgoal):\n 1. io1X = take (length io1X) xs", "by (metis append_eq_conv_conj prefixE)"], ["proof (state)\nthis:\n  io1X = take (length io1X) xs\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  tr1X' = take (length io1X) tr\n  io1X = take (length io1X) xs", "have \"(io1X || tr1X') = take (length io1X) (xs || tr)\""], ["proof (prove)\nusing this:\n  tr1X' = take (length io1X) tr\n  io1X = take (length io1X) xs\n\ngoal (1 subgoal):\n 1. io1X || tr1X' = take (length io1X) (xs || tr)", "by (metis take_zip)"], ["proof (state)\nthis:\n  io1X || tr1X' = take (length io1X) (xs || tr)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io1X || tr1X' = take (length io1X) (xs || tr)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"length (xs || tr) \\<ge> length (io1X || tr1X')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (io1X || tr1X') \\<le> length (xs || tr)", "by (metis (no_types) \\<open>io1X = take (length io1X) xs\\<close> assms(10) length_take length_zip\n          nat_le_linear take_all tr1X_def tr1x_unique)"], ["proof (state)\nthis:\n  length (io1X || tr1X') \\<le> length (xs || tr)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  io1X || tr1X' = take (length io1X) (xs || tr)\n  length (io1X || tr1X') \\<le> length (xs || tr)", "have rep_idx_1 : \"(states (xs || tr) ?qv) ! ((length io1X) - 1) = (s,rep)\""], ["proof (prove)\nusing this:\n  io1X || tr1X' = take (length io1X) (xs || tr)\n  length (io1X || tr1X') \\<le> length (xs || tr)\n\ngoal (1 subgoal):\n 1. states (xs || tr) (target (vs || trV) (initial PM)) !\n    (length io1X - 1) =\n    (s, rep)", "by (metis (no_types, lifting) One_nat_def Suc_less_eq Suc_pred rep_tgt_1 length_1\n          less_Suc_eq_le map_snd_zip scan_length scan_nth states_alt_def tr1X_def tr1x_unique)"], ["proof (state)\nthis:\n  states (xs || tr) (target (vs || trV) (initial PM)) ! (length io1X - 1) =\n  (s, rep)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"io_targets PM (initial PM) (vs @ io2X) = {(s,rep)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) (vs @ io2X) = {(s, rep)}", "using rep_state rep_ios_split"], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io1 = {(s, rep)} \\<and>\n  io_targets PM (initial PM) io2 = {(s, rep)}\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) (vs @ io2X) = {(s, rep)}", "by auto"], ["proof (state)\nthis:\n  io_targets PM (initial PM) (vs @ io2X) = {(s, rep)}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io_targets PM (initial PM) (vs @ io2X) = {(s, rep)}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"io_targets PM (initial PM) vs = {?qv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}", "using assms(8)"], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) vs = {(q2, q1)}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}", "by auto"], ["proof (state)\nthis:\n  io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  io_targets PM (initial PM) (vs @ io2X) = {(s, rep)}\n  io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}", "have rep_via_2 : \"io_targets PM ?qv io2X = {(s,rep)}\""], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) (vs @ io2X) = {(s, rep)}\n  io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}\n\ngoal (1 subgoal):\n 1. io_targets PM (target (vs || trV) (initial PM)) io2X = {(s, rep)}", "by (meson obs_PM observable_io_targets_split)"], ["proof (state)\nthis:\n  io_targets PM (target (vs || trV) (initial PM)) io2X = {(s, rep)}\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets PM (target (vs || trV) (initial PM)) io2X = {(s, rep)}", "have rep_tgt_2 : \"target (io2X || tr2X') ?qv = (s,rep)\""], ["proof (prove)\nusing this:\n  io_targets PM (target (vs || trV) (initial PM)) io2X = {(s, rep)}\n\ngoal (1 subgoal):\n 1. target (io2X || tr2X') (target (vs || trV) (initial PM)) = (s, rep)", "using obs_PM observable_io_target_unique_target[of PM ?qv io2X \"(s,rep)\"] tr2X'_def"], ["proof (prove)\nusing this:\n  io_targets PM (target (vs || trV) (initial PM)) io2X = {(s, rep)}\n  observable PM\n  \\<lbrakk>observable PM;\n   io_targets PM (target (vs || trV) (initial PM)) io2X = {(s, rep)};\n   path PM (io2X || ?tr) (target (vs || trV) (initial PM));\n   length io2X = length ?tr\\<rbrakk>\n  \\<Longrightarrow> target (io2X || ?tr) (target (vs || trV) (initial PM)) =\n                    (s, rep)\n  {tr.\n   path PM (io2X || tr) (target (vs || trV) (initial PM)) \\<and>\n   length io2X = length tr} =\n  {tr2X'}\n\ngoal (1 subgoal):\n 1. target (io2X || tr2X') (target (vs || trV) (initial PM)) = (s, rep)", "by blast"], ["proof (state)\nthis:\n  target (io2X || tr2X') (target (vs || trV) (initial PM)) = (s, rep)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  target (io2X || tr2X') (target (vs || trV) (initial PM)) = (s, rep)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have length_2 : \"length (io2X || tr2X') > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (io2X || tr2X')", "by (metis \\<open>length vs < length io1\\<close> append.right_neutral length_0_conv length_zip less_asym min.idem neq0_conv rep_ios_def rep_ios_split tr2X_def tr2x_unique)"], ["proof (state)\nthis:\n  0 < length (io2X || tr2X')\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have tr2X_alt_def : \"tr2X' = take (length io2X) tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr2X' = take (length io2X) tr", "by (metis (no_types) assms(10) assms(9) obs_PM observable_path_prefix qv_simp rep_ios_split tr2X_def tr2x_unique)"], ["proof (state)\nthis:\n  tr2X' = take (length io2X) tr\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  tr2X' = take (length io2X) tr\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"io2X = take (length io2X) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io2X = take (length io2X) xs", "using rep_ios_split"], ["proof (prove)\nusing this:\n  io1 = vs @ io1X \\<and>\n  prefix io1X xs \\<and> io2 = vs @ io2X \\<and> prefix io2X xs\n\ngoal (1 subgoal):\n 1. io2X = take (length io2X) xs", "by (metis append_eq_conv_conj prefixE)"], ["proof (state)\nthis:\n  io2X = take (length io2X) xs\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  target (io2X || tr2X') (target (vs || trV) (initial PM)) = (s, rep)\n  tr2X' = take (length io2X) tr\n  io2X = take (length io2X) xs", "have \"(io2X || tr2X') = take (length io2X) (xs || tr)\""], ["proof (prove)\nusing this:\n  target (io2X || tr2X') (target (vs || trV) (initial PM)) = (s, rep)\n  tr2X' = take (length io2X) tr\n  io2X = take (length io2X) xs\n\ngoal (1 subgoal):\n 1. io2X || tr2X' = take (length io2X) (xs || tr)", "by (metis take_zip)"], ["proof (state)\nthis:\n  io2X || tr2X' = take (length io2X) (xs || tr)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io2X || tr2X' = take (length io2X) (xs || tr)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"length (xs || tr) \\<ge> length (io2X || tr2X')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (io2X || tr2X') \\<le> length (xs || tr)", "using calculation"], ["proof (prove)\nusing this:\n  io2X || tr2X' = take (length io2X) (xs || tr)\n\ngoal (1 subgoal):\n 1. length (io2X || tr2X') \\<le> length (xs || tr)", "by auto"], ["proof (state)\nthis:\n  length (io2X || tr2X') \\<le> length (xs || tr)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  io2X || tr2X' = take (length io2X) (xs || tr)\n  length (io2X || tr2X') \\<le> length (xs || tr)", "have rep_idx_2 : \"(states (xs || tr) ?qv) ! ((length io2X) - 1) = (s,rep)\""], ["proof (prove)\nusing this:\n  io2X || tr2X' = take (length io2X) (xs || tr)\n  length (io2X || tr2X') \\<le> length (xs || tr)\n\ngoal (1 subgoal):\n 1. states (xs || tr) (target (vs || trV) (initial PM)) !\n    (length io2X - 1) =\n    (s, rep)", "by (metis (no_types, lifting) One_nat_def Suc_less_eq Suc_pred rep_tgt_2 length_2\n          less_Suc_eq_le map_snd_zip scan_length scan_nth states_alt_def tr2X_def tr2x_unique)\n\n\n    \\<comment> \\<open>thus the distinctness assumption is violated\\<close>"], ["proof (state)\nthis:\n  states (xs || tr) (target (vs || trV) (initial PM)) ! (length io2X - 1) =\n  (s, rep)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"length io1X \\<noteq> length io2X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length io1X \\<noteq> length io2X", "by (metis \\<open>io1X = take (length io1X) xs\\<close> \\<open>io2X = take (length io2X) xs\\<close> less_irrefl\n          rep_ios_def rep_ios_split)"], ["proof (state)\nthis:\n  length io1X \\<noteq> length io2X\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  length io1X \\<noteq> length io2X\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"(states (xs || tr) ?qv) ! ((length io1X) - 1)\n                    = (states (xs || tr) ?qv) ! ((length io2X) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (xs || tr) (target (vs || trV) (initial PM)) !\n    (length io1X - 1) =\n    states (xs || tr) (target (vs || trV) (initial PM)) ! (length io2X - 1)", "using rep_idx_1 rep_idx_2"], ["proof (prove)\nusing this:\n  states (xs || tr) (target (vs || trV) (initial PM)) ! (length io1X - 1) =\n  (s, rep)\n  states (xs || tr) (target (vs || trV) (initial PM)) ! (length io2X - 1) =\n  (s, rep)\n\ngoal (1 subgoal):\n 1. states (xs || tr) (target (vs || trV) (initial PM)) !\n    (length io1X - 1) =\n    states (xs || tr) (target (vs || trV) (initial PM)) ! (length io2X - 1)", "by simp"], ["proof (state)\nthis:\n  states (xs || tr) (target (vs || trV) (initial PM)) ! (length io1X - 1) =\n  states (xs || tr) (target (vs || trV) (initial PM)) ! (length io2X - 1)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  length io1X \\<noteq> length io2X\n  states (xs || tr) (target (vs || trV) (initial PM)) ! (length io1X - 1) =\n  states (xs || tr) (target (vs || trV) (initial PM)) ! (length io2X - 1)", "have \"\\<not> (distinct (states (xs || tr) ?qv))\""], ["proof (prove)\nusing this:\n  length io1X \\<noteq> length io2X\n  states (xs || tr) (target (vs || trV) (initial PM)) ! (length io1X - 1) =\n  states (xs || tr) (target (vs || trV) (initial PM)) ! (length io2X - 1)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (target (vs || trV) (initial PM)))", "by (metis Suc_less_eq \\<open>io1X = take (length io1X) xs\\<close>\n          \\<open>io1X || tr1X' = take (length io1X) (xs || tr)\\<close> \\<open>io2X = take (length io2X) xs\\<close>\n          \\<open>io2X || tr2X' = take (length io2X) (xs || tr)\\<close>\n          \\<open>length (io1X || tr1X') \\<le> length (xs || tr)\\<close> \\<open>length (io2X || tr2X') \\<le> length (xs || tr)\\<close>\n          assms(10) diff_Suc_1 distinct_conv_nth gr0_conv_Suc le_imp_less_Suc length_1 length_2\n          length_take map_snd_zip scan_length states_alt_def)"], ["proof (state)\nthis:\n  \\<not> distinct (states (xs || tr) (target (vs || trV) (initial PM)))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) \\<noteq>\n    card (R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct (states (xs || tr) (target (vs || trV) (initial PM)))", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> distinct (states (xs || tr) (target (vs || trV) (initial PM)))\n\ngoal (1 subgoal):\n 1. False", "by (metis assms(11) states_alt_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "ultimately"], ["proof (chain)\npicking this:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (R M2 s vs xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n  card (\\<Union> (io_targets PM (initial PM) ` R M2 s vs xs)) =\n  card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n    card (R M2 s vs xs)", "by linarith"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n  card (R M2 s vs xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_state_component_2 :\n  assumes \"io \\<in> (R M2 s vs xs)\"\n  and     \"observable M2\"\nshows \"io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "have \"s \\<in> io_targets M2 (initial M2) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> io_targets M2 (initial M2) io", "using assms(1)"], ["proof (prove)\nusing this:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. s \\<in> io_targets M2 (initial M2) io", "by auto"], ["proof (state)\nthis:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "moreover"], ["proof (state)\nthis:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "have \"io \\<in> language_state M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> L M2", "using calculation"], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. io \\<in> L M2", "by auto"], ["proof (state)\nthis:\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2", "show \"io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "using assms(2) io_targets_observable_singleton_ex"], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2\n  observable M2\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q2. io_targets ?M ?q1.0 ?io = {q2}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "by (metis singletonD)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {s}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_union_card_is_suffix_length :\n  assumes \"OFSM M2\"\n  and     \"io@xs \\<in> L M2\"\nshows \"sum (\\<lambda> q . card (R M2 q io xs)) (nodes M2) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs", "using assms"], ["proof (prove)\nusing this:\n  OFSM M2\n  io @ xs \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs", "proof (induction xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>OFSM M2; io @ [] \\<in> L M2\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2. card (R M2 q io [])) =\n                      length []\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "case Nil"], ["proof (state)\nthis:\n  OFSM M2\n  io @ [] \\<in> L M2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>OFSM M2; io @ [] \\<in> L M2\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2. card (R M2 q io [])) =\n                      length []\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io [])) = length []", "by (simp add: sum.neutral)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io [])) = length []\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs\n  OFSM M2\n  io @ xs @ [x] \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "have \"finite (nodes M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M2)", "using assms"], ["proof (prove)\nusing this:\n  OFSM M2\n  io @ xs \\<in> L M2\n\ngoal (1 subgoal):\n 1. finite (nodes M2)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "have R_update : \"\\<And> q . R M2 q io (xs@[x]) = (if (q \\<in> io_targets M2 (initial M2) (io @ xs @ [x]))\n                                    then insert (io@xs@[x]) (R M2 q io xs)\n                                    else R M2 q io xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       R M2 q io (xs @ [x]) =\n       (if q \\<in> io_targets M2 (initial M2) (io @ xs @ [x])\n        then insert (io @ xs @ [x]) (R M2 q io xs) else R M2 q io xs)", "by auto"], ["proof (state)\nthis:\n  R M2 ?q io (xs @ [x]) =\n  (if ?q \\<in> io_targets M2 (initial M2) (io @ xs @ [x])\n   then insert (io @ xs @ [x]) (R M2 ?q io xs) else R M2 ?q io xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "obtain q where \"io_targets M2 (initial M2) (io @ xs @ [x]) = {q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        io_targets M2 (initial M2) (io @ xs @ [x]) = {q} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(1) io_targets_observable_singleton_ex snoc.prems(2))"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (io @ xs @ [x]) = {q}\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) (io @ xs @ [x]) = {q}", "have \"R M2 q io (xs@[x]) = insert (io@xs@[x]) (R M2 q io xs)\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (io @ xs @ [x]) = {q}\n\ngoal (1 subgoal):\n 1. R M2 q io (xs @ [x]) = insert (io @ xs @ [x]) (R M2 q io xs)", "using R_update"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (io @ xs @ [x]) = {q}\n  R M2 ?q io (xs @ [x]) =\n  (if ?q \\<in> io_targets M2 (initial M2) (io @ xs @ [x])\n   then insert (io @ xs @ [x]) (R M2 ?q io xs) else R M2 ?q io xs)\n\ngoal (1 subgoal):\n 1. R M2 q io (xs @ [x]) = insert (io @ xs @ [x]) (R M2 q io xs)", "by auto"], ["proof (state)\nthis:\n  R M2 q io (xs @ [x]) = insert (io @ xs @ [x]) (R M2 q io xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  R M2 q io (xs @ [x]) = insert (io @ xs @ [x]) (R M2 q io xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "have \"(io@xs@[x]) \\<notin> (R M2 q io xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io @ xs @ [x] \\<notin> R M2 q io xs", "by auto"], ["proof (state)\nthis:\n  io @ xs @ [x] \\<notin> R M2 q io xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  R M2 q io (xs @ [x]) = insert (io @ xs @ [x]) (R M2 q io xs)\n  io @ xs @ [x] \\<notin> R M2 q io xs", "have \"card (R M2 q io (xs@[x])) = Suc (card (R M2 q io xs))\""], ["proof (prove)\nusing this:\n  R M2 q io (xs @ [x]) = insert (io @ xs @ [x]) (R M2 q io xs)\n  io @ xs @ [x] \\<notin> R M2 q io xs\n\ngoal (1 subgoal):\n 1. card (R M2 q io (xs @ [x])) = Suc (card (R M2 q io xs))", "by (metis card_insert_disjoint finite_R)"], ["proof (state)\nthis:\n  card (R M2 q io (xs @ [x])) = Suc (card (R M2 q io xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "have \"q \\<in> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> nodes M2", "by (metis (full_types) FSM.nodes.initial \\<open>io_targets M2 (initial M2) (io@xs @ [x]) = {q}\\<close>\n        insertI1 io_targets_nodes)"], ["proof (state)\nthis:\n  q \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "have \"\\<forall> q' . q' \\<noteq> q \\<longrightarrow> R M2 q' io (xs@[x]) = R M2 q' io xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q'.\n       q' \\<noteq> q \\<longrightarrow> R M2 q' io (xs @ [x]) = R M2 q' io xs", "using \\<open>io_targets M2 (initial M2) (io@xs @ [x]) = {q}\\<close> R_update"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (io @ xs @ [x]) = {q}\n  R M2 ?q io (xs @ [x]) =\n  (if ?q \\<in> io_targets M2 (initial M2) (io @ xs @ [x])\n   then insert (io @ xs @ [x]) (R M2 ?q io xs) else R M2 ?q io xs)\n\ngoal (1 subgoal):\n 1. \\<forall>q'.\n       q' \\<noteq> q \\<longrightarrow> R M2 q' io (xs @ [x]) = R M2 q' io xs", "by auto"], ["proof (state)\nthis:\n  \\<forall>q'.\n     q' \\<noteq> q \\<longrightarrow> R M2 q' io (xs @ [x]) = R M2 q' io xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "then"], ["proof (chain)\npicking this:\n  \\<forall>q'.\n     q' \\<noteq> q \\<longrightarrow> R M2 q' io (xs @ [x]) = R M2 q' io xs", "have \"\\<forall> q' . q' \\<noteq> q \\<longrightarrow> card (R M2 q' io (xs@[x])) = card (R M2 q' io xs)\""], ["proof (prove)\nusing this:\n  \\<forall>q'.\n     q' \\<noteq> q \\<longrightarrow> R M2 q' io (xs @ [x]) = R M2 q' io xs\n\ngoal (1 subgoal):\n 1. \\<forall>q'.\n       q' \\<noteq> q \\<longrightarrow>\n       card (R M2 q' io (xs @ [x])) = card (R M2 q' io xs)", "by auto"], ["proof (state)\nthis:\n  \\<forall>q'.\n     q' \\<noteq> q \\<longrightarrow>\n     card (R M2 q' io (xs @ [x])) = card (R M2 q' io xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "then"], ["proof (chain)\npicking this:\n  \\<forall>q'.\n     q' \\<noteq> q \\<longrightarrow>\n     card (R M2 q' io (xs @ [x])) = card (R M2 q' io xs)", "have \"(\\<Sum>q\\<in>(nodes M2 - {q}). card (R M2 q io (xs@[x])))\n              = (\\<Sum>q\\<in>(nodes M2 - {q}). card (R M2 q io xs))\""], ["proof (prove)\nusing this:\n  \\<forall>q'.\n     q' \\<noteq> q \\<longrightarrow>\n     card (R M2 q' io (xs @ [x])) = card (R M2 q' io xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "have \"(\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs@[x])))\n                  = (\\<Sum>q\\<in>(nodes M2 - {q}). card (R M2 q io (xs@[x]))) + (card (R M2 q io (xs@[x])))\"\n                \"(\\<Sum>q\\<in>nodes M2. card (R M2 q io xs))\n                  = (\\<Sum>q\\<in>(nodes M2 - {q}). card (R M2 q io xs)) + (card (R M2 q io xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) +\n    card (R M2 q io (xs @ [x])) &&&\n    (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs)) + card (R M2 q io xs)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) +\n    card (R M2 q io (xs @ [x]))\n 2. (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs)) + card (R M2 q io xs)", "have \"\\<forall>C c f. (infinite C \\<or> (c::'c) \\<notin> C) \\<or> sum f C = (f c::nat) + sum f (C - {c})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C c f.\n       (infinite C \\<or> c \\<notin> C) \\<or> sum f C = f c + sum f (C - {c})", "by (meson sum.remove)"], ["proof (state)\nthis:\n  \\<forall>C c f.\n     (infinite C \\<or> c \\<notin> C) \\<or> sum f C = f c + sum f (C - {c})\n\ngoal (2 subgoals):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) +\n    card (R M2 q io (xs @ [x]))\n 2. (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs)) + card (R M2 q io xs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>C c f.\n     (infinite C \\<or> c \\<notin> C) \\<or> sum f C = f c + sum f (C - {c})", "show \"(\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs@[x])))\n                = (\\<Sum>q\\<in>(nodes M2 - {q}). card (R M2 q io (xs@[x]))) + (card (R M2 q io (xs@[x])))\"\n              \"(\\<Sum>q\\<in>nodes M2. card (R M2 q io xs))\n                = (\\<Sum>q\\<in>(nodes M2 - {q}). card (R M2 q io xs)) + (card (R M2 q io xs))\""], ["proof (prove)\nusing this:\n  \\<forall>C c f.\n     (infinite C \\<or> c \\<notin> C) \\<or> sum f C = f c + sum f (C - {c})\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) +\n    card (R M2 q io (xs @ [x])) &&&\n    (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs)) + card (R M2 q io xs)", "using \\<open>finite (nodes M2)\\<close> \\<open>q \\<in> nodes M2\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>C c f.\n     (infinite C \\<or> c \\<notin> C) \\<or> sum f C = f c + sum f (C - {c})\n  finite (nodes M2)\n  q \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) +\n    card (R M2 q io (xs @ [x])) &&&\n    (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n    (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs)) + card (R M2 q io xs)", "by presburger+"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) +\n  card (R M2 q io (xs @ [x]))\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs)) + card (R M2 q io xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) +\n  card (R M2 q io (xs @ [x]))\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs)) + card (R M2 q io xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs))\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) +\n  card (R M2 q io (xs @ [x]))\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs)) + card (R M2 q io xs)", "have \"(\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs@[x])))\n                    = Suc (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs))\""], ["proof (prove)\nusing this:\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs))\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) +\n  card (R M2 q io (xs @ [x]))\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs)) + card (R M2 q io xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n    Suc (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs))", "using \\<open>card (R M2 q io (xs@[x])) = Suc (card (R M2 q io xs))\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs))\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io (xs @ [x]))) +\n  card (R M2 q io (xs @ [x]))\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n  (\\<Sum>q\\<in>nodes M2 - {q}. card (R M2 q io xs)) + card (R M2 q io xs)\n  card (R M2 q io (xs @ [x])) = Suc (card (R M2 q io xs))\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n    Suc (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs))", "by presburger"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) =\n  Suc (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "have \"(\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs", "using snoc.IH snoc.prems language_state_prefix[of \"io@xs\" \"[x]\" M2 \"initial M2\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs\n  OFSM M2\n  io @ xs @ [x] \\<in> L M2\n  (io @ xs) @ [x] \\<in> L M2 \\<Longrightarrow> io @ xs \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n             \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n                               length xs;\n     OFSM M2; io @ xs @ [x] \\<in> L M2;\n     (io @ xs) @ [x] \\<in> L M2 \\<Longrightarrow>\n     io @ xs \\<in> L M2\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) =\n                      length xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs", "by (metis (no_types) \\<open>(io @ xs) @ [x] \\<in> L M2 \\<Longrightarrow> io @ xs \\<in> L M2\\<close>\n          \\<open>OFSM M2\\<close> \\<open>io @ xs @ [x] \\<in> L M2\\<close> append.assoc snoc.IH)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>OFSM M2; io @ xs \\<in> L M2\\<rbrakk>\n                \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                                     card (R M2 q io xs)) =\n                                  length xs;\n        OFSM M2; io @ xs @ [x] \\<in> L M2\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2.\n                            card (R M2 q io (xs @ [x]))) =\n                         length (xs @ [x])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) = length (xs @ [x])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) = length (xs @ [x])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) = length (xs @ [x])", "by (metis (no_types)\n          \\<open>(\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) = Suc (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs))\\<close>\n          \\<open>(\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs\\<close> length_append_singleton)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) = length (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io (xs @ [x]))) = length (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_state_repetition_via_long_sequence :\n  assumes \"OFSM M\"\n  and     \"card (nodes M) \\<le> m\"\n  and     \"Suc (m * m) \\<le> length xs\"\n  and     \"vs@xs \\<in> L M\"\nshows \"\\<exists> q \\<in> nodes M . card (R M q vs xs) > m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M. m < card (R M q vs xs)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>q\\<in>nodes M. m < card (R M q vs xs))\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>q\\<in>nodes M. m < card (R M q vs xs))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>q\\<in>nodes M. m < card (R M q vs xs))", "have \"\\<forall> q \\<in> nodes M . card (R M q vs xs) \\<le> m\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>q\\<in>nodes M. m < card (R M q vs xs))\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>nodes M. card (R M q vs xs) \\<le> m", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>nodes M. card (R M q vs xs) \\<le> m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>nodes M. card (R M q vs xs) \\<le> m", "have \"sum (\\<lambda> q . card (R M q vs xs)) (nodes M) \\<le> sum (\\<lambda> q . m) (nodes M)\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>nodes M. card (R M q vs xs) \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M. m)", "by (meson sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M. m)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M. m)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "have \"sum (\\<lambda> q . m) (nodes M) \\<le> m * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M. m) \\<le> m * m", "using assms(2)"], ["proof (prove)\nusing this:\n  |M| \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M. m) \\<le> m * m", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M. m) \\<le> m * m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M. m)\n  (\\<Sum>q\\<in>nodes M. m) \\<le> m * m", "have \"sum (\\<lambda> q . card (R M q vs xs)) (nodes M) \\<le> m * m\""], ["proof (prove)\nusing this:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M. m)\n  (\\<Sum>q\\<in>nodes M. m) \\<le> m * m\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> m * m", "by presburger"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> m * m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> m * m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "have \"Suc (m*m) \\<le> sum (\\<lambda> q . card (R M q vs xs)) (nodes M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (m * m) \\<le> (\\<Sum>q\\<in>nodes M. card (R M q vs xs))", "using R_union_card_is_suffix_length[OF assms(1), of vs xs] assms(4,3)"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M \\<Longrightarrow>\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) = length xs\n  vs @ xs \\<in> L M\n  Suc (m * m) \\<le> length xs\n\ngoal (1 subgoal):\n 1. Suc (m * m) \\<le> (\\<Sum>q\\<in>nodes M. card (R M q vs xs))", "by auto"], ["proof (state)\nthis:\n  Suc (m * m) \\<le> (\\<Sum>q\\<in>nodes M. card (R M q vs xs))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> m * m\n  Suc (m * m) \\<le> (\\<Sum>q\\<in>nodes M. card (R M q vs xs))", "show \"False\""], ["proof (prove)\nusing this:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> m * m\n  Suc (m * m) \\<le> (\\<Sum>q\\<in>nodes M. card (R M q vs xs))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_state_repetition_distribution :\n  assumes \"OFSM M\"\n  and     \"Suc (card (nodes M) * m) \\<le> length xs\"\n  and     \"vs@xs \\<in> L M\"\nshows \"\\<exists> q \\<in> nodes M . card (R M q vs xs) > m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M. m < card (R M q vs xs)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>q\\<in>nodes M. m < card (R M q vs xs))\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>q\\<in>nodes M. m < card (R M q vs xs))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>q\\<in>nodes M. m < card (R M q vs xs))", "have \"\\<forall> q \\<in> nodes M . card (R M q vs xs) \\<le> m\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>q\\<in>nodes M. m < card (R M q vs xs))\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>nodes M. card (R M q vs xs) \\<le> m", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>nodes M. card (R M q vs xs) \\<le> m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>nodes M. card (R M q vs xs) \\<le> m", "have \"sum (\\<lambda> q . card (R M q vs xs)) (nodes M) \\<le> sum (\\<lambda> q . m) (nodes M)\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>nodes M. card (R M q vs xs) \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M. m)", "by (meson sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M. m)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M. m)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "have \"sum (\\<lambda> q . m) (nodes M) \\<le> card (nodes M) * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M. m) \\<le> |M| * m", "using assms(2)"], ["proof (prove)\nusing this:\n  Suc (|M| * m) \\<le> length xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M. m) \\<le> |M| * m", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M. m) \\<le> |M| * m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M. m)\n  (\\<Sum>q\\<in>nodes M. m) \\<le> |M| * m", "have \"sum (\\<lambda> q . card (R M q vs xs)) (nodes M) \\<le> card (nodes M) * m\""], ["proof (prove)\nusing this:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M. m)\n  (\\<Sum>q\\<in>nodes M. m) \\<le> |M| * m\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> |M| * m", "by presburger"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> |M| * m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> |M| * m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "have \"Suc (card (nodes M)*m) \\<le> sum (\\<lambda> q . card (R M q vs xs)) (nodes M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (|M| * m) \\<le> (\\<Sum>q\\<in>nodes M. card (R M q vs xs))", "using R_union_card_is_suffix_length[OF assms(1), of vs xs] assms(3,2)"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M \\<Longrightarrow>\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) = length xs\n  vs @ xs \\<in> L M\n  Suc (|M| * m) \\<le> length xs\n\ngoal (1 subgoal):\n 1. Suc (|M| * m) \\<le> (\\<Sum>q\\<in>nodes M. card (R M q vs xs))", "by auto"], ["proof (state)\nthis:\n  Suc (|M| * m) \\<le> (\\<Sum>q\\<in>nodes M. card (R M q vs xs))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>nodes M.\n               m < card (R M q vs xs)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> |M| * m\n  Suc (|M| * m) \\<le> (\\<Sum>q\\<in>nodes M. card (R M q vs xs))", "show \"False\""], ["proof (prove)\nusing this:\n  (\\<Sum>q\\<in>nodes M. card (R M q vs xs)) \\<le> |M| * m\n  Suc (|M| * m) \\<le> (\\<Sum>q\\<in>nodes M. card (R M q vs xs))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Function RP \\<close>"], ["", "text \\<open>\nFunction @{verbatim RP} extends function @{verbatim MR} by adding all elements from a set of\nIO-sequences that also reach the given state.\n\\<close>"], ["", "fun RP :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \\<Rightarrow> ('in \\<times> 'out) list\n            \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> ('in \\<times> 'out) list set\n            \\<Rightarrow> ('in \\<times> 'out) list set\"\n  where\n  \"RP M s vs xs V'' = R M s vs xs\n                      \\<union> {vs' \\<in> V'' . io_targets M (initial M) vs' = {s}}\""], ["", "lemma RP_from_R:\n  assumes \"is_det_state_cover M2 V\"\n  and     \"V'' \\<in> Perm V M1\"\nshows \"RP M2 s vs xs V'' = R M2 s vs xs\n        \\<or> (\\<exists> vs' \\<in> V'' . vs' \\<notin> R M2 s vs xs \\<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n    (\\<exists>vs'\\<in>V''.\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "assume assm : \"\\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n        (\\<exists>vs'\\<in>V''. vs' \\<notin> R M2 s vs xs \\<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)))\""], ["proof (state)\nthis:\n  \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n          (\\<exists>vs'\\<in>V''.\n              vs' \\<notin> R M2 s vs xs \\<and>\n              RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n          (\\<exists>vs'\\<in>V''.\n              vs' \\<notin> R M2 s vs xs \\<and>\n              RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "have \"R M2 s vs xs \\<subseteq> RP M2 s vs xs V''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R M2 s vs xs \\<subseteq> RP M2 s vs xs V''", "by simp"], ["proof (state)\nthis:\n  R M2 s vs xs \\<subseteq> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  R M2 s vs xs \\<subseteq> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "have \"RP M2 s vs xs V'' \\<subseteq> R M2 s vs xs \\<union> V''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<subseteq> R M2 s vs xs \\<union> V''", "by auto"], ["proof (state)\nthis:\n  RP M2 s vs xs V'' \\<subseteq> R M2 s vs xs \\<union> V''\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n          (\\<exists>vs'\\<in>V''.\n              vs' \\<notin> R M2 s vs xs \\<and>\n              RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)))\n  R M2 s vs xs \\<subseteq> RP M2 s vs xs V''\n  RP M2 s vs xs V'' \\<subseteq> R M2 s vs xs \\<union> V''", "obtain vs1 vs2 where vs_def :\n       \"vs1 \\<noteq> vs2 \\<and> vs1 \\<in> V'' \\<and> vs2 \\<in> V''\n        \\<and> vs1 \\<notin> R M2 s vs xs \\<and> vs2 \\<notin> R M2 s vs xs\n        \\<and> vs1 \\<in> RP M2 s vs xs V'' \\<and> vs2 \\<in> RP M2 s vs xs V''\""], ["proof (prove)\nusing this:\n  \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n          (\\<exists>vs'\\<in>V''.\n              vs' \\<notin> R M2 s vs xs \\<and>\n              RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)))\n  R M2 s vs xs \\<subseteq> RP M2 s vs xs V''\n  RP M2 s vs xs V'' \\<subseteq> R M2 s vs xs \\<union> V''\n\ngoal (1 subgoal):\n 1. (\\<And>vs1 vs2.\n        vs1 \\<noteq> vs2 \\<and>\n        vs1 \\<in> V'' \\<and>\n        vs2 \\<in> V'' \\<and>\n        vs1 \\<notin> R M2 s vs xs \\<and>\n        vs2 \\<notin> R M2 s vs xs \\<and>\n        vs1 \\<in> RP M2 s vs xs V'' \\<and>\n        vs2 \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vs1 \\<noteq> vs2 \\<and>\n  vs1 \\<in> V'' \\<and>\n  vs2 \\<in> V'' \\<and>\n  vs1 \\<notin> R M2 s vs xs \\<and>\n  vs2 \\<notin> R M2 s vs xs \\<and>\n  vs1 \\<in> RP M2 s vs xs V'' \\<and> vs2 \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  vs1 \\<noteq> vs2 \\<and>\n  vs1 \\<in> V'' \\<and>\n  vs2 \\<in> V'' \\<and>\n  vs1 \\<notin> R M2 s vs xs \\<and>\n  vs2 \\<notin> R M2 s vs xs \\<and>\n  vs1 \\<in> RP M2 s vs xs V'' \\<and> vs2 \\<in> RP M2 s vs xs V''", "have \"io_targets M2 (initial M2) vs1 = {s} \\<and> io_targets M2 (initial M2) vs2 = {s}\""], ["proof (prove)\nusing this:\n  vs1 \\<noteq> vs2 \\<and>\n  vs1 \\<in> V'' \\<and>\n  vs2 \\<in> V'' \\<and>\n  vs1 \\<notin> R M2 s vs xs \\<and>\n  vs2 \\<notin> R M2 s vs xs \\<and>\n  vs1 \\<in> RP M2 s vs xs V'' \\<and> vs2 \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs1 = {s} \\<and>\n    io_targets M2 (initial M2) vs2 = {s}", "by (metis (mono_tags, lifting) RP.simps Un_iff mem_Collect_eq)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) vs1 = {s} \\<and>\n  io_targets M2 (initial M2) vs2 = {s}\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) vs1 = {s} \\<and>\n  io_targets M2 (initial M2) vs2 = {s}", "have \"io_targets M2 (initial M2) vs1 = io_targets M2 (initial M2) vs2\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) vs1 = {s} \\<and>\n  io_targets M2 (initial M2) vs2 = {s}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs1 = io_targets M2 (initial M2) vs2", "by simp"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) vs1 = io_targets M2 (initial M2) vs2\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "obtain f where f_def : \"is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        is_det_state_cover_ass M2 f \\<and>\n        V = f ` d_reachable M2 (initial M2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        is_det_state_cover_ass M2 f \\<and>\n        V = f ` d_reachable M2 (initial M2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "have \"V = image f (d_reachable M2 (initial M2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = f ` d_reachable M2 (initial M2)", "using f_def"], ["proof (prove)\nusing this:\n  is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. V = f ` d_reachable M2 (initial M2)", "by blast"], ["proof (state)\nthis:\n  V = f ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  V = f ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "have \"map fst vs1 \\<in> V \\<and> map fst vs2 \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst vs1 \\<in> V \\<and> map fst vs2 \\<in> V", "using assms(2) perm_inputs vs_def"], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M1\n  \\<lbrakk>?V'' \\<in> Perm ?V ?M; ?vs \\<in> ?V''\\<rbrakk>\n  \\<Longrightarrow> map fst ?vs \\<in> ?V\n  vs1 \\<noteq> vs2 \\<and>\n  vs1 \\<in> V'' \\<and>\n  vs2 \\<in> V'' \\<and>\n  vs1 \\<notin> R M2 s vs xs \\<and>\n  vs2 \\<notin> R M2 s vs xs \\<and>\n  vs1 \\<in> RP M2 s vs xs V'' \\<and> vs2 \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. map fst vs1 \\<in> V \\<and> map fst vs2 \\<in> V", "by blast"], ["proof (state)\nthis:\n  map fst vs1 \\<in> V \\<and> map fst vs2 \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\n  V = f ` d_reachable M2 (initial M2)\n  map fst vs1 \\<in> V \\<and> map fst vs2 \\<in> V", "obtain r1 r2 where r_def :\n    \"f r1 = map fst vs1 \\<and> r1 \\<in> d_reachable M2 (initial M2)\"\n    \"f r2 = map fst vs2 \\<and> r2 \\<in> d_reachable M2 (initial M2)\""], ["proof (prove)\nusing this:\n  is_det_state_cover_ass M2 f \\<and> V = f ` d_reachable M2 (initial M2)\n  V = f ` d_reachable M2 (initial M2)\n  map fst vs1 \\<in> V \\<and> map fst vs2 \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>r1 r2.\n        \\<lbrakk>f r1 = map fst vs1 \\<and>\n                 r1 \\<in> d_reachable M2 (initial M2);\n         f r2 = map fst vs2 \\<and>\n         r2 \\<in> d_reachable M2 (initial M2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  f r1 = map fst vs1 \\<and> r1 \\<in> d_reachable M2 (initial M2)\n  f r2 = map fst vs2 \\<and> r2 \\<in> d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  f r1 = map fst vs1 \\<and> r1 \\<in> d_reachable M2 (initial M2)\n  f r2 = map fst vs2 \\<and> r2 \\<in> d_reachable M2 (initial M2)", "have \"d_reaches M2 (initial M2) (map fst vs1) r1\"\n            \"d_reaches M2 (initial M2) (map fst vs2) r2\""], ["proof (prove)\nusing this:\n  f r1 = map fst vs1 \\<and> r1 \\<in> d_reachable M2 (initial M2)\n  f r2 = map fst vs2 \\<and> r2 \\<in> d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs1) r1 &&&\n    d_reaches M2 (initial M2) (map fst vs2) r2", "by (metis f_def is_det_state_cover_ass.elims(2))+"], ["proof (state)\nthis:\n  d_reaches M2 (initial M2) (map fst vs1) r1\n  d_reaches M2 (initial M2) (map fst vs2) r2\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  d_reaches M2 (initial M2) (map fst vs1) r1\n  d_reaches M2 (initial M2) (map fst vs2) r2", "have \"io_targets M2 (initial M2) vs1 \\<subseteq> {r1}\""], ["proof (prove)\nusing this:\n  d_reaches M2 (initial M2) (map fst vs1) r1\n  d_reaches M2 (initial M2) (map fst vs2) r2\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs1 \\<subseteq> {r1}", "using d_reaches_io_target[of M2 \"initial M2\" \"map fst vs1\" r1 \"map snd vs1\"]"], ["proof (prove)\nusing this:\n  d_reaches M2 (initial M2) (map fst vs1) r1\n  d_reaches M2 (initial M2) (map fst vs2) r2\n  \\<lbrakk>d_reaches M2 (initial M2) (map fst vs1) r1;\n   length (map snd vs1) = length (map fst vs1)\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 (initial M2) (map fst vs1 || map snd vs1)\n                    \\<subseteq> {r1}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs1 \\<subseteq> {r1}", "by simp"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) vs1 \\<subseteq> {r1}\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) vs1 \\<subseteq> {r1}\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "have \"io_targets M2 (initial M2) vs2 \\<subseteq> {r2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs2 \\<subseteq> {r2}", "using d_reaches_io_target[of M2 \"initial M2\" \"map fst vs2\" r2 \"map snd vs2\"]\n          \\<open>d_reaches M2 (initial M2) (map fst vs2) r2\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>d_reaches M2 (initial M2) (map fst vs2) r2;\n   length (map snd vs2) = length (map fst vs2)\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 (initial M2) (map fst vs2 || map snd vs2)\n                    \\<subseteq> {r2}\n  d_reaches M2 (initial M2) (map fst vs2) r2\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs2 \\<subseteq> {r2}", "by auto"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) vs2 \\<subseteq> {r2}\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) vs1 \\<subseteq> {r1}\n  io_targets M2 (initial M2) vs2 \\<subseteq> {r2}", "have \"r1 = r2\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) vs1 \\<subseteq> {r1}\n  io_targets M2 (initial M2) vs2 \\<subseteq> {r2}\n\ngoal (1 subgoal):\n 1. r1 = r2", "using \\<open>io_targets M2 (initial M2) vs1 = {s} \\<and> io_targets M2 (initial M2) vs2 = {s}\\<close>"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) vs1 \\<subseteq> {r1}\n  io_targets M2 (initial M2) vs2 \\<subseteq> {r2}\n  io_targets M2 (initial M2) vs1 = {s} \\<and>\n  io_targets M2 (initial M2) vs2 = {s}\n\ngoal (1 subgoal):\n 1. r1 = r2", "by auto"], ["proof (state)\nthis:\n  r1 = r2\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "have \"map fst vs1 \\<noteq> map fst vs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst vs1 \\<noteq> map fst vs2", "using assms(2) perm_inputs_diff vs_def"], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M1\n  \\<lbrakk>?V'' \\<in> Perm ?V ?M; ?vs1.0 \\<in> ?V''; ?vs2.0 \\<in> ?V'';\n   ?vs1.0 \\<noteq> ?vs2.0\\<rbrakk>\n  \\<Longrightarrow> map fst ?vs1.0 \\<noteq> map fst ?vs2.0\n  vs1 \\<noteq> vs2 \\<and>\n  vs1 \\<in> V'' \\<and>\n  vs2 \\<in> V'' \\<and>\n  vs1 \\<notin> R M2 s vs xs \\<and>\n  vs2 \\<notin> R M2 s vs xs \\<and>\n  vs1 \\<in> RP M2 s vs xs V'' \\<and> vs2 \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. map fst vs1 \\<noteq> map fst vs2", "by blast"], ["proof (state)\nthis:\n  map fst vs1 \\<noteq> map fst vs2\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  map fst vs1 \\<noteq> map fst vs2", "have \"r1 \\<noteq> r2\""], ["proof (prove)\nusing this:\n  map fst vs1 \\<noteq> map fst vs2\n\ngoal (1 subgoal):\n 1. r1 \\<noteq> r2", "using r_def(1) r_def(2)"], ["proof (prove)\nusing this:\n  map fst vs1 \\<noteq> map fst vs2\n  f r1 = map fst vs1 \\<and> r1 \\<in> d_reachable M2 (initial M2)\n  f r2 = map fst vs2 \\<and> r2 \\<in> d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. r1 \\<noteq> r2", "by force"], ["proof (state)\nthis:\n  r1 \\<noteq> r2\n\ngoal (1 subgoal):\n 1. \\<not> (RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n            (\\<exists>vs'\\<in>V''.\n                vs' \\<notin> R M2 s vs xs \\<and>\n                RP M2 s vs xs V'' =\n                insert vs' (R M2 s vs xs))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  r1 \\<noteq> r2", "show \"False\""], ["proof (prove)\nusing this:\n  r1 \\<noteq> r2\n\ngoal (1 subgoal):\n 1. False", "using \\<open>r1 = r2\\<close>"], ["proof (prove)\nusing this:\n  r1 \\<noteq> r2\n  r1 = r2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_RP :\n  assumes \"is_det_state_cover M2 V\"\n  and     \"V'' \\<in> Perm V M1\"\nshows \"finite (RP M2 s vs xs V'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (RP M2 s vs xs V'')", "using assms RP_from_R finite_R"], ["proof (prove)\nusing this:\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  \\<lbrakk>is_det_state_cover ?M2.0 ?V; ?V'' \\<in> Perm ?V ?M1.0\\<rbrakk>\n  \\<Longrightarrow> RP ?M2.0 ?s ?vs ?xs ?V'' = R ?M2.0 ?s ?vs ?xs \\<or>\n                    (\\<exists>vs'\\<in>?V''.\n                        vs' \\<notin> R ?M2.0 ?s ?vs ?xs \\<and>\n                        RP ?M2.0 ?s ?vs ?xs ?V'' =\n                        insert vs' (R ?M2.0 ?s ?vs ?xs))\n  finite (R ?M ?s ?vs ?xs)\n\ngoal (1 subgoal):\n 1. finite (RP M2 s vs xs V'')", "by (metis finite_insert)"], ["", "lemma RP_count :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"s \\<in> nodes M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"distinct (states (xs || tr) (q2,q1))\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"\\<forall> s' \\<in> set (states (xs || map fst tr) q2) . \\<not> (\\<exists> v \\<in> V . d_reaches M2 (initial M2) v s')\"\nshows \"card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) = card (RP M2 s vs xs V'')\"\n  \\<comment> \\<open>each sequence in the set calculated by RP reaches a different state in M1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "proof -\n\n  \\<comment> \\<open>Proof sketch:\n     - RP calculates either the same set as R or the set of R and an additional element\n     - in the first case, the result for R applies\n     - in the second case, the additional element is not contained in the set calcualted by R due to\n       the assumption that no state reached by a non-empty prefix of xs after vs is also reached by\n       some sequence in V (see the last two assumptions)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have RP_cases : \"RP M2 s vs xs V'' = R M2 s vs xs\n                    \\<or> (\\<exists> vs' \\<in> V'' . vs' \\<notin> R M2 s vs xs\n                                      \\<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n    (\\<exists>vs'\\<in>V''.\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))", "using RP_from_R assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_det_state_cover ?M2.0 ?V; ?V'' \\<in> Perm ?V ?M1.0\\<rbrakk>\n  \\<Longrightarrow> RP ?M2.0 ?s ?vs ?xs ?V'' = R ?M2.0 ?s ?vs ?xs \\<or>\n                    (\\<exists>vs'\\<in>?V''.\n                        vs' \\<notin> R ?M2.0 ?s ?vs ?xs \\<and>\n                        RP ?M2.0 ?s ?vs ?xs ?V'' =\n                        insert vs' (R ?M2.0 ?s ?vs ?xs))\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  \\<forall>s'\\<in>set (states (xs || map fst tr) q2).\n     \\<not> (\\<exists>v\\<in>V. d_reaches M2 (initial M2) v s')\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n    (\\<exists>vs'\\<in>V''.\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))", "by metis"], ["proof (state)\nthis:\n  RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n  (\\<exists>vs'\\<in>V''.\n      vs' \\<notin> R M2 s vs xs \\<and>\n      RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "proof (cases \"RP M2 s vs xs V'' = R M2 s vs xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')\n 2. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "case True"], ["proof (state)\nthis:\n  RP M2 s vs xs V'' = R M2 s vs xs\n\ngoal (2 subgoals):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')\n 2. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "then"], ["proof (chain)\npicking this:\n  RP M2 s vs xs V'' = R M2 s vs xs", "show ?thesis"], ["proof (prove)\nusing this:\n  RP M2 s vs xs V'' = R M2 s vs xs\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "using R_count assms"], ["proof (prove)\nusing this:\n  RP M2 s vs xs V'' = R M2 s vs xs\n  \\<lbrakk>?vs @ ?xs \\<in> L ?M1.0 \\<inter> L ?M2.0; observable ?M1.0;\n   observable ?M2.0; well_formed ?M1.0; well_formed ?M2.0;\n   ?s \\<in> nodes ?M2.0; productF ?M2.0 ?M1.0 ?FAIL ?PM;\n   io_targets ?PM (initial ?PM) ?vs = {(?q2.0, ?q1.0)};\n   path ?PM (?xs || ?tr) (?q2.0, ?q1.0); length ?xs = length ?tr;\n   distinct (states (?xs || ?tr) (?q2.0, ?q1.0))\\<rbrakk>\n  \\<Longrightarrow> card\n                     (\\<Union>\n                       (io_targets ?M1.0 (initial ?M1.0) `\n                        R ?M2.0 ?s ?vs ?xs)) =\n                    card (R ?M2.0 ?s ?vs ?xs)\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  \\<forall>s'\\<in>set (states (xs || map fst tr) q2).\n     \\<not> (\\<exists>v\\<in>V. d_reaches M2 (initial M2) v s')\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "by metis"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "case False"], ["proof (state)\nthis:\n  RP M2 s vs xs V'' \\<noteq> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "then"], ["proof (chain)\npicking this:\n  RP M2 s vs xs V'' \\<noteq> R M2 s vs xs", "obtain vs' where vs'_def : \"vs' \\<in> V''\n                                      \\<and> vs' \\<notin> R M2 s vs xs\n                                      \\<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\""], ["proof (prove)\nusing this:\n  RP M2 s vs xs V'' \\<noteq> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        vs' \\<in> V'' \\<and>\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using RP_cases"], ["proof (prove)\nusing this:\n  RP M2 s vs xs V'' \\<noteq> R M2 s vs xs\n  RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n  (\\<exists>vs'\\<in>V''.\n      vs' \\<notin> R M2 s vs xs \\<and>\n      RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        vs' \\<in> V'' \\<and>\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have obs_PM : \"observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable PM", "using observable_productF assms(2) assms(3) assms(7)"], ["proof (prove)\nusing this:\n  \\<lbrakk>observable ?M1.0; observable ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> observable ?PM\n  observable M1\n  observable M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. observable PM", "by blast"], ["proof (state)\nthis:\n  observable PM\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have state_component_2 : \"\\<forall> io \\<in> (R M2 s vs xs) . io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "fix io"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "assume \"io \\<in> R M2 s vs xs\""], ["proof (state)\nthis:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "then"], ["proof (chain)\npicking this:\n  io \\<in> R M2 s vs xs", "have \"s \\<in> io_targets M2 (initial M2) io\""], ["proof (prove)\nusing this:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. s \\<in> io_targets M2 (initial M2) io", "by auto"], ["proof (state)\nthis:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "moreover"], ["proof (state)\nthis:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "have \"io \\<in> language_state M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> L M2", "using calculation"], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. io \\<in> L M2", "by auto"], ["proof (state)\nthis:\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2", "show \"io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "using assms(3) io_targets_observable_singleton_ex"], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2\n  observable M2\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q2. io_targets ?M ?q1.0 ?io = {q2}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "by (metis singletonD)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {s}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"vs' \\<in> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs' \\<in> L M1", "using assms(13) perm_language vs'_def"], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M1\n  \\<lbrakk>?V'' \\<in> Perm ?V ?M; ?vs \\<in> ?V''\\<rbrakk>\n  \\<Longrightarrow> ?vs \\<in> L ?M\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. vs' \\<in> L M1", "by blast"], ["proof (state)\nthis:\n  vs' \\<in> L M1\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "then"], ["proof (chain)\npicking this:\n  vs' \\<in> L M1", "obtain s' where s'_def : \"io_targets M1 (initial M1) vs' = {s'}\""], ["proof (prove)\nusing this:\n  vs' \\<in> L M1\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        io_targets M1 (initial M1) vs' = {s'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(2) io_targets_observable_singleton_ob)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) vs' = {s'}\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "moreover"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) vs' = {s'}\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"s' \\<notin> \\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "assume \"\\<not> s' \\<notin> \\<Union>(io_targets M1 (initial M1) ` R M2 s vs xs)\""], ["proof (state)\nthis:\n  \\<not> s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)", "obtain xs' where xs'_def : \"vs @ xs' \\<in> R M2 s vs xs \\<and> s' \\<in> io_targets M1 (initial M1) (vs @ xs')\""], ["proof (prove)\nusing this:\n  \\<not> s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        vs @ xs' \\<in> R M2 s vs xs \\<and>\n        s' \\<in> io_targets M1 (initial M1) (vs @ xs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                vs @ xs' \\<in> R M2 s vs xs \\<and>\n                s' \\<in> io_targets M1 (initial M1)\n                          (vs @ xs') \\<Longrightarrow>\n                thesis;\n     \\<not> s' \\<notin> \\<Union>\n                         (io_targets M1 (initial M1) `\n                          R M2 s vs xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume a1: \"\\<And>xs'. vs @ xs' \\<in> R M2 s vs xs \\<and> s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n                          \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  vs @ ?xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ ?xs') \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                vs @ xs' \\<in> R M2 s vs xs \\<and>\n                s' \\<in> io_targets M1 (initial M1)\n                          (vs @ xs') \\<Longrightarrow>\n                thesis;\n     \\<not> s' \\<notin> \\<Union>\n                         (io_targets M1 (initial M1) `\n                          R M2 s vs xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain pps :: \"('a \\<times> 'b) list set \\<Rightarrow> (('a \\<times> 'b) list \\<Rightarrow> 'c set) \\<Rightarrow> 'c \\<Rightarrow> ('a \\<times> 'b) list\"\n          where\n          \"\\<forall>x0 x1 x2. (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) = (pps x0 x1 x2 \\<in> x0 \\<and> x2 \\<in> x1 (pps x0 x1 x2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pps.\n        \\<forall>x0 x1 x2.\n           (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) =\n           (pps x0 x1 x2 \\<in> x0 \\<and>\n            x2 \\<in> x1 (pps x0 x1 x2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) =\n     (pps x0 x1 x2 \\<in> x0 \\<and> x2 \\<in> x1 (pps x0 x1 x2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                vs @ xs' \\<in> R M2 s vs xs \\<and>\n                s' \\<in> io_targets M1 (initial M1)\n                          (vs @ xs') \\<Longrightarrow>\n                thesis;\n     \\<not> s' \\<notin> \\<Union>\n                         (io_targets M1 (initial M1) `\n                          R M2 s vs xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) =\n     (pps x0 x1 x2 \\<in> x0 \\<and> x2 \\<in> x1 (pps x0 x1 x2))", "have f2: \"pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' \\<in> R M2 s vs xs\n                        \\<and> s' \\<in> io_targets M1 (initial M1) (pps (R M2 s vs xs)\n                                              (io_targets M1 (initial M1)) s')\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) =\n     (pps x0 x1 x2 \\<in> x0 \\<and> x2 \\<in> x1 (pps x0 x1 x2))\n\ngoal (1 subgoal):\n 1. pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n    \\<in> R M2 s vs xs \\<and>\n    s' \\<in> io_targets M1 (initial M1)\n              (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')", "using \\<open>\\<not> s' \\<notin> \\<Union>(io_targets M1 (initial M1) ` R M2 s vs xs)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) =\n     (pps x0 x1 x2 \\<in> x0 \\<and> x2 \\<in> x1 (pps x0 x1 x2))\n  \\<not> s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n    \\<in> R M2 s vs xs \\<and>\n    s' \\<in> io_targets M1 (initial M1)\n              (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')", "by blast"], ["proof (state)\nthis:\n  pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n  \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1)\n            (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                vs @ xs' \\<in> R M2 s vs xs \\<and>\n                s' \\<in> io_targets M1 (initial M1)\n                          (vs @ xs') \\<Longrightarrow>\n                thesis;\n     \\<not> s' \\<notin> \\<Union>\n                         (io_targets M1 (initial M1) `\n                          R M2 s vs xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n  \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1)\n            (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')", "have \"\\<exists>ps. pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps\n                        \\<and> ps \\<noteq> [] \\<and> prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)\""], ["proof (prove)\nusing this:\n  pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n  \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1)\n            (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')\n\ngoal (1 subgoal):\n 1. \\<exists>ps.\n       pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and>\n       ps \\<noteq> [] \\<and>\n       prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)", "by simp"], ["proof (state)\nthis:\n  \\<exists>ps.\n     pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and>\n     ps \\<noteq> [] \\<and>\n     prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                vs @ xs' \\<in> R M2 s vs xs \\<and>\n                s' \\<in> io_targets M1 (initial M1)\n                          (vs @ xs') \\<Longrightarrow>\n                thesis;\n     \\<not> s' \\<notin> \\<Union>\n                         (io_targets M1 (initial M1) `\n                          R M2 s vs xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>ps.\n     pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and>\n     ps \\<noteq> [] \\<and>\n     prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ps.\n     pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and>\n     ps \\<noteq> [] \\<and>\n     prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)\n\ngoal (1 subgoal):\n 1. thesis", "using f2 a1"], ["proof (prove)\nusing this:\n  \\<exists>ps.\n     pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and>\n     ps \\<noteq> [] \\<and>\n     prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)\n  pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n  \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1)\n            (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')\n  vs @ ?xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ ?xs') \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (metis (no_types))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')", "obtain tr' where tr'_def : \"path M2 (vs @ xs' || tr') (initial M2)\n                                        \\<and> length tr' = length (vs @ xs')\""], ["proof (prove)\nusing this:\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n\ngoal (1 subgoal):\n 1. (\\<And>tr'.\n        path M2 (vs @ xs' || tr') (initial M2) \\<and>\n        length tr' = length (vs @ xs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M2 (vs @ xs' || tr') (initial M2) \\<and>\n  length tr' = length (vs @ xs')\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  path M2 (vs @ xs' || tr') (initial M2) \\<and>\n  length tr' = length (vs @ xs')", "obtain trV' trX' where tr'_split : \"trV' = take (length vs) tr'\"\n                                              \"trX' = drop (length vs) tr'\"\n                                              \"tr' = trV' @ trX'\""], ["proof (prove)\nusing this:\n  path M2 (vs @ xs' || tr') (initial M2) \\<and>\n  length tr' = length (vs @ xs')\n\ngoal (1 subgoal):\n 1. (\\<And>trV' trX'.\n        \\<lbrakk>trV' = take (length vs) tr'; trX' = drop (length vs) tr';\n         tr' = trV' @ trX'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  trV' = take (length vs) tr'\n  trX' = drop (length vs) tr'\n  tr' = trV' @ trX'\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  trV' = take (length vs) tr'\n  trX' = drop (length vs) tr'\n  tr' = trV' @ trX'", "have \"path M2 (vs || trV') (initial M2) \\<and> length trV' = length vs\""], ["proof (prove)\nusing this:\n  trV' = take (length vs) tr'\n  trX' = drop (length vs) tr'\n  tr' = trV' @ trX'\n\ngoal (1 subgoal):\n 1. path M2 (vs || trV') (initial M2) \\<and> length trV' = length vs", "by (metis (no_types) FSM.path_append_elim \\<open>trV' = take (length vs) tr'\\<close>\n            append_eq_conv_conj length_take tr'_def zip_append1)"], ["proof (state)\nthis:\n  path M2 (vs || trV') (initial M2) \\<and> length trV' = length vs\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"initial PM = (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial PM = (initial M2, initial M1)", "using assms(7)"], ["proof (prove)\nusing this:\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. initial PM = (initial M2, initial M1)", "by simp"], ["proof (state)\nthis:\n  initial PM = (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  initial PM = (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"vs \\<in> L M2\" \"vs \\<in> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> L M2 &&& vs \\<in> L M1", "using assms(1) language_state_prefix"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  ?w1.0 @ ?w2.0 \\<in> LS ?M ?q \\<Longrightarrow> ?w1.0 \\<in> LS ?M ?q\n\ngoal (1 subgoal):\n 1. vs \\<in> L M2 &&& vs \\<in> L M1", "by auto"], ["proof (state)\nthis:\n  vs \\<in> L M2\n  vs \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  initial PM = (initial M2, initial M1)\n  vs \\<in> L M2\n  vs \\<in> L M1", "have \"io_targets M1 (initial M1) vs = {q1}\"\n                      \"io_targets M2 (initial M2) vs = {q2}\""], ["proof (prove)\nusing this:\n  initial PM = (initial M2, initial M1)\n  vs \\<in> L M2\n  vs \\<in> L M1\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) vs = {q1} &&&\n    io_targets M2 (initial M2) vs = {q2}", "using productF_path_io_targets[of M2 M1 FAIL PM \"initial M2\" \"initial M1\" vs q2 q1]"], ["proof (prove)\nusing this:\n  initial PM = (initial M2, initial M1)\n  vs \\<in> L M2\n  vs \\<in> L M1\n  \\<lbrakk>productF M2 M1 FAIL PM;\n   io_targets PM (initial M2, initial M1) vs = {(q2, q1)}; vs \\<in> L M2;\n   vs \\<in> L M1; observable M2; observable M1; well_formed M2;\n   well_formed M1; initial M2 \\<in> nodes M2;\n   initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> q2 \\<in> io_targets M2 (initial M2) vs\n  \\<lbrakk>productF M2 M1 FAIL PM;\n   io_targets PM (initial M2, initial M1) vs = {(q2, q1)}; vs \\<in> L M2;\n   vs \\<in> L M1; observable M2; observable M1; well_formed M2;\n   well_formed M1; initial M2 \\<in> nodes M2;\n   initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> q1 \\<in> io_targets M1 (initial M1) vs\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) vs = {q1} &&&\n    io_targets M2 (initial M2) vs = {q2}", "by (metis FSM.nodes.initial assms(7) assms(8) assms(2) assms(3) assms(4) assms(5)\n            io_targets_observable_singleton_ex singletonD)+"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) vs = {q1}\n  io_targets M2 (initial M2) vs = {q2}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) vs = {q1}\n  io_targets M2 (initial M2) vs = {q2}", "have \"target (vs || trV') (initial M2) = q2\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) vs = {q1}\n  io_targets M2 (initial M2) vs = {q2}\n\ngoal (1 subgoal):\n 1. target (vs || trV') (initial M2) = q2", "using \\<open>path M2 (vs || trV') (initial M2) \\<and> length trV' = length vs\\<close> io_target_target"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) vs = {q1}\n  io_targets M2 (initial M2) vs = {q2}\n  path M2 (vs || trV') (initial M2) \\<and> length trV' = length vs\n  \\<lbrakk>io_targets ?M ?q1.0 ?io = {?q2.0}; path ?M (?io || ?tr) ?q1.0;\n   length ?io = length ?tr\\<rbrakk>\n  \\<Longrightarrow> target (?io || ?tr) ?q1.0 = ?q2.0\n\ngoal (1 subgoal):\n 1. target (vs || trV') (initial M2) = q2", "by metis"], ["proof (state)\nthis:\n  target (vs || trV') (initial M2) = q2\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  target (vs || trV') (initial M2) = q2", "have path_xs' : \"path M2 (xs' || trX') q2 \\<and> length trX' = length xs'\""], ["proof (prove)\nusing this:\n  target (vs || trV') (initial M2) = q2\n\ngoal (1 subgoal):\n 1. path M2 (xs' || trX') q2 \\<and> length trX' = length xs'", "by (metis (no_types) FSM.path_append_elim\n            \\<open>path M2 (vs || trV') (initial M2) \\<and> length trV' = length vs\\<close>\n            \\<open>target (vs || trV') (initial M2) = q2\\<close> append_eq_conv_conj length_drop tr'_def\n            tr'_split(1) tr'_split(2) zip_append2)"], ["proof (state)\nthis:\n  path M2 (xs' || trX') q2 \\<and> length trX' = length xs'\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"io_targets M2 (initial M2) (vs @ xs') = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) (vs @ xs') = {s}", "using state_component_2 xs'_def"], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) (vs @ xs') = {s}", "by blast"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (vs @ xs') = {s}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) (vs @ xs') = {s}", "have \"io_targets M2 q2 xs' = {s}\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (vs @ xs') = {s}\n\ngoal (1 subgoal):\n 1. io_targets M2 q2 xs' = {s}", "by (meson assms(3) observable_io_targets_split \\<open>io_targets M2 (initial M2) vs = {q2}\\<close>)"], ["proof (state)\nthis:\n  io_targets M2 q2 xs' = {s}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets M2 q2 xs' = {s}", "have target_xs' : \"target (xs' || trX') q2 = s\""], ["proof (prove)\nusing this:\n  io_targets M2 q2 xs' = {s}\n\ngoal (1 subgoal):\n 1. target (xs' || trX') q2 = s", "using io_target_target path_xs'"], ["proof (prove)\nusing this:\n  io_targets M2 q2 xs' = {s}\n  \\<lbrakk>io_targets ?M ?q1.0 ?io = {?q2.0}; path ?M (?io || ?tr) ?q1.0;\n   length ?io = length ?tr\\<rbrakk>\n  \\<Longrightarrow> target (?io || ?tr) ?q1.0 = ?q2.0\n  path M2 (xs' || trX') q2 \\<and> length trX' = length xs'\n\ngoal (1 subgoal):\n 1. target (xs' || trX') q2 = s", "by metis"], ["proof (state)\nthis:\n  target (xs' || trX') q2 = s\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  target (xs' || trX') q2 = s\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"length xs' > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length xs'", "using xs'_def"], ["proof (prove)\nusing this:\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n\ngoal (1 subgoal):\n 1. 0 < length xs'", "by auto"], ["proof (state)\nthis:\n  0 < length xs'\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  target (xs' || trX') q2 = s\n  0 < length xs'", "have \"last (states (xs' || trX') q2) = s\""], ["proof (prove)\nusing this:\n  target (xs' || trX') q2 = s\n  0 < length xs'\n\ngoal (1 subgoal):\n 1. last (states (xs' || trX') q2) = s", "using path_xs' target_in_states"], ["proof (prove)\nusing this:\n  target (xs' || trX') q2 = s\n  0 < length xs'\n  path M2 (xs' || trX') q2 \\<and> length trX' = length xs'\n  \\<lbrakk>length ?io = length ?tr; 0 < length ?io\\<rbrakk>\n  \\<Longrightarrow> last (states (?io || ?tr) ?q) = target (?io || ?tr) ?q\n\ngoal (1 subgoal):\n 1. last (states (xs' || trX') q2) = s", "by metis"], ["proof (state)\nthis:\n  last (states (xs' || trX') q2) = s\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  last (states (xs' || trX') q2) = s\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"length (states (xs' || trX') q2) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (states (xs' || trX') q2)", "using \\<open>0 < length xs'\\<close> path_xs'"], ["proof (prove)\nusing this:\n  0 < length xs'\n  path M2 (xs' || trX') q2 \\<and> length trX' = length xs'\n\ngoal (1 subgoal):\n 1. 0 < length (states (xs' || trX') q2)", "by auto"], ["proof (state)\nthis:\n  0 < length (states (xs' || trX') q2)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  last (states (xs' || trX') q2) = s\n  0 < length (states (xs' || trX') q2)", "have states_xs' : \"s \\<in> set (states (xs' || trX') q2)\""], ["proof (prove)\nusing this:\n  last (states (xs' || trX') q2) = s\n  0 < length (states (xs' || trX') q2)\n\ngoal (1 subgoal):\n 1. s \\<in> set (states (xs' || trX') q2)", "using last_in_set"], ["proof (prove)\nusing this:\n  last (states (xs' || trX') q2) = s\n  0 < length (states (xs' || trX') q2)\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. s \\<in> set (states (xs' || trX') q2)", "by blast"], ["proof (state)\nthis:\n  s \\<in> set (states (xs' || trX') q2)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"vs @ xs \\<in> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M2", "using assms"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  \\<forall>s'\\<in>set (states (xs || map fst tr) q2).\n     \\<not> (\\<exists>v\\<in>V. d_reaches M2 (initial M2) v s')\n\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M2", "by simp"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  vs @ xs \\<in> L M2", "obtain q' where \"io_targets M2 (initial M2) (vs@xs) = {q'}\""], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        io_targets M2 (initial M2) (vs @ xs) = {q'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using io_targets_observable_singleton_ob[of M2 \"vs@xs\" \"initial M2\"] assms(3)"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M2\n  \\<lbrakk>observable M2; vs @ xs \\<in> L M2;\n   \\<And>q2.\n      io_targets M2 (initial M2) (vs @ xs) = {q2} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  observable M2\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        io_targets M2 (initial M2) (vs @ xs) = {q'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (vs @ xs) = {q'}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) (vs @ xs) = {q'}", "have \"xs \\<in> language_state M2 q2\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (vs @ xs) = {q'}\n\ngoal (1 subgoal):\n 1. xs \\<in> LS M2 q2", "using assms(3) \\<open>io_targets M2 (initial M2) vs = {q2}\\<close>\n              observable_io_targets_split[of M2 \"initial M2\" vs xs q' q2]"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (vs @ xs) = {q'}\n  observable M2\n  io_targets M2 (initial M2) vs = {q2}\n  \\<lbrakk>observable M2; io_targets M2 (initial M2) (vs @ xs) = {q'};\n   io_targets M2 (initial M2) vs = {q2}\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 q2 xs = {q'}\n\ngoal (1 subgoal):\n 1. xs \\<in> LS M2 q2", "by auto"], ["proof (state)\nthis:\n  xs \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  xs \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"path PM (xs || map fst tr || map snd tr) (q2,q1)\n                      \\<and> length xs = length (map fst tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (xs || map fst tr || map snd tr) (q2, q1) \\<and>\n    length xs = length (map fst tr)", "using assms(7) assms(9) assms(10) productF_path_unzip"], ["proof (prove)\nusing this:\n  productF M2 M1 FAIL PM\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  \\<lbrakk>productF ?A ?B ?FAIL ?AB; path ?AB (?w || ?tr) ?q;\n   length ?tr = length ?w\\<rbrakk>\n  \\<Longrightarrow> path ?AB (?w || map fst ?tr || map snd ?tr) ?q\n\ngoal (1 subgoal):\n 1. path PM (xs || map fst tr || map snd tr) (q2, q1) \\<and>\n    length xs = length (map fst tr)", "by simp"], ["proof (state)\nthis:\n  path PM (xs || map fst tr || map snd tr) (q2, q1) \\<and>\n  length xs = length (map fst tr)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  path PM (xs || map fst tr || map snd tr) (q2, q1) \\<and>\n  length xs = length (map fst tr)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"xs \\<in> language_state PM (q2,q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> LS PM (q2, q1)", "using assms(9) assms(10)"], ["proof (prove)\nusing this:\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n\ngoal (1 subgoal):\n 1. xs \\<in> LS PM (q2, q1)", "by auto"], ["proof (state)\nthis:\n  xs \\<in> LS PM (q2, q1)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  xs \\<in> LS PM (q2, q1)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"q2 \\<in> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M2", "using \\<open>io_targets M2 (initial M2) vs = {q2}\\<close> io_targets_nodes"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) vs = {q2}\n  \\<lbrakk>?q2.0 \\<in> io_targets ?M ?q1.0 ?io;\n   ?q1.0 \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> ?q2.0 \\<in> nodes ?M\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M2", "by (metis FSM.nodes.initial insertI1)"], ["proof (state)\nthis:\n  q2 \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  q2 \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"q1 \\<in> nodes M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<in> nodes M1", "using \\<open>io_targets M1 (initial M1) vs = {q1}\\<close> io_targets_nodes"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) vs = {q1}\n  \\<lbrakk>?q2.0 \\<in> io_targets ?M ?q1.0 ?io;\n   ?q1.0 \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> ?q2.0 \\<in> nodes ?M\n\ngoal (1 subgoal):\n 1. q1 \\<in> nodes M1", "by (metis FSM.nodes.initial insertI1)"], ["proof (state)\nthis:\n  q1 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  xs \\<in> LS M2 q2\n  path PM (xs || map fst tr || map snd tr) (q2, q1) \\<and>\n  length xs = length (map fst tr)\n  xs \\<in> LS PM (q2, q1)\n  q2 \\<in> nodes M2\n  q1 \\<in> nodes M1", "have path_xs : \"path M2 (xs || map fst tr) q2\""], ["proof (prove)\nusing this:\n  xs \\<in> LS M2 q2\n  path PM (xs || map fst tr || map snd tr) (q2, q1) \\<and>\n  length xs = length (map fst tr)\n  xs \\<in> LS PM (q2, q1)\n  q2 \\<in> nodes M2\n  q1 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. path M2 (xs || map fst tr) q2", "using productF_path_reverse_ob_2(1)[of xs \"map fst tr\" \"map snd tr\" M2 M1 FAIL PM q2 q1]\n              assms(2,3,4,5,7)"], ["proof (prove)\nusing this:\n  xs \\<in> LS M2 q2\n  path PM (xs || map fst tr || map snd tr) (q2, q1) \\<and>\n  length xs = length (map fst tr)\n  xs \\<in> LS PM (q2, q1)\n  q2 \\<in> nodes M2\n  q1 \\<in> nodes M1\n  \\<lbrakk>length xs = length (map fst tr);\n   length (map fst tr) = length (map snd tr); productF M2 M1 FAIL PM;\n   well_formed M2; well_formed M1;\n   path PM (xs || map fst tr || map snd tr) (q2, q1); q2 \\<in> nodes M2;\n   q1 \\<in> nodes M1; xs \\<in> LS M2 q2; observable M2\\<rbrakk>\n  \\<Longrightarrow> path M2 (xs || map fst tr) q2 \\<and>\n                    length xs = length (map fst tr)\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. path M2 (xs || map fst tr) q2", "by simp"], ["proof (state)\nthis:\n  path M2 (xs || map fst tr) q2\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  path M2 (xs || map fst tr) q2\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"prefix xs' xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs' xs", "using xs'_def"], ["proof (prove)\nusing this:\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n\ngoal (1 subgoal):\n 1. prefix xs' xs", "by auto"], ["proof (state)\nthis:\n  prefix xs' xs\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  path M2 (xs || map fst tr) q2\n  prefix xs' xs", "have \"trX' = take (length xs') (map fst tr)\""], ["proof (prove)\nusing this:\n  path M2 (xs || map fst tr) q2\n  prefix xs' xs\n\ngoal (1 subgoal):\n 1. trX' = take (length xs') (map fst tr)", "using \\<open>path PM (xs || map fst tr || map snd tr) (q2, q1) \\<and> length xs = length (map fst tr)\\<close>\n              assms(3) path_xs'"], ["proof (prove)\nusing this:\n  path M2 (xs || map fst tr) q2\n  prefix xs' xs\n  path PM (xs || map fst tr || map snd tr) (q2, q1) \\<and>\n  length xs = length (map fst tr)\n  observable M2\n  path M2 (xs' || trX') q2 \\<and> length trX' = length xs'\n\ngoal (1 subgoal):\n 1. trX' = take (length xs') (map fst tr)", "by (metis observable_path_prefix)"], ["proof (state)\nthis:\n  trX' = take (length xs') (map fst tr)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  trX' = take (length xs') (map fst tr)", "have states_xs : \"s \\<in> set (states (xs || map fst tr) q2)\""], ["proof (prove)\nusing this:\n  trX' = take (length xs') (map fst tr)\n\ngoal (1 subgoal):\n 1. s \\<in> set (states (xs || map fst tr) q2)", "by (metis assms(10) in_set_takeD length_map map_snd_zip path_xs' states_alt_def states_xs')"], ["proof (state)\nthis:\n  s \\<in> set (states (xs || map fst tr) q2)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"d_reaches M2 (initial M2) (map fst vs') s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "obtain fV where fV_def : \"is_det_state_cover_ass M2 fV\n                                  \\<and> V = fV ` d_reachable M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fV.\n        is_det_state_cover_ass M2 fV \\<and>\n        V = fV ` d_reachable M2 (initial M2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(12)"], ["proof (prove)\nusing this:\n  is_det_state_cover M2 V\n\ngoal (1 subgoal):\n 1. (\\<And>fV.\n        is_det_state_cover_ass M2 fV \\<and>\n        V = fV ` d_reachable M2 (initial M2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_det_state_cover_ass M2 fV \\<and> V = fV ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "moreover"], ["proof (state)\nthis:\n  is_det_state_cover_ass M2 fV \\<and> V = fV ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "have \"V = image fV (d_reachable M2 (initial M2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = fV ` d_reachable M2 (initial M2)", "using fV_def"], ["proof (prove)\nusing this:\n  is_det_state_cover_ass M2 fV \\<and> V = fV ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. V = fV ` d_reachable M2 (initial M2)", "by blast"], ["proof (state)\nthis:\n  V = fV ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "moreover"], ["proof (state)\nthis:\n  V = fV ` d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "have \"map fst vs' \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst vs' \\<in> V", "using perm_inputs vs'_def assms(13)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?V'' \\<in> Perm ?V ?M; ?vs \\<in> ?V''\\<rbrakk>\n  \\<Longrightarrow> map fst ?vs \\<in> ?V\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. map fst vs' \\<in> V", "by metis"], ["proof (state)\nthis:\n  map fst vs' \\<in> V\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "ultimately"], ["proof (chain)\npicking this:\n  is_det_state_cover_ass M2 fV \\<and> V = fV ` d_reachable M2 (initial M2)\n  V = fV ` d_reachable M2 (initial M2)\n  map fst vs' \\<in> V", "obtain qv where qv_def : \"fV qv = map fst vs' \\<and> qv\\<in> d_reachable M2 (initial M2)\""], ["proof (prove)\nusing this:\n  is_det_state_cover_ass M2 fV \\<and> V = fV ` d_reachable M2 (initial M2)\n  V = fV ` d_reachable M2 (initial M2)\n  map fst vs' \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>qv.\n        fV qv = map fst vs' \\<and>\n        qv \\<in> d_reachable M2 (initial M2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fV qv = map fst vs' \\<and> qv \\<in> d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "then"], ["proof (chain)\npicking this:\n  fV qv = map fst vs' \\<and> qv \\<in> d_reachable M2 (initial M2)", "have \"d_reaches M2 (initial M2) (map fst vs') qv\""], ["proof (prove)\nusing this:\n  fV qv = map fst vs' \\<and> qv \\<in> d_reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') qv", "by (metis fV_def is_det_state_cover_ass.elims(2))"], ["proof (state)\nthis:\n  d_reaches M2 (initial M2) (map fst vs') qv\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "then"], ["proof (chain)\npicking this:\n  d_reaches M2 (initial M2) (map fst vs') qv", "have \"io_targets M2 (initial M2) vs' \\<subseteq> {qv}\""], ["proof (prove)\nusing this:\n  d_reaches M2 (initial M2) (map fst vs') qv\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs' \\<subseteq> {qv}", "using d_reaches_io_target[of M2 \"initial M2\" \"map fst vs'\" qv \"map snd vs'\"]"], ["proof (prove)\nusing this:\n  d_reaches M2 (initial M2) (map fst vs') qv\n  \\<lbrakk>d_reaches M2 (initial M2) (map fst vs') qv;\n   length (map snd vs') = length (map fst vs')\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 (initial M2) (map fst vs' || map snd vs')\n                    \\<subseteq> {qv}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs' \\<subseteq> {qv}", "by simp"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) vs' \\<subseteq> {qv}\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "moreover"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) vs' \\<subseteq> {qv}\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "have \"io_targets M2 (initial M2) vs' = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs' = {s}", "using vs'_def"], ["proof (prove)\nusing this:\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs' = {s}", "by (metis (mono_tags, lifting) RP.simps Un_iff insertI1 mem_Collect_eq)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) vs' = {s}\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "ultimately"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) vs' \\<subseteq> {qv}\n  io_targets M2 (initial M2) vs' = {s}", "have \"qv = s\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) vs' \\<subseteq> {qv}\n  io_targets M2 (initial M2) vs' = {s}\n\ngoal (1 subgoal):\n 1. qv = s", "by simp"], ["proof (state)\nthis:\n  qv = s\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "then"], ["proof (chain)\npicking this:\n  qv = s", "show ?thesis"], ["proof (prove)\nusing this:\n  qv = s\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "using \\<open>d_reaches M2 (initial M2) (map fst vs') qv\\<close>"], ["proof (prove)\nusing this:\n  qv = s\n  d_reaches M2 (initial M2) (map fst vs') qv\n\ngoal (1 subgoal):\n 1. d_reaches M2 (initial M2) (map fst vs') s", "by blast"], ["proof (state)\nthis:\n  d_reaches M2 (initial M2) (map fst vs') s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d_reaches M2 (initial M2) (map fst vs') s\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  d_reaches M2 (initial M2) (map fst vs') s", "show \"False\""], ["proof (prove)\nusing this:\n  d_reaches M2 (initial M2) (map fst vs') s\n\ngoal (1 subgoal):\n 1. False", "by (meson assms(14) assms(13) perm_inputs states_xs vs'_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "moreover"], ["proof (state)\nthis:\n  s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"\\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs)))\n                    = insert s' (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n    insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))", "using s'_def"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) vs' = {s'}\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n    insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))", "by simp"], ["proof (state)\nthis:\n  \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n  insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "moreover"], ["proof (state)\nthis:\n  \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n  insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"finite (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (R M2 s vs xs)\n 2. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "show \"finite (R M2 s vs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R M2 s vs xs)", "using finite_R"], ["proof (prove)\nusing this:\n  finite (R ?M ?s ?vs ?xs)\n\ngoal (1 subgoal):\n 1. finite (R M2 s vs xs)", "by simp"], ["proof (state)\nthis:\n  finite (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "show \"\\<And>a. a \\<in> R M2 s vs xs \\<Longrightarrow> finite (io_targets M1 (initial M1) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "assume \"a \\<in> R M2 s vs xs\""], ["proof (state)\nthis:\n  a \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "then"], ["proof (chain)\npicking this:\n  a \\<in> R M2 s vs xs", "have \"prefix a (vs@xs)\""], ["proof (prove)\nusing this:\n  a \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. prefix a (vs @ xs)", "by auto"], ["proof (state)\nthis:\n  prefix a (vs @ xs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "then"], ["proof (chain)\npicking this:\n  prefix a (vs @ xs)", "have \"a \\<in> L M1\""], ["proof (prove)\nusing this:\n  prefix a (vs @ xs)\n\ngoal (1 subgoal):\n 1. a \\<in> L M1", "using language_state_prefix"], ["proof (prove)\nusing this:\n  prefix a (vs @ xs)\n  ?w1.0 @ ?w2.0 \\<in> LS ?M ?q \\<Longrightarrow> ?w1.0 \\<in> LS ?M ?q\n\ngoal (1 subgoal):\n 1. a \\<in> L M1", "by (metis IntD1 assms(1) prefix_def)"], ["proof (state)\nthis:\n  a \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "then"], ["proof (chain)\npicking this:\n  a \\<in> L M1", "obtain p where \"io_targets M1 (initial M1) a = {p}\""], ["proof (prove)\nusing this:\n  a \\<in> L M1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        io_targets M1 (initial M1) a = {p} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) io_targets_observable_singleton_ob"], ["proof (prove)\nusing this:\n  a \\<in> L M1\n  observable M1\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0;\n   \\<And>q2.\n      io_targets ?M ?q1.0 ?io = {q2} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        io_targets M1 (initial M1) a = {p} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) a = {p}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) a = {p}", "show \"finite (io_targets M1 (initial M1) a)\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) a = {p}\n\ngoal (1 subgoal):\n 1. finite (io_targets M1 (initial M1) a)", "by simp"], ["proof (state)\nthis:\n  finite (io_targets M1 (initial M1) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a \\<in> R M2 s vs xs \\<Longrightarrow>\n  finite (io_targets M1 (initial M1) ?a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "ultimately"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) vs' = {s'}\n  s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n  \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n  insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n  finite (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))", "have \"card (\\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))\n                     = Suc (card (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) vs' = {s'}\n  s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n  \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n  insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n  finite (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs))) =\n    Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))", "by (metis (no_types) card_insert_disjoint)"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs))) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "moreover"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs))) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))\n                    = card (\\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)))", "using vs'_def"], ["proof (prove)\nusing this:\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)))", "by simp"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "ultimately"], ["proof (chain)\npicking this:\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs))) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)))", "have \"card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))\n                      = Suc (card (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))\""], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs))) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))", "by linarith"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "then"], ["proof (chain)\npicking this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))", "have \"card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))\n                = Suc (card (R M2 s vs xs))\""], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    Suc (card (R M2 s vs xs))", "using R_count[of vs xs M1 M2 s FAIL PM q2 q1 tr] assms(1,10,11,2-9)"], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n  \\<lbrakk>vs @ xs \\<in> L M1 \\<inter> L M2; observable M1; observable M2;\n   well_formed M1; well_formed M2; s \\<in> nodes M2; productF M2 M1 FAIL PM;\n   io_targets PM (initial PM) vs = {(q2, q1)}; path PM (xs || tr) (q2, q1);\n   length xs = length tr; distinct (states (xs || tr) (q2, q1))\\<rbrakk>\n  \\<Longrightarrow> card\n                     (\\<Union>\n                       (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n                    card (R M2 s vs xs)\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    Suc (card (R M2 s vs xs))", "by linarith"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "moreover"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))", "using vs'_def"], ["proof (prove)\nusing this:\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))", "by (metis card_insert_if finite_R)"], ["proof (state)\nthis:\n  card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "ultimately"], ["proof (chain)\npicking this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (R M2 s vs xs))\n  card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (R M2 s vs xs))\n  card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "by linarith"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (RP M2 s vs xs V'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (RP M2 s vs xs V'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma RP_state_component_2 :\n  assumes \"io \\<in> (RP M2 s vs xs V'')\"\n  and     \"observable M2\"\nshows \"io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "by (metis (mono_tags, lifting) RP.simps R_state_component_2 Un_iff assms mem_Collect_eq)"], ["", "lemma RP_io_targets_split :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"io \\<in> RP M2 s vs xs V''\"\nshows \"io_targets PM (initial PM) io\n        = io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have RP_cases : \"RP M2 s vs xs V'' = R M2 s vs xs\n                    \\<or> (\\<exists> vs' \\<in> V'' . vs' \\<notin> R M2 s vs xs\n                                      \\<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n    (\\<exists>vs'\\<in>V''.\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))", "using RP_from_R assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_det_state_cover ?M2.0 ?V; ?V'' \\<in> Perm ?V ?M1.0\\<rbrakk>\n  \\<Longrightarrow> RP ?M2.0 ?s ?vs ?xs ?V'' = R ?M2.0 ?s ?vs ?xs \\<or>\n                    (\\<exists>vs'\\<in>?V''.\n                        vs' \\<notin> R ?M2.0 ?s ?vs ?xs \\<and>\n                        RP ?M2.0 ?s ?vs ?xs ?V'' =\n                        insert vs' (R ?M2.0 ?s ?vs ?xs))\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  io \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n    (\\<exists>vs'\\<in>V''.\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))", "by metis"], ["proof (state)\nthis:\n  RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n  (\\<exists>vs'\\<in>V''.\n      vs' \\<notin> R M2 s vs xs \\<and>\n      RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "proof (cases \"io \\<in> R M2 s vs xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "case True"], ["proof (state)\nthis:\n  io \\<in> R M2 s vs xs\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<in> R M2 s vs xs", "have io_prefix : \"prefix io (vs @ xs)\""], ["proof (prove)\nusing this:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. prefix io (vs @ xs)", "by auto"], ["proof (state)\nthis:\n  prefix io (vs @ xs)\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  prefix io (vs @ xs)", "have io_lang_subs : \"io \\<in> L M1 \\<and> io \\<in> L M2\""], ["proof (prove)\nusing this:\n  prefix io (vs @ xs)\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<and> io \\<in> L M2", "using assms(1)"], ["proof (prove)\nusing this:\n  prefix io (vs @ xs)\n  vs @ xs \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<and> io \\<in> L M2", "unfolding prefix_def"], ["proof (prove)\nusing this:\n  \\<exists>zs. vs @ xs = io @ zs\n  vs @ xs \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<and> io \\<in> L M2", "by (metis IntE language_state language_state_split)"], ["proof (state)\nthis:\n  io \\<in> L M1 \\<and> io \\<in> L M2\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M1 \\<and> io \\<in> L M2", "have io_lang_inter : \"io \\<in> L M1 \\<inter> L M2\""], ["proof (prove)\nusing this:\n  io \\<in> L M1 \\<and> io \\<in> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 \\<inter> L M2", "by simp"], ["proof (state)\nthis:\n  io \\<in> L M1 \\<inter> L M2\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M1 \\<inter> L M2", "have io_lang_pm : \"io \\<in> L PM\""], ["proof (prove)\nusing this:\n  io \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L PM", "using productF_language assms"], ["proof (prove)\nusing this:\n  io \\<in> L M1 \\<inter> L M2\n  \\<lbrakk>productF ?A ?B ?FAIL ?AB; well_formed ?A; well_formed ?B;\n   ?io \\<in> L ?A \\<inter> L ?B\\<rbrakk>\n  \\<Longrightarrow> ?io \\<in> L ?AB\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  io \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. io \\<in> L PM", "by blast"], ["proof (state)\nthis:\n  io \\<in> L PM\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "moreover"], ["proof (state)\nthis:\n  io \\<in> L PM\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "obtain p2 p1 where \"(p2,p1) \\<in> io_targets PM (initial PM) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 p1.\n        (p2, p1) \\<in> io_targets PM (initial PM) io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(2) assms(3) assms(6) calculation insert_absorb insert_ident insert_not_empty\n          io_targets_observable_singleton_ob observable_productF singleton_insert_inj_eq subrelI)"], ["proof (state)\nthis:\n  (p2, p1) \\<in> io_targets PM (initial PM) io\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "ultimately"], ["proof (chain)\npicking this:\n  io \\<in> L PM\n  (p2, p1) \\<in> io_targets PM (initial PM) io", "have targets_pm : \"io_targets PM (initial PM) io = {(p2,p1)}\""], ["proof (prove)\nusing this:\n  io \\<in> L PM\n  (p2, p1) \\<in> io_targets PM (initial PM) io\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {(p2, p1)}", "using assms io_targets_observable_singleton_ex singletonD"], ["proof (prove)\nusing this:\n  io \\<in> L PM\n  (p2, p1) \\<in> io_targets PM (initial PM) io\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  io \\<in> RP M2 s vs xs V''\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q2. io_targets ?M ?q1.0 ?io = {q2}\n  ?b \\<in> {?a} \\<Longrightarrow> ?b = ?a\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {(p2, p1)}", "by (metis observable_productF)"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io = {(p2, p1)}\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io_targets PM (initial PM) io = {(p2, p1)}", "obtain trP where trP_def : \"target (io || trP) (initial PM) = (p2,p1)\n                                      \\<and> path PM (io || trP) (initial PM) \\<and> length io = length trP\""], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io = {(p2, p1)}\n\ngoal (1 subgoal):\n 1. (\\<And>trP.\n        target (io || trP) (initial PM) = (p2, p1) \\<and>\n        path PM (io || trP) (initial PM) \\<and>\n        length io = length trP \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>trP.\n                target (io || trP) (initial PM) = (p2, p1) \\<and>\n                path PM (io || trP) (initial PM) \\<and>\n                length io = length trP \\<Longrightarrow>\n                thesis;\n     io_targets PM (initial PM) io = {(p2, p1)}\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume a1: \"\\<And>trP. target (io || trP) (initial PM) = (p2, p1)\n                          \\<and> path PM (io || trP) (initial PM) \\<and> length io = length trP \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  target (io || ?trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || ?trP) (initial PM) \\<and>\n  length io = length ?trP \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>trP.\n                target (io || trP) (initial PM) = (p2, p1) \\<and>\n                path PM (io || trP) (initial PM) \\<and>\n                length io = length trP \\<Longrightarrow>\n                thesis;\n     io_targets PM (initial PM) io = {(p2, p1)}\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<exists>ps. target (io || ps) (initial PM) = (p2, p1) \\<and> path PM (io || ps) (initial PM)\n                                                           \\<and> length io = length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ps.\n       target (io || ps) (initial PM) = (p2, p1) \\<and>\n       path PM (io || ps) (initial PM) \\<and> length io = length ps", "using \\<open>(p2, p1) \\<in> io_targets PM (initial PM) io\\<close>"], ["proof (prove)\nusing this:\n  (p2, p1) \\<in> io_targets PM (initial PM) io\n\ngoal (1 subgoal):\n 1. \\<exists>ps.\n       target (io || ps) (initial PM) = (p2, p1) \\<and>\n       path PM (io || ps) (initial PM) \\<and> length io = length ps", "by auto"], ["proof (state)\nthis:\n  \\<exists>ps.\n     target (io || ps) (initial PM) = (p2, p1) \\<and>\n     path PM (io || ps) (initial PM) \\<and> length io = length ps\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>trP.\n                target (io || trP) (initial PM) = (p2, p1) \\<and>\n                path PM (io || trP) (initial PM) \\<and>\n                length io = length trP \\<Longrightarrow>\n                thesis;\n     io_targets PM (initial PM) io = {(p2, p1)}\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>ps.\n     target (io || ps) (initial PM) = (p2, p1) \\<and>\n     path PM (io || ps) (initial PM) \\<and> length io = length ps", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ps.\n     target (io || ps) (initial PM) = (p2, p1) \\<and>\n     path PM (io || ps) (initial PM) \\<and> length io = length ps\n\ngoal (1 subgoal):\n 1. thesis", "using a1"], ["proof (prove)\nusing this:\n  \\<exists>ps.\n     target (io || ps) (initial PM) = (p2, p1) \\<and>\n     path PM (io || ps) (initial PM) \\<and> length io = length ps\n  target (io || ?trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || ?trP) (initial PM) \\<and>\n  length io = length ?trP \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP", "have trP_unique : \"{tr . path PM (io || tr) (initial PM) \\<and> length io = length tr} = {trP}\""], ["proof (prove)\nusing this:\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n\ngoal (1 subgoal):\n 1. {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} =\n    {trP}", "using observable_productF observable_path_unique_ex[of PM io \"initial PM\"]\n            io_lang_pm assms(2) assms(3) assms(7)"], ["proof (prove)\nusing this:\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n  \\<lbrakk>observable ?M1.0; observable ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> observable ?PM\n  \\<lbrakk>observable PM; io \\<in> L PM;\n   \\<And>tr.\n      {t. path PM (io || t) (initial PM) \\<and> length io = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  io \\<in> L PM\n  observable M1\n  observable M2\n  is_det_state_cover M2 V\n\ngoal (1 subgoal):\n 1. {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} =\n    {trP}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>target (io || trP) (initial PM) = (p2, p1) \\<and>\n             path PM (io || trP) (initial PM) \\<and> length io = length trP;\n     \\<And>M1 M2 FAIL PM.\n        \\<lbrakk>observable M1; observable M2;\n         productF M2 M1 FAIL PM\\<rbrakk>\n        \\<Longrightarrow> observable PM;\n     \\<And>thesis.\n        \\<lbrakk>observable PM; io \\<in> L PM;\n         \\<And>tr.\n            {t. path PM (io || t) (initial PM) \\<and>\n                length io = length t} =\n            {tr} \\<Longrightarrow>\n            thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     io \\<in> L PM; observable M1; observable M2;\n     is_det_state_cover M2 V\\<rbrakk>\n    \\<Longrightarrow> {tr.\n                       path PM (io || tr) (initial PM) \\<and>\n                       length io = length tr} =\n                      {trP}", "obtain pps :: \"('d \\<times> 'c) list\" where\n        f1: \"{ps. path PM (io || ps) (initial PM) \\<and> length io = length ps} = {pps}\n              \\<or> \\<not> observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pps.\n        {ps. path PM (io || ps) (initial PM) \\<and> length io = length ps} =\n        {pps} \\<or>\n        \\<not> observable PM \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types) \\<open>\\<And>thesis. \\<lbrakk>observable PM; io \\<in> L PM; \\<And>tr.\n                              {t. path PM (io || t) (initial PM) \\<and> length io = length t} = {tr}\n                               \\<Longrightarrow> thesis\\<rbrakk> \\<Longrightarrow> thesis\\<close>\n            io_lang_pm)"], ["proof (state)\nthis:\n  {ps. path PM (io || ps) (initial PM) \\<and> length io = length ps} =\n  {pps} \\<or>\n  \\<not> observable PM\n\ngoal (1 subgoal):\n 1. \\<lbrakk>target (io || trP) (initial PM) = (p2, p1) \\<and>\n             path PM (io || trP) (initial PM) \\<and> length io = length trP;\n     \\<And>M1 M2 FAIL PM.\n        \\<lbrakk>observable M1; observable M2;\n         productF M2 M1 FAIL PM\\<rbrakk>\n        \\<Longrightarrow> observable PM;\n     \\<And>thesis.\n        \\<lbrakk>observable PM; io \\<in> L PM;\n         \\<And>tr.\n            {t. path PM (io || t) (initial PM) \\<and>\n                length io = length t} =\n            {tr} \\<Longrightarrow>\n            thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     io \\<in> L PM; observable M1; observable M2;\n     is_det_state_cover M2 V\\<rbrakk>\n    \\<Longrightarrow> {tr.\n                       path PM (io || tr) (initial PM) \\<and>\n                       length io = length tr} =\n                      {trP}", "have f2: \"observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable PM", "by (meson \\<open>observable M1\\<close> \\<open>observable M2\\<close> \\<open>productF M2 M1 FAIL PM\\<close> observable_productF)"], ["proof (state)\nthis:\n  observable PM\n\ngoal (1 subgoal):\n 1. \\<lbrakk>target (io || trP) (initial PM) = (p2, p1) \\<and>\n             path PM (io || trP) (initial PM) \\<and> length io = length trP;\n     \\<And>M1 M2 FAIL PM.\n        \\<lbrakk>observable M1; observable M2;\n         productF M2 M1 FAIL PM\\<rbrakk>\n        \\<Longrightarrow> observable PM;\n     \\<And>thesis.\n        \\<lbrakk>observable PM; io \\<in> L PM;\n         \\<And>tr.\n            {t. path PM (io || t) (initial PM) \\<and>\n                length io = length t} =\n            {tr} \\<Longrightarrow>\n            thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     io \\<in> L PM; observable M1; observable M2;\n     is_det_state_cover M2 V\\<rbrakk>\n    \\<Longrightarrow> {tr.\n                       path PM (io || tr) (initial PM) \\<and>\n                       length io = length tr} =\n                      {trP}", "then"], ["proof (chain)\npicking this:\n  observable PM", "have \"trP \\<in> {pps}\""], ["proof (prove)\nusing this:\n  observable PM\n\ngoal (1 subgoal):\n 1. trP \\<in> {pps}", "using f1 trP_def"], ["proof (prove)\nusing this:\n  observable PM\n  {ps. path PM (io || ps) (initial PM) \\<and> length io = length ps} =\n  {pps} \\<or>\n  \\<not> observable PM\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n\ngoal (1 subgoal):\n 1. trP \\<in> {pps}", "by blast"], ["proof (state)\nthis:\n  trP \\<in> {pps}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>target (io || trP) (initial PM) = (p2, p1) \\<and>\n             path PM (io || trP) (initial PM) \\<and> length io = length trP;\n     \\<And>M1 M2 FAIL PM.\n        \\<lbrakk>observable M1; observable M2;\n         productF M2 M1 FAIL PM\\<rbrakk>\n        \\<Longrightarrow> observable PM;\n     \\<And>thesis.\n        \\<lbrakk>observable PM; io \\<in> L PM;\n         \\<And>tr.\n            {t. path PM (io || t) (initial PM) \\<and>\n                length io = length t} =\n            {tr} \\<Longrightarrow>\n            thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     io \\<in> L PM; observable M1; observable M2;\n     is_det_state_cover M2 V\\<rbrakk>\n    \\<Longrightarrow> {tr.\n                       path PM (io || tr) (initial PM) \\<and>\n                       length io = length tr} =\n                      {trP}", "then"], ["proof (chain)\npicking this:\n  trP \\<in> {pps}", "show ?thesis"], ["proof (prove)\nusing this:\n  trP \\<in> {pps}\n\ngoal (1 subgoal):\n 1. {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} =\n    {trP}", "using f2 f1"], ["proof (prove)\nusing this:\n  trP \\<in> {pps}\n  observable PM\n  {ps. path PM (io || ps) (initial PM) \\<and> length io = length ps} =\n  {pps} \\<or>\n  \\<not> observable PM\n\ngoal (1 subgoal):\n 1. {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} =\n    {trP}", "by force"], ["proof (state)\nthis:\n  {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} = {trP}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} = {trP}\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "obtain trIO2 where trIO2_def : \"{tr . path M2 (io || tr) (initial M2) \\<and> length io = length tr}\n                                    = { trIO2 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trIO2.\n        {tr. path M2 (io || tr) (initial M2) \\<and> length io = length tr} =\n        {trIO2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using observable_path_unique_ex[of M2 io \"initial M2\"] io_lang_subs assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>observable M2; io \\<in> L M2;\n   \\<And>tr.\n      {t. path M2 (io || t) (initial M2) \\<and> length io = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  io \\<in> L M1 \\<and> io \\<in> L M2\n  observable M2\n\ngoal (1 subgoal):\n 1. (\\<And>trIO2.\n        {tr. path M2 (io || tr) (initial M2) \\<and> length io = length tr} =\n        {trIO2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  {tr. path M2 (io || tr) (initial M2) \\<and> length io = length tr} =\n  {trIO2}\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "obtain trIO1 where trIO1_def : \"{tr . path M1 (io || tr) (initial M1) \\<and> length io = length tr}\n                                    = { trIO1 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trIO1.\n        {tr. path M1 (io || tr) (initial M1) \\<and> length io = length tr} =\n        {trIO1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using observable_path_unique_ex[of M1 io \"initial M1\"] io_lang_subs assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>observable M1; io \\<in> L M1;\n   \\<And>tr.\n      {t. path M1 (io || t) (initial M1) \\<and> length io = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  io \\<in> L M1 \\<and> io \\<in> L M2\n  observable M1\n\ngoal (1 subgoal):\n 1. (\\<And>trIO1.\n        {tr. path M1 (io || tr) (initial M1) \\<and> length io = length tr} =\n        {trIO1} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  {tr. path M1 (io || tr) (initial M1) \\<and> length io = length tr} =\n  {trIO1}\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"path PM (io || trIO2 || trIO1) (initial M2, initial M1)\n          \\<and> length io = length trIO2 \\<and> length trIO2 = length trIO1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "have f1: \"path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2", "using trIO2_def"], ["proof (prove)\nusing this:\n  {tr. path M2 (io || tr) (initial M2) \\<and> length io = length tr} =\n  {trIO2}\n\ngoal (1 subgoal):\n 1. path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2", "by auto"], ["proof (state)\nthis:\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "have f2: \"path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "using trIO1_def"], ["proof (prove)\nusing this:\n  {tr. path M1 (io || tr) (initial M1) \\<and> length io = length tr} =\n  {trIO1}\n\ngoal (1 subgoal):\n 1. path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "by auto"], ["proof (state)\nthis:\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "then"], ["proof (chain)\npicking this:\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "have \"length trIO2 = length trIO1\""], ["proof (prove)\nusing this:\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n\ngoal (1 subgoal):\n 1. length trIO2 = length trIO1", "using f1"], ["proof (prove)\nusing this:\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\n\ngoal (1 subgoal):\n 1. length trIO2 = length trIO1", "by presburger"], ["proof (state)\nthis:\n  length trIO2 = length trIO1\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "then"], ["proof (chain)\npicking this:\n  length trIO2 = length trIO1", "show ?thesis"], ["proof (prove)\nusing this:\n  length trIO2 = length trIO1\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "using f2 f1 assms(4) assms(5) assms(6)"], ["proof (prove)\nusing this:\n  length trIO2 = length trIO1\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "by blast"], ["proof (state)\nthis:\n  path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1", "have trP_split : \"path PM (io || trIO2 || trIO1) (initial PM)\n                           \\<and> length io = length trIO2 \\<and> length trIO2 = length trIO1\""], ["proof (prove)\nusing this:\n  path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "using assms(6)"], ["proof (prove)\nusing this:\n  path PM (io || trIO2 || trIO1) (initial M2, initial M1) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n    length io = length trIO2 \\<and> length trIO2 = length trIO1", "by auto"], ["proof (state)\nthis:\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1", "have trP_zip : \"trIO2 || trIO1 = trP\""], ["proof (prove)\nusing this:\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n\ngoal (1 subgoal):\n 1. trIO2 || trIO1 = trP", "using trP_def trP_unique length_zip"], ["proof (prove)\nusing this:\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n  {tr. path PM (io || tr) (initial PM) \\<and> length io = length tr} = {trP}\n  length (?xs || ?ys) = min (length ?xs) (length ?ys)\n\ngoal (1 subgoal):\n 1. trIO2 || trIO1 = trP", "by fastforce"], ["proof (state)\nthis:\n  trIO2 || trIO1 = trP\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"target (io || trIO2) (initial M2) = p2\n            \\<and> path M2 (io || trIO2) (initial M2)\n            \\<and> length io = length trIO2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || trIO2) (initial M2) = p2 \\<and>\n    path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2", "using trP_zip trP_split assms(6) trP_def trIO2_def"], ["proof (prove)\nusing this:\n  trIO2 || trIO1 = trP\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n  productF M2 M1 FAIL PM\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n  {tr. path M2 (io || tr) (initial M2) \\<and> length io = length tr} =\n  {trIO2}\n\ngoal (1 subgoal):\n 1. target (io || trIO2) (initial M2) = p2 \\<and>\n    path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2", "by auto"], ["proof (state)\nthis:\n  target (io || trIO2) (initial M2) = p2 \\<and>\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  target (io || trIO2) (initial M2) = p2 \\<and>\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2", "have \"p2 \\<in> io_targets M2 (initial M2) io\""], ["proof (prove)\nusing this:\n  target (io || trIO2) (initial M2) = p2 \\<and>\n  path M2 (io || trIO2) (initial M2) \\<and> length io = length trIO2\n\ngoal (1 subgoal):\n 1. p2 \\<in> io_targets M2 (initial M2) io", "by auto"], ["proof (state)\nthis:\n  p2 \\<in> io_targets M2 (initial M2) io\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  p2 \\<in> io_targets M2 (initial M2) io", "have targets_2 : \"io_targets M2 (initial M2) io = {p2}\""], ["proof (prove)\nusing this:\n  p2 \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {p2}", "by (meson assms(3) observable_io_target_is_singleton)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {p2}\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"target (io || trIO1) (initial M1) = p1\n          \\<and> path M1 (io || trIO1) (initial M1)\n          \\<and> length io = length trIO1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || trIO1) (initial M1) = p1 \\<and>\n    path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "using trP_zip trP_split assms(6) trP_def trIO1_def"], ["proof (prove)\nusing this:\n  trIO2 || trIO1 = trP\n  path PM (io || trIO2 || trIO1) (initial PM) \\<and>\n  length io = length trIO2 \\<and> length trIO2 = length trIO1\n  productF M2 M1 FAIL PM\n  target (io || trP) (initial PM) = (p2, p1) \\<and>\n  path PM (io || trP) (initial PM) \\<and> length io = length trP\n  {tr. path M1 (io || tr) (initial M1) \\<and> length io = length tr} =\n  {trIO1}\n\ngoal (1 subgoal):\n 1. target (io || trIO1) (initial M1) = p1 \\<and>\n    path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "by auto"], ["proof (state)\nthis:\n  target (io || trIO1) (initial M1) = p1 \\<and>\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  target (io || trIO1) (initial M1) = p1 \\<and>\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1", "have \"p1 \\<in> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  target (io || trIO1) (initial M1) = p1 \\<and>\n  path M1 (io || trIO1) (initial M1) \\<and> length io = length trIO1\n\ngoal (1 subgoal):\n 1. p1 \\<in> io_targets M1 (initial M1) io", "by auto"], ["proof (state)\nthis:\n  p1 \\<in> io_targets M1 (initial M1) io\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  p1 \\<in> io_targets M1 (initial M1) io", "have targets_1 : \"io_targets M1 (initial M1) io = {p1}\""], ["proof (prove)\nusing this:\n  p1 \\<in> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io = {p1}", "by (metis io_lang_subs assms(2) io_targets_observable_singleton_ex singletonD)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) io = {p1}\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io = {(p2,p1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n    {(p2, p1)}", "using targets_2 targets_1"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io = {p2}\n  io_targets M1 (initial M1) io = {p1}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n    {(p2, p1)}", "by simp"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n  {(p2, p1)}\n\ngoal (2 subgoals):\n 1. io \\<in> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n 2. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n  {(p2, p1)}", "show \"io_targets PM (initial PM) io\n                = io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n  {(p2, p1)}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "using targets_pm"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io =\n  {(p2, p1)}\n  io_targets PM (initial PM) io = {(p2, p1)}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "by simp"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "case False"], ["proof (state)\nthis:\n  io \\<notin> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<notin> R M2 s vs xs", "have \"io \\<notin> R M2 s vs xs \\<and> RP M2 s vs xs V'' = insert io (R M2 s vs xs)\""], ["proof (prove)\nusing this:\n  io \\<notin> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<and>\n    RP M2 s vs xs V'' = insert io (R M2 s vs xs)", "using RP_cases assms(9)"], ["proof (prove)\nusing this:\n  io \\<notin> R M2 s vs xs\n  RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n  (\\<exists>vs'\\<in>V''.\n      vs' \\<notin> R M2 s vs xs \\<and>\n      RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\n  io \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<and>\n    RP M2 s vs xs V'' = insert io (R M2 s vs xs)", "by (metis insertE)"], ["proof (state)\nthis:\n  io \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert io (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"io \\<in> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> L M1", "using assms(8) perm_language assms(9)"], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M1\n  \\<lbrakk>?V'' \\<in> Perm ?V ?M; ?vs \\<in> ?V''\\<rbrakk>\n  \\<Longrightarrow> ?vs \\<in> L ?M\n  io \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. io \\<in> L M1", "using False"], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M1\n  \\<lbrakk>?V'' \\<in> Perm ?V ?M; ?vs \\<in> ?V''\\<rbrakk>\n  \\<Longrightarrow> ?vs \\<in> L ?M\n  io \\<in> RP M2 s vs xs V''\n  io \\<notin> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. io \\<in> L M1", "by auto"], ["proof (state)\nthis:\n  io \\<in> L M1\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M1", "obtain s' where s'_def : \"io_targets M1 (initial M1) io = {s'}\""], ["proof (prove)\nusing this:\n  io \\<in> L M1\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        io_targets M1 (initial M1) io = {s'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(2) io_targets_observable_singleton_ob)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) io = {s'}\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) io = {s'}", "obtain tr1 where tr1_def : \"target (io || tr1) (initial M1) = s'\n                                      \\<and> path M1 (io || tr1) (initial M1) \\<and> length tr1 = length io\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) io = {s'}\n\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        target (io || tr1) (initial M1) = s' \\<and>\n        path M1 (io || tr1) (initial M1) \\<and>\n        length tr1 = length io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis io_targets_elim singletonI)"], ["proof (state)\nthis:\n  target (io || tr1) (initial M1) = s' \\<and>\n  path M1 (io || tr1) (initial M1) \\<and> length tr1 = length io\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "using assms(9) assms(3) RP_state_component_2"], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s vs xs V''\n  observable M2\n  \\<lbrakk>?io \\<in> RP ?M2.0 ?s ?vs ?xs ?V''; observable ?M2.0\\<rbrakk>\n  \\<Longrightarrow> io_targets ?M2.0 (initial ?M2.0) ?io = {?s}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "by simp"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {s}\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) io = {s}", "obtain tr2 where tr2_def : \"target (io || tr2) (initial M2) = s\n                                      \\<and> path M2 (io || tr2) (initial M2) \\<and> length tr2 = length io\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) io = {s}\n\ngoal (1 subgoal):\n 1. (\\<And>tr2.\n        target (io || tr2) (initial M2) = s \\<and>\n        path M2 (io || tr2) (initial M2) \\<and>\n        length tr2 = length io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis io_targets_elim singletonI)"], ["proof (state)\nthis:\n  target (io || tr2) (initial M2) = s \\<and>\n  path M2 (io || tr2) (initial M2) \\<and> length tr2 = length io\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  target (io || tr2) (initial M2) = s \\<and>\n  path M2 (io || tr2) (initial M2) \\<and> length tr2 = length io", "have paths : \"path M2 (io || tr2) (initial M2) \\<and> path M1 (io || tr1) (initial M1)\""], ["proof (prove)\nusing this:\n  target (io || tr2) (initial M2) = s \\<and>\n  path M2 (io || tr2) (initial M2) \\<and> length tr2 = length io\n\ngoal (1 subgoal):\n 1. path M2 (io || tr2) (initial M2) \\<and> path M1 (io || tr1) (initial M1)", "using tr1_def"], ["proof (prove)\nusing this:\n  target (io || tr2) (initial M2) = s \\<and>\n  path M2 (io || tr2) (initial M2) \\<and> length tr2 = length io\n  target (io || tr1) (initial M1) = s' \\<and>\n  path M1 (io || tr1) (initial M1) \\<and> length tr1 = length io\n\ngoal (1 subgoal):\n 1. path M2 (io || tr2) (initial M2) \\<and> path M1 (io || tr1) (initial M1)", "by simp"], ["proof (state)\nthis:\n  path M2 (io || tr2) (initial M2) \\<and> path M1 (io || tr1) (initial M1)\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"length io = length tr2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length io = length tr2", "using tr2_def"], ["proof (prove)\nusing this:\n  target (io || tr2) (initial M2) = s \\<and>\n  path M2 (io || tr2) (initial M2) \\<and> length tr2 = length io\n\ngoal (1 subgoal):\n 1. length io = length tr2", "by simp"], ["proof (state)\nthis:\n  length io = length tr2\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "moreover"], ["proof (state)\nthis:\n  length io = length tr2\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"length tr2 = length tr1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length tr2 = length tr1", "using tr1_def tr2_def"], ["proof (prove)\nusing this:\n  target (io || tr1) (initial M1) = s' \\<and>\n  path M1 (io || tr1) (initial M1) \\<and> length tr1 = length io\n  target (io || tr2) (initial M2) = s \\<and>\n  path M2 (io || tr2) (initial M2) \\<and> length tr2 = length io\n\ngoal (1 subgoal):\n 1. length tr2 = length tr1", "by simp"], ["proof (state)\nthis:\n  length tr2 = length tr1\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "ultimately"], ["proof (chain)\npicking this:\n  length io = length tr2\n  length tr2 = length tr1", "have \"path PM (io || tr2 || tr1) (initial M2, initial M1)\""], ["proof (prove)\nusing this:\n  length io = length tr2\n  length tr2 = length tr1\n\ngoal (1 subgoal):\n 1. path PM (io || tr2 || tr1) (initial M2, initial M1)", "using assms(6) assms(5) assms(4) paths\n            productF_path_forward[of io tr2 tr1 M2 M1 FAIL PM \"initial M2\" \"initial M1\"]"], ["proof (prove)\nusing this:\n  length io = length tr2\n  length tr2 = length tr1\n  productF M2 M1 FAIL PM\n  well_formed M2\n  well_formed M1\n  path M2 (io || tr2) (initial M2) \\<and> path M1 (io || tr1) (initial M1)\n  \\<lbrakk>length io = length tr2; length tr2 = length tr1;\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path M2 (io || tr2) (initial M2) \\<and>\n   path M1 (io || tr1) (initial M1) \\<or>\n   target (io || tr2 || tr1) (initial M2, initial M1) = FAIL \\<and>\n   0 < length io \\<and>\n   path M2 (butlast (io || tr2)) (initial M2) \\<and>\n   path M1 (butlast (io || tr1)) (initial M1) \\<and>\n   succ M2 (last io) (target (butlast (io || tr2)) (initial M2)) = {} \\<and>\n   succ M1 (last io) (target (butlast (io || tr1)) (initial M1)) \\<noteq>\n   {};\n   initial M2 \\<in> nodes M2; initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> path PM (io || tr2 || tr1) (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. path PM (io || tr2 || tr1) (initial M2, initial M1)", "by blast"], ["proof (state)\nthis:\n  path PM (io || tr2 || tr1) (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "moreover"], ["proof (state)\nthis:\n  path PM (io || tr2 || tr1) (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"target (io || tr2 || tr1) (initial M2, initial M1) = (s,s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || tr2 || tr1) (initial M2, initial M1) = (s, s')", "by (simp add: tr1_def tr2_def)"], ["proof (state)\nthis:\n  target (io || tr2 || tr1) (initial M2, initial M1) = (s, s')\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "moreover"], ["proof (state)\nthis:\n  target (io || tr2 || tr1) (initial M2, initial M1) = (s, s')\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"length (tr2 || tr2) = length io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (tr2 || tr2) = length io", "using tr1_def tr2_def"], ["proof (prove)\nusing this:\n  target (io || tr1) (initial M1) = s' \\<and>\n  path M1 (io || tr1) (initial M1) \\<and> length tr1 = length io\n  target (io || tr2) (initial M2) = s \\<and>\n  path M2 (io || tr2) (initial M2) \\<and> length tr2 = length io\n\ngoal (1 subgoal):\n 1. length (tr2 || tr2) = length io", "by simp"], ["proof (state)\nthis:\n  length (tr2 || tr2) = length io\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "moreover"], ["proof (state)\nthis:\n  length (tr2 || tr2) = length io\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"(initial M2, initial M1) = initial PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (initial M2, initial M1) = initial PM", "using assms(6)"], ["proof (prove)\nusing this:\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. (initial M2, initial M1) = initial PM", "by simp"], ["proof (state)\nthis:\n  (initial M2, initial M1) = initial PM\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "ultimately"], ["proof (chain)\npicking this:\n  path PM (io || tr2 || tr1) (initial M2, initial M1)\n  target (io || tr2 || tr1) (initial M2, initial M1) = (s, s')\n  length (tr2 || tr2) = length io\n  (initial M2, initial M1) = initial PM", "have \"(s,s') \\<in> io_targets PM (initial PM) io\""], ["proof (prove)\nusing this:\n  path PM (io || tr2 || tr1) (initial M2, initial M1)\n  target (io || tr2 || tr1) (initial M2, initial M1) = (s, s')\n  length (tr2 || tr2) = length io\n  (initial M2, initial M1) = initial PM\n\ngoal (1 subgoal):\n 1. (s, s') \\<in> io_targets PM (initial PM) io", "by (metis io_target_from_path length_zip tr1_def tr2_def)"], ["proof (state)\nthis:\n  (s, s') \\<in> io_targets PM (initial PM) io\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "moreover"], ["proof (state)\nthis:\n  (s, s') \\<in> io_targets PM (initial PM) io\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "have \"observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable PM", "using assms(2) assms(3) assms(6) observable_productF"], ["proof (prove)\nusing this:\n  observable M1\n  observable M2\n  productF M2 M1 FAIL PM\n  \\<lbrakk>observable ?M1.0; observable ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> observable ?PM\n\ngoal (1 subgoal):\n 1. observable PM", "by blast"], ["proof (state)\nthis:\n  observable PM\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  observable PM", "have \"io_targets PM (initial PM) io = {(s,s')}\""], ["proof (prove)\nusing this:\n  observable PM\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {(s, s')}", "by (meson calculation observable_io_target_is_singleton)"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io = {(s, s')}\n\ngoal (1 subgoal):\n 1. io \\<notin> R M2 s vs xs \\<Longrightarrow>\n    io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io_targets PM (initial PM) io = {(s, s')}", "show ?thesis"], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io = {(s, s')}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "using \\<open>io_targets M2 (initial M2) io = {s}\\<close> \\<open>io_targets M1 (initial M1) io = {s'}\\<close>"], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io = {(s, s')}\n  io_targets M2 (initial M2) io = {s}\n  io_targets M1 (initial M1) io = {s'}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "by simp"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma RP_io_targets_finite_M1 :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\nshows \"finite (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (RP M2 s vs xs V'')\n 2. \\<And>a.\n       a \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "show \"finite (RP M2 s vs xs V'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (RP M2 s vs xs V'')", "using finite_RP assms(3) assms(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_det_state_cover ?M2.0 ?V; ?V'' \\<in> Perm ?V ?M1.0\\<rbrakk>\n  \\<Longrightarrow> finite (RP ?M2.0 ?s ?vs ?xs ?V'')\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. finite (RP M2 s vs xs V'')", "by simp"], ["proof (state)\nthis:\n  finite (RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "show \"\\<And>a. a \\<in> RP M2 s vs xs V'' \\<Longrightarrow> finite (io_targets M1 (initial M1) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "assume \"a \\<in> RP M2 s vs xs V''\""], ["proof (state)\nthis:\n  a \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "have RP_cases : \"RP M2 s vs xs V'' = R M2 s vs xs\n                      \\<or> (\\<exists> vs' \\<in> V'' . vs' \\<notin> R M2 s vs xs\n                                        \\<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n    (\\<exists>vs'\\<in>V''.\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))", "using RP_from_R assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_det_state_cover ?M2.0 ?V; ?V'' \\<in> Perm ?V ?M1.0\\<rbrakk>\n  \\<Longrightarrow> RP ?M2.0 ?s ?vs ?xs ?V'' = R ?M2.0 ?s ?vs ?xs \\<or>\n                    (\\<exists>vs'\\<in>?V''.\n                        vs' \\<notin> R ?M2.0 ?s ?vs ?xs \\<and>\n                        RP ?M2.0 ?s ?vs ?xs ?V'' =\n                        insert vs' (R ?M2.0 ?s ?vs ?xs))\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n    (\\<exists>vs'\\<in>V''.\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))", "by metis"], ["proof (state)\nthis:\n  RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n  (\\<exists>vs'\\<in>V''.\n      vs' \\<notin> R M2 s vs xs \\<and>\n      RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "have \"a \\<in> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> L M1", "proof (cases \"a \\<in> R M2 s vs xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> R M2 s vs xs \\<Longrightarrow> a \\<in> L M1\n 2. a \\<notin> R M2 s vs xs \\<Longrightarrow> a \\<in> L M1", "case True"], ["proof (state)\nthis:\n  a \\<in> R M2 s vs xs\n\ngoal (2 subgoals):\n 1. a \\<in> R M2 s vs xs \\<Longrightarrow> a \\<in> L M1\n 2. a \\<notin> R M2 s vs xs \\<Longrightarrow> a \\<in> L M1", "then"], ["proof (chain)\npicking this:\n  a \\<in> R M2 s vs xs", "have \"prefix a (vs@xs)\""], ["proof (prove)\nusing this:\n  a \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. prefix a (vs @ xs)", "by auto"], ["proof (state)\nthis:\n  prefix a (vs @ xs)\n\ngoal (2 subgoals):\n 1. a \\<in> R M2 s vs xs \\<Longrightarrow> a \\<in> L M1\n 2. a \\<notin> R M2 s vs xs \\<Longrightarrow> a \\<in> L M1", "then"], ["proof (chain)\npicking this:\n  prefix a (vs @ xs)", "show \"a \\<in> L M1\""], ["proof (prove)\nusing this:\n  prefix a (vs @ xs)\n\ngoal (1 subgoal):\n 1. a \\<in> L M1", "using language_state_prefix"], ["proof (prove)\nusing this:\n  prefix a (vs @ xs)\n  ?w1.0 @ ?w2.0 \\<in> LS ?M ?q \\<Longrightarrow> ?w1.0 \\<in> LS ?M ?q\n\ngoal (1 subgoal):\n 1. a \\<in> L M1", "by (metis IntD1 assms(1) prefix_def)"], ["proof (state)\nthis:\n  a \\<in> L M1\n\ngoal (1 subgoal):\n 1. a \\<notin> R M2 s vs xs \\<Longrightarrow> a \\<in> L M1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> R M2 s vs xs \\<Longrightarrow> a \\<in> L M1", "case False"], ["proof (state)\nthis:\n  a \\<notin> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. a \\<notin> R M2 s vs xs \\<Longrightarrow> a \\<in> L M1", "then"], ["proof (chain)\npicking this:\n  a \\<notin> R M2 s vs xs", "have \"a \\<in> V'' \\<and> RP M2 s vs xs V'' = insert a (R M2 s vs xs)\""], ["proof (prove)\nusing this:\n  a \\<notin> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. a \\<in> V'' \\<and> RP M2 s vs xs V'' = insert a (R M2 s vs xs)", "using RP_cases \\<open>a \\<in> RP M2 s vs xs V''\\<close>"], ["proof (prove)\nusing this:\n  a \\<notin> R M2 s vs xs\n  RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n  (\\<exists>vs'\\<in>V''.\n      vs' \\<notin> R M2 s vs xs \\<and>\n      RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\n  a \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. a \\<in> V'' \\<and> RP M2 s vs xs V'' = insert a (R M2 s vs xs)", "by (metis insertE)"], ["proof (state)\nthis:\n  a \\<in> V'' \\<and> RP M2 s vs xs V'' = insert a (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. a \\<notin> R M2 s vs xs \\<Longrightarrow> a \\<in> L M1", "then"], ["proof (chain)\npicking this:\n  a \\<in> V'' \\<and> RP M2 s vs xs V'' = insert a (R M2 s vs xs)", "show \"a \\<in> L M1\""], ["proof (prove)\nusing this:\n  a \\<in> V'' \\<and> RP M2 s vs xs V'' = insert a (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. a \\<in> L M1", "by (meson assms(4) perm_language)"], ["proof (state)\nthis:\n  a \\<in> L M1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "then"], ["proof (chain)\npicking this:\n  a \\<in> L M1", "obtain p where \"io_targets M1 (initial M1) a = {p}\""], ["proof (prove)\nusing this:\n  a \\<in> L M1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        io_targets M1 (initial M1) a = {p} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) io_targets_observable_singleton_ob"], ["proof (prove)\nusing this:\n  a \\<in> L M1\n  observable M1\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0;\n   \\<And>q2.\n      io_targets ?M ?q1.0 ?io = {q2} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        io_targets M1 (initial M1) a = {p} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) a = {p}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) a = {p}", "show \"finite (io_targets M1 (initial M1) a)\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) a = {p}\n\ngoal (1 subgoal):\n 1. finite (io_targets M1 (initial M1) a)", "by simp"], ["proof (state)\nthis:\n  finite (io_targets M1 (initial M1) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n  finite (io_targets M1 (initial M1) ?a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma RP_io_targets_finite_PM :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\nshows \"finite (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s vs xs V'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))", "have \"\\<forall> io \\<in> RP M2 s vs xs V'' . io_targets PM (initial PM) io\n                                    = {s} \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>RP M2 s vs xs V''.\n       io_targets PM (initial PM) io =\n       {s} \\<times> io_targets M1 (initial M1) io", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s} \\<times> io_targets M1 (initial M1) io", "fix io"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s} \\<times> io_targets M1 (initial M1) io", "assume \"io \\<in> RP M2 s vs xs V''\""], ["proof (state)\nthis:\n  io \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s} \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<in> RP M2 s vs xs V''", "have \"io_targets PM (initial PM) io\n                = io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s vs xs V''\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "using assms RP_io_targets_split[of vs xs M1 M2 FAIL PM V V'' io s]"], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s vs xs V''\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  \\<lbrakk>vs @ xs \\<in> L M1 \\<inter> L M2; observable M1; observable M2;\n   well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n   is_det_state_cover M2 V; V'' \\<in> Perm V M1;\n   io \\<in> RP M2 s vs xs V''\\<rbrakk>\n  \\<Longrightarrow> io_targets PM (initial PM) io =\n                    io_targets M2 (initial M2) io \\<times>\n                    io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "by simp"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s} \\<times> io_targets M1 (initial M1) io", "moreover"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s} \\<times> io_targets M1 (initial M1) io", "have \"io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "using \\<open>io \\<in> RP M2 s vs xs V''\\<close> assms(3) RP_state_component_2[of io M2 s vs xs V'']"], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s vs xs V''\n  observable M2\n  \\<lbrakk>io \\<in> RP M2 s vs xs V''; observable M2\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 (initial M2) io = {s}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "by blast"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {s}\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s} \\<times> io_targets M1 (initial M1) io", "ultimately"], ["proof (chain)\npicking this:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n  io_targets M2 (initial M2) io = {s}", "show \"io_targets PM (initial PM) io = {s} \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n  io_targets M2 (initial M2) io = {s}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    {s} \\<times> io_targets M1 (initial M1) io", "by auto"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io = {s} \\<times> io_targets M1 (initial M1) io\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>io\\<in>RP M2 s vs xs V''.\n     io_targets PM (initial PM) io =\n     {s} \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))", "then"], ["proof (chain)\npicking this:\n  \\<forall>io\\<in>RP M2 s vs xs V''.\n     io_targets PM (initial PM) io =\n     {s} \\<times> io_targets M1 (initial M1) io", "have \"\\<Union> (image (io_targets PM (initial PM)) (RP M2 s vs xs V''))\n              = \\<Union> (image (\\<lambda> io . {s} \\<times> io_targets M1 (initial M1) io) (RP M2 s vs xs V''))\""], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>RP M2 s vs xs V''.\n     io_targets PM (initial PM) io =\n     {s} \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V'') =\n    (\\<Union>io\\<in>RP M2 s vs xs V''.\n        {s} \\<times> io_targets M1 (initial M1) io)", "by simp"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s vs xs V''.\n      {s} \\<times> io_targets M1 (initial M1) io)\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))", "moreover"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s vs xs V''.\n      {s} \\<times> io_targets M1 (initial M1) io)\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))", "have \"\\<Union> (image (\\<lambda> io . {s} \\<times> io_targets M1 (initial M1) io) (RP M2 s vs xs V''))\n                  = {s} \\<times> \\<Union> (image (\\<lambda> io . io_targets M1 (initial M1) io) (RP M2 s vs xs V''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>io\\<in>RP M2 s vs xs V''.\n        {s} \\<times> io_targets M1 (initial M1) io) =\n    {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')", "by blast"], ["proof (state)\nthis:\n  (\\<Union>io\\<in>RP M2 s vs xs V''.\n      {s} \\<times> io_targets M1 (initial M1) io) =\n  {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))", "ultimately"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s vs xs V''.\n      {s} \\<times> io_targets M1 (initial M1) io)\n  (\\<Union>io\\<in>RP M2 s vs xs V''.\n      {s} \\<times> io_targets M1 (initial M1) io) =\n  {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')", "have \"\\<Union> (image (io_targets PM (initial PM)) (RP M2 s vs xs V''))\n                    = {s} \\<times> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))\""], ["proof (prove)\nusing this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s vs xs V''.\n      {s} \\<times> io_targets M1 (initial M1) io)\n  (\\<Union>io\\<in>RP M2 s vs xs V''.\n      {s} \\<times> io_targets M1 (initial M1) io) =\n  {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V'') =\n    {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')", "by auto"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V'') =\n  {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))", "moreover"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V'') =\n  {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))", "have \"finite ({s} \\<times> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ({s} \\<times>\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using assms(1,2,7,8) RP_io_targets_finite_M1[of vs xs M1 M2 V V'' s]"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  \\<lbrakk>vs @ xs \\<in> L M1 \\<inter> L M2; observable M1;\n   is_det_state_cover M2 V; V'' \\<in> Perm V M1\\<rbrakk>\n  \\<Longrightarrow> finite\n                     (\\<Union>\n                       (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. finite\n     ({s} \\<times>\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by simp"], ["proof (state)\nthis:\n  finite\n   ({s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))", "ultimately"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V'') =\n  {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')\n  finite\n   ({s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V'') =\n  {s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')\n  finite\n   ({s} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))", "by simp"], ["proof (state)\nthis:\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s vs xs V''))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma RP_union_card_is_suffix_length :\n  assumes \"OFSM M2\"\n  and     \"io@xs \\<in> L M2\"\n  and     \"is_det_state_cover M2 V\"\n  and     \"V'' \\<in> Perm V M1\"\nshows \"\\<And> q . card (R M2 q io xs) \\<le> card (RP M2 q io xs V'')\"\n      \"sum (\\<lambda> q . card (RP M2 q io xs V'')) (nodes M2) \\<ge> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q. card (R M2 q io xs) \\<le> card (RP M2 q io xs V'')) &&&\n    length xs \\<le> (\\<Sum>q\\<in>nodes M2. card (RP M2 q io xs V''))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. card (R M2 q io xs) \\<le> card (RP M2 q io xs V'')\n 2. length xs \\<le> (\\<Sum>q\\<in>nodes M2. card (RP M2 q io xs V''))", "have \"sum (\\<lambda> q . card (R M2 q io xs)) (nodes M2) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs", "using R_union_card_is_suffix_length[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs", "by assumption"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs\n\ngoal (2 subgoals):\n 1. \\<And>q. card (R M2 q io xs) \\<le> card (RP M2 q io xs V'')\n 2. length xs \\<le> (\\<Sum>q\\<in>nodes M2. card (RP M2 q io xs V''))", "show \"\\<And> q . card (R M2 q io xs) \\<le> card (RP M2 q io xs V'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q. card (R M2 q io xs) \\<le> card (RP M2 q io xs V'')", "by (metis RP_from_R assms(3) assms(4) card_insert_le eq_iff finite_R)"], ["proof (state)\nthis:\n  card (R M2 ?q io xs) \\<le> card (RP M2 ?q io xs V'')\n\ngoal (1 subgoal):\n 1. length xs \\<le> (\\<Sum>q\\<in>nodes M2. card (RP M2 q io xs V''))", "show \"sum (\\<lambda> q . card (RP M2 q io xs V'')) (nodes M2) \\<ge> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> (\\<Sum>q\\<in>nodes M2. card (RP M2 q io xs V''))", "by (metis (no_types, lifting) \\<open>(\\<Sum>q\\<in>nodes M2. card (R M2 q io xs)) = length xs\\<close>\n        \\<open>\\<And>q. card (R M2 q io xs) \\<le> card (RP M2 q io xs V'')\\<close> sum_mono)"], ["proof (state)\nthis:\n  length xs \\<le> (\\<Sum>q\\<in>nodes M2. card (RP M2 q io xs V''))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma RP_state_repetition_distribution_productF :\n  assumes \"OFSM M2\"\n  and     \"OFSM M1\"\n  and     \"(card (nodes M2) * m) \\<le> length xs\"\n  and     \"card (nodes M1) \\<le> m\"\n  and     \"vs@xs \\<in> L M2 \\<inter> L M1\"\n  and     \"is_det_state_cover M2 V\"\n  and     \"V'' \\<in> Perm V M1\"\nshows \"\\<exists> q \\<in> nodes M2 . card (RP M2 q vs xs V'') > m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "have \"finite (nodes M1)\"\n       \"finite (nodes M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M1) &&& finite (nodes M2)", "using assms(1,2)"], ["proof (prove)\nusing this:\n  OFSM M2\n  OFSM M1\n\ngoal (1 subgoal):\n 1. finite (nodes M1) &&& finite (nodes M2)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M1)\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "then"], ["proof (chain)\npicking this:\n  finite (nodes M1)\n  finite (nodes M2)", "have \"card(nodes M2 \\<times> nodes M1) = card (nodes M2) * card (nodes M1)\""], ["proof (prove)\nusing this:\n  finite (nodes M1)\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. card (nodes M2 \\<times> nodes M1) = |M2| * |M1|", "using card_cartesian_product"], ["proof (prove)\nusing this:\n  finite (nodes M1)\n  finite (nodes M2)\n  card (?A \\<times> ?B) = card ?A * card ?B\n\ngoal (1 subgoal):\n 1. card (nodes M2 \\<times> nodes M1) = |M2| * |M1|", "by blast"], ["proof (state)\nthis:\n  card (nodes M2 \\<times> nodes M1) = |M2| * |M1|\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "have \"nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1", "using product_nodes"], ["proof (prove)\nusing this:\n  nodes (product ?A ?B) \\<subseteq> nodes ?A \\<times> nodes ?B\n\ngoal (1 subgoal):\n 1. nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1", "by auto"], ["proof (state)\nthis:\n  nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "have \"card (nodes (product M2 M1)) \\<le> card (nodes M2) * card (nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |product M2 M1| \\<le> |M2| * |M1|", "by (metis (no_types) \\<open>card (nodes M2 \\<times> nodes M1) = |M2| * |M1|\\<close> \\<open>finite (nodes M1)\\<close>\n        \\<open>finite (nodes M2)\\<close> \\<open>nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1\\<close>\n        card_mono finite_cartesian_product)"], ["proof (state)\nthis:\n  |product M2 M1| \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "have \"(\\<forall> q \\<in> nodes M2 . card (R M2 q vs xs) = m) \\<or> (\\<exists> q \\<in> nodes M2 . card (R M2 q vs xs) > m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n    (\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "assume \"\\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or> (\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs)))\""], ["proof (state)\nthis:\n  \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n          (\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs)))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n          (\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs)))", "have \"\\<forall> q \\<in> nodes M2 . card (R M2 q vs xs) \\<le> m\""], ["proof (prove)\nusing this:\n  \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n          (\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs)))\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) \\<le> m", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) \\<le> m\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) \\<le> m\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "obtain q' where \"q'\\<in>nodes M2\" \"card (R M2 q' vs xs) < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> nodes M2; card (R M2 q' vs xs) < m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or> (\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs)))\\<close>\n            nat_neq_iff"], ["proof (prove)\nusing this:\n  \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n          (\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs)))\n  (?m \\<noteq> ?n) = (?m < ?n \\<or> ?n < ?m)\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> nodes M2; card (R M2 q' vs xs) < m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q' \\<in> nodes M2\n  card (R M2 q' vs xs) < m\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "have \"sum (\\<lambda> q . card (R M2 q vs xs)) (nodes M2)\n          = sum (\\<lambda> q . card (R M2 q vs xs)) (nodes M2 - {q'})\n            + sum (\\<lambda> q . card (R M2 q vs xs)) {q'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) =\n    (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) +\n    (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs))", "using \\<open>q'\\<in>nodes M2\\<close>"], ["proof (prove)\nusing this:\n  q' \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) =\n    (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) +\n    (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs))", "by (meson \\<open>finite (nodes M2)\\<close> empty_subsetI insert_subset sum.subset_diff)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) =\n  (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) +\n  (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) =\n  (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) +\n  (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "have \"sum (\\<lambda> q . card (R M2 q vs xs)) (nodes M2 - {q'})\n                    \\<le> sum (\\<lambda> q . m) (nodes M2 - {q'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n    \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m)", "using \\<open>\\<forall> q \\<in> nodes M2 . card (R M2 q vs xs) \\<le> m\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n    \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m)", "by (meson sum_mono DiffD1)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n  \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n  \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "have \"sum (\\<lambda> q . card (R M2 q vs xs)) {q'} < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs)) < m", "using \\<open>card (R M2 q' vs xs) < m\\<close>"], ["proof (prove)\nusing this:\n  card (R M2 q' vs xs) < m\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs)) < m", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs)) < m\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) \\<le> m\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) =\n  (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) +\n  (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs))\n  (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n  \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m)\n  (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs)) < m", "have \"sum (\\<lambda> q . card (R M2 q vs xs)) (nodes M2) < sum (\\<lambda> q . m) (nodes M2)\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) \\<le> m\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) =\n  (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) +\n  (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs))\n  (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n  \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m)\n  (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs)) < m\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < (\\<Sum>q\\<in>nodes M2. m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) \\<le> m;\n     (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) =\n     (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) +\n     (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs));\n     (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n     \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m);\n     (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs)) < m\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs))\n                      < (\\<Sum>q\\<in>nodes M2. m)", "have \"\\<forall>C c f. infinite C \\<or> (c::'c) \\<notin> C \\<or> sum f C = (f c::nat) + sum f (C - {c})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C c f.\n       infinite C \\<or> c \\<notin> C \\<or> sum f C = f c + sum f (C - {c})", "by (meson sum.remove)"], ["proof (state)\nthis:\n  \\<forall>C c f.\n     infinite C \\<or> c \\<notin> C \\<or> sum f C = f c + sum f (C - {c})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) \\<le> m;\n     (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) =\n     (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) +\n     (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs));\n     (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n     \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m);\n     (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs)) < m\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs))\n                      < (\\<Sum>q\\<in>nodes M2. m)", "then"], ["proof (chain)\npicking this:\n  \\<forall>C c f.\n     infinite C \\<or> c \\<notin> C \\<or> sum f C = f c + sum f (C - {c})", "have \"(\\<Sum>c\\<in>nodes M2. m) = m + (\\<Sum>c\\<in>nodes M2 - {q'}. m)\""], ["proof (prove)\nusing this:\n  \\<forall>C c f.\n     infinite C \\<or> c \\<notin> C \\<or> sum f C = f c + sum f (C - {c})\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>nodes M2. m) = m + (\\<Sum>c\\<in>nodes M2 - {q'}. m)", "using \\<open>finite (nodes M2)\\<close> \\<open>q' \\<in> nodes M2\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>C c f.\n     infinite C \\<or> c \\<notin> C \\<or> sum f C = f c + sum f (C - {c})\n  finite (nodes M2)\n  q' \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>nodes M2. m) = m + (\\<Sum>c\\<in>nodes M2 - {q'}. m)", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>nodes M2. m) = m + (\\<Sum>c\\<in>nodes M2 - {q'}. m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) \\<le> m;\n     (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) =\n     (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) +\n     (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs));\n     (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n     \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m);\n     (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs)) < m\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs))\n                      < (\\<Sum>q\\<in>nodes M2. m)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>c\\<in>nodes M2. m) = m + (\\<Sum>c\\<in>nodes M2 - {q'}. m)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>c\\<in>nodes M2. m) = m + (\\<Sum>c\\<in>nodes M2 - {q'}. m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < (\\<Sum>q\\<in>nodes M2. m)", "using \\<open>(\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m)\\<close>\n              \\<open>(\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) = (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n                + (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs))\\<close>\n              \\<open>(\\<Sum>q\\<in>{q'}. card (R M2 q vs xs)) < m\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>c\\<in>nodes M2. m) = m + (\\<Sum>c\\<in>nodes M2 - {q'}. m)\n  (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs))\n  \\<le> (\\<Sum>q\\<in>nodes M2 - {q'}. m)\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) =\n  (\\<Sum>q\\<in>nodes M2 - {q'}. card (R M2 q vs xs)) +\n  (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs))\n  (\\<Sum>q\\<in>{q'}. card (R M2 q vs xs)) < m\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < (\\<Sum>q\\<in>nodes M2. m)", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < (\\<Sum>q\\<in>nodes M2. m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < (\\<Sum>q\\<in>nodes M2. m)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < (\\<Sum>q\\<in>nodes M2. m)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "have \"sum (\\<lambda> q . m) (nodes M2) \\<le> card (nodes M2) * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. m) \\<le> |M2| * m", "using assms(2)"], ["proof (prove)\nusing this:\n  OFSM M1\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. m) \\<le> |M2| * m", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. m) \\<le> |M2| * m\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < (\\<Sum>q\\<in>nodes M2. m)\n  (\\<Sum>q\\<in>nodes M2. m) \\<le> |M2| * m", "have \"sum (\\<lambda> q . card (R M2 q vs xs)) (nodes M2) < card (nodes M2) * m\""], ["proof (prove)\nusing this:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < (\\<Sum>q\\<in>nodes M2. m)\n  (\\<Sum>q\\<in>nodes M2. m) \\<le> |M2| * m\n\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < |M2| * m", "by presburger"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < |M2| * m\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < |M2| * m\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "have \"Suc (card (nodes M2)*m) \\<le> sum (\\<lambda> q . card (R M2 q vs xs)) (nodes M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (|M2| * m) \\<le> (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs))", "using R_union_card_is_suffix_length[OF assms(1), of vs xs] assms(5,3)"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M2 \\<Longrightarrow>\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) = length xs\n  vs @ xs \\<in> L M2 \\<inter> L M1\n  |M2| * m \\<le> length xs\n\ngoal (1 subgoal):\n 1. Suc (|M2| * m) \\<le> (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs))", "by (metis Int_iff \\<open>vs @ xs \\<in> L M2 \\<Longrightarrow> (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) = length xs\\<close>\n          \\<open>vs @ xs \\<in> L M2 \\<inter> L M1\\<close> \\<open>|M2| * m \\<le> length xs\\<close> calculation less_eq_Suc_le not_less_eq_eq)"], ["proof (state)\nthis:\n  Suc (|M2| * m) \\<le> (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n            (\\<exists>q\\<in>nodes M2.\n                m < card (R M2 q vs xs))) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < |M2| * m\n  Suc (|M2| * m) \\<le> (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs))", "show \"False\""], ["proof (prove)\nusing this:\n  (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs)) < |M2| * m\n  Suc (|M2| * m) \\<le> (\\<Sum>q\\<in>nodes M2. card (R M2 q vs xs))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n  (\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "then"], ["proof (chain)\npicking this:\n  (\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n  (\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m) \\<or>\n  (\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n 2. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "let ?q = \"initial M2\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n 2. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "assume \"\\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m\""], ["proof (state)\nthis:\n  \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n 2. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m", "have \"card (R M2 ?q vs xs) = m\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m\n\ngoal (1 subgoal):\n 1. card (R M2 (initial M2) vs xs) = m", "by auto"], ["proof (state)\nthis:\n  card (R M2 (initial M2) vs xs) = m\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n 2. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "have \"[] \\<in> V''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> V''", "by (meson assms(6) assms(7) perm_empty)"], ["proof (state)\nthis:\n  [] \\<in> V''\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n 2. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "then"], ["proof (chain)\npicking this:\n  [] \\<in> V''", "have \"[] \\<in> RP M2 ?q vs xs V''\""], ["proof (prove)\nusing this:\n  [] \\<in> V''\n\ngoal (1 subgoal):\n 1. [] \\<in> RP M2 (initial M2) vs xs V''", "by auto"], ["proof (state)\nthis:\n  [] \\<in> RP M2 (initial M2) vs xs V''\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n 2. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "have \"[] \\<notin> R M2 ?q vs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<notin> R M2 (initial M2) vs xs", "by auto"], ["proof (state)\nthis:\n  [] \\<notin> R M2 (initial M2) vs xs\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n 2. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "have \"card (RP M2 ?q vs xs V'') \\<ge> card (R M2 ?q vs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (R M2 (initial M2) vs xs) \\<le> card (RP M2 (initial M2) vs xs V'')", "using finite_R[of M2 ?q vs xs] finite_RP[OF assms(6,7),of ?q vs xs]"], ["proof (prove)\nusing this:\n  finite (R M2 (initial M2) vs xs)\n  finite (RP M2 (initial M2) vs xs V'')\n\ngoal (1 subgoal):\n 1. card (R M2 (initial M2) vs xs) \\<le> card (RP M2 (initial M2) vs xs V'')", "unfolding RP.simps"], ["proof (prove)\nusing this:\n  finite (R M2 (initial M2) vs xs)\n  finite\n   (R M2 (initial M2) vs xs \\<union>\n    {vs' \\<in> V''. io_targets M2 (initial M2) vs' = {initial M2}})\n\ngoal (1 subgoal):\n 1. card (R M2 (initial M2) vs xs)\n    \\<le> card\n           (R M2 (initial M2) vs xs \\<union>\n            {vs' \\<in> V''. io_targets M2 (initial M2) vs' = {initial M2}})", "by (simp add: card_mono)"], ["proof (state)\nthis:\n  card (R M2 (initial M2) vs xs) \\<le> card (RP M2 (initial M2) vs xs V'')\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n 2. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "have \"card (RP M2 ?q vs xs V'') > card (R M2 ?q vs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')", "have f1: \"\\<forall>n na. (\\<not> (n::nat) \\<le> na \\<or> n = na) \\<or> n < na\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n na. (\\<not> n \\<le> na \\<or> n = na) \\<or> n < na", "by (meson le_neq_trans)"], ["proof (state)\nthis:\n  \\<forall>n na. (\\<not> n \\<le> na \\<or> n = na) \\<or> n < na\n\ngoal (1 subgoal):\n 1. card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')", "have \"RP M2 (initial M2) vs xs V'' \\<noteq> R M2 (initial M2) vs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RP M2 (initial M2) vs xs V'' \\<noteq> R M2 (initial M2) vs xs", "using \\<open>[] \\<in> RP M2 (initial M2) vs xs V''\\<close> \\<open>[] \\<notin> R M2 (initial M2) vs xs\\<close>"], ["proof (prove)\nusing this:\n  [] \\<in> RP M2 (initial M2) vs xs V''\n  [] \\<notin> R M2 (initial M2) vs xs\n\ngoal (1 subgoal):\n 1. RP M2 (initial M2) vs xs V'' \\<noteq> R M2 (initial M2) vs xs", "by blast"], ["proof (state)\nthis:\n  RP M2 (initial M2) vs xs V'' \\<noteq> R M2 (initial M2) vs xs\n\ngoal (1 subgoal):\n 1. card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')", "then"], ["proof (chain)\npicking this:\n  RP M2 (initial M2) vs xs V'' \\<noteq> R M2 (initial M2) vs xs", "show ?thesis"], ["proof (prove)\nusing this:\n  RP M2 (initial M2) vs xs V'' \\<noteq> R M2 (initial M2) vs xs\n\ngoal (1 subgoal):\n 1. card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')", "using f1"], ["proof (prove)\nusing this:\n  RP M2 (initial M2) vs xs V'' \\<noteq> R M2 (initial M2) vs xs\n  \\<forall>n na. (\\<not> n \\<le> na \\<or> n = na) \\<or> n < na\n\ngoal (1 subgoal):\n 1. card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')", "by (metis (no_types) RP_from_R\n                     \\<open>card (R M2 (initial M2) vs xs) \\<le> card (RP M2 (initial M2) vs xs V'')\\<close>\n                     assms(6) assms(7) card_insert_disjoint finite_R le_simps(2))"], ["proof (state)\nthis:\n  card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>nodes M2. card (R M2 q vs xs) = m \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n 2. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "then"], ["proof (chain)\npicking this:\n  card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')", "show ?thesis"], ["proof (prove)\nusing this:\n  card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "using \\<open>card (R M2 ?q vs xs) = m\\<close>"], ["proof (prove)\nusing this:\n  card (R M2 (initial M2) vs xs) < card (RP M2 (initial M2) vs xs V'')\n  card (R M2 (initial M2) vs xs) = m\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "by blast"], ["proof (state)\nthis:\n  \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "assume \"\\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs)\""], ["proof (state)\nthis:\n  \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "then"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs)", "obtain q where \"q\\<in>nodes M2\" \"m < card (R M2 q vs xs)\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> nodes M2; m < card (R M2 q vs xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q \\<in> nodes M2\n  m < card (R M2 q vs xs)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "moreover"], ["proof (state)\nthis:\n  q \\<in> nodes M2\n  m < card (R M2 q vs xs)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "have \"card (RP M2 q vs xs V'') \\<ge> card (R M2 q vs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (R M2 q vs xs) \\<le> card (RP M2 q vs xs V'')", "using finite_R[of M2 q vs xs] finite_RP[OF assms(6,7),of q vs xs]"], ["proof (prove)\nusing this:\n  finite (R M2 q vs xs)\n  finite (RP M2 q vs xs V'')\n\ngoal (1 subgoal):\n 1. card (R M2 q vs xs) \\<le> card (RP M2 q vs xs V'')", "unfolding RP.simps"], ["proof (prove)\nusing this:\n  finite (R M2 q vs xs)\n  finite\n   (R M2 q vs xs \\<union>\n    {vs' \\<in> V''. io_targets M2 (initial M2) vs' = {q}})\n\ngoal (1 subgoal):\n 1. card (R M2 q vs xs)\n    \\<le> card\n           (R M2 q vs xs \\<union>\n            {vs' \\<in> V''. io_targets M2 (initial M2) vs' = {q}})", "by (simp add: card_mono)"], ["proof (state)\nthis:\n  card (R M2 q vs xs) \\<le> card (RP M2 q vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "ultimately"], ["proof (chain)\npicking this:\n  q \\<in> nodes M2\n  m < card (R M2 q vs xs)\n  card (R M2 q vs xs) \\<le> card (RP M2 q vs xs V'')", "have \"m < card (RP M2 q vs xs V'')\""], ["proof (prove)\nusing this:\n  q \\<in> nodes M2\n  m < card (R M2 q vs xs)\n  card (R M2 q vs xs) \\<le> card (RP M2 q vs xs V'')\n\ngoal (1 subgoal):\n 1. m < card (RP M2 q vs xs V'')", "by simp"], ["proof (state)\nthis:\n  m < card (RP M2 q vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (R M2 q vs xs) \\<Longrightarrow>\n    \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "using \\<open>q \\<in> nodes M2\\<close>  \\<open>m < card (RP M2 q vs xs V'')\\<close>"], ["proof (prove)\nusing this:\n  q \\<in> nodes M2\n  m < card (RP M2 q vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')", "by blast"], ["proof (state)\nthis:\n  \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q\\<in>nodes M2. m < card (RP M2 q vs xs V'')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Conditions for the result of LB to be a valid lower bound \\<close>"], ["", "text \\<open>\nThe following predicates describe the assumptions necessary to show that the value calculated by\n@{verbatim LB} is a lower bound on the number of states of a given FSM.\n\\<close>"], ["", "fun Prereq :: \"('in, 'out, 'state1) FSM \\<Rightarrow> ('in, 'out, 'state2) FSM \\<Rightarrow> ('in \\<times> 'out) list\n              \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> 'in list set \\<Rightarrow> 'state1 set \\<Rightarrow> ('in, 'out) ATC set\n              \\<Rightarrow> ('in \\<times> 'out) list set \\<Rightarrow> bool\"\n  where\n  \"Prereq M2 M1 vs xs T S \\<Omega> V'' = (\n    (finite T)\n    \\<and> (vs @ xs) \\<in> L M2 \\<inter> L M1\n    \\<and> S \\<subseteq> nodes M2\n    \\<and> (\\<forall> s1 \\<in> S . \\<forall> s2 \\<in> S . s1 \\<noteq> s2\n        \\<longrightarrow> (\\<forall> io1 \\<in> RP M2 s1 vs xs V'' .\n               \\<forall> io2 \\<in> RP M2 s2 vs xs V'' .\n                 B M1 io1 \\<Omega> \\<noteq> B M1 io2 \\<Omega> )))\""], ["", "fun Rep_Pre :: \"('in, 'out, 'state1) FSM \\<Rightarrow> ('in, 'out, 'state2) FSM \\<Rightarrow> ('in \\<times> 'out) list\n                \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> bool\" where\n  \"Rep_Pre M2 M1 vs xs = (\\<exists> xs1 xs2 . prefix xs1 xs2 \\<and> prefix xs2 xs \\<and> xs1 \\<noteq> xs2\n    \\<and> (\\<exists> s2 . io_targets M2 (initial M2) (vs @ xs1) = {s2}\n              \\<and> io_targets M2 (initial M2) (vs @ xs2) = {s2})\n    \\<and> (\\<exists> s1 . io_targets M1 (initial M1) (vs @ xs1) = {s1}\n              \\<and> io_targets M1 (initial M1) (vs @ xs2) = {s1}))\""], ["", "fun Rep_Cov :: \"('in, 'out, 'state1) FSM \\<Rightarrow> ('in, 'out, 'state2) FSM \\<Rightarrow> ('in \\<times> 'out) list set\n                \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> bool\" where\n  \"Rep_Cov M2 M1 V'' vs xs = (\\<exists> xs' vs' . xs' \\<noteq> [] \\<and> prefix xs' xs \\<and> vs' \\<in> V''\n    \\<and> (\\<exists> s2 . io_targets M2 (initial M2) (vs @ xs') = {s2}\n              \\<and> io_targets M2 (initial M2) (vs') = {s2})\n    \\<and> (\\<exists> s1 . io_targets M1 (initial M1) (vs @ xs') = {s1}\n              \\<and> io_targets M1 (initial M1) (vs') = {s1}))\""], ["", "lemma distinctness_via_Rep_Pre :\n  assumes \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\nshows \"distinct (states (xs || tr) (q2, q1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (states (xs || tr) (q2, q1))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "assume assm : \"\\<not> distinct (states (xs || tr) (q2, q1))\""], ["proof (state)\nthis:\n  \\<not> distinct (states (xs || tr) (q2, q1))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct (states (xs || tr) (q2, q1))", "obtain i1 i2 where index_def :\n     \"i1 \\<noteq> 0\n      \\<and> i1 \\<noteq> i2\n      \\<and> i1 < length (states (xs || tr) (q2, q1))\n      \\<and> i2 < length (states (xs || tr) (q2, q1))\n      \\<and> (states (xs || tr) (q2, q1)) ! i1 = (states (xs || tr) (q2, q1)) ! i2\""], ["proof (prove)\nusing this:\n  \\<not> distinct (states (xs || tr) (q2, q1))\n\ngoal (1 subgoal):\n 1. (\\<And>i1 i2.\n        i1 \\<noteq> 0 \\<and>\n        i1 \\<noteq> i2 \\<and>\n        i1 < length (states (xs || tr) (q2, q1)) \\<and>\n        i2 < length (states (xs || tr) (q2, q1)) \\<and>\n        states (xs || tr) (q2, q1) ! i1 =\n        states (xs || tr) (q2, q1) ! i2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis distinct_conv_nth)"], ["proof (state)\nthis:\n  i1 \\<noteq> 0 \\<and>\n  i1 \\<noteq> i2 \\<and>\n  i1 < length (states (xs || tr) (q2, q1)) \\<and>\n  i2 < length (states (xs || tr) (q2, q1)) \\<and>\n  states (xs || tr) (q2, q1) ! i1 = states (xs || tr) (q2, q1) ! i2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  i1 \\<noteq> 0 \\<and>\n  i1 \\<noteq> i2 \\<and>\n  i1 < length (states (xs || tr) (q2, q1)) \\<and>\n  i2 < length (states (xs || tr) (q2, q1)) \\<and>\n  states (xs || tr) (q2, q1) ! i1 = states (xs || tr) (q2, q1) ! i2", "have \"length xs > 0\""], ["proof (prove)\nusing this:\n  i1 \\<noteq> 0 \\<and>\n  i1 \\<noteq> i2 \\<and>\n  i1 < length (states (xs || tr) (q2, q1)) \\<and>\n  i2 < length (states (xs || tr) (q2, q1)) \\<and>\n  states (xs || tr) (q2, q1) ! i1 = states (xs || tr) (q2, q1) ! i2\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by auto"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "let ?xs1 = \"take (Suc i1) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "let ?xs2 = \"take (Suc i2) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "let ?tr1 = \"take (Suc i1) tr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "let ?tr2 = \"take (Suc i2) tr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "let ?st  = \"(states (xs || tr) (q2, q1)) ! i1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have obs_PM : \"observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable PM", "using observable_productF assms(2) assms(3) assms(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>observable ?M1.0; observable ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> observable ?PM\n  productF M2 M1 FAIL PM\n  observable M1\n  observable M2\n\ngoal (1 subgoal):\n 1. observable PM", "by blast"], ["proof (state)\nthis:\n  observable PM\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"initial PM = (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial PM = (initial M2, initial M1)", "using assms(2)"], ["proof (prove)\nusing this:\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. initial PM = (initial M2, initial M1)", "by simp"], ["proof (state)\nthis:\n  initial PM = (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  initial PM = (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"vs \\<in> L M2\" \"vs \\<in> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> L M2 &&& vs \\<in> L M1", "using assms(8) language_state_prefix"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  ?w1.0 @ ?w2.0 \\<in> LS ?M ?q \\<Longrightarrow> ?w1.0 \\<in> LS ?M ?q\n\ngoal (1 subgoal):\n 1. vs \\<in> L M2 &&& vs \\<in> L M1", "by auto"], ["proof (state)\nthis:\n  vs \\<in> L M2\n  vs \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  initial PM = (initial M2, initial M1)\n  vs \\<in> L M2\n  vs \\<in> L M1", "have \"io_targets M1 (initial M1) vs = {q1}\" \"io_targets M2 (initial M2) vs = {q2}\""], ["proof (prove)\nusing this:\n  initial PM = (initial M2, initial M1)\n  vs \\<in> L M2\n  vs \\<in> L M1\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) vs = {q1} &&&\n    io_targets M2 (initial M2) vs = {q2}", "using productF_path_io_targets[of M2 M1 FAIL PM \"initial M2\" \"initial M1\" vs q2 q1]"], ["proof (prove)\nusing this:\n  initial PM = (initial M2, initial M1)\n  vs \\<in> L M2\n  vs \\<in> L M1\n  \\<lbrakk>productF M2 M1 FAIL PM;\n   io_targets PM (initial M2, initial M1) vs = {(q2, q1)}; vs \\<in> L M2;\n   vs \\<in> L M1; observable M2; observable M1; well_formed M2;\n   well_formed M1; initial M2 \\<in> nodes M2;\n   initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> q2 \\<in> io_targets M2 (initial M2) vs\n  \\<lbrakk>productF M2 M1 FAIL PM;\n   io_targets PM (initial M2, initial M1) vs = {(q2, q1)}; vs \\<in> L M2;\n   vs \\<in> L M1; observable M2; observable M1; well_formed M2;\n   well_formed M1; initial M2 \\<in> nodes M2;\n   initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> q1 \\<in> io_targets M1 (initial M1) vs\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) vs = {q1} &&&\n    io_targets M2 (initial M2) vs = {q2}", "by (metis FSM.nodes.initial assms(2) assms(3) assms(4) assms(5) assms(9) assms(10)\n        io_targets_observable_singleton_ex singletonD)+\n\n  \\<comment> \\<open>paths for ?xs1\\<close>"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) vs = {q1}\n  io_targets M2 (initial M2) vs = {q2}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"(states (xs || tr) (q2, q1)) ! i1 \\<in> io_targets PM (q2, q1) ?xs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (xs || tr) (q2, q1) ! i1\n    \\<in> io_targets PM (q2, q1) (take (Suc i1) xs)", "by (metis \\<open>0 < length xs\\<close> assms(6) assms(7) index_def map_snd_zip states_alt_def\n        states_index_io_target)"], ["proof (state)\nthis:\n  states (xs || tr) (q2, q1) ! i1\n  \\<in> io_targets PM (q2, q1) (take (Suc i1) xs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  states (xs || tr) (q2, q1) ! i1\n  \\<in> io_targets PM (q2, q1) (take (Suc i1) xs)", "have \"io_targets PM (q2, q1) ?xs1 = {?st}\""], ["proof (prove)\nusing this:\n  states (xs || tr) (q2, q1) ! i1\n  \\<in> io_targets PM (q2, q1) (take (Suc i1) xs)\n\ngoal (1 subgoal):\n 1. io_targets PM (q2, q1) (take (Suc i1) xs) =\n    {states (xs || tr) (q2, q1) ! i1}", "using obs_PM"], ["proof (prove)\nusing this:\n  states (xs || tr) (q2, q1) ! i1\n  \\<in> io_targets PM (q2, q1) (take (Suc i1) xs)\n  observable PM\n\ngoal (1 subgoal):\n 1. io_targets PM (q2, q1) (take (Suc i1) xs) =\n    {states (xs || tr) (q2, q1) ! i1}", "by (meson observable_io_target_is_singleton)"], ["proof (state)\nthis:\n  io_targets PM (q2, q1) (take (Suc i1) xs) =\n  {states (xs || tr) (q2, q1) ! i1}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"path PM (?xs1 || ?tr1) (q2,q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (take (Suc i1) xs || take (Suc i1) tr) (q2, q1)", "by (metis FSM.path_append_elim append_take_drop_id assms(6) assms(7) length_take zip_append)"], ["proof (state)\nthis:\n  path PM (take (Suc i1) xs || take (Suc i1) tr) (q2, q1)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path PM (take (Suc i1) xs || take (Suc i1) tr) (q2, q1)", "have \"path PM (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1)\""], ["proof (prove)\nusing this:\n  path PM (take (Suc i1) xs || take (Suc i1) tr) (q2, q1)\n\ngoal (1 subgoal):\n 1. path PM\n     (take (Suc i1) xs ||\n      map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n     (q2, q1)", "by auto"], ["proof (state)\nthis:\n  path PM\n   (take (Suc i1) xs ||\n    map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n   (q2, q1)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"vs @ ?xs1 \\<in> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ take (Suc i1) xs \\<in> L M2", "by (metis (no_types) IntD2 append_assoc append_take_drop_id assms(8) language_state_prefix)"], ["proof (state)\nthis:\n  vs @ take (Suc i1) xs \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  vs @ take (Suc i1) xs \\<in> L M2", "obtain q2' where \"io_targets M2 (initial M2) (vs@?xs1) = {q2'}\""], ["proof (prove)\nusing this:\n  vs @ take (Suc i1) xs \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>q2'.\n        io_targets M2 (initial M2) (vs @ take (Suc i1) xs) =\n        {q2'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using io_targets_observable_singleton_ob[of M2 \"vs@?xs1\" \"initial M2\"] assms(4)"], ["proof (prove)\nusing this:\n  vs @ take (Suc i1) xs \\<in> L M2\n  \\<lbrakk>observable M2; vs @ take (Suc i1) xs \\<in> L M2;\n   \\<And>q2.\n      io_targets M2 (initial M2) (vs @ take (Suc i1) xs) =\n      {q2} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  observable M2\n\ngoal (1 subgoal):\n 1. (\\<And>q2'.\n        io_targets M2 (initial M2) (vs @ take (Suc i1) xs) =\n        {q2'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (vs @ take (Suc i1) xs) = {q2'}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) (vs @ take (Suc i1) xs) = {q2'}", "have \"q2' \\<in> io_targets M2 q2 ?xs1\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (vs @ take (Suc i1) xs) = {q2'}\n\ngoal (1 subgoal):\n 1. q2' \\<in> io_targets M2 q2 (take (Suc i1) xs)", "using assms(4) \\<open>io_targets M2 (initial M2) vs = {q2}\\<close>\n          observable_io_targets_split[of M2 \"initial M2\" vs ?xs1 q2' q2]"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (vs @ take (Suc i1) xs) = {q2'}\n  observable M2\n  io_targets M2 (initial M2) vs = {q2}\n  \\<lbrakk>observable M2;\n   io_targets M2 (initial M2) (vs @ take (Suc i1) xs) = {q2'};\n   io_targets M2 (initial M2) vs = {q2}\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 q2 (take (Suc i1) xs) = {q2'}\n\ngoal (1 subgoal):\n 1. q2' \\<in> io_targets M2 q2 (take (Suc i1) xs)", "by simp"], ["proof (state)\nthis:\n  q2' \\<in> io_targets M2 q2 (take (Suc i1) xs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  q2' \\<in> io_targets M2 q2 (take (Suc i1) xs)", "have \"?xs1 \\<in> language_state M2 q2\""], ["proof (prove)\nusing this:\n  q2' \\<in> io_targets M2 q2 (take (Suc i1) xs)\n\ngoal (1 subgoal):\n 1. take (Suc i1) xs \\<in> LS M2 q2", "by auto"], ["proof (state)\nthis:\n  take (Suc i1) xs \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  take (Suc i1) xs \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"length ?xs1 = length (map snd ?tr1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc i1) xs) = length (map snd (take (Suc i1) tr))", "using assms(7)"], ["proof (prove)\nusing this:\n  length xs = length tr\n\ngoal (1 subgoal):\n 1. length (take (Suc i1) xs) = length (map snd (take (Suc i1) tr))", "by auto"], ["proof (state)\nthis:\n  length (take (Suc i1) xs) = length (map snd (take (Suc i1) tr))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  length (take (Suc i1) xs) = length (map snd (take (Suc i1) tr))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"length (map fst ?tr1) = length (map snd ?tr1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst (take (Suc i1) tr)) =\n    length (map snd (take (Suc i1) tr))", "by auto"], ["proof (state)\nthis:\n  length (map fst (take (Suc i1) tr)) = length (map snd (take (Suc i1) tr))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  length (map fst (take (Suc i1) tr)) = length (map snd (take (Suc i1) tr))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"q2 \\<in> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M2", "using \\<open>io_targets M2 (initial M2) vs = {q2}\\<close> io_targets_nodes"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) vs = {q2}\n  \\<lbrakk>?q2.0 \\<in> io_targets ?M ?q1.0 ?io;\n   ?q1.0 \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> ?q2.0 \\<in> nodes ?M\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M2", "by (metis FSM.nodes.initial insertI1)"], ["proof (state)\nthis:\n  q2 \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  q2 \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"q1 \\<in> nodes M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<in> nodes M1", "using \\<open>io_targets M1 (initial M1) vs = {q1}\\<close> io_targets_nodes"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) vs = {q1}\n  \\<lbrakk>?q2.0 \\<in> io_targets ?M ?q1.0 ?io;\n   ?q1.0 \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> ?q2.0 \\<in> nodes ?M\n\ngoal (1 subgoal):\n 1. q1 \\<in> nodes M1", "by (metis FSM.nodes.initial insertI1)"], ["proof (state)\nthis:\n  q1 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  take (Suc i1) xs \\<in> LS M2 q2\n  length (take (Suc i1) xs) = length (map snd (take (Suc i1) tr))\n  length (map fst (take (Suc i1) tr)) = length (map snd (take (Suc i1) tr))\n  q2 \\<in> nodes M2\n  q1 \\<in> nodes M1", "have\n     \"path M1 (?xs1 || map snd ?tr1) q1\"\n     \"path M2 (?xs1 || map fst ?tr1) q2\"\n     \"target (?xs1 || map snd ?tr1) q1 = snd (target (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1))\"\n     \"target (?xs1 || map fst ?tr1) q2 = fst (target (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1))\""], ["proof (prove)\nusing this:\n  take (Suc i1) xs \\<in> LS M2 q2\n  length (take (Suc i1) xs) = length (map snd (take (Suc i1) tr))\n  length (map fst (take (Suc i1) tr)) = length (map snd (take (Suc i1) tr))\n  q2 \\<in> nodes M2\n  q1 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. (path M1 (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 &&&\n     path M2 (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2) &&&\n    target (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 =\n    snd (target\n          (take (Suc i1) xs ||\n           map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n          (q2, q1)) &&&\n    target (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2 =\n    fst (target\n          (take (Suc i1) xs ||\n           map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n          (q2, q1))", "using assms(2) assms(9) assms(10) \\<open>path PM (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1)\\<close>\n          assms(4)\n          productF_path_reverse_ob_2[of ?xs1 \"map fst ?tr1\" \"map snd ?tr1\" M2 M1 FAIL PM q2 q1]"], ["proof (prove)\nusing this:\n  take (Suc i1) xs \\<in> LS M2 q2\n  length (take (Suc i1) xs) = length (map snd (take (Suc i1) tr))\n  length (map fst (take (Suc i1) tr)) = length (map snd (take (Suc i1) tr))\n  q2 \\<in> nodes M2\n  q1 \\<in> nodes M1\n  productF M2 M1 FAIL PM\n  well_formed M1\n  well_formed M2\n  path PM\n   (take (Suc i1) xs ||\n    map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n   (q2, q1)\n  observable M2\n  \\<lbrakk>length (take (Suc i1) xs) = length (map fst (take (Suc i1) tr));\n   length (map fst (take (Suc i1) tr)) =\n   length (map snd (take (Suc i1) tr));\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path PM\n    (take (Suc i1) xs ||\n     map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n    (q2, q1);\n   q2 \\<in> nodes M2; q1 \\<in> nodes M1; take (Suc i1) xs \\<in> LS M2 q2;\n   observable M2\\<rbrakk>\n  \\<Longrightarrow> path M2 (take (Suc i1) xs || map fst (take (Suc i1) tr))\n                     q2 \\<and>\n                    length (take (Suc i1) xs) =\n                    length (map fst (take (Suc i1) tr))\n  \\<lbrakk>length (take (Suc i1) xs) = length (map fst (take (Suc i1) tr));\n   length (map fst (take (Suc i1) tr)) =\n   length (map snd (take (Suc i1) tr));\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path PM\n    (take (Suc i1) xs ||\n     map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n    (q2, q1);\n   q2 \\<in> nodes M2; q1 \\<in> nodes M1; take (Suc i1) xs \\<in> LS M2 q2;\n   observable M2\\<rbrakk>\n  \\<Longrightarrow> path M1 (take (Suc i1) xs || map snd (take (Suc i1) tr))\n                     q1 \\<and>\n                    length (take (Suc i1) xs) =\n                    length (map snd (take (Suc i1) tr))\n  \\<lbrakk>length (take (Suc i1) xs) = length (map fst (take (Suc i1) tr));\n   length (map fst (take (Suc i1) tr)) =\n   length (map snd (take (Suc i1) tr));\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path PM\n    (take (Suc i1) xs ||\n     map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n    (q2, q1);\n   q2 \\<in> nodes M2; q1 \\<in> nodes M1; take (Suc i1) xs \\<in> LS M2 q2;\n   observable M2\\<rbrakk>\n  \\<Longrightarrow> target (take (Suc i1) xs || map fst (take (Suc i1) tr))\n                     q2 =\n                    fst (target\n                          (take (Suc i1) xs ||\n                           map fst (take (Suc i1) tr) ||\n                           map snd (take (Suc i1) tr))\n                          (q2, q1))\n  \\<lbrakk>length (take (Suc i1) xs) = length (map fst (take (Suc i1) tr));\n   length (map fst (take (Suc i1) tr)) =\n   length (map snd (take (Suc i1) tr));\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path PM\n    (take (Suc i1) xs ||\n     map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n    (q2, q1);\n   q2 \\<in> nodes M2; q1 \\<in> nodes M1; take (Suc i1) xs \\<in> LS M2 q2;\n   observable M2\\<rbrakk>\n  \\<Longrightarrow> target (take (Suc i1) xs || map snd (take (Suc i1) tr))\n                     q1 =\n                    snd (target\n                          (take (Suc i1) xs ||\n                           map fst (take (Suc i1) tr) ||\n                           map snd (take (Suc i1) tr))\n                          (q2, q1))\n\ngoal (1 subgoal):\n 1. (path M1 (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 &&&\n     path M2 (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2) &&&\n    target (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 =\n    snd (target\n          (take (Suc i1) xs ||\n           map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n          (q2, q1)) &&&\n    target (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2 =\n    fst (target\n          (take (Suc i1) xs ||\n           map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n          (q2, q1))", "by simp+"], ["proof (state)\nthis:\n  path M1 (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1\n  path M2 (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2\n  target (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 =\n  snd (target\n        (take (Suc i1) xs ||\n         map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n        (q2, q1))\n  target (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2 =\n  fst (target\n        (take (Suc i1) xs ||\n         map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n        (q2, q1))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  path M1 (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1\n  path M2 (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2\n  target (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 =\n  snd (target\n        (take (Suc i1) xs ||\n         map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n        (q2, q1))\n  target (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2 =\n  fst (target\n        (take (Suc i1) xs ||\n         map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n        (q2, q1))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"target (?xs1 || map fst ?tr1 || map snd ?tr1) (q2,q1) = ?st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target\n     (take (Suc i1) xs ||\n      map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n     (q2, q1) =\n    states (xs || tr) (q2, q1) ! i1", "by (metis (no_types) index_def scan_nth take_zip zip_map_fst_snd)"], ["proof (state)\nthis:\n  target\n   (take (Suc i1) xs ||\n    map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n   (q2, q1) =\n  states (xs || tr) (q2, q1) ! i1\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  path M1 (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1\n  path M2 (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2\n  target (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 =\n  snd (target\n        (take (Suc i1) xs ||\n         map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n        (q2, q1))\n  target (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2 =\n  fst (target\n        (take (Suc i1) xs ||\n         map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n        (q2, q1))\n  target\n   (take (Suc i1) xs ||\n    map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n   (q2, q1) =\n  states (xs || tr) (q2, q1) ! i1", "have\n     \"target (?xs1 || map snd ?tr1) q1 = snd ?st\"\n     \"target (?xs1 || map fst ?tr1) q2 = fst ?st\""], ["proof (prove)\nusing this:\n  path M1 (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1\n  path M2 (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2\n  target (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 =\n  snd (target\n        (take (Suc i1) xs ||\n         map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n        (q2, q1))\n  target (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2 =\n  fst (target\n        (take (Suc i1) xs ||\n         map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n        (q2, q1))\n  target\n   (take (Suc i1) xs ||\n    map fst (take (Suc i1) tr) || map snd (take (Suc i1) tr))\n   (q2, q1) =\n  states (xs || tr) (q2, q1) ! i1\n\ngoal (1 subgoal):\n 1. target (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 =\n    snd (states (xs || tr) (q2, q1) ! i1) &&&\n    target (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2 =\n    fst (states (xs || tr) (q2, q1) ! i1)", "by simp+\n\n  \\<comment> \\<open>paths for ?xs2\\<close>"], ["proof (state)\nthis:\n  target (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 =\n  snd (states (xs || tr) (q2, q1) ! i1)\n  target (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2 =\n  fst (states (xs || tr) (q2, q1) ! i1)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"(states (xs || tr) (q2, q1)) ! i2 \\<in> io_targets PM (q2, q1) ?xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (xs || tr) (q2, q1) ! i2\n    \\<in> io_targets PM (q2, q1) (take (Suc i2) xs)", "by (metis \\<open>0 < length xs\\<close> assms(6) assms(7) index_def map_snd_zip states_alt_def states_index_io_target)"], ["proof (state)\nthis:\n  states (xs || tr) (q2, q1) ! i2\n  \\<in> io_targets PM (q2, q1) (take (Suc i2) xs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  states (xs || tr) (q2, q1) ! i2\n  \\<in> io_targets PM (q2, q1) (take (Suc i2) xs)", "have \"io_targets PM (q2, q1) ?xs2 = {?st}\""], ["proof (prove)\nusing this:\n  states (xs || tr) (q2, q1) ! i2\n  \\<in> io_targets PM (q2, q1) (take (Suc i2) xs)\n\ngoal (1 subgoal):\n 1. io_targets PM (q2, q1) (take (Suc i2) xs) =\n    {states (xs || tr) (q2, q1) ! i1}", "using obs_PM"], ["proof (prove)\nusing this:\n  states (xs || tr) (q2, q1) ! i2\n  \\<in> io_targets PM (q2, q1) (take (Suc i2) xs)\n  observable PM\n\ngoal (1 subgoal):\n 1. io_targets PM (q2, q1) (take (Suc i2) xs) =\n    {states (xs || tr) (q2, q1) ! i1}", "by (metis index_def observable_io_target_is_singleton)"], ["proof (state)\nthis:\n  io_targets PM (q2, q1) (take (Suc i2) xs) =\n  {states (xs || tr) (q2, q1) ! i1}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"path PM (?xs2 || ?tr2) (q2,q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (take (Suc i2) xs || take (Suc i2) tr) (q2, q1)", "by (metis FSM.path_append_elim append_take_drop_id assms(6) assms(7) length_take zip_append)"], ["proof (state)\nthis:\n  path PM (take (Suc i2) xs || take (Suc i2) tr) (q2, q1)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path PM (take (Suc i2) xs || take (Suc i2) tr) (q2, q1)", "have \"path PM (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1)\""], ["proof (prove)\nusing this:\n  path PM (take (Suc i2) xs || take (Suc i2) tr) (q2, q1)\n\ngoal (1 subgoal):\n 1. path PM\n     (take (Suc i2) xs ||\n      map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n     (q2, q1)", "by auto"], ["proof (state)\nthis:\n  path PM\n   (take (Suc i2) xs ||\n    map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n   (q2, q1)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"vs @ ?xs2 \\<in> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ take (Suc i2) xs \\<in> L M2", "by (metis (no_types) IntD2 append_assoc append_take_drop_id assms(8) language_state_prefix)"], ["proof (state)\nthis:\n  vs @ take (Suc i2) xs \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  vs @ take (Suc i2) xs \\<in> L M2", "obtain q2'' where \"io_targets M2 (initial M2) (vs@?xs2) = {q2''}\""], ["proof (prove)\nusing this:\n  vs @ take (Suc i2) xs \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>q2''.\n        io_targets M2 (initial M2) (vs @ take (Suc i2) xs) =\n        {q2''} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using io_targets_observable_singleton_ob[of M2 \"vs@?xs2\" \"initial M2\"] assms(4)"], ["proof (prove)\nusing this:\n  vs @ take (Suc i2) xs \\<in> L M2\n  \\<lbrakk>observable M2; vs @ take (Suc i2) xs \\<in> L M2;\n   \\<And>q2.\n      io_targets M2 (initial M2) (vs @ take (Suc i2) xs) =\n      {q2} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  observable M2\n\ngoal (1 subgoal):\n 1. (\\<And>q2''.\n        io_targets M2 (initial M2) (vs @ take (Suc i2) xs) =\n        {q2''} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (vs @ take (Suc i2) xs) = {q2''}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) (vs @ take (Suc i2) xs) = {q2''}", "have \"q2'' \\<in> io_targets M2 q2 ?xs2\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (vs @ take (Suc i2) xs) = {q2''}\n\ngoal (1 subgoal):\n 1. q2'' \\<in> io_targets M2 q2 (take (Suc i2) xs)", "using assms(4) \\<open>io_targets M2 (initial M2) vs = {q2}\\<close>\n          observable_io_targets_split[of M2 \"initial M2\" vs ?xs2 q2'' q2]"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (vs @ take (Suc i2) xs) = {q2''}\n  observable M2\n  io_targets M2 (initial M2) vs = {q2}\n  \\<lbrakk>observable M2;\n   io_targets M2 (initial M2) (vs @ take (Suc i2) xs) = {q2''};\n   io_targets M2 (initial M2) vs = {q2}\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 q2 (take (Suc i2) xs) = {q2''}\n\ngoal (1 subgoal):\n 1. q2'' \\<in> io_targets M2 q2 (take (Suc i2) xs)", "by simp"], ["proof (state)\nthis:\n  q2'' \\<in> io_targets M2 q2 (take (Suc i2) xs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  q2'' \\<in> io_targets M2 q2 (take (Suc i2) xs)", "have \"?xs2 \\<in> language_state M2 q2\""], ["proof (prove)\nusing this:\n  q2'' \\<in> io_targets M2 q2 (take (Suc i2) xs)\n\ngoal (1 subgoal):\n 1. take (Suc i2) xs \\<in> LS M2 q2", "by auto"], ["proof (state)\nthis:\n  take (Suc i2) xs \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  take (Suc i2) xs \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"length ?xs2 = length (map snd ?tr2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc i2) xs) = length (map snd (take (Suc i2) tr))", "using assms(7)"], ["proof (prove)\nusing this:\n  length xs = length tr\n\ngoal (1 subgoal):\n 1. length (take (Suc i2) xs) = length (map snd (take (Suc i2) tr))", "by auto"], ["proof (state)\nthis:\n  length (take (Suc i2) xs) = length (map snd (take (Suc i2) tr))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  length (take (Suc i2) xs) = length (map snd (take (Suc i2) tr))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"length (map fst ?tr2) = length (map snd ?tr2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst (take (Suc i2) tr)) =\n    length (map snd (take (Suc i2) tr))", "by auto"], ["proof (state)\nthis:\n  length (map fst (take (Suc i2) tr)) = length (map snd (take (Suc i2) tr))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  length (map fst (take (Suc i2) tr)) = length (map snd (take (Suc i2) tr))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"q2 \\<in> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M2", "using \\<open>io_targets M2 (initial M2) vs = {q2}\\<close> io_targets_nodes"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) vs = {q2}\n  \\<lbrakk>?q2.0 \\<in> io_targets ?M ?q1.0 ?io;\n   ?q1.0 \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> ?q2.0 \\<in> nodes ?M\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M2", "by (metis FSM.nodes.initial insertI1)"], ["proof (state)\nthis:\n  q2 \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  q2 \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"q1 \\<in> nodes M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<in> nodes M1", "using \\<open>io_targets M1 (initial M1) vs = {q1}\\<close> io_targets_nodes"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) vs = {q1}\n  \\<lbrakk>?q2.0 \\<in> io_targets ?M ?q1.0 ?io;\n   ?q1.0 \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> ?q2.0 \\<in> nodes ?M\n\ngoal (1 subgoal):\n 1. q1 \\<in> nodes M1", "by (metis FSM.nodes.initial insertI1)"], ["proof (state)\nthis:\n  q1 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  take (Suc i2) xs \\<in> LS M2 q2\n  length (take (Suc i2) xs) = length (map snd (take (Suc i2) tr))\n  length (map fst (take (Suc i2) tr)) = length (map snd (take (Suc i2) tr))\n  q2 \\<in> nodes M2\n  q1 \\<in> nodes M1", "have\n     \"path M1 (?xs2 || map snd ?tr2) q1\"\n     \"path M2 (?xs2 || map fst ?tr2) q2\"\n     \"target (?xs2 || map snd ?tr2) q1 = snd(target (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1))\"\n     \"target (?xs2 || map fst ?tr2) q2 = fst(target (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1))\""], ["proof (prove)\nusing this:\n  take (Suc i2) xs \\<in> LS M2 q2\n  length (take (Suc i2) xs) = length (map snd (take (Suc i2) tr))\n  length (map fst (take (Suc i2) tr)) = length (map snd (take (Suc i2) tr))\n  q2 \\<in> nodes M2\n  q1 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. (path M1 (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 &&&\n     path M2 (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2) &&&\n    target (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 =\n    snd (target\n          (take (Suc i2) xs ||\n           map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n          (q2, q1)) &&&\n    target (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2 =\n    fst (target\n          (take (Suc i2) xs ||\n           map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n          (q2, q1))", "using assms(2) assms(9) assms(10) \\<open>path PM (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1)\\<close>\n          assms(4)\n          productF_path_reverse_ob_2[of ?xs2 \"map fst ?tr2\" \"map snd ?tr2\" M2 M1 FAIL PM q2 q1]"], ["proof (prove)\nusing this:\n  take (Suc i2) xs \\<in> LS M2 q2\n  length (take (Suc i2) xs) = length (map snd (take (Suc i2) tr))\n  length (map fst (take (Suc i2) tr)) = length (map snd (take (Suc i2) tr))\n  q2 \\<in> nodes M2\n  q1 \\<in> nodes M1\n  productF M2 M1 FAIL PM\n  well_formed M1\n  well_formed M2\n  path PM\n   (take (Suc i2) xs ||\n    map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n   (q2, q1)\n  observable M2\n  \\<lbrakk>length (take (Suc i2) xs) = length (map fst (take (Suc i2) tr));\n   length (map fst (take (Suc i2) tr)) =\n   length (map snd (take (Suc i2) tr));\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path PM\n    (take (Suc i2) xs ||\n     map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n    (q2, q1);\n   q2 \\<in> nodes M2; q1 \\<in> nodes M1; take (Suc i2) xs \\<in> LS M2 q2;\n   observable M2\\<rbrakk>\n  \\<Longrightarrow> path M2 (take (Suc i2) xs || map fst (take (Suc i2) tr))\n                     q2 \\<and>\n                    length (take (Suc i2) xs) =\n                    length (map fst (take (Suc i2) tr))\n  \\<lbrakk>length (take (Suc i2) xs) = length (map fst (take (Suc i2) tr));\n   length (map fst (take (Suc i2) tr)) =\n   length (map snd (take (Suc i2) tr));\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path PM\n    (take (Suc i2) xs ||\n     map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n    (q2, q1);\n   q2 \\<in> nodes M2; q1 \\<in> nodes M1; take (Suc i2) xs \\<in> LS M2 q2;\n   observable M2\\<rbrakk>\n  \\<Longrightarrow> path M1 (take (Suc i2) xs || map snd (take (Suc i2) tr))\n                     q1 \\<and>\n                    length (take (Suc i2) xs) =\n                    length (map snd (take (Suc i2) tr))\n  \\<lbrakk>length (take (Suc i2) xs) = length (map fst (take (Suc i2) tr));\n   length (map fst (take (Suc i2) tr)) =\n   length (map snd (take (Suc i2) tr));\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path PM\n    (take (Suc i2) xs ||\n     map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n    (q2, q1);\n   q2 \\<in> nodes M2; q1 \\<in> nodes M1; take (Suc i2) xs \\<in> LS M2 q2;\n   observable M2\\<rbrakk>\n  \\<Longrightarrow> target (take (Suc i2) xs || map fst (take (Suc i2) tr))\n                     q2 =\n                    fst (target\n                          (take (Suc i2) xs ||\n                           map fst (take (Suc i2) tr) ||\n                           map snd (take (Suc i2) tr))\n                          (q2, q1))\n  \\<lbrakk>length (take (Suc i2) xs) = length (map fst (take (Suc i2) tr));\n   length (map fst (take (Suc i2) tr)) =\n   length (map snd (take (Suc i2) tr));\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path PM\n    (take (Suc i2) xs ||\n     map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n    (q2, q1);\n   q2 \\<in> nodes M2; q1 \\<in> nodes M1; take (Suc i2) xs \\<in> LS M2 q2;\n   observable M2\\<rbrakk>\n  \\<Longrightarrow> target (take (Suc i2) xs || map snd (take (Suc i2) tr))\n                     q1 =\n                    snd (target\n                          (take (Suc i2) xs ||\n                           map fst (take (Suc i2) tr) ||\n                           map snd (take (Suc i2) tr))\n                          (q2, q1))\n\ngoal (1 subgoal):\n 1. (path M1 (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 &&&\n     path M2 (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2) &&&\n    target (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 =\n    snd (target\n          (take (Suc i2) xs ||\n           map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n          (q2, q1)) &&&\n    target (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2 =\n    fst (target\n          (take (Suc i2) xs ||\n           map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n          (q2, q1))", "by simp+"], ["proof (state)\nthis:\n  path M1 (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1\n  path M2 (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2\n  target (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 =\n  snd (target\n        (take (Suc i2) xs ||\n         map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n        (q2, q1))\n  target (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2 =\n  fst (target\n        (take (Suc i2) xs ||\n         map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n        (q2, q1))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  path M1 (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1\n  path M2 (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2\n  target (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 =\n  snd (target\n        (take (Suc i2) xs ||\n         map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n        (q2, q1))\n  target (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2 =\n  fst (target\n        (take (Suc i2) xs ||\n         map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n        (q2, q1))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"target (?xs2 || map fst ?tr2 || map snd ?tr2) (q2,q1) = ?st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target\n     (take (Suc i2) xs ||\n      map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n     (q2, q1) =\n    states (xs || tr) (q2, q1) ! i1", "by (metis (no_types) index_def scan_nth take_zip zip_map_fst_snd)"], ["proof (state)\nthis:\n  target\n   (take (Suc i2) xs ||\n    map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n   (q2, q1) =\n  states (xs || tr) (q2, q1) ! i1\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  path M1 (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1\n  path M2 (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2\n  target (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 =\n  snd (target\n        (take (Suc i2) xs ||\n         map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n        (q2, q1))\n  target (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2 =\n  fst (target\n        (take (Suc i2) xs ||\n         map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n        (q2, q1))\n  target\n   (take (Suc i2) xs ||\n    map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n   (q2, q1) =\n  states (xs || tr) (q2, q1) ! i1", "have\n     \"target (?xs2 || map snd ?tr2) q1 = snd ?st\"\n     \"target (?xs2 || map fst ?tr2) q2 = fst ?st\""], ["proof (prove)\nusing this:\n  path M1 (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1\n  path M2 (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2\n  target (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 =\n  snd (target\n        (take (Suc i2) xs ||\n         map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n        (q2, q1))\n  target (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2 =\n  fst (target\n        (take (Suc i2) xs ||\n         map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n        (q2, q1))\n  target\n   (take (Suc i2) xs ||\n    map fst (take (Suc i2) tr) || map snd (take (Suc i2) tr))\n   (q2, q1) =\n  states (xs || tr) (q2, q1) ! i1\n\ngoal (1 subgoal):\n 1. target (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 =\n    snd (states (xs || tr) (q2, q1) ! i1) &&&\n    target (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2 =\n    fst (states (xs || tr) (q2, q1) ! i1)", "by simp+"], ["proof (state)\nthis:\n  target (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 =\n  snd (states (xs || tr) (q2, q1) ! i1)\n  target (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2 =\n  fst (states (xs || tr) (q2, q1) ! i1)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"io_targets M1 q1 ?xs1 = {snd ?st}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M1 q1 (take (Suc i1) xs) =\n    {snd (states (xs || tr) (q2, q1) ! i1)}", "using \\<open>path M1 (?xs1 || map snd ?tr1) q1\\<close> \\<open>target (?xs1 || map snd ?tr1) q1 = snd ?st\\<close>\n          \\<open>length ?xs1 = length (map snd ?tr1)\\<close> assms(3) obs_target_is_io_targets[of M1 ?xs1\n          \"map snd ?tr1\" q1]"], ["proof (prove)\nusing this:\n  path M1 (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1\n  target (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1 =\n  snd (states (xs || tr) (q2, q1) ! i1)\n  length (take (Suc i1) xs) = length (map snd (take (Suc i1) tr))\n  observable M1\n  \\<lbrakk>observable M1;\n   path M1 (take (Suc i1) xs || map snd (take (Suc i1) tr)) q1;\n   length (take (Suc i1) xs) = length (map snd (take (Suc i1) tr))\\<rbrakk>\n  \\<Longrightarrow> io_targets M1 q1 (take (Suc i1) xs) =\n                    {target (take (Suc i1) xs || map snd (take (Suc i1) tr))\n                      q1}\n\ngoal (1 subgoal):\n 1. io_targets M1 q1 (take (Suc i1) xs) =\n    {snd (states (xs || tr) (q2, q1) ! i1)}", "by simp"], ["proof (state)\nthis:\n  io_targets M1 q1 (take (Suc i1) xs) =\n  {snd (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io_targets M1 q1 (take (Suc i1) xs) =\n  {snd (states (xs || tr) (q2, q1) ! i1)}", "have tgt_1_1 : \"io_targets M1 (initial M1) (vs @ ?xs1) = {snd ?st}\""], ["proof (prove)\nusing this:\n  io_targets M1 q1 (take (Suc i1) xs) =\n  {snd (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) (vs @ take (Suc i1) xs) =\n    {snd (states (xs || tr) (q2, q1) ! i1)}", "by (meson \\<open>io_targets M1 (initial M1) vs = {q1}\\<close> assms(3) observable_io_targets_append)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) (vs @ take (Suc i1) xs) =\n  {snd (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"io_targets M2 q2 ?xs1 = {fst ?st}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 q2 (take (Suc i1) xs) =\n    {fst (states (xs || tr) (q2, q1) ! i1)}", "using \\<open>path M2 (?xs1 || map fst ?tr1) q2\\<close> \\<open>target (?xs1 || map fst ?tr1) q2 = fst ?st\\<close>\n          \\<open>length ?xs1 = length (map snd ?tr1)\\<close> assms(4)\n          obs_target_is_io_targets[of M2 ?xs1 \"map fst ?tr1\" q2]"], ["proof (prove)\nusing this:\n  path M2 (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2\n  target (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2 =\n  fst (states (xs || tr) (q2, q1) ! i1)\n  length (take (Suc i1) xs) = length (map snd (take (Suc i1) tr))\n  observable M2\n  \\<lbrakk>observable M2;\n   path M2 (take (Suc i1) xs || map fst (take (Suc i1) tr)) q2;\n   length (take (Suc i1) xs) = length (map fst (take (Suc i1) tr))\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 q2 (take (Suc i1) xs) =\n                    {target (take (Suc i1) xs || map fst (take (Suc i1) tr))\n                      q2}\n\ngoal (1 subgoal):\n 1. io_targets M2 q2 (take (Suc i1) xs) =\n    {fst (states (xs || tr) (q2, q1) ! i1)}", "by simp"], ["proof (state)\nthis:\n  io_targets M2 q2 (take (Suc i1) xs) =\n  {fst (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io_targets M2 q2 (take (Suc i1) xs) =\n  {fst (states (xs || tr) (q2, q1) ! i1)}", "have tgt_1_2 : \"io_targets M2 (initial M2) (vs @ ?xs1) = {fst ?st}\""], ["proof (prove)\nusing this:\n  io_targets M2 q2 (take (Suc i1) xs) =\n  {fst (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) (vs @ take (Suc i1) xs) =\n    {fst (states (xs || tr) (q2, q1) ! i1)}", "by (meson \\<open>io_targets M2 (initial M2) vs = {q2}\\<close> assms(4) observable_io_targets_append)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (vs @ take (Suc i1) xs) =\n  {fst (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"io_targets M1 q1 ?xs2 = {snd ?st}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M1 q1 (take (Suc i2) xs) =\n    {snd (states (xs || tr) (q2, q1) ! i1)}", "using \\<open>path M1 (?xs2 || map snd ?tr2) q1\\<close> \\<open>target (?xs2 || map snd ?tr2) q1 = snd ?st\\<close>\n          \\<open>length ?xs2 = length (map snd ?tr2)\\<close> assms(3)\n          obs_target_is_io_targets[of M1 ?xs2 \"map snd ?tr2\" q1]"], ["proof (prove)\nusing this:\n  path M1 (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1\n  target (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1 =\n  snd (states (xs || tr) (q2, q1) ! i1)\n  length (take (Suc i2) xs) = length (map snd (take (Suc i2) tr))\n  observable M1\n  \\<lbrakk>observable M1;\n   path M1 (take (Suc i2) xs || map snd (take (Suc i2) tr)) q1;\n   length (take (Suc i2) xs) = length (map snd (take (Suc i2) tr))\\<rbrakk>\n  \\<Longrightarrow> io_targets M1 q1 (take (Suc i2) xs) =\n                    {target (take (Suc i2) xs || map snd (take (Suc i2) tr))\n                      q1}\n\ngoal (1 subgoal):\n 1. io_targets M1 q1 (take (Suc i2) xs) =\n    {snd (states (xs || tr) (q2, q1) ! i1)}", "by simp"], ["proof (state)\nthis:\n  io_targets M1 q1 (take (Suc i2) xs) =\n  {snd (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io_targets M1 q1 (take (Suc i2) xs) =\n  {snd (states (xs || tr) (q2, q1) ! i1)}", "have tgt_2_1 : \"io_targets M1 (initial M1) (vs @ ?xs2) = {snd ?st}\""], ["proof (prove)\nusing this:\n  io_targets M1 q1 (take (Suc i2) xs) =\n  {snd (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) (vs @ take (Suc i2) xs) =\n    {snd (states (xs || tr) (q2, q1) ! i1)}", "by (meson \\<open>io_targets M1 (initial M1) vs = {q1}\\<close> assms(3) observable_io_targets_append)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) (vs @ take (Suc i2) xs) =\n  {snd (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"io_targets M2 q2 ?xs2 = {fst ?st}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 q2 (take (Suc i2) xs) =\n    {fst (states (xs || tr) (q2, q1) ! i1)}", "using \\<open>path M2 (?xs2 || map fst ?tr2) q2\\<close> \\<open>target (?xs2 || map fst ?tr2) q2 = fst ?st\\<close>\n          \\<open>length ?xs2 = length (map snd ?tr2)\\<close> assms(4)\n          obs_target_is_io_targets[of M2 ?xs2 \"map fst ?tr2\" q2]"], ["proof (prove)\nusing this:\n  path M2 (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2\n  target (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2 =\n  fst (states (xs || tr) (q2, q1) ! i1)\n  length (take (Suc i2) xs) = length (map snd (take (Suc i2) tr))\n  observable M2\n  \\<lbrakk>observable M2;\n   path M2 (take (Suc i2) xs || map fst (take (Suc i2) tr)) q2;\n   length (take (Suc i2) xs) = length (map fst (take (Suc i2) tr))\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 q2 (take (Suc i2) xs) =\n                    {target (take (Suc i2) xs || map fst (take (Suc i2) tr))\n                      q2}\n\ngoal (1 subgoal):\n 1. io_targets M2 q2 (take (Suc i2) xs) =\n    {fst (states (xs || tr) (q2, q1) ! i1)}", "by simp"], ["proof (state)\nthis:\n  io_targets M2 q2 (take (Suc i2) xs) =\n  {fst (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io_targets M2 q2 (take (Suc i2) xs) =\n  {fst (states (xs || tr) (q2, q1) ! i1)}", "have tgt_2_2 : \"io_targets M2 (initial M2) (vs @ ?xs2) = {fst ?st}\""], ["proof (prove)\nusing this:\n  io_targets M2 q2 (take (Suc i2) xs) =\n  {fst (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) (vs @ take (Suc i2) xs) =\n    {fst (states (xs || tr) (q2, q1) ! i1)}", "by (meson \\<open>io_targets M2 (initial M2) vs = {q2}\\<close> assms(4) observable_io_targets_append)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (vs @ take (Suc i2) xs) =\n  {fst (states (xs || tr) (q2, q1) ! i1)}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"?xs1 \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc i1) xs \\<noteq> []", "using \\<open>0 < length xs\\<close>"], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. take (Suc i1) xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  take (Suc i1) xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"prefix ?xs1 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (take (Suc i1) xs) xs", "using take_is_prefix"], ["proof (prove)\nusing this:\n  prefix (take ?n ?xs) ?xs\n\ngoal (1 subgoal):\n 1. prefix (take (Suc i1) xs) xs", "by blast"], ["proof (state)\nthis:\n  prefix (take (Suc i1) xs) xs\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"prefix ?xs2 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (take (Suc i2) xs) xs", "using take_is_prefix"], ["proof (prove)\nusing this:\n  prefix (take ?n ?xs) ?xs\n\ngoal (1 subgoal):\n 1. prefix (take (Suc i2) xs) xs", "by blast"], ["proof (state)\nthis:\n  prefix (take (Suc i2) xs) xs\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"?xs1 \\<noteq> ?xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc i1) xs \\<noteq> take (Suc i2) xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take (Suc i1) xs \\<noteq> take (Suc i2) xs", "have f1: \"\\<forall>n na. \\<not> n < na \\<or> Suc n \\<le> na\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n na. \\<not> n < na \\<or> Suc n \\<le> na", "by presburger"], ["proof (state)\nthis:\n  \\<forall>n na. \\<not> n < na \\<or> Suc n \\<le> na\n\ngoal (1 subgoal):\n 1. take (Suc i1) xs \\<noteq> take (Suc i2) xs", "have f2: \"Suc i1 \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i1 \\<le> length xs", "using index_def"], ["proof (prove)\nusing this:\n  i1 \\<noteq> 0 \\<and>\n  i1 \\<noteq> i2 \\<and>\n  i1 < length (states (xs || tr) (q2, q1)) \\<and>\n  i2 < length (states (xs || tr) (q2, q1)) \\<and>\n  states (xs || tr) (q2, q1) ! i1 = states (xs || tr) (q2, q1) ! i2\n\ngoal (1 subgoal):\n 1. Suc i1 \\<le> length xs", "by force"], ["proof (state)\nthis:\n  Suc i1 \\<le> length xs\n\ngoal (1 subgoal):\n 1. take (Suc i1) xs \\<noteq> take (Suc i2) xs", "have \"Suc i2 \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i2 \\<le> length xs", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>n na. \\<not> n < na \\<or> Suc n \\<le> na\n\ngoal (1 subgoal):\n 1. Suc i2 \\<le> length xs", "by (metis index_def length_take map_snd_zip_take min_less_iff_conj states_alt_def)"], ["proof (state)\nthis:\n  Suc i2 \\<le> length xs\n\ngoal (1 subgoal):\n 1. take (Suc i1) xs \\<noteq> take (Suc i2) xs", "then"], ["proof (chain)\npicking this:\n  Suc i2 \\<le> length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc i2 \\<le> length xs\n\ngoal (1 subgoal):\n 1. take (Suc i1) xs \\<noteq> take (Suc i2) xs", "using f2"], ["proof (prove)\nusing this:\n  Suc i2 \\<le> length xs\n  Suc i1 \\<le> length xs\n\ngoal (1 subgoal):\n 1. take (Suc i1) xs \\<noteq> take (Suc i2) xs", "by (metis (no_types) index_def length_take min.absorb2 nat.simps(1))"], ["proof (state)\nthis:\n  take (Suc i1) xs \\<noteq> take (Suc i2) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take (Suc i1) xs \\<noteq> take (Suc i2) xs\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "have \"Rep_Pre M2 M1 vs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Pre M2 M1 vs xs", "proof (cases \"length ?xs1 < length ?xs2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length (take (Suc i1) xs) < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs\n 2. \\<not> length (take (Suc i1) xs)\n           < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs", "case True"], ["proof (state)\nthis:\n  length (take (Suc i1) xs) < length (take (Suc i2) xs)\n\ngoal (2 subgoals):\n 1. length (take (Suc i1) xs) < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs\n 2. \\<not> length (take (Suc i1) xs)\n           < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs", "then"], ["proof (chain)\npicking this:\n  length (take (Suc i1) xs) < length (take (Suc i2) xs)", "have \"prefix ?xs1 ?xs2\""], ["proof (prove)\nusing this:\n  length (take (Suc i1) xs) < length (take (Suc i2) xs)\n\ngoal (1 subgoal):\n 1. prefix (take (Suc i1) xs) (take (Suc i2) xs)", "by (meson \\<open>prefix (take (Suc i1) xs) xs\\<close> \\<open>prefix (take (Suc i2) xs) xs\\<close> leD prefix_length_le\n          prefix_same_cases)"], ["proof (state)\nthis:\n  prefix (take (Suc i1) xs) (take (Suc i2) xs)\n\ngoal (2 subgoals):\n 1. length (take (Suc i1) xs) < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs\n 2. \\<not> length (take (Suc i1) xs)\n           < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Pre M2 M1 vs xs", "by (meson Rep_Pre.elims(3) \\<open>prefix (take (Suc i1) xs) (take (Suc i2) xs)\\<close>\n          \\<open>prefix (take (Suc i2) xs) xs\\<close> \\<open>take (Suc i1) xs \\<noteq> take (Suc i2) xs\\<close>\n          tgt_1_1 tgt_1_2 tgt_2_1 tgt_2_2)"], ["proof (state)\nthis:\n  Rep_Pre M2 M1 vs xs\n\ngoal (1 subgoal):\n 1. \\<not> length (take (Suc i1) xs)\n           < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (take (Suc i1) xs)\n           < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs", "case False"], ["proof (state)\nthis:\n  \\<not> length (take (Suc i1) xs) < length (take (Suc i2) xs)\n\ngoal (1 subgoal):\n 1. \\<not> length (take (Suc i1) xs)\n           < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs", "moreover"], ["proof (state)\nthis:\n  \\<not> length (take (Suc i1) xs) < length (take (Suc i2) xs)\n\ngoal (1 subgoal):\n 1. \\<not> length (take (Suc i1) xs)\n           < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs", "have \"length ?xs1 \\<noteq> length ?xs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Suc i1) xs) \\<noteq> length (take (Suc i2) xs)", "by (metis (no_types) \\<open>take (Suc i1) xs \\<noteq> take (Suc i2) xs\\<close> append_eq_conv_conj\n          append_take_drop_id)"], ["proof (state)\nthis:\n  length (take (Suc i1) xs) \\<noteq> length (take (Suc i2) xs)\n\ngoal (1 subgoal):\n 1. \\<not> length (take (Suc i1) xs)\n           < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> length (take (Suc i1) xs) < length (take (Suc i2) xs)\n  length (take (Suc i1) xs) \\<noteq> length (take (Suc i2) xs)", "have \"length ?xs2 < length ?xs1\""], ["proof (prove)\nusing this:\n  \\<not> length (take (Suc i1) xs) < length (take (Suc i2) xs)\n  length (take (Suc i1) xs) \\<noteq> length (take (Suc i2) xs)\n\ngoal (1 subgoal):\n 1. length (take (Suc i2) xs) < length (take (Suc i1) xs)", "by auto"], ["proof (state)\nthis:\n  length (take (Suc i2) xs) < length (take (Suc i1) xs)\n\ngoal (1 subgoal):\n 1. \\<not> length (take (Suc i1) xs)\n           < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs", "then"], ["proof (chain)\npicking this:\n  length (take (Suc i2) xs) < length (take (Suc i1) xs)", "have \"prefix ?xs2 ?xs1\""], ["proof (prove)\nusing this:\n  length (take (Suc i2) xs) < length (take (Suc i1) xs)\n\ngoal (1 subgoal):\n 1. prefix (take (Suc i2) xs) (take (Suc i1) xs)", "using \\<open>prefix (take (Suc i1) xs) xs\\<close> \\<open>prefix (take (Suc i2) xs) xs\\<close> less_imp_le_nat\n            prefix_length_prefix"], ["proof (prove)\nusing this:\n  length (take (Suc i2) xs) < length (take (Suc i1) xs)\n  prefix (take (Suc i1) xs) xs\n  prefix (take (Suc i2) xs) xs\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n  \\<lbrakk>prefix ?ps ?xs; prefix ?qs ?xs;\n   length ?ps \\<le> length ?qs\\<rbrakk>\n  \\<Longrightarrow> prefix ?ps ?qs\n\ngoal (1 subgoal):\n 1. prefix (take (Suc i2) xs) (take (Suc i1) xs)", "by blast"], ["proof (state)\nthis:\n  prefix (take (Suc i2) xs) (take (Suc i1) xs)\n\ngoal (1 subgoal):\n 1. \\<not> length (take (Suc i1) xs)\n           < length (take (Suc i2) xs) \\<Longrightarrow>\n    Rep_Pre M2 M1 vs xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Pre M2 M1 vs xs", "by (metis Rep_Pre.elims(3) \\<open>prefix (take (Suc i1) xs) xs\\<close>\n          \\<open>prefix (take (Suc i2) xs) (take (Suc i1) xs)\\<close> \\<open>take (Suc i1) xs \\<noteq> take (Suc i2) xs\\<close>\n          tgt_1_1 tgt_1_2 tgt_2_1 tgt_2_2)"], ["proof (state)\nthis:\n  Rep_Pre M2 M1 vs xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Rep_Pre M2 M1 vs xs\n\ngoal (1 subgoal):\n 1. \\<not> distinct (states (xs || tr) (q2, q1)) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Rep_Pre M2 M1 vs xs", "show \"False\""], ["proof (prove)\nusing this:\n  Rep_Pre M2 M1 vs xs\n\ngoal (1 subgoal):\n 1. False", "using assms(1)"], ["proof (prove)\nusing this:\n  Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Pre M2 M1 vs xs\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma RP_count_via_Rep_Cov :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"s \\<in> nodes M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"distinct (states (xs || tr) (q2,q1))\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"card (\\<Union>(image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) = card (RP M2 s vs xs V'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have RP_cases : \"RP M2 s vs xs V'' = R M2 s vs xs\n                    \\<or> (\\<exists> vs' \\<in> V'' . vs' \\<notin> R M2 s vs xs\n                                      \\<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n    (\\<exists>vs'\\<in>V''.\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))", "using RP_from_R assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_det_state_cover ?M2.0 ?V; ?V'' \\<in> Perm ?V ?M1.0\\<rbrakk>\n  \\<Longrightarrow> RP ?M2.0 ?s ?vs ?xs ?V'' = R ?M2.0 ?s ?vs ?xs \\<or>\n                    (\\<exists>vs'\\<in>?V''.\n                        vs' \\<notin> R ?M2.0 ?s ?vs ?xs \\<and>\n                        RP ?M2.0 ?s ?vs ?xs ?V'' =\n                        insert vs' (R ?M2.0 ?s ?vs ?xs))\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n    (\\<exists>vs'\\<in>V''.\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))", "by metis"], ["proof (state)\nthis:\n  RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n  (\\<exists>vs'\\<in>V''.\n      vs' \\<notin> R M2 s vs xs \\<and>\n      RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "proof (cases \"RP M2 s vs xs V'' = R M2 s vs xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')\n 2. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "case True"], ["proof (state)\nthis:\n  RP M2 s vs xs V'' = R M2 s vs xs\n\ngoal (2 subgoals):\n 1. RP M2 s vs xs V'' = R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')\n 2. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "then"], ["proof (chain)\npicking this:\n  RP M2 s vs xs V'' = R M2 s vs xs", "show ?thesis"], ["proof (prove)\nusing this:\n  RP M2 s vs xs V'' = R M2 s vs xs\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "using R_count assms"], ["proof (prove)\nusing this:\n  RP M2 s vs xs V'' = R M2 s vs xs\n  \\<lbrakk>?vs @ ?xs \\<in> L ?M1.0 \\<inter> L ?M2.0; observable ?M1.0;\n   observable ?M2.0; well_formed ?M1.0; well_formed ?M2.0;\n   ?s \\<in> nodes ?M2.0; productF ?M2.0 ?M1.0 ?FAIL ?PM;\n   io_targets ?PM (initial ?PM) ?vs = {(?q2.0, ?q1.0)};\n   path ?PM (?xs || ?tr) (?q2.0, ?q1.0); length ?xs = length ?tr;\n   distinct (states (?xs || ?tr) (?q2.0, ?q1.0))\\<rbrakk>\n  \\<Longrightarrow> card\n                     (\\<Union>\n                       (io_targets ?M1.0 (initial ?M1.0) `\n                        R ?M2.0 ?s ?vs ?xs)) =\n                    card (R ?M2.0 ?s ?vs ?xs)\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "by metis"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "case False"], ["proof (state)\nthis:\n  RP M2 s vs xs V'' \\<noteq> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "then"], ["proof (chain)\npicking this:\n  RP M2 s vs xs V'' \\<noteq> R M2 s vs xs", "obtain vs' where vs'_def : \"vs' \\<in> V''\n                                      \\<and> vs' \\<notin> R M2 s vs xs\n                                      \\<and> RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\""], ["proof (prove)\nusing this:\n  RP M2 s vs xs V'' \\<noteq> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        vs' \\<in> V'' \\<and>\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using RP_cases"], ["proof (prove)\nusing this:\n  RP M2 s vs xs V'' \\<noteq> R M2 s vs xs\n  RP M2 s vs xs V'' = R M2 s vs xs \\<or>\n  (\\<exists>vs'\\<in>V''.\n      vs' \\<notin> R M2 s vs xs \\<and>\n      RP M2 s vs xs V'' = insert vs' (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        vs' \\<in> V'' \\<and>\n        vs' \\<notin> R M2 s vs xs \\<and>\n        RP M2 s vs xs V'' = insert vs' (R M2 s vs xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have state_component_2 : \"\\<forall> io \\<in> (R M2 s vs xs) . io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "fix io"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "assume \"io \\<in> R M2 s vs xs\""], ["proof (state)\nthis:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "then"], ["proof (chain)\npicking this:\n  io \\<in> R M2 s vs xs", "have \"s \\<in> io_targets M2 (initial M2) io\""], ["proof (prove)\nusing this:\n  io \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. s \\<in> io_targets M2 (initial M2) io", "by auto"], ["proof (state)\nthis:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "moreover"], ["proof (state)\nthis:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "have \"io \\<in> language_state M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> L M2", "using calculation"], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. io \\<in> L M2", "by auto"], ["proof (state)\nthis:\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> R M2 s vs xs \\<Longrightarrow>\n       io_targets M2 (initial M2) io = {s}", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2", "show \"io_targets M2 (initial M2) io = {s}\""], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "using assms(3) io_targets_observable_singleton_ex"], ["proof (prove)\nusing this:\n  s \\<in> io_targets M2 (initial M2) io\n  io \\<in> L M2\n  observable M2\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q2. io_targets ?M ?q1.0 ?io = {q2}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s}", "by (metis singletonD)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {s}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"vs' \\<in> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs' \\<in> L M1", "using assms(13) perm_language vs'_def"], ["proof (prove)\nusing this:\n  V'' \\<in> Perm V M1\n  \\<lbrakk>?V'' \\<in> Perm ?V ?M; ?vs \\<in> ?V''\\<rbrakk>\n  \\<Longrightarrow> ?vs \\<in> L ?M\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. vs' \\<in> L M1", "by blast"], ["proof (state)\nthis:\n  vs' \\<in> L M1\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "then"], ["proof (chain)\npicking this:\n  vs' \\<in> L M1", "obtain s' where s'_def : \"io_targets M1 (initial M1) vs' = {s'}\""], ["proof (prove)\nusing this:\n  vs' \\<in> L M1\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        io_targets M1 (initial M1) vs' = {s'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(2) io_targets_observable_singleton_ob)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) vs' = {s'}\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "moreover"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) vs' = {s'}\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"s' \\<notin> \\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "assume \"\\<not> s' \\<notin> \\<Union>(io_targets M1 (initial M1) ` R M2 s vs xs)\""], ["proof (state)\nthis:\n  \\<not> s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)", "obtain xs' where xs'_def : \"vs @ xs' \\<in> R M2 s vs xs\n                                        \\<and> s' \\<in> io_targets M1 (initial M1) (vs @ xs')\""], ["proof (prove)\nusing this:\n  \\<not> s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        vs @ xs' \\<in> R M2 s vs xs \\<and>\n        s' \\<in> io_targets M1 (initial M1) (vs @ xs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                vs @ xs' \\<in> R M2 s vs xs \\<and>\n                s' \\<in> io_targets M1 (initial M1)\n                          (vs @ xs') \\<Longrightarrow>\n                thesis;\n     \\<not> s' \\<notin> \\<Union>\n                         (io_targets M1 (initial M1) `\n                          R M2 s vs xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume a1: \"\\<And>xs'. vs @ xs' \\<in> R M2 s vs xs\n                          \\<and> s' \\<in> io_targets M1 (initial M1) (vs @ xs') \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  vs @ ?xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ ?xs') \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                vs @ xs' \\<in> R M2 s vs xs \\<and>\n                s' \\<in> io_targets M1 (initial M1)\n                          (vs @ xs') \\<Longrightarrow>\n                thesis;\n     \\<not> s' \\<notin> \\<Union>\n                         (io_targets M1 (initial M1) `\n                          R M2 s vs xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain pps :: \"('a \\<times> 'b) list set \\<Rightarrow> (('a \\<times> 'b) list \\<Rightarrow> 'c set) \\<Rightarrow> 'c \\<Rightarrow> ('a \\<times> 'b) list\"\n          where\n          \"\\<forall>x0 x1 x2. (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) = (pps x0 x1 x2 \\<in> x0 \\<and> x2 \\<in> x1 (pps x0 x1 x2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pps.\n        \\<forall>x0 x1 x2.\n           (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) =\n           (pps x0 x1 x2 \\<in> x0 \\<and>\n            x2 \\<in> x1 (pps x0 x1 x2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) =\n     (pps x0 x1 x2 \\<in> x0 \\<and> x2 \\<in> x1 (pps x0 x1 x2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                vs @ xs' \\<in> R M2 s vs xs \\<and>\n                s' \\<in> io_targets M1 (initial M1)\n                          (vs @ xs') \\<Longrightarrow>\n                thesis;\n     \\<not> s' \\<notin> \\<Union>\n                         (io_targets M1 (initial M1) `\n                          R M2 s vs xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) =\n     (pps x0 x1 x2 \\<in> x0 \\<and> x2 \\<in> x1 (pps x0 x1 x2))", "have f2: \"pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' \\<in> R M2 s vs xs\n                        \\<and> s' \\<in> io_targets M1 (initial M1)\n                                              (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) =\n     (pps x0 x1 x2 \\<in> x0 \\<and> x2 \\<in> x1 (pps x0 x1 x2))\n\ngoal (1 subgoal):\n 1. pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n    \\<in> R M2 s vs xs \\<and>\n    s' \\<in> io_targets M1 (initial M1)\n              (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')", "using \\<open>\\<not> s' \\<notin> \\<Union>(io_targets M1 (initial M1) ` R M2 s vs xs)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x0 \\<and> x2 \\<in> x1 v3) =\n     (pps x0 x1 x2 \\<in> x0 \\<and> x2 \\<in> x1 (pps x0 x1 x2))\n  \\<not> s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n    \\<in> R M2 s vs xs \\<and>\n    s' \\<in> io_targets M1 (initial M1)\n              (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')", "by blast"], ["proof (state)\nthis:\n  pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n  \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1)\n            (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                vs @ xs' \\<in> R M2 s vs xs \\<and>\n                s' \\<in> io_targets M1 (initial M1)\n                          (vs @ xs') \\<Longrightarrow>\n                thesis;\n     \\<not> s' \\<notin> \\<Union>\n                         (io_targets M1 (initial M1) `\n                          R M2 s vs xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n  \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1)\n            (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')", "have \"\\<exists>ps. pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and> ps \\<noteq> []\n                        \\<and> prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)\""], ["proof (prove)\nusing this:\n  pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n  \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1)\n            (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')\n\ngoal (1 subgoal):\n 1. \\<exists>ps.\n       pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and>\n       ps \\<noteq> [] \\<and>\n       prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)", "by simp"], ["proof (state)\nthis:\n  \\<exists>ps.\n     pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and>\n     ps \\<noteq> [] \\<and>\n     prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                vs @ xs' \\<in> R M2 s vs xs \\<and>\n                s' \\<in> io_targets M1 (initial M1)\n                          (vs @ xs') \\<Longrightarrow>\n                thesis;\n     \\<not> s' \\<notin> \\<Union>\n                         (io_targets M1 (initial M1) `\n                          R M2 s vs xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>ps.\n     pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and>\n     ps \\<noteq> [] \\<and>\n     prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ps.\n     pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and>\n     ps \\<noteq> [] \\<and>\n     prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)\n\ngoal (1 subgoal):\n 1. thesis", "using f2 a1"], ["proof (prove)\nusing this:\n  \\<exists>ps.\n     pps (R M2 s vs xs) (io_targets M1 (initial M1)) s' = vs @ ps \\<and>\n     ps \\<noteq> [] \\<and>\n     prefix ps xs \\<and> s \\<in> io_targets M2 (initial M2) (vs @ ps)\n  pps (R M2 s vs xs) (io_targets M1 (initial M1)) s'\n  \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1)\n            (pps (R M2 s vs xs) (io_targets M1 (initial M1)) s')\n  vs @ ?xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ ?xs') \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (metis (no_types))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"vs @ xs' \\<in> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ xs' \\<in> L M1", "using xs'_def"], ["proof (prove)\nusing this:\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n\ngoal (1 subgoal):\n 1. vs @ xs' \\<in> L M1", "by blast"], ["proof (state)\nthis:\n  vs @ xs' \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  vs @ xs' \\<in> L M1", "have \"io_targets M1 (initial M1) (vs@xs') = {s'}\""], ["proof (prove)\nusing this:\n  vs @ xs' \\<in> L M1\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) (vs @ xs') = {s'}", "by (metis assms(2) io_targets_observable_singleton_ob singletonD xs'_def)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) (vs @ xs') = {s'}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) (vs @ xs') = {s'}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"io_targets M1 (initial M1) (vs') = {s'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) vs' = {s'}", "using s'_def"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) vs' = {s'}\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) vs' = {s'}", "by blast"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) vs' = {s'}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) vs' = {s'}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"io_targets M2 (initial M2) (vs @ xs') = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) (vs @ xs') = {s}", "using state_component_2 xs'_def"], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>R M2 s vs xs. io_targets M2 (initial M2) io = {s}\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) (vs @ xs') = {s}", "by blast"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (vs @ xs') = {s}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (vs @ xs') = {s}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"io_targets M2 (initial M2) (vs') = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) vs' = {s}", "by (metis (mono_tags, lifting) RP.simps Un_iff insertI1 mem_Collect_eq vs'_def)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) vs' = {s}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) vs' = {s}\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"xs' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' \\<noteq> []", "using xs'_def"], ["proof (prove)\nusing this:\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"prefix xs' xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs' xs", "using xs'_def"], ["proof (prove)\nusing this:\n  vs @ xs' \\<in> R M2 s vs xs \\<and>\n  s' \\<in> io_targets M1 (initial M1) (vs @ xs')\n\ngoal (1 subgoal):\n 1. prefix xs' xs", "by simp"], ["proof (state)\nthis:\n  prefix xs' xs\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  prefix xs' xs\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "have \"vs' \\<in> V''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs' \\<in> V''", "using vs'_def"], ["proof (prove)\nusing this:\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. vs' \\<in> V''", "by simp"], ["proof (state)\nthis:\n  vs' \\<in> V''\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) (vs @ xs') = {s'}\n  io_targets M1 (initial M1) vs' = {s'}\n  io_targets M2 (initial M2) (vs @ xs') = {s}\n  io_targets M2 (initial M2) vs' = {s}\n  xs' \\<noteq> []\n  prefix xs' xs\n  vs' \\<in> V''", "have \"Rep_Cov M2 M1 V'' vs xs\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) (vs @ xs') = {s'}\n  io_targets M1 (initial M1) vs' = {s'}\n  io_targets M2 (initial M2) (vs @ xs') = {s}\n  io_targets M2 (initial M2) vs' = {s}\n  xs' \\<noteq> []\n  prefix xs' xs\n  vs' \\<in> V''\n\ngoal (1 subgoal):\n 1. Rep_Cov M2 M1 V'' vs xs", "by auto"], ["proof (state)\nthis:\n  Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. \\<not> s' \\<notin> \\<Union>\n                        (io_targets M1 (initial M1) `\n                         R M2 s vs xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Rep_Cov M2 M1 V'' vs xs", "show \"False\""], ["proof (prove)\nusing this:\n  Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. False", "using assms(14)"], ["proof (prove)\nusing this:\n  Rep_Cov M2 M1 V'' vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "moreover"], ["proof (state)\nthis:\n  s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"\\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs)))\n                    = insert s' (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n    insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))", "using s'_def"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) vs' = {s'}\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n    insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))", "by simp"], ["proof (state)\nthis:\n  \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n  insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "moreover"], ["proof (state)\nthis:\n  \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n  insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"finite (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (R M2 s vs xs)\n 2. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "show \"finite (R M2 s vs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R M2 s vs xs)", "using finite_R"], ["proof (prove)\nusing this:\n  finite (R ?M ?s ?vs ?xs)\n\ngoal (1 subgoal):\n 1. finite (R M2 s vs xs)", "by simp"], ["proof (state)\nthis:\n  finite (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "show \"\\<And>a. a \\<in> R M2 s vs xs \\<Longrightarrow> finite (io_targets M1 (initial M1) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "assume \"a \\<in> R M2 s vs xs\""], ["proof (state)\nthis:\n  a \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "then"], ["proof (chain)\npicking this:\n  a \\<in> R M2 s vs xs", "have \"prefix a (vs@xs)\""], ["proof (prove)\nusing this:\n  a \\<in> R M2 s vs xs\n\ngoal (1 subgoal):\n 1. prefix a (vs @ xs)", "by auto"], ["proof (state)\nthis:\n  prefix a (vs @ xs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "then"], ["proof (chain)\npicking this:\n  prefix a (vs @ xs)", "have \"a \\<in> L M1\""], ["proof (prove)\nusing this:\n  prefix a (vs @ xs)\n\ngoal (1 subgoal):\n 1. a \\<in> L M1", "using language_state_prefix"], ["proof (prove)\nusing this:\n  prefix a (vs @ xs)\n  ?w1.0 @ ?w2.0 \\<in> LS ?M ?q \\<Longrightarrow> ?w1.0 \\<in> LS ?M ?q\n\ngoal (1 subgoal):\n 1. a \\<in> L M1", "by (metis IntD1 assms(1) prefix_def)"], ["proof (state)\nthis:\n  a \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "then"], ["proof (chain)\npicking this:\n  a \\<in> L M1", "obtain p where \"io_targets M1 (initial M1) a = {p}\""], ["proof (prove)\nusing this:\n  a \\<in> L M1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        io_targets M1 (initial M1) a = {p} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) io_targets_observable_singleton_ob"], ["proof (prove)\nusing this:\n  a \\<in> L M1\n  observable M1\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q1.0;\n   \\<And>q2.\n      io_targets ?M ?q1.0 ?io = {q2} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        io_targets M1 (initial M1) a = {p} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) a = {p}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> R M2 s vs xs \\<Longrightarrow>\n       finite (io_targets M1 (initial M1) a)", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) a = {p}", "show \"finite (io_targets M1 (initial M1) a)\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) a = {p}\n\ngoal (1 subgoal):\n 1. finite (io_targets M1 (initial M1) a)", "by simp"], ["proof (state)\nthis:\n  finite (io_targets M1 (initial M1) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a \\<in> R M2 s vs xs \\<Longrightarrow>\n  finite (io_targets M1 (initial M1) ?a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "ultimately"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) vs' = {s'}\n  s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n  \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n  insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n  finite (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))", "have \"card (\\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))\n                      = Suc (card (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) vs' = {s'}\n  s' \\<notin> \\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)\n  \\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)) =\n  insert s' (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n  finite (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs))) =\n    Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))", "by (metis (no_types) card_insert_disjoint)"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs))) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "moreover"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs))) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))\n                    = card (\\<Union> (image (io_targets M1 (initial M1)) (insert vs' (R M2 s vs xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)))", "using vs'_def"], ["proof (prove)\nusing this:\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)))", "by simp"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "ultimately"], ["proof (chain)\npicking this:\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs))) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)))", "have \"card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))\n                      = Suc (card (\\<Union> (image (io_targets M1 (initial M1)) (R M2 s vs xs))))\""], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs))) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` insert vs' (R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))", "by linarith"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "then"], ["proof (chain)\npicking this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))", "have \"card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))\n                  = Suc (card (R M2 s vs xs))\""], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    Suc (card (R M2 s vs xs))", "using R_count[of vs xs M1 M2 s FAIL PM q2 q1 tr]"], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n  \\<lbrakk>vs @ xs \\<in> L M1 \\<inter> L M2; observable M1; observable M2;\n   well_formed M1; well_formed M2; s \\<in> nodes M2; productF M2 M1 FAIL PM;\n   io_targets PM (initial PM) vs = {(q2, q1)}; path PM (xs || tr) (q2, q1);\n   length xs = length tr; distinct (states (xs || tr) (q2, q1))\\<rbrakk>\n  \\<Longrightarrow> card\n                     (\\<Union>\n                       (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n                    card (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    Suc (card (R M2 s vs xs))", "using assms(1,10,11,2-9)"], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (\\<Union> (io_targets M1 (initial M1) ` R M2 s vs xs)))\n  \\<lbrakk>vs @ xs \\<in> L M1 \\<inter> L M2; observable M1; observable M2;\n   well_formed M1; well_formed M2; s \\<in> nodes M2; productF M2 M1 FAIL PM;\n   io_targets PM (initial PM) vs = {(q2, q1)}; path PM (xs || tr) (q2, q1);\n   length xs = length tr; distinct (states (xs || tr) (q2, q1))\\<rbrakk>\n  \\<Longrightarrow> card\n                     (\\<Union>\n                       (io_targets M1 (initial M1) ` R M2 s vs xs)) =\n                    card (R M2 s vs xs)\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  length xs = length tr\n  distinct (states (xs || tr) (q2, q1))\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    Suc (card (R M2 s vs xs))", "by linarith"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "moreover"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))", "using vs'_def"], ["proof (prove)\nusing this:\n  vs' \\<in> V'' \\<and>\n  vs' \\<notin> R M2 s vs xs \\<and>\n  RP M2 s vs xs V'' = insert vs' (R M2 s vs xs)\n\ngoal (1 subgoal):\n 1. card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))", "by (metis card_insert_if finite_R)"], ["proof (state)\nthis:\n  card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. RP M2 s vs xs V'' \\<noteq> R M2 s vs xs \\<Longrightarrow>\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "ultimately"], ["proof (chain)\npicking this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (R M2 s vs xs))\n  card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  Suc (card (R M2 s vs xs))\n  card (RP M2 s vs xs V'') = Suc (card (R M2 s vs xs))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "by linarith"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (RP M2 s vs xs V'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (RP M2 s vs xs V'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma RP_count_alt_def :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"s \\<in> nodes M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"card (\\<Union>(image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) = card (RP M2 s vs xs V'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "have \"distinct (states (xs || tr) (q2,q1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (states (xs || tr) (q2, q1))", "using distinctness_via_Rep_Pre[of M2 M1 vs xs FAIL PM q2 q1 tr] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> Rep_Pre M2 M1 vs xs; productF M2 M1 FAIL PM;\n   observable M1; observable M2; io_targets PM (initial PM) vs = {(q2, q1)};\n   path PM (xs || tr) (q2, q1); length xs = length tr;\n   vs @ xs \\<in> L M1 \\<inter> L M2; well_formed M1; well_formed M2\\<rbrakk>\n  \\<Longrightarrow> distinct (states (xs || tr) (q2, q1))\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n  \\<not> Rep_Pre M2 M1 vs xs\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. distinct (states (xs || tr) (q2, q1))", "by simp"], ["proof (state)\nthis:\n  distinct (states (xs || tr) (q2, q1))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "then"], ["proof (chain)\npicking this:\n  distinct (states (xs || tr) (q2, q1))", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (states (xs || tr) (q2, q1))\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "using RP_count_via_Rep_Cov[of vs xs M1 M2 s FAIL PM q2 q1 tr V V'']"], ["proof (prove)\nusing this:\n  distinct (states (xs || tr) (q2, q1))\n  \\<lbrakk>vs @ xs \\<in> L M1 \\<inter> L M2; observable M1; observable M2;\n   well_formed M1; well_formed M2; s \\<in> nodes M2; productF M2 M1 FAIL PM;\n   io_targets PM (initial PM) vs = {(q2, q1)}; path PM (xs || tr) (q2, q1);\n   length xs = length tr; distinct (states (xs || tr) (q2, q1));\n   is_det_state_cover M2 V; V'' \\<in> Perm V M1;\n   \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n  \\<Longrightarrow> card\n                     (\\<Union>\n                       (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n                    card (RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "using assms(1,10,12-14,2-9)"], ["proof (prove)\nusing this:\n  distinct (states (xs || tr) (q2, q1))\n  \\<lbrakk>vs @ xs \\<in> L M1 \\<inter> L M2; observable M1; observable M2;\n   well_formed M1; well_formed M2; s \\<in> nodes M2; productF M2 M1 FAIL PM;\n   io_targets PM (initial PM) vs = {(q2, q1)}; path PM (xs || tr) (q2, q1);\n   length xs = length tr; distinct (states (xs || tr) (q2, q1));\n   is_det_state_cover M2 V; V'' \\<in> Perm V M1;\n   \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n  \\<Longrightarrow> card\n                     (\\<Union>\n                       (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n                    card (RP M2 s vs xs V'')\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  length xs = length tr\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  s \\<in> nodes M2\n  productF M2 M1 FAIL PM\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card (RP M2 s vs xs V'')", "by blast"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card (RP M2 s vs xs V'')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Function LB \\<close>"], ["", "text \\<open>\n@{verbatim LB} adds together the number of elements in sets calculated via RP for a given set of\nstates and the number of ATC-reaction known to exist but not produced by a state reached by any of\nthe above elements.\n\\<close>"], ["", "fun LB :: \"('in, 'out, 'state1) FSM \\<Rightarrow> ('in, 'out, 'state2) FSM\n          \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> 'in list set\n          \\<Rightarrow> 'state1 set \\<Rightarrow> ('in, 'out) ATC set\n          \\<Rightarrow> ('in \\<times> 'out) list set \\<Rightarrow> nat\"\n  where\n  \"LB M2 M1 vs xs T S \\<Omega> V'' =\n    (sum (\\<lambda> s . card (RP M2 s vs xs V'')) S)\n    + card ((D M1 T \\<Omega>) -\n            {B M1 xs' \\<Omega> | xs' s' . s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\""], ["", "lemma LB_count_helper_RP_disjoint_and_cards :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"s1 \\<noteq> s2\"\nshows \"\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))\n        \\<inter> \\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')) = {}\"\n      \"card (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')))\n        = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))\"\n      \"card (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))\n        = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {} &&&\n    card (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) &&&\n    card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n 3. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "have \"\\<forall> io \\<in> RP M2 s1 vs xs V'' . io_targets PM (initial PM) io\n                                      = {s1} \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>RP M2 s1 vs xs V''.\n       io_targets PM (initial PM) io =\n       {s1} \\<times> io_targets M1 (initial M1) io", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s1 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s1} \\<times> io_targets M1 (initial M1) io", "fix io"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s1 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s1} \\<times> io_targets M1 (initial M1) io", "assume \"io \\<in> RP M2 s1 vs xs V''\""], ["proof (state)\nthis:\n  io \\<in> RP M2 s1 vs xs V''\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s1 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s1} \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<in> RP M2 s1 vs xs V''", "have \"io_targets PM (initial PM) io\n                = io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s1 vs xs V''\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "using assms RP_io_targets_split[of vs xs M1 M2 FAIL PM V V'' io s1]"], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s1 vs xs V''\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  s1 \\<noteq> s2\n  \\<lbrakk>vs @ xs \\<in> L M1 \\<inter> L M2; observable M1; observable M2;\n   well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n   is_det_state_cover M2 V; V'' \\<in> Perm V M1;\n   io \\<in> RP M2 s1 vs xs V''\\<rbrakk>\n  \\<Longrightarrow> io_targets PM (initial PM) io =\n                    io_targets M2 (initial M2) io \\<times>\n                    io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "by simp"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s1 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s1} \\<times> io_targets M1 (initial M1) io", "moreover"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s1 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s1} \\<times> io_targets M1 (initial M1) io", "have \"io_targets M2 (initial M2) io = {s1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s1}", "using \\<open>io \\<in> RP M2 s1 vs xs V''\\<close> assms(3) RP_state_component_2[of io M2 s1 vs xs V'']"], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s1 vs xs V''\n  observable M2\n  \\<lbrakk>io \\<in> RP M2 s1 vs xs V''; observable M2\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 (initial M2) io = {s1}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s1}", "by blast"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {s1}\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s1 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s1} \\<times> io_targets M1 (initial M1) io", "ultimately"], ["proof (chain)\npicking this:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n  io_targets M2 (initial M2) io = {s1}", "show \"io_targets PM (initial PM) io = {s1} \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n  io_targets M2 (initial M2) io = {s1}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    {s1} \\<times> io_targets M1 (initial M1) io", "by auto"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  {s1} \\<times> io_targets M1 (initial M1) io\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>io\\<in>RP M2 s1 vs xs V''.\n     io_targets PM (initial PM) io =\n     {s1} \\<times> io_targets M1 (initial M1) io\n\ngoal (3 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n 3. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "then"], ["proof (chain)\npicking this:\n  \\<forall>io\\<in>RP M2 s1 vs xs V''.\n     io_targets PM (initial PM) io =\n     {s1} \\<times> io_targets M1 (initial M1) io", "have \"\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))\n              = \\<Union> (image (\\<lambda> io . {s1} \\<times> io_targets M1 (initial M1) io) (RP M2 s1 vs xs V''))\""], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>RP M2 s1 vs xs V''.\n     io_targets PM (initial PM) io =\n     {s1} \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') =\n    (\\<Union>io\\<in>RP M2 s1 vs xs V''.\n        {s1} \\<times> io_targets M1 (initial M1) io)", "by simp"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s1 vs xs V''.\n      {s1} \\<times> io_targets M1 (initial M1) io)\n\ngoal (3 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n 3. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "moreover"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s1 vs xs V''.\n      {s1} \\<times> io_targets M1 (initial M1) io)\n\ngoal (3 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n 3. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "have \"\\<Union> (image (\\<lambda> io . {s1} \\<times> io_targets M1 (initial M1) io) (RP M2 s1 vs xs V''))\n                  = {s1} \\<times> \\<Union> (image (\\<lambda> io . io_targets M1 (initial M1) io) (RP M2 s1 vs xs V''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>io\\<in>RP M2 s1 vs xs V''.\n        {s1} \\<times> io_targets M1 (initial M1) io) =\n    {s1} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')", "by blast"], ["proof (state)\nthis:\n  (\\<Union>io\\<in>RP M2 s1 vs xs V''.\n      {s1} \\<times> io_targets M1 (initial M1) io) =\n  {s1} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')\n\ngoal (3 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n 3. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "ultimately"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s1 vs xs V''.\n      {s1} \\<times> io_targets M1 (initial M1) io)\n  (\\<Union>io\\<in>RP M2 s1 vs xs V''.\n      {s1} \\<times> io_targets M1 (initial M1) io) =\n  {s1} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')", "have image_split_1 :\n    \"\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'') )\n      = {s1} \\<times> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))\""], ["proof (prove)\nusing this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s1 vs xs V''.\n      {s1} \\<times> io_targets M1 (initial M1) io)\n  (\\<Union>io\\<in>RP M2 s1 vs xs V''.\n      {s1} \\<times> io_targets M1 (initial M1) io) =\n  {s1} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') =\n    {s1} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')", "by simp"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') =\n  {s1} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')\n\ngoal (3 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n 3. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "then"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') =\n  {s1} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')", "show \"card (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')))\n              = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))\""], ["proof (prove)\nusing this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') =\n  {s1} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))", "by (metis (no_types)  card_cartesian_product_singleton)"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n\ngoal (2 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "have \"\\<forall> io \\<in> RP M2 s2 vs xs V'' . io_targets PM (initial PM) io\n                                      = {s2} \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>io\\<in>RP M2 s2 vs xs V''.\n       io_targets PM (initial PM) io =\n       {s2} \\<times> io_targets M1 (initial M1) io", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s2 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s2} \\<times> io_targets M1 (initial M1) io", "fix io"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s2 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s2} \\<times> io_targets M1 (initial M1) io", "assume \"io \\<in> RP M2 s2 vs xs V''\""], ["proof (state)\nthis:\n  io \\<in> RP M2 s2 vs xs V''\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s2 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s2} \\<times> io_targets M1 (initial M1) io", "then"], ["proof (chain)\npicking this:\n  io \\<in> RP M2 s2 vs xs V''", "have \"io_targets PM (initial PM) io\n                  = io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s2 vs xs V''\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "using assms RP_io_targets_split[of vs xs M1 M2 FAIL PM V V'' io s2]"], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s2 vs xs V''\n  vs @ xs \\<in> L M1 \\<inter> L M2\n  observable M1\n  observable M2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  is_det_state_cover M2 V\n  V'' \\<in> Perm V M1\n  s1 \\<noteq> s2\n  \\<lbrakk>vs @ xs \\<in> L M1 \\<inter> L M2; observable M1; observable M2;\n   well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n   is_det_state_cover M2 V; V'' \\<in> Perm V M1;\n   io \\<in> RP M2 s2 vs xs V''\\<rbrakk>\n  \\<Longrightarrow> io_targets PM (initial PM) io =\n                    io_targets M2 (initial M2) io \\<times>\n                    io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io", "by simp"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s2 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s2} \\<times> io_targets M1 (initial M1) io", "moreover"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s2 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s2} \\<times> io_targets M1 (initial M1) io", "have \"io_targets M2 (initial M2) io = {s2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s2}", "using \\<open>io \\<in> RP M2 s2 vs xs V''\\<close> assms(3) RP_state_component_2[of io M2 s2 vs xs V'']"], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s2 vs xs V''\n  observable M2\n  \\<lbrakk>io \\<in> RP M2 s2 vs xs V''; observable M2\\<rbrakk>\n  \\<Longrightarrow> io_targets M2 (initial M2) io = {s2}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) io = {s2}", "by blast"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) io = {s2}\n\ngoal (1 subgoal):\n 1. \\<And>io.\n       io \\<in> RP M2 s2 vs xs V'' \\<Longrightarrow>\n       io_targets PM (initial PM) io =\n       {s2} \\<times> io_targets M1 (initial M1) io", "ultimately"], ["proof (chain)\npicking this:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n  io_targets M2 (initial M2) io = {s2}", "show \"io_targets PM (initial PM) io = {s2} \\<times> io_targets M1 (initial M1) io\""], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io =\n  io_targets M2 (initial M2) io \\<times> io_targets M1 (initial M1) io\n  io_targets M2 (initial M2) io = {s2}\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io =\n    {s2} \\<times> io_targets M1 (initial M1) io", "by auto"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io =\n  {s2} \\<times> io_targets M1 (initial M1) io\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>io\\<in>RP M2 s2 vs xs V''.\n     io_targets PM (initial PM) io =\n     {s2} \\<times> io_targets M1 (initial M1) io\n\ngoal (2 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "then"], ["proof (chain)\npicking this:\n  \\<forall>io\\<in>RP M2 s2 vs xs V''.\n     io_targets PM (initial PM) io =\n     {s2} \\<times> io_targets M1 (initial M1) io", "have \"\\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V''))\n              = \\<Union> (image (\\<lambda> io . {s2} \\<times> io_targets M1 (initial M1) io) (RP M2 s2 vs xs V''))\""], ["proof (prove)\nusing this:\n  \\<forall>io\\<in>RP M2 s2 vs xs V''.\n     io_targets PM (initial PM) io =\n     {s2} \\<times> io_targets M1 (initial M1) io\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    (\\<Union>io\\<in>RP M2 s2 vs xs V''.\n        {s2} \\<times> io_targets M1 (initial M1) io)", "by simp"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s2 vs xs V''.\n      {s2} \\<times> io_targets M1 (initial M1) io)\n\ngoal (2 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "moreover"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s2 vs xs V''.\n      {s2} \\<times> io_targets M1 (initial M1) io)\n\ngoal (2 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "have \"\\<Union> (image (\\<lambda> io . {s2} \\<times> io_targets M1 (initial M1) io) (RP M2 s2 vs xs V''))\n                  = {s2} \\<times> \\<Union> (image (\\<lambda> io . io_targets M1 (initial M1) io) (RP M2 s2 vs xs V''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>io\\<in>RP M2 s2 vs xs V''.\n        {s2} \\<times> io_targets M1 (initial M1) io) =\n    {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')", "by blast"], ["proof (state)\nthis:\n  (\\<Union>io\\<in>RP M2 s2 vs xs V''.\n      {s2} \\<times> io_targets M1 (initial M1) io) =\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')\n\ngoal (2 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "ultimately"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s2 vs xs V''.\n      {s2} \\<times> io_targets M1 (initial M1) io)\n  (\\<Union>io\\<in>RP M2 s2 vs xs V''.\n      {s2} \\<times> io_targets M1 (initial M1) io) =\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')", "have image_split_2 :\n    \"\\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V''))\n      = {s2} \\<times> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V''))\""], ["proof (prove)\nusing this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  (\\<Union>io\\<in>RP M2 s2 vs xs V''.\n      {s2} \\<times> io_targets M1 (initial M1) io)\n  (\\<Union>io\\<in>RP M2 s2 vs xs V''.\n      {s2} \\<times> io_targets M1 (initial M1) io) =\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')", "by simp"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')\n\ngoal (2 subgoals):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}\n 2. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "then"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')", "show \"card (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))\n              = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))\""], ["proof (prove)\nusing this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')\n\ngoal (1 subgoal):\n 1. card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "by (metis (no_types)  card_cartesian_product_singleton)"], ["proof (state)\nthis:\n  card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}", "have \"\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))\n          \\<inter> \\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V''))\n        = {s1} \\<times> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))\n          \\<inter> {s2} \\<times> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {s1} \\<times>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')", "using image_split_1 image_split_2"], ["proof (prove)\nusing this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') =\n  {s1} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {s1} \\<times>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')", "by blast"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  {s1} \\<times>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}", "moreover"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  {s1} \\<times>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}", "have \"{s1} \\<times> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))\n                  \\<inter> {s2} \\<times> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s1} \\<times>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    {s2} \\<times>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "using assms(9)"], ["proof (prove)\nusing this:\n  s1 \\<noteq> s2\n\ngoal (1 subgoal):\n 1. {s1} \\<times>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    {s2} \\<times>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "by auto"], ["proof (state)\nthis:\n  {s1} \\<times>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n  {}\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  {s1} \\<times>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')\n  {s1} \\<times>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n  {}", "show \"\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))\n                    \\<inter> \\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')) = {}\""], ["proof (prove)\nusing this:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  {s1} \\<times>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')\n  {s1} \\<times>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  {s2} \\<times> \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n  {}\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n    {}", "by presburger"], ["proof (state)\nthis:\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LB_count_helper_RP_disjoint_card_M1 :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"s1 \\<noteq> s2\"\nshows \"card (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V''))\n              \\<union> \\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))\n       = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))\n          + card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<union>\n      \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<union>\n      \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "have \"finite (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s1 vs xs V'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V''))", "using RP_io_targets_finite_PM[OF assms(1-8)]"], ["proof (prove)\nusing this:\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 ?s vs xs V''))\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V''))", "by simp"], ["proof (state)\nthis:\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V''))\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<union>\n      \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "moreover"], ["proof (state)\nthis:\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V''))\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<union>\n      \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "have \"finite (\\<Union> (image (io_targets PM (initial PM)) (RP M2 s2 vs xs V'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V''))", "using RP_io_targets_finite_PM[OF assms(1-8)]"], ["proof (prove)\nusing this:\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 ?s vs xs V''))\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V''))", "by simp"], ["proof (state)\nthis:\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V''))\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<union>\n      \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "ultimately"], ["proof (chain)\npicking this:\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V''))\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V''))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V''))\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V''))\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<union>\n      \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "using LB_count_helper_RP_disjoint_and_cards[OF assms]"], ["proof (prove)\nusing this:\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V''))\n  finite (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V''))\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'') =\n  {}\n  card (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n  card (\\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<union>\n      \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "by (metis (no_types) card_Un_disjoint)"], ["proof (state)\nthis:\n  card\n   (\\<Union> (io_targets PM (initial PM) ` RP M2 s1 vs xs V'') \\<union>\n    \\<Union> (io_targets PM (initial PM) ` RP M2 s2 vs xs V'')) =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LB_count_helper_RP_disjoint_M1_pair :\n  assumes \"(vs @ xs) \\<in> L M1 \\<inter> L M2\"\n  and \"observable M1\"\n  and \"observable M2\"\n  and \"well_formed M1\"\n  and \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\n  and \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n  and \"path PM (xs || tr) (q2,q1)\"\n  and \"length xs = length tr\"\n  and \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and \"is_det_state_cover M2 V\"\n  and \"V'' \\<in> Perm V M1\"\n  and \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\n  and \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and \"s1 \\<noteq> s2\"\n  and \"s1 \\<in> S\"\n  and \"s2 \\<in> S\"\n  and \"applicable_set M1 \\<Omega>\"\n  and \"completely_specified M1\"\nshows \"card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'')\n        = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))\n          + card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))\"\n      \"\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))\n          \\<inter> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V''))\n        = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')) &&&\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n 2. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "have \"s1 \\<in> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<in> nodes M2", "using assms(14,16)"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  s1 \\<in> S\n\ngoal (1 subgoal):\n 1. s1 \\<in> nodes M2", "unfolding Prereq.simps"], ["proof (prove)\nusing this:\n  finite T \\<and>\n  vs @ xs \\<in> L M2 \\<inter> L M1 \\<and>\n  S \\<subseteq> nodes M2 \\<and>\n  (\\<forall>s1\\<in>S.\n      \\<forall>s2\\<in>S.\n         s1 \\<noteq> s2 \\<longrightarrow>\n         (\\<forall>io1\\<in>RP M2 s1 vs xs V''.\n             \\<forall>io2\\<in>RP M2 s2 vs xs V''.\n                B M1 io1 \\<Omega> \\<noteq> B M1 io2 \\<Omega>))\n  s1 \\<in> S\n\ngoal (1 subgoal):\n 1. s1 \\<in> nodes M2", "by blast"], ["proof (state)\nthis:\n  s1 \\<in> nodes M2\n\ngoal (2 subgoals):\n 1. card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n 2. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "have \"s2 \\<in> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s2 \\<in> nodes M2", "using assms(14,17)"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  s2 \\<in> S\n\ngoal (1 subgoal):\n 1. s2 \\<in> nodes M2", "unfolding Prereq.simps"], ["proof (prove)\nusing this:\n  finite T \\<and>\n  vs @ xs \\<in> L M2 \\<inter> L M1 \\<and>\n  S \\<subseteq> nodes M2 \\<and>\n  (\\<forall>s1\\<in>S.\n      \\<forall>s2\\<in>S.\n         s1 \\<noteq> s2 \\<longrightarrow>\n         (\\<forall>io1\\<in>RP M2 s1 vs xs V''.\n             \\<forall>io2\\<in>RP M2 s2 vs xs V''.\n                B M1 io1 \\<Omega> \\<noteq> B M1 io2 \\<Omega>))\n  s2 \\<in> S\n\ngoal (1 subgoal):\n 1. s2 \\<in> nodes M2", "by blast"], ["proof (state)\nthis:\n  s2 \\<in> nodes M2\n\ngoal (2 subgoals):\n 1. card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n 2. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "have \"card (RP M2 s1 vs xs V'')\n          = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (RP M2 s1 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))", "using RP_count_alt_def[OF assms(1-5) \\<open>s1 \\<in> nodes M2\\<close> assms(6-13)]"], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) =\n  card (RP M2 s1 vs xs V'')\n\ngoal (1 subgoal):\n 1. card (RP M2 s1 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))", "by linarith"], ["proof (state)\nthis:\n  card (RP M2 s1 vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n\ngoal (2 subgoals):\n 1. card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n 2. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "moreover"], ["proof (state)\nthis:\n  card (RP M2 s1 vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n\ngoal (2 subgoals):\n 1. card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n 2. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "have \"card (RP M2 s2 vs xs V'')\n                  = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "using RP_count_alt_def[OF assms(1-5) \\<open>s2 \\<in> nodes M2\\<close> assms(6-13)]"], ["proof (prove)\nusing this:\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'')) =\n  card (RP M2 s2 vs xs V'')\n\ngoal (1 subgoal):\n 1. card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "by linarith"], ["proof (state)\nthis:\n  card (RP M2 s2 vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n\ngoal (2 subgoals):\n 1. card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n 2. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "moreover"], ["proof (state)\nthis:\n  card (RP M2 s2 vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n\ngoal (2 subgoals):\n 1. card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n 2. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "show \"\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))\n                  \\<inter> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n    {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V''))\n              \\<inter> \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')) \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') \\<noteq>\n  {}", "obtain io1 io2 t where shared_elem_def :\n      \"io1 \\<in> (RP M2 s1 vs xs V'')\"\n      \"io2 \\<in> (RP M2 s2 vs xs V'')\"\n      \"t \\<in> io_targets M1 (initial M1) io1\"\n      \"t \\<in> io_targets M1 (initial M1) io2\""], ["proof (prove)\nusing this:\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>io1 io2 t.\n        \\<lbrakk>io1 \\<in> RP M2 s1 vs xs V''; io2 \\<in> RP M2 s2 vs xs V'';\n         t \\<in> io_targets M1 (initial M1) io1;\n         t \\<in> io_targets M1 (initial M1) io2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  io1 \\<in> RP M2 s1 vs xs V''\n  io2 \\<in> RP M2 s2 vs xs V''\n  t \\<in> io_targets M1 (initial M1) io1\n  t \\<in> io_targets M1 (initial M1) io2\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') \\<noteq>\n    {} \\<Longrightarrow>\n    False", "have dist_prop: \"(\\<forall> s1 \\<in> S . \\<forall> s2 \\<in> S . s1 \\<noteq> s2\n            \\<longrightarrow> (\\<forall> io1 \\<in> RP M2 s1 vs xs V'' .\n                       \\<forall> io2 \\<in> RP M2 s2 vs xs V'' .\n                         B M1 io1 \\<Omega> \\<noteq> B M1 io2 \\<Omega> ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s1\\<in>S.\n       \\<forall>s2\\<in>S.\n          s1 \\<noteq> s2 \\<longrightarrow>\n          (\\<forall>io1\\<in>RP M2 s1 vs xs V''.\n              \\<forall>io2\\<in>RP M2 s2 vs xs V''.\n                 B M1 io1 \\<Omega> \\<noteq> B M1 io2 \\<Omega>)", "using assms(14)"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n\ngoal (1 subgoal):\n 1. \\<forall>s1\\<in>S.\n       \\<forall>s2\\<in>S.\n          s1 \\<noteq> s2 \\<longrightarrow>\n          (\\<forall>io1\\<in>RP M2 s1 vs xs V''.\n              \\<forall>io2\\<in>RP M2 s2 vs xs V''.\n                 B M1 io1 \\<Omega> \\<noteq> B M1 io2 \\<Omega>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>s1\\<in>S.\n     \\<forall>s2\\<in>S.\n        s1 \\<noteq> s2 \\<longrightarrow>\n        (\\<forall>io1\\<in>RP M2 s1 vs xs V''.\n            \\<forall>io2\\<in>RP M2 s2 vs xs V''.\n               B M1 io1 \\<Omega> \\<noteq> B M1 io2 \\<Omega>)\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') \\<noteq>\n    {} \\<Longrightarrow>\n    False", "have \"io_targets M1 (initial M1) io1 \\<inter> io_targets M1 (initial M1) io2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io1 \\<inter> io_targets M1 (initial M1) io2 =\n    {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io1 \\<inter>\n    io_targets M1 (initial M1) io2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"io_targets M1 (initial M1) io1 \\<inter> io_targets M1 (initial M1) io2 \\<noteq> {}\""], ["proof (state)\nthis:\n  io_targets M1 (initial M1) io1 \\<inter>\n  io_targets M1 (initial M1) io2 \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io1 \\<inter>\n    io_targets M1 (initial M1) io2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) io1 \\<inter>\n  io_targets M1 (initial M1) io2 \\<noteq>\n  {}", "have \"io_targets M1 (initial M1) io1 \\<noteq> {}\" \"io_targets M1 (initial M1) io2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) io1 \\<inter>\n  io_targets M1 (initial M1) io2 \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io1 \\<noteq> {} &&&\n    io_targets M1 (initial M1) io2 \\<noteq> {}", "by blast+"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) io1 \\<noteq> {}\n  io_targets M1 (initial M1) io2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io1 \\<inter>\n    io_targets M1 (initial M1) io2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) io1 \\<noteq> {}\n  io_targets M1 (initial M1) io2 \\<noteq> {}", "obtain s1 s2 where \"s1 \\<in> io_targets M1 (initial M1) io1\"\n                              \"s2 \\<in> io_targets M1 (initial M1) io2\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) io1 \\<noteq> {}\n  io_targets M1 (initial M1) io2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>s1 s2.\n        \\<lbrakk>s1 \\<in> io_targets M1 (initial M1) io1;\n         s2 \\<in> io_targets M1 (initial M1) io2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s1 \\<in> io_targets M1 (initial M1) io1\n  s2 \\<in> io_targets M1 (initial M1) io2\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io1 \\<inter>\n    io_targets M1 (initial M1) io2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  s1 \\<in> io_targets M1 (initial M1) io1\n  s2 \\<in> io_targets M1 (initial M1) io2", "have \"io_targets M1 (initial M1) io1 = {s1}\"\n                \"io_targets M1 (initial M1) io2 = {s2}\""], ["proof (prove)\nusing this:\n  s1 \\<in> io_targets M1 (initial M1) io1\n  s2 \\<in> io_targets M1 (initial M1) io2\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io1 = {s1} &&&\n    io_targets M1 (initial M1) io2 = {s2}", "by (meson assms(2) observable_io_target_is_singleton)+"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) io1 = {s1}\n  io_targets M1 (initial M1) io2 = {s2}\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io1 \\<inter>\n    io_targets M1 (initial M1) io2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) io1 = {s1}\n  io_targets M1 (initial M1) io2 = {s2}", "have \"s1 = s2\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) io1 = {s1}\n  io_targets M1 (initial M1) io2 = {s2}\n\ngoal (1 subgoal):\n 1. s1 = s2", "using \\<open>io_targets M1 (initial M1) io1 \\<inter> io_targets M1 (initial M1) io2 \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) io1 = {s1}\n  io_targets M1 (initial M1) io2 = {s2}\n  io_targets M1 (initial M1) io1 \\<inter>\n  io_targets M1 (initial M1) io2 \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. s1 = s2", "by auto"], ["proof (state)\nthis:\n  s1 = s2\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io1 \\<inter>\n    io_targets M1 (initial M1) io2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  s1 = s2", "have \"B M1 io1 \\<Omega> = B M1 io2 \\<Omega>\""], ["proof (prove)\nusing this:\n  s1 = s2\n\ngoal (1 subgoal):\n 1. B M1 io1 \\<Omega> = B M1 io2 \\<Omega>", "using \\<open>io_targets M1 (initial M1) io1 = {s1}\\<close> \\<open>io_targets M1 (initial M1) io2 = {s2}\\<close>"], ["proof (prove)\nusing this:\n  s1 = s2\n  io_targets M1 (initial M1) io1 = {s1}\n  io_targets M1 (initial M1) io2 = {s2}\n\ngoal (1 subgoal):\n 1. B M1 io1 \\<Omega> = B M1 io2 \\<Omega>", "by auto"], ["proof (state)\nthis:\n  B M1 io1 \\<Omega> = B M1 io2 \\<Omega>\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) io1 \\<inter>\n    io_targets M1 (initial M1) io2 \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  B M1 io1 \\<Omega> = B M1 io2 \\<Omega>", "show \"False\""], ["proof (prove)\nusing this:\n  B M1 io1 \\<Omega> = B M1 io2 \\<Omega>\n\ngoal (1 subgoal):\n 1. False", "using assms(15-17) dist_prop shared_elem_def(1,2)"], ["proof (prove)\nusing this:\n  B M1 io1 \\<Omega> = B M1 io2 \\<Omega>\n  s1 \\<noteq> s2\n  s1 \\<in> S\n  s2 \\<in> S\n  \\<forall>s1\\<in>S.\n     \\<forall>s2\\<in>S.\n        s1 \\<noteq> s2 \\<longrightarrow>\n        (\\<forall>io1\\<in>RP M2 s1 vs xs V''.\n            \\<forall>io2\\<in>RP M2 s2 vs xs V''.\n               B M1 io1 \\<Omega> \\<noteq> B M1 io2 \\<Omega>)\n  io1 \\<in> RP M2 s1 vs xs V''\n  io2 \\<in> RP M2 s2 vs xs V''\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) io1 \\<inter> io_targets M1 (initial M1) io2 =\n  {}\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) io1 \\<inter> io_targets M1 (initial M1) io2 =\n  {}", "show \"False\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) io1 \\<inter> io_targets M1 (initial M1) io2 =\n  {}\n\ngoal (1 subgoal):\n 1. False", "using shared_elem_def(3,4)"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) io1 \\<inter> io_targets M1 (initial M1) io2 =\n  {}\n  t \\<in> io_targets M1 (initial M1) io1\n  t \\<in> io_targets M1 (initial M1) io2\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n  {}\n\ngoal (1 subgoal):\n 1. card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "ultimately"], ["proof (chain)\npicking this:\n  card (RP M2 s1 vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n  card (RP M2 s2 vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n  {}", "show \"card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'')\n       = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s1 vs xs V'')))\n          + card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s2 vs xs V'')))\""], ["proof (prove)\nusing this:\n  card (RP M2 s1 vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V''))\n  card (RP M2 s2 vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'') \\<inter>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V'') =\n  {}\n\ngoal (1 subgoal):\n 1. card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))", "by linarith"], ["proof (state)\nthis:\n  card (RP M2 s1 vs xs V'') + card (RP M2 s2 vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s1 vs xs V'')) +\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s2 vs xs V''))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LB_count_helper_RP_card_union :\n  assumes \"observable M2\"\n  and     \"s1 \\<noteq> s2\"\nshows \"RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' \\<noteq> {}\""], ["proof (state)\nthis:\n  RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' \\<noteq> {}", "obtain io where \"io \\<in> RP M2 s1 vs xs V'' \\<and> io \\<in> RP M2 s2 vs xs V''\""], ["proof (prove)\nusing this:\n  RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        io \\<in> RP M2 s1 vs xs V'' \\<and>\n        io \\<in> RP M2 s2 vs xs V'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  io \\<in> RP M2 s1 vs xs V'' \\<and> io \\<in> RP M2 s2 vs xs V''\n\ngoal (1 subgoal):\n 1. RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io \\<in> RP M2 s1 vs xs V'' \\<and> io \\<in> RP M2 s2 vs xs V''", "have \"s1 \\<in> io_targets M2 (initial M2) io\"\n            \"s2 \\<in> io_targets M2 (initial M2) io\""], ["proof (prove)\nusing this:\n  io \\<in> RP M2 s1 vs xs V'' \\<and> io \\<in> RP M2 s2 vs xs V''\n\ngoal (1 subgoal):\n 1. s1 \\<in> io_targets M2 (initial M2) io &&&\n    s2 \\<in> io_targets M2 (initial M2) io", "by auto"], ["proof (state)\nthis:\n  s1 \\<in> io_targets M2 (initial M2) io\n  s2 \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  s1 \\<in> io_targets M2 (initial M2) io\n  s2 \\<in> io_targets M2 (initial M2) io", "have \"s1 = s2\""], ["proof (prove)\nusing this:\n  s1 \\<in> io_targets M2 (initial M2) io\n  s2 \\<in> io_targets M2 (initial M2) io\n\ngoal (1 subgoal):\n 1. s1 = s2", "using assms(1)"], ["proof (prove)\nusing this:\n  s1 \\<in> io_targets M2 (initial M2) io\n  s2 \\<in> io_targets M2 (initial M2) io\n  observable M2\n\ngoal (1 subgoal):\n 1. s1 = s2", "by (metis observable_io_target_is_singleton singletonD)"], ["proof (state)\nthis:\n  s1 = s2\n\ngoal (1 subgoal):\n 1. RP M2 s1 vs xs V'' \\<inter> RP M2 s2 vs xs V'' \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  s1 = s2", "show \"False\""], ["proof (prove)\nusing this:\n  s1 = s2\n\ngoal (1 subgoal):\n 1. False", "using assms(2)"], ["proof (prove)\nusing this:\n  s1 = s2\n  s1 \\<noteq> s2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LB_count_helper_RP_inj :\nobtains f\nwhere \"\\<forall> q \\<in> (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)) .\n          f q \\<in> nodes M1\"\n      \"inj_on f (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<forall>q\\<in>\\<Union>s\\<in>S.\n                                   \\<Union>\n                                    (io_targets M1 (initial M1) `\n                                     RP M2 s vs xs V'').\n                    f q \\<in> nodes M1;\n         inj_on f\n          (\\<Union>s\\<in>S.\n              \\<Union>\n               (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<forall>q\\<in>\\<Union>s\\<in>S.\n                                   \\<Union>\n                                    (io_targets M1 (initial M1) `\n                                     RP M2 s vs xs V'').\n                    f q \\<in> nodes M1;\n         inj_on f\n          (\\<Union>s\\<in>S.\n              \\<Union>\n               (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?f =\n    \"\\<lambda> q . if (q \\<in> (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)))\n      then q\n      else (initial M1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<forall>q\\<in>\\<Union>s\\<in>S.\n                                   \\<Union>\n                                    (io_targets M1 (initial M1) `\n                                     RP M2 s vs xs V'').\n                    f q \\<in> nodes M1;\n         inj_on f\n          (\\<Union>s\\<in>S.\n              \\<Union>\n               (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)) \\<subseteq> nodes M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>s\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n    \\<subseteq> nodes M1", "by blast"], ["proof (state)\nthis:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<subseteq> nodes M1\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<forall>q\\<in>\\<Union>s\\<in>S.\n                                   \\<Union>\n                                    (io_targets M1 (initial M1) `\n                                     RP M2 s vs xs V'').\n                    f q \\<in> nodes M1;\n         inj_on f\n          (\\<Union>s\\<in>S.\n              \\<Union>\n               (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<subseteq> nodes M1", "have \"\\<forall> q \\<in> (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S)) .\n              ?f q \\<in> nodes M1\""], ["proof (prove)\nusing this:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<subseteq> nodes M1\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>\\<Union>s\\<in>S.\n                      \\<Union>\n                       (io_targets M1 (initial M1) ` RP M2 s vs xs V'').\n       (if q \\<in> (\\<Union>s\\<in>S.\n                       \\<Union>\n                        (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n        then q else initial M1)\n       \\<in> nodes M1", "by (metis Un_iff  sup.order_iff)"], ["proof (state)\nthis:\n  \\<forall>q\\<in>\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V'').\n     (if q \\<in> (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n      then q else initial M1)\n     \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<forall>q\\<in>\\<Union>s\\<in>S.\n                                   \\<Union>\n                                    (io_targets M1 (initial M1) `\n                                     RP M2 s vs xs V'').\n                    f q \\<in> nodes M1;\n         inj_on f\n          (\\<Union>s\\<in>S.\n              \\<Union>\n               (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<forall>q\\<in>\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V'').\n     (if q \\<in> (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n      then q else initial M1)\n     \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<forall>q\\<in>\\<Union>s\\<in>S.\n                                   \\<Union>\n                                    (io_targets M1 (initial M1) `\n                                     RP M2 s vs xs V'').\n                    f q \\<in> nodes M1;\n         inj_on f\n          (\\<Union>s\\<in>S.\n              \\<Union>\n               (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"inj_on ?f (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1))\n                                                      (RP M2 s vs xs V''))) S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>q.\n         if q \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then q else initial M1)\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>s\\<in>S.\n                            \\<Union>\n                             (io_targets M1 (initial M1) `\n                              RP M2 s vs xs V''));\n        y \\<in> (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''));\n        (if x \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then x else initial M1) =\n        (if y \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then y else initial M1)\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>s\\<in>S.\n                            \\<Union>\n                             (io_targets M1 (initial M1) `\n                              RP M2 s vs xs V''));\n        y \\<in> (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''));\n        (if x \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then x else initial M1) =\n        (if y \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then y else initial M1)\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S))\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>s\\<in>S.\n                            \\<Union>\n                             (io_targets M1 (initial M1) `\n                              RP M2 s vs xs V''));\n        y \\<in> (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''));\n        (if x \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then x else initial M1) =\n        (if y \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then y else initial M1)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "have \"?f x = x\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (if x \\<in> (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n     then x else initial M1) =\n    x", "by presburger"], ["proof (state)\nthis:\n  (if x \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then x else initial M1) =\n  x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>s\\<in>S.\n                            \\<Union>\n                             (io_targets M1 (initial M1) `\n                              RP M2 s vs xs V''));\n        y \\<in> (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''));\n        (if x \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then x else initial M1) =\n        (if y \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then y else initial M1)\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>s\\<in>S.\n                            \\<Union>\n                             (io_targets M1 (initial M1) `\n                              RP M2 s vs xs V''));\n        y \\<in> (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''));\n        (if x \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then x else initial M1) =\n        (if y \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then y else initial M1)\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"y \\<in> (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S))\""], ["proof (state)\nthis:\n  y \\<in> (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>s\\<in>S.\n                            \\<Union>\n                             (io_targets M1 (initial M1) `\n                              RP M2 s vs xs V''));\n        y \\<in> (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''));\n        (if x \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then x else initial M1) =\n        (if y \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then y else initial M1)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  y \\<in> (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "have \"?f y = y\""], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (if y \\<in> (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n     then y else initial M1) =\n    y", "by presburger"], ["proof (state)\nthis:\n  (if y \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then y else initial M1) =\n  y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>s\\<in>S.\n                            \\<Union>\n                             (io_targets M1 (initial M1) `\n                              RP M2 s vs xs V''));\n        y \\<in> (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''));\n        (if x \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then x else initial M1) =\n        (if y \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then y else initial M1)\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"?f x = ?f y\""], ["proof (state)\nthis:\n  (if x \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then x else initial M1) =\n  (if y \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then y else initial M1)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>s\\<in>S.\n                            \\<Union>\n                             (io_targets M1 (initial M1) `\n                              RP M2 s vs xs V''));\n        y \\<in> (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''));\n        (if x \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then x else initial M1) =\n        (if y \\<in> (\\<Union>s\\<in>S.\n                        \\<Union>\n                         (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n         then y else initial M1)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  (if x \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then x else initial M1) =\n  (if y \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then y else initial M1)", "show \"x = y\""], ["proof (prove)\nusing this:\n  (if x \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then x else initial M1) =\n  (if y \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then y else initial M1)\n\ngoal (1 subgoal):\n 1. x = y", "using \\<open>?f x = x\\<close> \\<open>?f y = y\\<close>"], ["proof (prove)\nusing this:\n  (if x \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then x else initial M1) =\n  (if y \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then y else initial M1)\n  (if x \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then x else initial M1) =\n  x\n  (if y \\<in> (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   then y else initial M1) =\n  y\n\ngoal (1 subgoal):\n 1. x = y", "by presburger"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>q.\n       if q \\<in> (\\<Union>s\\<in>S.\n                      \\<Union>\n                       (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n       then q else initial M1)\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<forall>q\\<in>\\<Union>s\\<in>S.\n                                   \\<Union>\n                                    (io_targets M1 (initial M1) `\n                                     RP M2 s vs xs V'').\n                    f q \\<in> nodes M1;\n         inj_on f\n          (\\<Union>s\\<in>S.\n              \\<Union>\n               (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V'').\n     (if q \\<in> (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n      then q else initial M1)\n     \\<in> nodes M1\n  inj_on\n   (\\<lambda>q.\n       if q \\<in> (\\<Union>s\\<in>S.\n                      \\<Union>\n                       (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n       then q else initial M1)\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V'').\n     (if q \\<in> (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n      then q else initial M1)\n     \\<in> nodes M1\n  inj_on\n   (\\<lambda>q.\n       if q \\<in> (\\<Union>s\\<in>S.\n                      \\<Union>\n                       (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n       then q else initial M1)\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V'').\n     (if q \\<in> (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n      then q else initial M1)\n     \\<in> nodes M1\n  inj_on\n   (\\<lambda>q.\n       if q \\<in> (\\<Union>s\\<in>S.\n                      \\<Union>\n                       (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n       then q else initial M1)\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<lbrakk>\\<forall>q\\<in>\\<Union>s\\<in>S.\n                             \\<Union>\n                              (io_targets M1 (initial M1) `\n                               RP M2 s vs xs V'').\n              ?f q \\<in> nodes M1;\n   inj_on ?f\n    (\\<Union>s\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by presburger"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation (input) UNION :: \"'a set \\<Rightarrow> ('a \\<Rightarrow> 'b set) \\<Rightarrow> 'b set\"\n  where \"UNION A f \\<equiv> \\<Union> (f ` A)\""], ["", "lemma LB_count_helper_RP_card_union_sum :\n  assumes \"(vs @ xs) \\<in> L M2 \\<inter> L M1\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"asc_fault_domain M2 M1 m\"\n  and     \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"V'' \\<in> Perm V M1\"\n  and     \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and     \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and     \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"sum (\\<lambda> s . card (RP M2 s vs xs V'')) S\n        = sum (\\<lambda> s . card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "using assms"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M2 \\<inter> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      (\\<Sum>s\\<in>S.\n                         card\n                          (\\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V'')))", "have \"finite (nodes M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M2)", "using assms(3)"], ["proof (prove)\nusing this:\n  OFSM M2\n\ngoal (1 subgoal):\n 1. finite (nodes M2)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      (\\<Sum>s\\<in>S.\n                         card\n                          (\\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V'')))", "moreover"], ["proof (state)\nthis:\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      (\\<Sum>s\\<in>S.\n                         card\n                          (\\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V'')))", "have \"S \\<subseteq> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> nodes M2", "using assms(7)"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n\ngoal (1 subgoal):\n 1. S \\<subseteq> nodes M2", "by simp"], ["proof (state)\nthis:\n  S \\<subseteq> nodes M2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      (\\<Sum>s\\<in>S.\n                         card\n                          (\\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V'')))", "ultimately"], ["proof (chain)\npicking this:\n  finite (nodes M2)\n  S \\<subseteq> nodes M2", "have \"finite S\""], ["proof (prove)\nusing this:\n  finite (nodes M2)\n  S \\<subseteq> nodes M2\n\ngoal (1 subgoal):\n 1. finite S", "using infinite_super"], ["proof (prove)\nusing this:\n  finite (nodes M2)\n  S \\<subseteq> nodes M2\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. finite S", "by blast"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      (\\<Sum>s\\<in>S.\n                         card\n                          (\\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V'')))", "then"], ["proof (chain)\npicking this:\n  finite S", "have \"sum (\\<lambda> s . card (RP M2 s vs xs V'')) S\n              = sum (\\<lambda> s . card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))) S\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  vs @ xs \\<in> L M2 \\<inter> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "proof (induction S)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T {} \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>{}. card (RP M2 s vs xs V'')) =\n                      (\\<Sum>s\\<in>{}.\n                         card\n                          (\\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V'')))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "case empty"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M2 \\<inter> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T {} \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T {} \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>{}. card (RP M2 s vs xs V'')) =\n                      (\\<Sum>s\\<in>{}.\n                         card\n                          (\\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V'')))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>{}. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>{}.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>{}. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>{}.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "case (insert s S)"], ["proof (state)\nthis:\n  finite S\n  s \\<notin> S\n  \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n   asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n   V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n   \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                    (\\<Sum>s\\<in>S.\n                       card\n                        (\\<Union>\n                          (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n  vs @ xs \\<in> L M2 \\<inter> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T (insert s S) \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "have \"(insert s S) \\<subseteq> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert s S \\<subseteq> nodes M2", "using insert.prems(7)"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T (insert s S) \\<Omega> V''\n\ngoal (1 subgoal):\n 1. insert s S \\<subseteq> nodes M2", "by simp"], ["proof (state)\nthis:\n  insert s S \\<subseteq> nodes M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "then"], ["proof (chain)\npicking this:\n  insert s S \\<subseteq> nodes M2", "have \"s \\<in> nodes M2\""], ["proof (prove)\nusing this:\n  insert s S \\<subseteq> nodes M2\n\ngoal (1 subgoal):\n 1. s \\<in> nodes M2", "by simp"], ["proof (state)\nthis:\n  s \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "have \"Prereq M2 M1 vs xs T S \\<Omega> V''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prereq M2 M1 vs xs T S \\<Omega> V''", "using \\<open>Prereq M2 M1 vs xs T (insert s S) \\<Omega> V''\\<close>"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T (insert s S) \\<Omega> V''\n\ngoal (1 subgoal):\n 1. Prereq M2 M1 vs xs T S \\<Omega> V''", "by simp"], ["proof (state)\nthis:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "then"], ["proof (chain)\npicking this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''", "have \"(\\<Sum>s\\<in>S. card (RP M2 s vs xs V''))\n                = (\\<Sum>s\\<in>S. card (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a))\""], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "using insert.IH[OF insert.prems(1-6) _ assms(8,9)]"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  Prereq M2 M1 vs xs T S \\<Omega> V'' \\<Longrightarrow>\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "by metis"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "have \"(\\<Sum>s'\\<in>(insert s S). card (RP M2 s' vs xs V''))\n                    = (\\<Sum>s'\\<in>S. card (RP M2 s' vs xs V'')) + card (RP M2 s vs xs V'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>insert s S. card (RP M2 s' vs xs V'')) =\n    (\\<Sum>s'\\<in>S. card (RP M2 s' vs xs V'')) + card (RP M2 s vs xs V'')", "by (simp add: add.commute insert.hyps(1) insert.hyps(2))"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>insert s S. card (RP M2 s' vs xs V'')) =\n  (\\<Sum>s'\\<in>S. card (RP M2 s' vs xs V'')) + card (RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n  (\\<Sum>s'\\<in>insert s S. card (RP M2 s' vs xs V'')) =\n  (\\<Sum>s'\\<in>S. card (RP M2 s' vs xs V'')) + card (RP M2 s vs xs V'')", "have S_prop : \"(\\<Sum>s'\\<in>(insert s S). card (RP M2 s' vs xs V''))\n                               = (\\<Sum>s\\<in>S. card (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a))\n                                  + card (RP M2 s vs xs V'')\""], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n  (\\<Sum>s'\\<in>insert s S. card (RP M2 s' vs xs V'')) =\n  (\\<Sum>s'\\<in>S. card (RP M2 s' vs xs V'')) + card (RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>insert s S. card (RP M2 s' vs xs V'')) =\n    (\\<Sum>s\\<in>S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))) +\n    card (RP M2 s vs xs V'')", "by presburger"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>insert s S. card (RP M2 s' vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))) +\n  card (RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "have \"vs@xs \\<in> L M1 \\<inter> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M1 \\<inter> L M2", "using insert.prems(1)"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M2 \\<inter> L M1\n\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M1 \\<inter> L M2", "by simp"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "obtain q2 q1 tr where suffix_path : \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n                          \"path PM (xs || tr) (q2,q1)\"\n                          \"length xs = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using productF_language_state_intermediate[OF insert.prems(1)\n            test_tools_props(1)[OF insert.prems(5,4)] OFSM_props(2,1)[OF insert.prems(3)]\n                                    OFSM_props(2,1)[OF insert.prems(2)]]"], ["proof (prove)\nusing this:\n  (\\<And>q2 q1 tr.\n      \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n       path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "have \"card (RP M2 s vs xs V'')\n            = card (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (RP M2 s vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using OFSM_props(2,1)[OF insert.prems(3)] OFSM_props(2,1)[OF insert.prems(2)]\n            RP_count_alt_def[OF \\<open>vs@xs \\<in> L M1 \\<inter> L M2\\<close> _ _ _ _\n                                \\<open>s\\<in>nodes M2\\<close> test_tools_props(1)[OF insert.prems(5,4)]\n                                suffix_path insert.prems(8)\n                                test_tools_props(2)[OF insert.prems(5,4)] assms(6) insert.prems(9)]"], ["proof (prove)\nusing this:\n  observable M2\n  well_formed M2\n  observable M1\n  well_formed M1\n  \\<lbrakk>observable M1; observable M2; well_formed M1;\n   well_formed M2\\<rbrakk>\n  \\<Longrightarrow> card\n                     (\\<Union>\n                       (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n                    card (RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. card (RP M2 s vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by linarith"], ["proof (state)\nthis:\n  card (RP M2 s vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          (\\<Sum>s\\<in>F.\n                             card\n                              (\\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V'')));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         (\\<Sum>s\\<in>insert x F.\n                            card\n                             (\\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V'')))", "show \"(\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n                  (\\<Sum>s\\<in>insert s S. card (UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>insert s S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>insert s S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "have \"(\\<Sum>c\\<in>insert s S. card (UNION (RP M2 c vs xs V'') (io_targets M1 (initial M1))))\n            = card (UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))\n              + (\\<Sum>c\\<in>S. card (UNION (RP M2 c vs xs V'') (io_targets M1 (initial M1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>insert s S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V''))) =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n    (\\<Sum>c\\<in>S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')))", "by (meson insert.hyps(1) insert.hyps(2) sum.insert)"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>insert s S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V''))) =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n  (\\<Sum>c\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>insert s S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>c\\<in>insert s S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V''))) =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n  (\\<Sum>c\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>c\\<in>insert s S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V''))) =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n  (\\<Sum>c\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>insert s S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "using \\<open>(\\<Sum>s'\\<in>insert s S. card (RP M2 s' vs xs V''))\n                = (\\<Sum>s\\<in>S. card (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a))\n                    + card (RP M2 s vs xs V'')\\<close>\n              \\<open>card (RP M2 s vs xs V'')\n                = card (UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>c\\<in>insert s S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V''))) =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n  (\\<Sum>c\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')))\n  (\\<Sum>s'\\<in>insert s S. card (RP M2 s' vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))) +\n  card (RP M2 s vs xs V'')\n  card (RP M2 s vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>insert s S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "by presburger"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>insert s S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>insert s S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      (\\<Sum>s\\<in>S.\n                         card\n                          (\\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V'')))", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "using assms"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n  vs @ xs \\<in> L M2 \\<inter> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    (\\<Sum>s\\<in>S.\n       card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  (\\<Sum>s\\<in>S.\n     card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_insert_card :\n  assumes \"finite (\\<Union>SS)\"\n  and     \"finite S\"\n  and     \"S \\<inter> (\\<Union>SS) = {}\"\nshows \"card (\\<Union> (insert S SS)) = card (\\<Union>SS) + card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (insert S SS)) = card (\\<Union> SS) + card S", "by (simp add: assms(1) assms(2) assms(3) card_Un_disjoint)"], ["", "lemma LB_count_helper_RP_disjoint_M1_union :\n  assumes \"(vs @ xs) \\<in> L M2 \\<inter> L M1\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"asc_fault_domain M2 M1 m\"\n  and     \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"V'' \\<in> Perm V M1\"\n  and     \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and     \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and     \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"sum (\\<lambda> s . card (RP M2 s vs xs V'')) S\n        = card (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using assms"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M2 \\<inter> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      card\n                       (\\<Union>s\\<in>S.\n                           \\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V''))", "have \"finite (nodes M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M2)", "using assms(3)"], ["proof (prove)\nusing this:\n  OFSM M2\n\ngoal (1 subgoal):\n 1. finite (nodes M2)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      card\n                       (\\<Union>s\\<in>S.\n                           \\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V''))", "moreover"], ["proof (state)\nthis:\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      card\n                       (\\<Union>s\\<in>S.\n                           \\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V''))", "have \"S \\<subseteq> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> nodes M2", "using assms(7)"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n\ngoal (1 subgoal):\n 1. S \\<subseteq> nodes M2", "by simp"], ["proof (state)\nthis:\n  S \\<subseteq> nodes M2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      card\n                       (\\<Union>s\\<in>S.\n                           \\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V''))", "ultimately"], ["proof (chain)\npicking this:\n  finite (nodes M2)\n  S \\<subseteq> nodes M2", "have \"finite S\""], ["proof (prove)\nusing this:\n  finite (nodes M2)\n  S \\<subseteq> nodes M2\n\ngoal (1 subgoal):\n 1. finite S", "using infinite_super"], ["proof (prove)\nusing this:\n  finite (nodes M2)\n  S \\<subseteq> nodes M2\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. finite S", "by blast"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                      card\n                       (\\<Union>s\\<in>S.\n                           \\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V''))", "then"], ["proof (chain)\npicking this:\n  finite S", "show \"sum (\\<lambda> s . card (RP M2 s vs xs V'')) S\n              = card (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S))\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  vs @ xs \\<in> L M2 \\<inter> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "proof (induction S)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T {} \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>{}. card (RP M2 s vs xs V'')) =\n                      card\n                       (\\<Union>s\\<in>{}.\n                           \\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V''))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "case empty"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M2 \\<inter> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T {} \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n     asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n     V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T {} \\<Omega> V'';\n     \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>s\\<in>{}. card (RP M2 s vs xs V'')) =\n                      card\n                       (\\<Union>s\\<in>{}.\n                           \\<Union>\n                            (io_targets M1 (initial M1) `\n                             RP M2 s vs xs V''))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>{}. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>{}.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>{}. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>{}.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "case (insert s S)"], ["proof (state)\nthis:\n  finite S\n  s \\<notin> S\n  \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n   asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n   V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n   \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n                    card\n                     (\\<Union>s\\<in>S.\n                         \\<Union>\n                          (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  vs @ xs \\<in> L M2 \\<inter> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T (insert s S) \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "have \"(insert s S) \\<subseteq> nodes M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert s S \\<subseteq> nodes M2", "using insert.prems(7)"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T (insert s S) \\<Omega> V''\n\ngoal (1 subgoal):\n 1. insert s S \\<subseteq> nodes M2", "by simp"], ["proof (state)\nthis:\n  insert s S \\<subseteq> nodes M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "then"], ["proof (chain)\npicking this:\n  insert s S \\<subseteq> nodes M2", "have \"s \\<in> nodes M2\""], ["proof (prove)\nusing this:\n  insert s S \\<subseteq> nodes M2\n\ngoal (1 subgoal):\n 1. s \\<in> nodes M2", "by simp"], ["proof (state)\nthis:\n  s \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "have \"Prereq M2 M1 vs xs T S \\<Omega> V''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prereq M2 M1 vs xs T S \\<Omega> V''", "using \\<open>Prereq M2 M1 vs xs T (insert s S) \\<Omega> V''\\<close>"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T (insert s S) \\<Omega> V''\n\ngoal (1 subgoal):\n 1. Prereq M2 M1 vs xs T S \\<Omega> V''", "by simp"], ["proof (state)\nthis:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "then"], ["proof (chain)\npicking this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''", "have applied_IH : \"(\\<Sum>s\\<in>S. card (RP M2 s vs xs V''))\n                              = card (\\<Union>s\\<in>S. \\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\""], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using insert.IH[OF insert.prems(1-6) _ insert.prems(8,9)]"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  Prereq M2 M1 vs xs T S \\<Omega> V'' \\<Longrightarrow>\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by metis"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "obtain q2 q1 tr where suffix_path : \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n                              \"path PM (xs || tr) (q2,q1)\"\n                              \"length xs = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using productF_language_state_intermediate\n            [OF insert.prems(1) test_tools_props(1)[OF insert.prems(5,4)]\n                OFSM_props(2,1)[OF insert.prems(3)] OFSM_props(2,1)[OF insert.prems(2)]]"], ["proof (prove)\nusing this:\n  (\\<And>q2 q1 tr.\n      \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n       path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  io_targets PM (initial PM) vs = {(q2, q1)}\n  path PM (xs || tr) (q2, q1)\n  length xs = length tr\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "have \"s \\<in> insert s S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> insert s S", "by simp"], ["proof (state)\nthis:\n  s \\<in> insert s S\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "have \"vs@xs \\<in> L M1 \\<inter> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M1 \\<inter> L M2", "using insert.prems(1)"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M2 \\<inter> L M1\n\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M1 \\<inter> L M2", "by simp"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "have \"\\<forall> s' \\<in> S . (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\n                        \\<inter> (\\<Union>a\\<in>RP M2 s' vs xs V''. io_targets M1 (initial M1) a) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s'\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n       {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s'.\n       s' \\<in> S \\<Longrightarrow>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n       {}", "fix s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s'.\n       s' \\<in> S \\<Longrightarrow>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n       {}", "assume \"s' \\<in> S\""], ["proof (state)\nthis:\n  s' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       s' \\<in> S \\<Longrightarrow>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n       {}", "have \"s \\<noteq> s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> s'", "using insert.hyps(2) \\<open>s' \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<notin> S\n  s' \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<noteq> s'", "by blast"], ["proof (state)\nthis:\n  s \\<noteq> s'\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       s' \\<in> S \\<Longrightarrow>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n       {}", "have \"s' \\<in> insert s S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<in> insert s S", "using \\<open>s' \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s' \\<in> S\n\ngoal (1 subgoal):\n 1. s' \\<in> insert s S", "by simp"], ["proof (state)\nthis:\n  s' \\<in> insert s S\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       s' \\<in> S \\<Longrightarrow>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n       {}", "show \"(\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\n              \\<inter> (\\<Union>a\\<in>RP M2 s' vs xs V''. io_targets M1 (initial M1) a) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n    {}", "using OFSM_props(2,1)[OF assms(3)] OFSM_props(2,1,3)[OF assms(2)]\n              LB_count_helper_RP_disjoint_M1_pair(2)\n                [OF \\<open>vs@xs \\<in> L M1 \\<inter> L M2\\<close> _ _ _ _ test_tools_props(1)[OF insert.prems(5,4)]\n                    suffix_path insert.prems(8) test_tools_props(2)[OF insert.prems(5,4)]\n                    insert.prems(6,9,7) \\<open>s \\<noteq> s'\\<close> \\<open>s \\<in> insert s S\\<close> \\<open>s' \\<in> insert s S\\<close>\n                    test_tools_props(4)[OF insert.prems(5,4)]]"], ["proof (prove)\nusing this:\n  observable M2\n  well_formed M2\n  observable M1\n  well_formed M1\n  completely_specified M1\n  \\<lbrakk>observable M1; observable M2; well_formed M1; well_formed M2;\n   completely_specified M1\\<rbrakk>\n  \\<Longrightarrow> \\<Union>\n                     (io_targets M1 (initial M1) `\n                      RP M2 s vs xs V'') \\<inter>\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n                    {}\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n    {}", "by linarith"], ["proof (state)\nthis:\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s'\\<in>S.\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n     {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "then"], ["proof (chain)\npicking this:\n  \\<forall>s'\\<in>S.\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n     {}", "have disj_insert : \"(\\<Union>s\\<in>S. \\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\n                                \\<inter> (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a) = {}\""], ["proof (prove)\nusing this:\n  \\<forall>s'\\<in>S.\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'') =\n     {}\n\ngoal (1 subgoal):\n 1. (\\<Union>s\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<inter>\n    \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') =\n    {}", "by blast"], ["proof (state)\nthis:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<inter>\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "have finite_S : \"finite (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using RP_io_targets_finite_M1[OF insert.prems(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>observable M2; is_det_state_cover M1 ?V;\n   ?V'' \\<in> Perm ?V M2\\<rbrakk>\n  \\<Longrightarrow> finite\n                     (\\<Union>\n                       (io_targets M2 (initial M2) ` RP M1 ?s vs xs ?V''))\n\ngoal (1 subgoal):\n 1. finite (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by (meson RP_io_targets_finite_M1 \\<open>vs @ xs \\<in> L M1 \\<inter> L M2\\<close> assms(2) assms(5) insert.prems(6))"], ["proof (state)\nthis:\n  finite (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "have finite_s : \"finite (\\<Union>s\\<in>S. \\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by (meson RP_io_targets_finite_M1 \\<open>vs @ xs \\<in> L M1 \\<inter> L M2\\<close> assms(2) assms(5)\n          finite_UN_I insert.hyps(1) insert.prems(6))"], ["proof (state)\nthis:\n  finite\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "have \"card (\\<Union>s\\<in>insert s S. \\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\n          = card (\\<Union>s\\<in>S. \\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\n            + card (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "have f1: \"insert (UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))\n                    ((\\<lambda>c. UNION (RP M2 c vs xs V'') (io_targets M1 (initial M1))) ` S)\n                = (\\<lambda>c. UNION (RP M2 c vs xs V'') (io_targets M1 (initial M1))) ` insert s S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n     ((\\<lambda>c.\n          \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) `\n      S) =\n    (\\<lambda>c.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) `\n    insert s S", "by blast"], ["proof (state)\nthis:\n  insert (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   ((\\<lambda>c.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) `\n    S) =\n  (\\<lambda>c. \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) `\n  insert s S\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "have \"\\<forall>c. c \\<in> S \\<longrightarrow> UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))\n                          \\<inter> UNION (RP M2 c vs xs V'') (io_targets M1 (initial M1)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       c \\<in> S \\<longrightarrow>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'') =\n       {}", "by (meson \\<open>\\<forall>s'\\<in>S. (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\n                              \\<inter> (\\<Union>a\\<in>RP M2 s' vs xs V''. io_targets M1 (initial M1) a) = {}\\<close>)"], ["proof (state)\nthis:\n  \\<forall>c.\n     c \\<in> S \\<longrightarrow>\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'') =\n     {}\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "then"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     c \\<in> S \\<longrightarrow>\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'') =\n     {}", "have \"UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))\n                  \\<inter> (\\<Union>c\\<in>S. UNION (RP M2 c vs xs V'') (io_targets M1 (initial M1))) = {}\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     c \\<in> S \\<longrightarrow>\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n     \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'') =\n     {}\n\ngoal (1 subgoal):\n 1. \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n    (\\<Union>c\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) =\n    {}", "by blast"], ["proof (state)\nthis:\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n  (\\<Union>c\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) =\n  {}\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "then"], ["proof (chain)\npicking this:\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n  (\\<Union>c\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) =\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n  (\\<Union>c\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) =\n  {}\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using f1"], ["proof (prove)\nusing this:\n  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'') \\<inter>\n  (\\<Union>c\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) =\n  {}\n  insert (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n   ((\\<lambda>c.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) `\n    S) =\n  (\\<lambda>c. \\<Union> (io_targets M1 (initial M1) ` RP M2 c vs xs V'')) `\n  insert s S\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by (metis finite_S finite_insert_card finite_s)"], ["proof (state)\nthis:\n  card\n   (\\<Union>s\\<in>insert s S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   (\\<Union>s\\<in>insert s S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "have \"card (RP M2 s vs xs V'')\n          = card (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (RP M2 s vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using assms(2) assms(3)\n            RP_count_alt_def[OF \\<open>vs@xs \\<in> L M1 \\<inter> L M2\\<close> _ _ _ _ \\<open>s \\<in> nodes M2\\<close>\n                                test_tools_props(1)[OF insert.prems(5,4)] suffix_path\n                                insert.prems(8) test_tools_props(2)[OF insert.prems(5,4)]\n                                insert.prems(6,9)]"], ["proof (prove)\nusing this:\n  OFSM M1\n  OFSM M2\n  \\<lbrakk>observable M1; observable M2; well_formed M1;\n   well_formed M2\\<rbrakk>\n  \\<Longrightarrow> card\n                     (\\<Union>\n                       (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n                    card (RP M2 s vs xs V'')\n\ngoal (1 subgoal):\n 1. card (RP M2 s vs xs V'') =\n    card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by metis"], ["proof (state)\nthis:\n  card (RP M2 s vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T F \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>s\\<in>F. card (RP M2 s vs xs V'')) =\n                          card\n                           (\\<Union>s\\<in>F.\n                               \\<Union>\n                                (io_targets M1 (initial M1) `\n                                 RP M2 s vs xs V''));\n        vs @ xs \\<in> L M2 \\<inter> L M1; OFSM M1; OFSM M2;\n        asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n        V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T (insert x F) \\<Omega> V'';\n        \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s\\<in>insert x F.\n                            card (RP M2 s vs xs V'')) =\n                         card\n                          (\\<Union>s\\<in>insert x F.\n                              \\<Union>\n                               (io_targets M1 (initial M1) `\n                                RP M2 s vs xs V''))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "have \"(\\<Sum>c\\<in>insert s S. card (RP M2 c vs xs V''))\n              = card (RP M2 s vs xs V'') + (\\<Sum>c\\<in>S. card (RP M2 c vs xs V''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>insert s S. card (RP M2 c vs xs V'')) =\n    card (RP M2 s vs xs V'') + (\\<Sum>c\\<in>S. card (RP M2 c vs xs V''))", "by (meson insert.hyps(1) insert.hyps(2) sum.insert)"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>insert s S. card (RP M2 c vs xs V'')) =\n  card (RP M2 s vs xs V'') + (\\<Sum>c\\<in>S. card (RP M2 c vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>c\\<in>insert s S. card (RP M2 c vs xs V'')) =\n  card (RP M2 s vs xs V'') + (\\<Sum>c\\<in>S. card (RP M2 c vs xs V''))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>c\\<in>insert s S. card (RP M2 c vs xs V'')) =\n  card (RP M2 s vs xs V'') + (\\<Sum>c\\<in>S. card (RP M2 c vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using \\<open>card (RP M2 s vs xs V'')\n                = card (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\\<close>\n              \\<open>card (\\<Union>s\\<in>insert s S. \\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\n                = card (\\<Union>s\\<in>S. \\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\n                  + card (\\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a)\\<close> applied_IH"], ["proof (prove)\nusing this:\n  (\\<Sum>c\\<in>insert s S. card (RP M2 c vs xs V'')) =\n  card (RP M2 s vs xs V'') + (\\<Sum>c\\<in>S. card (RP M2 c vs xs V''))\n  card (RP M2 s vs xs V'') =\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  card\n   (\\<Union>s\\<in>insert s S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) +\n  card (\\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>insert s S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by presburger"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>insert s S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>insert s S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>insert s S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LB_count_helper_LB1 :\n  assumes \"(vs @ xs) \\<in> L M2 \\<inter> L M1\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"asc_fault_domain M2 M1 m\"\n  and     \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"V'' \\<in> Perm V M1\"\n  and     \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and     \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and     \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"(sum (\\<lambda> s . card (RP M2 s vs xs V'')) S) \\<le> card (nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) \\<le> |M1|", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) \\<le> |M1|", "have \"(\\<Union>s\\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1))) \\<subseteq> nodes M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>s\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n    \\<subseteq> nodes M1", "by blast"], ["proof (state)\nthis:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<subseteq> nodes M1\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) \\<le> |M1|", "moreover"], ["proof (state)\nthis:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<subseteq> nodes M1\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) \\<le> |M1|", "have \"finite (nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M1)", "using assms(2) OFSM_props(1)"], ["proof (prove)\nusing this:\n  OFSM M1\n  OFSM ?M \\<Longrightarrow> well_formed ?M\n\ngoal (1 subgoal):\n 1. finite (nodes M1)", "unfolding well_formed.simps finite_FSM.simps"], ["proof (prove)\nusing this:\n  ((finite (nodes M1) \\<and>\n    finite (inputs M1) \\<and> finite (outputs M1)) \\<and>\n   (\\<forall>s1 x y.\n       x \\<notin> inputs M1 \\<or> y \\<notin> outputs M1 \\<longrightarrow>\n       succ M1 (x, y) s1 = {}) \\<and>\n   inputs M1 \\<noteq> {} \\<and> outputs M1 \\<noteq> {}) \\<and>\n  observable M1 \\<and> completely_specified M1\n  ((finite (nodes ?M) \\<and>\n    finite (inputs ?M) \\<and> finite (outputs ?M)) \\<and>\n   (\\<forall>s1 x y.\n       x \\<notin> inputs ?M \\<or> y \\<notin> outputs ?M \\<longrightarrow>\n       succ ?M (x, y) s1 = {}) \\<and>\n   inputs ?M \\<noteq> {} \\<and> outputs ?M \\<noteq> {}) \\<and>\n  observable ?M \\<and> completely_specified ?M \\<Longrightarrow>\n  (finite (nodes ?M) \\<and>\n   finite (inputs ?M) \\<and> finite (outputs ?M)) \\<and>\n  (\\<forall>s1 x y.\n      x \\<notin> inputs ?M \\<or> y \\<notin> outputs ?M \\<longrightarrow>\n      succ ?M (x, y) s1 = {}) \\<and>\n  inputs ?M \\<noteq> {} \\<and> outputs ?M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite (nodes M1)", "by simp"], ["proof (state)\nthis:\n  finite (nodes M1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) \\<le> |M1|", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<subseteq> nodes M1\n  finite (nodes M1)", "have \"card (\\<Union>s\\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))\n                    \\<le> card (nodes M1)\""], ["proof (prove)\nusing this:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<subseteq> nodes M1\n  finite (nodes M1)\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n    \\<le> |M1|", "by (meson card_mono)"], ["proof (state)\nthis:\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<le> |M1|\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) \\<le> |M1|", "moreover"], ["proof (state)\nthis:\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<le> |M1|\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) \\<le> |M1|", "have \"(\\<Sum>s\\<in>S. card (RP M2 s vs xs V''))\n                    = card (\\<Union>s\\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using LB_count_helper_RP_disjoint_M1_union[OF assms]"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) \\<le> |M1|", "ultimately"], ["proof (chain)\npicking this:\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<le> |M1|\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "show ?thesis"], ["proof (prove)\nusing this:\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<le> |M1|\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) \\<le> |M1|", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) \\<le> |M1|\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LB_count_helper_D_states :\n  assumes \"observable M\"\n  and     \"RS \\<in> (D M T \\<Omega>)\"\nobtains q\nwhere \"q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"RS \\<in> image (\\<lambda> io . B M io \\<Omega>) (LS\\<^sub>i\\<^sub>n M (initial M) T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RS \\<in> (\\<lambda>io. B M io \\<Omega>) ` L\\<^sub>i\\<^sub>n M T", "using assms"], ["proof (prove)\nusing this:\n  observable M\n  RS \\<in> D M T \\<Omega>\n\ngoal (1 subgoal):\n 1. RS \\<in> (\\<lambda>io. B M io \\<Omega>) ` L\\<^sub>i\\<^sub>n M T", "by simp"], ["proof (state)\nthis:\n  RS \\<in> (\\<lambda>io. B M io \\<Omega>) ` L\\<^sub>i\\<^sub>n M T\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  RS \\<in> (\\<lambda>io. B M io \\<Omega>) ` L\\<^sub>i\\<^sub>n M T", "obtain io where \"RS = B M io \\<Omega>\" \"io \\<in> LS\\<^sub>i\\<^sub>n M (initial M) T\""], ["proof (prove)\nusing this:\n  RS \\<in> (\\<lambda>io. B M io \\<Omega>) ` L\\<^sub>i\\<^sub>n M T\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        \\<lbrakk>RS = B M io \\<Omega>;\n         io \\<in> L\\<^sub>i\\<^sub>n M T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  RS = B M io \\<Omega>\n  io \\<in> L\\<^sub>i\\<^sub>n M T\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  RS = B M io \\<Omega>\n  io \\<in> L\\<^sub>i\\<^sub>n M T", "have \"io \\<in> language_state M (initial M)\""], ["proof (prove)\nusing this:\n  RS = B M io \\<Omega>\n  io \\<in> L\\<^sub>i\\<^sub>n M T\n\ngoal (1 subgoal):\n 1. io \\<in> L M", "using language_state_for_inputs_in_language_state[of M \"initial M\" T]"], ["proof (prove)\nusing this:\n  RS = B M io \\<Omega>\n  io \\<in> L\\<^sub>i\\<^sub>n M T\n  L\\<^sub>i\\<^sub>n M T \\<subseteq> L M\n\ngoal (1 subgoal):\n 1. io \\<in> L M", "by blast"], ["proof (state)\nthis:\n  io \\<in> L M\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M", "obtain q where \"{q} = io_targets M (initial M) io\""], ["proof (prove)\nusing this:\n  io \\<in> L M\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        {q} = io_targets M (initial M) io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(1) io_targets_observable_singleton_ob)"], ["proof (state)\nthis:\n  {q} = io_targets M (initial M) io\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  {q} = io_targets M (initial M) io", "have \"B M io \\<Omega> = \\<Union> (image (\\<lambda> s . IO_set M s \\<Omega>) {q})\""], ["proof (prove)\nusing this:\n  {q} = io_targets M (initial M) io\n\ngoal (1 subgoal):\n 1. B M io \\<Omega> = (\\<Union>s\\<in>{q}. IO_set M s \\<Omega>)", "by simp"], ["proof (state)\nthis:\n  B M io \\<Omega> = (\\<Union>s\\<in>{q}. IO_set M s \\<Omega>)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  B M io \\<Omega> = (\\<Union>s\\<in>{q}. IO_set M s \\<Omega>)", "have \"B M io \\<Omega> = IO_set M q \\<Omega>\""], ["proof (prove)\nusing this:\n  B M io \\<Omega> = (\\<Union>s\\<in>{q}. IO_set M s \\<Omega>)\n\ngoal (1 subgoal):\n 1. B M io \\<Omega> = IO_set M q \\<Omega>", "by simp"], ["proof (state)\nthis:\n  B M io \\<Omega> = IO_set M q \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  B M io \\<Omega> = IO_set M q \\<Omega>", "have \"RS = IO_set M q \\<Omega>\""], ["proof (prove)\nusing this:\n  B M io \\<Omega> = IO_set M q \\<Omega>\n\ngoal (1 subgoal):\n 1. RS = IO_set M q \\<Omega>", "using \\<open>RS = B M io \\<Omega>\\<close>"], ["proof (prove)\nusing this:\n  B M io \\<Omega> = IO_set M q \\<Omega>\n  RS = B M io \\<Omega>\n\ngoal (1 subgoal):\n 1. RS = IO_set M q \\<Omega>", "by simp"], ["proof (state)\nthis:\n  RS = IO_set M q \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  RS = IO_set M q \\<Omega>\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"q \\<in> nodes M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> nodes M", "using \\<open>{q} = io_targets M (initial M) io\\<close>"], ["proof (prove)\nusing this:\n  {q} = io_targets M (initial M) io\n\ngoal (1 subgoal):\n 1. q \\<in> nodes M", "by (metis FSM.nodes.initial insertI1 io_targets_nodes)"], ["proof (state)\nthis:\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q \\<in> nodes M \\<and> RS = IO_set M q \\<Omega> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  RS = IO_set M q \\<Omega>\n  q \\<in> nodes M", "show ?thesis"], ["proof (prove)\nusing this:\n  RS = IO_set M q \\<Omega>\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  RS = IO_set M q \\<Omega>\n  q \\<in> nodes M\n  ?q \\<in> nodes M \\<and> RS = IO_set M ?q \\<Omega> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LB_count_helper_LB2 :\n  assumes \"observable M1\"\n  and     \"IO_set M1 q \\<Omega> \\<in> (D M1 T \\<Omega>) - {B M1 xs' \\<Omega> | xs' s' . s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\"\nshows \"q \\<notin> (\\<Union> (image (\\<lambda> s . \\<Union> (image (io_targets M1 (initial M1)) (RP M2 s vs xs V''))) S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<notin> (\\<Union>s\\<in>S.\n                   \\<Union>\n                    (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "assume \"q \\<in> (\\<Union>s\\<in>S. UNION (RP M2 s vs xs V'') (io_targets M1 (initial M1)))\""], ["proof (state)\nthis:\n  q \\<in> (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  q \\<in> (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "obtain s' where \"s' \\<in> S\" \"q \\<in> (\\<Union> (image (io_targets M1 (initial M1)) (RP M2 s' vs xs V'')))\""], ["proof (prove)\nusing this:\n  q \\<in> (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> S;\n         q \\<in> \\<Union>\n                  (io_targets M1 (initial M1) ` RP M2 s' vs xs V'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s' \\<in> S\n  q \\<in> \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'')\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  s' \\<in> S\n  q \\<in> \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'')", "obtain xs' where \"q \\<in> io_targets M1 (initial M1) xs'\" \"xs' \\<in> RP M2 s' vs xs V''\""], ["proof (prove)\nusing this:\n  s' \\<in> S\n  q \\<in> \\<Union> (io_targets M1 (initial M1) ` RP M2 s' vs xs V'')\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>q \\<in> io_targets M1 (initial M1) xs';\n         xs' \\<in> RP M2 s' vs xs V''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q \\<in> io_targets M1 (initial M1) xs'\n  xs' \\<in> RP M2 s' vs xs V''\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  q \\<in> io_targets M1 (initial M1) xs'\n  xs' \\<in> RP M2 s' vs xs V''", "have \"{q} = io_targets M1 (initial M1) xs'\""], ["proof (prove)\nusing this:\n  q \\<in> io_targets M1 (initial M1) xs'\n  xs' \\<in> RP M2 s' vs xs V''\n\ngoal (1 subgoal):\n 1. {q} = io_targets M1 (initial M1) xs'", "by (metis assms(1) observable_io_target_is_singleton)"], ["proof (state)\nthis:\n  {q} = io_targets M1 (initial M1) xs'\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  {q} = io_targets M1 (initial M1) xs'", "have \"B M1 xs' \\<Omega> = \\<Union> (image (\\<lambda> s . IO_set M1 s \\<Omega>) {q})\""], ["proof (prove)\nusing this:\n  {q} = io_targets M1 (initial M1) xs'\n\ngoal (1 subgoal):\n 1. B M1 xs' \\<Omega> = (\\<Union>s\\<in>{q}. IO_set M1 s \\<Omega>)", "by simp"], ["proof (state)\nthis:\n  B M1 xs' \\<Omega> = (\\<Union>s\\<in>{q}. IO_set M1 s \\<Omega>)\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  B M1 xs' \\<Omega> = (\\<Union>s\\<in>{q}. IO_set M1 s \\<Omega>)", "have \"B M1 xs' \\<Omega> = IO_set M1 q \\<Omega>\""], ["proof (prove)\nusing this:\n  B M1 xs' \\<Omega> = (\\<Union>s\\<in>{q}. IO_set M1 s \\<Omega>)\n\ngoal (1 subgoal):\n 1. B M1 xs' \\<Omega> = IO_set M1 q \\<Omega>", "by simp"], ["proof (state)\nthis:\n  B M1 xs' \\<Omega> = IO_set M1 q \\<Omega>\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  B M1 xs' \\<Omega> = IO_set M1 q \\<Omega>\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "have \"B M1 xs' \\<Omega> \\<in> {B M1 xs' \\<Omega> | xs' s' . s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B M1 xs' \\<Omega>\n    \\<in> {uu_.\n           \\<exists>xs' s'.\n              uu_ = B M1 xs' \\<Omega> \\<and>\n              s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "using \\<open>s' \\<in> S\\<close> \\<open>xs' \\<in> RP M2 s' vs xs V''\\<close>"], ["proof (prove)\nusing this:\n  s' \\<in> S\n  xs' \\<in> RP M2 s' vs xs V''\n\ngoal (1 subgoal):\n 1. B M1 xs' \\<Omega>\n    \\<in> {uu_.\n           \\<exists>xs' s'.\n              uu_ = B M1 xs' \\<Omega> \\<and>\n              s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "by blast"], ["proof (state)\nthis:\n  B M1 xs' \\<Omega>\n  \\<in> {uu_.\n         \\<exists>xs' s'.\n            uu_ = B M1 xs' \\<Omega> \\<and>\n            s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  B M1 xs' \\<Omega> = IO_set M1 q \\<Omega>\n  B M1 xs' \\<Omega>\n  \\<in> {uu_.\n         \\<exists>xs' s'.\n            uu_ = B M1 xs' \\<Omega> \\<and>\n            s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "have \"IO_set M1 q \\<Omega> \\<in> {B M1 xs' \\<Omega> | xs' s' . s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\""], ["proof (prove)\nusing this:\n  B M1 xs' \\<Omega> = IO_set M1 q \\<Omega>\n  B M1 xs' \\<Omega>\n  \\<in> {uu_.\n         \\<exists>xs' s'.\n            uu_ = B M1 xs' \\<Omega> \\<and>\n            s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. IO_set M1 q \\<Omega>\n    \\<in> {uu_.\n           \\<exists>xs' s'.\n              uu_ = B M1 xs' \\<Omega> \\<and>\n              s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "by blast"], ["proof (state)\nthis:\n  IO_set M1 q \\<Omega>\n  \\<in> {uu_.\n         \\<exists>xs' s'.\n            uu_ = B M1 xs' \\<Omega> \\<and>\n            s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  IO_set M1 q \\<Omega>\n  \\<in> {uu_.\n         \\<exists>xs' s'.\n            uu_ = B M1 xs' \\<Omega> \\<and>\n            s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "have \"IO_set M1 q \\<Omega> \\<notin> {B M1 xs' \\<Omega> | xs' s' . s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO_set M1 q \\<Omega>\n    \\<notin> {uu_.\n              \\<exists>xs' s'.\n                 uu_ = B M1 xs' \\<Omega> \\<and>\n                 s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "using assms(2)"], ["proof (prove)\nusing this:\n  IO_set M1 q \\<Omega>\n  \\<in> D M1 T \\<Omega> -\n        {uu_.\n         \\<exists>xs' s'.\n            uu_ = B M1 xs' \\<Omega> \\<and>\n            s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. IO_set M1 q \\<Omega>\n    \\<notin> {uu_.\n              \\<exists>xs' s'.\n                 uu_ = B M1 xs' \\<Omega> \\<and>\n                 s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "by blast"], ["proof (state)\nthis:\n  IO_set M1 q \\<Omega>\n  \\<notin> {uu_.\n            \\<exists>xs' s'.\n               uu_ = B M1 xs' \\<Omega> \\<and>\n               s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. q \\<in> (\\<Union>s\\<in>S.\n                \\<Union>\n                 (io_targets M1 (initial M1) `\n                  RP M2 s vs xs V'')) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  IO_set M1 q \\<Omega>\n  \\<in> {uu_.\n         \\<exists>xs' s'.\n            uu_ = B M1 xs' \\<Omega> \\<and>\n            s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n  IO_set M1 q \\<Omega>\n  \\<notin> {uu_.\n            \\<exists>xs' s'.\n               uu_ = B M1 xs' \\<Omega> \\<and>\n               s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "show \"False\""], ["proof (prove)\nusing this:\n  IO_set M1 q \\<Omega>\n  \\<in> {uu_.\n         \\<exists>xs' s'.\n            uu_ = B M1 xs' \\<Omega> \\<and>\n            s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n  IO_set M1 q \\<Omega>\n  \\<notin> {uu_.\n            \\<exists>xs' s'.\n               uu_ = B M1 xs' \\<Omega> \\<and>\n               s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Validity of the result of LB constituting a lower bound \\<close>"], ["", "lemma LB_count :\nassumes \"(vs @ xs) \\<in> L M1\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"asc_fault_domain M2 M1 m\"\n  and     \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"V'' \\<in> Perm V M1\"\n  and     \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and     \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and     \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\nshows \"LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "let ?D = \"D M1 T \\<Omega>\""], ["proof (state)\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "let ?B = \"{B M1 xs' \\<Omega> | xs' s' . s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\""], ["proof (state)\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "let ?DB = \"?D - ?B\""], ["proof (state)\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "let ?RP = \"\\<Union>s\\<in>S. \\<Union>a\\<in>RP M2 s vs xs V''. io_targets M1 (initial M1) a\""], ["proof (state)\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "have \"finite (nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M1)", "using OFSM_props[OF assms(2)]"], ["proof (prove)\nusing this:\n  well_formed M1\n  observable M1\n  completely_specified M1\n\ngoal (1 subgoal):\n 1. finite (nodes M1)", "unfolding well_formed.simps finite_FSM.simps"], ["proof (prove)\nusing this:\n  (finite (nodes M1) \\<and>\n   finite (inputs M1) \\<and> finite (outputs M1)) \\<and>\n  (\\<forall>s1 x y.\n      x \\<notin> inputs M1 \\<or> y \\<notin> outputs M1 \\<longrightarrow>\n      succ M1 (x, y) s1 = {}) \\<and>\n  inputs M1 \\<noteq> {} \\<and> outputs M1 \\<noteq> {}\n  observable M1\n  completely_specified M1\n\ngoal (1 subgoal):\n 1. finite (nodes M1)", "by simp"], ["proof (state)\nthis:\n  finite (nodes M1)\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "then"], ["proof (chain)\npicking this:\n  finite (nodes M1)", "have \"finite ?D\""], ["proof (prove)\nusing this:\n  finite (nodes M1)\n\ngoal (1 subgoal):\n 1. finite (D M1 T \\<Omega>)", "using OFSM_props[OF assms(2)] assms(7) D_bound[of M1 T \\<Omega>]"], ["proof (prove)\nusing this:\n  finite (nodes M1)\n  well_formed M1\n  observable M1\n  completely_specified M1\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  \\<lbrakk>well_formed M1; observable M1; finite T\\<rbrakk>\n  \\<Longrightarrow> finite (D M1 T \\<Omega>)\n  \\<lbrakk>well_formed M1; observable M1; finite T\\<rbrakk>\n  \\<Longrightarrow> card (D M1 T \\<Omega>) \\<le> |M1|\n\ngoal (1 subgoal):\n 1. finite (D M1 T \\<Omega>)", "unfolding Prereq.simps"], ["proof (prove)\nusing this:\n  finite (nodes M1)\n  well_formed M1\n  observable M1\n  completely_specified M1\n  finite T \\<and>\n  vs @ xs \\<in> L M2 \\<inter> L M1 \\<and>\n  S \\<subseteq> nodes M2 \\<and>\n  (\\<forall>s1\\<in>S.\n      \\<forall>s2\\<in>S.\n         s1 \\<noteq> s2 \\<longrightarrow>\n         (\\<forall>io1\\<in>RP M2 s1 vs xs V''.\n             \\<forall>io2\\<in>RP M2 s2 vs xs V''.\n                B M1 io1 \\<Omega> \\<noteq> B M1 io2 \\<Omega>))\n  \\<lbrakk>well_formed M1; observable M1; finite T\\<rbrakk>\n  \\<Longrightarrow> finite (D M1 T \\<Omega>)\n  \\<lbrakk>well_formed M1; observable M1; finite T\\<rbrakk>\n  \\<Longrightarrow> card (D M1 T \\<Omega>) \\<le> |M1|\n\ngoal (1 subgoal):\n 1. finite (D M1 T \\<Omega>)", "by linarith"], ["proof (state)\nthis:\n  finite (D M1 T \\<Omega>)\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "then"], ["proof (chain)\npicking this:\n  finite (D M1 T \\<Omega>)", "have \"finite ?DB\""], ["proof (prove)\nusing this:\n  finite (D M1 T \\<Omega>)\n\ngoal (1 subgoal):\n 1. finite\n     (D M1 T \\<Omega> -\n      {uu_.\n       \\<exists>xs' s'.\n          uu_ = B M1 xs' \\<Omega> \\<and>\n          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})", "by simp\n\n  \\<comment> \\<open>Proof sketch:\n      Construct a function f (via induction) that maps each response set in ?DB to some state\n      that produces that response set.\n      This is then used to show that each response sets in ?DB indicates the existence of\n      a distinct state in M1 not reached via the RP-sequences.\\<close>"], ["proof (state)\nthis:\n  finite\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "have states_f : \"\\<And> DB' . DB' \\<subseteq> ?DB \\<Longrightarrow> \\<exists> f . inj_on f DB'\n                                                \\<and> image f DB' \\<subseteq> (nodes M1) - ?RP\n                                                \\<and> (\\<forall> RS \\<in> DB' . IO_set M1 (f RS) \\<Omega> = RS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>DB'.\n       DB'\n       \\<subseteq> D M1 T \\<Omega> -\n                   {uu_.\n                    \\<exists>xs' s'.\n                       uu_ = B M1 xs' \\<Omega> \\<and>\n                       s' \\<in> S \\<and>\n                       xs' \\<in> RP M2 s' vs xs V''} \\<Longrightarrow>\n       \\<exists>f.\n          inj_on f DB' \\<and>\n          f ` DB'\n          \\<subseteq> nodes M1 -\n                      (\\<Union>s\\<in>S.\n                          \\<Union>\n                           (io_targets M1 (initial M1) `\n                            RP M2 s vs xs V'')) \\<and>\n          (\\<forall>RS\\<in>DB'. IO_set M1 (f RS) \\<Omega> = RS)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>DB'.\n       DB'\n       \\<subseteq> D M1 T \\<Omega> -\n                   {uu_.\n                    \\<exists>xs' s'.\n                       uu_ = B M1 xs' \\<Omega> \\<and>\n                       s' \\<in> S \\<and>\n                       xs' \\<in> RP M2 s' vs xs V''} \\<Longrightarrow>\n       \\<exists>f.\n          inj_on f DB' \\<and>\n          f ` DB'\n          \\<subseteq> nodes M1 -\n                      (\\<Union>s\\<in>S.\n                          \\<Union>\n                           (io_targets M1 (initial M1) `\n                            RP M2 s vs xs V'')) \\<and>\n          (\\<forall>RS\\<in>DB'. IO_set M1 (f RS) \\<Omega> = RS)", "fix DB'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>DB'.\n       DB'\n       \\<subseteq> D M1 T \\<Omega> -\n                   {uu_.\n                    \\<exists>xs' s'.\n                       uu_ = B M1 xs' \\<Omega> \\<and>\n                       s' \\<in> S \\<and>\n                       xs' \\<in> RP M2 s' vs xs V''} \\<Longrightarrow>\n       \\<exists>f.\n          inj_on f DB' \\<and>\n          f ` DB'\n          \\<subseteq> nodes M1 -\n                      (\\<Union>s\\<in>S.\n                          \\<Union>\n                           (io_targets M1 (initial M1) `\n                            RP M2 s vs xs V'')) \\<and>\n          (\\<forall>RS\\<in>DB'. IO_set M1 (f RS) \\<Omega> = RS)", "assume \"DB' \\<subseteq> ?DB\""], ["proof (state)\nthis:\n  DB'\n  \\<subseteq> D M1 T \\<Omega> -\n              {uu_.\n               \\<exists>xs' s'.\n                  uu_ = B M1 xs' \\<Omega> \\<and>\n                  s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. \\<And>DB'.\n       DB'\n       \\<subseteq> D M1 T \\<Omega> -\n                   {uu_.\n                    \\<exists>xs' s'.\n                       uu_ = B M1 xs' \\<Omega> \\<and>\n                       s' \\<in> S \\<and>\n                       xs' \\<in> RP M2 s' vs xs V''} \\<Longrightarrow>\n       \\<exists>f.\n          inj_on f DB' \\<and>\n          f ` DB'\n          \\<subseteq> nodes M1 -\n                      (\\<Union>s\\<in>S.\n                          \\<Union>\n                           (io_targets M1 (initial M1) `\n                            RP M2 s vs xs V'')) \\<and>\n          (\\<forall>RS\\<in>DB'. IO_set M1 (f RS) \\<Omega> = RS)", "have \"finite DB'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite DB'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite DB' \\<Longrightarrow> False", "assume \"infinite DB'\""], ["proof (state)\nthis:\n  infinite DB'\n\ngoal (1 subgoal):\n 1. infinite DB' \\<Longrightarrow> False", "have \"infinite ?DB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite\n     (D M1 T \\<Omega> -\n      {uu_.\n       \\<exists>xs' s'.\n          uu_ = B M1 xs' \\<Omega> \\<and>\n          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})", "using infinite_super[OF \\<open>DB' \\<subseteq> ?DB\\<close> \\<open>infinite DB'\\<close> ]"], ["proof (prove)\nusing this:\n  infinite\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n\ngoal (1 subgoal):\n 1. infinite\n     (D M1 T \\<Omega> -\n      {uu_.\n       \\<exists>xs' s'.\n          uu_ = B M1 xs' \\<Omega> \\<and>\n          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})", "by simp"], ["proof (state)\nthis:\n  infinite\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n\ngoal (1 subgoal):\n 1. infinite DB' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  infinite\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})", "show \"False\""], ["proof (prove)\nusing this:\n  infinite\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n\ngoal (1 subgoal):\n 1. False", "using \\<open>finite ?DB\\<close>"], ["proof (prove)\nusing this:\n  infinite\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n  finite\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite DB'\n\ngoal (1 subgoal):\n 1. \\<And>DB'.\n       DB'\n       \\<subseteq> D M1 T \\<Omega> -\n                   {uu_.\n                    \\<exists>xs' s'.\n                       uu_ = B M1 xs' \\<Omega> \\<and>\n                       s' \\<in> S \\<and>\n                       xs' \\<in> RP M2 s' vs xs V''} \\<Longrightarrow>\n       \\<exists>f.\n          inj_on f DB' \\<and>\n          f ` DB'\n          \\<subseteq> nodes M1 -\n                      (\\<Union>s\\<in>S.\n                          \\<Union>\n                           (io_targets M1 (initial M1) `\n                            RP M2 s vs xs V'')) \\<and>\n          (\\<forall>RS\\<in>DB'. IO_set M1 (f RS) \\<Omega> = RS)", "then"], ["proof (chain)\npicking this:\n  finite DB'", "show \"\\<exists> f . inj_on f DB' \\<and> image f DB' \\<subseteq> (nodes M1) - ?RP\n                                  \\<and> (\\<forall> RS \\<in> DB' . IO_set M1 (f RS) \\<Omega> = RS)\""], ["proof (prove)\nusing this:\n  finite DB'\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       inj_on f DB' \\<and>\n       f ` DB'\n       \\<subseteq> nodes M1 -\n                   (\\<Union>s\\<in>S.\n                       \\<Union>\n                        (io_targets M1 (initial M1) `\n                         RP M2 s vs xs V'')) \\<and>\n       (\\<forall>RS\\<in>DB'. IO_set M1 (f RS) \\<Omega> = RS)", "using assms \\<open>DB' \\<subseteq> ?DB\\<close>"], ["proof (prove)\nusing this:\n  finite DB'\n  vs @ xs \\<in> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n  DB'\n  \\<subseteq> D M1 T \\<Omega> -\n              {uu_.\n               \\<exists>xs' s'.\n                  uu_ = B M1 xs' \\<Omega> \\<and>\n                  s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       inj_on f DB' \\<and>\n       f ` DB'\n       \\<subseteq> nodes M1 -\n                   (\\<Union>s\\<in>S.\n                       \\<Union>\n                        (io_targets M1 (initial M1) `\n                         RP M2 s vs xs V'')) \\<and>\n       (\\<forall>RS\\<in>DB'. IO_set M1 (f RS) \\<Omega> = RS)", "proof (induction DB')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n     test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n     Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n     \\<not> Rep_Cov M2 M1 V'' vs xs;\n     {} \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         inj_on f {} \\<and>\n                         f ` {}\n                         \\<subseteq> nodes M1 -\n                                     (\\<Union>s\\<in>S.\n   \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                         (\\<forall>RS\\<in>{}.\n                             IO_set M1 (f RS) \\<Omega> = RS)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "case empty"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n  {} \\<subseteq> D M1 T \\<Omega> -\n                 {uu_.\n                  \\<exists>xs' s'.\n                     uu_ = B M1 xs' \\<Omega> \\<and>\n                     s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n     test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n     Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n     \\<not> Rep_Cov M2 M1 V'' vs xs;\n     {} \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         inj_on f {} \\<and>\n                         f ` {}\n                         \\<subseteq> nodes M1 -\n                                     (\\<Union>s\\<in>S.\n   \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                         (\\<forall>RS\\<in>{}.\n                             IO_set M1 (f RS) \\<Omega> = RS)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       inj_on f {} \\<and>\n       f ` {}\n       \\<subseteq> nodes M1 -\n                   (\\<Union>s\\<in>S.\n                       \\<Union>\n                        (io_targets M1 (initial M1) `\n                         RP M2 s vs xs V'')) \\<and>\n       (\\<forall>RS\\<in>{}. IO_set M1 (f RS) \\<Omega> = RS)", "by simp"], ["proof (state)\nthis:\n  \\<exists>f.\n     inj_on f {} \\<and>\n     f ` {}\n     \\<subseteq> nodes M1 -\n                 (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) `\n                       RP M2 s vs xs V'')) \\<and>\n     (\\<forall>RS\\<in>{}. IO_set M1 (f RS) \\<Omega> = RS)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "case (insert RS DB')"], ["proof (state)\nthis:\n  finite DB'\n  RS \\<notin> DB'\n  \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n   test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n   Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n   \\<not> Rep_Cov M2 M1 V'' vs xs;\n   DB'\n   \\<subseteq> D M1 T \\<Omega> -\n               {uu_.\n                \\<exists>xs' s'.\n                   uu_ = B M1 xs' \\<Omega> \\<and>\n                   s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       inj_on f DB' \\<and>\n                       f ` DB'\n                       \\<subseteq> nodes M1 -\n                                   (\\<Union>s\\<in>S.\n \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                       (\\<forall>RS\\<in>DB'. IO_set M1 (f RS) \\<Omega> = RS)\n  vs @ xs \\<in> L M1\n  OFSM M1\n  OFSM M2\n  asc_fault_domain M2 M1 m\n  test_tools M2 M1 FAIL PM V \\<Omega>\n  V'' \\<in> Perm V M1\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n  \\<not> Rep_Pre M2 M1 vs xs\n  \\<not> Rep_Cov M2 M1 V'' vs xs\n  insert RS DB'\n  \\<subseteq> D M1 T \\<Omega> -\n              {uu_.\n               \\<exists>xs' s'.\n                  uu_ = B M1 xs' \\<Omega> \\<and>\n                  s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "have \"DB' \\<subseteq> ?DB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DB'\n    \\<subseteq> D M1 T \\<Omega> -\n                {uu_.\n                 \\<exists>xs' s'.\n                    uu_ = B M1 xs' \\<Omega> \\<and>\n                    s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "using insert.prems(10)"], ["proof (prove)\nusing this:\n  insert RS DB'\n  \\<subseteq> D M1 T \\<Omega> -\n              {uu_.\n               \\<exists>xs' s'.\n                  uu_ = B M1 xs' \\<Omega> \\<and>\n                  s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. DB'\n    \\<subseteq> D M1 T \\<Omega> -\n                {uu_.\n                 \\<exists>xs' s'.\n                    uu_ = B M1 xs' \\<Omega> \\<and>\n                    s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "by blast"], ["proof (state)\nthis:\n  DB'\n  \\<subseteq> D M1 T \\<Omega> -\n              {uu_.\n               \\<exists>xs' s'.\n                  uu_ = B M1 xs' \\<Omega> \\<and>\n                  s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "obtain f' where \"inj_on f' DB'\"\n                      \"image f' DB' \\<subseteq> (nodes M1) - ?RP\"\n                      \"\\<forall> RS \\<in> DB' . IO_set M1 (f' RS) \\<Omega> = RS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>inj_on f' DB';\n         f' ` DB'\n         \\<subseteq> nodes M1 -\n                     (\\<Union>s\\<in>S.\n                         \\<Union>\n                          (io_targets M1 (initial M1) ` RP M2 s vs xs V''));\n         \\<forall>RS\\<in>DB'. IO_set M1 (f' RS) \\<Omega> = RS\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert.IH[OF insert.prems(1-9) \\<open>DB' \\<subseteq> ?DB\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     inj_on f DB' \\<and>\n     f ` DB'\n     \\<subseteq> nodes M1 -\n                 (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) `\n                       RP M2 s vs xs V'')) \\<and>\n     (\\<forall>RS\\<in>DB'. IO_set M1 (f RS) \\<Omega> = RS)\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>inj_on f' DB';\n         f' ` DB'\n         \\<subseteq> nodes M1 -\n                     (\\<Union>s\\<in>S.\n                         \\<Union>\n                          (io_targets M1 (initial M1) ` RP M2 s vs xs V''));\n         \\<forall>RS\\<in>DB'. IO_set M1 (f' RS) \\<Omega> = RS\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inj_on f' DB'\n  f' ` DB'\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<forall>RS\\<in>DB'. IO_set M1 (f' RS) \\<Omega> = RS\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "have \"RS \\<in> D M1 T \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RS \\<in> D M1 T \\<Omega>", "using insert.prems(10)"], ["proof (prove)\nusing this:\n  insert RS DB'\n  \\<subseteq> D M1 T \\<Omega> -\n              {uu_.\n               \\<exists>xs' s'.\n                  uu_ = B M1 xs' \\<Omega> \\<and>\n                  s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. RS \\<in> D M1 T \\<Omega>", "by blast"], ["proof (state)\nthis:\n  RS \\<in> D M1 T \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "obtain q where \"q \\<in> nodes M1\" \"RS = IO_set M1 q \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> nodes M1; RS = IO_set M1 q \\<Omega>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert.prems(2)  LB_count_helper_D_states[OF _ \\<open>RS \\<in> D M1 T \\<Omega>\\<close>]"], ["proof (prove)\nusing this:\n  OFSM M1\n  \\<lbrakk>observable M1;\n   \\<And>q.\n      q \\<in> nodes M1 \\<and> RS = IO_set M1 q \\<Omega> \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> nodes M1; RS = IO_set M1 q \\<Omega>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q \\<in> nodes M1\n  RS = IO_set M1 q \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "then"], ["proof (chain)\npicking this:\n  q \\<in> nodes M1\n  RS = IO_set M1 q \\<Omega>", "have \"IO_set M1 q \\<Omega> \\<in> ?DB\""], ["proof (prove)\nusing this:\n  q \\<in> nodes M1\n  RS = IO_set M1 q \\<Omega>\n\ngoal (1 subgoal):\n 1. IO_set M1 q \\<Omega>\n    \\<in> D M1 T \\<Omega> -\n          {uu_.\n           \\<exists>xs' s'.\n              uu_ = B M1 xs' \\<Omega> \\<and>\n              s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "using insert.prems(10)"], ["proof (prove)\nusing this:\n  q \\<in> nodes M1\n  RS = IO_set M1 q \\<Omega>\n  insert RS DB'\n  \\<subseteq> D M1 T \\<Omega> -\n              {uu_.\n               \\<exists>xs' s'.\n                  uu_ = B M1 xs' \\<Omega> \\<and>\n                  s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. IO_set M1 q \\<Omega>\n    \\<in> D M1 T \\<Omega> -\n          {uu_.\n           \\<exists>xs' s'.\n              uu_ = B M1 xs' \\<Omega> \\<and>\n              s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "by blast"], ["proof (state)\nthis:\n  IO_set M1 q \\<Omega>\n  \\<in> D M1 T \\<Omega> -\n        {uu_.\n         \\<exists>xs' s'.\n            uu_ = B M1 xs' \\<Omega> \\<and>\n            s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "have \"q \\<notin> ?RP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<notin> (\\<Union>s\\<in>S.\n                   \\<Union>\n                    (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using insert.prems(2) LB_count_helper_LB2[OF _ \\<open>IO_set M1 q \\<Omega> \\<in> ?DB\\<close>]"], ["proof (prove)\nusing this:\n  OFSM M1\n  observable M1 \\<Longrightarrow>\n  q \\<notin> (\\<Union>s\\<in>S.\n                 \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. q \\<notin> (\\<Union>s\\<in>S.\n                   \\<Union>\n                    (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by blast"], ["proof (state)\nthis:\n  q \\<notin> (\\<Union>s\\<in>S.\n                 \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "let ?f = \"f'(RS := q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "have \"inj_on ?f (insert RS DB')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (f'(RS := q)) (insert RS DB')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (f'(RS := q)) DB' \\<and>\n    (f'(RS := q)) RS \\<notin> f'(RS := q) ` (DB' - {RS})", "have \"?f RS \\<notin> ?f ` (DB' - {RS})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f'(RS := q)) RS \\<notin> f'(RS := q) ` (DB' - {RS})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (f'(RS := q)) RS \\<in> f'(RS := q) ` (DB' - {RS}) \\<Longrightarrow>\n    False", "assume \"?f RS \\<in> ?f ` (DB' - {RS})\""], ["proof (state)\nthis:\n  (f'(RS := q)) RS \\<in> f'(RS := q) ` (DB' - {RS})\n\ngoal (1 subgoal):\n 1. (f'(RS := q)) RS \\<in> f'(RS := q) ` (DB' - {RS}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (f'(RS := q)) RS \\<in> f'(RS := q) ` (DB' - {RS})", "have \"q \\<in> ?f ` (DB' - {RS})\""], ["proof (prove)\nusing this:\n  (f'(RS := q)) RS \\<in> f'(RS := q) ` (DB' - {RS})\n\ngoal (1 subgoal):\n 1. q \\<in> f'(RS := q) ` (DB' - {RS})", "by auto"], ["proof (state)\nthis:\n  q \\<in> f'(RS := q) ` (DB' - {RS})\n\ngoal (1 subgoal):\n 1. (f'(RS := q)) RS \\<in> f'(RS := q) ` (DB' - {RS}) \\<Longrightarrow>\n    False", "have \"RS \\<in> DB'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "have \"\\<forall>P c f. \\<exists>Pa. ((c::'c) \\<notin> f ` P \\<or> (Pa::('a \\<times> 'b) list set) \\<in> P)\n                                \\<and> (c \\<notin> f ` P \\<or> f Pa = c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P c f.\n       \\<exists>Pa.\n          (c \\<notin> f ` P \\<or> Pa \\<in> P) \\<and>\n          (c \\<notin> f ` P \\<or> f Pa = c)", "by auto"], ["proof (state)\nthis:\n  \\<forall>P c f.\n     \\<exists>Pa.\n        (c \\<notin> f ` P \\<or> Pa \\<in> P) \\<and>\n        (c \\<notin> f ` P \\<or> f Pa = c)\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "moreover"], ["proof (state)\nthis:\n  \\<forall>P c f.\n     \\<exists>Pa.\n        (c \\<notin> f ` P \\<or> Pa \\<in> P) \\<and>\n        (c \\<notin> f ` P \\<or> f Pa = c)\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "{"], ["proof (state)\nthis:\n  \\<forall>P c f.\n     \\<exists>Pa.\n        (c \\<notin> f ` P \\<or> Pa \\<in> P) \\<and>\n        (c \\<notin> f ` P \\<or> f Pa = c)\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "assume \"q \\<notin> f' ` DB'\""], ["proof (state)\nthis:\n  q \\<notin> f' ` DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "moreover"], ["proof (state)\nthis:\n  q \\<notin> f' ` DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "{"], ["proof (state)\nthis:\n  q \\<notin> f' ` DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "assume \"q \\<notin> f'(RS := q) ` DB'\""], ["proof (state)\nthis:\n  q \\<notin> f'(RS := q) ` DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "then"], ["proof (chain)\npicking this:\n  q \\<notin> f'(RS := q) ` DB'", "have ?thesis"], ["proof (prove)\nusing this:\n  q \\<notin> f'(RS := q) ` DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "using \\<open>q \\<in> f'(RS := q) ` (DB' - {RS})\\<close>"], ["proof (prove)\nusing this:\n  q \\<notin> f'(RS := q) ` DB'\n  q \\<in> f'(RS := q) ` (DB' - {RS})\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "by blast"], ["proof (state)\nthis:\n  RS \\<in> DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "}"], ["proof (state)\nthis:\n  q \\<notin> f'(RS := q) ` DB' \\<Longrightarrow> RS \\<in> DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "ultimately"], ["proof (chain)\npicking this:\n  q \\<notin> f' ` DB'\n  q \\<notin> f'(RS := q) ` DB' \\<Longrightarrow> RS \\<in> DB'", "have ?thesis"], ["proof (prove)\nusing this:\n  q \\<notin> f' ` DB'\n  q \\<notin> f'(RS := q) ` DB' \\<Longrightarrow> RS \\<in> DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "by (metis fun_upd_image)"], ["proof (state)\nthis:\n  RS \\<in> DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "}"], ["proof (state)\nthis:\n  q \\<notin> f' ` DB' \\<Longrightarrow> RS \\<in> DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>P c f.\n     \\<exists>Pa.\n        (c \\<notin> f ` P \\<or> Pa \\<in> P) \\<and>\n        (c \\<notin> f ` P \\<or> f Pa = c)\n  q \\<notin> f' ` DB' \\<Longrightarrow> RS \\<in> DB'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>P c f.\n     \\<exists>Pa.\n        (c \\<notin> f ` P \\<or> Pa \\<in> P) \\<and>\n        (c \\<notin> f ` P \\<or> f Pa = c)\n  q \\<notin> f' ` DB' \\<Longrightarrow> RS \\<in> DB'\n\ngoal (1 subgoal):\n 1. RS \\<in> DB'", "by (metis (no_types) \\<open>RS = IO_set M1 q \\<Omega>\\<close> \\<open>\\<forall>RS\\<in>DB'. IO_set M1 (f' RS) \\<Omega> = RS\\<close>)"], ["proof (state)\nthis:\n  RS \\<in> DB'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  RS \\<in> DB'\n\ngoal (1 subgoal):\n 1. (f'(RS := q)) RS \\<in> f'(RS := q) ` (DB' - {RS}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  RS \\<in> DB'", "show \"False\""], ["proof (prove)\nusing this:\n  RS \\<in> DB'\n\ngoal (1 subgoal):\n 1. False", "using insert.hyps(2)"], ["proof (prove)\nusing this:\n  RS \\<in> DB'\n  RS \\<notin> DB'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f'(RS := q)) RS \\<notin> f'(RS := q) ` (DB' - {RS})\n\ngoal (1 subgoal):\n 1. inj_on (f'(RS := q)) DB' \\<and>\n    (f'(RS := q)) RS \\<notin> f'(RS := q) ` (DB' - {RS})", "then"], ["proof (chain)\npicking this:\n  (f'(RS := q)) RS \\<notin> f'(RS := q) ` (DB' - {RS})", "show \"inj_on ?f DB' \\<and> ?f RS \\<notin> ?f ` (DB' - {RS})\""], ["proof (prove)\nusing this:\n  (f'(RS := q)) RS \\<notin> f'(RS := q) ` (DB' - {RS})\n\ngoal (1 subgoal):\n 1. inj_on (f'(RS := q)) DB' \\<and>\n    (f'(RS := q)) RS \\<notin> f'(RS := q) ` (DB' - {RS})", "using \\<open>inj_on f' DB'\\<close> inj_on_fun_updI"], ["proof (prove)\nusing this:\n  (f'(RS := q)) RS \\<notin> f'(RS := q) ` (DB' - {RS})\n  inj_on f' DB'\n  \\<lbrakk>inj_on ?f ?A; ?y \\<notin> ?f ` ?A\\<rbrakk>\n  \\<Longrightarrow> inj_on (?f(?x := ?y)) ?A\n\ngoal (1 subgoal):\n 1. inj_on (f'(RS := q)) DB' \\<and>\n    (f'(RS := q)) RS \\<notin> f'(RS := q) ` (DB' - {RS})", "by fastforce"], ["proof (state)\nthis:\n  inj_on (f'(RS := q)) DB' \\<and>\n  (f'(RS := q)) RS \\<notin> f'(RS := q) ` (DB' - {RS})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (f'(RS := q)) (insert RS DB')\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "moreover"], ["proof (state)\nthis:\n  inj_on (f'(RS := q)) (insert RS DB')\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "have \"image ?f (insert RS DB') \\<subseteq> (nodes M1) - ?RP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f'(RS := q) ` insert RS DB'\n    \\<subseteq> nodes M1 -\n                (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f'(RS := q) ` insert RS DB'\n    \\<subseteq> nodes M1 -\n                (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "have \"image ?f {RS} = {q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f'(RS := q) ` {RS} = {q}", "by simp"], ["proof (state)\nthis:\n  f'(RS := q) ` {RS} = {q}\n\ngoal (1 subgoal):\n 1. f'(RS := q) ` insert RS DB'\n    \\<subseteq> nodes M1 -\n                (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "then"], ["proof (chain)\npicking this:\n  f'(RS := q) ` {RS} = {q}", "have \"image ?f {RS} \\<subseteq> (nodes M1) - ?RP\""], ["proof (prove)\nusing this:\n  f'(RS := q) ` {RS} = {q}\n\ngoal (1 subgoal):\n 1. f'(RS := q) ` {RS}\n    \\<subseteq> nodes M1 -\n                (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using \\<open>q \\<in> nodes M1\\<close> \\<open>q \\<notin> ?RP\\<close>"], ["proof (prove)\nusing this:\n  f'(RS := q) ` {RS} = {q}\n  q \\<in> nodes M1\n  q \\<notin> (\\<Union>s\\<in>S.\n                 \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. f'(RS := q) ` {RS}\n    \\<subseteq> nodes M1 -\n                (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by auto"], ["proof (state)\nthis:\n  f'(RS := q) ` {RS}\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. f'(RS := q) ` insert RS DB'\n    \\<subseteq> nodes M1 -\n                (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "moreover"], ["proof (state)\nthis:\n  f'(RS := q) ` {RS}\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. f'(RS := q) ` insert RS DB'\n    \\<subseteq> nodes M1 -\n                (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "have \"image ?f (insert RS DB') = image ?f {RS} \\<union> image ?f DB'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f'(RS := q) ` insert RS DB' =\n    f'(RS := q) ` {RS} \\<union> f'(RS := q) ` DB'", "by auto"], ["proof (state)\nthis:\n  f'(RS := q) ` insert RS DB' =\n  f'(RS := q) ` {RS} \\<union> f'(RS := q) ` DB'\n\ngoal (1 subgoal):\n 1. f'(RS := q) ` insert RS DB'\n    \\<subseteq> nodes M1 -\n                (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "ultimately"], ["proof (chain)\npicking this:\n  f'(RS := q) ` {RS}\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  f'(RS := q) ` insert RS DB' =\n  f'(RS := q) ` {RS} \\<union> f'(RS := q) ` DB'", "show ?thesis"], ["proof (prove)\nusing this:\n  f'(RS := q) ` {RS}\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  f'(RS := q) ` insert RS DB' =\n  f'(RS := q) ` {RS} \\<union> f'(RS := q) ` DB'\n\ngoal (1 subgoal):\n 1. f'(RS := q) ` insert RS DB'\n    \\<subseteq> nodes M1 -\n                (\\<Union>s\\<in>S.\n                    \\<Union>\n                     (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by (metis (no_types, lifting) \\<open>image f' DB' \\<subseteq> (nodes M1) - ?RP\\<close> fun_upd_other image_cong\n              image_insert insert.hyps(2) insert_subset)"], ["proof (state)\nthis:\n  f'(RS := q) ` insert RS DB'\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f'(RS := q) ` insert RS DB'\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "moreover"], ["proof (state)\nthis:\n  f'(RS := q) ` insert RS DB'\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "have \"\\<forall> RS \\<in> (insert RS DB') . IO_set M1 (?f RS) \\<Omega> = RS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>RSa\\<in>insert RS DB'.\n       IO_set M1 ((f'(RS := q)) RSa) \\<Omega> = RSa", "using \\<open>RS = IO_set M1 q \\<Omega>\\<close> \\<open>\\<forall>RS\\<in>DB'. IO_set M1 (f' RS) \\<Omega> = RS\\<close>"], ["proof (prove)\nusing this:\n  RS = IO_set M1 q \\<Omega>\n  \\<forall>RS\\<in>DB'. IO_set M1 (f' RS) \\<Omega> = RS\n\ngoal (1 subgoal):\n 1. \\<forall>RSa\\<in>insert RS DB'.\n       IO_set M1 ((f'(RS := q)) RSa) \\<Omega> = RSa", "by auto"], ["proof (state)\nthis:\n  \\<forall>RSa\\<in>insert RS DB'.\n     IO_set M1 ((f'(RS := q)) RSa) \\<Omega> = RSa\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>vs @ xs \\<in> L M1; OFSM M1; OFSM M2;\n         asc_fault_domain M2 M1 m; test_tools M2 M1 FAIL PM V \\<Omega>;\n         V'' \\<in> Perm V M1; Prereq M2 M1 vs xs T S \\<Omega> V'';\n         \\<not> Rep_Pre M2 M1 vs xs; \\<not> Rep_Cov M2 M1 V'' vs xs;\n         F \\<subseteq> D M1 T \\<Omega> -\n                       {uu_.\n                        \\<exists>xs' s'.\n                           uu_ = B M1 xs' \\<Omega> \\<and>\n                           s' \\<in> S \\<and>\n                           xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>f.\n                             inj_on f F \\<and>\n                             f ` F\n                             \\<subseteq> nodes M1 -\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                             (\\<forall>RS\\<in>F.\n                                 IO_set M1 (f RS) \\<Omega> = RS);\n        vs @ xs \\<in> L M1; OFSM M1; OFSM M2; asc_fault_domain M2 M1 m;\n        test_tools M2 M1 FAIL PM V \\<Omega>; V'' \\<in> Perm V M1;\n        Prereq M2 M1 vs xs T S \\<Omega> V''; \\<not> Rep_Pre M2 M1 vs xs;\n        \\<not> Rep_Cov M2 M1 V'' vs xs;\n        insert x F\n        \\<subseteq> D M1 T \\<Omega> -\n                    {uu_.\n                     \\<exists>xs' s'.\n                        uu_ = B M1 xs' \\<Omega> \\<and>\n                        s' \\<in> S \\<and>\n                        xs' \\<in> RP M2 s' vs xs V''}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            inj_on f (insert x F) \\<and>\n                            f ` insert x F\n                            \\<subseteq> nodes M1 -\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')) \\<and>\n                            (\\<forall>RS\\<in>insert x F.\n                                IO_set M1 (f RS) \\<Omega> = RS)", "ultimately"], ["proof (chain)\npicking this:\n  inj_on (f'(RS := q)) (insert RS DB')\n  f'(RS := q) ` insert RS DB'\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<forall>RSa\\<in>insert RS DB'.\n     IO_set M1 ((f'(RS := q)) RSa) \\<Omega> = RSa", "show ?case"], ["proof (prove)\nusing this:\n  inj_on (f'(RS := q)) (insert RS DB')\n  f'(RS := q) ` insert RS DB'\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<forall>RSa\\<in>insert RS DB'.\n     IO_set M1 ((f'(RS := q)) RSa) \\<Omega> = RSa\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       inj_on f (insert RS DB') \\<and>\n       f ` insert RS DB'\n       \\<subseteq> nodes M1 -\n                   (\\<Union>s\\<in>S.\n                       \\<Union>\n                        (io_targets M1 (initial M1) `\n                         RP M2 s vs xs V'')) \\<and>\n       (\\<forall>RS\\<in>insert RS DB'. IO_set M1 (f RS) \\<Omega> = RS)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f.\n     inj_on f (insert RS DB') \\<and>\n     f ` insert RS DB'\n     \\<subseteq> nodes M1 -\n                 (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) `\n                       RP M2 s vs xs V'')) \\<and>\n     (\\<forall>RS\\<in>insert RS DB'. IO_set M1 (f RS) \\<Omega> = RS)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     inj_on f DB' \\<and>\n     f ` DB'\n     \\<subseteq> nodes M1 -\n                 (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) `\n                       RP M2 s vs xs V'')) \\<and>\n     (\\<forall>RS\\<in>DB'. IO_set M1 (f RS) \\<Omega> = RS)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?DB'\n  \\<subseteq> D M1 T \\<Omega> -\n              {uu_.\n               \\<exists>xs' s'.\n                  uu_ = B M1 xs' \\<Omega> \\<and>\n                  s' \\<in> S \\<and>\n                  xs' \\<in> RP M2 s' vs xs V''} \\<Longrightarrow>\n  \\<exists>f.\n     inj_on f ?DB' \\<and>\n     f ` ?DB'\n     \\<subseteq> nodes M1 -\n                 (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) `\n                       RP M2 s vs xs V'')) \\<and>\n     (\\<forall>RS\\<in>?DB'. IO_set M1 (f RS) \\<Omega> = RS)\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "have \"?DB \\<subseteq> ?DB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n    \\<subseteq> D M1 T \\<Omega> -\n                {uu_.\n                 \\<exists>xs' s'.\n                    uu_ = B M1 xs' \\<Omega> \\<and>\n                    s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}", "by simp"], ["proof (state)\nthis:\n  D M1 T \\<Omega> -\n  {uu_.\n   \\<exists>xs' s'.\n      uu_ = B M1 xs' \\<Omega> \\<and>\n      s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n  \\<subseteq> D M1 T \\<Omega> -\n              {uu_.\n               \\<exists>xs' s'.\n                  uu_ = B M1 xs' \\<Omega> \\<and>\n                  s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "obtain f where \"inj_on f ?DB\" \"image f ?DB \\<subseteq> (nodes M1) - ?RP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>inj_on f\n                  (D M1 T \\<Omega> -\n                   {uu_.\n                    \\<exists>xs' s'.\n                       uu_ = B M1 xs' \\<Omega> \\<and>\n                       s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''});\n         f `\n         (D M1 T \\<Omega> -\n          {uu_.\n           \\<exists>xs' s'.\n              uu_ = B M1 xs' \\<Omega> \\<and>\n              s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n         \\<subseteq> nodes M1 -\n                     (\\<Union>s\\<in>S.\n                         \\<Union>\n                          (io_targets M1 (initial M1) `\n                           RP M2 s vs xs V''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using states_f[OF \\<open>?DB \\<subseteq> ?DB\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     inj_on f\n      (D M1 T \\<Omega> -\n       {uu_.\n        \\<exists>xs' s'.\n           uu_ = B M1 xs' \\<Omega> \\<and>\n           s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}) \\<and>\n     f `\n     (D M1 T \\<Omega> -\n      {uu_.\n       \\<exists>xs' s'.\n          uu_ = B M1 xs' \\<Omega> \\<and>\n          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n     \\<subseteq> nodes M1 -\n                 (\\<Union>s\\<in>S.\n                     \\<Union>\n                      (io_targets M1 (initial M1) `\n                       RP M2 s vs xs V'')) \\<and>\n     (\\<forall>RS\\<in>D M1 T \\<Omega> -\n                      {uu_.\n                       \\<exists>xs' s'.\n                          uu_ = B M1 xs' \\<Omega> \\<and>\n                          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''}.\n         IO_set M1 (f RS) \\<Omega> = RS)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>inj_on f\n                  (D M1 T \\<Omega> -\n                   {uu_.\n                    \\<exists>xs' s'.\n                       uu_ = B M1 xs' \\<Omega> \\<and>\n                       s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''});\n         f `\n         (D M1 T \\<Omega> -\n          {uu_.\n           \\<exists>xs' s'.\n              uu_ = B M1 xs' \\<Omega> \\<and>\n              s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n         \\<subseteq> nodes M1 -\n                     (\\<Union>s\\<in>S.\n                         \\<Union>\n                          (io_targets M1 (initial M1) `\n                           RP M2 s vs xs V''))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  inj_on f\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n  f `\n  (D M1 T \\<Omega> -\n   {uu_.\n    \\<exists>xs' s'.\n       uu_ = B M1 xs' \\<Omega> \\<and>\n       s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n  \\<subseteq> nodes M1 -\n              (\\<Union>s\\<in>S.\n                  \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "have \"finite (nodes M1 - ?RP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (nodes M1 -\n      (\\<Union>s\\<in>S.\n          \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "using \\<open>finite (nodes M1)\\<close>"], ["proof (prove)\nusing this:\n  finite (nodes M1)\n\ngoal (1 subgoal):\n 1. finite\n     (nodes M1 -\n      (\\<Union>s\\<in>S.\n          \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "by simp"], ["proof (state)\nthis:\n  finite\n   (nodes M1 -\n    (\\<Union>s\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "have \"card ?DB \\<le> card (nodes M1 - ?RP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (D M1 T \\<Omega> -\n      {uu_.\n       \\<exists>xs' s'.\n          uu_ = B M1 xs' \\<Omega> \\<and>\n          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n    \\<le> card\n           (nodes M1 -\n            (\\<Union>s\\<in>S.\n                \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "using card_inj_on_le[OF \\<open>inj_on f ?DB\\<close> \\<open>image f ?DB \\<subseteq> (nodes M1) - ?RP\\<close>\n                            \\<open>finite (nodes M1 - ?RP)\\<close>]"], ["proof (prove)\nusing this:\n  card\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n  \\<le> card\n         (nodes M1 -\n          (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal (1 subgoal):\n 1. card\n     (D M1 T \\<Omega> -\n      {uu_.\n       \\<exists>xs' s'.\n          uu_ = B M1 xs' \\<Omega> \\<and>\n          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n    \\<le> card\n           (nodes M1 -\n            (\\<Union>s\\<in>S.\n                \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))", "by assumption"], ["proof (state)\nthis:\n  card\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n  \\<le> card\n         (nodes M1 -\n          (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "have \"?RP \\<subseteq> nodes M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>s\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n    \\<subseteq> nodes M1", "by blast"], ["proof (state)\nthis:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<subseteq> nodes M1\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "then"], ["proof (chain)\npicking this:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<subseteq> nodes M1", "have \"card (nodes M1 - ?RP) = card (nodes M1) - card ?RP\""], ["proof (prove)\nusing this:\n  (\\<Union>s\\<in>S.\n      \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<subseteq> nodes M1\n\ngoal (1 subgoal):\n 1. card\n     (nodes M1 -\n      (\\<Union>s\\<in>S.\n          \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))) =\n    |M1| -\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by (meson \\<open>finite (nodes M1)\\<close> card_Diff_subset infinite_subset)"], ["proof (state)\nthis:\n  card\n   (nodes M1 -\n    (\\<Union>s\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))) =\n  |M1| -\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "then"], ["proof (chain)\npicking this:\n  card\n   (nodes M1 -\n    (\\<Union>s\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))) =\n  |M1| -\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "have \"card ?DB \\<le> card (nodes M1) - card ?RP\""], ["proof (prove)\nusing this:\n  card\n   (nodes M1 -\n    (\\<Union>s\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))) =\n  |M1| -\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. card\n     (D M1 T \\<Omega> -\n      {uu_.\n       \\<exists>xs' s'.\n          uu_ = B M1 xs' \\<Omega> \\<and>\n          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n    \\<le> |M1| -\n          card\n           (\\<Union>s\\<in>S.\n               \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using \\<open>card ?DB \\<le> card (nodes M1 - ?RP)\\<close>"], ["proof (prove)\nusing this:\n  card\n   (nodes M1 -\n    (\\<Union>s\\<in>S.\n        \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))) =\n  |M1| -\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  card\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n  \\<le> card\n         (nodes M1 -\n          (\\<Union>s\\<in>S.\n              \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V'')))\n\ngoal (1 subgoal):\n 1. card\n     (D M1 T \\<Omega> -\n      {uu_.\n       \\<exists>xs' s'.\n          uu_ = B M1 xs' \\<Omega> \\<and>\n          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n    \\<le> |M1| -\n          card\n           (\\<Union>s\\<in>S.\n               \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by linarith"], ["proof (state)\nthis:\n  card\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n  \\<le> |M1| -\n        card\n         (\\<Union>s\\<in>S.\n             \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "have \"vs @ xs \\<in> L M2 \\<inter> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M2 \\<inter> L M1", "using assms(7)"], ["proof (prove)\nusing this:\n  Prereq M2 M1 vs xs T S \\<Omega> V''\n\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M2 \\<inter> L M1", "by simp"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M2 \\<inter> L M1\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "have \"(sum (\\<lambda> s . card (RP M2 s vs xs V'')) S) = card ?RP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "using LB_count_helper_RP_disjoint_M1_union[OF \\<open>vs @ xs \\<in> L M2 \\<inter> L M1\\<close> assms(2-9)]"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n    card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "have \"card ?RP \\<le> card (nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n    \\<le> |M1|", "using card_mono[OF \\<open>finite (nodes M1)\\<close> \\<open>?RP \\<subseteq> nodes M1\\<close>]"], ["proof (prove)\nusing this:\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<le> |M1|\n\ngoal (1 subgoal):\n 1. card\n     (\\<Union>s\\<in>S.\n         \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n    \\<le> |M1|", "by assumption"], ["proof (state)\nthis:\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<le> |M1|\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<le> |M1|", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<le> |M1|\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "unfolding LB.simps"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<le> |M1|\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) +\n    card\n     (D M1 T \\<Omega> -\n      {uu_.\n       \\<exists>xs' s'.\n          uu_ = B M1 xs' \\<Omega> \\<and>\n          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n    \\<le> |M1|", "using \\<open>card ?DB \\<le> card (nodes M1) - card ?RP\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) =\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  card\n   (\\<Union>s\\<in>S.\n       \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n  \\<le> |M1|\n  card\n   (D M1 T \\<Omega> -\n    {uu_.\n     \\<exists>xs' s'.\n        uu_ = B M1 xs' \\<Omega> \\<and>\n        s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n  \\<le> |M1| -\n        card\n         (\\<Union>s\\<in>S.\n             \\<Union> (io_targets M1 (initial M1) ` RP M2 s vs xs V''))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S. card (RP M2 s vs xs V'')) +\n    card\n     (D M1 T \\<Omega> -\n      {uu_.\n       \\<exists>xs' s'.\n          uu_ = B M1 xs' \\<Omega> \\<and>\n          s' \\<in> S \\<and> xs' \\<in> RP M2 s' vs xs V''})\n    \\<le> |M1|", "by linarith"], ["proof (state)\nthis:\n  LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contradiction_via_LB :\nassumes \"(vs @ xs) \\<in> L M1\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"asc_fault_domain M2 M1 m\"\n  and     \"test_tools M2 M1 FAIL PM V \\<Omega>\"\n  and     \"V'' \\<in> Perm V M1\"\n  and     \"Prereq M2 M1 vs xs T S \\<Omega> V''\"\n  and     \"\\<not> Rep_Pre M2 M1 vs xs\"\n  and     \"\\<not> Rep_Cov M2 M1 V'' vs xs\"\n  and     \"LB M2 M1 vs xs T S \\<Omega> V'' > m\"\nshows  \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"LB M2 M1 vs xs T S \\<Omega> V'' \\<le> card (nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "using LB_count[OF assms(1-9)]"], ["proof (prove)\nusing this:\n  LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|\n\ngoal (1 subgoal):\n 1. LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|", "by assumption"], ["proof (state)\nthis:\n  LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|\n\ngoal (1 subgoal):\n 1. False", "have \"card (nodes M1) \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |M1| \\<le> m", "using assms(4)"], ["proof (prove)\nusing this:\n  asc_fault_domain M2 M1 m\n\ngoal (1 subgoal):\n 1. |M1| \\<le> m", "by auto"], ["proof (state)\nthis:\n  |M1| \\<le> m\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|\n  |M1| \\<le> m", "show \"False\""], ["proof (prove)\nusing this:\n  LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|\n  |M1| \\<le> m\n\ngoal (1 subgoal):\n 1. False", "using assms(10)"], ["proof (prove)\nusing this:\n  LB M2 M1 vs xs T S \\<Omega> V'' \\<le> |M1|\n  |M1| \\<le> m\n  m < LB M2 M1 vs xs T S \\<Omega> V''\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}