{"file_name": "/home/qj213/afp-2021-10-22/thys/Adaptive_State_Counting/FSM/FSM.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Adaptive_State_Counting", "problem_names": ["lemma states_alt_def: \"states r p = map snd r\"", "lemma trace_alt_def: \"trace r p = smap snd r\"", "lemma language_state_alt_def : \"LS M q = {io | io tr . path M (io || tr) q \\<and> length io = length tr}\"", "lemma language_state[intro]:\n  assumes \"path M (w || r) q\" \"length w = length r\"\n  shows \"w \\<in> LS M q\"", "lemma language_state_elim[elim]:\n  assumes \"w \\<in> LS M q\"\n  obtains r\n  where \"path M (w || r) q\" \"length w = length r\"", "lemma language_state_split:\n  assumes \"w1 @ w2 \\<in> LS M q\"\n  obtains tr1 tr2\n  where \"path M (w1 || tr1) q\" \"length w1 = length tr1\"\n        \"path M (w2 || tr2) (target (w1 || tr1) q)\" \"length w2 = length tr2\"", "lemma language_state_prefix :\n  assumes \"w1 @ w2 \\<in> LS M q\"\nshows \"w1 \\<in> LS M q\"", "lemma succ_nodes :\n  fixes A :: \"('a,'b,'c) FSM\"\n  and   w :: \"('a \\<times> 'b)\"\n  assumes \"q2 \\<in> succ A w q1\"\n  and     \"q1 \\<in> nodes A\"\nshows \"q2 \\<in> nodes A\"", "lemma states_target_index :\n  assumes \"i < length p\"\n  shows \"(states p q1) ! i = target (take (Suc i) p) q1\"", "lemma product_simps[simp]:\n  \"succ (product A B) a (p\\<^sub>1, p\\<^sub>2) = succ A a p\\<^sub>1 \\<times> succ B a p\\<^sub>2\"\n  \"inputs (product A B) = inputs A \\<union> inputs B\"\n  \"outputs (product A B) = outputs A \\<union> outputs B\"\n  \"initial (product A B) = (initial A, initial B)\"", "lemma product_target[simp]:\n  assumes \"length w = length r\\<^sub>1\" \"length r\\<^sub>1 = length r\\<^sub>2\"\n  shows \"target (w || r\\<^sub>1 || r\\<^sub>2) (p\\<^sub>1, p\\<^sub>2) = (target (w || r\\<^sub>1) p\\<^sub>1, target (w || r\\<^sub>2) p\\<^sub>2)\"", "lemma product_path[iff]:\n  assumes \"length w = length r\\<^sub>1\" \"length r\\<^sub>1 = length r\\<^sub>2\"\n  shows \"path (product A B) (w || r\\<^sub>1 || r\\<^sub>2) (p\\<^sub>1, p\\<^sub>2) \\<longleftrightarrow> path A (w || r\\<^sub>1) p\\<^sub>1 \\<and> path B (w || r\\<^sub>2) p\\<^sub>2\"", "lemma product_language_state[simp]: \"LS (product A B) (q1,q2) = LS A q1 \\<inter> LS B q2\"", "lemma product_nodes :\n  \"nodes (product A B) \\<subseteq> nodes A \\<times> nodes B\"", "lemma OFSM_props[elim!] :\n  assumes \"OFSM M\"\nshows \"well_formed M\" \n      \"observable M\" \n      \"completely_specified M\"", "lemma set_of_succs_finite :\n  assumes \"well_formed M\"\n  and     \"q \\<in> nodes M\"\nshows \"finite (succ M io q)\"", "lemma well_formed_path_io_containment : \n  assumes \"well_formed M\"\n  and     \"path M p q\"\nshows \"set (map fst p) \\<subseteq> (inputs M \\<times> outputs M)\"", "lemma path_input_containment :\n  assumes \"well_formed M\"\n  and     \"path M p q\"  \nshows \"set (map fst (map fst p)) \\<subseteq> inputs M\"", "lemma path_state_containment :\n  assumes \"path M p q\"\n  and     \"q \\<in> nodes M\"\nshows \"set (map snd p) \\<subseteq> nodes M\"", "lemma language_state_inputs :\n  assumes \"well_formed M\"\n  and     \"io \\<in> language_state M q\"\nshows \"set (map fst io) \\<subseteq> inputs M\"", "lemma set_of_paths_finite : \n  assumes \"well_formed M\"\n  and     \"q1 \\<in> nodes M\"\nshows \"finite { p . path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k }\"", "lemma non_distinct_duplicate_indices :\n  assumes \"\\<not> distinct xs\"\nshows \"\\<exists> i1 i2 . i1 \\<noteq> i2 \\<and> xs ! i1 = xs ! i2 \\<and> i1 \\<le> length xs \\<and> i2 \\<le> length xs\"", "lemma reaching_path_without_repetition :\n  assumes \"well_formed M\"\n  and     \"q2 \\<in> reachable M q1\"\n  and     \"q1 \\<in> nodes M\"\nshows \"\\<exists> p . path M p q1 \\<and> target p q1 = q2 \\<and> distinct (q1 # states p q1)\"", "lemma observable_path_unique[simp] :\n  assumes \"io \\<in> LS M q\"\n  and     \"observable M\"\n  and     \"path M (io || tr1) q\" \"length io = length tr1\"\n  and     \"path M (io || tr2) q\" \"length io = length tr2\"\nshows \"tr1 = tr2\"", "lemma observable_path_unique_ex[elim] : \n  assumes \"observable M\"\n  and     \"io \\<in> LS M q\"\nobtains tr \nwhere \"{ t . path M (io || t) q \\<and> length io = length t } = { tr }\"", "lemma well_formed_product[simp] :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\nshows \"well_formed (product M2 M1)\" (is \"well_formed ?PM\")", "lemma io_target_implies_L :\n  assumes \"q \\<in> io_targets M (initial M) io\"\n  shows \"io \\<in> L M\"", "lemma io_target_from_path :\n  assumes \"path M (w || tr) q\"\n  and     \"length w = length tr\"\nshows \"target (w || tr) q \\<in> io_targets M q w\"", "lemma io_targets_observable_singleton_ex :\n  assumes \"observable M\"\n  and     \"io \\<in> LS M q1\"\nshows \"\\<exists> q2 . io_targets M q1 io = { q2 }\"", "lemma io_targets_observable_singleton_ob :\n  assumes \"observable M\"\n  and     \"io \\<in> LS M q1\"\nobtains q2 \n  where \"io_targets M q1 io = { q2 }\"", "lemma io_targets_elim[elim] :\n  assumes \"p \\<in> io_targets M q io\"\nobtains tr \nwhere \"target (io || tr) q = p \\<and> path M (io || tr) q \\<and> length io = length tr\"", "lemma io_targets_reachable :\n  assumes \"q2 \\<in> io_targets M q1 io\"\n  shows \"q2 \\<in> reachable M q1\"", "lemma io_targets_nodes :\n  assumes \"q2 \\<in> io_targets M q1 io\"\n  and     \"q1 \\<in> nodes M\"\nshows \"q2 \\<in> nodes M\"", "lemma observable_io_targets_split :\n  assumes \"observable M\"\n  and \"io_targets M q1 (vs @ xs) = {q3}\"\n  and \"io_targets M q1 vs = {q2}\"\nshows \"io_targets M q2 xs = {q3}\"", "lemma observable_io_target_unique_target :\n  assumes \"observable M\"\n  and     \"io_targets M q1 io = {q2}\"\n  and     \"path M (io || tr) q1\"\n  and     \"length io = length tr\"\nshows \"target (io || tr) q1 = q2\"", "lemma target_in_states : \n  assumes \"length io = length tr\"\n  and     \"length io > 0\"\n  shows \"last (states (io || tr) q) = target (io || tr) q\"", "lemma target_alt_def :\n  assumes \"length io = length tr\"\n  shows \"length io = 0 \\<Longrightarrow> target (io || tr) q = q\"\n        \"length io > 0 \\<Longrightarrow> target (io || tr) q = last tr\"", "lemma obs_target_is_io_targets :\n  assumes \"observable M\"\n  and     \"path M (io || tr) q\"\n  and     \"length io = length tr\"\nshows \"io_targets M q io = {target (io || tr) q}\"", "lemma io_target_target :\n  assumes \"io_targets M q1 io = {q2}\"\n  and     \"path M (io || tr) q1\"\n  and     \"length io = length tr\"\nshows \"target (io || tr) q1 = q2\"", "lemma index_last_take :\n  assumes \"i < length xs\"\n  shows \"xs ! i = last (take (Suc i) xs)\"", "lemma path_last_io_target :\n  assumes \"path M (xs || tr) q\" \n  and     \"length xs = length tr\"\n  and     \"length xs > 0\"\nshows \"last tr \\<in> io_targets M q xs\"", "lemma path_prefix_io_targets :\n  assumes \"path M (xs || tr) q\" \n  and     \"length xs = length tr\"\n  and     \"length xs > 0\"\nshows \"last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)\"", "lemma states_index_io_target :\n  assumes \"i < length xs\"\n  and     \"path M (xs || tr) q\" \n  and     \"length xs = length tr\"\n  and     \"length xs > 0\"\nshows \"(states (xs || tr) q) ! i \\<in> io_targets M q (take (Suc i) xs)\"", "lemma observable_io_targets_append :\n  assumes \"observable M\"\n  and \"io_targets M q1 vs = {q2}\"\n  and \"io_targets M q2 xs = {q3}\"\nshows \"io_targets M q1 (vs@xs) = {q3}\"", "lemma io_path_states_prefix :\n  assumes \"observable M\"\n  and \"path M (io1 || tr1) q\"\n  and \"length tr1 = length io1\"\n  and \"path M (io2 || tr2) q\"\n  and \"length tr2 = length io2\"\n  and \"prefix io1 io2\"\nshows \"tr1 = take (length tr1) tr2\"", "lemma observable_io_targets_suffix :\n  assumes \"observable M\"\n  and \"io_targets M q1 vs = {q2}\"\n  and \"io_targets M q1 (vs@xs) = {q3}\"\nshows \"io_targets M q2 xs = {q3}\"", "lemma observable_io_target_is_singleton[simp] :\n  assumes \"observable M\"\n  and     \"p \\<in> io_targets M q io\"\nshows \"io_targets M q io = {p}\"", "lemma observable_path_prefix :\n  assumes \"observable M\"\n  and     \"path M (io || tr) q\"\n  and     \"length io = length tr\"\n  and     \"path M (ioP || trP) q\"\n  and     \"length ioP = length trP\"\n  and     \"prefix ioP io\" \nshows \"trP = take (length ioP) tr\"", "lemma io_targets_succ : \n  assumes \"q2 \\<in> io_targets M q1 [xy]\"\n  shows \"q2 \\<in> succ M xy q1\"", "lemma d_reaches_unique[elim] : \n  assumes \"d_reaches M p xs q1\"\n  and    \"d_reaches M p xs q2\"\nshows \"q1 = q2\"", "lemma d_reaches_unique_cases[simp] : \"{ q . d_reaches M (initial M) xs q } = {} \n                                      \\<or> (\\<exists> q2 . { q . d_reaches M (initial M) xs q } = { q2 })\"", "lemma d_reaches_unique_obtain[simp] :\n  assumes \"d_reaches M (initial M) xs q\"\nshows \"{ p . d_reaches M (initial M) xs p } = { q }\"", "lemma d_reaches_io_target :\n  assumes \"d_reaches M p xs q\"\n  and     \"length ys = length xs\"\nshows \"io_targets M p (xs || ys) \\<subseteq> {q}\"", "lemma d_reachable_reachable : \"d_reachable M p \\<subseteq> reachable M p\"", "lemma det_state_cover_ass_dist : \n  assumes \"is_det_state_cover_ass M f\"\n  and     \"s1 \\<in> d_reachable M (initial M)\"\n  and     \"s2 \\<in> d_reachable M (initial M)\"\n  and     \"s1 \\<noteq> s2\"\nshows \"\\<not>(d_reaches M (initial M) (f s2) s1)\"", "lemma det_state_cover_ass_diff :\n  assumes \"is_det_state_cover_ass M f\"\n  and     \"s1 \\<in> d_reachable M (initial M)\"\n  and     \"s2 \\<in> d_reachable M (initial M)\"\n  and     \"s1 \\<noteq> s2\"\nshows \"f s1 \\<noteq> f s2\"", "lemma det_state_cover_d_reachable[elim] :\n  assumes \"is_det_state_cover M V\"\n  and     \"v \\<in> V\"\nobtains q\nwhere \"d_reaches M (initial M) v q\"", "lemma det_state_cover_card[simp] :\n  assumes \"is_det_state_cover M V\"\n  and     \"finite (nodes M)\"\nshows   \"card (d_reachable M (initial M)) = card V\"", "lemma det_state_cover_finite :\n  assumes \"is_det_state_cover M V\"\n  and     \"finite (nodes M)\"\nshows \"finite V\"", "lemma det_state_cover_initial :\n  assumes \"is_det_state_cover M V\"\n  shows   \"[] \\<in> V\"", "lemma det_state_cover_empty : \n  assumes \"is_det_state_cover M V\"\n  shows \"[] \\<in> V\"", "lemma language_state_inclusion_of_state_reached_by_same_sequence : \n  assumes \"LS M1 q1 \\<subseteq> LS M2 q2\"\n  and     \"observable M1\"\n  and     \"observable M2\"\n  and     \"io_targets M1 q1 io = { q1t }\"\n  and     \"io_targets M2 q2 io = { q2t }\"\nshows \"LS M1 q1t \\<subseteq> LS M2 q2t\"", "lemma language_state_for_input_alt_def :\n  \"language_state_for_input M q xs = LS\\<^sub>i\\<^sub>n M q {xs}\"", "lemma language_state_for_inputs_alt_def :\n  \"LS\\<^sub>i\\<^sub>n M q ISeqs = \\<Union> (image (language_state_for_input M q) ISeqs)\"", "lemma language_state_for_inputs_in_language_state :\n  \"LS\\<^sub>i\\<^sub>n M q T \\<subseteq> language_state M q\"", "lemma language_state_for_inputs_map_fst :\n  assumes \"io \\<in> language_state M q\"\n  and     \"map fst io \\<in> T\"\nshows \"io \\<in> LS\\<^sub>i\\<^sub>n M q T\"", "lemma language_state_for_inputs_nonempty :\n  assumes \"set xs \\<subseteq> inputs M\"\n  and     \"completely_specified M\"\n  and     \"q \\<in> nodes M\"\nshows \"LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq> {}\"", "lemma language_state_for_inputs_map_fst_contained :\n  assumes \"vs \\<in> LS\\<^sub>i\\<^sub>n M q V\"\nshows \"map fst vs \\<in> V\"", "lemma language_state_for_inputs_empty : \n  assumes \"[] \\<in> V\"\n  shows \"[] \\<in> LS\\<^sub>i\\<^sub>n M q V\"", "lemma language_state_for_input_empty[simp] : \n  \"language_state_for_input M q [] = {[]}\"", "lemma language_state_for_input_take :\n  assumes \"io \\<in> language_state_for_input M q xs\"\nshows \"take n io \\<in> language_state_for_input M q (take n xs)\"", "lemma language_state_for_inputs_prefix :\n  assumes \"vs@xs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'@xs'}\"\n  and \"length vs = length vs'\"\nshows \"vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}\"", "lemma language_state_for_inputs_union : \n  shows \"LS\\<^sub>i\\<^sub>n M q T1 \\<union> LS\\<^sub>i\\<^sub>n M q T2 = LS\\<^sub>i\\<^sub>n M q (T1 \\<union> T2)\"", "lemma io_reduction_on_subset :\n  assumes \"io_reduction_on M1 T M2\"\n  and     \"T' \\<subseteq> T\"\nshows \"io_reduction_on M1 T' M2\"", "lemma sequence_to_failure_ob :\n  assumes \"\\<not> M1 \\<preceq> M2\"\n  and     \"well_formed M1\"\n  and     \"well_formed M2\"  \nobtains io\nwhere \"sequence_to_failure M1 M2 io\"", "lemma sequence_to_failure_succ :\n  assumes \"sequence_to_failure M1 M2 io\"\n  shows \"\\<forall> q \\<in> io_targets M2 (initial M2) (butlast io) . succ M2 (last io) q = {}\"", "lemma sequence_to_failure_non_nil : \n  assumes \"sequence_to_failure M1 M2 xs\"\n  shows \"xs \\<noteq> []\"", "lemma sequence_to_failure_from_arbitrary_failure :\n  assumes \"vs@xs \\<in> L M1 - L M2\"\n    and \"vs \\<in> L M2 \\<inter> L M1\"\nshows \"\\<exists> xs' . prefix xs' xs \\<and> sequence_to_failure M1 M2 (vs@xs')\"", "lemma sequence_to_failure_length :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"observable M1\"\n  and     \"observable M2\"\n  and     \"\\<not> M1 \\<preceq> M2\"\n  shows \"\\<exists> xs . sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|\"", "lemma minimal_sequence_to_failure_extending_det_state_cover_ob :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"observable M2\"\n  and     \"is_det_state_cover M2 V\"\n  and     \"\\<not> M1 \\<preceq> M2\"\nobtains vs xs\nwhere \"minimal_sequence_to_failure_extending V M1 M2 vs xs\"", "lemma mstfe_prefix_input_in_V :\n  assumes \"minimal_sequence_to_failure_extending V M1 M2 vs xs\"\n  shows \"(map fst vs) \\<in> V\"", "lemma product_suite_soundness :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"observable M1\"\n  and     \"observable M2\"\n  and     \"inputs M2 = inputs M1\"\n  and     \"|M1| \\<le> m \"\nshows     \"\\<not> M1 \\<preceq> M2 \\<longrightarrow> \\<not> M1 \\<preceq>\\<lbrakk>{xs . set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}\\<rbrakk> M2\" \n  (is \"\\<not> M1 \\<preceq> M2 \\<longrightarrow> \\<not> M1 \\<preceq>\\<lbrakk>?TS\\<rbrakk> M2\")", "lemma product_suite_completeness :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"observable M1\"\n  and     \"observable M2\"\n  and     \"inputs M2 = inputs M1\"\n  and     \"|M1| \\<le> m \"\nshows     \"M1 \\<preceq> M2 \\<longleftrightarrow> M1 \\<preceq>\\<lbrakk>{xs . set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}\\<rbrakk> M2\" \n  (is \"M1 \\<preceq> M2 \\<longleftrightarrow> M1 \\<preceq>\\<lbrakk>?TS\\<rbrakk> M2\")"], "translations": [["", "lemma states_alt_def: \"states r p = map snd r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states r p = map snd r", "by (induct r arbitrary: p) (auto)"], ["", "lemma trace_alt_def: \"trace r p = smap snd r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace r p = smap snd r", "by (coinduction arbitrary: r p) (auto)"], ["", "definition language_state :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \n                              \\<Rightarrow> ('in \\<times> 'out) list set\" (\"LS\") \n  where\n  \"language_state M q \\<equiv> {map fst r |r . path M r q}\""], ["", "text \\<open>\nThe language of an FSM is the language of its initial state.\n\\<close>"], ["", "abbreviation \"L M \\<equiv> LS M (initial M)\""], ["", "lemma language_state_alt_def : \"LS M q = {io | io tr . path M (io || tr) q \\<and> length io = length tr}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LS M q =\n    {uu_.\n     \\<exists>io tr.\n        uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LS M q =\n    {uu_.\n     \\<exists>io tr.\n        uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}", "have \"LS M q \\<subseteq> { io | io tr . path M  (io || tr) q \\<and> length io = length tr }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LS M q\n    \\<subseteq> {uu_.\n                 \\<exists>io tr.\n                    uu_ = io \\<and>\n                    path M (io || tr) q \\<and> length io = length tr}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LS M q \\<Longrightarrow>\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and> length io = length tr}", "fix xr"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LS M q \\<Longrightarrow>\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and> length io = length tr}", "assume xr_assm : \"xr \\<in> LS M q\""], ["proof (state)\nthis:\n  xr \\<in> LS M q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LS M q \\<Longrightarrow>\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and> length io = length tr}", "then"], ["proof (chain)\npicking this:\n  xr \\<in> LS M q", "obtain r where r_def : \"map fst r = xr\" \"path M r q\""], ["proof (prove)\nusing this:\n  xr \\<in> LS M q\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>map fst r = xr; path M r q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding language_state_def"], ["proof (prove)\nusing this:\n  xr \\<in> {map fst r |r. path M r q}\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>map fst r = xr; path M r q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  map fst r = xr\n  path M r q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LS M q \\<Longrightarrow>\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and> length io = length tr}", "then"], ["proof (chain)\npicking this:\n  map fst r = xr\n  path M r q", "obtain xs ys where xr_split : \"xr = xs || ys\" \n                                       \"length xs = length ys\" \n                                       \"length xs = length xr\""], ["proof (prove)\nusing this:\n  map fst r = xr\n  path M r q\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>xr = xs || ys; length xs = length ys;\n         length xs = length xr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_map zip_map_fst_snd)"], ["proof (state)\nthis:\n  xr = xs || ys\n  length xs = length ys\n  length xs = length xr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LS M q \\<Longrightarrow>\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and> length io = length tr}", "then"], ["proof (chain)\npicking this:\n  xr = xs || ys\n  length xs = length ys\n  length xs = length xr", "have \"(xs || ys) \\<in> { io | io tr . path M  (io || tr) q \\<and> length io = length tr }\""], ["proof (prove)\nusing this:\n  xr = xs || ys\n  length xs = length ys\n  length xs = length xr\n\ngoal (1 subgoal):\n 1. xs || ys\n    \\<in> {uu_.\n           \\<exists>io tr.\n              uu_ = io \\<and>\n              path M (io || tr) q \\<and> length io = length tr}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>xr = xs || ys; length xs = length ys;\n     length xs = length xr\\<rbrakk>\n    \\<Longrightarrow> xs || ys\n                      \\<in> {uu_.\n                             \\<exists>io tr.\n                                uu_ = io \\<and>\n                                path M (io || tr) q \\<and>\n                                length io = length tr}", "have f1: \"xs || ys = map fst r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs || ys = map fst r", "by (simp add: r_def(1) xr_split(1))"], ["proof (state)\nthis:\n  xs || ys = map fst r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xr = xs || ys; length xs = length ys;\n     length xs = length xr\\<rbrakk>\n    \\<Longrightarrow> xs || ys\n                      \\<in> {uu_.\n                             \\<exists>io tr.\n                                uu_ = io \\<and>\n                                path M (io || tr) q \\<and>\n                                length io = length tr}", "then"], ["proof (chain)\npicking this:\n  xs || ys = map fst r", "have f2: \"path M ((xs || ys) || take (min (length (xs || ys)) (length (map snd r))) \n                                                  (map snd r)) q\""], ["proof (prove)\nusing this:\n  xs || ys = map fst r\n\ngoal (1 subgoal):\n 1. path M\n     ((xs || ys) ||\n      take (min (length (xs || ys)) (length (map snd r))) (map snd r))\n     q", "by (simp add: r_def(2))"], ["proof (state)\nthis:\n  path M\n   ((xs || ys) ||\n    take (min (length (xs || ys)) (length (map snd r))) (map snd r))\n   q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xr = xs || ys; length xs = length ys;\n     length xs = length xr\\<rbrakk>\n    \\<Longrightarrow> xs || ys\n                      \\<in> {uu_.\n                             \\<exists>io tr.\n                                uu_ = io \\<and>\n                                path M (io || tr) q \\<and>\n                                length io = length tr}", "have \"length (xs || ys) = length \n                                  (take (min (length (xs || ys)) (length (map snd r))) (map snd r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (xs || ys) =\n    length (take (min (length (xs || ys)) (length (map snd r))) (map snd r))", "using f1"], ["proof (prove)\nusing this:\n  xs || ys = map fst r\n\ngoal (1 subgoal):\n 1. length (xs || ys) =\n    length (take (min (length (xs || ys)) (length (map snd r))) (map snd r))", "by force"], ["proof (state)\nthis:\n  length (xs || ys) =\n  length (take (min (length (xs || ys)) (length (map snd r))) (map snd r))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xr = xs || ys; length xs = length ys;\n     length xs = length xr\\<rbrakk>\n    \\<Longrightarrow> xs || ys\n                      \\<in> {uu_.\n                             \\<exists>io tr.\n                                uu_ = io \\<and>\n                                path M (io || tr) q \\<and>\n                                length io = length tr}", "then"], ["proof (chain)\npicking this:\n  length (xs || ys) =\n  length (take (min (length (xs || ys)) (length (map snd r))) (map snd r))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (xs || ys) =\n  length (take (min (length (xs || ys)) (length (map snd r))) (map snd r))\n\ngoal (1 subgoal):\n 1. xs || ys\n    \\<in> {uu_.\n           \\<exists>io tr.\n              uu_ = io \\<and>\n              path M (io || tr) q \\<and> length io = length tr}", "using f2"], ["proof (prove)\nusing this:\n  length (xs || ys) =\n  length (take (min (length (xs || ys)) (length (map snd r))) (map snd r))\n  path M\n   ((xs || ys) ||\n    take (min (length (xs || ys)) (length (map snd r))) (map snd r))\n   q\n\ngoal (1 subgoal):\n 1. xs || ys\n    \\<in> {uu_.\n           \\<exists>io tr.\n              uu_ = io \\<and>\n              path M (io || tr) q \\<and> length io = length tr}", "by blast"], ["proof (state)\nthis:\n  xs || ys\n  \\<in> {uu_.\n         \\<exists>io tr.\n            uu_ = io \\<and>\n            path M (io || tr) q \\<and> length io = length tr}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs || ys\n  \\<in> {uu_.\n         \\<exists>io tr.\n            uu_ = io \\<and>\n            path M (io || tr) q \\<and> length io = length tr}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LS M q \\<Longrightarrow>\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and> length io = length tr}", "then"], ["proof (chain)\npicking this:\n  xs || ys\n  \\<in> {uu_.\n         \\<exists>io tr.\n            uu_ = io \\<and>\n            path M (io || tr) q \\<and> length io = length tr}", "show \"xr \\<in> { io | io tr . path M  (io || tr) q \\<and> length io = length tr }\""], ["proof (prove)\nusing this:\n  xs || ys\n  \\<in> {uu_.\n         \\<exists>io tr.\n            uu_ = io \\<and>\n            path M (io || tr) q \\<and> length io = length tr}\n\ngoal (1 subgoal):\n 1. xr \\<in> {uu_.\n              \\<exists>io tr.\n                 uu_ = io \\<and>\n                 path M (io || tr) q \\<and> length io = length tr}", "using xr_split"], ["proof (prove)\nusing this:\n  xs || ys\n  \\<in> {uu_.\n         \\<exists>io tr.\n            uu_ = io \\<and>\n            path M (io || tr) q \\<and> length io = length tr}\n  xr = xs || ys\n  length xs = length ys\n  length xs = length xr\n\ngoal (1 subgoal):\n 1. xr \\<in> {uu_.\n              \\<exists>io tr.\n                 uu_ = io \\<and>\n                 path M (io || tr) q \\<and> length io = length tr}", "by metis"], ["proof (state)\nthis:\n  xr \\<in> {uu_.\n            \\<exists>io tr.\n               uu_ = io \\<and>\n               path M (io || tr) q \\<and> length io = length tr}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LS M q\n  \\<subseteq> {uu_.\n               \\<exists>io tr.\n                  uu_ = io \\<and>\n                  path M (io || tr) q \\<and> length io = length tr}\n\ngoal (1 subgoal):\n 1. LS M q =\n    {uu_.\n     \\<exists>io tr.\n        uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}", "moreover"], ["proof (state)\nthis:\n  LS M q\n  \\<subseteq> {uu_.\n               \\<exists>io tr.\n                  uu_ = io \\<and>\n                  path M (io || tr) q \\<and> length io = length tr}\n\ngoal (1 subgoal):\n 1. LS M q =\n    {uu_.\n     \\<exists>io tr.\n        uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}", "have \"{ io | io tr . path M  (io || tr) q \\<and> length io = length tr } \\<subseteq> LS M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>io tr.\n        uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}\n    \\<subseteq> LS M q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and>\n                   length io = length tr} \\<Longrightarrow>\n       x \\<in> LS M q", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and>\n                   length io = length tr} \\<Longrightarrow>\n       x \\<in> LS M q", "assume xs_assm : \"xs \\<in> { io | io tr . path M  (io || tr) q \\<and> length io = length tr }\""], ["proof (state)\nthis:\n  xs \\<in> {uu_.\n            \\<exists>io tr.\n               uu_ = io \\<and>\n               path M (io || tr) q \\<and> length io = length tr}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and>\n                   length io = length tr} \\<Longrightarrow>\n       x \\<in> LS M q", "then"], ["proof (chain)\npicking this:\n  xs \\<in> {uu_.\n            \\<exists>io tr.\n               uu_ = io \\<and>\n               path M (io || tr) q \\<and> length io = length tr}", "obtain ys where ys_def : \"path M (xs || ys) q\" \"length xs = length ys\""], ["proof (prove)\nusing this:\n  xs \\<in> {uu_.\n            \\<exists>io tr.\n               uu_ = io \\<and>\n               path M (io || tr) q \\<and> length io = length tr}\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>path M (xs || ys) q; length xs = length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M (xs || ys) q\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and>\n                   length io = length tr} \\<Longrightarrow>\n       x \\<in> LS M q", "then"], ["proof (chain)\npicking this:\n  path M (xs || ys) q\n  length xs = length ys", "have \"xs = map fst (xs || ys)\""], ["proof (prove)\nusing this:\n  path M (xs || ys) q\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. xs = map fst (xs || ys)", "by auto"], ["proof (state)\nthis:\n  xs = map fst (xs || ys)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {uu_.\n                \\<exists>io tr.\n                   uu_ = io \\<and>\n                   path M (io || tr) q \\<and>\n                   length io = length tr} \\<Longrightarrow>\n       x \\<in> LS M q", "then"], ["proof (chain)\npicking this:\n  xs = map fst (xs || ys)", "show \"xs \\<in> LS M q\""], ["proof (prove)\nusing this:\n  xs = map fst (xs || ys)\n\ngoal (1 subgoal):\n 1. xs \\<in> LS M q", "using ys_def"], ["proof (prove)\nusing this:\n  xs = map fst (xs || ys)\n  path M (xs || ys) q\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. xs \\<in> LS M q", "unfolding language_state_def"], ["proof (prove)\nusing this:\n  xs = map fst (xs || ys)\n  path M (xs || ys) q\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. xs \\<in> {map fst r |r. path M r q}", "by blast"], ["proof (state)\nthis:\n  xs \\<in> LS M q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>io tr.\n      uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}\n  \\<subseteq> LS M q\n\ngoal (1 subgoal):\n 1. LS M q =\n    {uu_.\n     \\<exists>io tr.\n        uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}", "ultimately"], ["proof (chain)\npicking this:\n  LS M q\n  \\<subseteq> {uu_.\n               \\<exists>io tr.\n                  uu_ = io \\<and>\n                  path M (io || tr) q \\<and> length io = length tr}\n  {uu_.\n   \\<exists>io tr.\n      uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}\n  \\<subseteq> LS M q", "show ?thesis"], ["proof (prove)\nusing this:\n  LS M q\n  \\<subseteq> {uu_.\n               \\<exists>io tr.\n                  uu_ = io \\<and>\n                  path M (io || tr) q \\<and> length io = length tr}\n  {uu_.\n   \\<exists>io tr.\n      uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}\n  \\<subseteq> LS M q\n\ngoal (1 subgoal):\n 1. LS M q =\n    {uu_.\n     \\<exists>io tr.\n        uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}", "by auto"], ["proof (state)\nthis:\n  LS M q =\n  {uu_.\n   \\<exists>io tr.\n      uu_ = io \\<and> path M (io || tr) q \\<and> length io = length tr}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma language_state[intro]:\n  assumes \"path M (w || r) q\" \"length w = length r\"\n  shows \"w \\<in> LS M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> LS M q", "using assms"], ["proof (prove)\nusing this:\n  path M (w || r) q\n  length w = length r\n\ngoal (1 subgoal):\n 1. w \\<in> LS M q", "unfolding language_state_def"], ["proof (prove)\nusing this:\n  path M (w || r) q\n  length w = length r\n\ngoal (1 subgoal):\n 1. w \\<in> {map fst r |r. path M r q}", "by force"], ["", "lemma language_state_elim[elim]:\n  assumes \"w \\<in> LS M q\"\n  obtains r\n  where \"path M (w || r) q\" \"length w = length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>path M (w || r) q; length w = length r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  w \\<in> LS M q\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>path M (w || r) q; length w = length r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding language_state_def"], ["proof (prove)\nusing this:\n  w \\<in> {map fst r |r. path M r q}\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>path M (w || r) q; length w = length r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force iff: split_zip_ex)"], ["", "lemma language_state_split:\n  assumes \"w1 @ w2 \\<in> LS M q\"\n  obtains tr1 tr2\n  where \"path M (w1 || tr1) q\" \"length w1 = length tr1\"\n        \"path M (w2 || tr2) (target (w1 || tr1) q)\" \"length w2 = length tr2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr1 tr2.\n        \\<lbrakk>path M (w1 || tr1) q; length w1 = length tr1;\n         path M (w2 || tr2) (target (w1 || tr1) q);\n         length w2 = length tr2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tr1 tr2.\n        \\<lbrakk>path M (w1 || tr1) q; length w1 = length tr1;\n         path M (w2 || tr2) (target (w1 || tr1) q);\n         length w2 = length tr2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain tr where tr_def : \"path M ((w1 @ w2) || tr) q\" \"length (w1 @ w2) = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>path M (w1 @ w2 || tr) q;\n         length (w1 @ w2) = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  w1 @ w2 \\<in> LS M q\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>path M (w1 @ w2 || tr) q;\n         length (w1 @ w2) = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path M (w1 @ w2 || tr) q\n  length (w1 @ w2) = length tr\n\ngoal (1 subgoal):\n 1. (\\<And>tr1 tr2.\n        \\<lbrakk>path M (w1 || tr1) q; length w1 = length tr1;\n         path M (w2 || tr2) (target (w1 || tr1) q);\n         length w2 = length tr2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?tr1 = \"take (length w1) tr\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tr1 tr2.\n        \\<lbrakk>path M (w1 || tr1) q; length w1 = length tr1;\n         path M (w2 || tr2) (target (w1 || tr1) q);\n         length w2 = length tr2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?tr2 = \"drop (length w1) tr\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tr1 tr2.\n        \\<lbrakk>path M (w1 || tr1) q; length w1 = length tr1;\n         path M (w2 || tr2) (target (w1 || tr1) q);\n         length w2 = length tr2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have tr_split : \"?tr1 @ ?tr2 = tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length w1) tr @ drop (length w1) tr = tr", "by auto"], ["proof (state)\nthis:\n  take (length w1) tr @ drop (length w1) tr = tr\n\ngoal (1 subgoal):\n 1. (\\<And>tr1 tr2.\n        \\<lbrakk>path M (w1 || tr1) q; length w1 = length tr1;\n         path M (w2 || tr2) (target (w1 || tr1) q);\n         length w2 = length tr2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  take (length w1) tr @ drop (length w1) tr = tr", "show ?thesis"], ["proof (prove)\nusing this:\n  take (length w1) tr @ drop (length w1) tr = tr\n\ngoal (1 subgoal):\n 1. thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take (length w1) tr @ drop (length w1) tr = tr \\<Longrightarrow> thesis", "have f1: \"length w1 + length w2 = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length w1 + length w2 = length tr", "using tr_def(2)"], ["proof (prove)\nusing this:\n  length (w1 @ w2) = length tr\n\ngoal (1 subgoal):\n 1. length w1 + length w2 = length tr", "by auto"], ["proof (state)\nthis:\n  length w1 + length w2 = length tr\n\ngoal (1 subgoal):\n 1. take (length w1) tr @ drop (length w1) tr = tr \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  length w1 + length w2 = length tr", "have f2: \"length w2 = length tr - length w1\""], ["proof (prove)\nusing this:\n  length w1 + length w2 = length tr\n\ngoal (1 subgoal):\n 1. length w2 = length tr - length w1", "by presburger"], ["proof (state)\nthis:\n  length w2 = length tr - length w1\n\ngoal (1 subgoal):\n 1. take (length w1) tr @ drop (length w1) tr = tr \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  length w2 = length tr - length w1", "have \"length w1 = length (take (length w1) tr)\""], ["proof (prove)\nusing this:\n  length w2 = length tr - length w1\n\ngoal (1 subgoal):\n 1. length w1 = length (take (length w1) tr)", "using f1"], ["proof (prove)\nusing this:\n  length w2 = length tr - length w1\n  length w1 + length w2 = length tr\n\ngoal (1 subgoal):\n 1. length w1 = length (take (length w1) tr)", "by (metis (no_types) tr_split diff_add_inverse2 length_append length_drop)"], ["proof (state)\nthis:\n  length w1 = length (take (length w1) tr)\n\ngoal (1 subgoal):\n 1. take (length w1) tr @ drop (length w1) tr = tr \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  length w1 = length (take (length w1) tr)", "show ?thesis"], ["proof (prove)\nusing this:\n  length w1 = length (take (length w1) tr)\n\ngoal (1 subgoal):\n 1. thesis", "using f2"], ["proof (prove)\nusing this:\n  length w1 = length (take (length w1) tr)\n  length w2 = length tr - length w1\n\ngoal (1 subgoal):\n 1. thesis", "by (metis (no_types) FSM.path_append_elim length_drop that tr_def(1) zip_append1)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma language_state_prefix :\n  assumes \"w1 @ w2 \\<in> LS M q\"\nshows \"w1 \\<in> LS M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<in> LS M q", "using assms"], ["proof (prove)\nusing this:\n  w1 @ w2 \\<in> LS M q\n\ngoal (1 subgoal):\n 1. w1 \\<in> LS M q", "by (meson language_state language_state_split)"], ["", "lemma succ_nodes :\n  fixes A :: \"('a,'b,'c) FSM\"\n  and   w :: \"('a \\<times> 'b)\"\n  assumes \"q2 \\<in> succ A w q1\"\n  and     \"q1 \\<in> nodes A\"\nshows \"q2 \\<in> nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<in> nodes A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q2 \\<in> nodes A", "obtain x y where \"w = (x,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. w = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  w = (x, y)\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes A", "then"], ["proof (chain)\npicking this:\n  w = (x, y)", "have \"q2 \\<in> successors A q1\""], ["proof (prove)\nusing this:\n  w = (x, y)\n\ngoal (1 subgoal):\n 1. q2 \\<in> successors A q1", "using assms"], ["proof (prove)\nusing this:\n  w = (x, y)\n  q2 \\<in> succ A w q1\n  q1 \\<in> nodes A\n\ngoal (1 subgoal):\n 1. q2 \\<in> successors A q1", "by auto"], ["proof (state)\nthis:\n  q2 \\<in> successors A q1\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes A", "then"], ["proof (chain)\npicking this:\n  q2 \\<in> successors A q1", "have \"q2 \\<in> reachable A q1\""], ["proof (prove)\nusing this:\n  q2 \\<in> successors A q1\n\ngoal (1 subgoal):\n 1. q2 \\<in> reachable A q1", "by blast"], ["proof (state)\nthis:\n  q2 \\<in> reachable A q1\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes A", "then"], ["proof (chain)\npicking this:\n  q2 \\<in> reachable A q1", "have \"q2 \\<in> reachable A (initial A)\""], ["proof (prove)\nusing this:\n  q2 \\<in> reachable A q1\n\ngoal (1 subgoal):\n 1. q2 \\<in> reachable A (initial A)", "using assms"], ["proof (prove)\nusing this:\n  q2 \\<in> reachable A q1\n  q2 \\<in> succ A w q1\n  q1 \\<in> nodes A\n\ngoal (1 subgoal):\n 1. q2 \\<in> reachable A (initial A)", "by blast"], ["proof (state)\nthis:\n  q2 \\<in> reachable A (initial A)\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes A", "then"], ["proof (chain)\npicking this:\n  q2 \\<in> reachable A (initial A)", "show \"q2 \\<in> nodes A\""], ["proof (prove)\nusing this:\n  q2 \\<in> reachable A (initial A)\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes A", "by blast"], ["proof (state)\nthis:\n  q2 \\<in> nodes A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma states_target_index :\n  assumes \"i < length p\"\n  shows \"(states p q1) ! i = target (take (Suc i) p) q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states p q1 ! i = target (take (Suc i) p) q1", "using assms"], ["proof (prove)\nusing this:\n  i < length p\n\ngoal (1 subgoal):\n 1. states p q1 ! i = target (take (Suc i) p) q1", "by auto"], ["", "subsection \\<open> Product machine for language intersection \\<close>"], ["", "text \\<open>\nThe following describes the construction of a product machine from two FSMs @{verbatim M1} \nand @{verbatim M2} such that the language of the product machine is the intersection of the \nlanguage of @{verbatim M1} and the language of @{verbatim M2}.\n\\<close>"], ["", "definition product :: \"('in, 'out, 'state1) FSM \\<Rightarrow> ('in, 'out, 'state2) FSM \\<Rightarrow>\n  ('in, 'out, 'state1 \\<times>'state2) FSM\" where\n  \"product A B \\<equiv>\n  \\<lparr>\n    succ = \\<lambda> a (p\\<^sub>1, p\\<^sub>2). succ A a p\\<^sub>1 \\<times> succ B a p\\<^sub>2,\n    inputs = inputs A \\<union> inputs B,\n    outputs = outputs A \\<union> outputs B,\n    initial = (initial A, initial B)\n  \\<rparr>\""], ["", "lemma product_simps[simp]:\n  \"succ (product A B) a (p\\<^sub>1, p\\<^sub>2) = succ A a p\\<^sub>1 \\<times> succ B a p\\<^sub>2\"\n  \"inputs (product A B) = inputs A \\<union> inputs B\"\n  \"outputs (product A B) = outputs A \\<union> outputs B\"\n  \"initial (product A B) = (initial A, initial B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (succ (product A B) a (p\\<^sub>1, p\\<^sub>2) =\n     succ A a p\\<^sub>1 \\<times> succ B a p\\<^sub>2 &&&\n     inputs (product A B) = inputs A \\<union> inputs B) &&&\n    outputs (product A B) = outputs A \\<union> outputs B &&&\n    initial (product A B) = (initial A, initial B)", "unfolding product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (succ\n      \\<lparr>succ =\n                \\<lambda>a (p\\<^sub>1, p\\<^sub>2).\n                   succ A a p\\<^sub>1 \\<times> succ B a p\\<^sub>2,\n         inputs = inputs A \\<union> inputs B,\n         outputs = outputs A \\<union> outputs B,\n         initial = (initial A, initial B)\\<rparr>\n      a (p\\<^sub>1, p\\<^sub>2) =\n     succ A a p\\<^sub>1 \\<times> succ B a p\\<^sub>2 &&&\n     inputs\n      \\<lparr>succ =\n                \\<lambda>a (p\\<^sub>1, p\\<^sub>2).\n                   succ A a p\\<^sub>1 \\<times> succ B a p\\<^sub>2,\n         inputs = inputs A \\<union> inputs B,\n         outputs = outputs A \\<union> outputs B,\n         initial = (initial A, initial B)\\<rparr> =\n     inputs A \\<union> inputs B) &&&\n    outputs\n     \\<lparr>succ =\n               \\<lambda>a (p\\<^sub>1, p\\<^sub>2).\n                  succ A a p\\<^sub>1 \\<times> succ B a p\\<^sub>2,\n        inputs = inputs A \\<union> inputs B,\n        outputs = outputs A \\<union> outputs B,\n        initial = (initial A, initial B)\\<rparr> =\n    outputs A \\<union> outputs B &&&\n    initial\n     \\<lparr>succ =\n               \\<lambda>a (p\\<^sub>1, p\\<^sub>2).\n                  succ A a p\\<^sub>1 \\<times> succ B a p\\<^sub>2,\n        inputs = inputs A \\<union> inputs B,\n        outputs = outputs A \\<union> outputs B,\n        initial = (initial A, initial B)\\<rparr> =\n    (initial A, initial B)", "by simp+"], ["", "lemma product_target[simp]:\n  assumes \"length w = length r\\<^sub>1\" \"length r\\<^sub>1 = length r\\<^sub>2\"\n  shows \"target (w || r\\<^sub>1 || r\\<^sub>2) (p\\<^sub>1, p\\<^sub>2) = (target (w || r\\<^sub>1) p\\<^sub>1, target (w || r\\<^sub>2) p\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w || r\\<^sub>1 || r\\<^sub>2) (p\\<^sub>1, p\\<^sub>2) =\n    (target (w || r\\<^sub>1) p\\<^sub>1, target (w || r\\<^sub>2) p\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  length w = length r\\<^sub>1\n  length r\\<^sub>1 = length r\\<^sub>2\n\ngoal (1 subgoal):\n 1. target (w || r\\<^sub>1 || r\\<^sub>2) (p\\<^sub>1, p\\<^sub>2) =\n    (target (w || r\\<^sub>1) p\\<^sub>1, target (w || r\\<^sub>2) p\\<^sub>2)", "by (induct arbitrary: p\\<^sub>1 p\\<^sub>2 rule: list_induct3) (auto)"], ["", "lemma product_path[iff]:\n  assumes \"length w = length r\\<^sub>1\" \"length r\\<^sub>1 = length r\\<^sub>2\"\n  shows \"path (product A B) (w || r\\<^sub>1 || r\\<^sub>2) (p\\<^sub>1, p\\<^sub>2) \\<longleftrightarrow> path A (w || r\\<^sub>1) p\\<^sub>1 \\<and> path B (w || r\\<^sub>2) p\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (product A B) (w || r\\<^sub>1 || r\\<^sub>2)\n     (p\\<^sub>1, p\\<^sub>2) =\n    (path A (w || r\\<^sub>1) p\\<^sub>1 \\<and>\n     path B (w || r\\<^sub>2) p\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  length w = length r\\<^sub>1\n  length r\\<^sub>1 = length r\\<^sub>2\n\ngoal (1 subgoal):\n 1. path (product A B) (w || r\\<^sub>1 || r\\<^sub>2)\n     (p\\<^sub>1, p\\<^sub>2) =\n    (path A (w || r\\<^sub>1) p\\<^sub>1 \\<and>\n     path B (w || r\\<^sub>2) p\\<^sub>2)", "by (induct arbitrary: p\\<^sub>1 p\\<^sub>2 rule: list_induct3) (auto)"], ["", "lemma product_language_state[simp]: \"LS (product A B) (q1,q2) = LS A q1 \\<inter> LS B q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LS (product A B) (q1, q2) = LS A q1 \\<inter> LS B q2", "by (fastforce iff: split_zip)"], ["", "lemma product_nodes :\n  \"nodes (product A B) \\<subseteq> nodes A \\<times> nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (product A B) \\<subseteq> nodes A \\<times> nodes B", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> nodes (product A B) \\<Longrightarrow>\n       x \\<in> nodes A \\<times> nodes B", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> nodes (product A B) \\<Longrightarrow>\n       x \\<in> nodes A \\<times> nodes B", "assume \"q \\<in> nodes (product A B)\""], ["proof (state)\nthis:\n  q \\<in> nodes (product A B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> nodes (product A B) \\<Longrightarrow>\n       x \\<in> nodes A \\<times> nodes B", "then"], ["proof (chain)\npicking this:\n  q \\<in> nodes (product A B)", "show \"q \\<in> nodes A \\<times> nodes B\""], ["proof (prove)\nusing this:\n  q \\<in> nodes (product A B)\n\ngoal (1 subgoal):\n 1. q \\<in> nodes A \\<times> nodes B", "proof (induction rule: FSM.nodes.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       p = initial (product A B) \\<Longrightarrow>\n       p \\<in> nodes A \\<times> nodes B\n 2. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "case (initial p)"], ["proof (state)\nthis:\n  p = initial (product A B)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       p = initial (product A B) \\<Longrightarrow>\n       p \\<in> nodes A \\<times> nodes B\n 2. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "then"], ["proof (chain)\npicking this:\n  p = initial (product A B)", "show ?case"], ["proof (prove)\nusing this:\n  p = initial (product A B)\n\ngoal (1 subgoal):\n 1. p \\<in> nodes A \\<times> nodes B", "by auto"], ["proof (state)\nthis:\n  p \\<in> nodes A \\<times> nodes B\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "case (execute p a)"], ["proof (state)\nthis:\n  p \\<in> nodes (product A B)\n  snd a \\<in> succ (product A B) (fst a) p\n  p \\<in> nodes A \\<times> nodes B\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "then"], ["proof (chain)\npicking this:\n  p \\<in> nodes (product A B)\n  snd a \\<in> succ (product A B) (fst a) p\n  p \\<in> nodes A \\<times> nodes B", "have \"fst p \\<in> nodes A\" \"snd p \\<in> nodes B\""], ["proof (prove)\nusing this:\n  p \\<in> nodes (product A B)\n  snd a \\<in> succ (product A B) (fst a) p\n  p \\<in> nodes A \\<times> nodes B\n\ngoal (1 subgoal):\n 1. fst p \\<in> nodes A &&& snd p \\<in> nodes B", "by auto"], ["proof (state)\nthis:\n  fst p \\<in> nodes A\n  snd p \\<in> nodes B\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "have \"snd a \\<in> (succ A (fst a) (fst p)) \\<times> (succ B (fst a) (snd p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd a \\<in> succ A (fst a) (fst p) \\<times> succ B (fst a) (snd p)", "using execute"], ["proof (prove)\nusing this:\n  p \\<in> nodes (product A B)\n  snd a \\<in> succ (product A B) (fst a) p\n  p \\<in> nodes A \\<times> nodes B\n\ngoal (1 subgoal):\n 1. snd a \\<in> succ A (fst a) (fst p) \\<times> succ B (fst a) (snd p)", "by auto"], ["proof (state)\nthis:\n  snd a \\<in> succ A (fst a) (fst p) \\<times> succ B (fst a) (snd p)\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "then"], ["proof (chain)\npicking this:\n  snd a \\<in> succ A (fst a) (fst p) \\<times> succ B (fst a) (snd p)", "have \"fst (snd a) \\<in> succ A (fst a) (fst p)\"\n              \"snd (snd a) \\<in> succ B (fst a) (snd p)\""], ["proof (prove)\nusing this:\n  snd a \\<in> succ A (fst a) (fst p) \\<times> succ B (fst a) (snd p)\n\ngoal (1 subgoal):\n 1. fst (snd a) \\<in> succ A (fst a) (fst p) &&&\n    snd (snd a) \\<in> succ B (fst a) (snd p)", "by auto"], ["proof (state)\nthis:\n  fst (snd a) \\<in> succ A (fst a) (fst p)\n  snd (snd a) \\<in> succ B (fst a) (snd p)\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "have \"fst (snd a) \\<in> nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd a) \\<in> nodes A", "using \\<open>fst p \\<in> nodes A\\<close> \\<open>fst (snd a) \\<in> succ A (fst a) (fst p)\\<close>"], ["proof (prove)\nusing this:\n  fst p \\<in> nodes A\n  fst (snd a) \\<in> succ A (fst a) (fst p)\n\ngoal (1 subgoal):\n 1. fst (snd a) \\<in> nodes A", "by (metis FSM.nodes.simps fst_conv snd_conv)"], ["proof (state)\nthis:\n  fst (snd a) \\<in> nodes A\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "moreover"], ["proof (state)\nthis:\n  fst (snd a) \\<in> nodes A\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "have \"snd (snd a) \\<in> nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd a) \\<in> nodes B", "using \\<open>snd p \\<in> nodes B\\<close> \\<open>snd (snd a) \\<in> succ B (fst a) (snd p)\\<close>"], ["proof (prove)\nusing this:\n  snd p \\<in> nodes B\n  snd (snd a) \\<in> succ B (fst a) (snd p)\n\ngoal (1 subgoal):\n 1. snd (snd a) \\<in> nodes B", "by (metis FSM.nodes.simps fst_conv snd_conv)"], ["proof (state)\nthis:\n  snd (snd a) \\<in> nodes B\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> nodes (product A B);\n        p \\<in> nodes A \\<times> nodes B;\n        snd a \\<in> succ (product A B) (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> nodes A \\<times> nodes B", "ultimately"], ["proof (chain)\npicking this:\n  fst (snd a) \\<in> nodes A\n  snd (snd a) \\<in> nodes B", "show ?case"], ["proof (prove)\nusing this:\n  fst (snd a) \\<in> nodes A\n  snd (snd a) \\<in> nodes B\n\ngoal (1 subgoal):\n 1. snd a \\<in> nodes A \\<times> nodes B", "by (simp add: mem_Times_iff)"], ["proof (state)\nthis:\n  snd a \\<in> nodes A \\<times> nodes B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> nodes A \\<times> nodes B\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Required properties \\<close>"], ["", "text \\<open>\nFSMs used by the adaptive state counting algorithm are required to satisfy certain properties which\nare introduced in here.\nMost notably, the observability property (see function @{verbatim observable}) implies the \nuniqueness of certain paths and hence allows for several stronger variations of previous results.\n\\<close>"], ["", "fun finite_FSM :: \"('in, 'out, 'state) FSM \\<Rightarrow> bool\" where\n  \"finite_FSM M = (finite (nodes M) \n                  \\<and> finite (inputs M) \n                  \\<and> finite (outputs M))\""], ["", "fun observable :: \"('in, 'out, 'state) FSM \\<Rightarrow> bool\" where\n  \"observable M = (\\<forall> t . \\<forall> s1 . ((succ M) t s1 = {}) \n                                \\<or> (\\<exists> s2 . (succ M) t s1 = {s2}))\""], ["", "fun completely_specified :: \"('in, 'out, 'state) FSM \\<Rightarrow> bool\" where\n  \"completely_specified M = (\\<forall> s1 \\<in> nodes M . \\<forall> x \\<in> inputs M . \n                              \\<exists> y \\<in> outputs M . \n                                \\<exists> s2 . s2 \\<in> (succ M) (x,y) s1)\""], ["", "fun well_formed :: \"('in, 'out, 'state) FSM \\<Rightarrow> bool\" where\n  \"well_formed M = (finite_FSM M\n                    \\<and> (\\<forall> s1 x y . (x \\<notin> inputs M \\<or> y \\<notin> outputs M) \n                                    \\<longrightarrow> succ M (x,y) s1 = {})\n                    \\<and> inputs M \\<noteq> {}\n                    \\<and> outputs M \\<noteq> {})\""], ["", "abbreviation \"OFSM M \\<equiv> well_formed M \n                        \\<and> observable M \n                        \\<and> completely_specified M\""], ["", "lemma OFSM_props[elim!] :\n  assumes \"OFSM M\"\nshows \"well_formed M\" \n      \"observable M\" \n      \"completely_specified M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_formed M &&& observable M &&& completely_specified M", "using assms"], ["proof (prove)\nusing this:\n  OFSM M\n\ngoal (1 subgoal):\n 1. well_formed M &&& observable M &&& completely_specified M", "by auto"], ["", "lemma set_of_succs_finite :\n  assumes \"well_formed M\"\n  and     \"q \\<in> nodes M\"\nshows \"finite (succ M io q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (succ M io q)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (succ M io q) \\<Longrightarrow> False", "assume \"infinite (succ M io q)\""], ["proof (state)\nthis:\n  infinite (succ M io q)\n\ngoal (1 subgoal):\n 1. infinite (succ M io q) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  infinite (succ M io q)\n\ngoal (1 subgoal):\n 1. infinite (succ M io q) \\<Longrightarrow> False", "have \"succ M io q \\<subseteq> nodes M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ M io q \\<subseteq> nodes M", "using assms"], ["proof (prove)\nusing this:\n  well_formed M\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. succ M io q \\<subseteq> nodes M", "by (simp add: subsetI succ_nodes)"], ["proof (state)\nthis:\n  succ M io q \\<subseteq> nodes M\n\ngoal (1 subgoal):\n 1. infinite (succ M io q) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  infinite (succ M io q)\n  succ M io q \\<subseteq> nodes M", "have \"infinite (nodes M)\""], ["proof (prove)\nusing this:\n  infinite (succ M io q)\n  succ M io q \\<subseteq> nodes M\n\ngoal (1 subgoal):\n 1. infinite (nodes M)", "using infinite_super"], ["proof (prove)\nusing this:\n  infinite (succ M io q)\n  succ M io q \\<subseteq> nodes M\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. infinite (nodes M)", "by blast"], ["proof (state)\nthis:\n  infinite (nodes M)\n\ngoal (1 subgoal):\n 1. infinite (succ M io q) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  infinite (nodes M)", "show \"False\""], ["proof (prove)\nusing this:\n  infinite (nodes M)\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  infinite (nodes M)\n  well_formed M\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma well_formed_path_io_containment : \n  assumes \"well_formed M\"\n  and     \"path M p q\"\nshows \"set (map fst p) \\<subseteq> (inputs M \\<times> outputs M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst p) \\<subseteq> inputs M \\<times> outputs M", "using assms"], ["proof (prove)\nusing this:\n  well_formed M\n  path M p q\n\ngoal (1 subgoal):\n 1. set (map fst p) \\<subseteq> inputs M \\<times> outputs M", "proof (induction p arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>well_formed M; path M [] q\\<rbrakk>\n       \\<Longrightarrow> set (map fst [])\n                         \\<subseteq> inputs M \\<times> outputs M\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst p)\n                                     \\<subseteq> inputs M \\<times>\n           outputs M;\n        well_formed M; path M (a # p) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (a # p))\n                         \\<subseteq> inputs M \\<times> outputs M", "case Nil"], ["proof (state)\nthis:\n  well_formed M\n  path M [] q\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>well_formed M; path M [] q\\<rbrakk>\n       \\<Longrightarrow> set (map fst [])\n                         \\<subseteq> inputs M \\<times> outputs M\n 2. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst p)\n                                     \\<subseteq> inputs M \\<times>\n           outputs M;\n        well_formed M; path M (a # p) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (a # p))\n                         \\<subseteq> inputs M \\<times> outputs M", "then"], ["proof (chain)\npicking this:\n  well_formed M\n  path M [] q", "show ?case"], ["proof (prove)\nusing this:\n  well_formed M\n  path M [] q\n\ngoal (1 subgoal):\n 1. set (map fst []) \\<subseteq> inputs M \\<times> outputs M", "by auto"], ["proof (state)\nthis:\n  set (map fst []) \\<subseteq> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst p)\n                                     \\<subseteq> inputs M \\<times>\n           outputs M;\n        well_formed M; path M (a # p) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (a # p))\n                         \\<subseteq> inputs M \\<times> outputs M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst p)\n                                     \\<subseteq> inputs M \\<times>\n           outputs M;\n        well_formed M; path M (a # p) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (a # p))\n                         \\<subseteq> inputs M \\<times> outputs M", "case (Cons a p)"], ["proof (state)\nthis:\n  \\<lbrakk>well_formed M; path M p ?q\\<rbrakk>\n  \\<Longrightarrow> set (map fst p) \\<subseteq> inputs M \\<times> outputs M\n  well_formed M\n  path M (a # p) q\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst p)\n                                     \\<subseteq> inputs M \\<times>\n           outputs M;\n        well_formed M; path M (a # p) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (a # p))\n                         \\<subseteq> inputs M \\<times> outputs M", "have \"fst a \\<in> (inputs M \\<times> outputs M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst a \\<in> inputs M \\<times> outputs M", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. fst a \\<notin> inputs M \\<times> outputs M \\<Longrightarrow> False", "assume \"fst a \\<notin> inputs M \\<times> outputs M\""], ["proof (state)\nthis:\n  fst a \\<notin> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. fst a \\<notin> inputs M \\<times> outputs M \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fst a \\<notin> inputs M \\<times> outputs M", "have \"fst (fst a) \\<notin> inputs M \\<or> snd (fst a) \\<notin> outputs M\""], ["proof (prove)\nusing this:\n  fst a \\<notin> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. fst (fst a) \\<notin> inputs M \\<or> snd (fst a) \\<notin> outputs M", "by (metis SigmaI prod.collapse)"], ["proof (state)\nthis:\n  fst (fst a) \\<notin> inputs M \\<or> snd (fst a) \\<notin> outputs M\n\ngoal (1 subgoal):\n 1. fst a \\<notin> inputs M \\<times> outputs M \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fst (fst a) \\<notin> inputs M \\<or> snd (fst a) \\<notin> outputs M", "have \"succ M (fst a) q = {}\""], ["proof (prove)\nusing this:\n  fst (fst a) \\<notin> inputs M \\<or> snd (fst a) \\<notin> outputs M\n\ngoal (1 subgoal):\n 1. succ M (fst a) q = {}", "using Cons"], ["proof (prove)\nusing this:\n  fst (fst a) \\<notin> inputs M \\<or> snd (fst a) \\<notin> outputs M\n  \\<lbrakk>well_formed M; path M p ?q\\<rbrakk>\n  \\<Longrightarrow> set (map fst p) \\<subseteq> inputs M \\<times> outputs M\n  well_formed M\n  path M (a # p) q\n\ngoal (1 subgoal):\n 1. succ M (fst a) q = {}", "by (metis prod.collapse well_formed.elims(2))"], ["proof (state)\nthis:\n  succ M (fst a) q = {}\n\ngoal (1 subgoal):\n 1. fst a \\<notin> inputs M \\<times> outputs M \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  succ M (fst a) q = {}\n\ngoal (1 subgoal):\n 1. fst a \\<notin> inputs M \\<times> outputs M \\<Longrightarrow> False", "have \"(snd a) \\<in> succ M (fst a) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd a \\<in> succ M (fst a) q", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed M; path M p ?q\\<rbrakk>\n  \\<Longrightarrow> set (map fst p) \\<subseteq> inputs M \\<times> outputs M\n  well_formed M\n  path M (a # p) q\n\ngoal (1 subgoal):\n 1. snd a \\<in> succ M (fst a) q", "by auto"], ["proof (state)\nthis:\n  snd a \\<in> succ M (fst a) q\n\ngoal (1 subgoal):\n 1. fst a \\<notin> inputs M \\<times> outputs M \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  succ M (fst a) q = {}\n  snd a \\<in> succ M (fst a) q", "show \"False\""], ["proof (prove)\nusing this:\n  succ M (fst a) q = {}\n  snd a \\<in> succ M (fst a) q\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst a \\<in> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst p)\n                                     \\<subseteq> inputs M \\<times>\n           outputs M;\n        well_formed M; path M (a # p) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (a # p))\n                         \\<subseteq> inputs M \\<times> outputs M", "moreover"], ["proof (state)\nthis:\n  fst a \\<in> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst p)\n                                     \\<subseteq> inputs M \\<times>\n           outputs M;\n        well_formed M; path M (a # p) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (a # p))\n                         \\<subseteq> inputs M \\<times> outputs M", "have \"set (map fst p) \\<subseteq> (inputs M \\<times> outputs M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst p) \\<subseteq> inputs M \\<times> outputs M", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed M; path M p ?q\\<rbrakk>\n  \\<Longrightarrow> set (map fst p) \\<subseteq> inputs M \\<times> outputs M\n  well_formed M\n  path M (a # p) q\n\ngoal (1 subgoal):\n 1. set (map fst p) \\<subseteq> inputs M \\<times> outputs M", "by blast"], ["proof (state)\nthis:\n  set (map fst p) \\<subseteq> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst p)\n                                     \\<subseteq> inputs M \\<times>\n           outputs M;\n        well_formed M; path M (a # p) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (a # p))\n                         \\<subseteq> inputs M \\<times> outputs M", "ultimately"], ["proof (chain)\npicking this:\n  fst a \\<in> inputs M \\<times> outputs M\n  set (map fst p) \\<subseteq> inputs M \\<times> outputs M", "show ?case"], ["proof (prove)\nusing this:\n  fst a \\<in> inputs M \\<times> outputs M\n  set (map fst p) \\<subseteq> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. set (map fst (a # p)) \\<subseteq> inputs M \\<times> outputs M", "by auto"], ["proof (state)\nthis:\n  set (map fst (a # p)) \\<subseteq> inputs M \\<times> outputs M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_input_containment :\n  assumes \"well_formed M\"\n  and     \"path M p q\"  \nshows \"set (map fst (map fst p)) \\<subseteq> inputs M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (map fst p)) \\<subseteq> inputs M", "using assms"], ["proof (prove)\nusing this:\n  well_formed M\n  path M p q\n\ngoal (1 subgoal):\n 1. set (map fst (map fst p)) \\<subseteq> inputs M", "proof (induction p arbitrary: q rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>well_formed M; path M [] q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst [])) \\<subseteq> inputs M\n 2. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M xs q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst (map fst xs))\n                                     \\<subseteq> inputs M;\n        well_formed M; path M (xs @ [x]) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst (xs @ [x])))\n                         \\<subseteq> inputs M", "case Nil"], ["proof (state)\nthis:\n  well_formed M\n  path M [] q\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>well_formed M; path M [] q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst [])) \\<subseteq> inputs M\n 2. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M xs q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst (map fst xs))\n                                     \\<subseteq> inputs M;\n        well_formed M; path M (xs @ [x]) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst (xs @ [x])))\n                         \\<subseteq> inputs M", "then"], ["proof (chain)\npicking this:\n  well_formed M\n  path M [] q", "show ?case"], ["proof (prove)\nusing this:\n  well_formed M\n  path M [] q\n\ngoal (1 subgoal):\n 1. set (map fst (map fst [])) \\<subseteq> inputs M", "by auto"], ["proof (state)\nthis:\n  set (map fst (map fst [])) \\<subseteq> inputs M\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M xs q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst (map fst xs))\n                                     \\<subseteq> inputs M;\n        well_formed M; path M (xs @ [x]) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst (xs @ [x])))\n                         \\<subseteq> inputs M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M xs q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst (map fst xs))\n                                     \\<subseteq> inputs M;\n        well_formed M; path M (xs @ [x]) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst (xs @ [x])))\n                         \\<subseteq> inputs M", "case (snoc a p)"], ["proof (state)\nthis:\n  \\<lbrakk>well_formed M; path M p ?q\\<rbrakk>\n  \\<Longrightarrow> set (map fst (map fst p)) \\<subseteq> inputs M\n  well_formed M\n  path M (p @ [a]) q\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M xs q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst (map fst xs))\n                                     \\<subseteq> inputs M;\n        well_formed M; path M (xs @ [x]) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst (xs @ [x])))\n                         \\<subseteq> inputs M", "have \"set (map fst (p @ [a])) \\<subseteq> (inputs M \\<times> outputs M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (p @ [a])) \\<subseteq> inputs M \\<times> outputs M", "using well_formed_path_io_containment[OF snoc.prems]"], ["proof (prove)\nusing this:\n  set (map fst (p @ [a])) \\<subseteq> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. set (map fst (p @ [a])) \\<subseteq> inputs M \\<times> outputs M", "by assumption"], ["proof (state)\nthis:\n  set (map fst (p @ [a])) \\<subseteq> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M xs q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst (map fst xs))\n                                     \\<subseteq> inputs M;\n        well_formed M; path M (xs @ [x]) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst (xs @ [x])))\n                         \\<subseteq> inputs M", "then"], ["proof (chain)\npicking this:\n  set (map fst (p @ [a])) \\<subseteq> inputs M \\<times> outputs M", "have \"(fst a) \\<in> (inputs M \\<times> outputs M)\""], ["proof (prove)\nusing this:\n  set (map fst (p @ [a])) \\<subseteq> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. fst a \\<in> inputs M \\<times> outputs M", "by auto"], ["proof (state)\nthis:\n  fst a \\<in> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M xs q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst (map fst xs))\n                                     \\<subseteq> inputs M;\n        well_formed M; path M (xs @ [x]) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst (xs @ [x])))\n                         \\<subseteq> inputs M", "then"], ["proof (chain)\npicking this:\n  fst a \\<in> inputs M \\<times> outputs M", "have \"fst (fst a) \\<in> inputs M\""], ["proof (prove)\nusing this:\n  fst a \\<in> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. fst (fst a) \\<in> inputs M", "by auto"], ["proof (state)\nthis:\n  fst (fst a) \\<in> inputs M\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M xs q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst (map fst xs))\n                                     \\<subseteq> inputs M;\n        well_formed M; path M (xs @ [x]) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst (xs @ [x])))\n                         \\<subseteq> inputs M", "moreover"], ["proof (state)\nthis:\n  fst (fst a) \\<in> inputs M\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M xs q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst (map fst xs))\n                                     \\<subseteq> inputs M;\n        well_formed M; path M (xs @ [x]) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst (xs @ [x])))\n                         \\<subseteq> inputs M", "have \"set (map fst (map fst p)) \\<subseteq> inputs M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (map fst p)) \\<subseteq> inputs M", "using snoc.IH[OF snoc.prems(1)]"], ["proof (prove)\nusing this:\n  path M p ?q \\<Longrightarrow>\n  set (map fst (map fst p)) \\<subseteq> inputs M\n\ngoal (1 subgoal):\n 1. set (map fst (map fst p)) \\<subseteq> inputs M", "using snoc.prems(2)"], ["proof (prove)\nusing this:\n  path M p ?q \\<Longrightarrow>\n  set (map fst (map fst p)) \\<subseteq> inputs M\n  path M (p @ [a]) q\n\ngoal (1 subgoal):\n 1. set (map fst (map fst p)) \\<subseteq> inputs M", "by blast"], ["proof (state)\nthis:\n  set (map fst (map fst p)) \\<subseteq> inputs M\n\ngoal (1 subgoal):\n 1. \\<And>x xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>well_formed M; path M xs q\\<rbrakk>\n                   \\<Longrightarrow> set (map fst (map fst xs))\n                                     \\<subseteq> inputs M;\n        well_formed M; path M (xs @ [x]) q\\<rbrakk>\n       \\<Longrightarrow> set (map fst (map fst (xs @ [x])))\n                         \\<subseteq> inputs M", "ultimately"], ["proof (chain)\npicking this:\n  fst (fst a) \\<in> inputs M\n  set (map fst (map fst p)) \\<subseteq> inputs M", "show ?case"], ["proof (prove)\nusing this:\n  fst (fst a) \\<in> inputs M\n  set (map fst (map fst p)) \\<subseteq> inputs M\n\ngoal (1 subgoal):\n 1. set (map fst (map fst (p @ [a]))) \\<subseteq> inputs M", "by simp"], ["proof (state)\nthis:\n  set (map fst (map fst (p @ [a]))) \\<subseteq> inputs M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_state_containment :\n  assumes \"path M p q\"\n  and     \"q \\<in> nodes M\"\nshows \"set (map snd p) \\<subseteq> nodes M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map snd p) \\<subseteq> nodes M", "using assms"], ["proof (prove)\nusing this:\n  path M p q\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. set (map snd p) \\<subseteq> nodes M", "by (metis FSM.nodes_states states_alt_def)"], ["", "lemma language_state_inputs :\n  assumes \"well_formed M\"\n  and     \"io \\<in> language_state M q\"\nshows \"set (map fst io) \\<subseteq> inputs M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst io) \\<subseteq> inputs M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map fst io) \\<subseteq> inputs M", "obtain tr where \"path M (io || tr) q\" \"length tr = length io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>path M (io || tr) q; length tr = length io\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  io \\<in> LS M q\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>path M (io || tr) q; length tr = length io\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M (io || tr) q\n  length tr = length io\n\ngoal (1 subgoal):\n 1. set (map fst io) \\<subseteq> inputs M", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst io) \\<subseteq> inputs M", "by (metis (no_types) \n        \\<open>\\<And>thesis. (\\<And>tr. \\<lbrakk>path M (io || tr) q; length tr = length io\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close> \n        assms(1) map_fst_zip path_input_containment)"], ["proof (state)\nthis:\n  set (map fst io) \\<subseteq> inputs M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_of_paths_finite : \n  assumes \"well_formed M\"\n  and     \"q1 \\<in> nodes M\"\nshows \"finite { p . path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "let ?trs = \"{ tr . set tr \\<subseteq> nodes M \\<and> length tr \\<le> k }\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "let ?ios = \"{ io . set io \\<subseteq> inputs M \\<times> outputs M \\<and> length io \\<le> k }\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "let ?iotrs = \"image (\\<lambda> (io,tr) . io || tr) (?ios \\<times> ?trs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "let ?paths = \"{ p . path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k }\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "have \"finite (inputs M \\<times> outputs M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (inputs M \\<times> outputs M)", "using assms"], ["proof (prove)\nusing this:\n  well_formed M\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. finite (inputs M \\<times> outputs M)", "by auto"], ["proof (state)\nthis:\n  finite (inputs M \\<times> outputs M)\n\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "then"], ["proof (chain)\npicking this:\n  finite (inputs M \\<times> outputs M)", "have \"finite ?ios\""], ["proof (prove)\nusing this:\n  finite (inputs M \\<times> outputs M)\n\ngoal (1 subgoal):\n 1. finite\n     {io.\n      set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n      length io \\<le> k}", "using assms"], ["proof (prove)\nusing this:\n  finite (inputs M \\<times> outputs M)\n  well_formed M\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. finite\n     {io.\n      set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n      length io \\<le> k}", "by (simp add: finite_lists_length_le)"], ["proof (state)\nthis:\n  finite\n   {io.\n    set io \\<subseteq> inputs M \\<times> outputs M \\<and> length io \\<le> k}\n\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "moreover"], ["proof (state)\nthis:\n  finite\n   {io.\n    set io \\<subseteq> inputs M \\<times> outputs M \\<and> length io \\<le> k}\n\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "have \"finite ?trs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "using assms"], ["proof (prove)\nusing this:\n  well_formed M\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. finite {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "by (simp add: finite_lists_length_le)"], ["proof (state)\nthis:\n  finite {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}\n\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   {io.\n    set io \\<subseteq> inputs M \\<times> outputs M \\<and> length io \\<le> k}\n  finite {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "have \"finite ?iotrs\""], ["proof (prove)\nusing this:\n  finite\n   {io.\n    set io \\<subseteq> inputs M \\<times> outputs M \\<and> length io \\<le> k}\n  finite {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(io, tr). io || tr) `\n      ({io.\n        set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n        length io \\<le> k} \\<times>\n       {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}))", "by auto"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(io, tr). io || tr) `\n    ({io.\n      set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n      length io \\<le> k} \\<times>\n     {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}))\n\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "moreover"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(io, tr). io || tr) `\n    ({io.\n      set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n      length io \\<le> k} \\<times>\n     {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}))\n\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "have \"?paths \\<subseteq> ?iotrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n    \\<subseteq> (\\<lambda>(io, tr). io || tr) `\n                ({io.\n                  set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                  length io \\<le> k} \\<times>\n                 {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. path M p q1 \\<and>\n                   target p q1 = q2 \\<and>\n                   length p \\<le> k} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(io, tr). io || tr) `\n               ({io.\n                 set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                 length io \\<le> k} \\<times>\n                {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. path M p q1 \\<and>\n                   target p q1 = q2 \\<and>\n                   length p \\<le> k} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(io, tr). io || tr) `\n               ({io.\n                 set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                 length io \\<le> k} \\<times>\n                {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "assume p_assm : \"p \\<in> { p . path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k }\""], ["proof (state)\nthis:\n  p \\<in> {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. path M p q1 \\<and>\n                   target p q1 = q2 \\<and>\n                   length p \\<le> k} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(io, tr). io || tr) `\n               ({io.\n                 set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                 length io \\<le> k} \\<times>\n                {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "then"], ["proof (chain)\npicking this:\n  p \\<in> {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "obtain io tr where p_split : \"p = io || tr \\<and> length io = length tr\""], ["proof (prove)\nusing this:\n  p \\<in> {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n\ngoal (1 subgoal):\n 1. (\\<And>io tr.\n        p = io || tr \\<and> length io = length tr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using that"], ["proof (prove)\nusing this:\n  p \\<in> {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n  p = ?io || ?tr \\<and> length ?io = length ?tr \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>io tr.\n        p = io || tr \\<and> length io = length tr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types) length_map zip_map_fst_snd)"], ["proof (state)\nthis:\n  p = io || tr \\<and> length io = length tr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. path M p q1 \\<and>\n                   target p q1 = q2 \\<and>\n                   length p \\<le> k} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(io, tr). io || tr) `\n               ({io.\n                 set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                 length io \\<le> k} \\<times>\n                {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "then"], ["proof (chain)\npicking this:\n  p = io || tr \\<and> length io = length tr", "have \"io \\<in> ?ios\""], ["proof (prove)\nusing this:\n  p = io || tr \\<and> length io = length tr\n\ngoal (1 subgoal):\n 1. io \\<in> {io.\n              set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n              length io \\<le> k}", "using well_formed_path_io_containment"], ["proof (prove)\nusing this:\n  p = io || tr \\<and> length io = length tr\n  \\<lbrakk>well_formed ?M; path ?M ?p ?q\\<rbrakk>\n  \\<Longrightarrow> set (map fst ?p)\n                    \\<subseteq> inputs ?M \\<times> outputs ?M\n\ngoal (1 subgoal):\n 1. io \\<in> {io.\n              set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n              length io \\<le> k}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = io || tr \\<and> length io = length tr;\n     \\<And>M p q.\n        \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n        \\<Longrightarrow> set (map fst p)\n                          \\<subseteq> inputs M \\<times> outputs M\\<rbrakk>\n    \\<Longrightarrow> io \\<in> {io.\n                                set io\n                                \\<subseteq> inputs M \\<times>\n      outputs M \\<and>\n                                length io \\<le> k}", "have f1: \"path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k", "using p_assm"], ["proof (prove)\nusing this:\n  p \\<in> {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n\ngoal (1 subgoal):\n 1. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k", "by force"], ["proof (state)\nthis:\n  path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = io || tr \\<and> length io = length tr;\n     \\<And>M p q.\n        \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n        \\<Longrightarrow> set (map fst p)\n                          \\<subseteq> inputs M \\<times> outputs M\\<rbrakk>\n    \\<Longrightarrow> io \\<in> {io.\n                                set io\n                                \\<subseteq> inputs M \\<times>\n      outputs M \\<and>\n                                length io \\<le> k}", "then"], ["proof (chain)\npicking this:\n  path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k", "have \"set io \\<subseteq> inputs M \\<times> outputs M\""], ["proof (prove)\nusing this:\n  path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k\n\ngoal (1 subgoal):\n 1. set io \\<subseteq> inputs M \\<times> outputs M", "by (metis (no_types) assms(1) map_fst_zip p_split well_formed_path_io_containment)"], ["proof (state)\nthis:\n  set io \\<subseteq> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = io || tr \\<and> length io = length tr;\n     \\<And>M p q.\n        \\<lbrakk>well_formed M; path M p q\\<rbrakk>\n        \\<Longrightarrow> set (map fst p)\n                          \\<subseteq> inputs M \\<times> outputs M\\<rbrakk>\n    \\<Longrightarrow> io \\<in> {io.\n                                set io\n                                \\<subseteq> inputs M \\<times>\n      outputs M \\<and>\n                                length io \\<le> k}", "then"], ["proof (chain)\npicking this:\n  set io \\<subseteq> inputs M \\<times> outputs M", "show ?thesis"], ["proof (prove)\nusing this:\n  set io \\<subseteq> inputs M \\<times> outputs M\n\ngoal (1 subgoal):\n 1. io \\<in> {io.\n              set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n              length io \\<le> k}", "using f1"], ["proof (prove)\nusing this:\n  set io \\<subseteq> inputs M \\<times> outputs M\n  path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k\n\ngoal (1 subgoal):\n 1. io \\<in> {io.\n              set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n              length io \\<le> k}", "by (simp add: p_split)"], ["proof (state)\nthis:\n  io \\<in> {io.\n            set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n            length io \\<le> k}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  io \\<in> {io.\n            set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n            length io \\<le> k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. path M p q1 \\<and>\n                   target p q1 = q2 \\<and>\n                   length p \\<le> k} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(io, tr). io || tr) `\n               ({io.\n                 set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                 length io \\<le> k} \\<times>\n                {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "moreover"], ["proof (state)\nthis:\n  io \\<in> {io.\n            set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n            length io \\<le> k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. path M p q1 \\<and>\n                   target p q1 = q2 \\<and>\n                   length p \\<le> k} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(io, tr). io || tr) `\n               ({io.\n                 set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                 length io \\<le> k} \\<times>\n                {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "have \"tr \\<in> ?trs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "using p_split"], ["proof (prove)\nusing this:\n  p = io || tr \\<and> length io = length tr\n\ngoal (1 subgoal):\n 1. tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = io || tr \\<and> length io = length tr \\<Longrightarrow>\n    tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "have f1: \"path M (io || tr) q1 \\<and> target (io || tr) q1 = q2 \n                  \\<and> length (io || tr) \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M (io || tr) q1 \\<and>\n    target (io || tr) q1 = q2 \\<and> length (io || tr) \\<le> k", "using \\<open>p \\<in> {p. path M p q1 \n                  \\<and> target p q1 = q2 \\<and> length p \\<le> k}\\<close> p_split"], ["proof (prove)\nusing this:\n  p \\<in> {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n  p = io || tr \\<and> length io = length tr\n\ngoal (1 subgoal):\n 1. path M (io || tr) q1 \\<and>\n    target (io || tr) q1 = q2 \\<and> length (io || tr) \\<le> k", "by force"], ["proof (state)\nthis:\n  path M (io || tr) q1 \\<and>\n  target (io || tr) q1 = q2 \\<and> length (io || tr) \\<le> k\n\ngoal (1 subgoal):\n 1. p = io || tr \\<and> length io = length tr \\<Longrightarrow>\n    tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "then"], ["proof (chain)\npicking this:\n  path M (io || tr) q1 \\<and>\n  target (io || tr) q1 = q2 \\<and> length (io || tr) \\<le> k", "have f2: \"length tr \\<le> k\""], ["proof (prove)\nusing this:\n  path M (io || tr) q1 \\<and>\n  target (io || tr) q1 = q2 \\<and> length (io || tr) \\<le> k\n\ngoal (1 subgoal):\n 1. length tr \\<le> k", "by (simp add: p_split)"], ["proof (state)\nthis:\n  length tr \\<le> k\n\ngoal (1 subgoal):\n 1. p = io || tr \\<and> length io = length tr \\<Longrightarrow>\n    tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "have \"set tr \\<subseteq> nodes M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set tr \\<subseteq> nodes M", "using f1"], ["proof (prove)\nusing this:\n  path M (io || tr) q1 \\<and>\n  target (io || tr) q1 = q2 \\<and> length (io || tr) \\<le> k\n\ngoal (1 subgoal):\n 1. set tr \\<subseteq> nodes M", "by (metis (no_types) assms(2) length_map p_split path_state_containment \n                      zip_eq zip_map_fst_snd)"], ["proof (state)\nthis:\n  set tr \\<subseteq> nodes M\n\ngoal (1 subgoal):\n 1. p = io || tr \\<and> length io = length tr \\<Longrightarrow>\n    tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "then"], ["proof (chain)\npicking this:\n  set tr \\<subseteq> nodes M", "show ?thesis"], ["proof (prove)\nusing this:\n  set tr \\<subseteq> nodes M\n\ngoal (1 subgoal):\n 1. tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "using f2"], ["proof (prove)\nusing this:\n  set tr \\<subseteq> nodes M\n  length tr \\<le> k\n\ngoal (1 subgoal):\n 1. tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "by blast"], ["proof (state)\nthis:\n  tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. path M p q1 \\<and>\n                   target p q1 = q2 \\<and>\n                   length p \\<le> k} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(io, tr). io || tr) `\n               ({io.\n                 set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                 length io \\<le> k} \\<times>\n                {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "ultimately"], ["proof (chain)\npicking this:\n  io \\<in> {io.\n            set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n            length io \\<le> k}\n  tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}", "show \"p \\<in> ?iotrs\""], ["proof (prove)\nusing this:\n  io \\<in> {io.\n            set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n            length io \\<le> k}\n  tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}\n\ngoal (1 subgoal):\n 1. p \\<in> (\\<lambda>(io, tr). io || tr) `\n            ({io.\n              set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n              length io \\<le> k} \\<times>\n             {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "using p_split"], ["proof (prove)\nusing this:\n  io \\<in> {io.\n            set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n            length io \\<le> k}\n  tr \\<in> {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}\n  p = io || tr \\<and> length io = length tr\n\ngoal (1 subgoal):\n 1. p \\<in> (\\<lambda>(io, tr). io || tr) `\n            ({io.\n              set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n              length io \\<le> k} \\<times>\n             {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "by auto"], ["proof (state)\nthis:\n  p \\<in> (\\<lambda>(io, tr). io || tr) `\n          ({io.\n            set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n            length io \\<le> k} \\<times>\n           {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n  \\<subseteq> (\\<lambda>(io, tr). io || tr) `\n              ({io.\n                set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                length io \\<le> k} \\<times>\n               {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})\n\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   ((\\<lambda>(io, tr). io || tr) `\n    ({io.\n      set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n      length io \\<le> k} \\<times>\n     {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}))\n  {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n  \\<subseteq> (\\<lambda>(io, tr). io || tr) `\n              ({io.\n                set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                length io \\<le> k} \\<times>\n               {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   ((\\<lambda>(io, tr). io || tr) `\n    ({io.\n      set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n      length io \\<le> k} \\<times>\n     {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}))\n  {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n  \\<subseteq> (\\<lambda>(io, tr). io || tr) `\n              ({io.\n                set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                length io \\<le> k} \\<times>\n               {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})\n\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "using Finite_Set.finite_subset"], ["proof (prove)\nusing this:\n  finite\n   ((\\<lambda>(io, tr). io || tr) `\n    ({io.\n      set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n      length io \\<le> k} \\<times>\n     {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k}))\n  {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n  \\<subseteq> (\\<lambda>(io, tr). io || tr) `\n              ({io.\n                set io \\<subseteq> inputs M \\<times> outputs M \\<and>\n                length io \\<le> k} \\<times>\n               {tr. set tr \\<subseteq> nodes M \\<and> length tr \\<le> k})\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}", "by blast"], ["proof (state)\nthis:\n  finite {p. path M p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> k}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_distinct_duplicate_indices :\n  assumes \"\\<not> distinct xs\"\nshows \"\\<exists> i1 i2 . i1 \\<noteq> i2 \\<and> xs ! i1 = xs ! i2 \\<and> i1 \\<le> length xs \\<and> i2 \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i1 i2.\n       i1 \\<noteq> i2 \\<and>\n       xs ! i1 = xs ! i2 \\<and> i1 \\<le> length xs \\<and> i2 \\<le> length xs", "using assms"], ["proof (prove)\nusing this:\n  \\<not> distinct xs\n\ngoal (1 subgoal):\n 1. \\<exists>i1 i2.\n       i1 \\<noteq> i2 \\<and>\n       xs ! i1 = xs ! i2 \\<and> i1 \\<le> length xs \\<and> i2 \\<le> length xs", "by (meson distinct_conv_nth less_imp_le)"], ["", "lemma reaching_path_without_repetition :\n  assumes \"well_formed M\"\n  and     \"q2 \\<in> reachable M q1\"\n  and     \"q1 \\<in> nodes M\"\nshows \"\\<exists> p . path M p q1 \\<and> target p q1 = q2 \\<and> distinct (q1 # states p q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "have shorten_nondistinct : \"\\<forall> p. (path M p q1 \\<and> target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1)) \n               \\<longrightarrow> (\\<exists> p' . path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and>\n       \\<not> distinct (q1 # states p q1) \\<longrightarrow>\n       (\\<exists>p'.\n           path M p' q1 \\<and>\n           target p' q1 = q2 \\<and> length p' < length p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and>\n       \\<not> distinct (q1 # states p q1) \\<longrightarrow>\n       (\\<exists>p'.\n           path M p' q1 \\<and>\n           target p' q1 = q2 \\<and> length p' < length p)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and>\n       \\<not> distinct (q1 # states p q1) \\<longrightarrow>\n       (\\<exists>p'.\n           path M p' q1 \\<and>\n           target p' q1 = q2 \\<and> length p' < length p)", "show \"(path M p q1 \\<and> target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1)) \n               \\<longrightarrow> (\\<exists> p' . path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M p q1 \\<and>\n    target p q1 = q2 \\<and>\n    \\<not> distinct (q1 # states p q1) \\<longrightarrow>\n    (\\<exists>p'.\n        path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. path M p q1 \\<and>\n    target p q1 = q2 \\<and>\n    \\<not> distinct (q1 # states p q1) \\<Longrightarrow>\n    \\<exists>p'.\n       path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p", "assume assm : \"path M p q1 \\<and> target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1)\""], ["proof (state)\nthis:\n  path M p q1 \\<and>\n  target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. path M p q1 \\<and>\n    target p q1 = q2 \\<and>\n    \\<not> distinct (q1 # states p q1) \\<Longrightarrow>\n    \\<exists>p'.\n       path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p", "then"], ["proof (chain)\npicking this:\n  path M p q1 \\<and>\n  target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1)", "show \"(\\<exists>p'. path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p)\""], ["proof (prove)\nusing this:\n  path M p q1 \\<and>\n  target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p", "proof (cases \"q1 \\<in> set (states p q1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<in> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p\n 2. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "case True"], ["proof (state)\nthis:\n  q1 \\<in> set (states p q1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<in> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p\n 2. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "have \"\\<exists> i1 . target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> i1 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i1.\n       target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>i1.\n       target (take i1 p) q1 = q1 \\<and>\n       i1 \\<le> length p \\<and> 0 < i1 \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists> i1. target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> i1 > 0)\""], ["proof (state)\nthis:\n  \\<nexists>i1.\n     target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1\n\ngoal (1 subgoal):\n 1. \\<nexists>i1.\n       target (take i1 p) q1 = q1 \\<and>\n       i1 \\<le> length p \\<and> 0 < i1 \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>i1.\n     target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1", "have \"\\<not> (\\<exists> i1 . (states p q1) ! i1 = q1 \\<and> i1 \\<le> length (states p q1))\""], ["proof (prove)\nusing this:\n  \\<nexists>i1.\n     target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1\n\ngoal (1 subgoal):\n 1. \\<nexists>i1. states p q1 ! i1 = q1 \\<and> i1 \\<le> length (states p q1)", "by (metis True in_set_conv_nth less_eq_Suc_le scan_length scan_nth zero_less_Suc)"], ["proof (state)\nthis:\n  \\<nexists>i1. states p q1 ! i1 = q1 \\<and> i1 \\<le> length (states p q1)\n\ngoal (1 subgoal):\n 1. \\<nexists>i1.\n       target (take i1 p) q1 = q1 \\<and>\n       i1 \\<le> length p \\<and> 0 < i1 \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>i1. states p q1 ! i1 = q1 \\<and> i1 \\<le> length (states p q1)", "have \"q1 \\<notin> set (states p q1)\""], ["proof (prove)\nusing this:\n  \\<nexists>i1. states p q1 ! i1 = q1 \\<and> i1 \\<le> length (states p q1)\n\ngoal (1 subgoal):\n 1. q1 \\<notin> set (states p q1)", "by (meson in_set_conv_nth less_imp_le)"], ["proof (state)\nthis:\n  q1 \\<notin> set (states p q1)\n\ngoal (1 subgoal):\n 1. \\<nexists>i1.\n       target (take i1 p) q1 = q1 \\<and>\n       i1 \\<le> length p \\<and> 0 < i1 \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  q1 \\<notin> set (states p q1)", "show \"False\""], ["proof (prove)\nusing this:\n  q1 \\<notin> set (states p q1)\n\ngoal (1 subgoal):\n 1. False", "using True"], ["proof (prove)\nusing this:\n  q1 \\<notin> set (states p q1)\n  q1 \\<in> set (states p q1)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i1.\n     target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<in> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p\n 2. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "then"], ["proof (chain)\npicking this:\n  \\<exists>i1.\n     target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1", "obtain i1 where i1_def : \"target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> i1 > 0\""], ["proof (prove)\nusing this:\n  \\<exists>i1.\n     target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1\n\ngoal (1 subgoal):\n 1. (\\<And>i1.\n        target (take i1 p) q1 = q1 \\<and>\n        i1 \\<le> length p \\<and> 0 < i1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<in> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p\n 2. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "then"], ["proof (chain)\npicking this:\n  target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1", "have \"path M (take i1 p) q1\""], ["proof (prove)\nusing this:\n  target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1\n\ngoal (1 subgoal):\n 1. path M (take i1 p) q1", "using assm"], ["proof (prove)\nusing this:\n  target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1\n  path M p q1 \\<and>\n  target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. path M (take i1 p) q1", "by (metis FSM.path_append_elim append_take_drop_id)"], ["proof (state)\nthis:\n  path M (take i1 p) q1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<in> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p\n 2. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "moreover"], ["proof (state)\nthis:\n  path M (take i1 p) q1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<in> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p\n 2. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "have \"path M (drop i1 p) q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M (drop i1 p) q1", "using i1_def"], ["proof (prove)\nusing this:\n  target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1\n\ngoal (1 subgoal):\n 1. path M (drop i1 p) q1", "by (metis FSM.path_append_elim append_take_drop_id assm)"], ["proof (state)\nthis:\n  path M (drop i1 p) q1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<in> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p\n 2. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "ultimately"], ["proof (chain)\npicking this:\n  path M (take i1 p) q1\n  path M (drop i1 p) q1", "have \"path M (drop i1 p) q1 \\<and> (target (drop i1 p) q1 = q2)\""], ["proof (prove)\nusing this:\n  path M (take i1 p) q1\n  path M (drop i1 p) q1\n\ngoal (1 subgoal):\n 1. path M (drop i1 p) q1 \\<and> target (drop i1 p) q1 = q2", "using i1_def"], ["proof (prove)\nusing this:\n  path M (take i1 p) q1\n  path M (drop i1 p) q1\n  target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1\n\ngoal (1 subgoal):\n 1. path M (drop i1 p) q1 \\<and> target (drop i1 p) q1 = q2", "by (metis (no_types) append_take_drop_id assm fold_append o_apply)"], ["proof (state)\nthis:\n  path M (drop i1 p) q1 \\<and> target (drop i1 p) q1 = q2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<in> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p\n 2. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "moreover"], ["proof (state)\nthis:\n  path M (drop i1 p) q1 \\<and> target (drop i1 p) q1 = q2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<in> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p\n 2. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "have \"length (drop i1 p) < length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (drop i1 p) < length p", "using i1_def"], ["proof (prove)\nusing this:\n  target (take i1 p) q1 = q1 \\<and> i1 \\<le> length p \\<and> 0 < i1\n\ngoal (1 subgoal):\n 1. length (drop i1 p) < length p", "by auto"], ["proof (state)\nthis:\n  length (drop i1 p) < length p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<in> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p\n 2. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "ultimately"], ["proof (chain)\npicking this:\n  path M (drop i1 p) q1 \\<and> target (drop i1 p) q1 = q2\n  length (drop i1 p) < length p", "show ?thesis"], ["proof (prove)\nusing this:\n  path M (drop i1 p) q1 \\<and> target (drop i1 p) q1 = q2\n  length (drop i1 p) < length p\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p", "using assms"], ["proof (prove)\nusing this:\n  path M (drop i1 p) q1 \\<and> target (drop i1 p) q1 = q2\n  length (drop i1 p) < length p\n  well_formed M\n  q2 \\<in> reachable M q1\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p", "by blast"], ["proof (state)\nthis:\n  \\<exists>p'.\n     path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "case False"], ["proof (state)\nthis:\n  q1 \\<notin> set (states p q1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "then"], ["proof (chain)\npicking this:\n  q1 \\<notin> set (states p q1)", "have assm' : \"path M p q1 \\<and> target p q1 = q2 \\<and> \\<not> distinct (states p q1)\""], ["proof (prove)\nusing this:\n  q1 \\<notin> set (states p q1)\n\ngoal (1 subgoal):\n 1. path M p q1 \\<and> target p q1 = q2 \\<and> \\<not> distinct (states p q1)", "using assm"], ["proof (prove)\nusing this:\n  q1 \\<notin> set (states p q1)\n  path M p q1 \\<and>\n  target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. path M p q1 \\<and> target p q1 = q2 \\<and> \\<not> distinct (states p q1)", "by auto"], ["proof (state)\nthis:\n  path M p q1 \\<and> target p q1 = q2 \\<and> \\<not> distinct (states p q1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "have \"\\<exists> i1 i2 . i1 \\<noteq> i2 \\<and> target (take i1 p) q1 = target (take i2 p) q1 \n                        \\<and> i1 \\<le> length p \\<and> i2 \\<le> length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i1 i2.\n       i1 \\<noteq> i2 \\<and>\n       target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n       i1 \\<le> length p \\<and> i2 \\<le> length p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>i1 i2.\n       i1 \\<noteq> i2 \\<and>\n       target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n       i1 \\<le> length p \\<and> i2 \\<le> length p \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists> i1 i2 . i1 \\<noteq> i2 \\<and> target (take i1 p) q1 = target (take i2 p) q1 \n                                \\<and> i1 \\<le> length p \\<and> i2 \\<le> length p)\""], ["proof (state)\nthis:\n  \\<nexists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n     i1 \\<le> length p \\<and> i2 \\<le> length p\n\ngoal (1 subgoal):\n 1. \\<nexists>i1 i2.\n       i1 \\<noteq> i2 \\<and>\n       target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n       i1 \\<le> length p \\<and> i2 \\<le> length p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n     i1 \\<le> length p \\<and> i2 \\<le> length p", "have \"\\<not> (\\<exists> i1 i2 . i1 \\<noteq> i2 \\<and> (states p q1) ! i1 = (states p q1) ! i2 \n                                  \\<and> i1 \\<le> length (states p q1) \\<and> i2 \\<le> length (states p q1))\""], ["proof (prove)\nusing this:\n  \\<nexists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n     i1 \\<le> length p \\<and> i2 \\<le> length p\n\ngoal (1 subgoal):\n 1. \\<nexists>i1 i2.\n       i1 \\<noteq> i2 \\<and>\n       states p q1 ! i1 = states p q1 ! i2 \\<and>\n       i1 \\<le> length (states p q1) \\<and> i2 \\<le> length (states p q1)", "by (metis (no_types, lifting) Suc_leI assm' distinct_conv_nth nat.inject \n                scan_length scan_nth)"], ["proof (state)\nthis:\n  \\<nexists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     states p q1 ! i1 = states p q1 ! i2 \\<and>\n     i1 \\<le> length (states p q1) \\<and> i2 \\<le> length (states p q1)\n\ngoal (1 subgoal):\n 1. \\<nexists>i1 i2.\n       i1 \\<noteq> i2 \\<and>\n       target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n       i1 \\<le> length p \\<and> i2 \\<le> length p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     states p q1 ! i1 = states p q1 ! i2 \\<and>\n     i1 \\<le> length (states p q1) \\<and> i2 \\<le> length (states p q1)", "have \"distinct (states p q1)\""], ["proof (prove)\nusing this:\n  \\<nexists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     states p q1 ! i1 = states p q1 ! i2 \\<and>\n     i1 \\<le> length (states p q1) \\<and> i2 \\<le> length (states p q1)\n\ngoal (1 subgoal):\n 1. distinct (states p q1)", "using non_distinct_duplicate_indices"], ["proof (prove)\nusing this:\n  \\<nexists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     states p q1 ! i1 = states p q1 ! i2 \\<and>\n     i1 \\<le> length (states p q1) \\<and> i2 \\<le> length (states p q1)\n  \\<not> distinct ?xs \\<Longrightarrow>\n  \\<exists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     ?xs ! i1 = ?xs ! i2 \\<and>\n     i1 \\<le> length ?xs \\<and> i2 \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. distinct (states p q1)", "by blast"], ["proof (state)\nthis:\n  distinct (states p q1)\n\ngoal (1 subgoal):\n 1. \\<nexists>i1 i2.\n       i1 \\<noteq> i2 \\<and>\n       target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n       i1 \\<le> length p \\<and> i2 \\<le> length p \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  distinct (states p q1)", "show \"False\""], ["proof (prove)\nusing this:\n  distinct (states p q1)\n\ngoal (1 subgoal):\n 1. False", "using assm'"], ["proof (prove)\nusing this:\n  distinct (states p q1)\n  path M p q1 \\<and> target p q1 = q2 \\<and> \\<not> distinct (states p q1)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n     i1 \\<le> length p \\<and> i2 \\<le> length p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "then"], ["proof (chain)\npicking this:\n  \\<exists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n     i1 \\<le> length p \\<and> i2 \\<le> length p", "obtain i1 i2 where i_def : \"i1 < i2 \\<and> target (take i1 p) q1 = target (take i2 p) q1 \n                                          \\<and> i1 \\<le> length p \\<and> i2 \\<le> length p\""], ["proof (prove)\nusing this:\n  \\<exists>i1 i2.\n     i1 \\<noteq> i2 \\<and>\n     target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n     i1 \\<le> length p \\<and> i2 \\<le> length p\n\ngoal (1 subgoal):\n 1. (\\<And>i1 i2.\n        i1 < i2 \\<and>\n        target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n        i1 \\<le> length p \\<and> i2 \\<le> length p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis nat_neq_iff)"], ["proof (state)\nthis:\n  i1 < i2 \\<and>\n  target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n  i1 \\<le> length p \\<and> i2 \\<le> length p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "then"], ["proof (chain)\npicking this:\n  i1 < i2 \\<and>\n  target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n  i1 \\<le> length p \\<and> i2 \\<le> length p", "have \"path M (take i1 p) q1\""], ["proof (prove)\nusing this:\n  i1 < i2 \\<and>\n  target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n  i1 \\<le> length p \\<and> i2 \\<le> length p\n\ngoal (1 subgoal):\n 1. path M (take i1 p) q1", "using assm"], ["proof (prove)\nusing this:\n  i1 < i2 \\<and>\n  target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n  i1 \\<le> length p \\<and> i2 \\<le> length p\n  path M p q1 \\<and>\n  target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. path M (take i1 p) q1", "by (metis FSM.path_append_elim append_take_drop_id)"], ["proof (state)\nthis:\n  path M (take i1 p) q1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "moreover"], ["proof (state)\nthis:\n  path M (take i1 p) q1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "have \"path M (drop i2 p) (target (take i2 p) q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M (drop i2 p) (target (take i2 p) q1)", "by (metis FSM.path_append_elim append_take_drop_id assm)"], ["proof (state)\nthis:\n  path M (drop i2 p) (target (take i2 p) q1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "ultimately"], ["proof (chain)\npicking this:\n  path M (take i1 p) q1\n  path M (drop i2 p) (target (take i2 p) q1)", "have \"path M ((take i1 p) @ (drop i2 p)) q1 \n                          \\<and> (target ((take i1 p) @ (drop i2 p)) q1 = q2)\""], ["proof (prove)\nusing this:\n  path M (take i1 p) q1\n  path M (drop i2 p) (target (take i2 p) q1)\n\ngoal (1 subgoal):\n 1. path M (take i1 p @ drop i2 p) q1 \\<and>\n    target (take i1 p @ drop i2 p) q1 = q2", "using i_def assm"], ["proof (prove)\nusing this:\n  path M (take i1 p) q1\n  path M (drop i2 p) (target (take i2 p) q1)\n  i1 < i2 \\<and>\n  target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n  i1 \\<le> length p \\<and> i2 \\<le> length p\n  path M p q1 \\<and>\n  target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. path M (take i1 p @ drop i2 p) q1 \\<and>\n    target (take i1 p @ drop i2 p) q1 = q2", "by (metis FSM.path_append append_take_drop_id fold_append o_apply)"], ["proof (state)\nthis:\n  path M (take i1 p @ drop i2 p) q1 \\<and>\n  target (take i1 p @ drop i2 p) q1 = q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "moreover"], ["proof (state)\nthis:\n  path M (take i1 p @ drop i2 p) q1 \\<and>\n  target (take i1 p @ drop i2 p) q1 = q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "have \"length ((take i1 p) @ (drop i2 p)) < length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take i1 p @ drop i2 p) < length p", "using i_def"], ["proof (prove)\nusing this:\n  i1 < i2 \\<and>\n  target (take i1 p) q1 = target (take i2 p) q1 \\<and>\n  i1 \\<le> length p \\<and> i2 \\<le> length p\n\ngoal (1 subgoal):\n 1. length (take i1 p @ drop i2 p) < length p", "by auto"], ["proof (state)\nthis:\n  length (take i1 p @ drop i2 p) < length p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "ultimately"], ["proof (chain)\npicking this:\n  path M (take i1 p @ drop i2 p) q1 \\<and>\n  target (take i1 p @ drop i2 p) q1 = q2\n  length (take i1 p @ drop i2 p) < length p", "have \"path M ((take i1 p) @ (drop i2 p)) q1 \n                          \\<and> target ((take i1 p) @ (drop i2 p)) q1 = q2 \n                          \\<and> length ((take i1 p) @ (drop i2 p)) < length p\""], ["proof (prove)\nusing this:\n  path M (take i1 p @ drop i2 p) q1 \\<and>\n  target (take i1 p @ drop i2 p) q1 = q2\n  length (take i1 p @ drop i2 p) < length p\n\ngoal (1 subgoal):\n 1. path M (take i1 p @ drop i2 p) q1 \\<and>\n    target (take i1 p @ drop i2 p) q1 = q2 \\<and>\n    length (take i1 p @ drop i2 p) < length p", "by simp"], ["proof (state)\nthis:\n  path M (take i1 p @ drop i2 p) q1 \\<and>\n  target (take i1 p @ drop i2 p) q1 = q2 \\<and>\n  length (take i1 p @ drop i2 p) < length p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path M p q1 \\<and>\n             target p q1 = q2 \\<and> \\<not> distinct (q1 # states p q1);\n     q1 \\<notin> set (states p q1)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p'.\n                         path M p' q1 \\<and>\n                         target p' q1 = q2 \\<and> length p' < length p", "then"], ["proof (chain)\npicking this:\n  path M (take i1 p @ drop i2 p) q1 \\<and>\n  target (take i1 p @ drop i2 p) q1 = q2 \\<and>\n  length (take i1 p @ drop i2 p) < length p", "show ?thesis"], ["proof (prove)\nusing this:\n  path M (take i1 p @ drop i2 p) q1 \\<and>\n  target (take i1 p @ drop i2 p) q1 = q2 \\<and>\n  length (take i1 p @ drop i2 p) < length p\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p", "using assms"], ["proof (prove)\nusing this:\n  path M (take i1 p @ drop i2 p) q1 \\<and>\n  target (take i1 p @ drop i2 p) q1 = q2 \\<and>\n  length (take i1 p @ drop i2 p) < length p\n  well_formed M\n  q2 \\<in> reachable M q1\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p", "by blast"], ["proof (state)\nthis:\n  \\<exists>p'.\n     path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p'.\n     path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path M p q1 \\<and>\n  target p q1 = q2 \\<and>\n  \\<not> distinct (q1 # states p q1) \\<longrightarrow>\n  (\\<exists>p'.\n      path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p.\n     path M p q1 \\<and>\n     target p q1 = q2 \\<and>\n     \\<not> distinct (q1 # states p q1) \\<longrightarrow>\n     (\\<exists>p'.\n         path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "obtain p where p_def : \"path M p q1 \\<and> target p q1 = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path M p q1 \\<and> target p q1 = q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  well_formed M\n  q2 \\<in> reachable M q1\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path M p q1 \\<and> target p q1 = q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M p q1 \\<and> target p q1 = q2\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "let ?paths = \"{p' . (path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' \\<le> length p)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "let ?minPath = \"arg_min length (\\<lambda> io . io \\<in> ?paths)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "have \"?paths \\<noteq> empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p'.\n     path M p' q1 \\<and>\n     target p' q1 = q2 \\<and> length p' \\<le> length p} \\<noteq>\n    {}", "using p_def"], ["proof (prove)\nusing this:\n  path M p q1 \\<and> target p q1 = q2\n\ngoal (1 subgoal):\n 1. {p'.\n     path M p' q1 \\<and>\n     target p' q1 = q2 \\<and> length p' \\<le> length p} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  {p'.\n   path M p' q1 \\<and>\n   target p' q1 = q2 \\<and> length p' \\<le> length p} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "moreover"], ["proof (state)\nthis:\n  {p'.\n   path M p' q1 \\<and>\n   target p' q1 = q2 \\<and> length p' \\<le> length p} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "have \"finite ?paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {p'.\n      path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' \\<le> length p}", "using assms"], ["proof (prove)\nusing this:\n  well_formed M\n  q2 \\<in> reachable M q1\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. finite\n     {p'.\n      path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' \\<le> length p}", "by (simp add: set_of_paths_finite)"], ["proof (state)\nthis:\n  finite\n   {p'.\n    path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' \\<le> length p}\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "ultimately"], ["proof (chain)\npicking this:\n  {p'.\n   path M p' q1 \\<and>\n   target p' q1 = q2 \\<and> length p' \\<le> length p} \\<noteq>\n  {}\n  finite\n   {p'.\n    path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' \\<le> length p}", "have minPath_def : \"?minPath \\<in> ?paths \\<and> (\\<forall> p' \\<in> ?paths . length ?minPath \\<le> length p')\""], ["proof (prove)\nusing this:\n  {p'.\n   path M p' q1 \\<and>\n   target p' q1 = q2 \\<and> length p' \\<le> length p} \\<noteq>\n  {}\n  finite\n   {p'.\n    path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' \\<le> length p}\n\ngoal (1 subgoal):\n 1. (ARG_MIN length io.\n        io \\<in> {p'.\n                  path M p' q1 \\<and>\n                  target p' q1 = q2 \\<and> length p' \\<le> length p})\n    \\<in> {p'.\n           path M p' q1 \\<and>\n           target p' q1 = q2 \\<and> length p' \\<le> length p} \\<and>\n    (\\<forall>p'\\<in>{p'.\n                      path M p' q1 \\<and>\n                      target p' q1 = q2 \\<and> length p' \\<le> length p}.\n        length\n         (ARG_MIN length io.\n             io \\<in> {p'.\n                       path M p' q1 \\<and>\n                       target p' q1 = q2 \\<and> length p' \\<le> length p})\n        \\<le> length p')", "by (meson arg_min_nat_lemma equals0I)"], ["proof (state)\nthis:\n  (ARG_MIN length io.\n      io \\<in> {p'.\n                path M p' q1 \\<and>\n                target p' q1 = q2 \\<and> length p' \\<le> length p})\n  \\<in> {p'.\n         path M p' q1 \\<and>\n         target p' q1 = q2 \\<and> length p' \\<le> length p} \\<and>\n  (\\<forall>p'\\<in>{p'.\n                    path M p' q1 \\<and>\n                    target p' q1 = q2 \\<and> length p' \\<le> length p}.\n      length\n       (ARG_MIN length io.\n           io \\<in> {p'.\n                     path M p' q1 \\<and>\n                     target p' q1 = q2 \\<and> length p' \\<le> length p})\n      \\<le> length p')\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "moreover"], ["proof (state)\nthis:\n  (ARG_MIN length io.\n      io \\<in> {p'.\n                path M p' q1 \\<and>\n                target p' q1 = q2 \\<and> length p' \\<le> length p})\n  \\<in> {p'.\n         path M p' q1 \\<and>\n         target p' q1 = q2 \\<and> length p' \\<le> length p} \\<and>\n  (\\<forall>p'\\<in>{p'.\n                    path M p' q1 \\<and>\n                    target p' q1 = q2 \\<and> length p' \\<le> length p}.\n      length\n       (ARG_MIN length io.\n           io \\<in> {p'.\n                     path M p' q1 \\<and>\n                     target p' q1 = q2 \\<and> length p' \\<le> length p})\n      \\<le> length p')\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "have \"distinct (q1 # states ?minPath q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (q1 #\n      states\n       (ARG_MIN length io.\n           io \\<in> {p'.\n                     path M p' q1 \\<and>\n                     target p' q1 = q2 \\<and> length p' \\<le> length p})\n       q1)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct\n            (q1 #\n             states\n              (ARG_MIN length io.\n                  io \\<in> {p'.\n                            path M p' q1 \\<and>\n                            target p' q1 = q2 \\<and>\n                            length p' \\<le> length p})\n              q1) \\<Longrightarrow>\n    False", "assume \"\\<not> distinct (q1 # states ?minPath q1)\""], ["proof (state)\nthis:\n  \\<not> distinct\n          (q1 #\n           states\n            (ARG_MIN length io.\n                io \\<in> {p'.\n                          path M p' q1 \\<and>\n                          target p' q1 = q2 \\<and>\n                          length p' \\<le> length p})\n            q1)\n\ngoal (1 subgoal):\n 1. \\<not> distinct\n            (q1 #\n             states\n              (ARG_MIN length io.\n                  io \\<in> {p'.\n                            path M p' q1 \\<and>\n                            target p' q1 = q2 \\<and>\n                            length p' \\<le> length p})\n              q1) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct\n          (q1 #\n           states\n            (ARG_MIN length io.\n                io \\<in> {p'.\n                          path M p' q1 \\<and>\n                          target p' q1 = q2 \\<and>\n                          length p' \\<le> length p})\n            q1)", "have \"\\<exists> p' . path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length ?minPath\""], ["proof (prove)\nusing this:\n  \\<not> distinct\n          (q1 #\n           states\n            (ARG_MIN length io.\n                io \\<in> {p'.\n                          path M p' q1 \\<and>\n                          target p' q1 = q2 \\<and>\n                          length p' \\<le> length p})\n            q1)\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       path M p' q1 \\<and>\n       target p' q1 = q2 \\<and>\n       length p'\n       < length\n          (ARG_MIN length io.\n              io \\<in> {p'.\n                        path M p' q1 \\<and>\n                        target p' q1 = q2 \\<and> length p' \\<le> length p})", "using shorten_nondistinct minPath_def"], ["proof (prove)\nusing this:\n  \\<not> distinct\n          (q1 #\n           states\n            (ARG_MIN length io.\n                io \\<in> {p'.\n                          path M p' q1 \\<and>\n                          target p' q1 = q2 \\<and>\n                          length p' \\<le> length p})\n            q1)\n  \\<forall>p.\n     path M p q1 \\<and>\n     target p q1 = q2 \\<and>\n     \\<not> distinct (q1 # states p q1) \\<longrightarrow>\n     (\\<exists>p'.\n         path M p' q1 \\<and> target p' q1 = q2 \\<and> length p' < length p)\n  (ARG_MIN length io.\n      io \\<in> {p'.\n                path M p' q1 \\<and>\n                target p' q1 = q2 \\<and> length p' \\<le> length p})\n  \\<in> {p'.\n         path M p' q1 \\<and>\n         target p' q1 = q2 \\<and> length p' \\<le> length p} \\<and>\n  (\\<forall>p'\\<in>{p'.\n                    path M p' q1 \\<and>\n                    target p' q1 = q2 \\<and> length p' \\<le> length p}.\n      length\n       (ARG_MIN length io.\n           io \\<in> {p'.\n                     path M p' q1 \\<and>\n                     target p' q1 = q2 \\<and> length p' \\<le> length p})\n      \\<le> length p')\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       path M p' q1 \\<and>\n       target p' q1 = q2 \\<and>\n       length p'\n       < length\n          (ARG_MIN length io.\n              io \\<in> {p'.\n                        path M p' q1 \\<and>\n                        target p' q1 = q2 \\<and> length p' \\<le> length p})", "by blast"], ["proof (state)\nthis:\n  \\<exists>p'.\n     path M p' q1 \\<and>\n     target p' q1 = q2 \\<and>\n     length p'\n     < length\n        (ARG_MIN length io.\n            io \\<in> {p'.\n                      path M p' q1 \\<and>\n                      target p' q1 = q2 \\<and> length p' \\<le> length p})\n\ngoal (1 subgoal):\n 1. \\<not> distinct\n            (q1 #\n             states\n              (ARG_MIN length io.\n                  io \\<in> {p'.\n                            path M p' q1 \\<and>\n                            target p' q1 = q2 \\<and>\n                            length p' \\<le> length p})\n              q1) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>p'.\n     path M p' q1 \\<and>\n     target p' q1 = q2 \\<and>\n     length p'\n     < length\n        (ARG_MIN length io.\n            io \\<in> {p'.\n                      path M p' q1 \\<and>\n                      target p' q1 = q2 \\<and> length p' \\<le> length p})", "show \"False\""], ["proof (prove)\nusing this:\n  \\<exists>p'.\n     path M p' q1 \\<and>\n     target p' q1 = q2 \\<and>\n     length p'\n     < length\n        (ARG_MIN length io.\n            io \\<in> {p'.\n                      path M p' q1 \\<and>\n                      target p' q1 = q2 \\<and> length p' \\<le> length p})\n\ngoal (1 subgoal):\n 1. False", "using minPath_def"], ["proof (prove)\nusing this:\n  \\<exists>p'.\n     path M p' q1 \\<and>\n     target p' q1 = q2 \\<and>\n     length p'\n     < length\n        (ARG_MIN length io.\n            io \\<in> {p'.\n                      path M p' q1 \\<and>\n                      target p' q1 = q2 \\<and> length p' \\<le> length p})\n  (ARG_MIN length io.\n      io \\<in> {p'.\n                path M p' q1 \\<and>\n                target p' q1 = q2 \\<and> length p' \\<le> length p})\n  \\<in> {p'.\n         path M p' q1 \\<and>\n         target p' q1 = q2 \\<and> length p' \\<le> length p} \\<and>\n  (\\<forall>p'\\<in>{p'.\n                    path M p' q1 \\<and>\n                    target p' q1 = q2 \\<and> length p' \\<le> length p}.\n      length\n       (ARG_MIN length io.\n           io \\<in> {p'.\n                     path M p' q1 \\<and>\n                     target p' q1 = q2 \\<and> length p' \\<le> length p})\n      \\<le> length p')\n\ngoal (1 subgoal):\n 1. False", "using arg_min_nat_le dual_order.strict_trans1"], ["proof (prove)\nusing this:\n  \\<exists>p'.\n     path M p' q1 \\<and>\n     target p' q1 = q2 \\<and>\n     length p'\n     < length\n        (ARG_MIN length io.\n            io \\<in> {p'.\n                      path M p' q1 \\<and>\n                      target p' q1 = q2 \\<and> length p' \\<le> length p})\n  (ARG_MIN length io.\n      io \\<in> {p'.\n                path M p' q1 \\<and>\n                target p' q1 = q2 \\<and> length p' \\<le> length p})\n  \\<in> {p'.\n         path M p' q1 \\<and>\n         target p' q1 = q2 \\<and> length p' \\<le> length p} \\<and>\n  (\\<forall>p'\\<in>{p'.\n                    path M p' q1 \\<and>\n                    target p' q1 = q2 \\<and> length p' \\<le> length p}.\n      length\n       (ARG_MIN length io.\n           io \\<in> {p'.\n                     path M p' q1 \\<and>\n                     target p' q1 = q2 \\<and> length p' \\<le> length p})\n      \\<le> length p')\n  ?P ?x \\<Longrightarrow> ?m (arg_min ?m ?P) \\<le> ?m ?x\n  \\<lbrakk>?b \\<le> ?a; ?c < ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct\n   (q1 #\n    states\n     (ARG_MIN length io.\n         io \\<in> {p'.\n                   path M p' q1 \\<and>\n                   target p' q1 = q2 \\<and> length p' \\<le> length p})\n     q1)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "ultimately"], ["proof (chain)\npicking this:\n  (ARG_MIN length io.\n      io \\<in> {p'.\n                path M p' q1 \\<and>\n                target p' q1 = q2 \\<and> length p' \\<le> length p})\n  \\<in> {p'.\n         path M p' q1 \\<and>\n         target p' q1 = q2 \\<and> length p' \\<le> length p} \\<and>\n  (\\<forall>p'\\<in>{p'.\n                    path M p' q1 \\<and>\n                    target p' q1 = q2 \\<and> length p' \\<le> length p}.\n      length\n       (ARG_MIN length io.\n           io \\<in> {p'.\n                     path M p' q1 \\<and>\n                     target p' q1 = q2 \\<and> length p' \\<le> length p})\n      \\<le> length p')\n  distinct\n   (q1 #\n    states\n     (ARG_MIN length io.\n         io \\<in> {p'.\n                   path M p' q1 \\<and>\n                   target p' q1 = q2 \\<and> length p' \\<le> length p})\n     q1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (ARG_MIN length io.\n      io \\<in> {p'.\n                path M p' q1 \\<and>\n                target p' q1 = q2 \\<and> length p' \\<le> length p})\n  \\<in> {p'.\n         path M p' q1 \\<and>\n         target p' q1 = q2 \\<and> length p' \\<le> length p} \\<and>\n  (\\<forall>p'\\<in>{p'.\n                    path M p' q1 \\<and>\n                    target p' q1 = q2 \\<and> length p' \\<le> length p}.\n      length\n       (ARG_MIN length io.\n           io \\<in> {p'.\n                     path M p' q1 \\<and>\n                     target p' q1 = q2 \\<and> length p' \\<le> length p})\n      \\<le> length p')\n  distinct\n   (q1 #\n    states\n     (ARG_MIN length io.\n         io \\<in> {p'.\n                   path M p' q1 \\<and>\n                   target p' q1 = q2 \\<and> length p' \\<le> length p})\n     q1)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path M p q1 \\<and>\n       target p q1 = q2 \\<and> distinct (q1 # states p q1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>p.\n     path M p q1 \\<and> target p q1 = q2 \\<and> distinct (q1 # states p q1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_path_unique[simp] :\n  assumes \"io \\<in> LS M q\"\n  and     \"observable M\"\n  and     \"path M (io || tr1) q\" \"length io = length tr1\"\n  and     \"path M (io || tr2) q\" \"length io = length tr2\"\nshows \"tr1 = tr2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr1 = tr2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. tr1 \\<noteq> tr2 \\<Longrightarrow> False", "assume tr_assm : \"tr1 \\<noteq> tr2\""], ["proof (state)\nthis:\n  tr1 \\<noteq> tr2\n\ngoal (1 subgoal):\n 1. tr1 \\<noteq> tr2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  tr1 \\<noteq> tr2", "have state_diff : \"(states (io || tr1) q ) \\<noteq> (states (io || tr2) q)\""], ["proof (prove)\nusing this:\n  tr1 \\<noteq> tr2\n\ngoal (1 subgoal):\n 1. states (io || tr1) q \\<noteq> states (io || tr2) q", "by (metis assms(4) assms(6) map_snd_zip states_alt_def)"], ["proof (state)\nthis:\n  states (io || tr1) q \\<noteq> states (io || tr2) q\n\ngoal (1 subgoal):\n 1. tr1 \\<noteq> tr2 \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms tr_assm"], ["proof (prove)\nusing this:\n  io \\<in> LS M q\n  observable M\n  path M (io || tr1) q\n  length io = length tr1\n  path M (io || tr2) q\n  length io = length tr2\n  tr1 \\<noteq> tr2\n\ngoal (1 subgoal):\n 1. False", "proof (induction io arbitrary: q tr1 tr2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q tr1 tr2.\n       \\<lbrakk>[] \\<in> LS M q; observable M; path M ([] || tr1) q;\n        length [] = length tr1; path M ([] || tr2) q;\n        length [] = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a io q tr1 tr2.\n       \\<lbrakk>\\<And>q tr1 tr2.\n                   \\<lbrakk>io \\<in> LS M q; observable M;\n                    path M (io || tr1) q; length io = length tr1;\n                    path M (io || tr2) q; length io = length tr2;\n                    tr1 \\<noteq> tr2\\<rbrakk>\n                   \\<Longrightarrow> False;\n        a # io \\<in> LS M q; observable M; path M (a # io || tr1) q;\n        length (a # io) = length tr1; path M (a # io || tr2) q;\n        length (a # io) = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> LS M q\n  observable M\n  path M ([] || tr1) q\n  length [] = length tr1\n  path M ([] || tr2) q\n  length [] = length tr2\n  tr1 \\<noteq> tr2\n\ngoal (2 subgoals):\n 1. \\<And>q tr1 tr2.\n       \\<lbrakk>[] \\<in> LS M q; observable M; path M ([] || tr1) q;\n        length [] = length tr1; path M ([] || tr2) q;\n        length [] = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a io q tr1 tr2.\n       \\<lbrakk>\\<And>q tr1 tr2.\n                   \\<lbrakk>io \\<in> LS M q; observable M;\n                    path M (io || tr1) q; length io = length tr1;\n                    path M (io || tr2) q; length io = length tr2;\n                    tr1 \\<noteq> tr2\\<rbrakk>\n                   \\<Longrightarrow> False;\n        a # io \\<in> LS M q; observable M; path M (a # io || tr1) q;\n        length (a # io) = length tr1; path M (a # io || tr2) q;\n        length (a # io) = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  [] \\<in> LS M q\n  observable M\n  path M ([] || tr1) q\n  length [] = length tr1\n  path M ([] || tr2) q\n  length [] = length tr2\n  tr1 \\<noteq> tr2", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<in> LS M q\n  observable M\n  path M ([] || tr1) q\n  length [] = length tr1\n  path M ([] || tr2) q\n  length [] = length tr2\n  tr1 \\<noteq> tr2\n\ngoal (1 subgoal):\n 1. False", "using Nil"], ["proof (prove)\nusing this:\n  [] \\<in> LS M q\n  observable M\n  path M ([] || tr1) q\n  length [] = length tr1\n  path M ([] || tr2) q\n  length [] = length tr2\n  tr1 \\<noteq> tr2\n  [] \\<in> LS M q\n  observable M\n  path M ([] || tr1) q\n  length [] = length tr1\n  path M ([] || tr2) q\n  length [] = length tr2\n  tr1 \\<noteq> tr2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a io q tr1 tr2.\n       \\<lbrakk>\\<And>q tr1 tr2.\n                   \\<lbrakk>io \\<in> LS M q; observable M;\n                    path M (io || tr1) q; length io = length tr1;\n                    path M (io || tr2) q; length io = length tr2;\n                    tr1 \\<noteq> tr2\\<rbrakk>\n                   \\<Longrightarrow> False;\n        a # io \\<in> LS M q; observable M; path M (a # io || tr1) q;\n        length (a # io) = length tr1; path M (a # io || tr2) q;\n        length (a # io) = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a io q tr1 tr2.\n       \\<lbrakk>\\<And>q tr1 tr2.\n                   \\<lbrakk>io \\<in> LS M q; observable M;\n                    path M (io || tr1) q; length io = length tr1;\n                    path M (io || tr2) q; length io = length tr2;\n                    tr1 \\<noteq> tr2\\<rbrakk>\n                   \\<Longrightarrow> False;\n        a # io \\<in> LS M q; observable M; path M (a # io || tr1) q;\n        length (a # io) = length tr1; path M (a # io || tr2) q;\n        length (a # io) = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False", "case (Cons io_hd io_tl)"], ["proof (state)\nthis:\n  \\<lbrakk>io_tl \\<in> LS M ?q; observable M; path M (io_tl || ?tr1.0) ?q;\n   length io_tl = length ?tr1.0; path M (io_tl || ?tr2.0) ?q;\n   length io_tl = length ?tr2.0; ?tr1.0 \\<noteq> ?tr2.0\\<rbrakk>\n  \\<Longrightarrow> False\n  io_hd # io_tl \\<in> LS M q\n  observable M\n  path M (io_hd # io_tl || tr1) q\n  length (io_hd # io_tl) = length tr1\n  path M (io_hd # io_tl || tr2) q\n  length (io_hd # io_tl) = length tr2\n  tr1 \\<noteq> tr2\n\ngoal (1 subgoal):\n 1. \\<And>a io q tr1 tr2.\n       \\<lbrakk>\\<And>q tr1 tr2.\n                   \\<lbrakk>io \\<in> LS M q; observable M;\n                    path M (io || tr1) q; length io = length tr1;\n                    path M (io || tr2) q; length io = length tr2;\n                    tr1 \\<noteq> tr2\\<rbrakk>\n                   \\<Longrightarrow> False;\n        a # io \\<in> LS M q; observable M; path M (a # io || tr1) q;\n        length (a # io) = length tr1; path M (a # io || tr2) q;\n        length (a # io) = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>io_tl \\<in> LS M ?q; observable M; path M (io_tl || ?tr1.0) ?q;\n   length io_tl = length ?tr1.0; path M (io_tl || ?tr2.0) ?q;\n   length io_tl = length ?tr2.0; ?tr1.0 \\<noteq> ?tr2.0\\<rbrakk>\n  \\<Longrightarrow> False\n  io_hd # io_tl \\<in> LS M q\n  observable M\n  path M (io_hd # io_tl || tr1) q\n  length (io_hd # io_tl) = length tr1\n  path M (io_hd # io_tl || tr2) q\n  length (io_hd # io_tl) = length tr2\n  tr1 \\<noteq> tr2", "obtain tr1_hd tr1_tl tr2_hd tr2_tl where tr_split : \"tr1 = tr1_hd # tr1_tl \n                                                              \\<and> tr2 = tr2_hd # tr2_tl\""], ["proof (prove)\nusing this:\n  \\<lbrakk>io_tl \\<in> LS M ?q; observable M; path M (io_tl || ?tr1.0) ?q;\n   length io_tl = length ?tr1.0; path M (io_tl || ?tr2.0) ?q;\n   length io_tl = length ?tr2.0; ?tr1.0 \\<noteq> ?tr2.0\\<rbrakk>\n  \\<Longrightarrow> False\n  io_hd # io_tl \\<in> LS M q\n  observable M\n  path M (io_hd # io_tl || tr1) q\n  length (io_hd # io_tl) = length tr1\n  path M (io_hd # io_tl || tr2) q\n  length (io_hd # io_tl) = length tr2\n  tr1 \\<noteq> tr2\n\ngoal (1 subgoal):\n 1. (\\<And>tr1_hd tr1_tl tr2_hd tr2_tl.\n        tr1 = tr1_hd # tr1_tl \\<and> tr2 = tr2_hd # tr2_tl \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis length_0_conv neq_Nil_conv)"], ["proof (state)\nthis:\n  tr1 = tr1_hd # tr1_tl \\<and> tr2 = tr2_hd # tr2_tl\n\ngoal (1 subgoal):\n 1. \\<And>a io q tr1 tr2.\n       \\<lbrakk>\\<And>q tr1 tr2.\n                   \\<lbrakk>io \\<in> LS M q; observable M;\n                    path M (io || tr1) q; length io = length tr1;\n                    path M (io || tr2) q; length io = length tr2;\n                    tr1 \\<noteq> tr2\\<rbrakk>\n                   \\<Longrightarrow> False;\n        a # io \\<in> LS M q; observable M; path M (a # io || tr1) q;\n        length (a # io) = length tr1; path M (a # io || tr2) q;\n        length (a # io) = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False", "have p1: \"path M ([io_hd] || [tr1_hd]) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M ([io_hd] || [tr1_hd]) q", "using Cons.prems tr_split"], ["proof (prove)\nusing this:\n  io_hd # io_tl \\<in> LS M q\n  observable M\n  path M (io_hd # io_tl || tr1) q\n  length (io_hd # io_tl) = length tr1\n  path M (io_hd # io_tl || tr2) q\n  length (io_hd # io_tl) = length tr2\n  tr1 \\<noteq> tr2\n  tr1 = tr1_hd # tr1_tl \\<and> tr2 = tr2_hd # tr2_tl\n\ngoal (1 subgoal):\n 1. path M ([io_hd] || [tr1_hd]) q", "by auto"], ["proof (state)\nthis:\n  path M ([io_hd] || [tr1_hd]) q\n\ngoal (1 subgoal):\n 1. \\<And>a io q tr1 tr2.\n       \\<lbrakk>\\<And>q tr1 tr2.\n                   \\<lbrakk>io \\<in> LS M q; observable M;\n                    path M (io || tr1) q; length io = length tr1;\n                    path M (io || tr2) q; length io = length tr2;\n                    tr1 \\<noteq> tr2\\<rbrakk>\n                   \\<Longrightarrow> False;\n        a # io \\<in> LS M q; observable M; path M (a # io || tr1) q;\n        length (a # io) = length tr1; path M (a # io || tr2) q;\n        length (a # io) = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False", "have p2: \"path M ([io_hd] || [tr2_hd]) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M ([io_hd] || [tr2_hd]) q", "using Cons.prems tr_split"], ["proof (prove)\nusing this:\n  io_hd # io_tl \\<in> LS M q\n  observable M\n  path M (io_hd # io_tl || tr1) q\n  length (io_hd # io_tl) = length tr1\n  path M (io_hd # io_tl || tr2) q\n  length (io_hd # io_tl) = length tr2\n  tr1 \\<noteq> tr2\n  tr1 = tr1_hd # tr1_tl \\<and> tr2 = tr2_hd # tr2_tl\n\ngoal (1 subgoal):\n 1. path M ([io_hd] || [tr2_hd]) q", "by auto"], ["proof (state)\nthis:\n  path M ([io_hd] || [tr2_hd]) q\n\ngoal (1 subgoal):\n 1. \\<And>a io q tr1 tr2.\n       \\<lbrakk>\\<And>q tr1 tr2.\n                   \\<lbrakk>io \\<in> LS M q; observable M;\n                    path M (io || tr1) q; length io = length tr1;\n                    path M (io || tr2) q; length io = length tr2;\n                    tr1 \\<noteq> tr2\\<rbrakk>\n                   \\<Longrightarrow> False;\n        a # io \\<in> LS M q; observable M; path M (a # io || tr1) q;\n        length (a # io) = length tr1; path M (a # io || tr2) q;\n        length (a # io) = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False", "have tr_hd_eq : \"tr1_hd = tr2_hd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr1_hd = tr2_hd", "using Cons.prems"], ["proof (prove)\nusing this:\n  io_hd # io_tl \\<in> LS M q\n  observable M\n  path M (io_hd # io_tl || tr1) q\n  length (io_hd # io_tl) = length tr1\n  path M (io_hd # io_tl || tr2) q\n  length (io_hd # io_tl) = length tr2\n  tr1 \\<noteq> tr2\n\ngoal (1 subgoal):\n 1. tr1_hd = tr2_hd", "unfolding observable.simps"], ["proof (prove)\nusing this:\n  io_hd # io_tl \\<in> LS M q\n  \\<forall>t s1. succ M t s1 = {} \\<or> (\\<exists>s2. succ M t s1 = {s2})\n  path M (io_hd # io_tl || tr1) q\n  length (io_hd # io_tl) = length tr1\n  path M (io_hd # io_tl || tr2) q\n  length (io_hd # io_tl) = length tr2\n  tr1 \\<noteq> tr2\n\ngoal (1 subgoal):\n 1. tr1_hd = tr2_hd", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>io_hd # io_tl \\<in> LS M q;\n     \\<forall>t s1.\n        succ M t s1 = {} \\<or> (\\<exists>s2. succ M t s1 = {s2});\n     path M (io_hd # io_tl || tr1) q; length (io_hd # io_tl) = length tr1;\n     path M (io_hd # io_tl || tr2) q; length (io_hd # io_tl) = length tr2;\n     tr1 \\<noteq> tr2\\<rbrakk>\n    \\<Longrightarrow> tr1_hd = tr2_hd", "assume \"\\<forall>t s1. succ M t s1 = {} \\<or> (\\<exists>s2. succ M t s1 = {s2})\""], ["proof (state)\nthis:\n  \\<forall>t s1. succ M t s1 = {} \\<or> (\\<exists>s2. succ M t s1 = {s2})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>io_hd # io_tl \\<in> LS M q;\n     \\<forall>t s1.\n        succ M t s1 = {} \\<or> (\\<exists>s2. succ M t s1 = {s2});\n     path M (io_hd # io_tl || tr1) q; length (io_hd # io_tl) = length tr1;\n     path M (io_hd # io_tl || tr2) q; length (io_hd # io_tl) = length tr2;\n     tr1 \\<noteq> tr2\\<rbrakk>\n    \\<Longrightarrow> tr1_hd = tr2_hd", "then"], ["proof (chain)\npicking this:\n  \\<forall>t s1. succ M t s1 = {} \\<or> (\\<exists>s2. succ M t s1 = {s2})", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t s1. succ M t s1 = {} \\<or> (\\<exists>s2. succ M t s1 = {s2})\n\ngoal (1 subgoal):\n 1. tr1_hd = tr2_hd", "by (metis (no_types) p1 p2 FSM.path_cons_elim empty_iff prod.sel(1) prod.sel(2) singletonD \n            zip_Cons_Cons)"], ["proof (state)\nthis:\n  tr1_hd = tr2_hd\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tr1_hd = tr2_hd\n\ngoal (1 subgoal):\n 1. \\<And>a io q tr1 tr2.\n       \\<lbrakk>\\<And>q tr1 tr2.\n                   \\<lbrakk>io \\<in> LS M q; observable M;\n                    path M (io || tr1) q; length io = length tr1;\n                    path M (io || tr2) q; length io = length tr2;\n                    tr1 \\<noteq> tr2\\<rbrakk>\n                   \\<Longrightarrow> False;\n        a # io \\<in> LS M q; observable M; path M (a # io || tr1) q;\n        length (a # io) = length tr1; path M (a # io || tr2) q;\n        length (a # io) = length tr2; tr1 \\<noteq> tr2\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  tr1_hd = tr2_hd", "show ?thesis"], ["proof (prove)\nusing this:\n  tr1_hd = tr2_hd\n\ngoal (1 subgoal):\n 1. False", "using Cons.IH Cons.prems(3) Cons.prems(4) Cons.prems(5) Cons.prems(6) Cons.prems(7) assms(2) \n            tr_split"], ["proof (prove)\nusing this:\n  tr1_hd = tr2_hd\n  \\<lbrakk>io_tl \\<in> LS M ?q; observable M; path M (io_tl || ?tr1.0) ?q;\n   length io_tl = length ?tr1.0; path M (io_tl || ?tr2.0) ?q;\n   length io_tl = length ?tr2.0; ?tr1.0 \\<noteq> ?tr2.0\\<rbrakk>\n  \\<Longrightarrow> False\n  path M (io_hd # io_tl || tr1) q\n  length (io_hd # io_tl) = length tr1\n  path M (io_hd # io_tl || tr2) q\n  length (io_hd # io_tl) = length tr2\n  tr1 \\<noteq> tr2\n  observable M\n  tr1 = tr1_hd # tr1_tl \\<and> tr2 = tr2_hd # tr2_tl\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_path_unique_ex[elim] : \n  assumes \"observable M\"\n  and     \"io \\<in> LS M q\"\nobtains tr \nwhere \"{ t . path M (io || t) q \\<and> length io = length t } = { tr }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        {t. path M (io || t) q \\<and> length io = length t} =\n        {tr} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        {t. path M (io || t) q \\<and> length io = length t} =\n        {tr} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain tr where tr_def : \"path M (io || tr) q\" \"length io = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>path M (io || tr) q; length io = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  observable M\n  io \\<in> LS M q\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>path M (io || tr) q; length io = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M (io || tr) q\n  length io = length tr\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        {t. path M (io || t) q \\<and> length io = length t} =\n        {tr} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  path M (io || tr) q\n  length io = length tr", "have \"{ t . path M (io || t) q \\<and> length io = length t } \\<noteq> {}\""], ["proof (prove)\nusing this:\n  path M (io || tr) q\n  length io = length tr\n\ngoal (1 subgoal):\n 1. {t. path M (io || t) q \\<and> length io = length t} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {t. path M (io || t) q \\<and> length io = length t} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        {t. path M (io || t) q \\<and> length io = length t} =\n        {tr} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  {t. path M (io || t) q \\<and> length io = length t} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        {t. path M (io || t) q \\<and> length io = length t} =\n        {tr} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall> t \\<in> { t . path M (io || t) q \\<and> length io = length t } . t = tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{t. path M (io || t) q \\<and> length io = length t}.\n       t = tr", "using assms tr_def"], ["proof (prove)\nusing this:\n  observable M\n  io \\<in> LS M q\n  path M (io || tr) q\n  length io = length tr\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{t. path M (io || t) q \\<and> length io = length t}.\n       t = tr", "by auto"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{t. path M (io || t) q \\<and> length io = length t}. t = tr\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        {t. path M (io || t) q \\<and> length io = length t} =\n        {tr} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  {t. path M (io || t) q \\<and> length io = length t} \\<noteq> {}\n  \\<forall>t\\<in>{t. path M (io || t) q \\<and> length io = length t}. t = tr", "show ?thesis"], ["proof (prove)\nusing this:\n  {t. path M (io || t) q \\<and> length io = length t} \\<noteq> {}\n  \\<forall>t\\<in>{t. path M (io || t) q \\<and> length io = length t}. t = tr\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  {t. path M (io || t) q \\<and> length io = length t} \\<noteq> {}\n  \\<forall>t\\<in>{t. path M (io || t) q \\<and> length io = length t}. t = tr\n  {t. path M (io || t) q \\<and> length io = length t} =\n  {?tr} \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by moura"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma well_formed_product[simp] :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\nshows \"well_formed (product M2 M1)\" (is \"well_formed ?PM\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_formed (product M2 M1)", "unfolding well_formed.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_FSM (product M2 M1) \\<and>\n    (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite_FSM (product M2 M1)\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "have \"finite (nodes M1)\" \"finite (nodes M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M1) &&& finite (nodes M2)", "using assms"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n\ngoal (1 subgoal):\n 1. finite (nodes M1) &&& finite (nodes M2)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M1)\n  finite (nodes M2)\n\ngoal (2 subgoals):\n 1. finite_FSM (product M2 M1)\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  finite (nodes M1)\n  finite (nodes M2)", "have \"finite (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\nusing this:\n  finite (nodes M1)\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. finite (nodes M2 \\<times> nodes M1)", "by simp"], ["proof (state)\nthis:\n  finite (nodes M2 \\<times> nodes M1)\n\ngoal (2 subgoals):\n 1. finite_FSM (product M2 M1)\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  finite (nodes M2 \\<times> nodes M1)\n\ngoal (2 subgoals):\n 1. finite_FSM (product M2 M1)\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "have \"nodes ?PM \\<subseteq> nodes M2 \\<times> nodes M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1", "using product_nodes assms"], ["proof (prove)\nusing this:\n  nodes (product ?A ?B) \\<subseteq> nodes ?A \\<times> nodes ?B\n  well_formed M1\n  well_formed M2\n\ngoal (1 subgoal):\n 1. nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1", "by blast"], ["proof (state)\nthis:\n  nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1\n\ngoal (2 subgoals):\n 1. finite_FSM (product M2 M1)\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  finite (nodes M2 \\<times> nodes M1)\n  nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1", "show \"finite_FSM ?PM\""], ["proof (prove)\nusing this:\n  finite (nodes M2 \\<times> nodes M1)\n  nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. finite_FSM (product M2 M1)", "using infinite_subset assms"], ["proof (prove)\nusing this:\n  finite (nodes M2 \\<times> nodes M1)\n  nodes (product M2 M1) \\<subseteq> nodes M2 \\<times> nodes M1\n  \\<lbrakk>infinite ?A; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> infinite ?B\n  well_formed M1\n  well_formed M2\n\ngoal (1 subgoal):\n 1. finite_FSM (product M2 M1)", "by auto"], ["proof (state)\nthis:\n  finite_FSM (product M2 M1)\n\ngoal (1 subgoal):\n 1. (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "have \"inputs ?PM = inputs M2 \\<union> inputs M1\" \n       \"outputs ?PM = outputs M2 \\<union> outputs M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputs (product M2 M1) = inputs M2 \\<union> inputs M1 &&&\n    outputs (product M2 M1) = outputs M2 \\<union> outputs M1", "by auto"], ["proof (state)\nthis:\n  inputs (product M2 M1) = inputs M2 \\<union> inputs M1\n  outputs (product M2 M1) = outputs M2 \\<union> outputs M1\n\ngoal (1 subgoal):\n 1. (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  inputs (product M2 M1) = inputs M2 \\<union> inputs M1\n  outputs (product M2 M1) = outputs M2 \\<union> outputs M1", "show \"(\\<forall>s1 x y. x \\<notin> inputs ?PM \\<or> y \\<notin> outputs ?PM \\<longrightarrow> succ ?PM (x, y) s1 = {}) \n                                                              \\<and> inputs ?PM \\<noteq> {} \\<and> outputs ?PM \\<noteq> {}\""], ["proof (prove)\nusing this:\n  inputs (product M2 M1) = inputs M2 \\<union> inputs M1\n  outputs (product M2 M1) = outputs M2 \\<union> outputs M1\n\ngoal (1 subgoal):\n 1. (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  inputs (product M2 M1) = inputs M2 \\<union> inputs M1\n  outputs (product M2 M1) = outputs M2 \\<union> outputs M1\n  well_formed M1\n  well_formed M2\n\ngoal (1 subgoal):\n 1. (\\<forall>s1 x y.\n        x \\<notin> inputs (product M2 M1) \\<or>\n        y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n        succ (product M2 M1) (x, y) s1 = {}) \\<and>\n    inputs (product M2 M1) \\<noteq> {} \\<and>\n    outputs (product M2 M1) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  (\\<forall>s1 x y.\n      x \\<notin> inputs (product M2 M1) \\<or>\n      y \\<notin> outputs (product M2 M1) \\<longrightarrow>\n      succ (product M2 M1) (x, y) s1 = {}) \\<and>\n  inputs (product M2 M1) \\<noteq> {} \\<and>\n  outputs (product M2 M1) \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> States reached by a given IO-sequence \\<close>"], ["", "text \\<open>\nFunction @{verbatim io_targets} collects all states of an FSM reached from a given state by a \ngiven IO-sequence.\nNotably, for any observable FSM, this set contains at most one state.\n\\<close>"], ["", "fun io_targets :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> 'state set\" where\n  \"io_targets M q io = { target (io || tr) q | tr . path M (io || tr) q \\<and> length io = length tr }\""], ["", "lemma io_target_implies_L :\n  assumes \"q \\<in> io_targets M (initial M) io\"\n  shows \"io \\<in> L M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> L M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io \\<in> L M", "obtain tr where \"path M (io || tr) (initial M)\" \n                  \"length tr = length io\" \n                  \"target (io || tr) (initial M) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>path M (io || tr) (initial M); length tr = length io;\n         target (io || tr) (initial M) = q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> io_targets M (initial M) io\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>path M (io || tr) (initial M); length tr = length io;\n         target (io || tr) (initial M) = q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M (io || tr) (initial M)\n  length tr = length io\n  target (io || tr) (initial M) = q\n\ngoal (1 subgoal):\n 1. io \\<in> L M", "then"], ["proof (chain)\npicking this:\n  path M (io || tr) (initial M)\n  length tr = length io\n  target (io || tr) (initial M) = q", "show ?thesis"], ["proof (prove)\nusing this:\n  path M (io || tr) (initial M)\n  length tr = length io\n  target (io || tr) (initial M) = q\n\ngoal (1 subgoal):\n 1. io \\<in> L M", "by auto"], ["proof (state)\nthis:\n  io \\<in> L M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma io_target_from_path :\n  assumes \"path M (w || tr) q\"\n  and     \"length w = length tr\"\nshows \"target (w || tr) q \\<in> io_targets M q w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w || tr) q \\<in> io_targets M q w", "using assms"], ["proof (prove)\nusing this:\n  path M (w || tr) q\n  length w = length tr\n\ngoal (1 subgoal):\n 1. target (w || tr) q \\<in> io_targets M q w", "by auto"], ["", "lemma io_targets_observable_singleton_ex :\n  assumes \"observable M\"\n  and     \"io \\<in> LS M q1\"\nshows \"\\<exists> q2 . io_targets M q1 io = { q2 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q2. io_targets M q1 io = {q2}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q2. io_targets M q1 io = {q2}", "obtain tr where tr_def : \"{ t . path M (io || t) q1 \\<and> length io = length t } = { tr }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        {t. path M (io || t) q1 \\<and> length io = length t} =\n        {tr} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms observable_path_unique_ex"], ["proof (prove)\nusing this:\n  observable M\n  io \\<in> LS M q1\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q;\n   \\<And>tr.\n      {t. path ?M (?io || t) ?q \\<and> length ?io = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        {t. path M (io || t) q1 \\<and> length io = length t} =\n        {tr} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  {t. path M (io || t) q1 \\<and> length io = length t} = {tr}\n\ngoal (1 subgoal):\n 1. \\<exists>q2. io_targets M q1 io = {q2}", "then"], ["proof (chain)\npicking this:\n  {t. path M (io || t) q1 \\<and> length io = length t} = {tr}", "have \"io_targets M q1 io = { target (io || tr) q1 }\""], ["proof (prove)\nusing this:\n  {t. path M (io || t) q1 \\<and> length io = length t} = {tr}\n\ngoal (1 subgoal):\n 1. io_targets M q1 io = {target (io || tr) q1}", "by fastforce"], ["proof (state)\nthis:\n  io_targets M q1 io = {target (io || tr) q1}\n\ngoal (1 subgoal):\n 1. \\<exists>q2. io_targets M q1 io = {q2}", "then"], ["proof (chain)\npicking this:\n  io_targets M q1 io = {target (io || tr) q1}", "show ?thesis"], ["proof (prove)\nusing this:\n  io_targets M q1 io = {target (io || tr) q1}\n\ngoal (1 subgoal):\n 1. \\<exists>q2. io_targets M q1 io = {q2}", "by blast"], ["proof (state)\nthis:\n  \\<exists>q2. io_targets M q1 io = {q2}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma io_targets_observable_singleton_ob :\n  assumes \"observable M\"\n  and     \"io \\<in> LS M q1\"\nobtains q2 \n  where \"io_targets M q1 io = { q2 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        io_targets M q1 io = {q2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        io_targets M q1 io = {q2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain tr where tr_def : \"{ t . path M (io || t) q1 \\<and> length io = length t } = { tr }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        {t. path M (io || t) q1 \\<and> length io = length t} =\n        {tr} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms observable_path_unique_ex"], ["proof (prove)\nusing this:\n  observable M\n  io \\<in> LS M q1\n  \\<lbrakk>observable ?M; ?io \\<in> LS ?M ?q;\n   \\<And>tr.\n      {t. path ?M (?io || t) ?q \\<and> length ?io = length t} =\n      {tr} \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        {t. path M (io || t) q1 \\<and> length io = length t} =\n        {tr} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  {t. path M (io || t) q1 \\<and> length io = length t} = {tr}\n\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        io_targets M q1 io = {q2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  {t. path M (io || t) q1 \\<and> length io = length t} = {tr}", "have \"io_targets M q1 io = { target (io || tr) q1 }\""], ["proof (prove)\nusing this:\n  {t. path M (io || t) q1 \\<and> length io = length t} = {tr}\n\ngoal (1 subgoal):\n 1. io_targets M q1 io = {target (io || tr) q1}", "by fastforce"], ["proof (state)\nthis:\n  io_targets M q1 io = {target (io || tr) q1}\n\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        io_targets M q1 io = {q2} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  io_targets M q1 io = {target (io || tr) q1}", "show ?thesis"], ["proof (prove)\nusing this:\n  io_targets M q1 io = {target (io || tr) q1}\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  io_targets M q1 io = {target (io || tr) q1}\n  io_targets M q1 io = {?q2.0} \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma io_targets_elim[elim] :\n  assumes \"p \\<in> io_targets M q io\"\nobtains tr \nwhere \"target (io || tr) q = p \\<and> path M (io || tr) q \\<and> length io = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        target (io || tr) q = p \\<and>\n        path M (io || tr) q \\<and> length io = length tr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> io_targets M q io\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        target (io || tr) q = p \\<and>\n        path M (io || tr) q \\<and> length io = length tr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding io_targets.simps"], ["proof (prove)\nusing this:\n  p \\<in> {target (io || tr) q |tr.\n           path M (io || tr) q \\<and> length io = length tr}\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        target (io || tr) q = p \\<and>\n        path M (io || tr) q \\<and> length io = length tr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["", "lemma io_targets_reachable :\n  assumes \"q2 \\<in> io_targets M q1 io\"\n  shows \"q2 \\<in> reachable M q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<in> reachable M q1", "using assms"], ["proof (prove)\nusing this:\n  q2 \\<in> io_targets M q1 io\n\ngoal (1 subgoal):\n 1. q2 \\<in> reachable M q1", "unfolding io_targets.simps"], ["proof (prove)\nusing this:\n  q2 \\<in> {target (io || tr) q1 |tr.\n            path M (io || tr) q1 \\<and> length io = length tr}\n\ngoal (1 subgoal):\n 1. q2 \\<in> reachable M q1", "by blast"], ["", "lemma io_targets_nodes :\n  assumes \"q2 \\<in> io_targets M q1 io\"\n  and     \"q1 \\<in> nodes M\"\nshows \"q2 \\<in> nodes M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M", "using assms"], ["proof (prove)\nusing this:\n  q2 \\<in> io_targets M q1 io\n  q1 \\<in> nodes M\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M", "by auto"], ["", "lemma observable_io_targets_split :\n  assumes \"observable M\"\n  and \"io_targets M q1 (vs @ xs) = {q3}\"\n  and \"io_targets M q1 vs = {q2}\"\nshows \"io_targets M q2 xs = {q3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "have \"vs @ xs \\<in> LS M q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ xs \\<in> LS M q1", "using assms(2)"], ["proof (prove)\nusing this:\n  io_targets M q1 (vs @ xs) = {q3}\n\ngoal (1 subgoal):\n 1. vs @ xs \\<in> LS M q1", "by force"], ["proof (state)\nthis:\n  vs @ xs \\<in> LS M q1\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "then"], ["proof (chain)\npicking this:\n  vs @ xs \\<in> LS M q1", "obtain trV trX where tr_def : \n        \"path M (vs || trV) q1\" \"length vs = length trV\"\n        \"path M (xs || trX) (target (vs || trV) q1)\" \"length xs = length trX\""], ["proof (prove)\nusing this:\n  vs @ xs \\<in> LS M q1\n\ngoal (1 subgoal):\n 1. (\\<And>trV trX.\n        \\<lbrakk>path M (vs || trV) q1; length vs = length trV;\n         path M (xs || trX) (target (vs || trV) q1);\n         length xs = length trX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using language_state_split[of vs xs M q1]"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> LS M q1\n  \\<lbrakk>vs @ xs \\<in> LS M q1;\n   \\<And>tr1 tr2.\n      \\<lbrakk>path M (vs || tr1) q1; length vs = length tr1;\n       path M (xs || tr2) (target (vs || tr1) q1);\n       length xs = length tr2\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>trV trX.\n        \\<lbrakk>path M (vs || trV) q1; length vs = length trV;\n         path M (xs || trX) (target (vs || trV) q1);\n         length xs = length trX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M (vs || trV) q1\n  length vs = length trV\n  path M (xs || trX) (target (vs || trV) q1)\n  length xs = length trX\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "then"], ["proof (chain)\npicking this:\n  path M (vs || trV) q1\n  length vs = length trV\n  path M (xs || trX) (target (vs || trV) q1)\n  length xs = length trX", "have tgt_V : \"target (vs || trV) q1 = q2\""], ["proof (prove)\nusing this:\n  path M (vs || trV) q1\n  length vs = length trV\n  path M (xs || trX) (target (vs || trV) q1)\n  length xs = length trX\n\ngoal (1 subgoal):\n 1. target (vs || trV) q1 = q2", "using assms(3)"], ["proof (prove)\nusing this:\n  path M (vs || trV) q1\n  length vs = length trV\n  path M (xs || trX) (target (vs || trV) q1)\n  length xs = length trX\n  io_targets M q1 vs = {q2}\n\ngoal (1 subgoal):\n 1. target (vs || trV) q1 = q2", "by auto"], ["proof (state)\nthis:\n  target (vs || trV) q1 = q2\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "then"], ["proof (chain)\npicking this:\n  target (vs || trV) q1 = q2", "have path_X : \"path M (xs || trX) q2 \\<and> length xs = length trX\""], ["proof (prove)\nusing this:\n  target (vs || trV) q1 = q2\n\ngoal (1 subgoal):\n 1. path M (xs || trX) q2 \\<and> length xs = length trX", "using tr_def"], ["proof (prove)\nusing this:\n  target (vs || trV) q1 = q2\n  path M (vs || trV) q1\n  length vs = length trV\n  path M (xs || trX) (target (vs || trV) q1)\n  length xs = length trX\n\ngoal (1 subgoal):\n 1. path M (xs || trX) q2 \\<and> length xs = length trX", "by auto"], ["proof (state)\nthis:\n  path M (xs || trX) q2 \\<and> length xs = length trX\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "have tgt_all :  \"target (vs @ xs || trV @ trX) q1 = q3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (vs @ xs || trV @ trX) q1 = q3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. target (vs @ xs || trV @ trX) q1 = q3", "have f1: \"\\<exists>cs. q3 = target (vs @ xs || cs) q1 \n                    \\<and> path M (vs @ xs || cs) q1 \\<and> length (vs @ xs) = length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       q3 = target (vs @ xs || cs) q1 \\<and>\n       path M (vs @ xs || cs) q1 \\<and> length (vs @ xs) = length cs", "using assms(2)"], ["proof (prove)\nusing this:\n  io_targets M q1 (vs @ xs) = {q3}\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       q3 = target (vs @ xs || cs) q1 \\<and>\n       path M (vs @ xs || cs) q1 \\<and> length (vs @ xs) = length cs", "by auto"], ["proof (state)\nthis:\n  \\<exists>cs.\n     q3 = target (vs @ xs || cs) q1 \\<and>\n     path M (vs @ xs || cs) q1 \\<and> length (vs @ xs) = length cs\n\ngoal (1 subgoal):\n 1. target (vs @ xs || trV @ trX) q1 = q3", "have \"length (vs @ xs) = length trV + length trX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (vs @ xs) = length trV + length trX", "by (simp add: tr_def(2) tr_def(4))"], ["proof (state)\nthis:\n  length (vs @ xs) = length trV + length trX\n\ngoal (1 subgoal):\n 1. target (vs @ xs || trV @ trX) q1 = q3", "then"], ["proof (chain)\npicking this:\n  length (vs @ xs) = length trV + length trX", "have \"length (vs @ xs) = length (trV @ trX)\""], ["proof (prove)\nusing this:\n  length (vs @ xs) = length trV + length trX\n\ngoal (1 subgoal):\n 1. length (vs @ xs) = length (trV @ trX)", "by simp"], ["proof (state)\nthis:\n  length (vs @ xs) = length (trV @ trX)\n\ngoal (1 subgoal):\n 1. target (vs @ xs || trV @ trX) q1 = q3", "then"], ["proof (chain)\npicking this:\n  length (vs @ xs) = length (trV @ trX)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (vs @ xs) = length (trV @ trX)\n\ngoal (1 subgoal):\n 1. target (vs @ xs || trV @ trX) q1 = q3", "using f1"], ["proof (prove)\nusing this:\n  length (vs @ xs) = length (trV @ trX)\n  \\<exists>cs.\n     q3 = target (vs @ xs || cs) q1 \\<and>\n     path M (vs @ xs || cs) q1 \\<and> length (vs @ xs) = length cs\n\ngoal (1 subgoal):\n 1. target (vs @ xs || trV @ trX) q1 = q3", "by (metis FSM.path_append \\<open>vs @ xs \\<in> LS M q1\\<close> assms(1) observable_path_unique \n                    tr_def(1) tr_def(2) tr_def(3) zip_append)"], ["proof (state)\nthis:\n  target (vs @ xs || trV @ trX) q1 = q3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  target (vs @ xs || trV @ trX) q1 = q3\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "then"], ["proof (chain)\npicking this:\n  target (vs @ xs || trV @ trX) q1 = q3", "have \"target ((vs || trV) @ (xs || trX)) q1 = q3\""], ["proof (prove)\nusing this:\n  target (vs @ xs || trV @ trX) q1 = q3\n\ngoal (1 subgoal):\n 1. target ((vs || trV) @ (xs || trX)) q1 = q3", "using tr_def"], ["proof (prove)\nusing this:\n  target (vs @ xs || trV @ trX) q1 = q3\n  path M (vs || trV) q1\n  length vs = length trV\n  path M (xs || trX) (target (vs || trV) q1)\n  length xs = length trX\n\ngoal (1 subgoal):\n 1. target ((vs || trV) @ (xs || trX)) q1 = q3", "by simp"], ["proof (state)\nthis:\n  target ((vs || trV) @ (xs || trX)) q1 = q3\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "then"], ["proof (chain)\npicking this:\n  target ((vs || trV) @ (xs || trX)) q1 = q3", "have \"target (xs || trX) q2 = q3\""], ["proof (prove)\nusing this:\n  target ((vs || trV) @ (xs || trX)) q1 = q3\n\ngoal (1 subgoal):\n 1. target (xs || trX) q2 = q3", "using tgt_V"], ["proof (prove)\nusing this:\n  target ((vs || trV) @ (xs || trX)) q1 = q3\n  target (vs || trV) q1 = q2\n\ngoal (1 subgoal):\n 1. target (xs || trX) q2 = q3", "by auto"], ["proof (state)\nthis:\n  target (xs || trX) q2 = q3\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "then"], ["proof (chain)\npicking this:\n  target (xs || trX) q2 = q3", "have \"q3 \\<in> io_targets M q2 xs\""], ["proof (prove)\nusing this:\n  target (xs || trX) q2 = q3\n\ngoal (1 subgoal):\n 1. q3 \\<in> io_targets M q2 xs", "using path_X"], ["proof (prove)\nusing this:\n  target (xs || trX) q2 = q3\n  path M (xs || trX) q2 \\<and> length xs = length trX\n\ngoal (1 subgoal):\n 1. q3 \\<in> io_targets M q2 xs", "by auto"], ["proof (state)\nthis:\n  q3 \\<in> io_targets M q2 xs\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "then"], ["proof (chain)\npicking this:\n  q3 \\<in> io_targets M q2 xs", "show ?thesis"], ["proof (prove)\nusing this:\n  q3 \\<in> io_targets M q2 xs\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "by (metis (no_types) \\<open>observable M\\<close> path_X insert_absorb io_targets_observable_singleton_ex \n        language_state singleton_insert_inj_eq')"], ["proof (state)\nthis:\n  io_targets M q2 xs = {q3}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_io_target_unique_target :\n  assumes \"observable M\"\n  and     \"io_targets M q1 io = {q2}\"\n  and     \"path M (io || tr) q1\"\n  and     \"length io = length tr\"\nshows \"target (io || tr) q1 = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || tr) q1 = q2", "using assms"], ["proof (prove)\nusing this:\n  observable M\n  io_targets M q1 io = {q2}\n  path M (io || tr) q1\n  length io = length tr\n\ngoal (1 subgoal):\n 1. target (io || tr) q1 = q2", "by auto"], ["", "lemma target_in_states : \n  assumes \"length io = length tr\"\n  and     \"length io > 0\"\n  shows \"last (states (io || tr) q) = target (io || tr) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (states (io || tr) q) = target (io || tr) q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last (states (io || tr) q) = target (io || tr) q", "have \"0 < length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length tr", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  length io = length tr\n  0 < length io\n\ngoal (1 subgoal):\n 1. 0 < length tr", "by presburger"], ["proof (state)\nthis:\n  0 < length tr\n\ngoal (1 subgoal):\n 1. last (states (io || tr) q) = target (io || tr) q", "then"], ["proof (chain)\npicking this:\n  0 < length tr", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < length tr\n\ngoal (1 subgoal):\n 1. last (states (io || tr) q) = target (io || tr) q", "by (simp add: FSM.target_alt_def assms(1) states_alt_def)"], ["proof (state)\nthis:\n  last (states (io || tr) q) = target (io || tr) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma target_alt_def :\n  assumes \"length io = length tr\"\n  shows \"length io = 0 \\<Longrightarrow> target (io || tr) q = q\"\n        \"length io > 0 \\<Longrightarrow> target (io || tr) q = last tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length io = 0 \\<Longrightarrow> target (io || tr) q = q) &&&\n    (0 < length io \\<Longrightarrow> target (io || tr) q = last tr)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. length io = 0 \\<Longrightarrow> target (io || tr) q = q\n 2. 0 < length io \\<Longrightarrow> target (io || tr) q = last tr", "show \"length io = 0 \\<Longrightarrow> target (io || tr) q = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length io = 0 \\<Longrightarrow> target (io || tr) q = q", "by simp"], ["proof (state)\nthis:\n  length io = 0 \\<Longrightarrow> target (io || tr) q = q\n\ngoal (1 subgoal):\n 1. 0 < length io \\<Longrightarrow> target (io || tr) q = last tr", "show \"length io > 0 \\<Longrightarrow> target (io || tr) q = last tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length io \\<Longrightarrow> target (io || tr) q = last tr", "by (metis assms last_ConsR length_greater_0_conv map_snd_zip scan_last states_alt_def)"], ["proof (state)\nthis:\n  0 < length io \\<Longrightarrow> target (io || tr) q = last tr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_target_is_io_targets :\n  assumes \"observable M\"\n  and     \"path M (io || tr) q\"\n  and     \"length io = length tr\"\nshows \"io_targets M q io = {target (io || tr) q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M q io = {target (io || tr) q}", "by (metis assms(1) assms(2) assms(3) io_targets_observable_singleton_ex language_state \n      observable_io_target_unique_target)"], ["", "lemma io_target_target :\n  assumes \"io_targets M q1 io = {q2}\"\n  and     \"path M (io || tr) q1\"\n  and     \"length io = length tr\"\nshows \"target (io || tr) q1 = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || tr) q1 = q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. target (io || tr) q1 = q2", "have \"target (io || tr) q1 \\<in> io_targets M q1 io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || tr) q1 \\<in> io_targets M q1 io", "using assms(2) assms(3)"], ["proof (prove)\nusing this:\n  path M (io || tr) q1\n  length io = length tr\n\ngoal (1 subgoal):\n 1. target (io || tr) q1 \\<in> io_targets M q1 io", "by auto"], ["proof (state)\nthis:\n  target (io || tr) q1 \\<in> io_targets M q1 io\n\ngoal (1 subgoal):\n 1. target (io || tr) q1 = q2", "then"], ["proof (chain)\npicking this:\n  target (io || tr) q1 \\<in> io_targets M q1 io", "show ?thesis"], ["proof (prove)\nusing this:\n  target (io || tr) q1 \\<in> io_targets M q1 io\n\ngoal (1 subgoal):\n 1. target (io || tr) q1 = q2", "using assms(1)"], ["proof (prove)\nusing this:\n  target (io || tr) q1 \\<in> io_targets M q1 io\n  io_targets M q1 io = {q2}\n\ngoal (1 subgoal):\n 1. target (io || tr) q1 = q2", "by blast"], ["proof (state)\nthis:\n  target (io || tr) q1 = q2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_last_take :\n  assumes \"i < length xs\"\n  shows \"xs ! i = last (take (Suc i) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! i = last (take (Suc i) xs)", "by (simp add: assms take_Suc_conv_app_nth)"], ["", "lemma path_last_io_target :\n  assumes \"path M (xs || tr) q\" \n  and     \"length xs = length tr\"\n  and     \"length xs > 0\"\nshows \"last tr \\<in> io_targets M q xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last tr \\<in> io_targets M q xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last tr \\<in> io_targets M q xs", "have \"last tr = target (xs || tr) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last tr = target (xs || tr) q", "by (metis assms(2) assms(3) map_snd_zip states_alt_def target_in_states)"], ["proof (state)\nthis:\n  last tr = target (xs || tr) q\n\ngoal (1 subgoal):\n 1. last tr \\<in> io_targets M q xs", "then"], ["proof (chain)\npicking this:\n  last tr = target (xs || tr) q", "show ?thesis"], ["proof (prove)\nusing this:\n  last tr = target (xs || tr) q\n\ngoal (1 subgoal):\n 1. last tr \\<in> io_targets M q xs", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  last tr = target (xs || tr) q\n  path M (xs || tr) q\n  length xs = length tr\n\ngoal (1 subgoal):\n 1. last tr \\<in> io_targets M q xs", "by auto"], ["proof (state)\nthis:\n  last tr \\<in> io_targets M q xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_prefix_io_targets :\n  assumes \"path M (xs || tr) q\" \n  and     \"length xs = length tr\"\n  and     \"length xs > 0\"\nshows \"last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)", "have \"path M (take (Suc i) xs || take (Suc i) tr) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M (take (Suc i) xs || take (Suc i) tr) q", "by (metis (no_types) FSM.path_append_elim append_take_drop_id assms(1) take_zip)"], ["proof (state)\nthis:\n  path M (take (Suc i) xs || take (Suc i) tr) q\n\ngoal (1 subgoal):\n 1. last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)", "then"], ["proof (chain)\npicking this:\n  path M (take (Suc i) xs || take (Suc i) tr) q", "show ?thesis"], ["proof (prove)\nusing this:\n  path M (take (Suc i) xs || take (Suc i) tr) q\n\ngoal (1 subgoal):\n 1. last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)", "using assms(2) assms(3) path_last_io_target"], ["proof (prove)\nusing this:\n  path M (take (Suc i) xs || take (Suc i) tr) q\n  length xs = length tr\n  0 < length xs\n  \\<lbrakk>path ?M (?xs || ?tr) ?q; length ?xs = length ?tr;\n   0 < length ?xs\\<rbrakk>\n  \\<Longrightarrow> last ?tr \\<in> io_targets ?M ?q ?xs\n\ngoal (1 subgoal):\n 1. last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)", "by fastforce"], ["proof (state)\nthis:\n  last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma states_index_io_target :\n  assumes \"i < length xs\"\n  and     \"path M (xs || tr) q\" \n  and     \"length xs = length tr\"\n  and     \"length xs > 0\"\nshows \"(states (xs || tr) q) ! i \\<in> io_targets M q (take (Suc i) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i \\<in> io_targets M q (take (Suc i) xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i \\<in> io_targets M q (take (Suc i) xs)", "have \"(states (xs || tr) q) ! i = last (take (Suc i) (states (xs || tr) q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i = last (take (Suc i) (states (xs || tr) q))", "by (metis assms(1) assms(3) map_snd_zip states_alt_def index_last_take)"], ["proof (state)\nthis:\n  states (xs || tr) q ! i = last (take (Suc i) (states (xs || tr) q))\n\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i \\<in> io_targets M q (take (Suc i) xs)", "then"], ["proof (chain)\npicking this:\n  states (xs || tr) q ! i = last (take (Suc i) (states (xs || tr) q))", "have \"(states (xs || tr) q) ! i = last (states (take (Suc i) xs || take (Suc i) tr) q)\""], ["proof (prove)\nusing this:\n  states (xs || tr) q ! i = last (take (Suc i) (states (xs || tr) q))\n\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i =\n    last (states (take (Suc i) xs || take (Suc i) tr) q)", "by (simp add: take_zip)"], ["proof (state)\nthis:\n  states (xs || tr) q ! i =\n  last (states (take (Suc i) xs || take (Suc i) tr) q)\n\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i \\<in> io_targets M q (take (Suc i) xs)", "then"], ["proof (chain)\npicking this:\n  states (xs || tr) q ! i =\n  last (states (take (Suc i) xs || take (Suc i) tr) q)", "have \"(states (xs || tr) q) ! i = last (take (Suc i) tr)\""], ["proof (prove)\nusing this:\n  states (xs || tr) q ! i =\n  last (states (take (Suc i) xs || take (Suc i) tr) q)\n\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i = last (take (Suc i) tr)", "by (simp add: assms(3) states_alt_def)"], ["proof (state)\nthis:\n  states (xs || tr) q ! i = last (take (Suc i) tr)\n\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i \\<in> io_targets M q (take (Suc i) xs)", "moreover"], ["proof (state)\nthis:\n  states (xs || tr) q ! i = last (take (Suc i) tr)\n\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i \\<in> io_targets M q (take (Suc i) xs)", "have \"last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)", "by (meson assms(2) assms(3) assms(4) path_prefix_io_targets)"], ["proof (state)\nthis:\n  last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)\n\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i \\<in> io_targets M q (take (Suc i) xs)", "ultimately"], ["proof (chain)\npicking this:\n  states (xs || tr) q ! i = last (take (Suc i) tr)\n  last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  states (xs || tr) q ! i = last (take (Suc i) tr)\n  last (take (Suc i) tr) \\<in> io_targets M q (take (Suc i) xs)\n\ngoal (1 subgoal):\n 1. states (xs || tr) q ! i \\<in> io_targets M q (take (Suc i) xs)", "by simp"], ["proof (state)\nthis:\n  states (xs || tr) q ! i \\<in> io_targets M q (take (Suc i) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_io_targets_append :\n  assumes \"observable M\"\n  and \"io_targets M q1 vs = {q2}\"\n  and \"io_targets M q2 xs = {q3}\"\nshows \"io_targets M q1 (vs@xs) = {q3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M q1 (vs @ xs) = {q3}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io_targets M q1 (vs @ xs) = {q3}", "obtain trV where \"path M (vs || trV) q1 \\<and> length trV = length vs \\<and> target (vs || trV) q1 = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trV.\n        path M (vs || trV) q1 \\<and>\n        length trV = length vs \\<and>\n        target (vs || trV) q1 = q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(2) io_targets_elim singletonI)"], ["proof (state)\nthis:\n  path M (vs || trV) q1 \\<and>\n  length trV = length vs \\<and> target (vs || trV) q1 = q2\n\ngoal (1 subgoal):\n 1. io_targets M q1 (vs @ xs) = {q3}", "moreover"], ["proof (state)\nthis:\n  path M (vs || trV) q1 \\<and>\n  length trV = length vs \\<and> target (vs || trV) q1 = q2\n\ngoal (1 subgoal):\n 1. io_targets M q1 (vs @ xs) = {q3}", "obtain trX where \"path M (xs || trX) q2 \\<and> length trX = length xs \n                              \\<and> target (xs || trX) q2 = q3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trX.\n        path M (xs || trX) q2 \\<and>\n        length trX = length xs \\<and>\n        target (xs || trX) q2 = q3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(3) io_targets_elim singletonI)"], ["proof (state)\nthis:\n  path M (xs || trX) q2 \\<and>\n  length trX = length xs \\<and> target (xs || trX) q2 = q3\n\ngoal (1 subgoal):\n 1. io_targets M q1 (vs @ xs) = {q3}", "ultimately"], ["proof (chain)\npicking this:\n  path M (vs || trV) q1 \\<and>\n  length trV = length vs \\<and> target (vs || trV) q1 = q2\n  path M (xs || trX) q2 \\<and>\n  length trX = length xs \\<and> target (xs || trX) q2 = q3", "have \"path M (vs @ xs || trV @ trX) q1 \\<and> length (trV @ trX) = length (vs @ xs) \n                    \\<and> target (vs @ xs || trV @ trX) q1 = q3\""], ["proof (prove)\nusing this:\n  path M (vs || trV) q1 \\<and>\n  length trV = length vs \\<and> target (vs || trV) q1 = q2\n  path M (xs || trX) q2 \\<and>\n  length trX = length xs \\<and> target (xs || trX) q2 = q3\n\ngoal (1 subgoal):\n 1. path M (vs @ xs || trV @ trX) q1 \\<and>\n    length (trV @ trX) = length (vs @ xs) \\<and>\n    target (vs @ xs || trV @ trX) q1 = q3", "by auto"], ["proof (state)\nthis:\n  path M (vs @ xs || trV @ trX) q1 \\<and>\n  length (trV @ trX) = length (vs @ xs) \\<and>\n  target (vs @ xs || trV @ trX) q1 = q3\n\ngoal (1 subgoal):\n 1. io_targets M q1 (vs @ xs) = {q3}", "then"], ["proof (chain)\npicking this:\n  path M (vs @ xs || trV @ trX) q1 \\<and>\n  length (trV @ trX) = length (vs @ xs) \\<and>\n  target (vs @ xs || trV @ trX) q1 = q3", "show ?thesis"], ["proof (prove)\nusing this:\n  path M (vs @ xs || trV @ trX) q1 \\<and>\n  length (trV @ trX) = length (vs @ xs) \\<and>\n  target (vs @ xs || trV @ trX) q1 = q3\n\ngoal (1 subgoal):\n 1. io_targets M q1 (vs @ xs) = {q3}", "by (metis assms(1) obs_target_is_io_targets)"], ["proof (state)\nthis:\n  io_targets M q1 (vs @ xs) = {q3}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma io_path_states_prefix :\n  assumes \"observable M\"\n  and \"path M (io1 || tr1) q\"\n  and \"length tr1 = length io1\"\n  and \"path M (io2 || tr2) q\"\n  and \"length tr2 = length io2\"\n  and \"prefix io1 io2\"\nshows \"tr1 = take (length tr1) tr2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr1 = take (length tr1) tr2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tr1 = take (length tr1) tr2", "let ?tr1' = \"take (length tr1) tr2\""], ["proof (state)\ngoal (1 subgoal):\n 1. tr1 = take (length tr1) tr2", "let ?io1' = \"take (length tr1) io2\""], ["proof (state)\ngoal (1 subgoal):\n 1. tr1 = take (length tr1) tr2", "have \"path M (?io1' || ?tr1') q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M (take (length tr1) io2 || take (length tr1) tr2) q", "by (metis FSM.path_append_elim append_take_drop_id assms(4) take_zip)"], ["proof (state)\nthis:\n  path M (take (length tr1) io2 || take (length tr1) tr2) q\n\ngoal (1 subgoal):\n 1. tr1 = take (length tr1) tr2", "have \"length ?tr1' = length ?io1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (length tr1) tr2) = length (take (length tr1) io2)", "using assms (5)"], ["proof (prove)\nusing this:\n  length tr2 = length io2\n\ngoal (1 subgoal):\n 1. length (take (length tr1) tr2) = length (take (length tr1) io2)", "by auto"], ["proof (state)\nthis:\n  length (take (length tr1) tr2) = length (take (length tr1) io2)\n\ngoal (1 subgoal):\n 1. tr1 = take (length tr1) tr2", "have \"?io1' = io1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length tr1) io2 = io1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take (length tr1) io2 = io1", "have \"\\<forall>ps psa. \\<not> prefix (ps::('a \\<times> 'b) list) psa \\<or> length ps \\<le> length psa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps psa. \\<not> prefix ps psa \\<or> length ps \\<le> length psa", "using prefix_length_le"], ["proof (prove)\nusing this:\n  prefix ?xs ?ys \\<Longrightarrow> length ?xs \\<le> length ?ys\n\ngoal (1 subgoal):\n 1. \\<forall>ps psa. \\<not> prefix ps psa \\<or> length ps \\<le> length psa", "by blast"], ["proof (state)\nthis:\n  \\<forall>ps psa. \\<not> prefix ps psa \\<or> length ps \\<le> length psa\n\ngoal (1 subgoal):\n 1. take (length tr1) io2 = io1", "then"], ["proof (chain)\npicking this:\n  \\<forall>ps psa. \\<not> prefix ps psa \\<or> length ps \\<le> length psa", "have \"length (take (length tr1) io2) = length io1\""], ["proof (prove)\nusing this:\n  \\<forall>ps psa. \\<not> prefix ps psa \\<or> length ps \\<le> length psa\n\ngoal (1 subgoal):\n 1. length (take (length tr1) io2) = length io1", "using assms(3) assms(6) min.absorb2"], ["proof (prove)\nusing this:\n  \\<forall>ps psa. \\<not> prefix ps psa \\<or> length ps \\<le> length psa\n  length tr1 = length io1\n  prefix io1 io2\n  ?b \\<le> ?a \\<Longrightarrow> min ?a ?b = ?b\n\ngoal (1 subgoal):\n 1. length (take (length tr1) io2) = length io1", "by auto"], ["proof (state)\nthis:\n  length (take (length tr1) io2) = length io1\n\ngoal (1 subgoal):\n 1. take (length tr1) io2 = io1", "then"], ["proof (chain)\npicking this:\n  length (take (length tr1) io2) = length io1", "show ?thesis"], ["proof (prove)\nusing this:\n  length (take (length tr1) io2) = length io1\n\ngoal (1 subgoal):\n 1. take (length tr1) io2 = io1", "by (metis assms(6) min.cobounded2 min_def_raw prefix_length_prefix \n          prefix_order.dual_order.antisym take_is_prefix)"], ["proof (state)\nthis:\n  take (length tr1) io2 = io1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take (length tr1) io2 = io1\n\ngoal (1 subgoal):\n 1. tr1 = take (length tr1) tr2", "show \"tr1 = ?tr1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr1 = take (length tr1) tr2", "by (metis \\<open>length (take (length tr1) tr2) = length (take (length tr1) io2)\\<close> \n        \\<open>path M (take (length tr1) io2 || take (length tr1) tr2) q\\<close> \\<open>take (length tr1) io2 = io1\\<close> \n        assms(1) assms(2) assms(3) language_state observable_path_unique)"], ["proof (state)\nthis:\n  tr1 = take (length tr1) tr2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_io_targets_suffix :\n  assumes \"observable M\"\n  and \"io_targets M q1 vs = {q2}\"\n  and \"io_targets M q1 (vs@xs) = {q3}\"\nshows \"io_targets M q2 xs = {q3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "have \"prefix vs (vs@xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix vs (vs @ xs)", "by auto"], ["proof (state)\nthis:\n  prefix vs (vs @ xs)\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "obtain trV where \"path M (vs || trV) q1 \\<and> length trV = length vs \\<and> target (vs || trV) q1 = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trV.\n        path M (vs || trV) q1 \\<and>\n        length trV = length vs \\<and>\n        target (vs || trV) q1 = q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(2) io_targets_elim singletonI)"], ["proof (state)\nthis:\n  path M (vs || trV) q1 \\<and>\n  length trV = length vs \\<and> target (vs || trV) q1 = q2\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "moreover"], ["proof (state)\nthis:\n  path M (vs || trV) q1 \\<and>\n  length trV = length vs \\<and> target (vs || trV) q1 = q2\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "obtain trVX where \"path M (vs@xs || trVX) q1 \n                                \\<and> length trVX = length (vs@xs) \\<and> target (vs@xs || trVX) q1 = q3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trVX.\n        path M (vs @ xs || trVX) q1 \\<and>\n        length trVX = length (vs @ xs) \\<and>\n        target (vs @ xs || trVX) q1 = q3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(3) io_targets_elim singletonI)"], ["proof (state)\nthis:\n  path M (vs @ xs || trVX) q1 \\<and>\n  length trVX = length (vs @ xs) \\<and> target (vs @ xs || trVX) q1 = q3\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "ultimately"], ["proof (chain)\npicking this:\n  path M (vs || trV) q1 \\<and>\n  length trV = length vs \\<and> target (vs || trV) q1 = q2\n  path M (vs @ xs || trVX) q1 \\<and>\n  length trVX = length (vs @ xs) \\<and> target (vs @ xs || trVX) q1 = q3", "have \"trV = take (length trV) trVX\""], ["proof (prove)\nusing this:\n  path M (vs || trV) q1 \\<and>\n  length trV = length vs \\<and> target (vs || trV) q1 = q2\n  path M (vs @ xs || trVX) q1 \\<and>\n  length trVX = length (vs @ xs) \\<and> target (vs @ xs || trVX) q1 = q3\n\ngoal (1 subgoal):\n 1. trV = take (length trV) trVX", "using io_path_states_prefix[OF assms(1) _ _ _ _ \\<open>prefix vs (vs@xs)\\<close>, of trV q1 trVX]"], ["proof (prove)\nusing this:\n  path M (vs || trV) q1 \\<and>\n  length trV = length vs \\<and> target (vs || trV) q1 = q2\n  path M (vs @ xs || trVX) q1 \\<and>\n  length trVX = length (vs @ xs) \\<and> target (vs @ xs || trVX) q1 = q3\n  \\<lbrakk>path M (vs || trV) q1; length trV = length vs;\n   path M (vs @ xs || trVX) q1; length trVX = length (vs @ xs)\\<rbrakk>\n  \\<Longrightarrow> trV = take (length trV) trVX\n\ngoal (1 subgoal):\n 1. trV = take (length trV) trVX", "by auto"], ["proof (state)\nthis:\n  trV = take (length trV) trVX\n\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M q2 xs = {q3}", "by (meson assms(1) assms(2) assms(3) observable_io_targets_split)"], ["proof (state)\nthis:\n  io_targets M q2 xs = {q3}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_io_target_is_singleton[simp] :\n  assumes \"observable M\"\n  and     \"p \\<in> io_targets M q io\"\nshows \"io_targets M q io = {p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M q io = {p}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io_targets M q io = {p}", "have \"io \\<in> LS M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> LS M q", "using assms(2)"], ["proof (prove)\nusing this:\n  p \\<in> io_targets M q io\n\ngoal (1 subgoal):\n 1. io \\<in> LS M q", "by auto"], ["proof (state)\nthis:\n  io \\<in> LS M q\n\ngoal (1 subgoal):\n 1. io_targets M q io = {p}", "then"], ["proof (chain)\npicking this:\n  io \\<in> LS M q", "obtain p' where \"io_targets M q io = {p'}\""], ["proof (prove)\nusing this:\n  io \\<in> LS M q\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        io_targets M q io = {p'} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  io \\<in> LS M q\n  observable M\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        io_targets M q io = {p'} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson io_targets_observable_singleton_ex)"], ["proof (state)\nthis:\n  io_targets M q io = {p'}\n\ngoal (1 subgoal):\n 1. io_targets M q io = {p}", "then"], ["proof (chain)\npicking this:\n  io_targets M q io = {p'}", "show ?thesis"], ["proof (prove)\nusing this:\n  io_targets M q io = {p'}\n\ngoal (1 subgoal):\n 1. io_targets M q io = {p}", "using assms(2)"], ["proof (prove)\nusing this:\n  io_targets M q io = {p'}\n  p \\<in> io_targets M q io\n\ngoal (1 subgoal):\n 1. io_targets M q io = {p}", "by simp"], ["proof (state)\nthis:\n  io_targets M q io = {p}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_path_prefix :\n  assumes \"observable M\"\n  and     \"path M (io || tr) q\"\n  and     \"length io = length tr\"\n  and     \"path M (ioP || trP) q\"\n  and     \"length ioP = length trP\"\n  and     \"prefix ioP io\" \nshows \"trP = take (length ioP) tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trP = take (length ioP) tr", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trP = take (length ioP) tr", "have ioP_def : \"ioP = take (length ioP) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ioP = take (length ioP) io", "using assms(6)"], ["proof (prove)\nusing this:\n  prefix ioP io\n\ngoal (1 subgoal):\n 1. ioP = take (length ioP) io", "by (metis append_eq_conv_conj prefixE)"], ["proof (state)\nthis:\n  ioP = take (length ioP) io\n\ngoal (1 subgoal):\n 1. trP = take (length ioP) tr", "then"], ["proof (chain)\npicking this:\n  ioP = take (length ioP) io", "have \"take (length ioP) (io || tr) = take (length ioP) io || take (length ioP) tr\""], ["proof (prove)\nusing this:\n  ioP = take (length ioP) io\n\ngoal (1 subgoal):\n 1. take (length ioP) (io || tr) =\n    take (length ioP) io || take (length ioP) tr", "using take_zip"], ["proof (prove)\nusing this:\n  ioP = take (length ioP) io\n  take ?n (?xs || ?ys) = take ?n ?xs || take ?n ?ys\n\ngoal (1 subgoal):\n 1. take (length ioP) (io || tr) =\n    take (length ioP) io || take (length ioP) tr", "by blast"], ["proof (state)\nthis:\n  take (length ioP) (io || tr) =\n  take (length ioP) io || take (length ioP) tr\n\ngoal (1 subgoal):\n 1. trP = take (length ioP) tr", "moreover"], ["proof (state)\nthis:\n  take (length ioP) (io || tr) =\n  take (length ioP) io || take (length ioP) tr\n\ngoal (1 subgoal):\n 1. trP = take (length ioP) tr", "have \"path M (take (length ioP) (io || tr)) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M (take (length ioP) (io || tr)) q", "using assms"], ["proof (prove)\nusing this:\n  observable M\n  path M (io || tr) q\n  length io = length tr\n  path M (ioP || trP) q\n  length ioP = length trP\n  prefix ioP io\n\ngoal (1 subgoal):\n 1. path M (take (length ioP) (io || tr)) q", "by (metis FSM.path_append_elim append_take_drop_id)"], ["proof (state)\nthis:\n  path M (take (length ioP) (io || tr)) q\n\ngoal (1 subgoal):\n 1. trP = take (length ioP) tr", "ultimately"], ["proof (chain)\npicking this:\n  take (length ioP) (io || tr) =\n  take (length ioP) io || take (length ioP) tr\n  path M (take (length ioP) (io || tr)) q", "have \"path M (take (length ioP) io || take (length ioP) tr) q \n                    \\<and> length (take (length ioP) io) = length (take (length ioP) tr)\""], ["proof (prove)\nusing this:\n  take (length ioP) (io || tr) =\n  take (length ioP) io || take (length ioP) tr\n  path M (take (length ioP) (io || tr)) q\n\ngoal (1 subgoal):\n 1. path M (take (length ioP) io || take (length ioP) tr) q \\<and>\n    length (take (length ioP) io) = length (take (length ioP) tr)", "using assms(3)"], ["proof (prove)\nusing this:\n  take (length ioP) (io || tr) =\n  take (length ioP) io || take (length ioP) tr\n  path M (take (length ioP) (io || tr)) q\n  length io = length tr\n\ngoal (1 subgoal):\n 1. path M (take (length ioP) io || take (length ioP) tr) q \\<and>\n    length (take (length ioP) io) = length (take (length ioP) tr)", "by auto"], ["proof (state)\nthis:\n  path M (take (length ioP) io || take (length ioP) tr) q \\<and>\n  length (take (length ioP) io) = length (take (length ioP) tr)\n\ngoal (1 subgoal):\n 1. trP = take (length ioP) tr", "then"], ["proof (chain)\npicking this:\n  path M (take (length ioP) io || take (length ioP) tr) q \\<and>\n  length (take (length ioP) io) = length (take (length ioP) tr)", "have \"path M (ioP || take (length ioP) tr) q \\<and> length ioP = length (take (length ioP) tr)\""], ["proof (prove)\nusing this:\n  path M (take (length ioP) io || take (length ioP) tr) q \\<and>\n  length (take (length ioP) io) = length (take (length ioP) tr)\n\ngoal (1 subgoal):\n 1. path M (ioP || take (length ioP) tr) q \\<and>\n    length ioP = length (take (length ioP) tr)", "using assms(3)"], ["proof (prove)\nusing this:\n  path M (take (length ioP) io || take (length ioP) tr) q \\<and>\n  length (take (length ioP) io) = length (take (length ioP) tr)\n  length io = length tr\n\ngoal (1 subgoal):\n 1. path M (ioP || take (length ioP) tr) q \\<and>\n    length ioP = length (take (length ioP) tr)", "using ioP_def"], ["proof (prove)\nusing this:\n  path M (take (length ioP) io || take (length ioP) tr) q \\<and>\n  length (take (length ioP) io) = length (take (length ioP) tr)\n  length io = length tr\n  ioP = take (length ioP) io\n\ngoal (1 subgoal):\n 1. path M (ioP || take (length ioP) tr) q \\<and>\n    length ioP = length (take (length ioP) tr)", "by auto"], ["proof (state)\nthis:\n  path M (ioP || take (length ioP) tr) q \\<and>\n  length ioP = length (take (length ioP) tr)\n\ngoal (1 subgoal):\n 1. trP = take (length ioP) tr", "then"], ["proof (chain)\npicking this:\n  path M (ioP || take (length ioP) tr) q \\<and>\n  length ioP = length (take (length ioP) tr)", "show ?thesis"], ["proof (prove)\nusing this:\n  path M (ioP || take (length ioP) tr) q \\<and>\n  length ioP = length (take (length ioP) tr)\n\ngoal (1 subgoal):\n 1. trP = take (length ioP) tr", "by (meson assms(1) assms(4) assms(5) language_state observable_path_unique)"], ["proof (state)\nthis:\n  trP = take (length ioP) tr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma io_targets_succ : \n  assumes \"q2 \\<in> io_targets M q1 [xy]\"\n  shows \"q2 \\<in> succ M xy q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<in> succ M xy q1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q2 \\<in> succ M xy q1", "obtain tr where tr_def : \"target ([xy] || tr) q1 = q2\" \n                           \"path M ([xy] || tr) q1\" \n                           \"length [xy] = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>target ([xy] || tr) q1 = q2; path M ([xy] || tr) q1;\n         length [xy] = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  q2 \\<in> io_targets M q1 [xy]\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>target ([xy] || tr) q1 = q2; path M ([xy] || tr) q1;\n         length [xy] = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  target ([xy] || tr) q1 = q2\n  path M ([xy] || tr) q1\n  length [xy] = length tr\n\ngoal (1 subgoal):\n 1. q2 \\<in> succ M xy q1", "have \"length tr = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length tr = Suc 0", "using \\<open>length [xy] = length tr\\<close>"], ["proof (prove)\nusing this:\n  length [xy] = length tr\n\ngoal (1 subgoal):\n 1. length tr = Suc 0", "by auto"], ["proof (state)\nthis:\n  length tr = Suc 0\n\ngoal (1 subgoal):\n 1. q2 \\<in> succ M xy q1", "then"], ["proof (chain)\npicking this:\n  length tr = Suc 0", "obtain q2' where \"tr = [q2']\""], ["proof (prove)\nusing this:\n  length tr = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>q2'. tr = [q2'] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv length_0_conv)"], ["proof (state)\nthis:\n  tr = [q2']\n\ngoal (1 subgoal):\n 1. q2 \\<in> succ M xy q1", "then"], ["proof (chain)\npicking this:\n  tr = [q2']", "have \"target ([xy] || tr) q1 = q2'\""], ["proof (prove)\nusing this:\n  tr = [q2']\n\ngoal (1 subgoal):\n 1. target ([xy] || tr) q1 = q2'", "by auto"], ["proof (state)\nthis:\n  target ([xy] || tr) q1 = q2'\n\ngoal (1 subgoal):\n 1. q2 \\<in> succ M xy q1", "then"], ["proof (chain)\npicking this:\n  target ([xy] || tr) q1 = q2'", "have \"q2' = q2\""], ["proof (prove)\nusing this:\n  target ([xy] || tr) q1 = q2'\n\ngoal (1 subgoal):\n 1. q2' = q2", "using \\<open>target ([xy] || tr) q1 = q2\\<close>"], ["proof (prove)\nusing this:\n  target ([xy] || tr) q1 = q2'\n  target ([xy] || tr) q1 = q2\n\ngoal (1 subgoal):\n 1. q2' = q2", "by simp"], ["proof (state)\nthis:\n  q2' = q2\n\ngoal (1 subgoal):\n 1. q2 \\<in> succ M xy q1", "then"], ["proof (chain)\npicking this:\n  q2' = q2", "have \"path M ([xy] || [q2]) q1\""], ["proof (prove)\nusing this:\n  q2' = q2\n\ngoal (1 subgoal):\n 1. path M ([xy] || [q2]) q1", "using tr_def(2) \\<open>tr = [q2']\\<close>"], ["proof (prove)\nusing this:\n  q2' = q2\n  path M ([xy] || tr) q1\n  tr = [q2']\n\ngoal (1 subgoal):\n 1. path M ([xy] || [q2]) q1", "by auto"], ["proof (state)\nthis:\n  path M ([xy] || [q2]) q1\n\ngoal (1 subgoal):\n 1. q2 \\<in> succ M xy q1", "then"], ["proof (chain)\npicking this:\n  path M ([xy] || [q2]) q1", "have \"path M [(xy,q2)] q1\""], ["proof (prove)\nusing this:\n  path M ([xy] || [q2]) q1\n\ngoal (1 subgoal):\n 1. path M [(xy, q2)] q1", "by auto"], ["proof (state)\nthis:\n  path M [(xy, q2)] q1\n\ngoal (1 subgoal):\n 1. q2 \\<in> succ M xy q1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<in> succ M xy q1", "proof (cases rule: FSM.path.cases[of M \"[(xy,q2)]\" q1])"], ["proof (state)\ngoal (2 subgoals):\n 1. path M [(xy, q2)] q1\n 2. \\<lbrakk>snd (xy, q2) \\<in> succ M (fst (xy, q2)) q1;\n     path M [] (snd (xy, q2))\\<rbrakk>\n    \\<Longrightarrow> q2 \\<in> succ M xy q1", "case nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. path M [(xy, q2)] q1\n 2. \\<lbrakk>snd (xy, q2) \\<in> succ M (fst (xy, q2)) q1;\n     path M [] (snd (xy, q2))\\<rbrakk>\n    \\<Longrightarrow> q2 \\<in> succ M xy q1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. path M [(xy, q2)] q1", "using \\<open>path M [(xy,q2)] q1\\<close>"], ["proof (prove)\nusing this:\n  path M [(xy, q2)] q1\n\ngoal (1 subgoal):\n 1. path M [(xy, q2)] q1", "by simp"], ["proof (state)\nthis:\n  path M [(xy, q2)] q1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (xy, q2) \\<in> succ M (fst (xy, q2)) q1;\n     path M [] (snd (xy, q2))\\<rbrakk>\n    \\<Longrightarrow> q2 \\<in> succ M xy q1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (xy, q2) \\<in> succ M (fst (xy, q2)) q1;\n     path M [] (snd (xy, q2))\\<rbrakk>\n    \\<Longrightarrow> q2 \\<in> succ M xy q1", "case cons"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (xy, q2) \\<in> succ M (fst (xy, q2)) q1;\n     path M [] (snd (xy, q2))\\<rbrakk>\n    \\<Longrightarrow> q2 \\<in> succ M xy q1", "show \"snd (xy, q2) \\<in> succ M (fst (xy, q2)) q1 \\<Longrightarrow> path M [] (snd (xy, q2)) \n            \\<Longrightarrow> q2 \\<in> succ M xy q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (xy, q2) \\<in> succ M (fst (xy, q2)) q1;\n     path M [] (snd (xy, q2))\\<rbrakk>\n    \\<Longrightarrow> q2 \\<in> succ M xy q1", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>snd (xy, q2) \\<in> succ M (fst (xy, q2)) q1;\n   path M [] (snd (xy, q2))\\<rbrakk>\n  \\<Longrightarrow> q2 \\<in> succ M xy q1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q2 \\<in> succ M xy q1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> D-reachability \\<close>"], ["", "text \\<open>\nA state of some FSM is d-reached (deterministically reached) by some input sequence if any sequence \nin the language of the FSM with this input sequence reaches that state. \nThat state is then called d-reachable. \n\\<close>"], ["", "abbreviation  \"d_reached_by M p xs q tr ys \\<equiv> \n                    ((length xs = length ys \\<and> length xs = length tr \n                    \\<and> (path M ((xs || ys) || tr) p) \\<and> target ((xs || ys) || tr) p = q) \n                    \\<and> (\\<forall> ys2 tr2 .  (length xs = length ys2 \\<and> length xs = length tr2 \n                    \\<and> path M ((xs || ys2) || tr2) p) \\<longrightarrow> target ((xs || ys2) || tr2) p = q))\""], ["", "fun d_reaches :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \\<Rightarrow> 'in list \\<Rightarrow> 'state \\<Rightarrow> bool\" where\n  \"d_reaches M p xs q = (\\<exists> tr ys . d_reached_by M p xs q tr ys)\""], ["", "fun d_reachable :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \\<Rightarrow> 'state set\" where\n  \"d_reachable M p = { q . (\\<exists> xs . d_reaches M p xs q) }\""], ["", "lemma d_reaches_unique[elim] : \n  assumes \"d_reaches M p xs q1\"\n  and    \"d_reaches M p xs q2\"\nshows \"q1 = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 = q2", "using assms"], ["proof (prove)\nusing this:\n  d_reaches M p xs q1\n  d_reaches M p xs q2\n\ngoal (1 subgoal):\n 1. q1 = q2", "unfolding d_reaches.simps"], ["proof (prove)\nusing this:\n  \\<exists>tr ys. d_reached_by M p xs q1 tr ys\n  \\<exists>tr ys. d_reached_by M p xs q2 tr ys\n\ngoal (1 subgoal):\n 1. q1 = q2", "by blast"], ["", "lemma d_reaches_unique_cases[simp] : \"{ q . d_reaches M (initial M) xs q } = {} \n                                      \\<or> (\\<exists> q2 . { q . d_reaches M (initial M) xs q } = { q2 })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. d_reaches M (initial M) xs q} = {} \\<or>\n    (\\<exists>q2. {q. d_reaches M (initial M) xs q} = {q2})", "unfolding d_reaches.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. \\<exists>tr ys. d_reached_by M (initial M) xs q tr ys} = {} \\<or>\n    (\\<exists>q2.\n        {q. \\<exists>tr ys. d_reached_by M (initial M) xs q tr ys} = {q2})", "by blast"], ["", "lemma d_reaches_unique_obtain[simp] :\n  assumes \"d_reaches M (initial M) xs q\"\nshows \"{ p . d_reaches M (initial M) xs p } = { q }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. d_reaches M (initial M) xs p} = {q}", "using assms"], ["proof (prove)\nusing this:\n  d_reaches M (initial M) xs q\n\ngoal (1 subgoal):\n 1. {p. d_reaches M (initial M) xs p} = {q}", "unfolding d_reaches.simps"], ["proof (prove)\nusing this:\n  \\<exists>tr ys. d_reached_by M (initial M) xs q tr ys\n\ngoal (1 subgoal):\n 1. {p. \\<exists>tr ys. d_reached_by M (initial M) xs p tr ys} = {q}", "by blast"], ["", "lemma d_reaches_io_target :\n  assumes \"d_reaches M p xs q\"\n  and     \"length ys = length xs\"\nshows \"io_targets M p (xs || ys) \\<subseteq> {q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M p (xs || ys) \\<subseteq> {q}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> io_targets M p (xs || ys) \\<Longrightarrow> x \\<in> {q}", "fix q'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> io_targets M p (xs || ys) \\<Longrightarrow> x \\<in> {q}", "assume \"q' \\<in> io_targets M p (xs || ys)\""], ["proof (state)\nthis:\n  q' \\<in> io_targets M p (xs || ys)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> io_targets M p (xs || ys) \\<Longrightarrow> x \\<in> {q}", "then"], ["proof (chain)\npicking this:\n  q' \\<in> io_targets M p (xs || ys)", "obtain trQ where \"path M ((xs || ys) || trQ) p \\<and> length (xs || ys) = length trQ\""], ["proof (prove)\nusing this:\n  q' \\<in> io_targets M p (xs || ys)\n\ngoal (1 subgoal):\n 1. (\\<And>trQ.\n        path M ((xs || ys) || trQ) p \\<and>\n        length (xs || ys) = length trQ \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M ((xs || ys) || trQ) p \\<and> length (xs || ys) = length trQ\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> io_targets M p (xs || ys) \\<Longrightarrow> x \\<in> {q}", "moreover"], ["proof (state)\nthis:\n  path M ((xs || ys) || trQ) p \\<and> length (xs || ys) = length trQ\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> io_targets M p (xs || ys) \\<Longrightarrow> x \\<in> {q}", "obtain trD ysD where \"d_reached_by M p xs q trD ysD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ysD trD.\n        d_reached_by M p xs q trD ysD \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  d_reaches M p xs q\n\ngoal (1 subgoal):\n 1. (\\<And>ysD trD.\n        d_reached_by M p xs q trD ysD \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d_reached_by M p xs q trD ysD\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> io_targets M p (xs || ys) \\<Longrightarrow> x \\<in> {q}", "ultimately"], ["proof (chain)\npicking this:\n  path M ((xs || ys) || trQ) p \\<and> length (xs || ys) = length trQ\n  d_reached_by M p xs q trD ysD", "have \"target ((xs || ys) || trQ) p = q\""], ["proof (prove)\nusing this:\n  path M ((xs || ys) || trQ) p \\<and> length (xs || ys) = length trQ\n  d_reached_by M p xs q trD ysD\n\ngoal (1 subgoal):\n 1. target ((xs || ys) || trQ) p = q", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  target ((xs || ys) || trQ) p = q\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> io_targets M p (xs || ys) \\<Longrightarrow> x \\<in> {q}", "then"], ["proof (chain)\npicking this:\n  target ((xs || ys) || trQ) p = q", "show \"q' \\<in> {q}\""], ["proof (prove)\nusing this:\n  target ((xs || ys) || trQ) p = q\n\ngoal (1 subgoal):\n 1. q' \\<in> {q}", "using \\<open>d_reached_by M p xs q trD ysD\\<close> \\<open>q' \\<in> io_targets M p (xs || ys)\\<close> assms(2)"], ["proof (prove)\nusing this:\n  target ((xs || ys) || trQ) p = q\n  d_reached_by M p xs q trD ysD\n  q' \\<in> io_targets M p (xs || ys)\n  length ys = length xs\n\ngoal (1 subgoal):\n 1. q' \\<in> {q}", "by auto"], ["proof (state)\nthis:\n  q' \\<in> {q}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma d_reachable_reachable : \"d_reachable M p \\<subseteq> reachable M p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_reachable M p \\<subseteq> reachable M p", "unfolding d_reaches.simps d_reachable.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. \\<exists>xs tr ys. d_reached_by M p xs q tr ys}\n    \\<subseteq> reachable M p", "by blast"], ["", "subsection \\<open> Deterministic state cover \\<close>"], ["", "text \\<open>\nThe deterministic state cover of some FSM is a minimal set of input sequences such that every\nd-reachable state of the FSM is d-reached by a sequence in the set and the set contains the\nempty sequence (which d-reaches the initial state). \n\\<close>"], ["", "fun is_det_state_cover_ass :: \"('in, 'out, 'state) FSM \\<Rightarrow> ('state \\<Rightarrow> 'in list) \\<Rightarrow> bool\" where\n  \"is_det_state_cover_ass M f = (f (initial M) = [] \\<and> (\\<forall> s \\<in> d_reachable M (initial M) . \n                                                                d_reaches M (initial M) (f s) s))\""], ["", "lemma det_state_cover_ass_dist : \n  assumes \"is_det_state_cover_ass M f\"\n  and     \"s1 \\<in> d_reachable M (initial M)\"\n  and     \"s2 \\<in> d_reachable M (initial M)\"\n  and     \"s1 \\<noteq> s2\"\nshows \"\\<not>(d_reaches M (initial M) (f s2) s1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> d_reaches M (initial M) (f s2) s1", "by (meson assms(1) assms(3) assms(4) d_reaches_unique is_det_state_cover_ass.simps)"], ["", "lemma det_state_cover_ass_diff :\n  assumes \"is_det_state_cover_ass M f\"\n  and     \"s1 \\<in> d_reachable M (initial M)\"\n  and     \"s2 \\<in> d_reachable M (initial M)\"\n  and     \"s1 \\<noteq> s2\"\nshows \"f s1 \\<noteq> f s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f s1 \\<noteq> f s2", "by (metis assms det_state_cover_ass_dist is_det_state_cover_ass.simps)"], ["", "fun is_det_state_cover :: \"('in, 'out, 'state) FSM \\<Rightarrow> 'in list set \\<Rightarrow> bool\" where\n  \"is_det_state_cover M V = (\\<exists> f . is_det_state_cover_ass M f \n                                    \\<and> V = image f (d_reachable M (initial M)))\""], ["", "lemma det_state_cover_d_reachable[elim] :\n  assumes \"is_det_state_cover M V\"\n  and     \"v \\<in> V\"\nobtains q\nwhere \"d_reaches M (initial M) v q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        d_reaches M (initial M) v q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, hide_lams) assms(1) assms(2) image_iff is_det_state_cover.simps \n      is_det_state_cover_ass.elims(2))"], ["", "lemma det_state_cover_card[simp] :\n  assumes \"is_det_state_cover M V\"\n  and     \"finite (nodes M)\"\nshows   \"card (d_reachable M (initial M)) = card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (d_reachable M (initial M)) = card V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (d_reachable M (initial M)) = card V", "obtain f where f_def : \"is_det_state_cover_ass M f \\<and> V = image f (d_reachable M (initial M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        is_det_state_cover_ass M f \\<and>\n        V = f ` d_reachable M (initial M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_det_state_cover M V\n  finite (nodes M)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        is_det_state_cover_ass M f \\<and>\n        V = f ` d_reachable M (initial M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding is_det_state_cover.simps"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     is_det_state_cover_ass M f \\<and> V = f ` d_reachable M (initial M)\n  finite (nodes M)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        is_det_state_cover_ass M f \\<and>\n        V = f ` d_reachable M (initial M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_det_state_cover_ass M f \\<and> V = f ` d_reachable M (initial M)\n\ngoal (1 subgoal):\n 1. card (d_reachable M (initial M)) = card V", "then"], ["proof (chain)\npicking this:\n  is_det_state_cover_ass M f \\<and> V = f ` d_reachable M (initial M)", "have card_f : \"card V = card (image f (d_reachable M (initial M)))\""], ["proof (prove)\nusing this:\n  is_det_state_cover_ass M f \\<and> V = f ` d_reachable M (initial M)\n\ngoal (1 subgoal):\n 1. card V = card (f ` d_reachable M (initial M))", "by simp"], ["proof (state)\nthis:\n  card V = card (f ` d_reachable M (initial M))\n\ngoal (1 subgoal):\n 1. card (d_reachable M (initial M)) = card V", "have \"d_reachable M (initial M) \\<subseteq> nodes M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_reachable M (initial M) \\<subseteq> nodes M", "unfolding d_reachable.simps d_reaches.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. \\<exists>xs tr ys. d_reached_by M (initial M) xs q tr ys}\n    \\<subseteq> nodes M", "using d_reachable_reachable"], ["proof (prove)\nusing this:\n  d_reachable ?M ?p \\<subseteq> reachable ?M ?p\n\ngoal (1 subgoal):\n 1. {q. \\<exists>xs tr ys. d_reached_by M (initial M) xs q tr ys}\n    \\<subseteq> nodes M", "by blast"], ["proof (state)\nthis:\n  d_reachable M (initial M) \\<subseteq> nodes M\n\ngoal (1 subgoal):\n 1. card (d_reachable M (initial M)) = card V", "then"], ["proof (chain)\npicking this:\n  d_reachable M (initial M) \\<subseteq> nodes M", "have dr_finite : \"finite (d_reachable M (initial M))\""], ["proof (prove)\nusing this:\n  d_reachable M (initial M) \\<subseteq> nodes M\n\ngoal (1 subgoal):\n 1. finite (d_reachable M (initial M))", "using assms infinite_super"], ["proof (prove)\nusing this:\n  d_reachable M (initial M) \\<subseteq> nodes M\n  is_det_state_cover M V\n  finite (nodes M)\n  \\<lbrakk>?S \\<subseteq> ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite ?T\n\ngoal (1 subgoal):\n 1. finite (d_reachable M (initial M))", "by blast"], ["proof (state)\nthis:\n  finite (d_reachable M (initial M))\n\ngoal (1 subgoal):\n 1. card (d_reachable M (initial M)) = card V", "then"], ["proof (chain)\npicking this:\n  finite (d_reachable M (initial M))", "have card_le : \"card (image f (d_reachable M (initial M))) \\<le> card (d_reachable M (initial M))\""], ["proof (prove)\nusing this:\n  finite (d_reachable M (initial M))\n\ngoal (1 subgoal):\n 1. card (f ` d_reachable M (initial M))\n    \\<le> card (d_reachable M (initial M))", "using card_image_le"], ["proof (prove)\nusing this:\n  finite (d_reachable M (initial M))\n  finite ?A \\<Longrightarrow> card (?f ` ?A) \\<le> card ?A\n\ngoal (1 subgoal):\n 1. card (f ` d_reachable M (initial M))\n    \\<le> card (d_reachable M (initial M))", "by blast"], ["proof (state)\nthis:\n  card (f ` d_reachable M (initial M))\n  \\<le> card (d_reachable M (initial M))\n\ngoal (1 subgoal):\n 1. card (d_reachable M (initial M)) = card V", "have \"card (image f (d_reachable M (initial M))) = card (d_reachable M (initial M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f ` d_reachable M (initial M)) = card (d_reachable M (initial M))", "by (meson card_image det_state_cover_ass_diff f_def inj_onI)"], ["proof (state)\nthis:\n  card (f ` d_reachable M (initial M)) = card (d_reachable M (initial M))\n\ngoal (1 subgoal):\n 1. card (d_reachable M (initial M)) = card V", "then"], ["proof (chain)\npicking this:\n  card (f ` d_reachable M (initial M)) = card (d_reachable M (initial M))", "show ?thesis"], ["proof (prove)\nusing this:\n  card (f ` d_reachable M (initial M)) = card (d_reachable M (initial M))\n\ngoal (1 subgoal):\n 1. card (d_reachable M (initial M)) = card V", "using card_f"], ["proof (prove)\nusing this:\n  card (f ` d_reachable M (initial M)) = card (d_reachable M (initial M))\n  card V = card (f ` d_reachable M (initial M))\n\ngoal (1 subgoal):\n 1. card (d_reachable M (initial M)) = card V", "by auto"], ["proof (state)\nthis:\n  card (d_reachable M (initial M)) = card V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_state_cover_finite :\n  assumes \"is_det_state_cover M V\"\n  and     \"finite (nodes M)\"\nshows \"finite V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite V", "have \"d_reachable M (initial M) \\<subseteq> nodes M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_reachable M (initial M) \\<subseteq> nodes M", "by auto"], ["proof (state)\nthis:\n  d_reachable M (initial M) \\<subseteq> nodes M\n\ngoal (1 subgoal):\n 1. finite V", "show \"finite V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V", "using det_state_cover_card[OF assms]"], ["proof (prove)\nusing this:\n  card (d_reachable M (initial M)) = card V\n\ngoal (1 subgoal):\n 1. finite V", "by (metis \\<open>d_reachable M (initial M) \\<subseteq> nodes M\\<close> assms(1) assms(2) finite_imageI infinite_super \n        is_det_state_cover.simps)"], ["proof (state)\nthis:\n  finite V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_state_cover_initial :\n  assumes \"is_det_state_cover M V\"\n  shows   \"[] \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<in> V", "have \"d_reached_by M (initial M) [] (initial M) [] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_reached_by M (initial M) [] (initial M) [] []", "by (simp add: FSM.nil)"], ["proof (state)\nthis:\n  d_reached_by M (initial M) [] (initial M) [] []\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "then"], ["proof (chain)\npicking this:\n  d_reached_by M (initial M) [] (initial M) [] []", "have \"d_reaches M (initial M) [] (initial M)\""], ["proof (prove)\nusing this:\n  d_reached_by M (initial M) [] (initial M) [] []\n\ngoal (1 subgoal):\n 1. d_reaches M (initial M) [] (initial M)", "by auto"], ["proof (state)\nthis:\n  d_reaches M (initial M) [] (initial M)\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "have \"initial M \\<in> d_reachable M (initial M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial M \\<in> d_reachable M (initial M)", "by (metis (no_types) \\<open>d_reaches M (initial M) [] (initial M)\\<close> d_reachable.simps mem_Collect_eq)"], ["proof (state)\nthis:\n  initial M \\<in> d_reachable M (initial M)\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "then"], ["proof (chain)\npicking this:\n  initial M \\<in> d_reachable M (initial M)", "show ?thesis"], ["proof (prove)\nusing this:\n  initial M \\<in> d_reachable M (initial M)\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "by (metis (no_types, lifting) assms image_iff is_det_state_cover.elims(2) \n        is_det_state_cover_ass.simps)"], ["proof (state)\nthis:\n  [] \\<in> V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_state_cover_empty : \n  assumes \"is_det_state_cover M V\"\n  shows \"[] \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<in> V", "obtain f where f_def : \"is_det_state_cover_ass M f \\<and> V = f ` d_reachable M (initial M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        is_det_state_cover_ass M f \\<and>\n        V = f ` d_reachable M (initial M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_det_state_cover M V\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        is_det_state_cover_ass M f \\<and>\n        V = f ` d_reachable M (initial M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_det_state_cover_ass M f \\<and> V = f ` d_reachable M (initial M)\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "then"], ["proof (chain)\npicking this:\n  is_det_state_cover_ass M f \\<and> V = f ` d_reachable M (initial M)", "have \"f (initial M) = []\""], ["proof (prove)\nusing this:\n  is_det_state_cover_ass M f \\<and> V = f ` d_reachable M (initial M)\n\ngoal (1 subgoal):\n 1. f (initial M) = []", "by auto"], ["proof (state)\nthis:\n  f (initial M) = []\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "moreover"], ["proof (state)\nthis:\n  f (initial M) = []\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "have \"initial M \\<in> d_reachable M (initial M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial M \\<in> d_reachable M (initial M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. initial M \\<in> d_reachable M (initial M)", "have \"d_reaches M (initial M) [] (initial M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_reaches M (initial M) [] (initial M)", "by auto"], ["proof (state)\nthis:\n  d_reaches M (initial M) [] (initial M)\n\ngoal (1 subgoal):\n 1. initial M \\<in> d_reachable M (initial M)", "then"], ["proof (chain)\npicking this:\n  d_reaches M (initial M) [] (initial M)", "show ?thesis"], ["proof (prove)\nusing this:\n  d_reaches M (initial M) [] (initial M)\n\ngoal (1 subgoal):\n 1. initial M \\<in> d_reachable M (initial M)", "by (metis d_reachable.simps mem_Collect_eq)"], ["proof (state)\nthis:\n  initial M \\<in> d_reachable M (initial M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  initial M \\<in> d_reachable M (initial M)\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "moreover"], ["proof (state)\nthis:\n  initial M \\<in> d_reachable M (initial M)\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "have \"f (initial M) \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (initial M) \\<in> V", "using f_def calculation"], ["proof (prove)\nusing this:\n  is_det_state_cover_ass M f \\<and> V = f ` d_reachable M (initial M)\n  f (initial M) = []\n  initial M \\<in> d_reachable M (initial M)\n\ngoal (1 subgoal):\n 1. f (initial M) \\<in> V", "by blast"], ["proof (state)\nthis:\n  f (initial M) \\<in> V\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "ultimately"], ["proof (chain)\npicking this:\n  f (initial M) = []\n  initial M \\<in> d_reachable M (initial M)\n  f (initial M) \\<in> V", "show ?thesis"], ["proof (prove)\nusing this:\n  f (initial M) = []\n  initial M \\<in> d_reachable M (initial M)\n  f (initial M) \\<in> V\n\ngoal (1 subgoal):\n 1. [] \\<in> V", "by auto"], ["proof (state)\nthis:\n  [] \\<in> V\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> IO reduction \\<close>"], ["", "text \\<open>\nAn FSM is a reduction of another, if its language is a subset of the language of the latter FSM.\n\\<close>"], ["", "fun io_reduction :: \"('in, 'out, 'state) FSM \\<Rightarrow> ('in, 'out, 'state) FSM \n                      \\<Rightarrow> bool\" (infix \"\\<preceq>\" 200) \n  where \n  \"M1 \\<preceq> M2 = (LS M1 (initial M1) \\<subseteq> LS M2 (initial M2))\""], ["", "lemma language_state_inclusion_of_state_reached_by_same_sequence : \n  assumes \"LS M1 q1 \\<subseteq> LS M2 q2\"\n  and     \"observable M1\"\n  and     \"observable M2\"\n  and     \"io_targets M1 q1 io = { q1t }\"\n  and     \"io_targets M2 q2 io = { q2t }\"\nshows \"LS M1 q1t \\<subseteq> LS M2 q2t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LS M1 q1t \\<subseteq> LS M2 q2t", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> LS M1 q1t \\<Longrightarrow> x \\<in> LS M2 q2t", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> LS M1 q1t \\<Longrightarrow> x \\<in> LS M2 q2t", "assume \"x \\<in> LS M1 q1t\""], ["proof (state)\nthis:\n  x \\<in> LS M1 q1t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> LS M1 q1t \\<Longrightarrow> x \\<in> LS M2 q2t", "obtain q1x where \"io_targets M1 q1t x = {q1x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1x.\n        io_targets M1 q1t x = {q1x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson \\<open>x \\<in> LS M1 q1t\\<close> assms(2) io_targets_observable_singleton_ex)"], ["proof (state)\nthis:\n  io_targets M1 q1t x = {q1x}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> LS M1 q1t \\<Longrightarrow> x \\<in> LS M2 q2t", "have \"io \\<in> LS M1 q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> LS M1 q1", "using assms(4)"], ["proof (prove)\nusing this:\n  io_targets M1 q1 io = {q1t}\n\ngoal (1 subgoal):\n 1. io \\<in> LS M1 q1", "by auto"], ["proof (state)\nthis:\n  io \\<in> LS M1 q1\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> LS M1 q1t \\<Longrightarrow> x \\<in> LS M2 q2t", "have \"io@x \\<in> LS M1 q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io @ x \\<in> LS M1 q1", "using observable_io_targets_append[OF assms(2) \\<open>io_targets M1 q1 io = { q1t }\\<close> \n          \\<open>io_targets M1 q1t x = {q1x}\\<close>]"], ["proof (prove)\nusing this:\n  io_targets M1 q1 (io @ x) = {q1x}\n\ngoal (1 subgoal):\n 1. io @ x \\<in> LS M1 q1", "by (metis io_targets_elim language_state singletonI)"], ["proof (state)\nthis:\n  io @ x \\<in> LS M1 q1\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> LS M1 q1t \\<Longrightarrow> x \\<in> LS M2 q2t", "then"], ["proof (chain)\npicking this:\n  io @ x \\<in> LS M1 q1", "have \"io@x \\<in> LS M2 q2\""], ["proof (prove)\nusing this:\n  io @ x \\<in> LS M1 q1\n\ngoal (1 subgoal):\n 1. io @ x \\<in> LS M2 q2", "using assms(1)"], ["proof (prove)\nusing this:\n  io @ x \\<in> LS M1 q1\n  LS M1 q1 \\<subseteq> LS M2 q2\n\ngoal (1 subgoal):\n 1. io @ x \\<in> LS M2 q2", "by blast"], ["proof (state)\nthis:\n  io @ x \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> LS M1 q1t \\<Longrightarrow> x \\<in> LS M2 q2t", "then"], ["proof (chain)\npicking this:\n  io @ x \\<in> LS M2 q2", "obtain q2x where \"io_targets M2 q2 (io@x) = {q2x}\""], ["proof (prove)\nusing this:\n  io @ x \\<in> LS M2 q2\n\ngoal (1 subgoal):\n 1. (\\<And>q2x.\n        io_targets M2 q2 (io @ x) = {q2x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(3) io_targets_observable_singleton_ex)"], ["proof (state)\nthis:\n  io_targets M2 q2 (io @ x) = {q2x}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> LS M1 q1t \\<Longrightarrow> x \\<in> LS M2 q2t", "show \"x \\<in> LS M2 q2t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> LS M2 q2t", "using observable_io_targets_split[OF assms(3) \\<open>io_targets M2 q2 (io @ x) = {q2x}\\<close> assms(5)]"], ["proof (prove)\nusing this:\n  io_targets M2 q2t x = {q2x}\n\ngoal (1 subgoal):\n 1. x \\<in> LS M2 q2t", "by auto"], ["proof (state)\nthis:\n  x \\<in> LS M2 q2t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Language subsets for input sequences \\<close>"], ["", "text \\<open>\nThe following definitions describe restrictions of languages to only those IO-sequences that \nexhibit a certain input sequence or whose input sequence is contained in a given set of\ninput sequences.\nThis allows to define the notion that some FSM is a reduction of another over a given set of\ninput sequences, but not necessarily over the entire language of the latter FSM.\n\\<close>"], ["", "fun language_state_for_input :: \n  \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \\<Rightarrow> 'in list \\<Rightarrow> ('in \\<times> 'out) list set\" where\n  \"language_state_for_input M q xs = {(xs || ys) | ys . (length xs = length ys \\<and> (xs || ys) \\<in> LS M q)}\""], ["", "fun language_state_for_inputs  :: \n  \"('in, 'out, 'state) FSM \\<Rightarrow> 'state \\<Rightarrow> 'in list set \\<Rightarrow> ('in \\<times> 'out) list set\" \n    (\"(LS\\<^sub>i\\<^sub>n _ _ _)\" [1000,1000,1000]) where\n  \"language_state_for_inputs  M q ISeqs = {(xs || ys) | xs ys . (xs \\<in> ISeqs \n                                                                  \\<and> length xs = length ys \n                                                                  \\<and> (xs || ys) \\<in> LS M q)}\""], ["", "abbreviation \"L\\<^sub>i\\<^sub>n M TS \\<equiv> LS\\<^sub>i\\<^sub>n M (initial M) TS\""], ["", "abbreviation  \"io_reduction_on M1 TS M2 \\<equiv> (L\\<^sub>i\\<^sub>n M1 TS \\<subseteq> L\\<^sub>i\\<^sub>n M2 TS)\""], ["", "notation \n  io_reduction_on (\"(_ \\<preceq>\\<lbrakk>_\\<rbrakk> _)\" [1000,0,0] 61)"], ["", "notation  (latex output)\n  io_reduction_on (\"(_ \\<preceq>\\<^bsub>_\\<^esub> _)\" [1000,0,0] 61)"], ["", "lemma language_state_for_input_alt_def :\n  \"language_state_for_input M q xs = LS\\<^sub>i\\<^sub>n M q {xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language_state_for_input M q xs = LS\\<^sub>i\\<^sub>n M q {xs}", "unfolding language_state_for_input.simps language_state_for_inputs.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs || ys |ys. length xs = length ys \\<and> xs || ys \\<in> LS M q} =\n    {xsa || ys |xsa ys.\n     xsa \\<in> {xs} \\<and>\n     length xsa = length ys \\<and> xsa || ys \\<in> LS M q}", "by blast"], ["", "lemma language_state_for_inputs_alt_def :\n  \"LS\\<^sub>i\\<^sub>n M q ISeqs = \\<Union> (image (language_state_for_input M q) ISeqs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LS\\<^sub>i\\<^sub>n M q ISeqs =\n    \\<Union> (language_state_for_input M q ` ISeqs)", "by auto"], ["", "lemma language_state_for_inputs_in_language_state :\n  \"LS\\<^sub>i\\<^sub>n M q T \\<subseteq> language_state M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LS\\<^sub>i\\<^sub>n M q T \\<subseteq> LS M q", "unfolding language_state_for_inputs.simps language_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs || ys |xs ys.\n     xs \\<in> T \\<and>\n     length xs = length ys \\<and> xs || ys \\<in> {map fst r |r. path M r q}}\n    \\<subseteq> {map fst r |r. path M r q}", "by blast"], ["", "lemma language_state_for_inputs_map_fst :\n  assumes \"io \\<in> language_state M q\"\n  and     \"map fst io \\<in> T\"\nshows \"io \\<in> LS\\<^sub>i\\<^sub>n M q T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> LS\\<^sub>i\\<^sub>n M q T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io \\<in> LS\\<^sub>i\\<^sub>n M q T", "let ?xs = \"map fst io\""], ["proof (state)\ngoal (1 subgoal):\n 1. io \\<in> LS\\<^sub>i\\<^sub>n M q T", "let ?ys = \"map snd io\""], ["proof (state)\ngoal (1 subgoal):\n 1. io \\<in> LS\\<^sub>i\\<^sub>n M q T", "have \"?xs \\<in> T \\<and> length ?xs = length ?ys \\<and> ?xs || ?ys \\<in> language_state M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst io \\<in> T \\<and>\n    length (map fst io) = length (map snd io) \\<and>\n    map fst io || map snd io \\<in> LS M q", "using assms(2,1)"], ["proof (prove)\nusing this:\n  map fst io \\<in> T\n  io \\<in> LS M q\n\ngoal (1 subgoal):\n 1. map fst io \\<in> T \\<and>\n    length (map fst io) = length (map snd io) \\<and>\n    map fst io || map snd io \\<in> LS M q", "by auto"], ["proof (state)\nthis:\n  map fst io \\<in> T \\<and>\n  length (map fst io) = length (map snd io) \\<and>\n  map fst io || map snd io \\<in> LS M q\n\ngoal (1 subgoal):\n 1. io \\<in> LS\\<^sub>i\\<^sub>n M q T", "then"], ["proof (chain)\npicking this:\n  map fst io \\<in> T \\<and>\n  length (map fst io) = length (map snd io) \\<and>\n  map fst io || map snd io \\<in> LS M q", "have \"?xs || ?ys \\<in> LS\\<^sub>i\\<^sub>n M q T\""], ["proof (prove)\nusing this:\n  map fst io \\<in> T \\<and>\n  length (map fst io) = length (map snd io) \\<and>\n  map fst io || map snd io \\<in> LS M q\n\ngoal (1 subgoal):\n 1. map fst io || map snd io \\<in> LS\\<^sub>i\\<^sub>n M q T", "unfolding language_state_for_inputs.simps"], ["proof (prove)\nusing this:\n  map fst io \\<in> T \\<and>\n  length (map fst io) = length (map snd io) \\<and>\n  map fst io || map snd io \\<in> LS M q\n\ngoal (1 subgoal):\n 1. map fst io || map snd io\n    \\<in> {xs || ys |xs ys.\n           xs \\<in> T \\<and>\n           length xs = length ys \\<and> xs || ys \\<in> LS M q}", "by blast"], ["proof (state)\nthis:\n  map fst io || map snd io \\<in> LS\\<^sub>i\\<^sub>n M q T\n\ngoal (1 subgoal):\n 1. io \\<in> LS\\<^sub>i\\<^sub>n M q T", "then"], ["proof (chain)\npicking this:\n  map fst io || map snd io \\<in> LS\\<^sub>i\\<^sub>n M q T", "show ?thesis"], ["proof (prove)\nusing this:\n  map fst io || map snd io \\<in> LS\\<^sub>i\\<^sub>n M q T\n\ngoal (1 subgoal):\n 1. io \\<in> LS\\<^sub>i\\<^sub>n M q T", "by simp"], ["proof (state)\nthis:\n  io \\<in> LS\\<^sub>i\\<^sub>n M q T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma language_state_for_inputs_nonempty :\n  assumes \"set xs \\<subseteq> inputs M\"\n  and     \"completely_specified M\"\n  and     \"q \\<in> nodes M\"\nshows \"LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> inputs M\n  completely_specified M\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq> {}", "proof (induction xs arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>set [] \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {[]} \\<noteq> {}\n 2. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> inputs M\n  completely_specified M\n  q \\<in> nodes M\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>set [] \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {[]} \\<noteq> {}\n 2. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  set [] \\<subseteq> inputs M\n  completely_specified M\n  q \\<in> nodes M", "show ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> inputs M\n  completely_specified M\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. LS\\<^sub>i\\<^sub>n M q {[]} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  LS\\<^sub>i\\<^sub>n M q {[]} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>set xs \\<subseteq> inputs M; completely_specified M;\n   ?q \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M ?q {xs} \\<noteq> {}\n  set (x # xs) \\<subseteq> inputs M\n  completely_specified M\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>set xs \\<subseteq> inputs M; completely_specified M;\n   ?q \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M ?q {xs} \\<noteq> {}\n  set (x # xs) \\<subseteq> inputs M\n  completely_specified M\n  q \\<in> nodes M", "have \"x \\<in> inputs M\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs \\<subseteq> inputs M; completely_specified M;\n   ?q \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M ?q {xs} \\<noteq> {}\n  set (x # xs) \\<subseteq> inputs M\n  completely_specified M\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. x \\<in> inputs M", "by simp"], ["proof (state)\nthis:\n  x \\<in> inputs M\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  x \\<in> inputs M", "obtain y q' where x_step : \"q' \\<in> succ M (x,y) q\""], ["proof (prove)\nusing this:\n  x \\<in> inputs M\n\ngoal (1 subgoal):\n 1. (\\<And>q' y.\n        q' \\<in> succ M (x, y) q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons(3,4)"], ["proof (prove)\nusing this:\n  x \\<in> inputs M\n  completely_specified M\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. (\\<And>q' y.\n        q' \\<in> succ M (x, y) q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding completely_specified.simps"], ["proof (prove)\nusing this:\n  x \\<in> inputs M\n  \\<forall>s1\\<in>nodes M.\n     \\<forall>x\\<in>inputs M.\n        \\<exists>y\\<in>outputs M. \\<exists>s2. s2 \\<in> succ M (x, y) s1\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. (\\<And>q' y.\n        q' \\<in> succ M (x, y) q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q' \\<in> succ M (x, y) q\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  q' \\<in> succ M (x, y) q", "have \"path M ([(x,y)] || [q']) q \\<and> length [q] = length [(x,y)]\" \n            \"target ([(x,y)] || [q']) q = q'\""], ["proof (prove)\nusing this:\n  q' \\<in> succ M (x, y) q\n\ngoal (1 subgoal):\n 1. path M ([(x, y)] || [q']) q \\<and> length [q] = length [(x, y)] &&&\n    target ([(x, y)] || [q']) q = q'", "by auto"], ["proof (state)\nthis:\n  path M ([(x, y)] || [q']) q \\<and> length [q] = length [(x, y)]\n  target ([(x, y)] || [q']) q = q'\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  path M ([(x, y)] || [q']) q \\<and> length [q] = length [(x, y)]\n  target ([(x, y)] || [q']) q = q'", "have \"q' \\<in> nodes M\""], ["proof (prove)\nusing this:\n  path M ([(x, y)] || [q']) q \\<and> length [q] = length [(x, y)]\n  target ([(x, y)] || [q']) q = q'\n\ngoal (1 subgoal):\n 1. q' \\<in> nodes M", "using Cons(4)"], ["proof (prove)\nusing this:\n  path M ([(x, y)] || [q']) q \\<and> length [q] = length [(x, y)]\n  target ([(x, y)] || [q']) q = q'\n  q \\<in> nodes M\n\ngoal (1 subgoal):\n 1. q' \\<in> nodes M", "by (metis FSM.nodes_target)"], ["proof (state)\nthis:\n  q' \\<in> nodes M\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  q' \\<in> nodes M", "have \"LS\\<^sub>i\\<^sub>n M q' {xs} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  q' \\<in> nodes M\n\ngoal (1 subgoal):\n 1. LS\\<^sub>i\\<^sub>n M q' {xs} \\<noteq> {}", "using Cons.prems Cons.IH"], ["proof (prove)\nusing this:\n  q' \\<in> nodes M\n  set (x # xs) \\<subseteq> inputs M\n  completely_specified M\n  q \\<in> nodes M\n  \\<lbrakk>set xs \\<subseteq> inputs M; completely_specified M;\n   ?q \\<in> nodes M\\<rbrakk>\n  \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M ?q {xs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. LS\\<^sub>i\\<^sub>n M q' {xs} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  LS\\<^sub>i\\<^sub>n M q' {xs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  LS\\<^sub>i\\<^sub>n M q' {xs} \\<noteq> {}", "obtain ys where \"length xs = length ys \\<and> (xs || ys) \\<in> LS M q'\""], ["proof (prove)\nusing this:\n  LS\\<^sub>i\\<^sub>n M q' {xs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        length xs = length ys \\<and>\n        xs || ys \\<in> LS M q' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length xs = length ys \\<and> xs || ys \\<in> LS M q'\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  length xs = length ys \\<and> xs || ys \\<in> LS M q'", "obtain tr where \"path M ((xs || ys) || tr) q' \\<and> length tr = length (xs || ys)\""], ["proof (prove)\nusing this:\n  length xs = length ys \\<and> xs || ys \\<in> LS M q'\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        path M ((xs || ys) || tr) q' \\<and>\n        length tr = length (xs || ys) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M ((xs || ys) || tr) q' \\<and> length tr = length (xs || ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  path M ((xs || ys) || tr) q' \\<and> length tr = length (xs || ys)", "have \"path M ([(x,y)] @ (xs || ys) || [q'] @ tr) q \n              \\<and> length ([q'] @ tr) = length ([(x,y)] @ (xs || ys))\""], ["proof (prove)\nusing this:\n  path M ((xs || ys) || tr) q' \\<and> length tr = length (xs || ys)\n\ngoal (1 subgoal):\n 1. path M ([(x, y)] @ (xs || ys) || [q'] @ tr) q \\<and>\n    length ([q'] @ tr) = length ([(x, y)] @ (xs || ys))", "by (simp add: FSM.path.intros(2) x_step)"], ["proof (state)\nthis:\n  path M ([(x, y)] @ (xs || ys) || [q'] @ tr) q \\<and>\n  length ([q'] @ tr) = length ([(x, y)] @ (xs || ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  path M ([(x, y)] @ (xs || ys) || [q'] @ tr) q \\<and>\n  length ([q'] @ tr) = length ([(x, y)] @ (xs || ys))", "have \"path M ((x#xs || y#ys) || [q'] @ tr) q \\<and> length ([q'] @ tr) = length (x#xs || y#ys)\""], ["proof (prove)\nusing this:\n  path M ([(x, y)] @ (xs || ys) || [q'] @ tr) q \\<and>\n  length ([q'] @ tr) = length ([(x, y)] @ (xs || ys))\n\ngoal (1 subgoal):\n 1. path M ((x # xs || y # ys) || [q'] @ tr) q \\<and>\n    length ([q'] @ tr) = length (x # xs || y # ys)", "by auto"], ["proof (state)\nthis:\n  path M ((x # xs || y # ys) || [q'] @ tr) q \\<and>\n  length ([q'] @ tr) = length (x # xs || y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  path M ((x # xs || y # ys) || [q'] @ tr) q \\<and>\n  length ([q'] @ tr) = length (x # xs || y # ys)", "have \"(x#xs || y#ys) \\<in> LS M q\""], ["proof (prove)\nusing this:\n  path M ((x # xs || y # ys) || [q'] @ tr) q \\<and>\n  length ([q'] @ tr) = length (x # xs || y # ys)\n\ngoal (1 subgoal):\n 1. x # xs || y # ys \\<in> LS M q", "by (metis language_state)"], ["proof (state)\nthis:\n  x # xs || y # ys \\<in> LS M q\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  x # xs || y # ys \\<in> LS M q\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "have \"length (x#xs) = length (y#ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (x # xs) = length (y # ys)", "by (simp add: \\<open>length xs = length ys \\<and> xs || ys \\<in> LS M q'\\<close>)"], ["proof (state)\nthis:\n  length (x # xs) = length (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  x # xs || y # ys \\<in> LS M q\n  length (x # xs) = length (y # ys)", "have \"(x#xs || y#ys) \\<in> LS\\<^sub>i\\<^sub>n M q {x # xs}\""], ["proof (prove)\nusing this:\n  x # xs || y # ys \\<in> LS M q\n  length (x # xs) = length (y # ys)\n\ngoal (1 subgoal):\n 1. x # xs || y # ys \\<in> LS\\<^sub>i\\<^sub>n M q {x # xs}", "unfolding language_state_for_inputs.simps"], ["proof (prove)\nusing this:\n  x # xs || y # ys \\<in> LS M q\n  length (x # xs) = length (y # ys)\n\ngoal (1 subgoal):\n 1. x # xs || y # ys\n    \\<in> {xs || ys |xs ys.\n           xs \\<in> {x # xs} \\<and>\n           length xs = length ys \\<and> xs || ys \\<in> LS M q}", "by blast"], ["proof (state)\nthis:\n  x # xs || y # ys \\<in> LS\\<^sub>i\\<^sub>n M q {x # xs}\n\ngoal (1 subgoal):\n 1. \\<And>a xs q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>set xs \\<subseteq> inputs M;\n                    completely_specified M; q \\<in> nodes M\\<rbrakk>\n                   \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {xs} \\<noteq>\n                                     {};\n        set (a # xs) \\<subseteq> inputs M; completely_specified M;\n        q \\<in> nodes M\\<rbrakk>\n       \\<Longrightarrow> LS\\<^sub>i\\<^sub>n M q {a # xs} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  x # xs || y # ys \\<in> LS\\<^sub>i\\<^sub>n M q {x # xs}", "show ?case"], ["proof (prove)\nusing this:\n  x # xs || y # ys \\<in> LS\\<^sub>i\\<^sub>n M q {x # xs}\n\ngoal (1 subgoal):\n 1. LS\\<^sub>i\\<^sub>n M q {x # xs} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  LS\\<^sub>i\\<^sub>n M q {x # xs} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma language_state_for_inputs_map_fst_contained :\n  assumes \"vs \\<in> LS\\<^sub>i\\<^sub>n M q V\"\nshows \"map fst vs \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "have \"(map fst vs) || (map snd vs) = vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst vs || map snd vs = vs", "by auto"], ["proof (state)\nthis:\n  map fst vs || map snd vs = vs\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "then"], ["proof (chain)\npicking this:\n  map fst vs || map snd vs = vs", "have \"(map fst vs) || (map snd vs) \\<in> LS\\<^sub>i\\<^sub>n M q V\""], ["proof (prove)\nusing this:\n  map fst vs || map snd vs = vs\n\ngoal (1 subgoal):\n 1. map fst vs || map snd vs \\<in> LS\\<^sub>i\\<^sub>n M q V", "using assms"], ["proof (prove)\nusing this:\n  map fst vs || map snd vs = vs\n  vs \\<in> LS\\<^sub>i\\<^sub>n M q V\n\ngoal (1 subgoal):\n 1. map fst vs || map snd vs \\<in> LS\\<^sub>i\\<^sub>n M q V", "by auto"], ["proof (state)\nthis:\n  map fst vs || map snd vs \\<in> LS\\<^sub>i\\<^sub>n M q V\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "then"], ["proof (chain)\npicking this:\n  map fst vs || map snd vs \\<in> LS\\<^sub>i\\<^sub>n M q V", "show ?thesis"], ["proof (prove)\nusing this:\n  map fst vs || map snd vs \\<in> LS\\<^sub>i\\<^sub>n M q V\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "by auto"], ["proof (state)\nthis:\n  map fst vs \\<in> V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma language_state_for_inputs_empty : \n  assumes \"[] \\<in> V\"\n  shows \"[] \\<in> LS\\<^sub>i\\<^sub>n M q V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> LS\\<^sub>i\\<^sub>n M q V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<in> LS\\<^sub>i\\<^sub>n M q V", "have \"[] \\<in> language_state_for_input M q []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> language_state_for_input M q []", "by auto"], ["proof (state)\nthis:\n  [] \\<in> language_state_for_input M q []\n\ngoal (1 subgoal):\n 1. [] \\<in> LS\\<^sub>i\\<^sub>n M q V", "then"], ["proof (chain)\npicking this:\n  [] \\<in> language_state_for_input M q []", "show ?thesis"], ["proof (prove)\nusing this:\n  [] \\<in> language_state_for_input M q []\n\ngoal (1 subgoal):\n 1. [] \\<in> LS\\<^sub>i\\<^sub>n M q V", "using language_state_for_inputs_alt_def"], ["proof (prove)\nusing this:\n  [] \\<in> language_state_for_input M q []\n  LS\\<^sub>i\\<^sub>n ?M ?q ?ISeqs =\n  \\<Union> (language_state_for_input ?M ?q ` ?ISeqs)\n\ngoal (1 subgoal):\n 1. [] \\<in> LS\\<^sub>i\\<^sub>n M q V", "by (metis UN_I assms)"], ["proof (state)\nthis:\n  [] \\<in> LS\\<^sub>i\\<^sub>n M q V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma language_state_for_input_empty[simp] : \n  \"language_state_for_input M q [] = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language_state_for_input M q [] = {[]}", "by auto"], ["", "lemma language_state_for_input_take :\n  assumes \"io \\<in> language_state_for_input M q xs\"\nshows \"take n io \\<in> language_state_for_input M q (take n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "obtain ys where \"io = xs || ys\" \"length xs = length ys\" \"xs || ys \\<in> language_state M q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>io = xs || ys; length xs = length ys;\n         xs || ys \\<in> LS M q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  io \\<in> language_state_for_input M q xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>io = xs || ys; length xs = length ys;\n         xs || ys \\<in> LS M q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  io = xs || ys\n  length xs = length ys\n  xs || ys \\<in> LS M q\n\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "then"], ["proof (chain)\npicking this:\n  io = xs || ys\n  length xs = length ys\n  xs || ys \\<in> LS M q", "obtain p where \"length p = length xs\" \"path M ((xs || ys) || p) q \""], ["proof (prove)\nusing this:\n  io = xs || ys\n  length xs = length ys\n  xs || ys \\<in> LS M q\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>length p = length xs; path M ((xs || ys) || p) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length p = length xs\n  path M ((xs || ys) || p) q\n\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "then"], ["proof (chain)\npicking this:\n  length p = length xs\n  path M ((xs || ys) || p) q", "have \"path M (take n ((xs || ys) || p)) q\""], ["proof (prove)\nusing this:\n  length p = length xs\n  path M ((xs || ys) || p) q\n\ngoal (1 subgoal):\n 1. path M (take n ((xs || ys) || p)) q", "by (metis FSM.path_append_elim append_take_drop_id)"], ["proof (state)\nthis:\n  path M (take n ((xs || ys) || p)) q\n\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "then"], ["proof (chain)\npicking this:\n  path M (take n ((xs || ys) || p)) q", "have \"take n (xs || ys) \\<in> language_state M q\""], ["proof (prove)\nusing this:\n  path M (take n ((xs || ys) || p)) q\n\ngoal (1 subgoal):\n 1. take n (xs || ys) \\<in> LS M q", "by (simp add: \\<open>length p = length xs\\<close> \\<open>length xs = length ys\\<close> language_state take_zip)"], ["proof (state)\nthis:\n  take n (xs || ys) \\<in> LS M q\n\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "then"], ["proof (chain)\npicking this:\n  take n (xs || ys) \\<in> LS M q", "have \"(take n xs) || (take n ys) \\<in> language_state M q\""], ["proof (prove)\nusing this:\n  take n (xs || ys) \\<in> LS M q\n\ngoal (1 subgoal):\n 1. take n xs || take n ys \\<in> LS M q", "by (simp add: take_zip)"], ["proof (state)\nthis:\n  take n xs || take n ys \\<in> LS M q\n\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "have \"take n io = (take n xs) || (take n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n io = take n xs || take n ys", "using \\<open>io = xs || ys\\<close> take_zip"], ["proof (prove)\nusing this:\n  io = xs || ys\n  take ?n (?xs || ?ys) = take ?n ?xs || take ?n ?ys\n\ngoal (1 subgoal):\n 1. take n io = take n xs || take n ys", "by blast"], ["proof (state)\nthis:\n  take n io = take n xs || take n ys\n\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "moreover"], ["proof (state)\nthis:\n  take n io = take n xs || take n ys\n\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "have \"length (take n xs) = length (take n ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take n xs) = length (take n ys)", "by (simp add: \\<open>length xs = length ys\\<close>)"], ["proof (state)\nthis:\n  length (take n xs) = length (take n ys)\n\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "ultimately"], ["proof (chain)\npicking this:\n  take n io = take n xs || take n ys\n  length (take n xs) = length (take n ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  take n io = take n xs || take n ys\n  length (take n xs) = length (take n ys)\n\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "using \\<open>(take n xs) || (take n ys) \\<in> language_state M q\\<close>"], ["proof (prove)\nusing this:\n  take n io = take n xs || take n ys\n  length (take n xs) = length (take n ys)\n  take n xs || take n ys \\<in> LS M q\n\ngoal (1 subgoal):\n 1. take n io \\<in> language_state_for_input M q (take n xs)", "unfolding language_state_for_input.simps"], ["proof (prove)\nusing this:\n  take n io = take n xs || take n ys\n  length (take n xs) = length (take n ys)\n  take n xs || take n ys \\<in> LS M q\n\ngoal (1 subgoal):\n 1. take n io\n    \\<in> {take n xs || ys |ys.\n           length (take n xs) = length ys \\<and>\n           take n xs || ys \\<in> LS M q}", "by blast"], ["proof (state)\nthis:\n  take n io \\<in> language_state_for_input M q (take n xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma language_state_for_inputs_prefix :\n  assumes \"vs@xs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'@xs'}\"\n  and \"length vs = length vs'\"\nshows \"vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}", "have \"vs@xs \\<in> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M1", "using assms(1)"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L\\<^sub>i\\<^sub>n M1 {vs' @ xs'}\n\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M1", "by auto"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M1\n\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}", "then"], ["proof (chain)\npicking this:\n  vs @ xs \\<in> L M1", "have \"vs \\<in> L M1\""], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M1\n\ngoal (1 subgoal):\n 1. vs \\<in> L M1", "by (meson language_state_prefix)"], ["proof (state)\nthis:\n  vs \\<in> L M1\n\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}", "then"], ["proof (chain)\npicking this:\n  vs \\<in> L M1", "have \"vs \\<in> L\\<^sub>i\\<^sub>n M1 {map fst vs}\""], ["proof (prove)\nusing this:\n  vs \\<in> L M1\n\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 {map fst vs}", "by (meson insertI1 language_state_for_inputs_map_fst)"], ["proof (state)\nthis:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 {map fst vs}\n\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}", "moreover"], ["proof (state)\nthis:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 {map fst vs}\n\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}", "have \"vs' = map fst vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs' = map fst vs", "by (metis append_eq_append_conv assms(1) assms(2) language_state_for_inputs_map_fst_contained \n        length_map map_append singletonD)"], ["proof (state)\nthis:\n  vs' = map fst vs\n\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}", "ultimately"], ["proof (chain)\npicking this:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 {map fst vs}\n  vs' = map fst vs", "show ?thesis"], ["proof (prove)\nusing this:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 {map fst vs}\n  vs' = map fst vs\n\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}", "by blast"], ["proof (state)\nthis:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 {vs'}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma language_state_for_inputs_union : \n  shows \"LS\\<^sub>i\\<^sub>n M q T1 \\<union> LS\\<^sub>i\\<^sub>n M q T2 = LS\\<^sub>i\\<^sub>n M q (T1 \\<union> T2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LS\\<^sub>i\\<^sub>n M q T1 \\<union> LS\\<^sub>i\\<^sub>n M q T2 =\n    LS\\<^sub>i\\<^sub>n M q (T1 \\<union> T2)", "unfolding language_state_for_inputs.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs || ys |xs ys.\n     xs \\<in> T1 \\<and>\n     length xs = length ys \\<and> xs || ys \\<in> LS M q} \\<union>\n    {xs || ys |xs ys.\n     xs \\<in> T2 \\<and>\n     length xs = length ys \\<and> xs || ys \\<in> LS M q} =\n    {xs || ys |xs ys.\n     xs \\<in> T1 \\<union> T2 \\<and>\n     length xs = length ys \\<and> xs || ys \\<in> LS M q}", "by blast"], ["", "lemma io_reduction_on_subset :\n  assumes \"io_reduction_on M1 T M2\"\n  and     \"T' \\<subseteq> T\"\nshows \"io_reduction_on M1 T' M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2 \\<Longrightarrow> False", "assume \"\\<not> io_reduction_on M1 T' M2\""], ["proof (state)\nthis:\n  \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2", "obtain xs' where \"xs' \\<in> T'\" \"\\<not> L\\<^sub>i\\<^sub>n M1 {xs'} \\<subseteq> L\\<^sub>i\\<^sub>n M2 {xs'}\""], ["proof (prove)\nusing this:\n  \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>xs' \\<in> T';\n         \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                \\<lbrakk>xs' \\<in> T';\n                 \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have f1: \"\\<forall>ps P Pa. (ps::('a \\<times> 'b) list) \\<notin> P \\<or> \\<not> P \\<subseteq> Pa \\<or> ps \\<in> Pa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps P Pa.\n       ps \\<notin> P \\<or> \\<not> P \\<subseteq> Pa \\<or> ps \\<in> Pa", "by blast"], ["proof (state)\nthis:\n  \\<forall>ps P Pa.\n     ps \\<notin> P \\<or> \\<not> P \\<subseteq> Pa \\<or> ps \\<in> Pa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                \\<lbrakk>xs' \\<in> T';\n                 \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain pps :: \"('a \\<times> 'b) list set \\<Rightarrow> ('a \\<times> 'b) list set \\<Rightarrow> ('a \\<times> 'b) list\" where\n      \"\\<forall>x0 x1. (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) = (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pps.\n        \\<forall>x0 x1.\n           (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n           (pps x0 x1 \\<in> x1 \\<and>\n            pps x0 x1 \\<notin> x0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                \\<lbrakk>xs' \\<in> T';\n                 \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)", "have f2: \"\\<forall>P Pa. pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n\ngoal (1 subgoal):\n 1. \\<forall>P Pa.\n       pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa", "by (meson subsetI)"], ["proof (state)\nthis:\n  \\<forall>P Pa.\n     pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                \\<lbrakk>xs' \\<in> T';\n                 \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2\\<rbrakk>\n    \\<Longrightarrow> thesis", "have f3: \"\\<forall>ps f c A. (ps::('a \\<times> 'b) list) \\<notin> LS\\<^sub>i\\<^sub>n f (c::'c) A \\<or> map fst ps \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ps f c A.\n       ps \\<notin> LS\\<^sub>i\\<^sub>n f c A \\<or> map fst ps \\<in> A", "by (meson language_state_for_inputs_map_fst_contained)"], ["proof (state)\nthis:\n  \\<forall>ps f c A.\n     ps \\<notin> LS\\<^sub>i\\<^sub>n f c A \\<or> map fst ps \\<in> A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                \\<lbrakk>xs' \\<in> T';\n                 \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>ps f c A.\n     ps \\<notin> LS\\<^sub>i\\<^sub>n f c A \\<or> map fst ps \\<in> A", "have \"L\\<^sub>i\\<^sub>n M1 T' \\<subseteq> L\\<^sub>i\\<^sub>n M1 T\""], ["proof (prove)\nusing this:\n  \\<forall>ps f c A.\n     ps \\<notin> LS\\<^sub>i\\<^sub>n f c A \\<or> map fst ps \\<in> A\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 T' \\<subseteq> L\\<^sub>i\\<^sub>n M1 T", "using f2"], ["proof (prove)\nusing this:\n  \\<forall>ps f c A.\n     ps \\<notin> LS\\<^sub>i\\<^sub>n f c A \\<or> map fst ps \\<in> A\n  \\<forall>P Pa.\n     pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa\n\ngoal (1 subgoal):\n 1. L\\<^sub>i\\<^sub>n M1 T' \\<subseteq> L\\<^sub>i\\<^sub>n M1 T", "by (meson assms(2) language_state_for_inputs_in_language_state \n                    language_state_for_inputs_map_fst set_rev_mp)"], ["proof (state)\nthis:\n  L\\<^sub>i\\<^sub>n M1 T' \\<subseteq> L\\<^sub>i\\<^sub>n M1 T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs'.\n                \\<lbrakk>xs' \\<in> T';\n                 \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  L\\<^sub>i\\<^sub>n M1 T' \\<subseteq> L\\<^sub>i\\<^sub>n M1 T", "show ?thesis"], ["proof (prove)\nusing this:\n  L\\<^sub>i\\<^sub>n M1 T' \\<subseteq> L\\<^sub>i\\<^sub>n M1 T\n\ngoal (1 subgoal):\n 1. thesis", "using f3 f2 f1"], ["proof (prove)\nusing this:\n  L\\<^sub>i\\<^sub>n M1 T' \\<subseteq> L\\<^sub>i\\<^sub>n M1 T\n  \\<forall>ps f c A.\n     ps \\<notin> LS\\<^sub>i\\<^sub>n f c A \\<or> map fst ps \\<in> A\n  \\<forall>P Pa.\n     pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa \\<or> P \\<subseteq> Pa\n  \\<forall>ps P Pa.\n     ps \\<notin> P \\<or> \\<not> P \\<subseteq> Pa \\<or> ps \\<in> Pa\n\ngoal (1 subgoal):\n 1. thesis", "by (meson \\<open>\\<not> io_reduction_on M1 T' M2\\<close> assms(1) \n                          language_state_for_inputs_in_language_state \n                          language_state_for_inputs_map_fst)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs' \\<in> T'\n  \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xs' \\<in> T'\n  \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2", "have \"xs' \\<in> T\""], ["proof (prove)\nusing this:\n  xs' \\<in> T'\n  \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. xs' \\<in> T", "using assms(2)"], ["proof (prove)\nusing this:\n  xs' \\<in> T'\n  \\<not> M1 \\<preceq>\\<lbrakk>{xs'}\\<rbrakk> M2\n  T' \\<subseteq> T\n\ngoal (1 subgoal):\n 1. xs' \\<in> T", "by blast"], ["proof (state)\nthis:\n  xs' \\<in> T\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2 \\<Longrightarrow> False", "have \"\\<not> io_reduction_on M1 T M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "have f1: \"\\<forall>as. as \\<notin> T' \\<or> as \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>as. as \\<notin> T' \\<or> as \\<in> T", "using assms(2)"], ["proof (prove)\nusing this:\n  T' \\<subseteq> T\n\ngoal (1 subgoal):\n 1. \\<forall>as. as \\<notin> T' \\<or> as \\<in> T", "by auto"], ["proof (state)\nthis:\n  \\<forall>as. as \\<notin> T' \\<or> as \\<in> T\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "obtain pps :: \"('a \\<times> 'b) list set \\<Rightarrow> ('a \\<times> 'b) list set \\<Rightarrow> ('a \\<times> 'b) list\" where\n      \"\\<forall>x0 x1. (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) = (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pps.\n        \\<forall>x0 x1.\n           (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n           (pps x0 x1 \\<in> x1 \\<and>\n            pps x0 x1 \\<notin> x0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)", "have \"\\<forall>P Pa. (\\<not> P \\<subseteq> Pa \\<or> (\\<forall>ps. ps \\<notin> P \\<or> ps \\<in> Pa)) \n                      \\<and> (P \\<subseteq> Pa \\<or> pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa)\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> x1 \\<and> v2 \\<notin> x0) =\n     (pps x0 x1 \\<in> x1 \\<and> pps x0 x1 \\<notin> x0)\n\ngoal (1 subgoal):\n 1. \\<forall>P Pa.\n       (\\<not> P \\<subseteq> Pa \\<or>\n        (\\<forall>ps. ps \\<notin> P \\<or> ps \\<in> Pa)) \\<and>\n       (P \\<subseteq> Pa \\<or> pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa)", "by blast"], ["proof (state)\nthis:\n  \\<forall>P Pa.\n     (\\<not> P \\<subseteq> Pa \\<or>\n      (\\<forall>ps. ps \\<notin> P \\<or> ps \\<in> Pa)) \\<and>\n     (P \\<subseteq> Pa \\<or> pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa)\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  \\<forall>P Pa.\n     (\\<not> P \\<subseteq> Pa \\<or>\n      (\\<forall>ps. ps \\<notin> P \\<or> ps \\<in> Pa)) \\<and>\n     (P \\<subseteq> Pa \\<or> pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>P Pa.\n     (\\<not> P \\<subseteq> Pa \\<or>\n      (\\<forall>ps. ps \\<notin> P \\<or> ps \\<in> Pa)) \\<and>\n     (P \\<subseteq> Pa \\<or> pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa)\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>P Pa.\n     (\\<not> P \\<subseteq> Pa \\<or>\n      (\\<forall>ps. ps \\<notin> P \\<or> ps \\<in> Pa)) \\<and>\n     (P \\<subseteq> Pa \\<or> pps Pa P \\<in> P \\<and> pps Pa P \\<notin> Pa)\n  \\<forall>as. as \\<notin> T' \\<or> as \\<in> T\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "by (meson \\<open>\\<not> io_reduction_on M1 T' M2\\<close> language_state_for_inputs_in_language_state \n                    language_state_for_inputs_map_fst language_state_for_inputs_map_fst_contained)"], ["proof (state)\nthis:\n  \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>T'\\<rbrakk> M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. False", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<not> M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n  M1 \\<preceq>\\<lbrakk>T\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Sequences to failures \\<close>"], ["", "text \\<open>\nA sequence to a failure for FSMs @{verbatim M1} and @{verbatim M2} is a sequence such that any \nproper prefix of it is contained in the languages of both @{verbatim M1} and @{verbatim M2}, while \nthe sequence itself is contained only in the language of A.\n\nThat is, if a sequence to a failure for @{verbatim M1} and @{verbatim M2} exists, then \n@{verbatim M1} is not a reduction of @{verbatim M2}.\n\\<close>"], ["", "fun sequence_to_failure :: \n  \"('in,'out,'state) FSM \\<Rightarrow> ('in,'out,'state) FSM \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> bool\" where\n  \"sequence_to_failure M1 M2 xs = (\n    (butlast xs) \\<in> (language_state M2 (initial M2) \\<inter> language_state M1 (initial M1))\n    \\<and> xs \\<in> (language_state M1 (initial M1) - language_state M2 (initial M2)))\""], ["", "lemma sequence_to_failure_ob :\n  assumes \"\\<not> M1 \\<preceq> M2\"\n  and     \"well_formed M1\"\n  and     \"well_formed M2\"  \nobtains io\nwhere \"sequence_to_failure M1 M2 io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?diff = \"{ io . io \\<in> language_state M1 (initial M1) \\<and> io \\<notin> language_state M2 (initial M2)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"?diff \\<noteq> empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {io \\<in> L M1. io \\<notin> L M2} \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  \\<not> M1 \\<preceq> M2\n  well_formed M1\n  well_formed M2\n\ngoal (1 subgoal):\n 1. {io \\<in> L M1. io \\<notin> L M2} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {io \\<in> L M1. io \\<notin> L M2} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  {io \\<in> L M1. io \\<notin> L M2} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain io where io_def[simp] : \"io = arg_min length (\\<lambda> io . io \\<in> ?diff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>io.\n        io =\n        (ARG_MIN length io.\n            io \\<in> {io \\<in> L M1. io \\<notin> L M2}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> M1 \\<preceq> M2\n  well_formed M1\n  well_formed M2\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        io =\n        (ARG_MIN length io.\n            io \\<in> {io \\<in> L M1. io \\<notin> L M2}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  io = (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  {io \\<in> L M1. io \\<notin> L M2} \\<noteq> {}\n  io = (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})", "have io_diff : \"io \\<in> ?diff\""], ["proof (prove)\nusing this:\n  {io \\<in> L M1. io \\<notin> L M2} \\<noteq> {}\n  io = (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})\n\ngoal (1 subgoal):\n 1. io \\<in> {io \\<in> L M1. io \\<notin> L M2}", "using assms"], ["proof (prove)\nusing this:\n  {io \\<in> L M1. io \\<notin> L M2} \\<noteq> {}\n  io = (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})\n  \\<not> M1 \\<preceq> M2\n  well_formed M1\n  well_formed M2\n\ngoal (1 subgoal):\n 1. io \\<in> {io \\<in> L M1. io \\<notin> L M2}", "by (meson all_not_in_conv arg_min_natI)"], ["proof (state)\nthis:\n  io \\<in> {io \\<in> L M1. io \\<notin> L M2}\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  io \\<in> {io \\<in> L M1. io \\<notin> L M2}", "have \"io \\<noteq> []\""], ["proof (prove)\nusing this:\n  io \\<in> {io \\<in> L M1. io \\<notin> L M2}\n\ngoal (1 subgoal):\n 1. io \\<noteq> []", "using assms io_def language_state"], ["proof (prove)\nusing this:\n  io \\<in> {io \\<in> L M1. io \\<notin> L M2}\n  \\<not> M1 \\<preceq> M2\n  well_formed M1\n  well_formed M2\n  io = (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})\n  \\<lbrakk>path ?M (?w || ?r) ?q; length ?w = length ?r\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> LS ?M ?q\n\ngoal (1 subgoal):\n 1. io \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  io \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  io \\<noteq> []", "obtain io_init io_last where io_split[simp] : \"io = io_init @ [io_last]\""], ["proof (prove)\nusing this:\n  io \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>io_init io_last.\n        io = io_init @ [io_last] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id)"], ["proof (state)\nthis:\n  io = io_init @ [io_last]\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have io_init_inclusion : \"io_init \\<in> language_state M1 (initial M1) \n                            \\<and> io_init \\<in> language_state M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_init \\<in> L M1 \\<and> io_init \\<in> L M2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2) \\<Longrightarrow>\n    False", "assume assm : \"\\<not> (io_init \\<in> language_state M1 (initial M1) \n                        \\<and> io_init \\<in> language_state M2 (initial M2))\""], ["proof (state)\nthis:\n  \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2)\n\ngoal (1 subgoal):\n 1. \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2) \\<Longrightarrow>\n    False", "have \"io_init @ [io_last] \\<in> language_state M1 (initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_init @ [io_last] \\<in> L M1", "using io_diff io_split"], ["proof (prove)\nusing this:\n  io \\<in> {io \\<in> L M1. io \\<notin> L M2}\n  io = io_init @ [io_last]\n\ngoal (1 subgoal):\n 1. io_init @ [io_last] \\<in> L M1", "by auto"], ["proof (state)\nthis:\n  io_init @ [io_last] \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_init @ [io_last] \\<in> L M1", "have \"io_init \\<in> language_state M1 (initial M1)\""], ["proof (prove)\nusing this:\n  io_init @ [io_last] \\<in> L M1\n\ngoal (1 subgoal):\n 1. io_init \\<in> L M1", "by (meson language_state language_state_split)"], ["proof (state)\nthis:\n  io_init \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io_init \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2) \\<Longrightarrow>\n    False", "have \"io_init \\<notin> language_state M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_init \\<notin> L M2", "using assm calculation"], ["proof (prove)\nusing this:\n  \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2)\n  io_init \\<in> L M1\n\ngoal (1 subgoal):\n 1. io_init \\<notin> L M2", "by auto"], ["proof (state)\nthis:\n  io_init \\<notin> L M2\n\ngoal (1 subgoal):\n 1. \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  io_init \\<in> L M1\n  io_init \\<notin> L M2", "have \"io_init \\<in> ?diff\""], ["proof (prove)\nusing this:\n  io_init \\<in> L M1\n  io_init \\<notin> L M2\n\ngoal (1 subgoal):\n 1. io_init \\<in> {io \\<in> L M1. io \\<notin> L M2}", "by auto"], ["proof (state)\nthis:\n  io_init \\<in> {io \\<in> L M1. io \\<notin> L M2}\n\ngoal (1 subgoal):\n 1. \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  io_init \\<in> {io \\<in> L M1. io \\<notin> L M2}\n\ngoal (1 subgoal):\n 1. \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2) \\<Longrightarrow>\n    False", "have \"length io_init < length io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length io_init < length io", "using io_split"], ["proof (prove)\nusing this:\n  io = io_init @ [io_last]\n\ngoal (1 subgoal):\n 1. length io_init < length io", "by auto"], ["proof (state)\nthis:\n  length io_init < length io\n\ngoal (1 subgoal):\n 1. \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  io_init \\<in> {io \\<in> L M1. io \\<notin> L M2}\n  length io_init < length io", "have \"io \\<noteq> arg_min length (\\<lambda> io . io \\<in> ?diff)\""], ["proof (prove)\nusing this:\n  io_init \\<in> {io \\<in> L M1. io \\<notin> L M2}\n  length io_init < length io\n\ngoal (1 subgoal):\n 1. io \\<noteq>\n    (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>io_init \\<in> {io \\<in> L M1. io \\<notin> L M2};\n     length io_init < length io\\<rbrakk>\n    \\<Longrightarrow> io \\<noteq>\n                      (ARG_MIN length io.\n                          io \\<in> {io \\<in> L M1. io \\<notin> L M2})", "have \"\\<exists>ps. ps \\<in> {ps \\<in> language_state M1 (initial M1). \n                              ps \\<notin> language_state M2 (initial M2)} \\<and> \\<not> length io \\<le> length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ps.\n       ps \\<in> {ps \\<in> L M1. ps \\<notin> L M2} \\<and>\n       \\<not> length io \\<le> length ps", "using \\<open>io_init \\<in> {io\\<in> language_state M1 (initial M1). io \\<notin> language_state M2 (initial M2)}\\<close>\n              \\<open>length io_init < length io\\<close> linorder_not_less"], ["proof (prove)\nusing this:\n  io_init \\<in> {io \\<in> L M1. io \\<notin> L M2}\n  length io_init < length io\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>ps.\n       ps \\<in> {ps \\<in> L M1. ps \\<notin> L M2} \\<and>\n       \\<not> length io \\<le> length ps", "by blast"], ["proof (state)\nthis:\n  \\<exists>ps.\n     ps \\<in> {ps \\<in> L M1. ps \\<notin> L M2} \\<and>\n     \\<not> length io \\<le> length ps\n\ngoal (1 subgoal):\n 1. \\<lbrakk>io_init \\<in> {io \\<in> L M1. io \\<notin> L M2};\n     length io_init < length io\\<rbrakk>\n    \\<Longrightarrow> io \\<noteq>\n                      (ARG_MIN length io.\n                          io \\<in> {io \\<in> L M1. io \\<notin> L M2})", "then"], ["proof (chain)\npicking this:\n  \\<exists>ps.\n     ps \\<in> {ps \\<in> L M1. ps \\<notin> L M2} \\<and>\n     \\<not> length io \\<le> length ps", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ps.\n     ps \\<in> {ps \\<in> L M1. ps \\<notin> L M2} \\<and>\n     \\<not> length io \\<le> length ps\n\ngoal (1 subgoal):\n 1. io \\<noteq>\n    (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})", "by (meson arg_min_nat_le)"], ["proof (state)\nthis:\n  io \\<noteq>\n  (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  io \\<noteq>\n  (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})\n\ngoal (1 subgoal):\n 1. \\<not> (io_init \\<in> L M1 \\<and> io_init \\<in> L M2) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io \\<noteq>\n  (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})", "show \"False\""], ["proof (prove)\nusing this:\n  io \\<noteq>\n  (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})\n\ngoal (1 subgoal):\n 1. False", "using io_def"], ["proof (prove)\nusing this:\n  io \\<noteq>\n  (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})\n  io = (ARG_MIN length io. io \\<in> {io \\<in> L M1. io \\<notin> L M2})\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  io_init \\<in> L M1 \\<and> io_init \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  io_init \\<in> L M1 \\<and> io_init \\<in> L M2", "have \"sequence_to_failure M1 M2 io\""], ["proof (prove)\nusing this:\n  io_init \\<in> L M1 \\<and> io_init \\<in> L M2\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "using io_split io_diff"], ["proof (prove)\nusing this:\n  io_init \\<in> L M1 \\<and> io_init \\<in> L M2\n  io = io_init @ [io_last]\n  io \\<in> {io \\<in> L M1. io \\<notin> L M2}\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "by auto"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 io\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  sequence_to_failure M1 M2 io", "show ?thesis"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 io\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 io\n  sequence_to_failure M1 M2 ?io \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sequence_to_failure_succ :\n  assumes \"sequence_to_failure M1 M2 io\"\n  shows \"\\<forall> q \\<in> io_targets M2 (initial M2) (butlast io) . succ M2 (last io) q = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>io_targets M2 (initial M2) (butlast io).\n       succ M2 (last io) q = {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> io_targets M2 (initial M2) (butlast io) \\<Longrightarrow>\n       succ M2 (last io) q = {}", "have \"io \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 io\n\ngoal (1 subgoal):\n 1. io \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  io \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> io_targets M2 (initial M2) (butlast io) \\<Longrightarrow>\n       succ M2 (last io) q = {}", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> io_targets M2 (initial M2) (butlast io) \\<Longrightarrow>\n       succ M2 (last io) q = {}", "assume \"q \\<in> io_targets M2 (initial M2) (butlast io)\""], ["proof (state)\nthis:\n  q \\<in> io_targets M2 (initial M2) (butlast io)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> io_targets M2 (initial M2) (butlast io) \\<Longrightarrow>\n       succ M2 (last io) q = {}", "then"], ["proof (chain)\npicking this:\n  q \\<in> io_targets M2 (initial M2) (butlast io)", "obtain tr where \"q = target (butlast io || tr) (initial M2)\"\n                 and   \"path M2 (butlast io || tr) (initial M2)\"\n                 and   \"length (butlast io) = length tr\""], ["proof (prove)\nusing this:\n  q \\<in> io_targets M2 (initial M2) (butlast io)\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>q = target (butlast io || tr) (initial M2);\n         path M2 (butlast io || tr) (initial M2);\n         length (butlast io) = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding io_targets.simps"], ["proof (prove)\nusing this:\n  q \\<in> {target (butlast io || tr) (initial M2) |tr.\n           path M2 (butlast io || tr) (initial M2) \\<and>\n           length (butlast io) = length tr}\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>q = target (butlast io || tr) (initial M2);\n         path M2 (butlast io || tr) (initial M2);\n         length (butlast io) = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q = target (butlast io || tr) (initial M2)\n  path M2 (butlast io || tr) (initial M2)\n  length (butlast io) = length tr\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> io_targets M2 (initial M2) (butlast io) \\<Longrightarrow>\n       succ M2 (last io) q = {}", "show \"succ M2 (last io) q = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ M2 (last io) q = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. succ M2 (last io) q \\<noteq> {} \\<Longrightarrow> False", "assume \"succ M2 (last io) q \\<noteq> {}\""], ["proof (state)\nthis:\n  succ M2 (last io) q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. succ M2 (last io) q \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  succ M2 (last io) q \\<noteq> {}", "obtain q' where \"q' \\<in> succ M2 (last io) q\""], ["proof (prove)\nusing this:\n  succ M2 (last io) q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        q' \\<in> succ M2 (last io) q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q' \\<in> succ M2 (last io) q\n\ngoal (1 subgoal):\n 1. succ M2 (last io) q \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  q' \\<in> succ M2 (last io) q", "have \"path M2 [(last io, q')] (target (butlast io || tr) (initial M2))\""], ["proof (prove)\nusing this:\n  q' \\<in> succ M2 (last io) q\n\ngoal (1 subgoal):\n 1. path M2 [(last io, q')] (target (butlast io || tr) (initial M2))", "using \\<open>q = target (butlast io || tr) (initial M2)\\<close>"], ["proof (prove)\nusing this:\n  q' \\<in> succ M2 (last io) q\n  q = target (butlast io || tr) (initial M2)\n\ngoal (1 subgoal):\n 1. path M2 [(last io, q')] (target (butlast io || tr) (initial M2))", "by auto"], ["proof (state)\nthis:\n  path M2 [(last io, q')] (target (butlast io || tr) (initial M2))\n\ngoal (1 subgoal):\n 1. succ M2 (last io) q \\<noteq> {} \\<Longrightarrow> False", "have \"path M2 ((butlast io || tr) @ [(last io, q')]) (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M2 ((butlast io || tr) @ [(last io, q')]) (initial M2)", "using \\<open>path M2 (butlast io || tr) (initial M2)\\<close> \n            \\<open>path M2 [(last io, q')] (target (butlast io || tr) (initial M2))\\<close>"], ["proof (prove)\nusing this:\n  path M2 (butlast io || tr) (initial M2)\n  path M2 [(last io, q')] (target (butlast io || tr) (initial M2))\n\ngoal (1 subgoal):\n 1. path M2 ((butlast io || tr) @ [(last io, q')]) (initial M2)", "by auto"], ["proof (state)\nthis:\n  path M2 ((butlast io || tr) @ [(last io, q')]) (initial M2)\n\ngoal (1 subgoal):\n 1. succ M2 (last io) q \\<noteq> {} \\<Longrightarrow> False", "have \"butlast io @ [last io] = io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast io @ [last io] = io", "by (meson \\<open>io \\<noteq> []\\<close> append_butlast_last_id)"], ["proof (state)\nthis:\n  butlast io @ [last io] = io\n\ngoal (1 subgoal):\n 1. succ M2 (last io) q \\<noteq> {} \\<Longrightarrow> False", "have \"path M2 (io || (tr@[q'])) (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M2 (io || tr @ [q']) (initial M2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path M2 (io || tr @ [q']) (initial M2)", "have \"path M2 ((butlast io || tr) @ ([last io] || [q'])) (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M2 ((butlast io || tr) @ ([last io] || [q'])) (initial M2)", "by (simp add: FSM.path_append \\<open>path M2 (butlast io || tr) (initial M2)\\<close> \n              \\<open>path M2 [(last io, q')] (target (butlast io || tr) (initial M2))\\<close>)"], ["proof (state)\nthis:\n  path M2 ((butlast io || tr) @ ([last io] || [q'])) (initial M2)\n\ngoal (1 subgoal):\n 1. path M2 (io || tr @ [q']) (initial M2)", "then"], ["proof (chain)\npicking this:\n  path M2 ((butlast io || tr) @ ([last io] || [q'])) (initial M2)", "show ?thesis"], ["proof (prove)\nusing this:\n  path M2 ((butlast io || tr) @ ([last io] || [q'])) (initial M2)\n\ngoal (1 subgoal):\n 1. path M2 (io || tr @ [q']) (initial M2)", "by (metis (no_types) \\<open>butlast io @ [last io] = io\\<close> \n              \\<open>length (butlast io) = length tr\\<close> zip_append)"], ["proof (state)\nthis:\n  path M2 (io || tr @ [q']) (initial M2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path M2 (io || tr @ [q']) (initial M2)\n\ngoal (1 subgoal):\n 1. succ M2 (last io) q \\<noteq> {} \\<Longrightarrow> False", "have \"io \\<in> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> L M2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io \\<in> L M2", "have \"length tr + (0 + Suc 0) = length io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length tr + (0 + Suc 0) = length io", "by (metis \\<open>butlast io @ [last io] = io\\<close> \\<open>length (butlast io) = length tr\\<close> \n            length_append list.size(3) list.size(4))"], ["proof (state)\nthis:\n  length tr + (0 + Suc 0) = length io\n\ngoal (1 subgoal):\n 1. io \\<in> L M2", "then"], ["proof (chain)\npicking this:\n  length tr + (0 + Suc 0) = length io", "show ?thesis"], ["proof (prove)\nusing this:\n  length tr + (0 + Suc 0) = length io\n\ngoal (1 subgoal):\n 1. io \\<in> L M2", "using \\<open>path M2 (io || tr @ [q']) (initial M2)\\<close>"], ["proof (prove)\nusing this:\n  length tr + (0 + Suc 0) = length io\n  path M2 (io || tr @ [q']) (initial M2)\n\ngoal (1 subgoal):\n 1. io \\<in> L M2", "by fastforce"], ["proof (state)\nthis:\n  io \\<in> L M2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. succ M2 (last io) q \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M2", "show \"False\""], ["proof (prove)\nusing this:\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  io \\<in> L M2\n  sequence_to_failure M1 M2 io\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  succ M2 (last io) q = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sequence_to_failure_non_nil : \n  assumes \"sequence_to_failure M1 M2 xs\"\n  shows \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> False", "assume \"xs = []\""], ["proof (state)\nthis:\n  xs = []\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xs = []", "have \"xs \\<in> L M1 \\<inter> L M2\""], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. xs \\<in> L M1 \\<inter> L M2", "by auto"], ["proof (state)\nthis:\n  xs \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xs \\<in> L M1 \\<inter> L M2", "show \"False\""], ["proof (prove)\nusing this:\n  xs \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  xs \\<in> L M1 \\<inter> L M2\n  sequence_to_failure M1 M2 xs\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sequence_to_failure_from_arbitrary_failure :\n  assumes \"vs@xs \\<in> L M1 - L M2\"\n    and \"vs \\<in> L M2 \\<inter> L M1\"\nshows \"\\<exists> xs' . prefix xs' xs \\<and> sequence_to_failure M1 M2 (vs@xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'. prefix xs' xs \\<and> sequence_to_failure M1 M2 (vs @ xs')", "using assms"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M1 - L M2\n  vs \\<in> L M2 \\<inter> L M1\n\ngoal (1 subgoal):\n 1. \\<exists>xs'. prefix xs' xs \\<and> sequence_to_failure M1 M2 (vs @ xs')", "proof (induction xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>vs @ [] \\<in> L M1 - L M2; vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         prefix xs' [] \\<and>\n                         sequence_to_failure M1 M2 (vs @ xs')\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>vs @ xs \\<in> L M1 - L M2;\n                 vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs'.\n                                     prefix xs' xs \\<and>\n                                     sequence_to_failure M1 M2 (vs @ xs');\n        vs @ xs @ [x] \\<in> L M1 - L M2;\n        vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            prefix xs' (xs @ [x]) \\<and>\n                            sequence_to_failure M1 M2 (vs @ xs')", "case Nil"], ["proof (state)\nthis:\n  vs @ [] \\<in> L M1 - L M2\n  vs \\<in> L M2 \\<inter> L M1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vs @ [] \\<in> L M1 - L M2; vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs'.\n                         prefix xs' [] \\<and>\n                         sequence_to_failure M1 M2 (vs @ xs')\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>vs @ xs \\<in> L M1 - L M2;\n                 vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs'.\n                                     prefix xs' xs \\<and>\n                                     sequence_to_failure M1 M2 (vs @ xs');\n        vs @ xs @ [x] \\<in> L M1 - L M2;\n        vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            prefix xs' (xs @ [x]) \\<and>\n                            sequence_to_failure M1 M2 (vs @ xs')", "then"], ["proof (chain)\npicking this:\n  vs @ [] \\<in> L M1 - L M2\n  vs \\<in> L M2 \\<inter> L M1", "show ?case"], ["proof (prove)\nusing this:\n  vs @ [] \\<in> L M1 - L M2\n  vs \\<in> L M2 \\<inter> L M1\n\ngoal (1 subgoal):\n 1. \\<exists>xs'. prefix xs' [] \\<and> sequence_to_failure M1 M2 (vs @ xs')", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs'. prefix xs' [] \\<and> sequence_to_failure M1 M2 (vs @ xs')\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>vs @ xs \\<in> L M1 - L M2;\n                 vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs'.\n                                     prefix xs' xs \\<and>\n                                     sequence_to_failure M1 M2 (vs @ xs');\n        vs @ xs @ [x] \\<in> L M1 - L M2;\n        vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            prefix xs' (xs @ [x]) \\<and>\n                            sequence_to_failure M1 M2 (vs @ xs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>vs @ xs \\<in> L M1 - L M2;\n                 vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs'.\n                                     prefix xs' xs \\<and>\n                                     sequence_to_failure M1 M2 (vs @ xs');\n        vs @ xs @ [x] \\<in> L M1 - L M2;\n        vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            prefix xs' (xs @ [x]) \\<and>\n                            sequence_to_failure M1 M2 (vs @ xs')", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>vs @ xs \\<in> L M1 - L M2; vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs'.\n                       prefix xs' xs \\<and>\n                       sequence_to_failure M1 M2 (vs @ xs')\n  vs @ xs @ [x] \\<in> L M1 - L M2\n  vs \\<in> L M2 \\<inter> L M1\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>vs @ xs \\<in> L M1 - L M2;\n                 vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs'.\n                                     prefix xs' xs \\<and>\n                                     sequence_to_failure M1 M2 (vs @ xs');\n        vs @ xs @ [x] \\<in> L M1 - L M2;\n        vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            prefix xs' (xs @ [x]) \\<and>\n                            sequence_to_failure M1 M2 (vs @ xs')", "have \"vs @ xs \\<in> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M1", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  vs @ xs @ [x] \\<in> L M1 - L M2\n\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M1", "by (metis Diff_iff append.assoc language_state_prefix)"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>vs @ xs \\<in> L M1 - L M2;\n                 vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs'.\n                                     prefix xs' xs \\<and>\n                                     sequence_to_failure M1 M2 (vs @ xs');\n        vs @ xs @ [x] \\<in> L M1 - L M2;\n        vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs'.\n                            prefix xs' (xs @ [x]) \\<and>\n                            sequence_to_failure M1 M2 (vs @ xs')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "proof (cases \"vs@xs \\<in> L M2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. vs @ xs \\<in> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')\n 2. vs @ xs \\<notin> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "case True"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M2\n\ngoal (2 subgoals):\n 1. vs @ xs \\<in> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')\n 2. vs @ xs \\<notin> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "have \"butlast (vs@xs@[x]) \\<in> L M2 \\<inter> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (vs @ xs @ [x]) \\<in> L M2 \\<inter> L M1", "using True \\<open>vs @ xs \\<in> L M1\\<close>"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M2\n  vs @ xs \\<in> L M1\n\ngoal (1 subgoal):\n 1. butlast (vs @ xs @ [x]) \\<in> L M2 \\<inter> L M1", "by (simp add: butlast_append)"], ["proof (state)\nthis:\n  butlast (vs @ xs @ [x]) \\<in> L M2 \\<inter> L M1\n\ngoal (2 subgoals):\n 1. vs @ xs \\<in> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')\n 2. vs @ xs \\<notin> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "then"], ["proof (chain)\npicking this:\n  butlast (vs @ xs @ [x]) \\<in> L M2 \\<inter> L M1", "show ?thesis"], ["proof (prove)\nusing this:\n  butlast (vs @ xs @ [x]) \\<in> L M2 \\<inter> L M1\n\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "using sequence_to_failure.simps snoc.prems"], ["proof (prove)\nusing this:\n  butlast (vs @ xs @ [x]) \\<in> L M2 \\<inter> L M1\n  sequence_to_failure ?M1.0 ?M2.0 ?xs =\n  (butlast ?xs \\<in> L ?M2.0 \\<inter> L ?M1.0 \\<and>\n   ?xs \\<in> L ?M1.0 - L ?M2.0)\n  vs @ xs @ [x] \\<in> L M1 - L M2\n  vs \\<in> L M2 \\<inter> L M1\n\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')\n\ngoal (1 subgoal):\n 1. vs @ xs \\<notin> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. vs @ xs \\<notin> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "case False"], ["proof (state)\nthis:\n  vs @ xs \\<notin> L M2\n\ngoal (1 subgoal):\n 1. vs @ xs \\<notin> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "then"], ["proof (chain)\npicking this:\n  vs @ xs \\<notin> L M2", "have \"vs@xs \\<in> L M1 - L M2\""], ["proof (prove)\nusing this:\n  vs @ xs \\<notin> L M2\n\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M1 - L M2", "using \\<open>vs @ xs \\<in> L M1\\<close>"], ["proof (prove)\nusing this:\n  vs @ xs \\<notin> L M2\n  vs @ xs \\<in> L M1\n\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L M1 - L M2", "by blast"], ["proof (state)\nthis:\n  vs @ xs \\<in> L M1 - L M2\n\ngoal (1 subgoal):\n 1. vs @ xs \\<notin> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "then"], ["proof (chain)\npicking this:\n  vs @ xs \\<in> L M1 - L M2", "obtain xs' where \"prefix xs' xs\" \"sequence_to_failure M1 M2 (vs@xs')\""], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M1 - L M2\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>prefix xs' xs;\n         sequence_to_failure M1 M2 (vs @ xs')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using snoc.prems(2) snoc.IH"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L M1 - L M2\n  vs \\<in> L M2 \\<inter> L M1\n  \\<lbrakk>vs @ xs \\<in> L M1 - L M2; vs \\<in> L M2 \\<inter> L M1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs'.\n                       prefix xs' xs \\<and>\n                       sequence_to_failure M1 M2 (vs @ xs')\n\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        \\<lbrakk>prefix xs' xs;\n         sequence_to_failure M1 M2 (vs @ xs')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prefix xs' xs\n  sequence_to_failure M1 M2 (vs @ xs')\n\ngoal (1 subgoal):\n 1. vs @ xs \\<notin> L M2 \\<Longrightarrow>\n    \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "then"], ["proof (chain)\npicking this:\n  prefix xs' xs\n  sequence_to_failure M1 M2 (vs @ xs')", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix xs' xs\n  sequence_to_failure M1 M2 (vs @ xs')\n\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "using prefix_snoc"], ["proof (prove)\nusing this:\n  prefix xs' xs\n  sequence_to_failure M1 M2 (vs @ xs')\n  prefix ?xs (?ys @ [?y]) = (?xs = ?ys @ [?y] \\<or> prefix ?xs ?ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs'.\n       prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs'.\n     prefix xs' (xs @ [x]) \\<and> sequence_to_failure M1 M2 (vs @ xs')\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following lemma shows that if @{verbatim M1} is not a reduction of @{verbatim M2}, then a \nminimal sequence to a failure exists that is of length at most the number of states in \n@{verbatim M1} times the number of states in @{verbatim M2}. \n\\<close>"], ["", "lemma sequence_to_failure_length :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"observable M1\"\n  and     \"observable M2\"\n  and     \"\\<not> M1 \\<preceq> M2\"\n  shows \"\\<exists> xs . sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "obtain seq where \"sequence_to_failure M1 M2 seq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>seq.\n        sequence_to_failure M1 M2 seq \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms sequence_to_failure_ob"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  observable M1\n  observable M2\n  \\<not> M1 \\<preceq> M2\n  \\<lbrakk>\\<not> ?M1.0 \\<preceq> ?M2.0; well_formed ?M1.0;\n   well_formed ?M2.0;\n   \\<And>io.\n      sequence_to_failure ?M1.0 ?M2.0 io \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>seq.\n        sequence_to_failure M1 M2 seq \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 seq\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  sequence_to_failure M1 M2 seq", "have \"seq \\<noteq> []\""], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 seq\n\ngoal (1 subgoal):\n 1. seq \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  seq \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "let ?bls = \"butlast seq\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"?bls \\<in> L M1\" \"?bls \\<in> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast seq \\<in> L M1 &&& butlast seq \\<in> L M2", "using \\<open>sequence_to_failure M1 M2 seq\\<close>"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 seq\n\ngoal (1 subgoal):\n 1. butlast seq \\<in> L M1 &&& butlast seq \\<in> L M2", "by auto"], ["proof (state)\nthis:\n  butlast seq \\<in> L M1\n  butlast seq \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  butlast seq \\<in> L M1\n  butlast seq \\<in> L M2", "obtain tr1b tr2b where \n    \"path M1 (?bls || tr1b) (initial M1)\"\n    \"length tr1b = length ?bls\"\n    \"path M2 (?bls || tr2b) (initial M2)\"\n    \"length ?bls = length tr2b\""], ["proof (prove)\nusing this:\n  butlast seq \\<in> L M1\n  butlast seq \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>tr1b tr2b.\n        \\<lbrakk>path M1 (butlast seq || tr1b) (initial M1);\n         length tr1b = length (butlast seq);\n         path M2 (butlast seq || tr2b) (initial M2);\n         length (butlast seq) = length tr2b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  path M1 (butlast seq || tr1b) (initial M1)\n  length tr1b = length (butlast seq)\n  path M2 (butlast seq || tr2b) (initial M2)\n  length (butlast seq) = length tr2b\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  path M1 (butlast seq || tr1b) (initial M1)\n  length tr1b = length (butlast seq)\n  path M2 (butlast seq || tr2b) (initial M2)\n  length (butlast seq) = length tr2b", "have \"length tr2b = length tr1b\""], ["proof (prove)\nusing this:\n  path M1 (butlast seq || tr1b) (initial M1)\n  length tr1b = length (butlast seq)\n  path M2 (butlast seq || tr2b) (initial M2)\n  length (butlast seq) = length tr2b\n\ngoal (1 subgoal):\n 1. length tr2b = length tr1b", "by auto"], ["proof (state)\nthis:\n  length tr2b = length tr1b\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "let ?PM = \"product M2 M1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"well_formed ?PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_formed (product M2 M1)", "using well_formed_product[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  well_formed (product M2 M1)\n\ngoal (1 subgoal):\n 1. well_formed (product M2 M1)", "by assumption"], ["proof (state)\nthis:\n  well_formed (product M2 M1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"path ?PM (?bls || tr2b || tr1b) (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (product M2 M1) (butlast seq || tr2b || tr1b)\n     (initial M2, initial M1)", "using product_path[OF \\<open>length ?bls = length tr2b\\<close> \\<open>length tr2b = length tr1b\\<close>, \n                       of M2 M1 \"initial M2\" \"initial M1\"]"], ["proof (prove)\nusing this:\n  path (product M2 M1) (butlast seq || tr2b || tr1b)\n   (initial M2, initial M1) =\n  (path M2 (butlast seq || tr2b) (initial M2) \\<and>\n   path M1 (butlast seq || tr1b) (initial M1))\n\ngoal (1 subgoal):\n 1. path (product M2 M1) (butlast seq || tr2b || tr1b)\n     (initial M2, initial M1)", "using \\<open>path M1 (butlast seq || tr1b) (initial M1)\\<close> \n          \\<open>path M2 (butlast seq || tr2b) (initial M2)\\<close>"], ["proof (prove)\nusing this:\n  path (product M2 M1) (butlast seq || tr2b || tr1b)\n   (initial M2, initial M1) =\n  (path M2 (butlast seq || tr2b) (initial M2) \\<and>\n   path M1 (butlast seq || tr1b) (initial M1))\n  path M1 (butlast seq || tr1b) (initial M1)\n  path M2 (butlast seq || tr2b) (initial M2)\n\ngoal (1 subgoal):\n 1. path (product M2 M1) (butlast seq || tr2b || tr1b)\n     (initial M2, initial M1)", "by blast"], ["proof (state)\nthis:\n  path (product M2 M1) (butlast seq || tr2b || tr1b)\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "let ?q1b = \"target (?bls || tr1b) (initial M1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "let ?q2b = \"target (?bls || tr2b) (initial M2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"io_targets M2 (initial M2) ?bls = {?q2b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) (butlast seq) =\n    {target (butlast seq || tr2b) (initial M2)}", "by (metis \\<open>length (butlast seq) = length tr2b\\<close> \\<open>path M2 (butlast seq || tr2b) (initial M2)\\<close> \n        assms(4) obs_target_is_io_targets)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (butlast seq) =\n  {target (butlast seq || tr2b) (initial M2)}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"io_targets M1 (initial M1) ?bls = {?q1b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) (butlast seq) =\n    {target (butlast seq || tr1b) (initial M1)}", "by (metis \\<open>length tr1b = length (butlast seq)\\<close> \\<open>path M1 (butlast seq || tr1b) (initial M1)\\<close> \n        assms(3) obs_target_is_io_targets)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) (butlast seq) =\n  {target (butlast seq || tr1b) (initial M1)}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"(?q2b, ?q1b) \\<in> reachable (product M2 M1) (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (target (butlast seq || tr2b) (initial M2),\n     target (butlast seq || tr1b) (initial M1))\n    \\<in> reachable (product M2 M1) (initial M2, initial M1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (target (butlast seq || tr2b) (initial M2),\n     target (butlast seq || tr1b) (initial M1))\n    \\<in> reachable (product M2 M1) (initial M2, initial M1)", "have \"target (butlast seq || tr2b || tr1b) (initial M2, initial M1) \n            \\<in> reachable (product M2 M1) (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (butlast seq || tr2b || tr1b) (initial M2, initial M1)\n    \\<in> reachable (product M2 M1) (initial M2, initial M1)", "using \\<open>path (product M2 M1) (butlast seq || tr2b || tr1b) (initial M2, initial M1)\\<close>"], ["proof (prove)\nusing this:\n  path (product M2 M1) (butlast seq || tr2b || tr1b)\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. target (butlast seq || tr2b || tr1b) (initial M2, initial M1)\n    \\<in> reachable (product M2 M1) (initial M2, initial M1)", "by blast"], ["proof (state)\nthis:\n  target (butlast seq || tr2b || tr1b) (initial M2, initial M1)\n  \\<in> reachable (product M2 M1) (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. (target (butlast seq || tr2b) (initial M2),\n     target (butlast seq || tr1b) (initial M1))\n    \\<in> reachable (product M2 M1) (initial M2, initial M1)", "then"], ["proof (chain)\npicking this:\n  target (butlast seq || tr2b || tr1b) (initial M2, initial M1)\n  \\<in> reachable (product M2 M1) (initial M2, initial M1)", "show ?thesis"], ["proof (prove)\nusing this:\n  target (butlast seq || tr2b || tr1b) (initial M2, initial M1)\n  \\<in> reachable (product M2 M1) (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. (target (butlast seq || tr2b) (initial M2),\n     target (butlast seq || tr1b) (initial M1))\n    \\<in> reachable (product M2 M1) (initial M2, initial M1)", "using \\<open>length (butlast seq) = length tr2b\\<close> \\<open>length tr2b = length tr1b\\<close>"], ["proof (prove)\nusing this:\n  target (butlast seq || tr2b || tr1b) (initial M2, initial M1)\n  \\<in> reachable (product M2 M1) (initial M2, initial M1)\n  length (butlast seq) = length tr2b\n  length tr2b = length tr1b\n\ngoal (1 subgoal):\n 1. (target (butlast seq || tr2b) (initial M2),\n     target (butlast seq || tr1b) (initial M1))\n    \\<in> reachable (product M2 M1) (initial M2, initial M1)", "by auto"], ["proof (state)\nthis:\n  (target (butlast seq || tr2b) (initial M2),\n   target (butlast seq || tr1b) (initial M1))\n  \\<in> reachable (product M2 M1) (initial M2, initial M1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (target (butlast seq || tr2b) (initial M2),\n   target (butlast seq || tr1b) (initial M1))\n  \\<in> reachable (product M2 M1) (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"(initial M2, initial M1) \\<in> nodes (product M2 M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (initial M2, initial M1) \\<in> nodes (product M2 M1)", "by (simp add: FSM.nodes.initial)"], ["proof (state)\nthis:\n  (initial M2, initial M1) \\<in> nodes (product M2 M1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "obtain p where repFreePath : \"path (product M2 M1) p (initial M2, initial M1) \\<and>\n        target p (initial M2, initial M1) =\n        (?q2b,?q1b)\"\n        \"distinct ((initial M2, initial M1) # states p (initial M2, initial M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path (product M2 M1) p (initial M2, initial M1) \\<and>\n                 target p (initial M2, initial M1) =\n                 (target (butlast seq || tr2b) (initial M2),\n                  target (butlast seq || tr1b) (initial M1));\n         distinct\n          ((initial M2, initial M1) #\n           states p (initial M2, initial M1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using reaching_path_without_repetition[OF \\<open>well_formed ?PM\\<close> \n          \\<open>(?q2b, ?q1b) \\<in> reachable (product M2 M1) (initial M2, initial M1)\\<close> \n          \\<open>(initial M2, initial M1) \\<in> nodes (product M2 M1)\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     path (product M2 M1) p (initial M2, initial M1) \\<and>\n     target p (initial M2, initial M1) =\n     (target (butlast seq || tr2b) (initial M2),\n      target (butlast seq || tr1b) (initial M1)) \\<and>\n     distinct ((initial M2, initial M1) # states p (initial M2, initial M1))\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path (product M2 M1) p (initial M2, initial M1) \\<and>\n                 target p (initial M2, initial M1) =\n                 (target (butlast seq || tr2b) (initial M2),\n                  target (butlast seq || tr1b) (initial M1));\n         distinct\n          ((initial M2, initial M1) #\n           states p (initial M2, initial M1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path (product M2 M1) p (initial M2, initial M1) \\<and>\n  target p (initial M2, initial M1) =\n  (target (butlast seq || tr2b) (initial M2),\n   target (butlast seq || tr1b) (initial M1))\n  distinct ((initial M2, initial M1) # states p (initial M2, initial M1))\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  path (product M2 M1) p (initial M2, initial M1) \\<and>\n  target p (initial M2, initial M1) =\n  (target (butlast seq || tr2b) (initial M2),\n   target (butlast seq || tr1b) (initial M1))\n  distinct ((initial M2, initial M1) # states p (initial M2, initial M1))", "have \"set (states p (initial M2, initial M1)) \\<subseteq> nodes ?PM\""], ["proof (prove)\nusing this:\n  path (product M2 M1) p (initial M2, initial M1) \\<and>\n  target p (initial M2, initial M1) =\n  (target (butlast seq || tr2b) (initial M2),\n   target (butlast seq || tr1b) (initial M1))\n  distinct ((initial M2, initial M1) # states p (initial M2, initial M1))\n\ngoal (1 subgoal):\n 1. set (states p (initial M2, initial M1))\n    \\<subseteq> nodes (product M2 M1)", "by (simp add: FSM.nodes_states \\<open>(initial M2, initial M1) \\<in> nodes (product M2 M1)\\<close>)"], ["proof (state)\nthis:\n  set (states p (initial M2, initial M1)) \\<subseteq> nodes (product M2 M1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "moreover"], ["proof (state)\nthis:\n  set (states p (initial M2, initial M1)) \\<subseteq> nodes (product M2 M1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"(initial M2, initial M1) \\<notin> set (states p (initial M2, initial M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (initial M2, initial M1)\n    \\<notin> set (states p (initial M2, initial M1))", "using \\<open>distinct ((initial M2, initial M1) # states p (initial M2, initial M1))\\<close>"], ["proof (prove)\nusing this:\n  distinct ((initial M2, initial M1) # states p (initial M2, initial M1))\n\ngoal (1 subgoal):\n 1. (initial M2, initial M1)\n    \\<notin> set (states p (initial M2, initial M1))", "by auto"], ["proof (state)\nthis:\n  (initial M2, initial M1) \\<notin> set (states p (initial M2, initial M1))\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "ultimately"], ["proof (chain)\npicking this:\n  set (states p (initial M2, initial M1)) \\<subseteq> nodes (product M2 M1)\n  (initial M2, initial M1) \\<notin> set (states p (initial M2, initial M1))", "have \"set (states p (initial M2, initial M1)) \\<subseteq> nodes ?PM - {(initial M2,initial M1)}\""], ["proof (prove)\nusing this:\n  set (states p (initial M2, initial M1)) \\<subseteq> nodes (product M2 M1)\n  (initial M2, initial M1) \\<notin> set (states p (initial M2, initial M1))\n\ngoal (1 subgoal):\n 1. set (states p (initial M2, initial M1))\n    \\<subseteq> nodes (product M2 M1) - {(initial M2, initial M1)}", "by blast"], ["proof (state)\nthis:\n  set (states p (initial M2, initial M1))\n  \\<subseteq> nodes (product M2 M1) - {(initial M2, initial M1)}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "moreover"], ["proof (state)\nthis:\n  set (states p (initial M2, initial M1))\n  \\<subseteq> nodes (product M2 M1) - {(initial M2, initial M1)}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"finite (nodes ?PM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes (product M2 M1))", "using \\<open>well_formed ?PM\\<close>"], ["proof (prove)\nusing this:\n  well_formed (product M2 M1)\n\ngoal (1 subgoal):\n 1. finite (nodes (product M2 M1))", "by auto"], ["proof (state)\nthis:\n  finite (nodes (product M2 M1))\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "ultimately"], ["proof (chain)\npicking this:\n  set (states p (initial M2, initial M1))\n  \\<subseteq> nodes (product M2 M1) - {(initial M2, initial M1)}\n  finite (nodes (product M2 M1))", "have \"card (set (states p (initial M2, initial M1))) < card (nodes ?PM)\""], ["proof (prove)\nusing this:\n  set (states p (initial M2, initial M1))\n  \\<subseteq> nodes (product M2 M1) - {(initial M2, initial M1)}\n  finite (nodes (product M2 M1))\n\ngoal (1 subgoal):\n 1. card (set (states p (initial M2, initial M1))) < |product M2 M1|", "by (metis \\<open>(initial M2, initial M1) \\<in> nodes (product M2 M1)\\<close> \n        \\<open>(initial M2, initial M1) \\<notin> set (states p (initial M2, initial M1))\\<close> \n        \\<open>set (states p (initial M2, initial M1)) \\<subseteq> nodes (product M2 M1)\\<close> \n        psubsetI psubset_card_mono)"], ["proof (state)\nthis:\n  card (set (states p (initial M2, initial M1))) < |product M2 M1|\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "moreover"], ["proof (state)\nthis:\n  card (set (states p (initial M2, initial M1))) < |product M2 M1|\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"card (set (states p (initial M2, initial M1))) \n                  = length (states p (initial M2, initial M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (states p (initial M2, initial M1))) =\n    length (states p (initial M2, initial M1))", "using distinct_card repFreePath(2)"], ["proof (prove)\nusing this:\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  distinct ((initial M2, initial M1) # states p (initial M2, initial M1))\n\ngoal (1 subgoal):\n 1. card (set (states p (initial M2, initial M1))) =\n    length (states p (initial M2, initial M1))", "by fastforce"], ["proof (state)\nthis:\n  card (set (states p (initial M2, initial M1))) =\n  length (states p (initial M2, initial M1))\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "ultimately"], ["proof (chain)\npicking this:\n  card (set (states p (initial M2, initial M1))) < |product M2 M1|\n  card (set (states p (initial M2, initial M1))) =\n  length (states p (initial M2, initial M1))", "have \"length (states p (initial M2, initial M1)) < |?PM|\""], ["proof (prove)\nusing this:\n  card (set (states p (initial M2, initial M1))) < |product M2 M1|\n  card (set (states p (initial M2, initial M1))) =\n  length (states p (initial M2, initial M1))\n\ngoal (1 subgoal):\n 1. length (states p (initial M2, initial M1)) < |product M2 M1|", "by linarith"], ["proof (state)\nthis:\n  length (states p (initial M2, initial M1)) < |product M2 M1|\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  length (states p (initial M2, initial M1)) < |product M2 M1|", "have \"length p < |?PM|\""], ["proof (prove)\nusing this:\n  length (states p (initial M2, initial M1)) < |product M2 M1|\n\ngoal (1 subgoal):\n 1. length p < |product M2 M1|", "by auto"], ["proof (state)\nthis:\n  length p < |product M2 M1|\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "let ?p1 = \"map (snd \\<circ> snd) p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "let ?p2 = \"map (fst \\<circ> snd) p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "let ?pIO = \"map fst p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"p = ?pIO || ?p2 || ?p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = map fst p || map (fst \\<circ> snd) p || map (snd \\<circ> snd) p", "by (metis map_map zip_map_fst_snd)"], ["proof (state)\nthis:\n  p = map fst p || map (fst \\<circ> snd) p || map (snd \\<circ> snd) p\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"path M2 (?pIO || ?p2) (initial M2)\"  \n       \"path M1 (?pIO || ?p1) (initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M2 (map fst p || map (fst \\<circ> snd) p) (initial M2) &&&\n    path M1 (map fst p || map (snd \\<circ> snd) p) (initial M1)", "using product_path[of ?pIO ?p2 ?p1 M2 M1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>length (map fst p) = length (map (fst \\<circ> snd) p);\n   length (map (fst \\<circ> snd) p) =\n   length (map (snd \\<circ> snd) p)\\<rbrakk>\n  \\<Longrightarrow> path (product M2 M1)\n                     (map fst p ||\n                      map (fst \\<circ> snd) p || map (snd \\<circ> snd) p)\n                     (?p\\<^sub>1, ?p\\<^sub>2) =\n                    (path M2 (map fst p || map (fst \\<circ> snd) p)\n                      ?p\\<^sub>1 \\<and>\n                     path M1 (map fst p || map (snd \\<circ> snd) p)\n                      ?p\\<^sub>2)\n\ngoal (1 subgoal):\n 1. path M2 (map fst p || map (fst \\<circ> snd) p) (initial M2) &&&\n    path M1 (map fst p || map (snd \\<circ> snd) p) (initial M1)", "using \\<open>p = ?pIO || ?p2 || ?p1\\<close> repFreePath(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>length (map fst p) = length (map (fst \\<circ> snd) p);\n   length (map (fst \\<circ> snd) p) =\n   length (map (snd \\<circ> snd) p)\\<rbrakk>\n  \\<Longrightarrow> path (product M2 M1)\n                     (map fst p ||\n                      map (fst \\<circ> snd) p || map (snd \\<circ> snd) p)\n                     (?p\\<^sub>1, ?p\\<^sub>2) =\n                    (path M2 (map fst p || map (fst \\<circ> snd) p)\n                      ?p\\<^sub>1 \\<and>\n                     path M1 (map fst p || map (snd \\<circ> snd) p)\n                      ?p\\<^sub>2)\n  p = map fst p || map (fst \\<circ> snd) p || map (snd \\<circ> snd) p\n  path (product M2 M1) p (initial M2, initial M1) \\<and>\n  target p (initial M2, initial M1) =\n  (target (butlast seq || tr2b) (initial M2),\n   target (butlast seq || tr1b) (initial M1))\n\ngoal (1 subgoal):\n 1. path M2 (map fst p || map (fst \\<circ> snd) p) (initial M2) &&&\n    path M1 (map fst p || map (snd \\<circ> snd) p) (initial M1)", "by auto"], ["proof (state)\nthis:\n  path M2 (map fst p || map (fst \\<circ> snd) p) (initial M2)\n  path M1 (map fst p || map (snd \\<circ> snd) p) (initial M1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"(?q2b, ?q1b) = (target (?pIO || ?p2 || ?p1) (initial M2, initial M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (target (butlast seq || tr2b) (initial M2),\n     target (butlast seq || tr1b) (initial M1)) =\n    target (map fst p || map (fst \\<circ> snd) p || map (snd \\<circ> snd) p)\n     (initial M2, initial M1)", "using \\<open>p = ?pIO || ?p2 || ?p1\\<close> repFreePath(1)"], ["proof (prove)\nusing this:\n  p = map fst p || map (fst \\<circ> snd) p || map (snd \\<circ> snd) p\n  path (product M2 M1) p (initial M2, initial M1) \\<and>\n  target p (initial M2, initial M1) =\n  (target (butlast seq || tr2b) (initial M2),\n   target (butlast seq || tr1b) (initial M1))\n\ngoal (1 subgoal):\n 1. (target (butlast seq || tr2b) (initial M2),\n     target (butlast seq || tr1b) (initial M1)) =\n    target (map fst p || map (fst \\<circ> snd) p || map (snd \\<circ> snd) p)\n     (initial M2, initial M1)", "by auto"], ["proof (state)\nthis:\n  (target (butlast seq || tr2b) (initial M2),\n   target (butlast seq || tr1b) (initial M1)) =\n  target (map fst p || map (fst \\<circ> snd) p || map (snd \\<circ> snd) p)\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  (target (butlast seq || tr2b) (initial M2),\n   target (butlast seq || tr1b) (initial M1)) =\n  target (map fst p || map (fst \\<circ> snd) p || map (snd \\<circ> snd) p)\n   (initial M2, initial M1)", "have \"?q2b = target (?pIO || ?p2) (initial M2)\" \n            \"?q1b = target (?pIO || ?p1) (initial M1)\""], ["proof (prove)\nusing this:\n  (target (butlast seq || tr2b) (initial M2),\n   target (butlast seq || tr1b) (initial M1)) =\n  target (map fst p || map (fst \\<circ> snd) p || map (snd \\<circ> snd) p)\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. target (butlast seq || tr2b) (initial M2) =\n    target (map fst p || map (fst \\<circ> snd) p) (initial M2) &&&\n    target (butlast seq || tr1b) (initial M1) =\n    target (map fst p || map (snd \\<circ> snd) p) (initial M1)", "by auto"], ["proof (state)\nthis:\n  target (butlast seq || tr2b) (initial M2) =\n  target (map fst p || map (fst \\<circ> snd) p) (initial M2)\n  target (butlast seq || tr1b) (initial M1) =\n  target (map fst p || map (snd \\<circ> snd) p) (initial M1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"io_targets M2 (initial M2) ?pIO = {?q2b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) (map fst p) =\n    {target (butlast seq || tr2b) (initial M2)}", "by (metis \\<open>path M2 (map fst p || map (fst \\<circ> snd) p) (initial M2)\\<close> \n        \\<open>target (?bls || tr2b) (initial M2) = target (map fst p || map (fst \\<circ> snd) p) (initial M2)\\<close> \n        assms(4) length_map obs_target_is_io_targets)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (map fst p) =\n  {target (butlast seq || tr2b) (initial M2)}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"io_targets M1 (initial M1) ?pIO = {?q1b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) (map fst p) =\n    {target (butlast seq || tr1b) (initial M1)}", "by (metis \\<open>path M1 (map fst p || map (snd \\<circ> snd) p) (initial M1)\\<close> \n        \\<open>target (?bls || tr1b) (initial M1) = target (map fst p || map (snd \\<circ> snd) p) (initial M1)\\<close> \n        assms(3) length_map obs_target_is_io_targets)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) (map fst p) =\n  {target (butlast seq || tr1b) (initial M1)}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"seq \\<in> L M1\" \"seq \\<notin> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<in> L M1 &&& seq \\<notin> L M2", "using \\<open>sequence_to_failure M1 M2 seq\\<close>"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 seq\n\ngoal (1 subgoal):\n 1. seq \\<in> L M1 &&& seq \\<notin> L M2", "by auto"], ["proof (state)\nthis:\n  seq \\<in> L M1\n  seq \\<notin> L M2\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"io_targets M1 (initial M1) ?bls = {?q1b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) (butlast seq) =\n    {target (butlast seq || tr1b) (initial M1)}", "by (metis \\<open>length tr1b = length (butlast seq)\\<close> \\<open>path M1 (butlast seq || tr1b) (initial M1)\\<close> \n        assms(3) obs_target_is_io_targets)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) (butlast seq) =\n  {target (butlast seq || tr1b) (initial M1)}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "obtain q1s where \"io_targets M1 (initial M1) seq = {q1s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1s.\n        io_targets M1 (initial M1) seq = {q1s} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson \\<open>seq \\<in> L M1\\<close> assms(3) io_targets_observable_singleton_ob)"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) seq = {q1s}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "moreover"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) seq = {q1s}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"seq = (butlast seq)@[last seq]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq = butlast seq @ [last seq]", "using \\<open>seq \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  seq \\<noteq> []\n\ngoal (1 subgoal):\n 1. seq = butlast seq @ [last seq]", "by auto"], ["proof (state)\nthis:\n  seq = butlast seq @ [last seq]\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "ultimately"], ["proof (chain)\npicking this:\n  io_targets M1 (initial M1) seq = {q1s}\n  seq = butlast seq @ [last seq]", "have \"io_targets M1 (initial M1) ((butlast seq)@[last seq]) = {q1s}\""], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) seq = {q1s}\n  seq = butlast seq @ [last seq]\n\ngoal (1 subgoal):\n 1. io_targets M1 (initial M1) (butlast seq @ [last seq]) = {q1s}", "by auto"], ["proof (state)\nthis:\n  io_targets M1 (initial M1) (butlast seq @ [last seq]) = {q1s}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"io_targets M1 ?q1b [last seq] = {q1s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M1 (target (butlast seq || tr1b) (initial M1)) [last seq] =\n    {q1s}", "using observable_io_targets_suffix[OF assms(3) \\<open>io_targets M1 (initial M1) ?bls = {?q1b}\\<close> \n          \\<open>io_targets M1 (initial M1) ((butlast seq)@[last seq]) = {q1s}\\<close>]"], ["proof (prove)\nusing this:\n  io_targets M1 (target (butlast seq || tr1b) (initial M1)) [last seq] =\n  {q1s}\n\ngoal (1 subgoal):\n 1. io_targets M1 (target (butlast seq || tr1b) (initial M1)) [last seq] =\n    {q1s}", "by assumption"], ["proof (state)\nthis:\n  io_targets M1 (target (butlast seq || tr1b) (initial M1)) [last seq] =\n  {q1s}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  io_targets M1 (target (butlast seq || tr1b) (initial M1)) [last seq] =\n  {q1s}", "obtain tr1s where \"q1s = target ([last seq] || tr1s) ?q1b\" \n                         \"path M1 ([last seq] || tr1s) ?q1b\" \n                         \"length [last seq] = length tr1s\""], ["proof (prove)\nusing this:\n  io_targets M1 (target (butlast seq || tr1b) (initial M1)) [last seq] =\n  {q1s}\n\ngoal (1 subgoal):\n 1. (\\<And>tr1s.\n        \\<lbrakk>q1s =\n                 target ([last seq] || tr1s)\n                  (target (butlast seq || tr1b) (initial M1));\n         path M1 ([last seq] || tr1s)\n          (target (butlast seq || tr1b) (initial M1));\n         length [last seq] = length tr1s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q1s =\n  target ([last seq] || tr1s) (target (butlast seq || tr1b) (initial M1))\n  path M1 ([last seq] || tr1s) (target (butlast seq || tr1b) (initial M1))\n  length [last seq] = length tr1s\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"path M1 ([last seq] || [q1s]) ?q1b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M1 ([last seq] || [q1s])\n     (target (butlast seq || tr1b) (initial M1))", "by (metis (no_types) \\<open>length [last seq] = length tr1s\\<close> \n        \\<open>path M1 ([last seq] || tr1s) (target (butlast seq || tr1b) (initial M1))\\<close> \n        \\<open>q1s = target ([last seq] || tr1s) (target (butlast seq || tr1b) (initial M1))\\<close> \n        append_Nil append_butlast_last_id butlast.simps(2) length_butlast length_greater_0_conv \n        not_Cons_self2 target_alt_def(2))"], ["proof (state)\nthis:\n  path M1 ([last seq] || [q1s]) (target (butlast seq || tr1b) (initial M1))\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  path M1 ([last seq] || [q1s]) (target (butlast seq || tr1b) (initial M1))", "have \"q1s \\<in> succ M1 (last seq) ?q1b\""], ["proof (prove)\nusing this:\n  path M1 ([last seq] || [q1s]) (target (butlast seq || tr1b) (initial M1))\n\ngoal (1 subgoal):\n 1. q1s \\<in> succ M1 (last seq) (target (butlast seq || tr1b) (initial M1))", "by auto"], ["proof (state)\nthis:\n  q1s \\<in> succ M1 (last seq) (target (butlast seq || tr1b) (initial M1))\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"succ M2 (last seq) ?q2b = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq> {}\""], ["proof (state)\nthis:\n  succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq> {}", "obtain q2f where \"q2f \\<in> succ M2 (last seq) ?q2b\""], ["proof (prove)\nusing this:\n  succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q2f.\n        q2f\n        \\<in> succ M2 (last seq)\n               (target (butlast seq || tr2b) (initial M2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q2f \\<in> succ M2 (last seq) (target (butlast seq || tr2b) (initial M2))\n\ngoal (1 subgoal):\n 1. succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  q2f \\<in> succ M2 (last seq) (target (butlast seq || tr2b) (initial M2))", "have \"target ([last seq] || [q2f]) ?q2b = q2f\" \n              \"path M2 ([last seq] || [q2f]) ?q2b\" \n              \"length [q2f] = length [last seq]\""], ["proof (prove)\nusing this:\n  q2f \\<in> succ M2 (last seq) (target (butlast seq || tr2b) (initial M2))\n\ngoal (1 subgoal):\n 1. target ([last seq] || [q2f])\n     (target (butlast seq || tr2b) (initial M2)) =\n    q2f &&&\n    path M2 ([last seq] || [q2f])\n     (target (butlast seq || tr2b) (initial M2)) &&&\n    length [q2f] = length [last seq]", "by auto"], ["proof (state)\nthis:\n  target ([last seq] || [q2f]) (target (butlast seq || tr2b) (initial M2)) =\n  q2f\n  path M2 ([last seq] || [q2f]) (target (butlast seq || tr2b) (initial M2))\n  length [q2f] = length [last seq]\n\ngoal (1 subgoal):\n 1. succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  target ([last seq] || [q2f]) (target (butlast seq || tr2b) (initial M2)) =\n  q2f\n  path M2 ([last seq] || [q2f]) (target (butlast seq || tr2b) (initial M2))\n  length [q2f] = length [last seq]", "have \"q2f \\<in> io_targets M2 ?q2b [last seq]\""], ["proof (prove)\nusing this:\n  target ([last seq] || [q2f]) (target (butlast seq || tr2b) (initial M2)) =\n  q2f\n  path M2 ([last seq] || [q2f]) (target (butlast seq || tr2b) (initial M2))\n  length [q2f] = length [last seq]\n\ngoal (1 subgoal):\n 1. q2f\n    \\<in> io_targets M2 (target (butlast seq || tr2b) (initial M2))\n           [last seq]", "by (metis io_target_from_path)"], ["proof (state)\nthis:\n  q2f\n  \\<in> io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq]\n\ngoal (1 subgoal):\n 1. succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  q2f\n  \\<in> io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq]", "have \"io_targets M2 ?q2b [last seq] = {q2f}\""], ["proof (prove)\nusing this:\n  q2f\n  \\<in> io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq]\n\ngoal (1 subgoal):\n 1. io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq] =\n    {q2f}", "using assms(4)"], ["proof (prove)\nusing this:\n  q2f\n  \\<in> io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq]\n  observable M2\n\ngoal (1 subgoal):\n 1. io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq] =\n    {q2f}", "by (meson observable_io_target_is_singleton)"], ["proof (state)\nthis:\n  io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq] =\n  {q2f}\n\ngoal (1 subgoal):\n 1. succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "have \"io_targets M2 (initial M2) (butlast seq @ [last seq]) = {q2f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) (butlast seq @ [last seq]) = {q2f}", "using observable_io_targets_append[OF assms(4) \\<open>io_targets M2 (initial M2) ?bls = {?q2b}\\<close> \n            \\<open>io_targets M2 ?q2b [last seq] = {q2f}\\<close>]"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (butlast seq @ [last seq]) = {q2f}\n\ngoal (1 subgoal):\n 1. io_targets M2 (initial M2) (butlast seq @ [last seq]) = {q2f}", "by assumption"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (butlast seq @ [last seq]) = {q2f}\n\ngoal (1 subgoal):\n 1. succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (initial M2) (butlast seq @ [last seq]) = {q2f}", "have \"seq \\<in> L M2\""], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (butlast seq @ [last seq]) = {q2f}\n\ngoal (1 subgoal):\n 1. seq \\<in> L M2", "using \\<open>seq = butlast seq @ [last seq]\\<close>"], ["proof (prove)\nusing this:\n  io_targets M2 (initial M2) (butlast seq @ [last seq]) = {q2f}\n  seq = butlast seq @ [last seq]\n\ngoal (1 subgoal):\n 1. seq \\<in> L M2", "by auto"], ["proof (state)\nthis:\n  seq \\<in> L M2\n\ngoal (1 subgoal):\n 1. succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  seq \\<in> L M2", "show \"False\""], ["proof (prove)\nusing this:\n  seq \\<in> L M2\n\ngoal (1 subgoal):\n 1. False", "using \\<open>seq \\<notin> L M2\\<close>"], ["proof (prove)\nusing this:\n  seq \\<in> L M2\n  seq \\<notin> L M2\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"?pIO \\<in> L M1\" \"?pIO \\<in> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst p \\<in> L M1 &&& map fst p \\<in> L M2", "using \\<open>path M1 (?pIO || ?p1) (initial M1)\\<close> \\<open>path M2 (?pIO || ?p2) (initial M2)\\<close>"], ["proof (prove)\nusing this:\n  path M1 (map fst p || map (snd \\<circ> snd) p) (initial M1)\n  path M2 (map fst p || map (fst \\<circ> snd) p) (initial M2)\n\ngoal (1 subgoal):\n 1. map fst p \\<in> L M1 &&& map fst p \\<in> L M2", "by auto"], ["proof (state)\nthis:\n  map fst p \\<in> L M1\n  map fst p \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  map fst p \\<in> L M1\n  map fst p \\<in> L M2", "have \"butlast (?pIO@[last seq]) \\<in> L M1 \\<inter> L M2\""], ["proof (prove)\nusing this:\n  map fst p \\<in> L M1\n  map fst p \\<in> L M2\n\ngoal (1 subgoal):\n 1. butlast (map fst p @ [last seq]) \\<in> L M1 \\<inter> L M2", "by auto"], ["proof (state)\nthis:\n  butlast (map fst p @ [last seq]) \\<in> L M1 \\<inter> L M2\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"?pIO@[last seq] \\<in> L M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst p @ [last seq] \\<in> L M1", "using observable_io_targets_append[OF assms(3) \\<open>io_targets M1 (initial M1) ?pIO = {?q1b}\\<close> \n          \\<open>io_targets M1 ?q1b [last seq] = {q1s}\\<close>]"], ["proof (prove)\nusing this:\n  io_targets M1 (initial M1) (map fst p @ [last seq]) = {q1s}\n\ngoal (1 subgoal):\n 1. map fst p @ [last seq] \\<in> L M1", "by (metis all_not_in_conv insert_not_empty io_targets_elim language_state)"], ["proof (state)\nthis:\n  map fst p @ [last seq] \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "moreover"], ["proof (state)\nthis:\n  map fst p @ [last seq] \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"?pIO@[last seq] \\<notin> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst p @ [last seq] \\<notin> L M2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. map fst p @ [last seq] \\<in> L M2 \\<Longrightarrow> False", "assume \"?pIO@[last seq] \\<in> L M2\""], ["proof (state)\nthis:\n  map fst p @ [last seq] \\<in> L M2\n\ngoal (1 subgoal):\n 1. map fst p @ [last seq] \\<in> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  map fst p @ [last seq] \\<in> L M2", "obtain q2f where \"io_targets M2 (initial M2) (?pIO@[last seq]) = {q2f}\""], ["proof (prove)\nusing this:\n  map fst p @ [last seq] \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>q2f.\n        io_targets M2 (initial M2) (map fst p @ [last seq]) =\n        {q2f} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(4) io_targets_observable_singleton_ob)"], ["proof (state)\nthis:\n  io_targets M2 (initial M2) (map fst p @ [last seq]) = {q2f}\n\ngoal (1 subgoal):\n 1. map fst p @ [last seq] \\<in> L M2 \\<Longrightarrow> False", "have \"io_targets M2 ?q2b [last seq] = {q2f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq] =\n    {q2f}", "using observable_io_targets_split[OF assms(4) \n            \\<open>io_targets M2 (initial M2) (?pIO@[last seq]) = {q2f}\\<close> \n            \\<open>io_targets M2 (initial M2) (map fst p) = {?q2b}\\<close>]"], ["proof (prove)\nusing this:\n  io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq] =\n  {q2f}\n\ngoal (1 subgoal):\n 1. io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq] =\n    {q2f}", "by assumption"], ["proof (state)\nthis:\n  io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq] =\n  {q2f}\n\ngoal (1 subgoal):\n 1. map fst p @ [last seq] \\<in> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq] =\n  {q2f}", "have \"q2f \\<in> succ M2 (last seq) ?q2b\""], ["proof (prove)\nusing this:\n  io_targets M2 (target (butlast seq || tr2b) (initial M2)) [last seq] =\n  {q2f}\n\ngoal (1 subgoal):\n 1. q2f \\<in> succ M2 (last seq) (target (butlast seq || tr2b) (initial M2))", "by (simp add: io_targets_succ)"], ["proof (state)\nthis:\n  q2f \\<in> succ M2 (last seq) (target (butlast seq || tr2b) (initial M2))\n\ngoal (1 subgoal):\n 1. map fst p @ [last seq] \\<in> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  q2f \\<in> succ M2 (last seq) (target (butlast seq || tr2b) (initial M2))", "show \"False\""], ["proof (prove)\nusing this:\n  q2f \\<in> succ M2 (last seq) (target (butlast seq || tr2b) (initial M2))\n\ngoal (1 subgoal):\n 1. False", "using \\<open>succ M2 (last seq) ?q2b = {}\\<close>"], ["proof (prove)\nusing this:\n  q2f \\<in> succ M2 (last seq) (target (butlast seq || tr2b) (initial M2))\n  succ M2 (last seq) (target (butlast seq || tr2b) (initial M2)) = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map fst p @ [last seq] \\<notin> L M2\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "ultimately"], ["proof (chain)\npicking this:\n  map fst p @ [last seq] \\<in> L M1\n  map fst p @ [last seq] \\<notin> L M2", "have \"?pIO@[last seq] \\<in> L M1 - L M2\""], ["proof (prove)\nusing this:\n  map fst p @ [last seq] \\<in> L M1\n  map fst p @ [last seq] \\<notin> L M2\n\ngoal (1 subgoal):\n 1. map fst p @ [last seq] \\<in> L M1 - L M2", "by auto"], ["proof (state)\nthis:\n  map fst p @ [last seq] \\<in> L M1 - L M2\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"sequence_to_failure M1 M2 (?pIO@[last seq])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 (map fst p @ [last seq])", "using \\<open>butlast (?pIO@[last seq]) \\<in> L M1 \\<inter> L M2\\<close> \\<open>?pIO@[last seq] \\<in> L M1 - L M2\\<close>"], ["proof (prove)\nusing this:\n  butlast (map fst p @ [last seq]) \\<in> L M1 \\<inter> L M2\n  map fst p @ [last seq] \\<in> L M1 - L M2\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 (map fst p @ [last seq])", "by auto"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 (map fst p @ [last seq])\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"length (?pIO@[last seq]) = Suc (length ?pIO)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst p @ [last seq]) = Suc (length (map fst p))", "by auto"], ["proof (state)\nthis:\n  length (map fst p @ [last seq]) = Suc (length (map fst p))\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  length (map fst p @ [last seq]) = Suc (length (map fst p))", "have \"length (?pIO@[last seq]) \\<le> |?PM|\""], ["proof (prove)\nusing this:\n  length (map fst p @ [last seq]) = Suc (length (map fst p))\n\ngoal (1 subgoal):\n 1. length (map fst p @ [last seq]) \\<le> |product M2 M1|", "using \\<open>length p < |?PM|\\<close>"], ["proof (prove)\nusing this:\n  length (map fst p @ [last seq]) = Suc (length (map fst p))\n  length p < |product M2 M1|\n\ngoal (1 subgoal):\n 1. length (map fst p @ [last seq]) \\<le> |product M2 M1|", "by auto"], ["proof (state)\nthis:\n  length (map fst p @ [last seq]) \\<le> |product M2 M1|\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"card (nodes M2 \\<times> nodes M1) \\<le> |M2| * |M1|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (nodes M2 \\<times> nodes M1) \\<le> |M2| * |M1|", "by (simp add: card_cartesian_product)"], ["proof (state)\nthis:\n  card (nodes M2 \\<times> nodes M1) \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"finite (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M2 \\<times> nodes M1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (nodes M2)\n 2. \\<And>uu_. uu_ \\<in> nodes M2 \\<Longrightarrow> finite (nodes M1)", "show \"finite (nodes M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M2)", "using assms"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  observable M1\n  observable M2\n  \\<not> M1 \\<preceq> M2\n\ngoal (1 subgoal):\n 1. finite (nodes M2)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. \\<And>uu_. uu_ \\<in> nodes M2 \\<Longrightarrow> finite (nodes M1)", "show \"finite (nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M1)", "using assms"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  observable M1\n  observable M2\n  \\<not> M1 \\<preceq> M2\n\ngoal (1 subgoal):\n 1. finite (nodes M1)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (nodes M2 \\<times> nodes M1)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "have \"|?PM| \\<le> |M2| * |M1|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |product M2 M1| \\<le> |M2| * |M1|", "by (meson \\<open>card (nodes M2 \\<times> nodes M1) \\<le> |M2| * |M1|\\<close> \\<open>finite (nodes M2 \\<times> nodes M1)\\<close> \n        card_mono dual_order.trans product_nodes)"], ["proof (state)\nthis:\n  |product M2 M1| \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  |product M2 M1| \\<le> |M2| * |M1|", "have \"length (?pIO@[last seq]) \\<le> |M2| * |M1|\""], ["proof (prove)\nusing this:\n  |product M2 M1| \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. length (map fst p @ [last seq]) \\<le> |M2| * |M1|", "using \\<open>length (?pIO@[last seq]) \\<le> |?PM|\\<close>"], ["proof (prove)\nusing this:\n  |product M2 M1| \\<le> |M2| * |M1|\n  length (map fst p @ [last seq]) \\<le> |product M2 M1|\n\ngoal (1 subgoal):\n 1. length (map fst p @ [last seq]) \\<le> |M2| * |M1|", "by auto"], ["proof (state)\nthis:\n  length (map fst p @ [last seq]) \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  length (map fst p @ [last seq]) \\<le> |M2| * |M1|", "have \"sequence_to_failure M1 M2 (?pIO@[last seq]) \\<and> length (?pIO@[last seq]) \\<le> |M2| * |M1|\""], ["proof (prove)\nusing this:\n  length (map fst p @ [last seq]) \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 (map fst p @ [last seq]) \\<and>\n    length (map fst p @ [last seq]) \\<le> |M2| * |M1|", "using \\<open>sequence_to_failure M1 M2 (?pIO@[last seq])\\<close>"], ["proof (prove)\nusing this:\n  length (map fst p @ [last seq]) \\<le> |M2| * |M1|\n  sequence_to_failure M1 M2 (map fst p @ [last seq])\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 (map fst p @ [last seq]) \\<and>\n    length (map fst p @ [last seq]) \\<le> |M2| * |M1|", "by auto"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 (map fst p @ [last seq]) \\<and>\n  length (map fst p @ [last seq]) \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "then"], ["proof (chain)\npicking this:\n  sequence_to_failure M1 M2 (map fst p @ [last seq]) \\<and>\n  length (map fst p @ [last seq]) \\<le> |M2| * |M1|", "show ?thesis"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 (map fst p @ [last seq]) \\<and>\n  length (map fst p @ [last seq]) \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs.\n     sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Minimal sequence to failure extending \\<close>"], ["", "text \\<open>\nA minimal sequence to a failure extending some some set of IO-sequences is a sequence to a failure\nof minimal length such that a prefix of that sequence is contained in the set.\n\\<close>"], ["", "fun minimal_sequence_to_failure_extending :: \n  \"'in list set \\<Rightarrow> ('in,'out,'state) FSM \\<Rightarrow> ('in,'out,'state) FSM \\<Rightarrow> ('in \\<times> 'out) list \n    \\<Rightarrow> ('in \\<times> 'out) list \\<Rightarrow> bool\" where\n  \"minimal_sequence_to_failure_extending V M1 M2 v' io = (\n   v' \\<in> L\\<^sub>i\\<^sub>n M1 V \\<and> sequence_to_failure M1 M2 (v' @ io) \n              \\<and> \\<not> (\\<exists> io' . \\<exists> w' \\<in> L\\<^sub>i\\<^sub>n M1 V . sequence_to_failure M1 M2 (w' @ io') \n                                                            \\<and> length io' < length io))\""], ["", "lemma minimal_sequence_to_failure_extending_det_state_cover_ob :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"observable M2\"\n  and     \"is_det_state_cover M2 V\"\n  and     \"\\<not> M1 \\<preceq> M2\"\nobtains vs xs\nwhere \"minimal_sequence_to_failure_extending V M1 M2 vs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -\n  \\<comment> \\<open>set of all IO-sequences that extend some reaction of M1 to V to a failure\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?exts = \"{xs. \\<exists>vs' \\<in> L\\<^sub>i\\<^sub>n M1 V. sequence_to_failure M1 M2 (vs'@xs)}\"\n  \n  \\<comment> \\<open>arbitrary sequence to failure\\<close>\n  \\<comment> \\<open>must be contained in ?exts as V contains the empty sequence\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain stf where \"sequence_to_failure M1 M2 stf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stf.\n        sequence_to_failure M1 M2 stf \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms sequence_to_failure_ob"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  observable M2\n  is_det_state_cover M2 V\n  \\<not> M1 \\<preceq> M2\n  \\<lbrakk>\\<not> ?M1.0 \\<preceq> ?M2.0; well_formed ?M1.0;\n   well_formed ?M2.0;\n   \\<And>io.\n      sequence_to_failure ?M1.0 ?M2.0 io \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>stf.\n        sequence_to_failure M1 M2 stf \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 stf\n\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  sequence_to_failure M1 M2 stf", "have \"sequence_to_failure M1 M2 ([] @ stf)\""], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 stf\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 ([] @ stf)", "by simp"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 ([] @ stf)\n\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 ([] @ stf)\n\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"[] \\<in> L\\<^sub>i\\<^sub>n M1 V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> L\\<^sub>i\\<^sub>n M1 V", "by (meson assms(4) det_state_cover_initial language_state_for_inputs_empty)"], ["proof (state)\nthis:\n  [] \\<in> L\\<^sub>i\\<^sub>n M1 V\n\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  sequence_to_failure M1 M2 ([] @ stf)\n  [] \\<in> L\\<^sub>i\\<^sub>n M1 V", "have \"stf \\<in> ?exts\""], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 ([] @ stf)\n  [] \\<in> L\\<^sub>i\\<^sub>n M1 V\n\ngoal (1 subgoal):\n 1. stf\n    \\<in> {xs.\n           \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n              sequence_to_failure M1 M2 (vs' @ xs)}", "by blast\n\n  \\<comment> \\<open>the minimal length sequence of ?exts\\<close>\n  \\<comment> \\<open>is a minimal sequence to a failure extending V by construction\\<close>"], ["proof (state)\nthis:\n  stf\n  \\<in> {xs.\n         \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n            sequence_to_failure M1 M2 (vs' @ xs)}\n\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?xsMin = \"arg_min length (\\<lambda>xs. xs \\<in> ?exts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have xsMin_def : \"?xsMin \\<in> ?exts \n                    \\<and> (\\<forall>xs \\<in> ?exts. length  ?xsMin \\<le> length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ARG_MIN length xs.\n        xs \\<in> {xs.\n                  \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                     sequence_to_failure M1 M2 (vs' @ xs)})\n    \\<in> {xs.\n           \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n              sequence_to_failure M1 M2 (vs' @ xs)} \\<and>\n    (\\<forall>xs\\<in>{xs.\n                      \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                         sequence_to_failure M1 M2 (vs' @ xs)}.\n        length\n         (ARG_MIN length xs.\n             xs \\<in> {xs.\n                       \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                          sequence_to_failure M1 M2 (vs' @ xs)})\n        \\<le> length xs)", "by (metis (no_types, lifting) \\<open>stf \\<in> ?exts\\<close> arg_min_nat_lemma)"], ["proof (state)\nthis:\n  (ARG_MIN length xs.\n      xs \\<in> {xs.\n                \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                   sequence_to_failure M1 M2 (vs' @ xs)})\n  \\<in> {xs.\n         \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n            sequence_to_failure M1 M2 (vs' @ xs)} \\<and>\n  (\\<forall>xs\\<in>{xs.\n                    \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                       sequence_to_failure M1 M2 (vs' @ xs)}.\n      length\n       (ARG_MIN length xs.\n           xs \\<in> {xs.\n                     \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                        sequence_to_failure M1 M2 (vs' @ xs)})\n      \\<le> length xs)\n\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (ARG_MIN length xs.\n      xs \\<in> {xs.\n                \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                   sequence_to_failure M1 M2 (vs' @ xs)})\n  \\<in> {xs.\n         \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n            sequence_to_failure M1 M2 (vs' @ xs)} \\<and>\n  (\\<forall>xs\\<in>{xs.\n                    \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                       sequence_to_failure M1 M2 (vs' @ xs)}.\n      length\n       (ARG_MIN length xs.\n           xs \\<in> {xs.\n                     \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                        sequence_to_failure M1 M2 (vs' @ xs)})\n      \\<le> length xs)", "obtain vs where \"vs \\<in> L\\<^sub>i\\<^sub>n M1 V \n                        \\<and> sequence_to_failure M1 M2 (vs @ ?xsMin)\""], ["proof (prove)\nusing this:\n  (ARG_MIN length xs.\n      xs \\<in> {xs.\n                \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                   sequence_to_failure M1 M2 (vs' @ xs)})\n  \\<in> {xs.\n         \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n            sequence_to_failure M1 M2 (vs' @ xs)} \\<and>\n  (\\<forall>xs\\<in>{xs.\n                    \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                       sequence_to_failure M1 M2 (vs' @ xs)}.\n      length\n       (ARG_MIN length xs.\n           xs \\<in> {xs.\n                     \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                        sequence_to_failure M1 M2 (vs' @ xs)})\n      \\<le> length xs)\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        vs \\<in> L\\<^sub>i\\<^sub>n M1 V \\<and>\n        sequence_to_failure M1 M2\n         (vs @\n          (ARG_MIN length xs.\n              xs \\<in> {xs.\n                        \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                           sequence_to_failure M1 M2\n                            (vs' @ xs)})) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 V \\<and>\n  sequence_to_failure M1 M2\n   (vs @\n    (ARG_MIN length xs.\n        xs \\<in> {xs.\n                  \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                     sequence_to_failure M1 M2 (vs' @ xs)}))\n\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 V \\<and>\n  sequence_to_failure M1 M2\n   (vs @\n    (ARG_MIN length xs.\n        xs \\<in> {xs.\n                  \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                     sequence_to_failure M1 M2 (vs' @ xs)}))\n\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<not>(\\<exists>xs . \\<exists>ws \\<in> L\\<^sub>i\\<^sub>n M1 V. sequence_to_failure M1 M2 (ws@xs) \n                                         \\<and> length xs < length ?xsMin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>xs.\n       \\<exists>ws\\<in>L\\<^sub>i\\<^sub>n M1 V.\n          sequence_to_failure M1 M2 (ws @ xs) \\<and>\n          length xs\n          < length\n             (ARG_MIN length xs.\n                 xs \\<in> {xs.\n                           \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                              sequence_to_failure M1 M2 (vs' @ xs)})", "using leD xsMin_def"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  (ARG_MIN length xs.\n      xs \\<in> {xs.\n                \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                   sequence_to_failure M1 M2 (vs' @ xs)})\n  \\<in> {xs.\n         \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n            sequence_to_failure M1 M2 (vs' @ xs)} \\<and>\n  (\\<forall>xs\\<in>{xs.\n                    \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                       sequence_to_failure M1 M2 (vs' @ xs)}.\n      length\n       (ARG_MIN length xs.\n           xs \\<in> {xs.\n                     \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                        sequence_to_failure M1 M2 (vs' @ xs)})\n      \\<le> length xs)\n\ngoal (1 subgoal):\n 1. \\<nexists>xs.\n       \\<exists>ws\\<in>L\\<^sub>i\\<^sub>n M1 V.\n          sequence_to_failure M1 M2 (ws @ xs) \\<and>\n          length xs\n          < length\n             (ARG_MIN length xs.\n                 xs \\<in> {xs.\n                           \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                              sequence_to_failure M1 M2 (vs' @ xs)})", "by blast"], ["proof (state)\nthis:\n  \\<nexists>xs.\n     \\<exists>ws\\<in>L\\<^sub>i\\<^sub>n M1 V.\n        sequence_to_failure M1 M2 (ws @ xs) \\<and>\n        length xs\n        < length\n           (ARG_MIN length xs.\n               xs \\<in> {xs.\n                         \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                            sequence_to_failure M1 M2 (vs' @ xs)})\n\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 V \\<and>\n  sequence_to_failure M1 M2\n   (vs @\n    (ARG_MIN length xs.\n        xs \\<in> {xs.\n                  \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                     sequence_to_failure M1 M2 (vs' @ xs)}))\n  \\<nexists>xs.\n     \\<exists>ws\\<in>L\\<^sub>i\\<^sub>n M1 V.\n        sequence_to_failure M1 M2 (ws @ xs) \\<and>\n        length xs\n        < length\n           (ARG_MIN length xs.\n               xs \\<in> {xs.\n                         \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                            sequence_to_failure M1 M2 (vs' @ xs)})", "have \"minimal_sequence_to_failure_extending V M1 M2 vs ?xsMin\""], ["proof (prove)\nusing this:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 V \\<and>\n  sequence_to_failure M1 M2\n   (vs @\n    (ARG_MIN length xs.\n        xs \\<in> {xs.\n                  \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                     sequence_to_failure M1 M2 (vs' @ xs)}))\n  \\<nexists>xs.\n     \\<exists>ws\\<in>L\\<^sub>i\\<^sub>n M1 V.\n        sequence_to_failure M1 M2 (ws @ xs) \\<and>\n        length xs\n        < length\n           (ARG_MIN length xs.\n               xs \\<in> {xs.\n                         \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                            sequence_to_failure M1 M2 (vs' @ xs)})\n\ngoal (1 subgoal):\n 1. minimal_sequence_to_failure_extending V M1 M2 vs\n     (ARG_MIN length xs.\n         xs \\<in> {xs.\n                   \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                      sequence_to_failure M1 M2 (vs' @ xs)})", "by auto"], ["proof (state)\nthis:\n  minimal_sequence_to_failure_extending V M1 M2 vs\n   (ARG_MIN length xs.\n       xs \\<in> {xs.\n                 \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                    sequence_to_failure M1 M2 (vs' @ xs)})\n\ngoal (1 subgoal):\n 1. (\\<And>vs xs.\n        minimal_sequence_to_failure_extending V M1 M2 vs\n         xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  minimal_sequence_to_failure_extending V M1 M2 vs\n   (ARG_MIN length xs.\n       xs \\<in> {xs.\n                 \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                    sequence_to_failure M1 M2 (vs' @ xs)})", "show ?thesis"], ["proof (prove)\nusing this:\n  minimal_sequence_to_failure_extending V M1 M2 vs\n   (ARG_MIN length xs.\n       xs \\<in> {xs.\n                 \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                    sequence_to_failure M1 M2 (vs' @ xs)})\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  minimal_sequence_to_failure_extending V M1 M2 vs\n   (ARG_MIN length xs.\n       xs \\<in> {xs.\n                 \\<exists>vs'\\<in>L\\<^sub>i\\<^sub>n M1 V.\n                    sequence_to_failure M1 M2 (vs' @ xs)})\n  minimal_sequence_to_failure_extending V M1 M2 ?vs ?xs \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mstfe_prefix_input_in_V :\n  assumes \"minimal_sequence_to_failure_extending V M1 M2 vs xs\"\n  shows \"(map fst vs) \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "have \"vs \\<in> L\\<^sub>i\\<^sub>n M1 V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 V", "using assms"], ["proof (prove)\nusing this:\n  minimal_sequence_to_failure_extending V M1 M2 vs xs\n\ngoal (1 subgoal):\n 1. vs \\<in> L\\<^sub>i\\<^sub>n M1 V", "by auto"], ["proof (state)\nthis:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 V\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "then"], ["proof (chain)\npicking this:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 V", "show ?thesis"], ["proof (prove)\nusing this:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 V\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "using language_state_for_inputs_map_fst_contained"], ["proof (prove)\nusing this:\n  vs \\<in> L\\<^sub>i\\<^sub>n M1 V\n  ?vs \\<in> LS\\<^sub>i\\<^sub>n ?M ?q ?V \\<Longrightarrow>\n  map fst ?vs \\<in> ?V\n\ngoal (1 subgoal):\n 1. map fst vs \\<in> V", "by auto"], ["proof (state)\nthis:\n  map fst vs \\<in> V\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Complete test suite derived from the product machine \\<close>"], ["", "text \\<open>\nThe classical result of testing FSMs for language inclusion :\nAny failure can be observed by a sequence of length at\nmost n*m where n is the number of states of the reference \nmodel (here FSM @{verbatim M2}) and m is an upper bound on the number\nof states of the SUT (here FSM @{verbatim M1}).\n\\<close>"], ["", "lemma product_suite_soundness :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"observable M1\"\n  and     \"observable M2\"\n  and     \"inputs M2 = inputs M1\"\n  and     \"|M1| \\<le> m \"\nshows     \"\\<not> M1 \\<preceq> M2 \\<longrightarrow> \\<not> M1 \\<preceq>\\<lbrakk>{xs . set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}\\<rbrakk> M2\" \n  (is \"\\<not> M1 \\<preceq> M2 \\<longrightarrow> \\<not> M1 \\<preceq>\\<lbrakk>?TS\\<rbrakk> M2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "assume \"\\<not> M1 \\<preceq> M2\""], ["proof (state)\nthis:\n  \\<not> M1 \\<preceq> M2\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "obtain stf where \"sequence_to_failure M1 M2 stf \\<and> length stf \\<le> |M2| * |M1|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>stf.\n        sequence_to_failure M1 M2 stf \\<and>\n        length stf \\<le> |M2| * |M1| \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sequence_to_failure_length[OF assms(1-4) \\<open>\\<not> M1 \\<preceq> M2\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>xs.\n     sequence_to_failure M1 M2 xs \\<and> length xs \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. (\\<And>stf.\n        sequence_to_failure M1 M2 stf \\<and>\n        length stf \\<le> |M2| * |M1| \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 stf \\<and> length stf \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  sequence_to_failure M1 M2 stf \\<and> length stf \\<le> |M2| * |M1|", "have \"sequence_to_failure M1 M2 stf\" \"length stf \\<le> |M2| * |M1|\""], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 stf \\<and> length stf \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 stf &&& length stf \\<le> |M2| * |M1|", "by auto"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 stf\n  length stf \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  sequence_to_failure M1 M2 stf\n  length stf \\<le> |M2| * |M1|", "have \"stf \\<in> L M1\""], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 stf\n  length stf \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. stf \\<in> L M1", "by auto"], ["proof (state)\nthis:\n  stf \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "let ?xs = \"map fst stf\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "have \"set ?xs \\<subseteq> inputs M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst stf) \\<subseteq> inputs M1", "by (meson \\<open>stf \\<in> L M1\\<close> assms(1) language_state_inputs)"], ["proof (state)\nthis:\n  set (map fst stf) \\<subseteq> inputs M1\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  set (map fst stf) \\<subseteq> inputs M1", "have \"set ?xs \\<subseteq> inputs M2\""], ["proof (prove)\nusing this:\n  set (map fst stf) \\<subseteq> inputs M1\n\ngoal (1 subgoal):\n 1. set (map fst stf) \\<subseteq> inputs M2", "using assms(5)"], ["proof (prove)\nusing this:\n  set (map fst stf) \\<subseteq> inputs M1\n  inputs M2 = inputs M1\n\ngoal (1 subgoal):\n 1. set (map fst stf) \\<subseteq> inputs M2", "by auto"], ["proof (state)\nthis:\n  set (map fst stf) \\<subseteq> inputs M2\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "have \"length ?xs \\<le> |M2| * |M1|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst stf) \\<le> |M2| * |M1|", "using \\<open>length stf \\<le> |M2| * |M1|\\<close>"], ["proof (prove)\nusing this:\n  length stf \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. length (map fst stf) \\<le> |M2| * |M1|", "by auto"], ["proof (state)\nthis:\n  length (map fst stf) \\<le> |M2| * |M1|\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "have \"length ?xs \\<le> |M2| * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst stf) \\<le> |M2| * m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (map fst stf) \\<le> |M2| * m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst stf) \\<le> |M2| * m", "by (metis (no_types) \\<open>length (map fst stf) \\<le> |M2| * |M1|\\<close> \\<open>|M1| \\<le> m\\<close> \n          dual_order.trans mult.commute mult_le_mono1)"], ["proof (state)\nthis:\n  length (map fst stf) \\<le> |M2| * m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (map fst stf) \\<le> |M2| * m\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "have \"stf \\<in> L\\<^sub>i\\<^sub>n M1 {?xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stf \\<in> L\\<^sub>i\\<^sub>n M1 {map fst stf}", "by (meson \\<open>stf \\<in> L M1\\<close> insertI1 language_state_for_inputs_map_fst)"], ["proof (state)\nthis:\n  stf \\<in> L\\<^sub>i\\<^sub>n M1 {map fst stf}\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "have \"?xs \\<in> ?TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst stf\n    \\<in> {xs. set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}", "using \\<open>set ?xs \\<subseteq> inputs M2\\<close> \\<open>length ?xs \\<le> |M2| * m\\<close>"], ["proof (prove)\nusing this:\n  set (map fst stf) \\<subseteq> inputs M2\n  length (map fst stf) \\<le> |M2| * m\n\ngoal (1 subgoal):\n 1. map fst stf\n    \\<in> {xs. set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}", "by blast"], ["proof (state)\nthis:\n  map fst stf\n  \\<in> {xs. set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "have \"stf \\<in> L\\<^sub>i\\<^sub>n M1 ?TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stf\n    \\<in> L\\<^sub>i\\<^sub>n M1\n           {xs.\n            set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}", "by (metis (no_types, lifting) \\<open>map fst stf \\<in> {xs. set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}\\<close> \n        \\<open>stf \\<in> L M1\\<close> language_state_for_inputs_map_fst)"], ["proof (state)\nthis:\n  stf\n  \\<in> L\\<^sub>i\\<^sub>n M1\n         {xs. set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "have \"stf \\<notin> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stf \\<notin> L M2", "using \\<open>sequence_to_failure M1 M2 stf\\<close>"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 stf\n\ngoal (1 subgoal):\n 1. stf \\<notin> L M2", "by auto"], ["proof (state)\nthis:\n  stf \\<notin> L M2\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "then"], ["proof (chain)\npicking this:\n  stf \\<notin> L M2", "have \"stf \\<notin> L\\<^sub>i\\<^sub>n M2 ?TS\""], ["proof (prove)\nusing this:\n  stf \\<notin> L M2\n\ngoal (1 subgoal):\n 1. stf\n    \\<notin> L\\<^sub>i\\<^sub>n M2\n              {xs.\n               set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}", "by auto"], ["proof (state)\nthis:\n  stf\n  \\<notin> L\\<^sub>i\\<^sub>n M2\n            {xs.\n             set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "show \"\\<not> M1 \\<preceq>\\<lbrakk>?TS\\<rbrakk> M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "using \\<open>stf \\<in> L\\<^sub>i\\<^sub>n M1 ?TS\\<close> \\<open>stf \\<notin> L\\<^sub>i\\<^sub>n M2 ?TS\\<close>"], ["proof (prove)\nusing this:\n  stf\n  \\<in> L\\<^sub>i\\<^sub>n M1\n         {xs. set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}\n  stf\n  \\<notin> L\\<^sub>i\\<^sub>n M2\n            {xs.\n             set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                                 set xs \\<subseteq> inputs M2 \\<and>\n                                 length xs \\<le> |M2| * m}\\<rbrakk> M2", "by blast"], ["proof (state)\nthis:\n  \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                               set xs \\<subseteq> inputs M2 \\<and>\n                               length xs \\<le> |M2| * m}\\<rbrakk> M2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_suite_completeness :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"observable M1\"\n  and     \"observable M2\"\n  and     \"inputs M2 = inputs M1\"\n  and     \"|M1| \\<le> m \"\nshows     \"M1 \\<preceq> M2 \\<longleftrightarrow> M1 \\<preceq>\\<lbrakk>{xs . set xs \\<subseteq> inputs M2 \\<and> length xs \\<le> |M2| * m}\\<rbrakk> M2\" \n  (is \"M1 \\<preceq> M2 \\<longleftrightarrow> M1 \\<preceq>\\<lbrakk>?TS\\<rbrakk> M2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq> M2 =\n    M1 \\<preceq>\\<lbrakk>{xs.\n                          set xs \\<subseteq> inputs M2 \\<and>\n                          length xs \\<le> |M2| * m}\\<rbrakk> M2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. M1 \\<preceq> M2 \\<Longrightarrow>\n    M1 \\<preceq>\\<lbrakk>{xs.\n                          set xs \\<subseteq> inputs M2 \\<and>\n                          length xs \\<le> |M2| * m}\\<rbrakk> M2\n 2. M1 \\<preceq>\\<lbrakk>{xs.\n                          set xs \\<subseteq> inputs M2 \\<and>\n                          length xs\n                          \\<le> |M2| * m}\\<rbrakk> M2 \\<Longrightarrow>\n    M1 \\<preceq> M2", "show \"M1 \\<preceq> M2 \\<Longrightarrow> M1 \\<preceq>\\<lbrakk>?TS\\<rbrakk> M2\" \\<comment> \\<open>soundness holds trivially\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq> M2 \\<Longrightarrow>\n    M1 \\<preceq>\\<lbrakk>{xs.\n                          set xs \\<subseteq> inputs M2 \\<and>\n                          length xs \\<le> |M2| * m}\\<rbrakk> M2", "unfolding language_state_for_inputs.simps io_reduction.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. L M1 \\<subseteq> L M2 \\<Longrightarrow>\n    {xs || ys |xs ys.\n     xs \\<in> {xs.\n               set xs \\<subseteq> inputs M2 \\<and>\n               length xs \\<le> |M2| * m} \\<and>\n     length xs = length ys \\<and> xs || ys \\<in> L M1}\n    \\<subseteq> {xs || ys |xs ys.\n                 xs \\<in> {xs.\n                           set xs \\<subseteq> inputs M2 \\<and>\n                           length xs \\<le> |M2| * m} \\<and>\n                 length xs = length ys \\<and> xs || ys \\<in> L M2}", "by blast"], ["proof (state)\nthis:\n  M1 \\<preceq> M2 \\<Longrightarrow>\n  M1 \\<preceq>\\<lbrakk>{xs.\n                        set xs \\<subseteq> inputs M2 \\<and>\n                        length xs \\<le> |M2| * m}\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>{xs.\n                          set xs \\<subseteq> inputs M2 \\<and>\n                          length xs\n                          \\<le> |M2| * m}\\<rbrakk> M2 \\<Longrightarrow>\n    M1 \\<preceq> M2", "show \"M1 \\<preceq>\\<lbrakk>?TS\\<rbrakk> M2 \\<Longrightarrow> M1 \\<preceq> M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>{xs.\n                          set xs \\<subseteq> inputs M2 \\<and>\n                          length xs\n                          \\<le> |M2| * m}\\<rbrakk> M2 \\<Longrightarrow>\n    M1 \\<preceq> M2", "using product_suite_soundness[OF assms]"], ["proof (prove)\nusing this:\n  \\<not> M1 \\<preceq> M2 \\<longrightarrow>\n  \\<not> M1 \\<preceq>\\<lbrakk>{xs.\n                               set xs \\<subseteq> inputs M2 \\<and>\n                               length xs \\<le> |M2| * m}\\<rbrakk> M2\n\ngoal (1 subgoal):\n 1. M1 \\<preceq>\\<lbrakk>{xs.\n                          set xs \\<subseteq> inputs M2 \\<and>\n                          length xs\n                          \\<le> |M2| * m}\\<rbrakk> M2 \\<Longrightarrow>\n    M1 \\<preceq> M2", "by auto"], ["proof (state)\nthis:\n  M1 \\<preceq>\\<lbrakk>{xs.\n                        set xs \\<subseteq> inputs M2 \\<and>\n                        length xs\n                        \\<le> |M2| * m}\\<rbrakk> M2 \\<Longrightarrow>\n  M1 \\<preceq> M2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}