{"file_name": "/home/qj213/afp-2021-10-22/thys/Adaptive_State_Counting/FSM/FSM_Product.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Adaptive_State_Counting", "problem_names": ["lemma productF_simps[simp]:\n  \"productF A B FAIL AB \\<Longrightarrow> succ AB a (p1,p2) = (if (p1 \\<in> nodes A \\<and> p2 \\<in> nodes B \n                                        \\<and> (fst a \\<in> inputs A) \\<and> (snd a \\<in> outputs A \\<union> outputs B))\n                                    then (if (succ A a p1 = {} \\<and> succ B a p2 \\<noteq> {})\n                                      then {FAIL} \n                                      else (succ A a p1 \\<times> succ B a p2))\n                                    else {})\"\n  \"productF A B FAIL AB \\<Longrightarrow> inputs AB = inputs A\"\n  \"productF A B FAIL AB \\<Longrightarrow> outputs AB = outputs A \\<union> outputs B\"\n  \"productF A B FAIL AB \\<Longrightarrow> initial AB = (initial A, initial B)\"", "lemma fail_next_productF : \n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"succ PM a FAIL = {}\"", "lemma nodes_productF : \n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\"", "lemma well_formed_productF[simp] :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"well_formed PM\"", "lemma observable_productF[simp] : \n  assumes \"observable M1\"\n  and     \"observable M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"observable PM\"", "lemma no_transition_after_FAIL :\n  assumes \"productF A B FAIL AB\"\n  shows \"succ AB io FAIL = {}\"", "lemma no_prefix_targets_FAIL :\n  assumes \"productF M2 M1 FAIL PM\"\n  and     \"path PM p q\"\n  and     \"k < length p\"\nshows \"target (take k p) q \\<noteq> FAIL\"", "lemma productF_path_inclusion :\n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"path A (w || r1) p1 \\<and> path B (w || r2) p2\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\nshows \"path (AB) (w || r1 || r2) (p1, p2)\"", "lemma productF_path_forward :\n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"(path A (w || r1) p1 \\<and> path B (w || r2) p2) \n            \\<or> (target (w || r1 || r2) (p1, p2) = FAIL\n              \\<and> length w > 0\n              \\<and> path A (butlast (w || r1)) p1\n              \\<and> path B (butlast (w || r2)) p2\n              \\<and> succ A (last w) (target (butlast (w || r1)) p1) = {}\n              \\<and> succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {})\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\nshows \"path (AB) (w || r1 || r2) (p1, p2)\"", "lemma butlast_zip_cons : \"length ws = length r1s \\<Longrightarrow> ws \\<noteq> [] \n                            \\<Longrightarrow> butlast (w # ws || r1 # r1s) = ((w,r1) # (butlast (ws || r1s)))\"", "lemma productF_succ_fail_imp : \n  assumes \"productF A B FAIL AB\"\n  and     \"FAIL \\<in> succ AB w (p1,p2)\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\nshows \"p1 \\<in> nodes A \\<and> p2 \\<in> nodes B \\<and> (fst w \\<in> inputs A) \\<and> (snd w \\<in> outputs A \\<union> outputs B) \n        \\<and> succ AB w (p1,p2) = {FAIL} \\<and> succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\"", "lemma productF_path_reverse :\n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"path AB (w || r1 || r2) (p1, p2)\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\nshows \"(path A (w || r1) p1 \\<and> path B (w || r2) p2) \n            \\<or> (target (w || r1 || r2) (p1, p2) = FAIL\n              \\<and> length w > 0\n              \\<and> path A (butlast (w || r1)) p1\n              \\<and> path B (butlast (w || r2)) p2\n              \\<and> succ A (last w) (target (butlast (w || r1)) p1) = {}\n              \\<and> succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {})\"", "lemma butlast_zip[simp] :\n  assumes \"length xs = length ys\"\n  shows \"butlast (xs || ys) = (butlast xs || butlast ys)\"", "lemma productF_path_reverse_ob : \n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"path AB (w || r1 || r2) (p1, p2)\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\nobtains r2' \nwhere \"path B (w || r2') p2 \\<and> length w = length r2'\"", "lemma productF_path[iff] :\n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\nshows \"path AB (w || r1 || r2) (p1, p2) \\<longleftrightarrow> ((path A (w || r1) p1 \\<and> path B (w || r2) p2) \n            \\<or> (target (w || r1 || r2) (p1, p2) = FAIL\n              \\<and> length w > 0\n              \\<and> path A (butlast (w || r1)) p1\n              \\<and> path B (butlast (w || r2)) p2\n              \\<and> succ A (last w) (target (butlast (w || r1)) p1) = {}\n              \\<and> succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}))\" (is \"?path \\<longleftrightarrow> ?paths\")", "lemma path_last_succ :\n  assumes \"path A (ws || r1s) p1\"\n  and     \"length r1s = length ws\"\n  and     \"length ws > 0\"\nshows     \"last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)\"", "lemma zip_last :\n  assumes \"length r1 > 0\"\n  and     \"length r1 = length r2\"\nshows \"last (r1 || r2) = (last r1, last r2)\"", "lemma productF_path_reverse_ob_2 : \n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"path AB (w || r1 || r2) (p1, p2)\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\n  and     \"w \\<in> language_state A p1\"\n  and     \"observable A\"\nshows \"path A (w || r1) p1 \\<and> length w = length r1\" \"path B (w || r2) p2 \\<and> length w = length r2\"\n      \"target (w || r1) p1 = fst (target (w || r1 || r2) (p1,p2))\"\n      \"target (w || r2) p2 = snd (target (w || r1 || r2) (p1,p2))\"", "lemma productF_path_unzip :\n  assumes \"productF A B FAIL AB\"\n  and     \"path AB (w || tr) q\"\n  and     \"length tr = length w\"\nshows \"path AB (w || (map fst tr || map snd tr)) q\"", "lemma productF_path_io_targets :\n  assumes \"productF A B FAIL AB\"\n  and     \"io_targets AB (qA,qB) w = {(pA,pB)}\"\n  and     \"w \\<in> language_state A qA\"\n  and     \"w \\<in> language_state B qB\"\n  and     \"observable A\"\n  and     \"observable B\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"qA \\<in> nodes A\"\n  and     \"qB \\<in> nodes B\" \nshows \"pA \\<in> io_targets A qA w\" \"pB \\<in> io_targets B qB w\"", "lemma productF_path_io_targets_reverse :\n  assumes \"productF A B FAIL AB\"\n  and     \"pA \\<in> io_targets A qA w\" \n  and     \"pB \\<in> io_targets B qB w\"\n  and     \"w \\<in> language_state A qA\"\n  and     \"w \\<in> language_state B qB\"\n  and     \"observable A\"\n  and     \"observable B\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"qA \\<in> nodes A\"\n  and     \"qB \\<in> nodes B\" \nshows \"io_targets AB (qA,qB) w = {(pA,pB)}\"", "lemma fail_reachable_by_sequence_to_failure :\n  assumes \"sequence_to_failure M1 M2 io\"\n  and     \"well_formed M1\"\n  and     \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\nobtains p\nwhere \"path PM (io||p) (initial PM) \\<and> length p = length io \\<and> target (io||p) (initial PM) = FAIL\"", "lemma fail_reachable :\n  assumes \"\\<not> M1 \\<preceq> M2\"\n  and     \"well_formed M1\"\n  and     \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\nshows \"FAIL \\<in> reachable PM (initial PM)\"", "lemma fail_reachable_ob :\n  assumes \"\\<not> M1 \\<preceq> M2\"\n  and     \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"observable M2\"\n  and \"productF M2 M1 FAIL PM\"\nobtains p\nwhere \"path PM p (initial PM)\" \"target p (initial PM) = FAIL\"", "lemma fail_reachable_reverse : \n  assumes \"well_formed M1\"\n  and     \"well_formed M2\" \n  and     \"productF M2 M1 FAIL PM\"\n  and     \"FAIL \\<in> reachable PM (initial PM)\"\n  and     \"observable M2\"\nshows \"\\<not> M1 \\<preceq> M2\"", "lemma fail_reachable_iff[iff] : \n  assumes \"well_formed M1\"\n  and     \"well_formed M2\" \n  and     \"productF M2 M1 FAIL PM\"\n  and     \"observable M2\"\nshows \"FAIL \\<in> reachable PM (initial PM) \\<longleftrightarrow> \\<not> M1 \\<preceq> M2\"", "lemma reaching_path_length :\n  assumes \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"q2 \\<in> reachable AB q1\"\n  and     \"q2 \\<noteq> FAIL\"\n  and     \"q1 \\<in> nodes AB\"\nshows \"\\<exists> p . path AB p q1 \\<and> target p q1 = q2 \\<and> length p < card (nodes A) * card (nodes B)\"", "lemma reaching_path_fail_length :\n  assumes \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"q2 \\<in> reachable AB q1\"\n  and     \"q1 \\<in> nodes AB\"\nshows \"\\<exists> p . path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> card (nodes A) * card (nodes B)\"", "lemma productF_language :\n  assumes \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"io \\<in> L A \\<inter> L B\"\nshows \"io \\<in> L AB\"", "lemma productF_language_state_intermediate :\n  assumes \"vs @ xs \\<in> L M2 \\<inter> L M1\"\n  and     \"productF M2 M1 FAIL PM\"\n  and     \"observable M2\"\n  and     \"well_formed M2\"\n  and     \"observable M1\"\n  and     \"well_formed M1\"\nobtains q2 q1 tr \nwhere \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n      \"path PM (xs || tr) (q2,q1)\" \n      \"length xs = length tr\"", "lemma sequence_to_failure_reaches_FAIL :\n  assumes \"sequence_to_failure M1 M2 io\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"FAIL \\<in> io_targets PM (initial PM) io\"", "lemma sequence_to_failure_reaches_FAIL_ob :\n  assumes \"sequence_to_failure M1 M2 io\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"io_targets PM (initial PM) io = {FAIL}\"", "lemma sequence_to_failure_alt_def :\n  assumes \"io_targets PM (initial PM) io = {FAIL}\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"sequence_to_failure M1 M2 io\""], "translations": [["", "lemma productF_simps[simp]:\n  \"productF A B FAIL AB \\<Longrightarrow> succ AB a (p1,p2) = (if (p1 \\<in> nodes A \\<and> p2 \\<in> nodes B \n                                        \\<and> (fst a \\<in> inputs A) \\<and> (snd a \\<in> outputs A \\<union> outputs B))\n                                    then (if (succ A a p1 = {} \\<and> succ B a p2 \\<noteq> {})\n                                      then {FAIL} \n                                      else (succ A a p1 \\<times> succ B a p2))\n                                    else {})\"\n  \"productF A B FAIL AB \\<Longrightarrow> inputs AB = inputs A\"\n  \"productF A B FAIL AB \\<Longrightarrow> outputs AB = outputs A \\<union> outputs B\"\n  \"productF A B FAIL AB \\<Longrightarrow> initial AB = (initial A, initial B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((productF A B FAIL AB \\<Longrightarrow>\n      succ AB a (p1, p2) =\n      (if p1 \\<in> nodes A \\<and>\n          p2 \\<in> nodes B \\<and>\n          fst a \\<in> inputs A \\<and>\n          snd a \\<in> outputs A \\<union> outputs B\n       then if succ A a p1 = {} \\<and> succ B a p2 \\<noteq> {} then {FAIL}\n            else succ A a p1 \\<times> succ B a p2\n       else {})) &&&\n     (productF A B FAIL AB \\<Longrightarrow> inputs AB = inputs A)) &&&\n    (productF A B FAIL AB \\<Longrightarrow>\n     outputs AB = outputs A \\<union> outputs B) &&&\n    (productF A B FAIL AB \\<Longrightarrow>\n     initial AB = (initial A, initial B))", "unfolding productF.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((inputs A = inputs B \\<and>\n      fst FAIL \\<notin> nodes A \\<and>\n      snd FAIL \\<notin> nodes B \\<and>\n      AB =\n      \\<lparr>succ =\n                \\<lambda>a (p1, p2).\n                   if p1 \\<in> nodes A \\<and>\n                      p2 \\<in> nodes B \\<and>\n                      fst a \\<in> inputs A \\<and>\n                      snd a \\<in> outputs A \\<union> outputs B\n                   then if succ A a p1 = {} \\<and> succ B a p2 \\<noteq> {}\n                        then {FAIL} else succ A a p1 \\<times> succ B a p2\n                   else {},\n         inputs = inputs A, outputs = outputs A \\<union> outputs B,\n         initial = (initial A, initial B)\\<rparr> \\<Longrightarrow>\n      succ AB a (p1, p2) =\n      (if p1 \\<in> nodes A \\<and>\n          p2 \\<in> nodes B \\<and>\n          fst a \\<in> inputs A \\<and>\n          snd a \\<in> outputs A \\<union> outputs B\n       then if succ A a p1 = {} \\<and> succ B a p2 \\<noteq> {} then {FAIL}\n            else succ A a p1 \\<times> succ B a p2\n       else {})) &&&\n     (inputs A = inputs B \\<and>\n      fst FAIL \\<notin> nodes A \\<and>\n      snd FAIL \\<notin> nodes B \\<and>\n      AB =\n      \\<lparr>succ =\n                \\<lambda>a (p1, p2).\n                   if p1 \\<in> nodes A \\<and>\n                      p2 \\<in> nodes B \\<and>\n                      fst a \\<in> inputs A \\<and>\n                      snd a \\<in> outputs A \\<union> outputs B\n                   then if succ A a p1 = {} \\<and> succ B a p2 \\<noteq> {}\n                        then {FAIL} else succ A a p1 \\<times> succ B a p2\n                   else {},\n         inputs = inputs A, outputs = outputs A \\<union> outputs B,\n         initial = (initial A, initial B)\\<rparr> \\<Longrightarrow>\n      inputs AB = inputs A)) &&&\n    (inputs A = inputs B \\<and>\n     fst FAIL \\<notin> nodes A \\<and>\n     snd FAIL \\<notin> nodes B \\<and>\n     AB =\n     \\<lparr>succ =\n               \\<lambda>a (p1, p2).\n                  if p1 \\<in> nodes A \\<and>\n                     p2 \\<in> nodes B \\<and>\n                     fst a \\<in> inputs A \\<and>\n                     snd a \\<in> outputs A \\<union> outputs B\n                  then if succ A a p1 = {} \\<and> succ B a p2 \\<noteq> {}\n                       then {FAIL} else succ A a p1 \\<times> succ B a p2\n                  else {},\n        inputs = inputs A, outputs = outputs A \\<union> outputs B,\n        initial = (initial A, initial B)\\<rparr> \\<Longrightarrow>\n     outputs AB = outputs A \\<union> outputs B) &&&\n    (inputs A = inputs B \\<and>\n     fst FAIL \\<notin> nodes A \\<and>\n     snd FAIL \\<notin> nodes B \\<and>\n     AB =\n     \\<lparr>succ =\n               \\<lambda>a (p1, p2).\n                  if p1 \\<in> nodes A \\<and>\n                     p2 \\<in> nodes B \\<and>\n                     fst a \\<in> inputs A \\<and>\n                     snd a \\<in> outputs A \\<union> outputs B\n                  then if succ A a p1 = {} \\<and> succ B a p2 \\<noteq> {}\n                       then {FAIL} else succ A a p1 \\<times> succ B a p2\n                  else {},\n        inputs = inputs A, outputs = outputs A \\<union> outputs B,\n        initial = (initial A, initial B)\\<rparr> \\<Longrightarrow>\n     initial AB = (initial A, initial B))", "by simp+"], ["", "lemma fail_next_productF : \n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"succ PM a FAIL = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ PM a FAIL = {}", "proof (cases \"((fst FAIL) \\<in> nodes M2 \\<and> (snd FAIL) \\<in> nodes M1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst FAIL \\<in> nodes M2 \\<and> snd FAIL \\<in> nodes M1 \\<Longrightarrow>\n    succ PM a FAIL = {}\n 2. \\<not> (fst FAIL \\<in> nodes M2 \\<and>\n            snd FAIL \\<in> nodes M1) \\<Longrightarrow>\n    succ PM a FAIL = {}", "case True"], ["proof (state)\nthis:\n  fst FAIL \\<in> nodes M2 \\<and> snd FAIL \\<in> nodes M1\n\ngoal (2 subgoals):\n 1. fst FAIL \\<in> nodes M2 \\<and> snd FAIL \\<in> nodes M1 \\<Longrightarrow>\n    succ PM a FAIL = {}\n 2. \\<not> (fst FAIL \\<in> nodes M2 \\<and>\n            snd FAIL \\<in> nodes M1) \\<Longrightarrow>\n    succ PM a FAIL = {}", "then"], ["proof (chain)\npicking this:\n  fst FAIL \\<in> nodes M2 \\<and> snd FAIL \\<in> nodes M1", "show ?thesis"], ["proof (prove)\nusing this:\n  fst FAIL \\<in> nodes M2 \\<and> snd FAIL \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. succ PM a FAIL = {}", "using assms"], ["proof (prove)\nusing this:\n  fst FAIL \\<in> nodes M2 \\<and> snd FAIL \\<in> nodes M1\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. succ PM a FAIL = {}", "by auto"], ["proof (state)\nthis:\n  succ PM a FAIL = {}\n\ngoal (1 subgoal):\n 1. \\<not> (fst FAIL \\<in> nodes M2 \\<and>\n            snd FAIL \\<in> nodes M1) \\<Longrightarrow>\n    succ PM a FAIL = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (fst FAIL \\<in> nodes M2 \\<and>\n            snd FAIL \\<in> nodes M1) \\<Longrightarrow>\n    succ PM a FAIL = {}", "case False"], ["proof (state)\nthis:\n  \\<not> (fst FAIL \\<in> nodes M2 \\<and> snd FAIL \\<in> nodes M1)\n\ngoal (1 subgoal):\n 1. \\<not> (fst FAIL \\<in> nodes M2 \\<and>\n            snd FAIL \\<in> nodes M1) \\<Longrightarrow>\n    succ PM a FAIL = {}", "then"], ["proof (chain)\npicking this:\n  \\<not> (fst FAIL \\<in> nodes M2 \\<and> snd FAIL \\<in> nodes M1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (fst FAIL \\<in> nodes M2 \\<and> snd FAIL \\<in> nodes M1)\n\ngoal (1 subgoal):\n 1. succ PM a FAIL = {}", "using assms"], ["proof (prove)\nusing this:\n  \\<not> (fst FAIL \\<in> nodes M2 \\<and> snd FAIL \\<in> nodes M1)\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. succ PM a FAIL = {}", "by (cases \"(succ M2 a (fst FAIL) = {} \\<and> (fst a \\<in> inputs M2) \n                                                      \\<and> (snd a \\<in> outputs M2))\"; auto)"], ["proof (state)\nthis:\n  succ PM a FAIL = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nodes_productF : \n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> nodes PM \\<Longrightarrow>\n       x \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> nodes PM \\<Longrightarrow>\n       x \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "assume q_assm : \"q \\<in> nodes PM\""], ["proof (state)\nthis:\n  q \\<in> nodes PM\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> nodes PM \\<Longrightarrow>\n       x \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q \\<in> nodes PM", "show \"q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\nusing this:\n  q \\<in> nodes PM\n\ngoal (1 subgoal):\n 1. q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> nodes PM\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n     q = initial PM\\<rbrakk>\n    \\<Longrightarrow> q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n 2. \\<And>p a.\n       \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n        q = snd a; p \\<in> nodes PM; snd a \\<in> succ PM (fst a) p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "case initial"], ["proof (state)\nthis:\n  q = initial PM\n\ngoal (2 subgoals):\n 1. \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n     q = initial PM\\<rbrakk>\n    \\<Longrightarrow> q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n 2. \\<And>p a.\n       \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n        q = snd a; p \\<in> nodes PM; snd a \\<in> succ PM (fst a) p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q = initial PM", "show ?thesis"], ["proof (prove)\nusing this:\n  q = initial PM\n\ngoal (1 subgoal):\n 1. q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "using assms"], ["proof (prove)\nusing this:\n  q = initial PM\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "by auto"], ["proof (state)\nthis:\n  q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n        q = snd a; p \\<in> nodes PM; snd a \\<in> succ PM (fst a) p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n        q = snd a; p \\<in> nodes PM; snd a \\<in> succ PM (fst a) p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "case (execute p a)"], ["proof (state)\nthis:\n  q = snd a\n  p \\<in> nodes PM\n  snd a \\<in> succ PM (fst a) p\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n        q = snd a; p \\<in> nodes PM; snd a \\<in> succ PM (fst a) p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q = snd a\n  p \\<in> nodes PM\n  snd a \\<in> succ PM (fst a) p", "obtain p1 p2 x y q1 q2  where p_a_split[simp] : \"p = (p1,p2)\" \n                                                         \"a = ((x,y),q)\" \n                                                         \"q = (q1,q2)\""], ["proof (prove)\nusing this:\n  q = snd a\n  p \\<in> nodes PM\n  snd a \\<in> succ PM (fst a) p\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2 x y q1 q2.\n        \\<lbrakk>p = (p1, p2); a = ((x, y), q); q = (q1, q2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis eq_snd_iff)"], ["proof (state)\nthis:\n  p = (p1, p2)\n  a = ((x, y), q)\n  q = (q1, q2)\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n        q = snd a; p \\<in> nodes PM; snd a \\<in> succ PM (fst a) p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "have subnodes : \"p1 \\<in> nodes M2 \\<and> p2 \\<in> nodes M1 \\<and> x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<in> nodes M2 \\<and>\n    p2 \\<in> nodes M1 \\<and>\n    x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p1 \\<in> nodes M2 \\<and>\n            p2 \\<in> nodes M1 \\<and>\n            x \\<in> inputs M2 \\<and>\n            y \\<in> outputs M2 \\<union> outputs M1) \\<Longrightarrow>\n    False", "assume \"\\<not> (p1 \\<in> nodes M2 \\<and> p2 \\<in> nodes M1  \\<and> x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1)\""], ["proof (state)\nthis:\n  \\<not> (p1 \\<in> nodes M2 \\<and>\n          p2 \\<in> nodes M1 \\<and>\n          x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1)\n\ngoal (1 subgoal):\n 1. \\<not> (p1 \\<in> nodes M2 \\<and>\n            p2 \\<in> nodes M1 \\<and>\n            x \\<in> inputs M2 \\<and>\n            y \\<in> outputs M2 \\<union> outputs M1) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (p1 \\<in> nodes M2 \\<and>\n          p2 \\<in> nodes M1 \\<and>\n          x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1)", "have \"succ PM (x,y) (p1,p2) = {}\""], ["proof (prove)\nusing this:\n  \\<not> (p1 \\<in> nodes M2 \\<and>\n          p2 \\<in> nodes M1 \\<and>\n          x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1)\n\ngoal (1 subgoal):\n 1. succ PM (x, y) (p1, p2) = {}", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<not> (p1 \\<in> nodes M2 \\<and>\n          p2 \\<in> nodes M1 \\<and>\n          x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1)\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. succ PM (x, y) (p1, p2) = {}", "by auto"], ["proof (state)\nthis:\n  succ PM (x, y) (p1, p2) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (p1 \\<in> nodes M2 \\<and>\n            p2 \\<in> nodes M1 \\<and>\n            x \\<in> inputs M2 \\<and>\n            y \\<in> outputs M2 \\<union> outputs M1) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  succ PM (x, y) (p1, p2) = {}", "show \"False\""], ["proof (prove)\nusing this:\n  succ PM (x, y) (p1, p2) = {}\n\ngoal (1 subgoal):\n 1. False", "using execute"], ["proof (prove)\nusing this:\n  succ PM (x, y) (p1, p2) = {}\n  q = snd a\n  p \\<in> nodes PM\n  snd a \\<in> succ PM (fst a) p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 \\<in> nodes M2 \\<and>\n  p2 \\<in> nodes M1 \\<and>\n  x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n        q = snd a; p \\<in> nodes PM; snd a \\<in> succ PM (fst a) p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "proof (cases \"(succ M2 (x,y) p1 = {} \\<and> succ M1 (x,y) p2 \\<noteq> {})\")"], ["proof (state)\ngoal (2 subgoals):\n 1. succ M2 (x, y) p1 = {} \\<and>\n    succ M1 (x, y) p2 \\<noteq> {} \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n 2. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "case True"], ["proof (state)\nthis:\n  succ M2 (x, y) p1 = {} \\<and> succ M1 (x, y) p2 \\<noteq> {}\n\ngoal (2 subgoals):\n 1. succ M2 (x, y) p1 = {} \\<and>\n    succ M1 (x, y) p2 \\<noteq> {} \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n 2. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  succ M2 (x, y) p1 = {} \\<and> succ M1 (x, y) p2 \\<noteq> {}", "have \"q = FAIL\""], ["proof (prove)\nusing this:\n  succ M2 (x, y) p1 = {} \\<and> succ M1 (x, y) p2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. q = FAIL", "using subnodes assms(3) execute"], ["proof (prove)\nusing this:\n  succ M2 (x, y) p1 = {} \\<and> succ M1 (x, y) p2 \\<noteq> {}\n  p1 \\<in> nodes M2 \\<and>\n  p2 \\<in> nodes M1 \\<and>\n  x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1\n  productF M2 M1 FAIL PM\n  q = snd a\n  p \\<in> nodes PM\n  snd a \\<in> succ PM (fst a) p\n\ngoal (1 subgoal):\n 1. q = FAIL", "by auto"], ["proof (state)\nthis:\n  q = FAIL\n\ngoal (2 subgoals):\n 1. succ M2 (x, y) p1 = {} \\<and>\n    succ M1 (x, y) p2 \\<noteq> {} \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n 2. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q = FAIL", "show ?thesis"], ["proof (prove)\nusing this:\n  q = FAIL\n\ngoal (1 subgoal):\n 1. q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "by auto"], ["proof (state)\nthis:\n  q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "case False"], ["proof (state)\nthis:\n  \\<not> (succ M2 (x, y) p1 = {} \\<and> succ M1 (x, y) p2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  \\<not> (succ M2 (x, y) p1 = {} \\<and> succ M1 (x, y) p2 \\<noteq> {})", "have \"succ PM (fst a) p = succ M2 (x,y) p1 \\<times> succ M1 (x,y) p2\""], ["proof (prove)\nusing this:\n  \\<not> (succ M2 (x, y) p1 = {} \\<and> succ M1 (x, y) p2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. succ PM (fst a) p = succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2", "using subnodes assms(3) execute"], ["proof (prove)\nusing this:\n  \\<not> (succ M2 (x, y) p1 = {} \\<and> succ M1 (x, y) p2 \\<noteq> {})\n  p1 \\<in> nodes M2 \\<and>\n  p2 \\<in> nodes M1 \\<and>\n  x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1\n  productF M2 M1 FAIL PM\n  q = snd a\n  p \\<in> nodes PM\n  snd a \\<in> succ PM (fst a) p\n\ngoal (1 subgoal):\n 1. succ PM (fst a) p = succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2", "by auto"], ["proof (state)\nthis:\n  succ PM (fst a) p = succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  succ PM (fst a) p = succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2", "have \"q \\<in> (succ M2 (x,y) p1 \\<times> succ M1 (x,y) p2)\""], ["proof (prove)\nusing this:\n  succ PM (fst a) p = succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2\n\ngoal (1 subgoal):\n 1. q \\<in> succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2", "using execute"], ["proof (prove)\nusing this:\n  succ PM (fst a) p = succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2\n  q = snd a\n  p \\<in> nodes PM\n  snd a \\<in> succ PM (fst a) p\n\ngoal (1 subgoal):\n 1. q \\<in> succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2", "by blast"], ["proof (state)\nthis:\n  q \\<in> succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q \\<in> succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2", "have q_succ : \"(q1,q2) \\<in> (succ M2 (x,y) p1 \\<times> succ M1 (x,y) p2)\""], ["proof (prove)\nusing this:\n  q \\<in> succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2\n\ngoal (1 subgoal):\n 1. (q1, q2) \\<in> succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2", "by simp"], ["proof (state)\nthis:\n  (q1, q2) \\<in> succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "have \"q1 \\<in> succ M2 (x,y) p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 \\<in> succ M2 (x, y) p1", "using q_succ"], ["proof (prove)\nusing this:\n  (q1, q2) \\<in> succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2\n\ngoal (1 subgoal):\n 1. q1 \\<in> succ M2 (x, y) p1", "by simp"], ["proof (state)\nthis:\n  q1 \\<in> succ M2 (x, y) p1\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q1 \\<in> succ M2 (x, y) p1", "have \"q1 \\<in> successors M2 p1\""], ["proof (prove)\nusing this:\n  q1 \\<in> succ M2 (x, y) p1\n\ngoal (1 subgoal):\n 1. q1 \\<in> successors M2 p1", "by auto"], ["proof (state)\nthis:\n  q1 \\<in> successors M2 p1\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q1 \\<in> successors M2 p1", "have \"q1 \\<in> reachable M2 p1\""], ["proof (prove)\nusing this:\n  q1 \\<in> successors M2 p1\n\ngoal (1 subgoal):\n 1. q1 \\<in> reachable M2 p1", "by blast"], ["proof (state)\nthis:\n  q1 \\<in> reachable M2 p1\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q1 \\<in> reachable M2 p1", "have \"q1 \\<in> reachable M2 (initial M2)\""], ["proof (prove)\nusing this:\n  q1 \\<in> reachable M2 p1\n\ngoal (1 subgoal):\n 1. q1 \\<in> reachable M2 (initial M2)", "using subnodes"], ["proof (prove)\nusing this:\n  q1 \\<in> reachable M2 p1\n  p1 \\<in> nodes M2 \\<and>\n  p2 \\<in> nodes M1 \\<and>\n  x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1\n\ngoal (1 subgoal):\n 1. q1 \\<in> reachable M2 (initial M2)", "by blast"], ["proof (state)\nthis:\n  q1 \\<in> reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q1 \\<in> reachable M2 (initial M2)", "have nodes1 : \"q1 \\<in> nodes M2\""], ["proof (prove)\nusing this:\n  q1 \\<in> reachable M2 (initial M2)\n\ngoal (1 subgoal):\n 1. q1 \\<in> nodes M2", "by blast"], ["proof (state)\nthis:\n  q1 \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "have \"q2 \\<in> succ M1 (x,y) p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<in> succ M1 (x, y) p2", "using q_succ"], ["proof (prove)\nusing this:\n  (q1, q2) \\<in> succ M2 (x, y) p1 \\<times> succ M1 (x, y) p2\n\ngoal (1 subgoal):\n 1. q2 \\<in> succ M1 (x, y) p2", "by simp"], ["proof (state)\nthis:\n  q2 \\<in> succ M1 (x, y) p2\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q2 \\<in> succ M1 (x, y) p2", "have \"q2 \\<in> successors M1 p2\""], ["proof (prove)\nusing this:\n  q2 \\<in> succ M1 (x, y) p2\n\ngoal (1 subgoal):\n 1. q2 \\<in> successors M1 p2", "by auto"], ["proof (state)\nthis:\n  q2 \\<in> successors M1 p2\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q2 \\<in> successors M1 p2", "have \"q2 \\<in> reachable M1 p2\""], ["proof (prove)\nusing this:\n  q2 \\<in> successors M1 p2\n\ngoal (1 subgoal):\n 1. q2 \\<in> reachable M1 p2", "by blast"], ["proof (state)\nthis:\n  q2 \\<in> reachable M1 p2\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q2 \\<in> reachable M1 p2", "have \"q2 \\<in> reachable M1 (initial M1)\""], ["proof (prove)\nusing this:\n  q2 \\<in> reachable M1 p2\n\ngoal (1 subgoal):\n 1. q2 \\<in> reachable M1 (initial M1)", "using subnodes"], ["proof (prove)\nusing this:\n  q2 \\<in> reachable M1 p2\n  p1 \\<in> nodes M2 \\<and>\n  p2 \\<in> nodes M1 \\<and>\n  x \\<in> inputs M2 \\<and> y \\<in> outputs M2 \\<union> outputs M1\n\ngoal (1 subgoal):\n 1. q2 \\<in> reachable M1 (initial M1)", "by blast"], ["proof (state)\nthis:\n  q2 \\<in> reachable M1 (initial M1)\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "then"], ["proof (chain)\npicking this:\n  q2 \\<in> reachable M1 (initial M1)", "have nodes2 : \"q2 \\<in> nodes M1\""], ["proof (prove)\nusing this:\n  q2 \\<in> reachable M1 (initial M1)\n\ngoal (1 subgoal):\n 1. q2 \\<in> nodes M1", "by blast"], ["proof (state)\nthis:\n  q2 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. \\<not> (succ M2 (x, y) p1 = {} \\<and>\n            succ M1 (x, y) p2 \\<noteq> {}) \\<Longrightarrow>\n    q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "using nodes1 nodes2"], ["proof (prove)\nusing this:\n  q1 \\<in> nodes M2\n  q2 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "by auto"], ["proof (state)\nthis:\n  q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma well_formed_productF[simp] :\n  assumes \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"well_formed PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_formed PM", "unfolding well_formed.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_FSM PM \\<and>\n    (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite_FSM PM\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "have \"finite (nodes M1)\" \"finite (nodes M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes M1) &&& finite (nodes M2)", "using assms"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. finite (nodes M1) &&& finite (nodes M2)", "by auto"], ["proof (state)\nthis:\n  finite (nodes M1)\n  finite (nodes M2)\n\ngoal (2 subgoals):\n 1. finite_FSM PM\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  finite (nodes M1)\n  finite (nodes M2)", "have \"finite (insert FAIL (nodes M2 \\<times> nodes M1))\""], ["proof (prove)\nusing this:\n  finite (nodes M1)\n  finite (nodes M2)\n\ngoal (1 subgoal):\n 1. finite (insert FAIL (nodes M2 \\<times> nodes M1))", "by simp"], ["proof (state)\nthis:\n  finite (insert FAIL (nodes M2 \\<times> nodes M1))\n\ngoal (2 subgoals):\n 1. finite_FSM PM\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  finite (insert FAIL (nodes M2 \\<times> nodes M1))\n\ngoal (2 subgoals):\n 1. finite_FSM PM\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "have \"nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)", "using nodes_productF assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed ?M1.0; well_formed ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> nodes ?PM\n                    \\<subseteq> insert ?FAIL\n                                 (nodes ?M2.0 \\<times> nodes ?M1.0)\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)", "by blast"], ["proof (state)\nthis:\n  nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\n\ngoal (2 subgoals):\n 1. finite_FSM PM\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\n\ngoal (2 subgoals):\n 1. finite_FSM PM\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "have \"inputs PM = inputs M2\" \"outputs PM = outputs M2 \\<union> outputs M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputs PM = inputs M2 &&& outputs PM = outputs M2 \\<union> outputs M1", "using assms"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. inputs PM = inputs M2 &&& outputs PM = outputs M2 \\<union> outputs M1", "by auto"], ["proof (state)\nthis:\n  inputs PM = inputs M2\n  outputs PM = outputs M2 \\<union> outputs M1\n\ngoal (2 subgoals):\n 1. finite_FSM PM\n 2. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  finite (insert FAIL (nodes M2 \\<times> nodes M1))\n  nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\n  inputs PM = inputs M2\n  outputs PM = outputs M2 \\<union> outputs M1", "show \"finite_FSM PM\""], ["proof (prove)\nusing this:\n  finite (insert FAIL (nodes M2 \\<times> nodes M1))\n  nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\n  inputs PM = inputs M2\n  outputs PM = outputs M2 \\<union> outputs M1\n\ngoal (1 subgoal):\n 1. finite_FSM PM", "using infinite_subset assms"], ["proof (prove)\nusing this:\n  finite (insert FAIL (nodes M2 \\<times> nodes M1))\n  nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\n  inputs PM = inputs M2\n  outputs PM = outputs M2 \\<union> outputs M1\n  \\<lbrakk>infinite ?A; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> infinite ?B\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. finite_FSM PM", "by auto"], ["proof (state)\nthis:\n  finite_FSM PM\n\ngoal (1 subgoal):\n 1. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "have \"inputs PM = inputs M2\" \"outputs PM = outputs M2 \\<union> outputs M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputs PM = inputs M2 &&& outputs PM = outputs M2 \\<union> outputs M1", "using assms"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. inputs PM = inputs M2 &&& outputs PM = outputs M2 \\<union> outputs M1", "by auto"], ["proof (state)\nthis:\n  inputs PM = inputs M2\n  outputs PM = outputs M2 \\<union> outputs M1\n\ngoal (1 subgoal):\n 1. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  inputs PM = inputs M2\n  outputs PM = outputs M2 \\<union> outputs M1", "show \"(\\<forall>s1 x y. x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow> succ PM (x, y) s1 = {}) \n              \\<and> inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}\""], ["proof (prove)\nusing this:\n  inputs PM = inputs M2\n  outputs PM = outputs M2 \\<union> outputs M1\n\ngoal (1 subgoal):\n 1. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  inputs PM = inputs M2\n  outputs PM = outputs M2 \\<union> outputs M1\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. (\\<forall>s1 x y.\n        x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n        succ PM (x, y) s1 = {}) \\<and>\n    inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  (\\<forall>s1 x y.\n      x \\<notin> inputs PM \\<or> y \\<notin> outputs PM \\<longrightarrow>\n      succ PM (x, y) s1 = {}) \\<and>\n  inputs PM \\<noteq> {} \\<and> outputs PM \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_productF[simp] : \n  assumes \"observable M1\"\n  and     \"observable M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable PM", "unfolding observable.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t s1.\n       succ PM t s1 = {} \\<or> (\\<exists>s2. succ PM t s1 = {s2})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>t s1.\n       succ PM t s1 = {} \\<or> (\\<exists>s2. succ PM t s1 = {s2})", "have \"\\<forall> t s . succ M1 t (fst s) = {} \\<or> (\\<exists>s2. succ M1 t (fst s) = {s2})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t s.\n       succ M1 t (fst s) = {} \\<or> (\\<exists>s2. succ M1 t (fst s) = {s2})", "using assms"], ["proof (prove)\nusing this:\n  observable M1\n  observable M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. \\<forall>t s.\n       succ M1 t (fst s) = {} \\<or> (\\<exists>s2. succ M1 t (fst s) = {s2})", "by auto"], ["proof (state)\nthis:\n  \\<forall>t s.\n     succ M1 t (fst s) = {} \\<or> (\\<exists>s2. succ M1 t (fst s) = {s2})\n\ngoal (1 subgoal):\n 1. \\<forall>t s1.\n       succ PM t s1 = {} \\<or> (\\<exists>s2. succ PM t s1 = {s2})", "moreover"], ["proof (state)\nthis:\n  \\<forall>t s.\n     succ M1 t (fst s) = {} \\<or> (\\<exists>s2. succ M1 t (fst s) = {s2})\n\ngoal (1 subgoal):\n 1. \\<forall>t s1.\n       succ PM t s1 = {} \\<or> (\\<exists>s2. succ PM t s1 = {s2})", "have \"\\<forall> t s . succ M2 t (snd s) = {} \\<or> (\\<exists>s2. succ M2 t (snd s) = {s2})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t s.\n       succ M2 t (snd s) = {} \\<or> (\\<exists>s2. succ M2 t (snd s) = {s2})", "using assms"], ["proof (prove)\nusing this:\n  observable M1\n  observable M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. \\<forall>t s.\n       succ M2 t (snd s) = {} \\<or> (\\<exists>s2. succ M2 t (snd s) = {s2})", "by auto"], ["proof (state)\nthis:\n  \\<forall>t s.\n     succ M2 t (snd s) = {} \\<or> (\\<exists>s2. succ M2 t (snd s) = {s2})\n\ngoal (1 subgoal):\n 1. \\<forall>t s1.\n       succ PM t s1 = {} \\<or> (\\<exists>s2. succ PM t s1 = {s2})", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>t s.\n     succ M1 t (fst s) = {} \\<or> (\\<exists>s2. succ M1 t (fst s) = {s2})\n  \\<forall>t s.\n     succ M2 t (snd s) = {} \\<or> (\\<exists>s2. succ M2 t (snd s) = {s2})", "have sub_succs : \"\\<forall> t s . succ M2 t (fst s) \\<times> succ M1 t (snd s) = {} \n                                        \\<or> (\\<exists> s2 . succ M2 t (fst s) \\<times> succ M1 t (snd s) = {s2})\""], ["proof (prove)\nusing this:\n  \\<forall>t s.\n     succ M1 t (fst s) = {} \\<or> (\\<exists>s2. succ M1 t (fst s) = {s2})\n  \\<forall>t s.\n     succ M2 t (snd s) = {} \\<or> (\\<exists>s2. succ M2 t (snd s) = {s2})\n\ngoal (1 subgoal):\n 1. \\<forall>t s.\n       succ M2 t (fst s) \\<times> succ M1 t (snd s) = {} \\<or>\n       (\\<exists>s2. succ M2 t (fst s) \\<times> succ M1 t (snd s) = {s2})", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>t s.\n     succ M2 t (fst s) \\<times> succ M1 t (snd s) = {} \\<or>\n     (\\<exists>s2. succ M2 t (fst s) \\<times> succ M1 t (snd s) = {s2})\n\ngoal (1 subgoal):\n 1. \\<forall>t s1.\n       succ PM t s1 = {} \\<or> (\\<exists>s2. succ PM t s1 = {s2})", "moreover"], ["proof (state)\nthis:\n  \\<forall>t s.\n     succ M2 t (fst s) \\<times> succ M1 t (snd s) = {} \\<or>\n     (\\<exists>s2. succ M2 t (fst s) \\<times> succ M1 t (snd s) = {s2})\n\ngoal (1 subgoal):\n 1. \\<forall>t s1.\n       succ PM t s1 = {} \\<or> (\\<exists>s2. succ PM t s1 = {s2})", "have succ_split : \"\\<forall> t s . succ PM t s = {} \n                                      \\<or> succ PM t s = {FAIL} \n                                      \\<or> succ PM t s = succ M2 t (fst s) \\<times> succ M1 t (snd s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t s.\n       succ PM t s = {} \\<or>\n       succ PM t s = {FAIL} \\<or>\n       succ PM t s = succ M2 t (fst s) \\<times> succ M1 t (snd s)", "using assms"], ["proof (prove)\nusing this:\n  observable M1\n  observable M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. \\<forall>t s.\n       succ PM t s = {} \\<or>\n       succ PM t s = {FAIL} \\<or>\n       succ PM t s = succ M2 t (fst s) \\<times> succ M1 t (snd s)", "by auto"], ["proof (state)\nthis:\n  \\<forall>t s.\n     succ PM t s = {} \\<or>\n     succ PM t s = {FAIL} \\<or>\n     succ PM t s = succ M2 t (fst s) \\<times> succ M1 t (snd s)\n\ngoal (1 subgoal):\n 1. \\<forall>t s1.\n       succ PM t s1 = {} \\<or> (\\<exists>s2. succ PM t s1 = {s2})", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>t s.\n     succ M2 t (fst s) \\<times> succ M1 t (snd s) = {} \\<or>\n     (\\<exists>s2. succ M2 t (fst s) \\<times> succ M1 t (snd s) = {s2})\n  \\<forall>t s.\n     succ PM t s = {} \\<or>\n     succ PM t s = {FAIL} \\<or>\n     succ PM t s = succ M2 t (fst s) \\<times> succ M1 t (snd s)", "show \"\\<forall>t s. succ PM t s = {} \\<or> (\\<exists>s2. succ PM t s = {s2})\""], ["proof (prove)\nusing this:\n  \\<forall>t s.\n     succ M2 t (fst s) \\<times> succ M1 t (snd s) = {} \\<or>\n     (\\<exists>s2. succ M2 t (fst s) \\<times> succ M1 t (snd s) = {s2})\n  \\<forall>t s.\n     succ PM t s = {} \\<or>\n     succ PM t s = {FAIL} \\<or>\n     succ PM t s = succ M2 t (fst s) \\<times> succ M1 t (snd s)\n\ngoal (1 subgoal):\n 1. \\<forall>t s. succ PM t s = {} \\<or> (\\<exists>s2. succ PM t s = {s2})", "by metis"], ["proof (state)\nthis:\n  \\<forall>t s. succ PM t s = {} \\<or> (\\<exists>s2. succ PM t s = {s2})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_transition_after_FAIL :\n  assumes \"productF A B FAIL AB\"\n  shows \"succ AB io FAIL = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ AB io FAIL = {}", "using assms"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n\ngoal (1 subgoal):\n 1. succ AB io FAIL = {}", "by auto"], ["", "lemma no_prefix_targets_FAIL :\n  assumes \"productF M2 M1 FAIL PM\"\n  and     \"path PM p q\"\n  and     \"k < length p\"\nshows \"target (take k p) q \\<noteq> FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (take k p) q \\<noteq> FAIL", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. target (take k p) q = FAIL \\<Longrightarrow> False", "assume assm : \"target (take k p) q = FAIL\""], ["proof (state)\nthis:\n  target (take k p) q = FAIL\n\ngoal (1 subgoal):\n 1. target (take k p) q = FAIL \\<Longrightarrow> False", "have \"path PM (take k p @ drop k p) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (take k p @ drop k p) q", "using assms"], ["proof (prove)\nusing this:\n  productF M2 M1 FAIL PM\n  path PM p q\n  k < length p\n\ngoal (1 subgoal):\n 1. path PM (take k p @ drop k p) q", "by auto"], ["proof (state)\nthis:\n  path PM (take k p @ drop k p) q\n\ngoal (1 subgoal):\n 1. target (take k p) q = FAIL \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path PM (take k p @ drop k p) q", "have \"path PM (drop k p) (target (take k p) q)\""], ["proof (prove)\nusing this:\n  path PM (take k p @ drop k p) q\n\ngoal (1 subgoal):\n 1. path PM (drop k p) (target (take k p) q)", "by blast"], ["proof (state)\nthis:\n  path PM (drop k p) (target (take k p) q)\n\ngoal (1 subgoal):\n 1. target (take k p) q = FAIL \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path PM (drop k p) (target (take k p) q)", "have path_from_FAIL : \"path PM (drop k p) FAIL\""], ["proof (prove)\nusing this:\n  path PM (drop k p) (target (take k p) q)\n\ngoal (1 subgoal):\n 1. path PM (drop k p) FAIL", "using assm"], ["proof (prove)\nusing this:\n  path PM (drop k p) (target (take k p) q)\n  target (take k p) q = FAIL\n\ngoal (1 subgoal):\n 1. path PM (drop k p) FAIL", "by auto"], ["proof (state)\nthis:\n  path PM (drop k p) FAIL\n\ngoal (1 subgoal):\n 1. target (take k p) q = FAIL \\<Longrightarrow> False", "have \"length (drop k p) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (drop k p) \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  productF M2 M1 FAIL PM\n  path PM p q\n  k < length p\n\ngoal (1 subgoal):\n 1. length (drop k p) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length (drop k p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. target (take k p) q = FAIL \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  length (drop k p) \\<noteq> 0", "obtain io q where \"drop k p = (io,q) # (drop (Suc k) p)\""], ["proof (prove)\nusing this:\n  length (drop k p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>io q.\n        drop k p = (io, q) # drop (Suc k) p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Cons_nth_drop_Suc assms(3) prod_cases3)"], ["proof (state)\nthis:\n  drop k p = (io, q) # drop (Suc k) p\n\ngoal (1 subgoal):\n 1. target (take k p) q = FAIL \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  drop k p = (io, q) # drop (Suc k) p", "have \"succ PM io FAIL \\<noteq> {}\""], ["proof (prove)\nusing this:\n  drop k p = (io, q) # drop (Suc k) p\n\ngoal (1 subgoal):\n 1. succ PM io FAIL \\<noteq> {}", "using path_from_FAIL"], ["proof (prove)\nusing this:\n  drop k p = (io, q) # drop (Suc k) p\n  path PM (drop k p) FAIL\n\ngoal (1 subgoal):\n 1. succ PM io FAIL \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  succ PM io FAIL \\<noteq> {}\n\ngoal (1 subgoal):\n 1. target (take k p) q = FAIL \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  succ PM io FAIL \\<noteq> {}", "show \"False\""], ["proof (prove)\nusing this:\n  succ PM io FAIL \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "using no_transition_after_FAIL assms"], ["proof (prove)\nusing this:\n  succ PM io FAIL \\<noteq> {}\n  productF ?A ?B ?FAIL ?AB \\<Longrightarrow> succ ?AB ?io ?FAIL = {}\n  productF M2 M1 FAIL PM\n  path PM p q\n  k < length p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma productF_path_inclusion :\n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"path A (w || r1) p1 \\<and> path B (w || r2) p2\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\nshows \"path (AB) (w || r1 || r2) (p1, p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB (w || r1 || r2) (p1, p2)", "using assms"], ["proof (prove)\nusing this:\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w || r1) p1 \\<and> path B (w || r2) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB (w || r1 || r2) (p1, p2)", "proof (induction w r1 r2 arbitrary: p1 p2 rule: list_induct3)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p1 p2.\n       \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n        path A ([] || []) p1 \\<and> path B ([] || []) p2; p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB ([] || [] || []) (p1, p2)\n 2. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "case Nil"], ["proof (state)\nthis:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A ([] || []) p1 \\<and> path B ([] || []) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (2 subgoals):\n 1. \\<And>p1 p2.\n       \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n        path A ([] || []) p1 \\<and> path B ([] || []) p2; p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB ([] || [] || []) (p1, p2)\n 2. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A ([] || []) p1 \\<and> path B ([] || []) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B", "show ?case"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A ([] || []) p1 \\<and> path B ([] || []) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB ([] || [] || []) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB ([] || [] || []) (p1, p2)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "case (Cons w ws r1 r1s r2 r2s)"], ["proof (state)\nthis:\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0;\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0;\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B", "have \"path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\""], ["proof (prove)\nusing this:\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0;\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2", "by auto"], ["proof (state)\nthis:\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2", "have succs : \"r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\""], ["proof (prove)\nusing this:\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2", "by auto"], ["proof (state)\nthis:\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2", "have \"succ A w p1 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\n\ngoal (1 subgoal):\n 1. succ A w p1 \\<noteq> {}", "by force"], ["proof (state)\nthis:\n  succ A w p1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  succ A w p1 \\<noteq> {}", "have w_elem : \"fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \""], ["proof (prove)\nusing this:\n  succ A w p1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fst w \\<in> inputs A \\<and> snd w \\<in> outputs A", "using Cons"], ["proof (prove)\nusing this:\n  succ A w p1 \\<noteq> {}\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0;\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. fst w \\<in> inputs A \\<and> snd w \\<in> outputs A", "by (metis assms(4) prod.collapse well_formed.elims(2))"], ["proof (state)\nthis:\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A", "have \"(r1,r2) \\<in> succ AB w (p1,p2)\""], ["proof (prove)\nusing this:\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<in> succ AB w (p1, p2)", "using Cons succs"], ["proof (prove)\nusing this:\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0;\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<in> succ AB w (p1, p2)", "by auto"], ["proof (state)\nthis:\n  (r1, r2) \\<in> succ AB w (p1, p2)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  (r1, r2) \\<in> succ AB w (p1, p2)", "have path_head : \"path AB ([w] || [(r1,r2)]) (p1,p2)\""], ["proof (prove)\nusing this:\n  (r1, r2) \\<in> succ AB w (p1, p2)\n\ngoal (1 subgoal):\n 1. path AB ([w] || [(r1, r2)]) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB ([w] || [(r1, r2)]) (p1, p2)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "have \"path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2", "using Cons"], ["proof (prove)\nusing this:\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0;\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2", "by auto"], ["proof (state)\nthis:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "moreover"], ["proof (state)\nthis:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "have \"r1 \\<in> nodes A \\<and> r2 \\<in> nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1 \\<in> nodes A \\<and> r2 \\<in> nodes B", "using succs Cons.prems succ_nodes[of r1 A w p1] succ_nodes[of r2 B w p2]"], ["proof (prove)\nusing this:\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  \\<lbrakk>r1 \\<in> succ A w p1; p1 \\<in> nodes A\\<rbrakk>\n  \\<Longrightarrow> r1 \\<in> nodes A\n  \\<lbrakk>r2 \\<in> succ B w p2; p2 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> r2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. r1 \\<in> nodes A \\<and> r2 \\<in> nodes B", "by auto"], ["proof (state)\nthis:\n  r1 \\<in> nodes A \\<and> r2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "ultimately"], ["proof (chain)\npicking this:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\n  r1 \\<in> nodes A \\<and> r2 \\<in> nodes B", "have \"path AB (ws || r1s || r2s) (r1,r2)\""], ["proof (prove)\nusing this:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\n  r1 \\<in> nodes A \\<and> r2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB (ws || r1s || r2s) (r1, r2)", "using Cons"], ["proof (prove)\nusing this:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\n  r1 \\<in> nodes A \\<and> r2 \\<in> nodes B\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0;\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB (ws || r1s || r2s) (r1, r2)", "by blast"], ["proof (state)\nthis:\n  path AB (ws || r1s || r2s) (r1, r2)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2;\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and> path B (x # xs || z # zs) p2;\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  path AB (ws || r1s || r2s) (r1, r2)", "show ?case"], ["proof (prove)\nusing this:\n  path AB (ws || r1s || r2s) (r1, r2)\n\ngoal (1 subgoal):\n 1. path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "using path_head"], ["proof (prove)\nusing this:\n  path AB (ws || r1s || r2s) (r1, r2)\n  path AB ([w] || [(r1, r2)]) (p1, p2)\n\ngoal (1 subgoal):\n 1. path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma productF_path_forward :\n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"(path A (w || r1) p1 \\<and> path B (w || r2) p2) \n            \\<or> (target (w || r1 || r2) (p1, p2) = FAIL\n              \\<and> length w > 0\n              \\<and> path A (butlast (w || r1)) p1\n              \\<and> path B (butlast (w || r2)) p2\n              \\<and> succ A (last w) (target (butlast (w || r1)) p1) = {}\n              \\<and> succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {})\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\nshows \"path (AB) (w || r1 || r2) (p1, p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB (w || r1 || r2) (p1, p2)", "using assms"], ["proof (prove)\nusing this:\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB (w || r1 || r2) (p1, p2)", "proof (induction w r1 r2 arbitrary: p1 p2 rule: list_induct3)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p1 p2.\n       \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n        path A ([] || []) p1 \\<and> path B ([] || []) p2 \\<or>\n        target ([] || [] || []) (p1, p2) = FAIL \\<and>\n        0 < length [] \\<and>\n        path A (butlast ([] || [])) p1 \\<and>\n        path B (butlast ([] || [])) p2 \\<and>\n        succ A (last []) (target (butlast ([] || [])) p1) = {} \\<and>\n        succ B (last []) (target (butlast ([] || [])) p2) \\<noteq> {};\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB ([] || [] || []) (p1, p2)\n 2. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2 \\<or>\n            target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n            0 < length xs \\<and>\n            path A (butlast (xs || ys)) p1 \\<and>\n            path B (butlast (xs || zs)) p2 \\<and>\n            succ A (last xs) (target (butlast (xs || ys)) p1) = {} \\<and>\n            succ B (last xs) (target (butlast (xs || zs)) p2) \\<noteq> {};\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and>\n        path B (x # xs || z # zs) p2 \\<or>\n        target (x # xs || y # ys || z # zs) (p1, p2) = FAIL \\<and>\n        0 < length (x # xs) \\<and>\n        path A (butlast (x # xs || y # ys)) p1 \\<and>\n        path B (butlast (x # xs || z # zs)) p2 \\<and>\n        succ A (last (x # xs)) (target (butlast (x # xs || y # ys)) p1) =\n        {} \\<and>\n        succ B (last (x # xs))\n         (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n        {};\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "case Nil"], ["proof (state)\nthis:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A ([] || []) p1 \\<and> path B ([] || []) p2 \\<or>\n  target ([] || [] || []) (p1, p2) = FAIL \\<and>\n  0 < length [] \\<and>\n  path A (butlast ([] || [])) p1 \\<and>\n  path B (butlast ([] || [])) p2 \\<and>\n  succ A (last []) (target (butlast ([] || [])) p1) = {} \\<and>\n  succ B (last []) (target (butlast ([] || [])) p2) \\<noteq> {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (2 subgoals):\n 1. \\<And>p1 p2.\n       \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n        path A ([] || []) p1 \\<and> path B ([] || []) p2 \\<or>\n        target ([] || [] || []) (p1, p2) = FAIL \\<and>\n        0 < length [] \\<and>\n        path A (butlast ([] || [])) p1 \\<and>\n        path B (butlast ([] || [])) p2 \\<and>\n        succ A (last []) (target (butlast ([] || [])) p1) = {} \\<and>\n        succ B (last []) (target (butlast ([] || [])) p2) \\<noteq> {};\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB ([] || [] || []) (p1, p2)\n 2. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2 \\<or>\n            target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n            0 < length xs \\<and>\n            path A (butlast (xs || ys)) p1 \\<and>\n            path B (butlast (xs || zs)) p2 \\<and>\n            succ A (last xs) (target (butlast (xs || ys)) p1) = {} \\<and>\n            succ B (last xs) (target (butlast (xs || zs)) p2) \\<noteq> {};\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and>\n        path B (x # xs || z # zs) p2 \\<or>\n        target (x # xs || y # ys || z # zs) (p1, p2) = FAIL \\<and>\n        0 < length (x # xs) \\<and>\n        path A (butlast (x # xs || y # ys)) p1 \\<and>\n        path B (butlast (x # xs || z # zs)) p2 \\<and>\n        succ A (last (x # xs)) (target (butlast (x # xs || y # ys)) p1) =\n        {} \\<and>\n        succ B (last (x # xs))\n         (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n        {};\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A ([] || []) p1 \\<and> path B ([] || []) p2 \\<or>\n  target ([] || [] || []) (p1, p2) = FAIL \\<and>\n  0 < length [] \\<and>\n  path A (butlast ([] || [])) p1 \\<and>\n  path B (butlast ([] || [])) p2 \\<and>\n  succ A (last []) (target (butlast ([] || [])) p1) = {} \\<and>\n  succ B (last []) (target (butlast ([] || [])) p2) \\<noteq> {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B", "show ?case"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A ([] || []) p1 \\<and> path B ([] || []) p2 \\<or>\n  target ([] || [] || []) (p1, p2) = FAIL \\<and>\n  0 < length [] \\<and>\n  path A (butlast ([] || [])) p1 \\<and>\n  path B (butlast ([] || [])) p2 \\<and>\n  succ A (last []) (target (butlast ([] || [])) p1) = {} \\<and>\n  succ B (last []) (target (butlast ([] || [])) p2) \\<noteq> {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB ([] || [] || []) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB ([] || [] || []) (p1, p2)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2 \\<or>\n            target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n            0 < length xs \\<and>\n            path A (butlast (xs || ys)) p1 \\<and>\n            path B (butlast (xs || zs)) p2 \\<and>\n            succ A (last xs) (target (butlast (xs || ys)) p1) = {} \\<and>\n            succ B (last xs) (target (butlast (xs || zs)) p2) \\<noteq> {};\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and>\n        path B (x # xs || z # zs) p2 \\<or>\n        target (x # xs || y # ys || z # zs) (p1, p2) = FAIL \\<and>\n        0 < length (x # xs) \\<and>\n        path A (butlast (x # xs || y # ys)) p1 \\<and>\n        path B (butlast (x # xs || z # zs)) p2 \\<and>\n        succ A (last (x # xs)) (target (butlast (x # xs || y # ys)) p1) =\n        {} \\<and>\n        succ B (last (x # xs))\n         (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n        {};\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2 \\<or>\n            target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n            0 < length xs \\<and>\n            path A (butlast (xs || ys)) p1 \\<and>\n            path B (butlast (xs || zs)) p2 \\<and>\n            succ A (last xs) (target (butlast (xs || ys)) p1) = {} \\<and>\n            succ B (last xs) (target (butlast (xs || zs)) p2) \\<noteq> {};\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and>\n        path B (x # xs || z # zs) p2 \\<or>\n        target (x # xs || y # ys || z # zs) (p1, p2) = FAIL \\<and>\n        0 < length (x # xs) \\<and>\n        path A (butlast (x # xs || y # ys)) p1 \\<and>\n        path B (butlast (x # xs || z # zs)) p2 \\<and>\n        succ A (last (x # xs)) (target (butlast (x # xs || y # ys)) p1) =\n        {} \\<and>\n        succ B (last (x # xs))\n         (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n        {};\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "case (Cons w ws r1 r1s r2 r2s)"], ["proof (state)\nthis:\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0 \\<or>\n   target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n   0 < length ws \\<and>\n   path A (butlast (ws || r1s)) ?p1.0 \\<and>\n   path B (butlast (ws || r2s)) ?p2.0 \\<and>\n   succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) = {} \\<and>\n   succ B (last ws) (target (butlast (ws || r2s)) ?p2.0) \\<noteq> {};\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path A (xs || ys) p1 \\<and> path B (xs || zs) p2 \\<or>\n            target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n            0 < length xs \\<and>\n            path A (butlast (xs || ys)) p1 \\<and>\n            path B (butlast (xs || zs)) p2 \\<and>\n            succ A (last xs) (target (butlast (xs || ys)) p1) = {} \\<and>\n            succ B (last xs) (target (butlast (xs || zs)) p2) \\<noteq> {};\n            p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path AB (xs || ys || zs) (p1, p2);\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path A (x # xs || y # ys) p1 \\<and>\n        path B (x # xs || z # zs) p2 \\<or>\n        target (x # xs || y # ys || z # zs) (p1, p2) = FAIL \\<and>\n        0 < length (x # xs) \\<and>\n        path A (butlast (x # xs || y # ys)) p1 \\<and>\n        path B (butlast (x # xs || z # zs)) p2 \\<and>\n        succ A (last (x # xs)) (target (butlast (x # xs || y # ys)) p1) =\n        {} \\<and>\n        succ B (last (x # xs))\n         (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n        {};\n        p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path AB (x # xs || y # ys || z # zs) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0 \\<or>\n   target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n   0 < length ws \\<and>\n   path A (butlast (ws || r1s)) ?p1.0 \\<and>\n   path B (butlast (ws || r2s)) ?p2.0 \\<and>\n   succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) = {} \\<and>\n   succ B (last ws) (target (butlast (ws || r2s)) ?p2.0) \\<noteq> {};\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B", "show ?case"], ["proof (prove)\nusing this:\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0 \\<or>\n   target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n   0 < length ws \\<and>\n   path A (butlast (ws || r1s)) ?p1.0 \\<and>\n   path B (butlast (ws || r2s)) ?p2.0 \\<and>\n   succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) = {} \\<and>\n   succ B (last ws) (target (butlast (ws || r2s)) ?p2.0) \\<noteq> {};\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "proof (cases \"(path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length ws = length r1s; length r1s = length r2s;\n     \\<And>p1 p2.\n        \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n         path A (ws || r1s) p1 \\<and> path B (ws || r2s) p2 \\<or>\n         target (ws || r1s || r2s) (p1, p2) = FAIL \\<and>\n         0 < length ws \\<and>\n         path A (butlast (ws || r1s)) p1 \\<and>\n         path B (butlast (ws || r2s)) p2 \\<and>\n         succ A (last ws) (target (butlast (ws || r1s)) p1) = {} \\<and>\n         succ B (last ws) (target (butlast (ws || r2s)) p2) \\<noteq> {};\n         p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n        \\<Longrightarrow> path AB (ws || r1s || r2s) (p1, p2);\n     productF A B FAIL AB; well_formed A; well_formed B;\n     path A (w # ws || r1 # r1s) p1 \\<and>\n     path B (w # ws || r2 # r2s) p2 \\<or>\n     target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n     0 < length (w # ws) \\<and>\n     path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n     path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n     succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n     {} \\<and>\n     succ B (last (w # ws))\n      (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n     {};\n     p1 \\<in> nodes A; p2 \\<in> nodes B;\n     path A (w # ws || r1 # r1s) p1 \\<and>\n     path B (w # ws || r2 # r2s) p2\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<lbrakk>length ws = length r1s; length r1s = length r2s;\n     \\<And>p1 p2.\n        \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n         path A (ws || r1s) p1 \\<and> path B (ws || r2s) p2 \\<or>\n         target (ws || r1s || r2s) (p1, p2) = FAIL \\<and>\n         0 < length ws \\<and>\n         path A (butlast (ws || r1s)) p1 \\<and>\n         path B (butlast (ws || r2s)) p2 \\<and>\n         succ A (last ws) (target (butlast (ws || r1s)) p1) = {} \\<and>\n         succ B (last ws) (target (butlast (ws || r2s)) p2) \\<noteq> {};\n         p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n        \\<Longrightarrow> path AB (ws || r1s || r2s) (p1, p2);\n     productF A B FAIL AB; well_formed A; well_formed B;\n     path A (w # ws || r1 # r1s) p1 \\<and>\n     path B (w # ws || r2 # r2s) p2 \\<or>\n     target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n     0 < length (w # ws) \\<and>\n     path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n     path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n     succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n     {} \\<and>\n     succ B (last (w # ws))\n      (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n     {};\n     p1 \\<in> nodes A; p2 \\<in> nodes B;\n     \\<not> (path A (w # ws || r1 # r1s) p1 \\<and>\n             path B (w # ws || r2 # r2s) p2)\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "case True"], ["proof (state)\nthis:\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length ws = length r1s; length r1s = length r2s;\n     \\<And>p1 p2.\n        \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n         path A (ws || r1s) p1 \\<and> path B (ws || r2s) p2 \\<or>\n         target (ws || r1s || r2s) (p1, p2) = FAIL \\<and>\n         0 < length ws \\<and>\n         path A (butlast (ws || r1s)) p1 \\<and>\n         path B (butlast (ws || r2s)) p2 \\<and>\n         succ A (last ws) (target (butlast (ws || r1s)) p1) = {} \\<and>\n         succ B (last ws) (target (butlast (ws || r2s)) p2) \\<noteq> {};\n         p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n        \\<Longrightarrow> path AB (ws || r1s || r2s) (p1, p2);\n     productF A B FAIL AB; well_formed A; well_formed B;\n     path A (w # ws || r1 # r1s) p1 \\<and>\n     path B (w # ws || r2 # r2s) p2 \\<or>\n     target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n     0 < length (w # ws) \\<and>\n     path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n     path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n     succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n     {} \\<and>\n     succ B (last (w # ws))\n      (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n     {};\n     p1 \\<in> nodes A; p2 \\<in> nodes B;\n     path A (w # ws || r1 # r1s) p1 \\<and>\n     path B (w # ws || r2 # r2s) p2\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<lbrakk>length ws = length r1s; length r1s = length r2s;\n     \\<And>p1 p2.\n        \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n         path A (ws || r1s) p1 \\<and> path B (ws || r2s) p2 \\<or>\n         target (ws || r1s || r2s) (p1, p2) = FAIL \\<and>\n         0 < length ws \\<and>\n         path A (butlast (ws || r1s)) p1 \\<and>\n         path B (butlast (ws || r2s)) p2 \\<and>\n         succ A (last ws) (target (butlast (ws || r1s)) p1) = {} \\<and>\n         succ B (last ws) (target (butlast (ws || r2s)) p2) \\<noteq> {};\n         p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n        \\<Longrightarrow> path AB (ws || r1s || r2s) (p1, p2);\n     productF A B FAIL AB; well_formed A; well_formed B;\n     path A (w # ws || r1 # r1s) p1 \\<and>\n     path B (w # ws || r2 # r2s) p2 \\<or>\n     target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n     0 < length (w # ws) \\<and>\n     path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n     path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n     succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n     {} \\<and>\n     succ B (last (w # ws))\n      (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n     {};\n     p1 \\<in> nodes A; p2 \\<in> nodes B;\n     \\<not> (path A (w # ws || r1 # r1s) p1 \\<and>\n             path B (w # ws || r2 # r2s) p2)\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2", "show ?thesis"], ["proof (prove)\nusing this:\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n\ngoal (1 subgoal):\n 1. path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "using Cons productF_path_inclusion[of \"w # ws\" \"r1 # r1s\" \"r2 # r2s\" A B FAIL AB p1 p2]"], ["proof (prove)\nusing this:\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0 \\<or>\n   target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n   0 < length ws \\<and>\n   path A (butlast (ws || r1s)) ?p1.0 \\<and>\n   path B (butlast (ws || r2s)) ?p2.0 \\<and>\n   succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) = {} \\<and>\n   succ B (last ws) (target (butlast (ws || r2s)) ?p2.0) \\<noteq> {};\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  \\<lbrakk>length (w # ws) = length (r1 # r1s);\n   length (r1 # r1s) = length (r2 # r2s); productF A B FAIL AB;\n   well_formed A; well_formed B;\n   path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2;\n   p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n\ngoal (1 subgoal):\n 1. path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; length r1s = length r2s;\n     \\<And>p1 p2.\n        \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n         path A (ws || r1s) p1 \\<and> path B (ws || r2s) p2 \\<or>\n         target (ws || r1s || r2s) (p1, p2) = FAIL \\<and>\n         0 < length ws \\<and>\n         path A (butlast (ws || r1s)) p1 \\<and>\n         path B (butlast (ws || r2s)) p2 \\<and>\n         succ A (last ws) (target (butlast (ws || r1s)) p1) = {} \\<and>\n         succ B (last ws) (target (butlast (ws || r2s)) p2) \\<noteq> {};\n         p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n        \\<Longrightarrow> path AB (ws || r1s || r2s) (p1, p2);\n     productF A B FAIL AB; well_formed A; well_formed B;\n     path A (w # ws || r1 # r1s) p1 \\<and>\n     path B (w # ws || r2 # r2s) p2 \\<or>\n     target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n     0 < length (w # ws) \\<and>\n     path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n     path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n     succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n     {} \\<and>\n     succ B (last (w # ws))\n      (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n     {};\n     p1 \\<in> nodes A; p2 \\<in> nodes B;\n     \\<not> (path A (w # ws || r1 # r1s) p1 \\<and>\n             path B (w # ws || r2 # r2s) p2)\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; length r1s = length r2s;\n     \\<And>p1 p2.\n        \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n         path A (ws || r1s) p1 \\<and> path B (ws || r2s) p2 \\<or>\n         target (ws || r1s || r2s) (p1, p2) = FAIL \\<and>\n         0 < length ws \\<and>\n         path A (butlast (ws || r1s)) p1 \\<and>\n         path B (butlast (ws || r2s)) p2 \\<and>\n         succ A (last ws) (target (butlast (ws || r1s)) p1) = {} \\<and>\n         succ B (last ws) (target (butlast (ws || r2s)) p2) \\<noteq> {};\n         p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n        \\<Longrightarrow> path AB (ws || r1s || r2s) (p1, p2);\n     productF A B FAIL AB; well_formed A; well_formed B;\n     path A (w # ws || r1 # r1s) p1 \\<and>\n     path B (w # ws || r2 # r2s) p2 \\<or>\n     target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n     0 < length (w # ws) \\<and>\n     path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n     path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n     succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n     {} \\<and>\n     succ B (last (w # ws))\n      (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n     {};\n     p1 \\<in> nodes A; p2 \\<in> nodes B;\n     \\<not> (path A (w # ws || r1 # r1s) p1 \\<and>\n             path B (w # ws || r2 # r2s) p2)\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "case False"], ["proof (state)\nthis:\n  \\<not> (path A (w # ws || r1 # r1s) p1 \\<and>\n          path B (w # ws || r2 # r2s) p2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; length r1s = length r2s;\n     \\<And>p1 p2.\n        \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n         path A (ws || r1s) p1 \\<and> path B (ws || r2s) p2 \\<or>\n         target (ws || r1s || r2s) (p1, p2) = FAIL \\<and>\n         0 < length ws \\<and>\n         path A (butlast (ws || r1s)) p1 \\<and>\n         path B (butlast (ws || r2s)) p2 \\<and>\n         succ A (last ws) (target (butlast (ws || r1s)) p1) = {} \\<and>\n         succ B (last ws) (target (butlast (ws || r2s)) p2) \\<noteq> {};\n         p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n        \\<Longrightarrow> path AB (ws || r1s || r2s) (p1, p2);\n     productF A B FAIL AB; well_formed A; well_formed B;\n     path A (w # ws || r1 # r1s) p1 \\<and>\n     path B (w # ws || r2 # r2s) p2 \\<or>\n     target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n     0 < length (w # ws) \\<and>\n     path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n     path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n     succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n     {} \\<and>\n     succ B (last (w # ws))\n      (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n     {};\n     p1 \\<in> nodes A; p2 \\<in> nodes B;\n     \\<not> (path A (w # ws || r1 # r1s) p1 \\<and>\n             path B (w # ws || r2 # r2s) p2)\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  \\<not> (path A (w # ws || r1 # r1s) p1 \\<and>\n          path B (w # ws || r2 # r2s) p2)", "have fail_prop : \"target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) = {} \\<and>\n                succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> (path A (w # ws || r1 # r1s) p1 \\<and>\n          path B (w # ws || r2 # r2s) p2)\n\ngoal (1 subgoal):\n 1. target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "using Cons.prems"], ["proof (prove)\nusing this:\n  \\<not> (path A (w # ws || r1 # r1s) p1 \\<and>\n          path B (w # ws || r2 # r2s) p2)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "by fastforce"], ["proof (state)\nthis:\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; length r1s = length r2s;\n     \\<And>p1 p2.\n        \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n         path A (ws || r1s) p1 \\<and> path B (ws || r2s) p2 \\<or>\n         target (ws || r1s || r2s) (p1, p2) = FAIL \\<and>\n         0 < length ws \\<and>\n         path A (butlast (ws || r1s)) p1 \\<and>\n         path B (butlast (ws || r2s)) p2 \\<and>\n         succ A (last ws) (target (butlast (ws || r1s)) p1) = {} \\<and>\n         succ B (last ws) (target (butlast (ws || r2s)) p2) \\<noteq> {};\n         p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n        \\<Longrightarrow> path AB (ws || r1s || r2s) (p1, p2);\n     productF A B FAIL AB; well_formed A; well_formed B;\n     path A (w # ws || r1 # r1s) p1 \\<and>\n     path B (w # ws || r2 # r2s) p2 \\<or>\n     target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n     0 < length (w # ws) \\<and>\n     path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n     path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n     succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n     {} \\<and>\n     succ B (last (w # ws))\n      (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n     {};\n     p1 \\<in> nodes A; p2 \\<in> nodes B;\n     \\<not> (path A (w # ws || r1 # r1s) p1 \\<and>\n             path B (w # ws || r2 # r2s) p2)\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "proof (cases \"length ws\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n             0 < length (w # ws) \\<and>\n             path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n             path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n             succ A (last (w # ws))\n              (target (butlast (w # ws || r1 # r1s)) p1) =\n             {} \\<and>\n             succ B (last (w # ws))\n              (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n             {};\n     length ws = 0\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "case 0"], ["proof (state)\nthis:\n  length ws = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n             0 < length (w # ws) \\<and>\n             path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n             path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n             succ A (last (w # ws))\n              (target (butlast (w # ws || r1 # r1s)) p1) =\n             {} \\<and>\n             succ B (last (w # ws))\n              (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n             {};\n     length ws = 0\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  length ws = 0", "have empty[simp] : \"ws = []\" \"r1s = []\" \"r2s = []\""], ["proof (prove)\nusing this:\n  length ws = 0\n\ngoal (1 subgoal):\n 1. ws = [] &&& r1s = [] &&& r2s = []", "using Cons.hyps"], ["proof (prove)\nusing this:\n  length ws = 0\n  length ws = length r1s\n  length r1s = length r2s\n\ngoal (1 subgoal):\n 1. ws = [] &&& r1s = [] &&& r2s = []", "by auto"], ["proof (state)\nthis:\n  ws = []\n  r1s = []\n  r2s = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n             0 < length (w # ws) \\<and>\n             path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n             path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n             succ A (last (w # ws))\n              (target (butlast (w # ws || r1 # r1s)) p1) =\n             {} \\<and>\n             succ B (last (w # ws))\n              (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n             {};\n     length ws = 0\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  ws = []\n  r1s = []\n  r2s = []", "have fail_prop_0 : \"target ( [w] || [r1] || [r2]) (p1, p2) = FAIL \\<and>\n                0 < length ([w]) \\<and>\n                path A [] p1 \\<and>\n                path B [] p2 \\<and>\n                succ A w p1 = {} \\<and>\n                succ B w p2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  ws = []\n  r1s = []\n  r2s = []\n\ngoal (1 subgoal):\n 1. target ([w] || [r1] || [r2]) (p1, p2) = FAIL \\<and>\n    0 < length [w] \\<and>\n    path A [] p1 \\<and>\n    path B [] p2 \\<and> succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "using fail_prop"], ["proof (prove)\nusing this:\n  ws = []\n  r1s = []\n  r2s = []\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. target ([w] || [r1] || [r2]) (p1, p2) = FAIL \\<and>\n    0 < length [w] \\<and>\n    path A [] p1 \\<and>\n    path B [] p2 \\<and> succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  target ([w] || [r1] || [r2]) (p1, p2) = FAIL \\<and>\n  0 < length [w] \\<and>\n  path A [] p1 \\<and>\n  path B [] p2 \\<and> succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n             0 < length (w # ws) \\<and>\n             path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n             path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n             succ A (last (w # ws))\n              (target (butlast (w # ws || r1 # r1s)) p1) =\n             {} \\<and>\n             succ B (last (w # ws))\n              (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n             {};\n     length ws = 0\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  target ([w] || [r1] || [r2]) (p1, p2) = FAIL \\<and>\n  0 < length [w] \\<and>\n  path A [] p1 \\<and>\n  path B [] p2 \\<and> succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "have \"fst w \\<in> inputs B \\<and> snd w \\<in> outputs B\""], ["proof (prove)\nusing this:\n  target ([w] || [r1] || [r2]) (p1, p2) = FAIL \\<and>\n  0 < length [w] \\<and>\n  path A [] p1 \\<and>\n  path B [] p2 \\<and> succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fst w \\<in> inputs B \\<and> snd w \\<in> outputs B", "using Cons.prems"], ["proof (prove)\nusing this:\n  target ([w] || [r1] || [r2]) (p1, p2) = FAIL \\<and>\n  0 < length [w] \\<and>\n  path A [] p1 \\<and>\n  path B [] p2 \\<and> succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. fst w \\<in> inputs B \\<and> snd w \\<in> outputs B", "by (metis prod.collapse well_formed.elims(2))"], ["proof (state)\nthis:\n  fst w \\<in> inputs B \\<and> snd w \\<in> outputs B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n             0 < length (w # ws) \\<and>\n             path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n             path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n             succ A (last (w # ws))\n              (target (butlast (w # ws || r1 # r1s)) p1) =\n             {} \\<and>\n             succ B (last (w # ws))\n              (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n             {};\n     length ws = 0\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  fst w \\<in> inputs B \\<and> snd w \\<in> outputs B", "have inputs_0 : \"fst w \\<in> inputs A \\<and> snd w \\<in> outputs B\""], ["proof (prove)\nusing this:\n  fst w \\<in> inputs B \\<and> snd w \\<in> outputs B\n\ngoal (1 subgoal):\n 1. fst w \\<in> inputs A \\<and> snd w \\<in> outputs B", "using Cons.prems"], ["proof (prove)\nusing this:\n  fst w \\<in> inputs B \\<and> snd w \\<in> outputs B\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. fst w \\<in> inputs A \\<and> snd w \\<in> outputs B", "by auto"], ["proof (state)\nthis:\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n             0 < length (w # ws) \\<and>\n             path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n             path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n             succ A (last (w # ws))\n              (target (butlast (w # ws || r1 # r1s)) p1) =\n             {} \\<and>\n             succ B (last (w # ws))\n              (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n             {};\n     length ws = 0\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "moreover"], ["proof (state)\nthis:\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n             0 < length (w # ws) \\<and>\n             path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n             path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n             succ A (last (w # ws))\n              (target (butlast (w # ws || r1 # r1s)) p1) =\n             {} \\<and>\n             succ B (last (w # ws))\n              (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n             {};\n     length ws = 0\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "have fail_elems_0 : \"(r1,r2) = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r1, r2) = FAIL", "using fail_prop"], ["proof (prove)\nusing this:\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (r1, r2) = FAIL", "by auto"], ["proof (state)\nthis:\n  (r1, r2) = FAIL\n\ngoal (2 subgoals):\n 1. \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n             0 < length (w # ws) \\<and>\n             path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n             path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n             succ A (last (w # ws))\n              (target (butlast (w # ws || r1 # r1s)) p1) =\n             {} \\<and>\n             succ B (last (w # ws))\n              (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n             {};\n     length ws = 0\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "ultimately"], ["proof (chain)\npicking this:\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs B\n  (r1, r2) = FAIL", "have \"succ AB w (p1,p2) = {FAIL}\""], ["proof (prove)\nusing this:\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs B\n  (r1, r2) = FAIL\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = {FAIL}", "using fail_prop_0 Cons.prems"], ["proof (prove)\nusing this:\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs B\n  (r1, r2) = FAIL\n  target ([w] || [r1] || [r2]) (p1, p2) = FAIL \\<and>\n  0 < length [w] \\<and>\n  path A [] p1 \\<and>\n  path B [] p2 \\<and> succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = {FAIL}", "by auto"], ["proof (state)\nthis:\n  succ AB w (p1, p2) = {FAIL}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n             0 < length (w # ws) \\<and>\n             path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n             path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n             succ A (last (w # ws))\n              (target (butlast (w # ws || r1 # r1s)) p1) =\n             {} \\<and>\n             succ B (last (w # ws))\n              (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n             {};\n     length ws = 0\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  succ AB w (p1, p2) = {FAIL}", "have \"path AB ( [w] || [r1] || [r2]) (p1, p2)\""], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) = {FAIL}\n\ngoal (1 subgoal):\n 1. path AB ([w] || [r1] || [r2]) (p1, p2)", "using Cons.prems fail_elems_0"], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) = {FAIL}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  (r1, r2) = FAIL\n\ngoal (1 subgoal):\n 1. path AB ([w] || [r1] || [r2]) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB ([w] || [r1] || [r2]) (p1, p2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n             0 < length (w # ws) \\<and>\n             path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n             path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n             succ A (last (w # ws))\n              (target (butlast (w # ws || r1 # r1s)) p1) =\n             {} \\<and>\n             succ B (last (w # ws))\n              (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n             {};\n     length ws = 0\\<rbrakk>\n    \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n 2. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  path AB ([w] || [r1] || [r2]) (p1, p2)", "show ?thesis"], ["proof (prove)\nusing this:\n  path AB ([w] || [r1] || [r2]) (p1, p2)\n\ngoal (1 subgoal):\n 1. path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "case (Suc nat)"], ["proof (state)\nthis:\n  length ws = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  length ws = Suc nat", "have path_r1 : \"path A ([w] || [r1]) p1\""], ["proof (prove)\nusing this:\n  length ws = Suc nat\n\ngoal (1 subgoal):\n 1. path A ([w] || [r1]) p1", "using fail_prop"], ["proof (prove)\nusing this:\n  length ws = Suc nat\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. path A ([w] || [r1]) p1", "by (metis Cons.hyps(1) FSM.nil FSM.path.intros(2) FSM.path_cons_elim Suc_neq_Zero \n            butlast.simps(2) length_0_conv zip_Cons_Cons zip_Nil zip_eq)"], ["proof (state)\nthis:\n  path A ([w] || [r1]) p1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  path A ([w] || [r1]) p1", "have path_r1s : \"path A (butlast (ws || r1s)) r1\""], ["proof (prove)\nusing this:\n  path A ([w] || [r1]) p1\n\ngoal (1 subgoal):\n 1. path A (butlast (ws || r1s)) r1", "using Suc"], ["proof (prove)\nusing this:\n  path A ([w] || [r1]) p1\n  length ws = Suc nat\n\ngoal (1 subgoal):\n 1. path A (butlast (ws || r1s)) r1", "by (metis (no_types, lifting) Cons.hyps(1) FSM.path_cons_elim Suc_neq_Zero butlast.simps(2) \n            fail_prop length_0_conv snd_conv zip.simps(1) zip_Cons_Cons zip_eq)"], ["proof (state)\nthis:\n  path A (butlast (ws || r1s)) r1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "have path_r2 : \"path B ([w] || [r2]) p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path B ([w] || [r2]) p2", "using Suc fail_prop"], ["proof (prove)\nusing this:\n  length ws = Suc nat\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. path B ([w] || [r2]) p2", "by (metis Cons.hyps(1) Cons.hyps(2) FSM.nil FSM.path.intros(2) FSM.path_cons_elim \n            Suc_neq_Zero butlast.simps(2) length_0_conv zip_Cons_Cons zip_Nil zip_eq)"], ["proof (state)\nthis:\n  path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  path B ([w] || [r2]) p2", "have path_r2s : \"path B (butlast (ws || r2s)) r2\""], ["proof (prove)\nusing this:\n  path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. path B (butlast (ws || r2s)) r2", "using Suc"], ["proof (prove)\nusing this:\n  path B ([w] || [r2]) p2\n  length ws = Suc nat\n\ngoal (1 subgoal):\n 1. path B (butlast (ws || r2s)) r2", "by (metis (no_types, lifting) Cons.hyps(1) Cons.hyps(2) FSM.path_cons_elim Suc_neq_Zero \n            butlast.simps(2) fail_prop length_0_conv snd_conv zip.simps(1) zip_Cons_Cons zip_eq)"], ["proof (state)\nthis:\n  path B (butlast (ws || r2s)) r2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "have \"target (ws || r1s || r2s) (r1, r2) = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (ws || r1s || r2s) (r1, r2) = FAIL", "using fail_prop"], ["proof (prove)\nusing this:\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. target (ws || r1s || r2s) (r1, r2) = FAIL", "by auto"], ["proof (state)\nthis:\n  target (ws || r1s || r2s) (r1, r2) = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "moreover"], ["proof (state)\nthis:\n  target (ws || r1s || r2s) (r1, r2) = FAIL\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "have \"r1 \\<in> nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1 \\<in> nodes A", "using Cons.prems path_r1"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  path A ([w] || [r1]) p1\n\ngoal (1 subgoal):\n 1. r1 \\<in> nodes A", "by (metis FSM.path_cons_elim snd_conv succ_nodes zip_Cons_Cons)"], ["proof (state)\nthis:\n  r1 \\<in> nodes A\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "moreover"], ["proof (state)\nthis:\n  r1 \\<in> nodes A\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "have \"r2 \\<in> nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2 \\<in> nodes B", "using Cons.prems path_r2"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. r2 \\<in> nodes B", "by (metis FSM.path_cons_elim snd_conv succ_nodes zip_Cons_Cons)"], ["proof (state)\nthis:\n  r2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "moreover"], ["proof (state)\nthis:\n  r2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "have \"succ A (last ws) (target (butlast (ws || r1s)) r1) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ A (last ws) (target (butlast (ws || r1s)) r1) = {}", "by (metis (no_types, lifting) Cons.hyps(1) Suc Suc_neq_Zero butlast.simps(2) fail_prop \n            fold_simps(2) last_ConsR list.size(3) snd_conv zip_Cons_Cons zip_Nil zip_eq)"], ["proof (state)\nthis:\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "moreover"], ["proof (state)\nthis:\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "have \"succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}", "by (metis (no_types, lifting) Cons.hyps(1) Cons.hyps(2) Suc Suc_neq_Zero butlast.simps(2) \n            fail_prop fold_simps(2) last_ConsR list.size(3) snd_conv zip_Cons_Cons zip_Nil zip_eq)"], ["proof (state)\nthis:\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "have \"path AB (ws || r1s || r2s) (r1, r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB (ws || r1s || r2s) (r1, r2)", "using Cons.IH Suc \\<open>succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\\<close> \n              assms(3) assms(4) assms(5) calculation(1-4) path_r1s path_r2s zero_less_Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path A (ws || r1s) ?p1.0 \\<and> path B (ws || r2s) ?p2.0 \\<or>\n   target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n   0 < length ws \\<and>\n   path A (butlast (ws || r1s)) ?p1.0 \\<and>\n   path B (butlast (ws || r2s)) ?p2.0 \\<and>\n   succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) = {} \\<and>\n   succ B (last ws) (target (butlast (ws || r2s)) ?p2.0) \\<noteq> {};\n   ?p1.0 \\<in> nodes A; ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (ws || r1s || r2s) (?p1.0, ?p2.0)\n  length ws = Suc nat\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  target (ws || r1s || r2s) (r1, r2) = FAIL\n  r1 \\<in> nodes A\n  r2 \\<in> nodes B\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {}\n  path A (butlast (ws || r1s)) r1\n  path B (butlast (ws || r2s)) r2\n  0 < Suc ?n\n\ngoal (1 subgoal):\n 1. path AB (ws || r1s || r2s) (r1, r2)", "by presburger"], ["proof (state)\nthis:\n  path AB (ws || r1s || r2s) (r1, r2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "moreover"], ["proof (state)\nthis:\n  path AB (ws || r1s || r2s) (r1, r2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "have \"path AB ([w] || [r1] || [r2]) (p1,p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB ([w] || [r1] || [r2]) (p1, p2)", "using path_r1 path_r2 productF_path_inclusion[of \"[w]\" \"[r1]\" \"[r2]\" A B FAIL AB p1 p2] \n              Cons.prems"], ["proof (prove)\nusing this:\n  path A ([w] || [r1]) p1\n  path B ([w] || [r2]) p2\n  \\<lbrakk>length [w] = length [r1]; length [r1] = length [r2];\n   productF A B FAIL AB; well_formed A; well_formed B;\n   path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2; p1 \\<in> nodes A;\n   p2 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB ([w] || [r1] || [r2]) (p1, p2)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB ([w] || [r1] || [r2]) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB ([w] || [r1] || [r2]) (p1, p2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                FAIL \\<and>\n                0 < length (w # ws) \\<and>\n                path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                succ A (last (w # ws))\n                 (target (butlast (w # ws || r1 # r1s)) p1) =\n                {} \\<and>\n                succ B (last (w # ws))\n                 (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                {};\n        length ws = Suc nat\\<rbrakk>\n       \\<Longrightarrow> path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "ultimately"], ["proof (chain)\npicking this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL\n  r1 \\<in> nodes A\n  r2 \\<in> nodes B\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {}\n  path AB (ws || r1s || r2s) (r1, r2)\n  path AB ([w] || [r1] || [r2]) (p1, p2)", "show ?thesis"], ["proof (prove)\nusing this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL\n  r1 \\<in> nodes A\n  r2 \\<in> nodes B\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {}\n  path AB (ws || r1s || r2s) (r1, r2)\n  path AB ([w] || [r1] || [r2]) (p1, p2)\n\ngoal (1 subgoal):\n 1. path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma butlast_zip_cons : \"length ws = length r1s \\<Longrightarrow> ws \\<noteq> [] \n                            \\<Longrightarrow> butlast (w # ws || r1 # r1s) = ((w,r1) # (butlast (ws || r1s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; ws \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> butlast (w # ws || r1 # r1s) =\n                      (w, r1) # butlast (ws || r1s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; ws \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> butlast (w # ws || r1 # r1s) =\n                      (w, r1) # butlast (ws || r1s)", "assume a1: \"length ws = length r1s\""], ["proof (state)\nthis:\n  length ws = length r1s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; ws \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> butlast (w # ws || r1 # r1s) =\n                      (w, r1) # butlast (ws || r1s)", "assume a2: \"ws \\<noteq> []\""], ["proof (state)\nthis:\n  ws \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; ws \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> butlast (w # ws || r1 # r1s) =\n                      (w, r1) # butlast (ws || r1s)", "have \"length (w # ws) = length r1s + Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (w # ws) = length r1s + Suc 0", "using a1"], ["proof (prove)\nusing this:\n  length ws = length r1s\n\ngoal (1 subgoal):\n 1. length (w # ws) = length r1s + Suc 0", "by (metis list.size(4))"], ["proof (state)\nthis:\n  length (w # ws) = length r1s + Suc 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; ws \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> butlast (w # ws || r1 # r1s) =\n                      (w, r1) # butlast (ws || r1s)", "then"], ["proof (chain)\npicking this:\n  length (w # ws) = length r1s + Suc 0", "have f3: \"length (w # ws) = length (r1 # r1s)\""], ["proof (prove)\nusing this:\n  length (w # ws) = length r1s + Suc 0\n\ngoal (1 subgoal):\n 1. length (w # ws) = length (r1 # r1s)", "by (metis list.size(4))"], ["proof (state)\nthis:\n  length (w # ws) = length (r1 # r1s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; ws \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> butlast (w # ws || r1 # r1s) =\n                      (w, r1) # butlast (ws || r1s)", "have f4: \"ws @ w # ws \\<noteq> w # ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws @ w # ws \\<noteq> w # ws", "using a2"], ["proof (prove)\nusing this:\n  ws \\<noteq> []\n\ngoal (1 subgoal):\n 1. ws @ w # ws \\<noteq> w # ws", "by (meson append_self_conv2)"], ["proof (state)\nthis:\n  ws @ w # ws \\<noteq> w # ws\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; ws \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> butlast (w # ws || r1 # r1s) =\n                      (w, r1) # butlast (ws || r1s)", "have \"length (ws @ w # ws) = length (r1s @ r1 # r1s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ws @ w # ws) = length (r1s @ r1 # r1s)", "using a1"], ["proof (prove)\nusing this:\n  length ws = length r1s\n\ngoal (1 subgoal):\n 1. length (ws @ w # ws) = length (r1s @ r1 # r1s)", "by auto"], ["proof (state)\nthis:\n  length (ws @ w # ws) = length (r1s @ r1 # r1s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; ws \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> butlast (w # ws || r1 # r1s) =\n                      (w, r1) # butlast (ws || r1s)", "then"], ["proof (chain)\npicking this:\n  length (ws @ w # ws) = length (r1s @ r1 # r1s)", "have \"ws @ w # ws || r1s @ r1 # r1s \\<noteq> w # ws || r1 # r1s\""], ["proof (prove)\nusing this:\n  length (ws @ w # ws) = length (r1s @ r1 # r1s)\n\ngoal (1 subgoal):\n 1. ws @ w # ws || r1s @ r1 # r1s \\<noteq> w # ws || r1 # r1s", "using f4 f3"], ["proof (prove)\nusing this:\n  length (ws @ w # ws) = length (r1s @ r1 # r1s)\n  ws @ w # ws \\<noteq> w # ws\n  length (w # ws) = length (r1 # r1s)\n\ngoal (1 subgoal):\n 1. ws @ w # ws || r1s @ r1 # r1s \\<noteq> w # ws || r1 # r1s", "by (meson zip_eq)"], ["proof (state)\nthis:\n  ws @ w # ws || r1s @ r1 # r1s \\<noteq> w # ws || r1 # r1s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length ws = length r1s; ws \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> butlast (w # ws || r1 # r1s) =\n                      (w, r1) # butlast (ws || r1s)", "then"], ["proof (chain)\npicking this:\n  ws @ w # ws || r1s @ r1 # r1s \\<noteq> w # ws || r1 # r1s", "show ?thesis"], ["proof (prove)\nusing this:\n  ws @ w # ws || r1s @ r1 # r1s \\<noteq> w # ws || r1 # r1s\n\ngoal (1 subgoal):\n 1. butlast (w # ws || r1 # r1s) = (w, r1) # butlast (ws || r1s)", "using a1"], ["proof (prove)\nusing this:\n  ws @ w # ws || r1s @ r1 # r1s \\<noteq> w # ws || r1 # r1s\n  length ws = length r1s\n\ngoal (1 subgoal):\n 1. butlast (w # ws || r1 # r1s) = (w, r1) # butlast (ws || r1s)", "by simp"], ["proof (state)\nthis:\n  butlast (w # ws || r1 # r1s) = (w, r1) # butlast (ws || r1s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma productF_succ_fail_imp : \n  assumes \"productF A B FAIL AB\"\n  and     \"FAIL \\<in> succ AB w (p1,p2)\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\nshows \"p1 \\<in> nodes A \\<and> p2 \\<in> nodes B \\<and> (fst w \\<in> inputs A) \\<and> (snd w \\<in> outputs A \\<union> outputs B) \n        \\<and> succ AB w (p1,p2) = {FAIL} \\<and> succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "have path_head : \"path AB ([w] || [FAIL]) (p1,p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB ([w] || [FAIL]) (p1, p2)", "using assms"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  FAIL \\<in> succ AB w (p1, p2)\n  well_formed A\n  well_formed B\n\ngoal (1 subgoal):\n 1. path AB ([w] || [FAIL]) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB ([w] || [FAIL]) (p1, p2)\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  path AB ([w] || [FAIL]) (p1, p2)", "have succ_nonempty : \"succ AB w (p1,p2) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  path AB ([w] || [FAIL]) (p1, p2)\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) \\<noteq> {}", "by force"], ["proof (state)\nthis:\n  succ AB w (p1, p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  succ AB w (p1, p2) \\<noteq> {}", "have succ_if_1 : \"p1 \\<in> nodes A \\<and> p2 \\<in> nodes B \\<and> (fst w \\<in> inputs A) \n                            \\<and> (snd w \\<in> outputs A \\<union> outputs B)\""], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B", "using assms"], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) \\<noteq> {}\n  productF A B FAIL AB\n  FAIL \\<in> succ AB w (p1, p2)\n  well_formed A\n  well_formed B\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B", "by auto"], ["proof (state)\nthis:\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B", "have \"(p1,p2) \\<noteq> FAIL\""], ["proof (prove)\nusing this:\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n\ngoal (1 subgoal):\n 1. (p1, p2) \\<noteq> FAIL", "using assms"], ["proof (prove)\nusing this:\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n  productF A B FAIL AB\n  FAIL \\<in> succ AB w (p1, p2)\n  well_formed A\n  well_formed B\n\ngoal (1 subgoal):\n 1. (p1, p2) \\<noteq> FAIL", "by auto"], ["proof (state)\nthis:\n  (p1, p2) \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "have \"succ A w p1 \\<subseteq> nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ A w p1 \\<subseteq> nodes A", "using assms succ_if_1"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  FAIL \\<in> succ AB w (p1, p2)\n  well_formed A\n  well_formed B\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n\ngoal (1 subgoal):\n 1. succ A w p1 \\<subseteq> nodes A", "by (simp add: subsetI succ_nodes)"], ["proof (state)\nthis:\n  succ A w p1 \\<subseteq> nodes A\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  succ A w p1 \\<subseteq> nodes A\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "have \"succ B w p2 \\<subseteq> nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ B w p2 \\<subseteq> nodes B", "using assms succ_if_1"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  FAIL \\<in> succ AB w (p1, p2)\n  well_formed A\n  well_formed B\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n\ngoal (1 subgoal):\n 1. succ B w p2 \\<subseteq> nodes B", "by (simp add: subsetI succ_nodes)"], ["proof (state)\nthis:\n  succ B w p2 \\<subseteq> nodes B\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  succ A w p1 \\<subseteq> nodes A\n  succ B w p2 \\<subseteq> nodes B", "have \"FAIL \\<notin> (succ A w p1 \\<times> succ B w p2)\""], ["proof (prove)\nusing this:\n  succ A w p1 \\<subseteq> nodes A\n  succ B w p2 \\<subseteq> nodes B\n\ngoal (1 subgoal):\n 1. FAIL \\<notin> succ A w p1 \\<times> succ B w p2", "using assms"], ["proof (prove)\nusing this:\n  succ A w p1 \\<subseteq> nodes A\n  succ B w p2 \\<subseteq> nodes B\n  productF A B FAIL AB\n  FAIL \\<in> succ AB w (p1, p2)\n  well_formed A\n  well_formed B\n\ngoal (1 subgoal):\n 1. FAIL \\<notin> succ A w p1 \\<times> succ B w p2", "by auto"], ["proof (state)\nthis:\n  FAIL \\<notin> succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  FAIL \\<notin> succ A w p1 \\<times> succ B w p2", "have succ_no_inclusion : \"succ AB w (p1,p2) \\<noteq> (succ A w p1 \\<times> succ B w p2)\""], ["proof (prove)\nusing this:\n  FAIL \\<notin> succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) \\<noteq> succ A w p1 \\<times> succ B w p2", "using assms succ_if_1"], ["proof (prove)\nusing this:\n  FAIL \\<notin> succ A w p1 \\<times> succ B w p2\n  productF A B FAIL AB\n  FAIL \\<in> succ AB w (p1, p2)\n  well_formed A\n  well_formed B\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) \\<noteq> succ A w p1 \\<times> succ B w p2", "by blast"], ["proof (state)\nthis:\n  succ AB w (p1, p2) \\<noteq> succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "moreover"], ["proof (state)\nthis:\n  succ AB w (p1, p2) \\<noteq> succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "have \"succ AB w (p1,p2) = {} \\<or> succ AB w (p1,p2) = {FAIL} \n                  \\<or> succ AB w (p1,p2) = (succ A w p1 \\<times> succ B w p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = {} \\<or>\n    succ AB w (p1, p2) = {FAIL} \\<or>\n    succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2", "using assms"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  FAIL \\<in> succ AB w (p1, p2)\n  well_formed A\n  well_formed B\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = {} \\<or>\n    succ AB w (p1, p2) = {FAIL} \\<or>\n    succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2", "by simp"], ["proof (state)\nthis:\n  succ AB w (p1, p2) = {} \\<or>\n  succ AB w (p1, p2) = {FAIL} \\<or>\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "ultimately"], ["proof (chain)\npicking this:\n  succ AB w (p1, p2) \\<noteq> succ A w p1 \\<times> succ B w p2\n  succ AB w (p1, p2) = {} \\<or>\n  succ AB w (p1, p2) = {FAIL} \\<or>\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2", "have succ_fail : \"succ AB w (p1,p2) = {FAIL}\""], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) \\<noteq> succ A w p1 \\<times> succ B w p2\n  succ AB w (p1, p2) = {} \\<or>\n  succ AB w (p1, p2) = {FAIL} \\<or>\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = {FAIL}", "using succ_nonempty"], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) \\<noteq> succ A w p1 \\<times> succ B w p2\n  succ AB w (p1, p2) = {} \\<or>\n  succ AB w (p1, p2) = {FAIL} \\<or>\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2\n  succ AB w (p1, p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = {FAIL}", "by simp"], ["proof (state)\nthis:\n  succ AB w (p1, p2) = {FAIL}\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "have \"succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (succ A w p1 = {} \\<and>\n            succ B w p2 \\<noteq> {}) \\<Longrightarrow>\n    False", "assume \"\\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\""], ["proof (state)\nthis:\n  \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<not> (succ A w p1 = {} \\<and>\n            succ B w p2 \\<noteq> {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})", "have \"succ AB w (p1,p2) = (succ A w p1 \\<times> succ B w p2)\""], ["proof (prove)\nusing this:\n  \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2", "using assms"], ["proof (prove)\nusing this:\n  \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\n  productF A B FAIL AB\n  FAIL \\<in> succ AB w (p1, p2)\n  well_formed A\n  well_formed B\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2", "by auto"], ["proof (state)\nthis:\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. \\<not> (succ A w p1 = {} \\<and>\n            succ B w p2 \\<noteq> {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2", "show \"False\""], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. False", "using succ_no_inclusion"], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2\n  succ AB w (p1, p2) \\<noteq> succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "using succ_if_1 succ_fail"], ["proof (prove)\nusing this:\n  succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n  succ AB w (p1, p2) = {FAIL}\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and>\n    snd w \\<in> outputs A \\<union> outputs B \\<and>\n    succ AB w (p1, p2) = {FAIL} \\<and>\n    succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and>\n  snd w \\<in> outputs A \\<union> outputs B \\<and>\n  succ AB w (p1, p2) = {FAIL} \\<and>\n  succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma productF_path_reverse :\n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"path AB (w || r1 || r2) (p1, p2)\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\nshows \"(path A (w || r1) p1 \\<and> path B (w || r2) p2) \n            \\<or> (target (w || r1 || r2) (p1, p2) = FAIL\n              \\<and> length w > 0\n              \\<and> path A (butlast (w || r1)) p1\n              \\<and> path B (butlast (w || r2)) p2\n              \\<and> succ A (last w) (target (butlast (w || r1)) p1) = {}\n              \\<and> succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w || r1 || r2) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "proof (induction w r1 r2 arbitrary: p1 p2 rule: list_induct3)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p1 p2.\n       \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n        path AB ([] || [] || []) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A ([] || []) p1 \\<and>\n                         path B ([] || []) p2 \\<or>\n                         target ([] || [] || []) (p1, p2) = FAIL \\<and>\n                         0 < length [] \\<and>\n                         path A (butlast ([] || [])) p1 \\<and>\n                         path B (butlast ([] || [])) p2 \\<and>\n                         succ A (last []) (target (butlast ([] || [])) p1) =\n                         {} \\<and>\n                         succ B (last [])\n                          (target (butlast ([] || [])) p2) \\<noteq>\n                         {}\n 2. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path AB (xs || ys || zs) (p1, p2); p1 \\<in> nodes A;\n            p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path A (xs || ys) p1 \\<and>\n                             path B (xs || zs) p2 \\<or>\n                             target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n                             0 < length xs \\<and>\n                             path A (butlast (xs || ys)) p1 \\<and>\n                             path B (butlast (xs || zs)) p2 \\<and>\n                             succ A (last xs)\n                              (target (butlast (xs || ys)) p1) =\n                             {} \\<and>\n                             succ B (last xs)\n                              (target (butlast (xs || zs)) p2) \\<noteq>\n                             {};\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path AB (x # xs || y # ys || z # zs) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A (x # xs || y # ys) p1 \\<and>\n                         path B (x # xs || z # zs) p2 \\<or>\n                         target (x # xs || y # ys || z # zs) (p1, p2) =\n                         FAIL \\<and>\n                         0 < length (x # xs) \\<and>\n                         path A (butlast (x # xs || y # ys)) p1 \\<and>\n                         path B (butlast (x # xs || z # zs)) p2 \\<and>\n                         succ A (last (x # xs))\n                          (target (butlast (x # xs || y # ys)) p1) =\n                         {} \\<and>\n                         succ B (last (x # xs))\n                          (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n                         {}", "case Nil"], ["proof (state)\nthis:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB ([] || [] || []) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (2 subgoals):\n 1. \\<And>p1 p2.\n       \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n        path AB ([] || [] || []) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A ([] || []) p1 \\<and>\n                         path B ([] || []) p2 \\<or>\n                         target ([] || [] || []) (p1, p2) = FAIL \\<and>\n                         0 < length [] \\<and>\n                         path A (butlast ([] || [])) p1 \\<and>\n                         path B (butlast ([] || [])) p2 \\<and>\n                         succ A (last []) (target (butlast ([] || [])) p1) =\n                         {} \\<and>\n                         succ B (last [])\n                          (target (butlast ([] || [])) p2) \\<noteq>\n                         {}\n 2. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path AB (xs || ys || zs) (p1, p2); p1 \\<in> nodes A;\n            p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path A (xs || ys) p1 \\<and>\n                             path B (xs || zs) p2 \\<or>\n                             target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n                             0 < length xs \\<and>\n                             path A (butlast (xs || ys)) p1 \\<and>\n                             path B (butlast (xs || zs)) p2 \\<and>\n                             succ A (last xs)\n                              (target (butlast (xs || ys)) p1) =\n                             {} \\<and>\n                             succ B (last xs)\n                              (target (butlast (xs || zs)) p2) \\<noteq>\n                             {};\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path AB (x # xs || y # ys || z # zs) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A (x # xs || y # ys) p1 \\<and>\n                         path B (x # xs || z # zs) p2 \\<or>\n                         target (x # xs || y # ys || z # zs) (p1, p2) =\n                         FAIL \\<and>\n                         0 < length (x # xs) \\<and>\n                         path A (butlast (x # xs || y # ys)) p1 \\<and>\n                         path B (butlast (x # xs || z # zs)) p2 \\<and>\n                         succ A (last (x # xs))\n                          (target (butlast (x # xs || y # ys)) p1) =\n                         {} \\<and>\n                         succ B (last (x # xs))\n                          (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n                         {}", "then"], ["proof (chain)\npicking this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB ([] || [] || []) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B", "show ?case"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB ([] || [] || []) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path A ([] || []) p1 \\<and> path B ([] || []) p2 \\<or>\n    target ([] || [] || []) (p1, p2) = FAIL \\<and>\n    0 < length [] \\<and>\n    path A (butlast ([] || [])) p1 \\<and>\n    path B (butlast ([] || [])) p2 \\<and>\n    succ A (last []) (target (butlast ([] || [])) p1) = {} \\<and>\n    succ B (last []) (target (butlast ([] || [])) p2) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  path A ([] || []) p1 \\<and> path B ([] || []) p2 \\<or>\n  target ([] || [] || []) (p1, p2) = FAIL \\<and>\n  0 < length [] \\<and>\n  path A (butlast ([] || [])) p1 \\<and>\n  path B (butlast ([] || [])) p2 \\<and>\n  succ A (last []) (target (butlast ([] || [])) p1) = {} \\<and>\n  succ B (last []) (target (butlast ([] || [])) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path AB (xs || ys || zs) (p1, p2); p1 \\<in> nodes A;\n            p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path A (xs || ys) p1 \\<and>\n                             path B (xs || zs) p2 \\<or>\n                             target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n                             0 < length xs \\<and>\n                             path A (butlast (xs || ys)) p1 \\<and>\n                             path B (butlast (xs || zs)) p2 \\<and>\n                             succ A (last xs)\n                              (target (butlast (xs || ys)) p1) =\n                             {} \\<and>\n                             succ B (last xs)\n                              (target (butlast (xs || zs)) p2) \\<noteq>\n                             {};\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path AB (x # xs || y # ys || z # zs) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A (x # xs || y # ys) p1 \\<and>\n                         path B (x # xs || z # zs) p2 \\<or>\n                         target (x # xs || y # ys || z # zs) (p1, p2) =\n                         FAIL \\<and>\n                         0 < length (x # xs) \\<and>\n                         path A (butlast (x # xs || y # ys)) p1 \\<and>\n                         path B (butlast (x # xs || z # zs)) p2 \\<and>\n                         succ A (last (x # xs))\n                          (target (butlast (x # xs || y # ys)) p1) =\n                         {} \\<and>\n                         succ B (last (x # xs))\n                          (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n                         {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path AB (xs || ys || zs) (p1, p2); p1 \\<in> nodes A;\n            p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path A (xs || ys) p1 \\<and>\n                             path B (xs || zs) p2 \\<or>\n                             target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n                             0 < length xs \\<and>\n                             path A (butlast (xs || ys)) p1 \\<and>\n                             path B (butlast (xs || zs)) p2 \\<and>\n                             succ A (last xs)\n                              (target (butlast (xs || ys)) p1) =\n                             {} \\<and>\n                             succ B (last xs)\n                              (target (butlast (xs || zs)) p2) \\<noteq>\n                             {};\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path AB (x # xs || y # ys || z # zs) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A (x # xs || y # ys) p1 \\<and>\n                         path B (x # xs || z # zs) p2 \\<or>\n                         target (x # xs || y # ys || z # zs) (p1, p2) =\n                         FAIL \\<and>\n                         0 < length (x # xs) \\<and>\n                         path A (butlast (x # xs || y # ys)) p1 \\<and>\n                         path B (butlast (x # xs || z # zs)) p2 \\<and>\n                         succ A (last (x # xs))\n                          (target (butlast (x # xs || y # ys)) p1) =\n                         {} \\<and>\n                         succ B (last (x # xs))\n                          (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n                         {}", "case (Cons w ws r1 r1s r2 r2s)"], ["proof (state)\nthis:\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (?p1.0, ?p2.0); ?p1.0 \\<in> nodes A;\n   ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) ?p1.0 \\<and>\n                    path B (ws || r2s) ?p2.0 \\<or>\n                    target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) ?p1.0 \\<and>\n                    path B (butlast (ws || r2s)) ?p2.0 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) ?p2.0) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path AB (xs || ys || zs) (p1, p2); p1 \\<in> nodes A;\n            p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path A (xs || ys) p1 \\<and>\n                             path B (xs || zs) p2 \\<or>\n                             target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n                             0 < length xs \\<and>\n                             path A (butlast (xs || ys)) p1 \\<and>\n                             path B (butlast (xs || zs)) p2 \\<and>\n                             succ A (last xs)\n                              (target (butlast (xs || ys)) p1) =\n                             {} \\<and>\n                             succ B (last xs)\n                              (target (butlast (xs || zs)) p2) \\<noteq>\n                             {};\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path AB (x # xs || y # ys || z # zs) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A (x # xs || y # ys) p1 \\<and>\n                         path B (x # xs || z # zs) p2 \\<or>\n                         target (x # xs || y # ys || z # zs) (p1, p2) =\n                         FAIL \\<and>\n                         0 < length (x # xs) \\<and>\n                         path A (butlast (x # xs || y # ys)) p1 \\<and>\n                         path B (butlast (x # xs || z # zs)) p2 \\<and>\n                         succ A (last (x # xs))\n                          (target (butlast (x # xs || y # ys)) p1) =\n                         {} \\<and>\n                         succ B (last (x # xs))\n                          (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n                         {}", "have path_head : \"path AB ([w] || [(r1,r2)]) (p1,p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB ([w] || [(r1, r2)]) (p1, p2)", "using Cons"], ["proof (prove)\nusing this:\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (?p1.0, ?p2.0); ?p1.0 \\<in> nodes A;\n   ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) ?p1.0 \\<and>\n                    path B (ws || r2s) ?p2.0 \\<or>\n                    target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) ?p1.0 \\<and>\n                    path B (butlast (ws || r2s)) ?p2.0 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) ?p2.0) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB ([w] || [(r1, r2)]) (p1, p2)", "by auto"], ["proof (state)\nthis:\n  path AB ([w] || [(r1, r2)]) (p1, p2)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path AB (xs || ys || zs) (p1, p2); p1 \\<in> nodes A;\n            p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path A (xs || ys) p1 \\<and>\n                             path B (xs || zs) p2 \\<or>\n                             target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n                             0 < length xs \\<and>\n                             path A (butlast (xs || ys)) p1 \\<and>\n                             path B (butlast (xs || zs)) p2 \\<and>\n                             succ A (last xs)\n                              (target (butlast (xs || ys)) p1) =\n                             {} \\<and>\n                             succ B (last xs)\n                              (target (butlast (xs || zs)) p2) \\<noteq>\n                             {};\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path AB (x # xs || y # ys || z # zs) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A (x # xs || y # ys) p1 \\<and>\n                         path B (x # xs || z # zs) p2 \\<or>\n                         target (x # xs || y # ys || z # zs) (p1, p2) =\n                         FAIL \\<and>\n                         0 < length (x # xs) \\<and>\n                         path A (butlast (x # xs || y # ys)) p1 \\<and>\n                         path B (butlast (x # xs || z # zs)) p2 \\<and>\n                         succ A (last (x # xs))\n                          (target (butlast (x # xs || y # ys)) p1) =\n                         {} \\<and>\n                         succ B (last (x # xs))\n                          (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n                         {}", "then"], ["proof (chain)\npicking this:\n  path AB ([w] || [(r1, r2)]) (p1, p2)", "have succ_nonempty : \"succ AB w (p1,p2) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  path AB ([w] || [(r1, r2)]) (p1, p2)\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) \\<noteq> {}", "by force"], ["proof (state)\nthis:\n  succ AB w (p1, p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path AB (xs || ys || zs) (p1, p2); p1 \\<in> nodes A;\n            p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path A (xs || ys) p1 \\<and>\n                             path B (xs || zs) p2 \\<or>\n                             target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n                             0 < length xs \\<and>\n                             path A (butlast (xs || ys)) p1 \\<and>\n                             path B (butlast (xs || zs)) p2 \\<and>\n                             succ A (last xs)\n                              (target (butlast (xs || ys)) p1) =\n                             {} \\<and>\n                             succ B (last xs)\n                              (target (butlast (xs || zs)) p2) \\<noteq>\n                             {};\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path AB (x # xs || y # ys || z # zs) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A (x # xs || y # ys) p1 \\<and>\n                         path B (x # xs || z # zs) p2 \\<or>\n                         target (x # xs || y # ys || z # zs) (p1, p2) =\n                         FAIL \\<and>\n                         0 < length (x # xs) \\<and>\n                         path A (butlast (x # xs || y # ys)) p1 \\<and>\n                         path B (butlast (x # xs || z # zs)) p2 \\<and>\n                         succ A (last (x # xs))\n                          (target (butlast (x # xs || y # ys)) p1) =\n                         {} \\<and>\n                         succ B (last (x # xs))\n                          (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n                         {}", "then"], ["proof (chain)\npicking this:\n  succ AB w (p1, p2) \\<noteq> {}", "have succ_if_1 : \"p1 \\<in> nodes A \\<and> p2 \\<in> nodes B \\<and> (fst w \\<in> inputs A) \n                          \\<and> (snd w \\<in> outputs A \\<union> outputs B)\""], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B", "using Cons"], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) \\<noteq> {}\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (?p1.0, ?p2.0); ?p1.0 \\<in> nodes A;\n   ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) ?p1.0 \\<and>\n                    path B (ws || r2s) ?p2.0 \\<or>\n                    target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) ?p1.0 \\<and>\n                    path B (butlast (ws || r2s)) ?p2.0 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) ?p2.0) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. p1 \\<in> nodes A \\<and>\n    p2 \\<in> nodes B \\<and>\n    fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B", "by fastforce"], ["proof (state)\nthis:\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path AB (xs || ys || zs) (p1, p2); p1 \\<in> nodes A;\n            p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path A (xs || ys) p1 \\<and>\n                             path B (xs || zs) p2 \\<or>\n                             target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n                             0 < length xs \\<and>\n                             path A (butlast (xs || ys)) p1 \\<and>\n                             path B (butlast (xs || zs)) p2 \\<and>\n                             succ A (last xs)\n                              (target (butlast (xs || ys)) p1) =\n                             {} \\<and>\n                             succ B (last xs)\n                              (target (butlast (xs || zs)) p2) \\<noteq>\n                             {};\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path AB (x # xs || y # ys || z # zs) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A (x # xs || y # ys) p1 \\<and>\n                         path B (x # xs || z # zs) p2 \\<or>\n                         target (x # xs || y # ys || z # zs) (p1, p2) =\n                         FAIL \\<and>\n                         0 < length (x # xs) \\<and>\n                         path A (butlast (x # xs || y # ys)) p1 \\<and>\n                         path B (butlast (x # xs || z # zs)) p2 \\<and>\n                         succ A (last (x # xs))\n                          (target (butlast (x # xs || y # ys)) p1) =\n                         {} \\<and>\n                         succ B (last (x # xs))\n                          (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n                         {}", "then"], ["proof (chain)\npicking this:\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B", "have \"(p1,p2) \\<noteq> FAIL\""], ["proof (prove)\nusing this:\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n\ngoal (1 subgoal):\n 1. (p1, p2) \\<noteq> FAIL", "using Cons"], ["proof (prove)\nusing this:\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (?p1.0, ?p2.0); ?p1.0 \\<in> nodes A;\n   ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) ?p1.0 \\<and>\n                    path B (ws || r2s) ?p2.0 \\<or>\n                    target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) ?p1.0 \\<and>\n                    path B (butlast (ws || r2s)) ?p2.0 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) ?p2.0) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. (p1, p2) \\<noteq> FAIL", "by auto"], ["proof (state)\nthis:\n  (p1, p2) \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path AB (xs || ys || zs) (p1, p2); p1 \\<in> nodes A;\n            p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path A (xs || ys) p1 \\<and>\n                             path B (xs || zs) p2 \\<or>\n                             target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n                             0 < length xs \\<and>\n                             path A (butlast (xs || ys)) p1 \\<and>\n                             path B (butlast (xs || zs)) p2 \\<and>\n                             succ A (last xs)\n                              (target (butlast (xs || ys)) p1) =\n                             {} \\<and>\n                             succ B (last xs)\n                              (target (butlast (xs || zs)) p2) \\<noteq>\n                             {};\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path AB (x # xs || y # ys || z # zs) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A (x # xs || y # ys) p1 \\<and>\n                         path B (x # xs || z # zs) p2 \\<or>\n                         target (x # xs || y # ys || z # zs) (p1, p2) =\n                         FAIL \\<and>\n                         0 < length (x # xs) \\<and>\n                         path A (butlast (x # xs || y # ys)) p1 \\<and>\n                         path B (butlast (x # xs || z # zs)) p2 \\<and>\n                         succ A (last (x # xs))\n                          (target (butlast (x # xs || y # ys)) p1) =\n                         {} \\<and>\n                         succ B (last (x # xs))\n                          (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n                         {}", "have path_tail : \"path AB (ws || r1s || r2s) (r1,r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB (ws || r1s || r2s) (r1, r2)", "using path_head Cons"], ["proof (prove)\nusing this:\n  path AB ([w] || [(r1, r2)]) (p1, p2)\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (?p1.0, ?p2.0); ?p1.0 \\<in> nodes A;\n   ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) ?p1.0 \\<and>\n                    path B (ws || r2s) ?p2.0 \\<or>\n                    target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) ?p1.0 \\<and>\n                    path B (butlast (ws || r2s)) ?p2.0 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) ?p2.0) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB (ws || r1s || r2s) (r1, r2)", "by auto"], ["proof (state)\nthis:\n  path AB (ws || r1s || r2s) (r1, r2)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys z zs p1 p2.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        \\<And>p1 p2.\n           \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n            path AB (xs || ys || zs) (p1, p2); p1 \\<in> nodes A;\n            p2 \\<in> nodes B\\<rbrakk>\n           \\<Longrightarrow> path A (xs || ys) p1 \\<and>\n                             path B (xs || zs) p2 \\<or>\n                             target (xs || ys || zs) (p1, p2) = FAIL \\<and>\n                             0 < length xs \\<and>\n                             path A (butlast (xs || ys)) p1 \\<and>\n                             path B (butlast (xs || zs)) p2 \\<and>\n                             succ A (last xs)\n                              (target (butlast (xs || ys)) p1) =\n                             {} \\<and>\n                             succ B (last xs)\n                              (target (butlast (xs || zs)) p2) \\<noteq>\n                             {};\n        productF A B FAIL AB; well_formed A; well_formed B;\n        path AB (x # xs || y # ys || z # zs) (p1, p2); p1 \\<in> nodes A;\n        p2 \\<in> nodes B\\<rbrakk>\n       \\<Longrightarrow> path A (x # xs || y # ys) p1 \\<and>\n                         path B (x # xs || z # zs) p2 \\<or>\n                         target (x # xs || y # ys || z # zs) (p1, p2) =\n                         FAIL \\<and>\n                         0 < length (x # xs) \\<and>\n                         path A (butlast (x # xs || y # ys)) p1 \\<and>\n                         path B (butlast (x # xs || z # zs)) p2 \\<and>\n                         succ A (last (x # xs))\n                          (target (butlast (x # xs || y # ys)) p1) =\n                         {} \\<and>\n                         succ B (last (x # xs))\n                          (target (butlast (x # xs || z # zs)) p2) \\<noteq>\n                         {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "proof (cases \"(r1,r2) = FAIL\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "case True"], ["proof (state)\nthis:\n  (r1, r2) = FAIL\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have \"r1s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1s = []", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. r1s \\<noteq> [] \\<Longrightarrow> False", "assume \"\\<not> (r1s = [])\""], ["proof (state)\nthis:\n  r1s \\<noteq> []\n\ngoal (1 subgoal):\n 1. r1s \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r1s \\<noteq> []", "have \"(\\<not> (ws = [])) \\<and> (\\<not> (r1s = [])) \\<and> (\\<not> (r2s = []))\""], ["proof (prove)\nusing this:\n  r1s \\<noteq> []\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<and> r1s \\<noteq> [] \\<and> r2s \\<noteq> []", "using Cons.hyps"], ["proof (prove)\nusing this:\n  r1s \\<noteq> []\n  length ws = length r1s\n  length r1s = length r2s\n\ngoal (1 subgoal):\n 1. ws \\<noteq> [] \\<and> r1s \\<noteq> [] \\<and> r2s \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ws \\<noteq> [] \\<and> r1s \\<noteq> [] \\<and> r2s \\<noteq> []\n\ngoal (1 subgoal):\n 1. r1s \\<noteq> [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ws \\<noteq> [] \\<and> r1s \\<noteq> [] \\<and> r2s \\<noteq> []\n\ngoal (1 subgoal):\n 1. r1s \\<noteq> [] \\<Longrightarrow> False", "have \"path AB (ws || r1s || r2s) FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB (ws || r1s || r2s) FAIL", "using True path_tail"], ["proof (prove)\nusing this:\n  (r1, r2) = FAIL\n  path AB (ws || r1s || r2s) (r1, r2)\n\ngoal (1 subgoal):\n 1. path AB (ws || r1s || r2s) FAIL", "by simp"], ["proof (state)\nthis:\n  path AB (ws || r1s || r2s) FAIL\n\ngoal (1 subgoal):\n 1. r1s \\<noteq> [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ws \\<noteq> [] \\<and> r1s \\<noteq> [] \\<and> r2s \\<noteq> []\n  path AB (ws || r1s || r2s) FAIL", "have \"path AB ([hd ws] @ tl ws || [hd r1s] @ tl r1s || [hd r2s] @ tl r2s) FAIL\""], ["proof (prove)\nusing this:\n  ws \\<noteq> [] \\<and> r1s \\<noteq> [] \\<and> r2s \\<noteq> []\n  path AB (ws || r1s || r2s) FAIL\n\ngoal (1 subgoal):\n 1. path AB ([hd ws] @ tl ws || [hd r1s] @ tl r1s || [hd r2s] @ tl r2s) FAIL", "by simp"], ["proof (state)\nthis:\n  path AB ([hd ws] @ tl ws || [hd r1s] @ tl r1s || [hd r2s] @ tl r2s) FAIL\n\ngoal (1 subgoal):\n 1. r1s \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path AB ([hd ws] @ tl ws || [hd r1s] @ tl r1s || [hd r2s] @ tl r2s) FAIL", "have \"path AB ([hd ws] || [hd r1s] || [hd r2s]) FAIL\""], ["proof (prove)\nusing this:\n  path AB ([hd ws] @ tl ws || [hd r1s] @ tl r1s || [hd r2s] @ tl r2s) FAIL\n\ngoal (1 subgoal):\n 1. path AB ([hd ws] || [hd r1s] || [hd r2s]) FAIL", "by auto"], ["proof (state)\nthis:\n  path AB ([hd ws] || [hd r1s] || [hd r2s]) FAIL\n\ngoal (1 subgoal):\n 1. r1s \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path AB ([hd ws] || [hd r1s] || [hd r2s]) FAIL", "have \"succ AB (hd ws) FAIL \\<noteq> {}\""], ["proof (prove)\nusing this:\n  path AB ([hd ws] || [hd r1s] || [hd r2s]) FAIL\n\ngoal (1 subgoal):\n 1. succ AB (hd ws) FAIL \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  succ AB (hd ws) FAIL \\<noteq> {}\n\ngoal (1 subgoal):\n 1. r1s \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  succ AB (hd ws) FAIL \\<noteq> {}", "show \"False\""], ["proof (prove)\nusing this:\n  succ AB (hd ws) FAIL \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "using no_transition_after_FAIL"], ["proof (prove)\nusing this:\n  succ AB (hd ws) FAIL \\<noteq> {}\n  productF ?A ?B ?FAIL ?AB \\<Longrightarrow> succ ?AB ?io ?FAIL = {}\n\ngoal (1 subgoal):\n 1. False", "using Cons.prems"], ["proof (prove)\nusing this:\n  succ AB (hd ws) FAIL \\<noteq> {}\n  productF ?A ?B ?FAIL ?AB \\<Longrightarrow> succ ?AB ?io ?FAIL = {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r1s = []\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  r1s = []", "have tail_nil : \"ws = [] \\<and> r1s = [] \\<and> r2s = []\""], ["proof (prove)\nusing this:\n  r1s = []\n\ngoal (1 subgoal):\n 1. ws = [] \\<and> r1s = [] \\<and> r2s = []", "using Cons.hyps"], ["proof (prove)\nusing this:\n  r1s = []\n  length ws = length r1s\n  length r1s = length r2s\n\ngoal (1 subgoal):\n 1. ws = [] \\<and> r1s = [] \\<and> r2s = []", "by simp"], ["proof (state)\nthis:\n  ws = [] \\<and> r1s = [] \\<and> r2s = []\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have succ_fail : \"FAIL \\<in> succ AB w (p1,p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<in> succ AB w (p1, p2)", "using path_head True"], ["proof (prove)\nusing this:\n  path AB ([w] || [(r1, r2)]) (p1, p2)\n  (r1, r2) = FAIL\n\ngoal (1 subgoal):\n 1. FAIL \\<in> succ AB w (p1, p2)", "by auto"], ["proof (state)\nthis:\n  FAIL \\<in> succ AB w (p1, p2)\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  FAIL \\<in> succ AB w (p1, p2)", "have succs : \"succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  FAIL \\<in> succ AB w (p1, p2)\n\ngoal (1 subgoal):\n 1. succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "using Cons.prems"], ["proof (prove)\nusing this:\n  FAIL \\<in> succ AB w (p1, p2)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}", "by (meson productF_succ_fail_imp)"], ["proof (state)\nthis:\n  succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have  \"target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL", "using True tail_nil"], ["proof (prove)\nusing this:\n  (r1, r2) = FAIL\n  ws = [] \\<and> r1s = [] \\<and> r2s = []\n\ngoal (1 subgoal):\n 1. target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL", "by simp"], ["proof (state)\nthis:\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have \"0 < length (w # ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (w # ws)", "by simp"], ["proof (state)\nthis:\n  0 < length (w # ws)\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  0 < length (w # ws)\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have \"path A (butlast (w # ws || r1 # r1s)) p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (butlast (w # ws || r1 # r1s)) p1", "using tail_nil"], ["proof (prove)\nusing this:\n  ws = [] \\<and> r1s = [] \\<and> r2s = []\n\ngoal (1 subgoal):\n 1. path A (butlast (w # ws || r1 # r1s)) p1", "by auto"], ["proof (state)\nthis:\n  path A (butlast (w # ws || r1 # r1s)) p1\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  path A (butlast (w # ws || r1 # r1s)) p1\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have \"path B (butlast (w # ws || r2 # r2s)) p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path B (butlast (w # ws || r2 # r2s)) p2", "using tail_nil"], ["proof (prove)\nusing this:\n  ws = [] \\<and> r1s = [] \\<and> r2s = []\n\ngoal (1 subgoal):\n 1. path B (butlast (w # ws || r2 # r2s)) p2", "by auto"], ["proof (state)\nthis:\n  path B (butlast (w # ws || r2 # r2s)) p2\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  path B (butlast (w # ws || r2 # r2s)) p2\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have \"succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) = {}", "using succs tail_nil"], ["proof (prove)\nusing this:\n  succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n  ws = [] \\<and> r1s = [] \\<and> r2s = []\n\ngoal (1 subgoal):\n 1. succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) = {}", "by simp"], ["proof (state)\nthis:\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) = {}\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) = {}\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have \"succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "using succs tail_nil"], ["proof (prove)\nusing this:\n  succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {}\n  ws = [] \\<and> r1s = [] \\<and> r2s = []\n\ngoal (1 subgoal):\n 1. succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "by simp"], ["proof (state)\nthis:\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. (r1, r2) = FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}\n 2. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL\n  0 < length (w # ws)\n  path A (butlast (w # ws || r1 # r1s)) p1\n  path B (butlast (w # ws || r2 # r2s)) p2\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) = {}\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL\n  0 < length (w # ws)\n  path A (butlast (w # ws || r1 # r1s)) p1\n  path B (butlast (w # ws || r2 # r2s)) p2\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) = {}\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "by simp"], ["proof (state)\nthis:\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "case False"], ["proof (state)\nthis:\n  (r1, r2) \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have \"(r1,r2) \\<in> succ AB w (p1,p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r1, r2) \\<in> succ AB w (p1, p2)", "using path_head"], ["proof (prove)\nusing this:\n  path AB ([w] || [(r1, r2)]) (p1, p2)\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<in> succ AB w (p1, p2)", "by auto"], ["proof (state)\nthis:\n  (r1, r2) \\<in> succ AB w (p1, p2)\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  (r1, r2) \\<in> succ AB w (p1, p2)", "have succ_not_fail : \"succ AB w (p1,p2) \\<noteq> {FAIL}\""], ["proof (prove)\nusing this:\n  (r1, r2) \\<in> succ AB w (p1, p2)\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) \\<noteq> {FAIL}", "using succ_nonempty False"], ["proof (prove)\nusing this:\n  (r1, r2) \\<in> succ AB w (p1, p2)\n  succ AB w (p1, p2) \\<noteq> {}\n  (r1, r2) \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) \\<noteq> {FAIL}", "by auto"], ["proof (state)\nthis:\n  succ AB w (p1, p2) \\<noteq> {FAIL}\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have \"\\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> (succ A w p1 = {} \\<and>\n                   succ B w p2 \\<noteq> {}) \\<Longrightarrow>\n    False", "assume \"\\<not> \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\""], ["proof (state)\nthis:\n  \\<not> \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (succ A w p1 = {} \\<and>\n                   succ B w p2 \\<noteq> {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})", "have \"succ AB w (p1,p2) = {FAIL}\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = {FAIL}", "using succ_if_1 Cons"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (?p1.0, ?p2.0); ?p1.0 \\<in> nodes A;\n   ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) ?p1.0 \\<and>\n                    path B (ws || r2s) ?p2.0 \\<or>\n                    target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) ?p1.0 \\<and>\n                    path B (butlast (ws || r2s)) ?p2.0 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) ?p2.0) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = {FAIL}", "by auto"], ["proof (state)\nthis:\n  succ AB w (p1, p2) = {FAIL}\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (succ A w p1 = {} \\<and>\n                   succ B w p2 \\<noteq> {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  succ AB w (p1, p2) = {FAIL}", "show \"False\""], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) = {FAIL}\n\ngoal (1 subgoal):\n 1. False", "using succ_not_fail"], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) = {FAIL}\n  succ AB w (p1, p2) \\<noteq> {FAIL}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})", "have \"succ AB w (p1,p2) = (succ A w p1 \\<times> succ B w p2)\""], ["proof (prove)\nusing this:\n  \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2", "using succ_if_1 Cons"], ["proof (prove)\nusing this:\n  \\<not> (succ A w p1 = {} \\<and> succ B w p2 \\<noteq> {})\n  p1 \\<in> nodes A \\<and>\n  p2 \\<in> nodes B \\<and>\n  fst w \\<in> inputs A \\<and> snd w \\<in> outputs A \\<union> outputs B\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (?p1.0, ?p2.0); ?p1.0 \\<in> nodes A;\n   ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) ?p1.0 \\<and>\n                    path B (ws || r2s) ?p2.0 \\<or>\n                    target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) ?p1.0 \\<and>\n                    path B (butlast (ws || r2s)) ?p2.0 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) ?p2.0) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2", "by auto"], ["proof (state)\nthis:\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2", "have \"(r1,r2) \\<in> (succ A w p1 \\<times> succ B w p2)\""], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<in> succ A w p1 \\<times> succ B w p2", "using Cons"], ["proof (prove)\nusing this:\n  succ AB w (p1, p2) = succ A w p1 \\<times> succ B w p2\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (?p1.0, ?p2.0); ?p1.0 \\<in> nodes A;\n   ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) ?p1.0 \\<and>\n                    path B (ws || r2s) ?p2.0 \\<or>\n                    target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) ?p1.0 \\<and>\n                    path B (butlast (ws || r2s)) ?p2.0 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) ?p2.0) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<in> succ A w p1 \\<times> succ B w p2", "by auto"], ["proof (state)\nthis:\n  (r1, r2) \\<in> succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  (r1, r2) \\<in> succ A w p1 \\<times> succ B w p2", "have succs_next : \"r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\""], ["proof (prove)\nusing this:\n  (r1, r2) \\<in> succ A w p1 \\<times> succ B w p2\n\ngoal (1 subgoal):\n 1. r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2", "by auto"], ["proof (state)\nthis:\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2", "have nodes_next : \"r1 \\<in> nodes A \\<and> r2 \\<in> nodes B\""], ["proof (prove)\nusing this:\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\n\ngoal (1 subgoal):\n 1. r1 \\<in> nodes A \\<and> r2 \\<in> nodes B", "using Cons succ_nodes"], ["proof (prove)\nusing this:\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (?p1.0, ?p2.0); ?p1.0 \\<in> nodes A;\n   ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) ?p1.0 \\<and>\n                    path B (ws || r2s) ?p2.0 \\<or>\n                    target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) ?p1.0 \\<and>\n                    path B (butlast (ws || r2s)) ?p2.0 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) ?p2.0) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  \\<lbrakk>?q2.0 \\<in> succ ?A ?w ?q1.0; ?q1.0 \\<in> nodes ?A\\<rbrakk>\n  \\<Longrightarrow> ?q2.0 \\<in> nodes ?A\n\ngoal (1 subgoal):\n 1. r1 \\<in> nodes A \\<and> r2 \\<in> nodes B", "by metis"], ["proof (state)\nthis:\n  r1 \\<in> nodes A \\<and> r2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  r1 \\<in> nodes A \\<and> r2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have path_tail : \"path AB (ws || r1s || r2s) (r1,r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB (ws || r1s || r2s) (r1, r2)", "using Cons"], ["proof (prove)\nusing this:\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (?p1.0, ?p2.0); ?p1.0 \\<in> nodes A;\n   ?p2.0 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) ?p1.0 \\<and>\n                    path B (ws || r2s) ?p2.0 \\<or>\n                    target (ws || r1s || r2s) (?p1.0, ?p2.0) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) ?p1.0 \\<and>\n                    path B (butlast (ws || r2s)) ?p2.0 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) ?p1.0) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) ?p2.0) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path AB (ws || r1s || r2s) (r1, r2)", "by auto"], ["proof (state)\nthis:\n  path AB (ws || r1s || r2s) (r1, r2)\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "ultimately"], ["proof (chain)\npicking this:\n  r1 \\<in> nodes A \\<and> r2 \\<in> nodes B\n  path AB (ws || r1s || r2s) (r1, r2)", "have prop_tail : \n        \"path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2 \\<or>\n            target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n            0 < length ws \\<and>\n            path A (butlast (ws || r1s)) r1 \\<and>\n            path B (butlast (ws || r2s)) r2 \\<and>\n            succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n            succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  r1 \\<in> nodes A \\<and> r2 \\<in> nodes B\n  path AB (ws || r1s || r2s) (r1, r2)\n\ngoal (1 subgoal):\n 1. path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2 \\<or>\n    target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n    0 < length ws \\<and>\n    path A (butlast (ws || r1s)) r1 \\<and>\n    path B (butlast (ws || r2s)) r2 \\<and>\n    succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n    succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}", "using Cons.IH[of r1 r2] Cons.prems"], ["proof (prove)\nusing this:\n  r1 \\<in> nodes A \\<and> r2 \\<in> nodes B\n  path AB (ws || r1s || r2s) (r1, r2)\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (ws || r1s || r2s) (r1, r2); r1 \\<in> nodes A;\n   r2 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2 \\<or>\n                    target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n                    0 < length ws \\<and>\n                    path A (butlast (ws || r1s)) r1 \\<and>\n                    path B (butlast (ws || r2s)) r2 \\<and>\n                    succ A (last ws) (target (butlast (ws || r1s)) r1) =\n                    {} \\<and>\n                    succ B (last ws)\n                     (target (butlast (ws || r2s)) r2) \\<noteq>\n                    {}\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w # ws || r1 # r1s || r2 # r2s) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2 \\<or>\n    target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n    0 < length ws \\<and>\n    path A (butlast (ws || r1s)) r1 \\<and>\n    path B (butlast (ws || r2s)) r2 \\<and>\n    succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n    succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2 \\<or>\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "moreover"], ["proof (state)\nthis:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2 \\<or>\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "have \"path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2", "using succs_next"], ["proof (prove)\nusing this:\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\n\ngoal (1 subgoal):\n 1. path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2", "by auto"], ["proof (state)\nthis:\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. (r1, r2) \\<noteq> FAIL \\<Longrightarrow>\n    path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2", "show ?thesis"], ["proof (prove)\nusing this:\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "proof (cases \"path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}\n 2. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "case True"], ["proof (state)\nthis:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}\n 2. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "moreover"], ["proof (state)\nthis:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}\n 2. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "have paths_head : \"path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2", "using succs_next"], ["proof (prove)\nusing this:\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\n\ngoal (1 subgoal):\n 1. path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2", "by auto"], ["proof (state)\nthis:\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}\n 2. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "ultimately"], ["proof (chain)\npicking this:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2", "show ?thesis"], ["proof (prove)\nusing this:\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "by (metis (no_types) FSM.path.simps FSM.path_cons_elim True eq_snd_iff \n            paths_head zip_Cons_Cons)"], ["proof (state)\nthis:\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "case False"], ["proof (state)\nthis:\n  \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "then"], ["proof (chain)\npicking this:\n  \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)", "have fail_prop : \"target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n            0 < length ws \\<and>\n            path A (butlast (ws || r1s)) r1 \\<and>\n            path B (butlast (ws || r2s)) r2 \\<and>\n            succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n            succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\n\ngoal (1 subgoal):\n 1. target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n    0 < length ws \\<and>\n    path A (butlast (ws || r1s)) r1 \\<and>\n    path B (butlast (ws || r2s)) r2 \\<and>\n    succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n    succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}", "using prop_tail"], ["proof (prove)\nusing this:\n  \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\n  path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2 \\<or>\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n    0 < length ws \\<and>\n    path A (butlast (ws || r1s)) r1 \\<and>\n    path B (butlast (ws || r2s)) r2 \\<and>\n    succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n    succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "then"], ["proof (chain)\npicking this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}", "have paths_head : \"path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\""], ["proof (prove)\nusing this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2", "using succs_next"], ["proof (prove)\nusing this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n  r1 \\<in> succ A w p1 \\<and> r2 \\<in> succ B w p2\n\ngoal (1 subgoal):\n 1. path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2", "by auto"], ["proof (state)\nthis:\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "have \"(last (w # ws)) = last ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (w # ws) = last ws", "using fail_prop"], ["proof (prove)\nusing this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. last (w # ws) = last ws", "by simp"], ["proof (state)\nthis:\n  last (w # ws) = last ws\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "moreover"], ["proof (state)\nthis:\n  last (w # ws) = last ws\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "have \"(target (butlast (w # ws || r1 # r1s)) p1) = (target (butlast (ws || r1s)) r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (butlast (w # ws || r1 # r1s)) p1 =\n    target (butlast (ws || r1s)) r1", "using fail_prop Cons.hyps(1) butlast_zip_cons"], ["proof (prove)\nusing this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n  length ws = length r1s\n  \\<lbrakk>length ?ws = length ?r1s; ?ws \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> butlast (?w # ?ws || ?r1.0 # ?r1s) =\n                    (?w, ?r1.0) # butlast (?ws || ?r1s)\n\ngoal (1 subgoal):\n 1. target (butlast (w # ws || r1 # r1s)) p1 =\n    target (butlast (ws || r1s)) r1", "by fastforce"], ["proof (state)\nthis:\n  target (butlast (w # ws || r1 # r1s)) p1 = target (butlast (ws || r1s)) r1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "moreover"], ["proof (state)\nthis:\n  target (butlast (w # ws || r1 # r1s)) p1 = target (butlast (ws || r1s)) r1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "have \"(target (butlast (w # ws || r2 # r2s)) p2) = (target (butlast (ws || r2s)) r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (butlast (w # ws || r2 # r2s)) p2 =\n    target (butlast (ws || r2s)) r2", "using fail_prop Cons.hyps(1) Cons.hyps(2) butlast_zip_cons"], ["proof (prove)\nusing this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n  length ws = length r1s\n  length r1s = length r2s\n  \\<lbrakk>length ?ws = length ?r1s; ?ws \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> butlast (?w # ?ws || ?r1.0 # ?r1s) =\n                    (?w, ?r1.0) # butlast (?ws || ?r1s)\n\ngoal (1 subgoal):\n 1. target (butlast (w # ws || r2 # r2s)) p2 =\n    target (butlast (ws || r2s)) r2", "by fastforce"], ["proof (state)\nthis:\n  target (butlast (w # ws || r2 # r2s)) p2 = target (butlast (ws || r2s)) r2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "ultimately"], ["proof (chain)\npicking this:\n  last (w # ws) = last ws\n  target (butlast (w # ws || r1 # r1s)) p1 = target (butlast (ws || r1s)) r1\n  target (butlast (w # ws || r2 # r2s)) p2 = target (butlast (ws || r2s)) r2", "have \"succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) = {} \n                        \\<and> succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  last (w # ws) = last ws\n  target (butlast (w # ws || r1 # r1s)) p1 = target (butlast (ws || r1s)) r1\n  target (butlast (w # ws || r2 # r2s)) p2 = target (butlast (ws || r2s)) r2\n\ngoal (1 subgoal):\n 1. succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "using fail_prop"], ["proof (prove)\nusing this:\n  last (w # ws) = last ws\n  target (butlast (w # ws || r1 # r1s)) p1 = target (butlast (ws || r1s)) r1\n  target (butlast (w # ws || r2 # r2s)) p2 = target (butlast (ws || r2s)) r2\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "moreover"], ["proof (state)\nthis:\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "have \"path A (butlast (w # ws || r1 # r1s)) p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (butlast (w # ws || r1 # r1s)) p1", "using fail_prop paths_head"], ["proof (prove)\nusing this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. path A (butlast (w # ws || r1 # r1s)) p1", "by auto"], ["proof (state)\nthis:\n  path A (butlast (w # ws || r1 # r1s)) p1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "moreover"], ["proof (state)\nthis:\n  path A (butlast (w # ws || r1 # r1s)) p1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "have \"path B (butlast (w # ws || r2 # r2s)) p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path B (butlast (w # ws || r2 # r2s)) p2", "using fail_prop paths_head"], ["proof (prove)\nusing this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. path B (butlast (w # ws || r2 # r2s)) p2", "by auto"], ["proof (state)\nthis:\n  path B (butlast (w # ws || r2 # r2s)) p2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "moreover"], ["proof (state)\nthis:\n  path B (butlast (w # ws || r2 # r2s)) p2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "have \"target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL", "using fail_prop paths_head"], ["proof (prove)\nusing this:\n  target (ws || r1s || r2s) (r1, r2) = FAIL \\<and>\n  0 < length ws \\<and>\n  path A (butlast (ws || r1s)) r1 \\<and>\n  path B (butlast (ws || r2s)) r2 \\<and>\n  succ A (last ws) (target (butlast (ws || r1s)) r1) = {} \\<and>\n  succ B (last ws) (target (butlast (ws || r2s)) r2) \\<noteq> {}\n  path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2\n\ngoal (1 subgoal):\n 1. target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL", "by auto"], ["proof (state)\nthis:\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path A ([w] || [r1]) p1 \\<and> path B ([w] || [r2]) p2;\n     \\<not> (path A (ws || r1s) r1 \\<and> path B (ws || r2s) r2)\\<rbrakk>\n    \\<Longrightarrow> path A (w # ws || r1 # r1s) p1 \\<and>\n                      path B (w # ws || r2 # r2s) p2 \\<or>\n                      target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) =\n                      FAIL \\<and>\n                      0 < length (w # ws) \\<and>\n                      path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n                      path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n                      succ A (last (w # ws))\n                       (target (butlast (w # ws || r1 # r1s)) p1) =\n                      {} \\<and>\n                      succ B (last (w # ws))\n                       (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n                      {}", "ultimately"], ["proof (chain)\npicking this:\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  path A (butlast (w # ws || r1 # r1s)) p1\n  path B (butlast (w # ws || r2 # r2s)) p2\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL", "show ?thesis"], ["proof (prove)\nusing this:\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n  path A (butlast (w # ws || r1 # r1s)) p1\n  path B (butlast (w # ws || r2 # r2s)) p2\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL\n\ngoal (1 subgoal):\n 1. path A (w # ws || r1 # r1s) p1 \\<and>\n    path B (w # ws || r2 # r2s) p2 \\<or>\n    target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n    0 < length (w # ws) \\<and>\n    path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n    path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n    succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n    {} \\<and>\n    succ B (last (w # ws))\n     (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n    {}", "by simp"], ["proof (state)\nthis:\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path A (w # ws || r1 # r1s) p1 \\<and> path B (w # ws || r2 # r2s) p2 \\<or>\n  target (w # ws || r1 # r1s || r2 # r2s) (p1, p2) = FAIL \\<and>\n  0 < length (w # ws) \\<and>\n  path A (butlast (w # ws || r1 # r1s)) p1 \\<and>\n  path B (butlast (w # ws || r2 # r2s)) p2 \\<and>\n  succ A (last (w # ws)) (target (butlast (w # ws || r1 # r1s)) p1) =\n  {} \\<and>\n  succ B (last (w # ws)) (target (butlast (w # ws || r2 # r2s)) p2) \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma butlast_zip[simp] :\n  assumes \"length xs = length ys\"\n  shows \"butlast (xs || ys) = (butlast xs || butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (xs || ys) = butlast xs || butlast ys", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. butlast (xs || ys) = butlast xs || butlast ys", "by (metis (no_types, lifting) map_butlast map_fst_zip map_snd_zip zip_map_fst_snd)"], ["", "lemma productF_path_reverse_ob : \n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"path AB (w || r1 || r2) (p1, p2)\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\nobtains r2' \nwhere \"path B (w || r2') p2 \\<and> length w = length r2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r2'.\n        path B (w || r2') p2 \\<and> length w = length r2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>r2'.\n        path B (w || r2') p2 \\<and> length w = length r2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have path_prop : \"(path A (w || r1) p1 \\<and> path B (w || r2) p2) \n                    \\<or> (target (w || r1 || r2) (p1, p2) = FAIL\n                      \\<and> length w > 0\n                      \\<and> path A (butlast (w || r1)) p1\n                      \\<and> path B (butlast (w || r2)) p2\n                      \\<and> succ A (last w) (target (butlast (w || r1)) p1) = {}\n                      \\<and> succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "using assms productF_path_reverse[of w r1 r2 A B FAIL AB p1 p2]"], ["proof (prove)\nusing this:\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w || r1 || r2) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  \\<lbrakk>length w = length r1; length r1 = length r2;\n   productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (w || r1 || r2) (p1, p2); p1 \\<in> nodes A;\n   p2 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n                    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n                    0 < length w \\<and>\n                    path A (butlast (w || r1)) p1 \\<and>\n                    path B (butlast (w || r2)) p2 \\<and>\n                    succ A (last w) (target (butlast (w || r1)) p1) =\n                    {} \\<and>\n                    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>r2'.\n        path B (w || r2') p2 \\<and> length w = length r2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists> r1' . path B (w || r1') p2 \\<and> length w = length r1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "proof (cases \"path A (w || r1) p1 \\<and> path B (w || r2) p2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'\n 2. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "case True"], ["proof (state)\nthis:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2\n\ngoal (2 subgoals):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'\n 2. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "then"], ["proof (chain)\npicking this:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2", "show ?thesis"], ["proof (prove)\nusing this:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2\n\ngoal (1 subgoal):\n 1. \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "using assms"], ["proof (prove)\nusing this:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w || r1 || r2) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "by auto"], ["proof (state)\nthis:\n  \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "case False"], ["proof (state)\nthis:\n  \\<not> (path A (w || r1) p1 \\<and> path B (w || r2) p2)\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "then"], ["proof (chain)\npicking this:\n  \\<not> (path A (w || r1) p1 \\<and> path B (w || r2) p2)", "have B_prop : \"length w > 0\n                \\<and> path B (butlast (w || r2)) p2\n                \\<and> succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> (path A (w || r1) p1 \\<and> path B (w || r2) p2)\n\ngoal (1 subgoal):\n 1. 0 < length w \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "using path_prop"], ["proof (prove)\nusing this:\n  \\<not> (path A (w || r1) p1 \\<and> path B (w || r2) p2)\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < length w \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  0 < length w \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "then"], ["proof (chain)\npicking this:\n  0 < length w \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "obtain rx where \"rx \\<in> succ B (last w) (target (butlast (w || r2)) p2)\""], ["proof (prove)\nusing this:\n  0 < length w \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>rx.\n        rx \\<in> succ B (last w)\n                  (target (butlast (w || r2)) p2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rx \\<in> succ B (last w) (target (butlast (w || r2)) p2)\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "then"], ["proof (chain)\npicking this:\n  rx \\<in> succ B (last w) (target (butlast (w || r2)) p2)", "have \"path B ([last w] || [rx]) (target (butlast (w || r2)) p2)\""], ["proof (prove)\nusing this:\n  rx \\<in> succ B (last w) (target (butlast (w || r2)) p2)\n\ngoal (1 subgoal):\n 1. path B ([last w] || [rx]) (target (butlast (w || r2)) p2)", "using B_prop"], ["proof (prove)\nusing this:\n  rx \\<in> succ B (last w) (target (butlast (w || r2)) p2)\n  0 < length w \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. path B ([last w] || [rx]) (target (butlast (w || r2)) p2)", "by auto"], ["proof (state)\nthis:\n  path B ([last w] || [rx]) (target (butlast (w || r2)) p2)\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "then"], ["proof (chain)\npicking this:\n  path B ([last w] || [rx]) (target (butlast (w || r2)) p2)", "have \"path B ((butlast (w || r2)) @ ([last w] || [rx])) p2\""], ["proof (prove)\nusing this:\n  path B ([last w] || [rx]) (target (butlast (w || r2)) p2)\n\ngoal (1 subgoal):\n 1. path B (butlast (w || r2) @ ([last w] || [rx])) p2", "using B_prop"], ["proof (prove)\nusing this:\n  path B ([last w] || [rx]) (target (butlast (w || r2)) p2)\n  0 < length w \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. path B (butlast (w || r2) @ ([last w] || [rx])) p2", "by auto"], ["proof (state)\nthis:\n  path B (butlast (w || r2) @ ([last w] || [rx])) p2\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "moreover"], ["proof (state)\nthis:\n  path B (butlast (w || r2) @ ([last w] || [rx])) p2\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "have \"butlast (w || r2) = (butlast w || butlast r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (w || r2) = butlast w || butlast r2", "using assms"], ["proof (prove)\nusing this:\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w || r1 || r2) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n\ngoal (1 subgoal):\n 1. butlast (w || r2) = butlast w || butlast r2", "by simp"], ["proof (state)\nthis:\n  butlast (w || r2) = butlast w || butlast r2\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "ultimately"], ["proof (chain)\npicking this:\n  path B (butlast (w || r2) @ ([last w] || [rx])) p2\n  butlast (w || r2) = butlast w || butlast r2", "have \"path B ((butlast w) @ [last w] || (butlast r2) @ [rx]) p2\""], ["proof (prove)\nusing this:\n  path B (butlast (w || r2) @ ([last w] || [rx])) p2\n  butlast (w || r2) = butlast w || butlast r2\n\ngoal (1 subgoal):\n 1. path B (butlast w @ [last w] || butlast r2 @ [rx]) p2", "using assms B_prop"], ["proof (prove)\nusing this:\n  path B (butlast (w || r2) @ ([last w] || [rx])) p2\n  butlast (w || r2) = butlast w || butlast r2\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w || r1 || r2) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  0 < length w \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. path B (butlast w @ [last w] || butlast r2 @ [rx]) p2", "by auto"], ["proof (state)\nthis:\n  path B (butlast w @ [last w] || butlast r2 @ [rx]) p2\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "moreover"], ["proof (state)\nthis:\n  path B (butlast w @ [last w] || butlast r2 @ [rx]) p2\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "have \"(butlast w) @ [last w] = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast w @ [last w] = w", "using B_prop"], ["proof (prove)\nusing this:\n  0 < length w \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. butlast w @ [last w] = w", "by simp"], ["proof (state)\nthis:\n  butlast w @ [last w] = w\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "moreover"], ["proof (state)\nthis:\n  butlast w @ [last w] = w\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "have \"length ((butlast r2) @ [rx]) = length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (butlast r2 @ [rx]) = length w", "using assms B_prop"], ["proof (prove)\nusing this:\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w || r1 || r2) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  0 < length w \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. length (butlast r2 @ [rx]) = length w", "by auto"], ["proof (state)\nthis:\n  length (butlast r2 @ [rx]) = length w\n\ngoal (1 subgoal):\n 1. \\<not> (path A (w || r1) p1 \\<and>\n            path B (w || r2) p2) \\<Longrightarrow>\n    \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "ultimately"], ["proof (chain)\npicking this:\n  path B (butlast w @ [last w] || butlast r2 @ [rx]) p2\n  butlast w @ [last w] = w\n  length (butlast r2 @ [rx]) = length w", "show ?thesis"], ["proof (prove)\nusing this:\n  path B (butlast w @ [last w] || butlast r2 @ [rx]) p2\n  butlast w @ [last w] = w\n  length (butlast r2 @ [rx]) = length w\n\ngoal (1 subgoal):\n 1. \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "by auto"], ["proof (state)\nthis:\n  \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'\n\ngoal (1 subgoal):\n 1. (\\<And>r2'.\n        path B (w || r2') p2 \\<and> length w = length r2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'", "obtain r1' where \"path B (w || r1') p2 \\<and> length w = length r1'\""], ["proof (prove)\nusing this:\n  \\<exists>r1'. path B (w || r1') p2 \\<and> length w = length r1'\n\ngoal (1 subgoal):\n 1. (\\<And>r1'.\n        path B (w || r1') p2 \\<and> length w = length r1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path B (w || r1') p2 \\<and> length w = length r1'\n\ngoal (1 subgoal):\n 1. (\\<And>r2'.\n        path B (w || r2') p2 \\<and> length w = length r2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  path B (w || r1') p2 \\<and> length w = length r1'", "show ?thesis"], ["proof (prove)\nusing this:\n  path B (w || r1') p2 \\<and> length w = length r1'\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  path B (w || r1') p2 \\<and> length w = length r1'\n  path B (w || ?r2') p2 \\<and> length w = length ?r2' \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following lemma formalizes the property of paths of the product machine as described \nin the section introduction.\n\\<close>"], ["", "lemma productF_path[iff] :\n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\nshows \"path AB (w || r1 || r2) (p1, p2) \\<longleftrightarrow> ((path A (w || r1) p1 \\<and> path B (w || r2) p2) \n            \\<or> (target (w || r1 || r2) (p1, p2) = FAIL\n              \\<and> length w > 0\n              \\<and> path A (butlast (w || r1)) p1\n              \\<and> path B (butlast (w || r2)) p2\n              \\<and> succ A (last w) (target (butlast (w || r1)) p1) = {}\n              \\<and> succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}))\" (is \"?path \\<longleftrightarrow> ?paths\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB (w || r1 || r2) (p1, p2) =\n    (path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n     target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n     0 < length w \\<and>\n     path A (butlast (w || r1)) p1 \\<and>\n     path B (butlast (w || r2)) p2 \\<and>\n     succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n     succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. path AB (w || r1 || r2) (p1, p2) \\<Longrightarrow>\n    path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n 2. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq>\n    {} \\<Longrightarrow>\n    path AB (w || r1 || r2) (p1, p2)", "assume ?path"], ["proof (state)\nthis:\n  path AB (w || r1 || r2) (p1, p2)\n\ngoal (2 subgoals):\n 1. path AB (w || r1 || r2) (p1, p2) \\<Longrightarrow>\n    path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n 2. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq>\n    {} \\<Longrightarrow>\n    path AB (w || r1 || r2) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  path AB (w || r1 || r2) (p1, p2)", "show ?paths"], ["proof (prove)\nusing this:\n  path AB (w || r1 || r2) (p1, p2)\n\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "using assms productF_path_reverse[of w r1 r2 A B FAIL AB p1 p2]"], ["proof (prove)\nusing this:\n  path AB (w || r1 || r2) (p1, p2)\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  \\<lbrakk>length w = length r1; length r1 = length r2;\n   productF A B FAIL AB; well_formed A; well_formed B;\n   path AB (w || r1 || r2) (p1, p2); p1 \\<in> nodes A;\n   p2 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n                    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n                    0 < length w \\<and>\n                    path A (butlast (w || r1)) p1 \\<and>\n                    path B (butlast (w || r2)) p2 \\<and>\n                    succ A (last w) (target (butlast (w || r1)) p1) =\n                    {} \\<and>\n                    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq>\n    {} \\<Longrightarrow>\n    path AB (w || r1 || r2) (p1, p2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq>\n    {} \\<Longrightarrow>\n    path AB (w || r1 || r2) (p1, p2)", "assume ?paths"], ["proof (state)\nthis:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq>\n    {} \\<Longrightarrow>\n    path AB (w || r1 || r2) (p1, p2)", "then"], ["proof (chain)\npicking this:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "show ?path"], ["proof (prove)\nusing this:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. path AB (w || r1 || r2) (p1, p2)", "using assms productF_path_forward[of w r1 r2 A B FAIL AB p1 p2]"], ["proof (prove)\nusing this:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  \\<lbrakk>length w = length r1; length r1 = length r2;\n   productF A B FAIL AB; well_formed A; well_formed B;\n   path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n   target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n   0 < length w \\<and>\n   path A (butlast (w || r1)) p1 \\<and>\n   path B (butlast (w || r2)) p2 \\<and>\n   succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n   succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {};\n   p1 \\<in> nodes A; p2 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (w || r1 || r2) (p1, p2)\n\ngoal (1 subgoal):\n 1. path AB (w || r1 || r2) (p1, p2)", "by simp"], ["proof (state)\nthis:\n  path AB (w || r1 || r2) (p1, p2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_last_succ :\n  assumes \"path A (ws || r1s) p1\"\n  and     \"length r1s = length ws\"\n  and     \"length ws > 0\"\nshows     \"last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)", "have \"path A (butlast (ws || r1s)) p1 \n        \\<and> path A [last (ws || r1s)] (target (butlast (ws || r1s)) p1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (butlast (ws || r1s)) p1 \\<and>\n    path A [last (ws || r1s)] (target (butlast (ws || r1s)) p1)", "by (metis FSM.path_append_elim append_butlast_last_id assms length_greater_0_conv \n        list.size(3) zip_Nil zip_eq)"], ["proof (state)\nthis:\n  path A (butlast (ws || r1s)) p1 \\<and>\n  path A [last (ws || r1s)] (target (butlast (ws || r1s)) p1)\n\ngoal (1 subgoal):\n 1. last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)", "then"], ["proof (chain)\npicking this:\n  path A (butlast (ws || r1s)) p1 \\<and>\n  path A [last (ws || r1s)] (target (butlast (ws || r1s)) p1)", "have \"snd (last (ws || r1s)) \\<in> \n              succ A (fst (last (ws || r1s))) (target (butlast (ws || r1s)) p1)\""], ["proof (prove)\nusing this:\n  path A (butlast (ws || r1s)) p1 \\<and>\n  path A [last (ws || r1s)] (target (butlast (ws || r1s)) p1)\n\ngoal (1 subgoal):\n 1. snd (last (ws || r1s))\n    \\<in> succ A (fst (last (ws || r1s))) (target (butlast (ws || r1s)) p1)", "by auto"], ["proof (state)\nthis:\n  snd (last (ws || r1s))\n  \\<in> succ A (fst (last (ws || r1s))) (target (butlast (ws || r1s)) p1)\n\ngoal (1 subgoal):\n 1. last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)", "moreover"], ["proof (state)\nthis:\n  snd (last (ws || r1s))\n  \\<in> succ A (fst (last (ws || r1s))) (target (butlast (ws || r1s)) p1)\n\ngoal (1 subgoal):\n 1. last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)", "have \"ws || r1s \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws || r1s \\<noteq> []", "using assms(3) assms(2)"], ["proof (prove)\nusing this:\n  0 < length ws\n  length r1s = length ws\n\ngoal (1 subgoal):\n 1. ws || r1s \\<noteq> []", "by (metis length_zip list.size(3) min.idem neq0_conv)"], ["proof (state)\nthis:\n  ws || r1s \\<noteq> []\n\ngoal (1 subgoal):\n 1. last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)", "ultimately"], ["proof (chain)\npicking this:\n  snd (last (ws || r1s))\n  \\<in> succ A (fst (last (ws || r1s))) (target (butlast (ws || r1s)) p1)\n  ws || r1s \\<noteq> []", "have \"last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)\""], ["proof (prove)\nusing this:\n  snd (last (ws || r1s))\n  \\<in> succ A (fst (last (ws || r1s))) (target (butlast (ws || r1s)) p1)\n  ws || r1s \\<noteq> []\n\ngoal (1 subgoal):\n 1. last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)\n\ngoal (1 subgoal):\n 1. last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)", "then"], ["proof (chain)\npicking this:\n  last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)", "show ?thesis"], ["proof (prove)\nusing this:\n  last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)\n\ngoal (1 subgoal):\n 1. last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)", "by auto"], ["proof (state)\nthis:\n  last r1s \\<in> succ A (last ws) (target (butlast (ws || r1s)) p1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zip_last :\n  assumes \"length r1 > 0\"\n  and     \"length r1 = length r2\"\nshows \"last (r1 || r2) = (last r1, last r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (r1 || r2) = (last r1, last r2)", "by (metis (no_types) assms(1) assms(2) less_nat_zero_code list.size(3) \n      map_fst_zip zip_Nil zip_last)"], ["", "lemma productF_path_reverse_ob_2 : \n  assumes \"length w = length r1\" \"length r1 = length r2\"\n  and     \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"path AB (w || r1 || r2) (p1, p2)\"\n  and     \"p1 \\<in> nodes A\"\n  and     \"p2 \\<in> nodes B\"\n  and     \"w \\<in> language_state A p1\"\n  and     \"observable A\"\nshows \"path A (w || r1) p1 \\<and> length w = length r1\" \"path B (w || r2) p2 \\<and> length w = length r2\"\n      \"target (w || r1) p1 = fst (target (w || r1 || r2) (p1,p2))\"\n      \"target (w || r2) p2 = snd (target (w || r1 || r2) (p1,p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (path A (w || r1) p1 \\<and> length w = length r1 &&&\n     path B (w || r2) p2 \\<and> length w = length r2) &&&\n    target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) &&&\n    target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. path A (w || r1) p1 \\<and> length w = length r1\n 2. path B (w || r2) p2 \\<and> length w = length r2\n 3. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 4. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "have \"(path A (w || r1) p1 \\<and> path B (w || r2) p2) \n            \\<or> (target (w || r1 || r2) (p1, p2) = FAIL\n              \\<and> length w > 0\n              \\<and> path A (butlast (w || r1)) p1\n              \\<and> path B (butlast (w || r2)) p2\n              \\<and> succ A (last w) (target (butlast (w || r1)) p1) = {}\n              \\<and> succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "using productF_path[of w r1 r2 A B FAIL AB p1 p2] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>length w = length r1; length r1 = length r2;\n   productF A B FAIL AB; well_formed A; well_formed B; p1 \\<in> nodes A;\n   p2 \\<in> nodes B\\<rbrakk>\n  \\<Longrightarrow> path AB (w || r1 || r2) (p1, p2) =\n                    (path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n                     target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n                     0 < length w \\<and>\n                     path A (butlast (w || r1)) p1 \\<and>\n                     path B (butlast (w || r2)) p2 \\<and>\n                     succ A (last w) (target (butlast (w || r1)) p1) =\n                     {} \\<and>\n                     succ B (last w)\n                      (target (butlast (w || r2)) p2) \\<noteq>\n                     {})\n  length w = length r1\n  length r1 = length r2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  path AB (w || r1 || r2) (p1, p2)\n  p1 \\<in> nodes A\n  p2 \\<in> nodes B\n  w \\<in> LS A p1\n  observable A\n\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n    target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n    0 < length w \\<and>\n    path A (butlast (w || r1)) p1 \\<and>\n    path B (butlast (w || r2)) p2 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (4 subgoals):\n 1. path A (w || r1) p1 \\<and> length w = length r1\n 2. path B (w || r2) p2 \\<and> length w = length r2\n 3. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 4. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "moreover"], ["proof (state)\nthis:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n\ngoal (4 subgoals):\n 1. path A (w || r1) p1 \\<and> length w = length r1\n 2. path B (w || r2) p2 \\<and> length w = length r2\n 3. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 4. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "have \"path A (butlast (w || r1)) p1 \n                  \\<and> succ A (last w) (target (butlast (w || r1)) p1) = {} \n                  \\<and> length w > 0 \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "assume assm : \"path A (butlast (w || r1)) p1 \n                    \\<and> succ A (last w) (target (butlast (w || r1)) p1) = {} \n                    \\<and> length w > 0\""], ["proof (state)\nthis:\n  path A (butlast (w || r1)) p1 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and> 0 < length w\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "obtain r1' where r1'_def : \"path A (w || r1') p1 \\<and> length r1' = length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r1'.\n        path A (w || r1') p1 \\<and> length r1' = length w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(9)"], ["proof (prove)\nusing this:\n  w \\<in> LS A p1\n\ngoal (1 subgoal):\n 1. (\\<And>r1'.\n        path A (w || r1') p1 \\<and> length r1' = length w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path A (w || r1') p1 \\<and> length r1' = length w\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  path A (w || r1') p1 \\<and> length r1' = length w", "have \"path A (butlast (w || r1')) p1 \\<and> length (butlast r1') = length (butlast w)\""], ["proof (prove)\nusing this:\n  path A (w || r1') p1 \\<and> length r1' = length w\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1')) p1 \\<and>\n    length (butlast r1') = length (butlast w)", "by (metis FSM.path_append_elim append_butlast_last_id butlast.simps(1) length_butlast)"], ["proof (state)\nthis:\n  path A (butlast (w || r1')) p1 \\<and>\n  length (butlast r1') = length (butlast w)\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  path A (butlast (w || r1')) p1 \\<and>\n  length (butlast r1') = length (butlast w)\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "have \"path A (butlast (w || r1)) p1 \\<and> length (butlast r1) = length (butlast w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    length (butlast r1) = length (butlast w)", "using assm assms(1)"], ["proof (prove)\nusing this:\n  path A (butlast (w || r1)) p1 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and> 0 < length w\n  length w = length r1\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    length (butlast r1) = length (butlast w)", "by auto"], ["proof (state)\nthis:\n  path A (butlast (w || r1)) p1 \\<and>\n  length (butlast r1) = length (butlast w)\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  path A (butlast (w || r1')) p1 \\<and>\n  length (butlast r1') = length (butlast w)\n  path A (butlast (w || r1)) p1 \\<and>\n  length (butlast r1) = length (butlast w)", "have \"butlast r1 = butlast r1'\""], ["proof (prove)\nusing this:\n  path A (butlast (w || r1')) p1 \\<and>\n  length (butlast r1') = length (butlast w)\n  path A (butlast (w || r1)) p1 \\<and>\n  length (butlast r1) = length (butlast w)\n\ngoal (1 subgoal):\n 1. butlast r1 = butlast r1'", "by (metis assms(1) assms(10) butlast_zip language_state observable_path_unique r1'_def)"], ["proof (state)\nthis:\n  butlast r1 = butlast r1'\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  butlast r1 = butlast r1'", "have \"butlast (w || r1) = butlast (w || r1')\""], ["proof (prove)\nusing this:\n  butlast r1 = butlast r1'\n\ngoal (1 subgoal):\n 1. butlast (w || r1) = butlast (w || r1')", "using assms(1) r1'_def"], ["proof (prove)\nusing this:\n  butlast r1 = butlast r1'\n  length w = length r1\n  path A (w || r1') p1 \\<and> length r1' = length w\n\ngoal (1 subgoal):\n 1. butlast (w || r1) = butlast (w || r1')", "by simp"], ["proof (state)\nthis:\n  butlast (w || r1) = butlast (w || r1')\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  butlast (w || r1) = butlast (w || r1')\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "have \"succ A (last w) (target (butlast (w || r1')) p1) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ A (last w) (target (butlast (w || r1')) p1) \\<noteq> {}", "by (metis (no_types) assm empty_iff path_last_succ r1'_def)"], ["proof (state)\nthis:\n  succ A (last w) (target (butlast (w || r1')) p1) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. path A (butlast (w || r1)) p1 \\<and>\n    succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n    0 < length w \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  butlast (w || r1) = butlast (w || r1')\n  succ A (last w) (target (butlast (w || r1')) p1) \\<noteq> {}", "show \"False\""], ["proof (prove)\nusing this:\n  butlast (w || r1) = butlast (w || r1')\n  succ A (last w) (target (butlast (w || r1')) p1) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "using assm"], ["proof (prove)\nusing this:\n  butlast (w || r1) = butlast (w || r1')\n  succ A (last w) (target (butlast (w || r1')) p1) \\<noteq> {}\n  path A (butlast (w || r1)) p1 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and> 0 < length w\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path A (butlast (w || r1)) p1 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  0 < length w \\<Longrightarrow>\n  False\n\ngoal (4 subgoals):\n 1. path A (w || r1) p1 \\<and> length w = length r1\n 2. path B (w || r2) p2 \\<and> length w = length r2\n 3. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 4. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "ultimately"], ["proof (chain)\npicking this:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n  path A (butlast (w || r1)) p1 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  0 < length w \\<Longrightarrow>\n  False", "have paths : \"(path A (w || r1) p1 \\<and> path B (w || r2) p2)\""], ["proof (prove)\nusing this:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2 \\<or>\n  target (w || r1 || r2) (p1, p2) = FAIL \\<and>\n  0 < length w \\<and>\n  path A (butlast (w || r1)) p1 \\<and>\n  path B (butlast (w || r2)) p2 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  succ B (last w) (target (butlast (w || r2)) p2) \\<noteq> {}\n  path A (butlast (w || r1)) p1 \\<and>\n  succ A (last w) (target (butlast (w || r1)) p1) = {} \\<and>\n  0 < length w \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> path B (w || r2) p2", "by auto"], ["proof (state)\nthis:\n  path A (w || r1) p1 \\<and> path B (w || r2) p2\n\ngoal (4 subgoals):\n 1. path A (w || r1) p1 \\<and> length w = length r1\n 2. path B (w || r2) p2 \\<and> length w = length r2\n 3. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 4. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "show \"path A (w || r1) p1 \\<and> length w = length r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> length w = length r1", "using assms(1) paths"], ["proof (prove)\nusing this:\n  length w = length r1\n  path A (w || r1) p1 \\<and> path B (w || r2) p2\n\ngoal (1 subgoal):\n 1. path A (w || r1) p1 \\<and> length w = length r1", "by simp"], ["proof (state)\nthis:\n  path A (w || r1) p1 \\<and> length w = length r1\n\ngoal (3 subgoals):\n 1. path B (w || r2) p2 \\<and> length w = length r2\n 2. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 3. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "show \"path B (w || r2) p2 \\<and> length w = length r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path B (w || r2) p2 \\<and> length w = length r2", "using assms(1) assms(2) paths"], ["proof (prove)\nusing this:\n  length w = length r1\n  length r1 = length r2\n  path A (w || r1) p1 \\<and> path B (w || r2) p2\n\ngoal (1 subgoal):\n 1. path B (w || r2) p2 \\<and> length w = length r2", "by simp"], ["proof (state)\nthis:\n  path B (w || r2) p2 \\<and> length w = length r2\n\ngoal (2 subgoals):\n 1. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 2. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "have \"length w = 0 \\<Longrightarrow> target (w || r1 || r2) (p1,p2) = (p1,p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length w = 0 \\<Longrightarrow>\n    target (w || r1 || r2) (p1, p2) = (p1, p2)", "by simp"], ["proof (state)\nthis:\n  length w = 0 \\<Longrightarrow> target (w || r1 || r2) (p1, p2) = (p1, p2)\n\ngoal (2 subgoals):\n 1. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 2. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "moreover"], ["proof (state)\nthis:\n  length w = 0 \\<Longrightarrow> target (w || r1 || r2) (p1, p2) = (p1, p2)\n\ngoal (2 subgoals):\n 1. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 2. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "have \"length w > 0 \\<Longrightarrow> target (w || r1 || r2) (p1,p2) = last (r1 || r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length w \\<Longrightarrow>\n    target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length w \\<Longrightarrow>\n    target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "assume \"length w > 0\""], ["proof (state)\nthis:\n  0 < length w\n\ngoal (1 subgoal):\n 1. 0 < length w \\<Longrightarrow>\n    target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "moreover"], ["proof (state)\nthis:\n  0 < length w\n\ngoal (1 subgoal):\n 1. 0 < length w \\<Longrightarrow>\n    target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "have \"length w = length (r1 || r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length w = length (r1 || r2)", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  length w = length r1\n  length r1 = length r2\n\ngoal (1 subgoal):\n 1. length w = length (r1 || r2)", "by simp"], ["proof (state)\nthis:\n  length w = length (r1 || r2)\n\ngoal (1 subgoal):\n 1. 0 < length w \\<Longrightarrow>\n    target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "ultimately"], ["proof (chain)\npicking this:\n  0 < length w\n  length w = length (r1 || r2)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < length w\n  length w = length (r1 || r2)\n\ngoal (1 subgoal):\n 1. target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "using target_alt_def(2)[of w \"r1 || r2\" \"(p1,p2)\"]"], ["proof (prove)\nusing this:\n  0 < length w\n  length w = length (r1 || r2)\n  \\<lbrakk>length w = length (r1 || r2); 0 < length w\\<rbrakk>\n  \\<Longrightarrow> target (w || r1 || r2) (p1, p2) = last (r1 || r2)\n\ngoal (1 subgoal):\n 1. target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "by simp"], ["proof (state)\nthis:\n  target (w || r1 || r2) (p1, p2) = last (r1 || r2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < length w \\<Longrightarrow>\n  target (w || r1 || r2) (p1, p2) = last (r1 || r2)\n\ngoal (2 subgoals):\n 1. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 2. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "ultimately"], ["proof (chain)\npicking this:\n  length w = 0 \\<Longrightarrow> target (w || r1 || r2) (p1, p2) = (p1, p2)\n  0 < length w \\<Longrightarrow>\n  target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "have \"target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) \n                   \\<and> target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))\""], ["proof (prove)\nusing this:\n  length w = 0 \\<Longrightarrow> target (w || r1 || r2) (p1, p2) = (p1, p2)\n  0 < length w \\<Longrightarrow>\n  target (w || r1 || r2) (p1, p2) = last (r1 || r2)\n\ngoal (1 subgoal):\n 1. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) \\<and>\n    target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "proof (cases \"length w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length w = 0 \\<Longrightarrow>\n             target (w || r1 || r2) (p1, p2) = (p1, p2);\n     0 < length w \\<Longrightarrow>\n     target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n     length w = 0\\<rbrakk>\n    \\<Longrightarrow> target (w || r1) p1 =\n                      fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                      target (w || r2) p2 =\n                      snd (target (w || r1 || r2) (p1, p2))\n 2. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "case 0"], ["proof (state)\nthis:\n  length w = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length w = 0 \\<Longrightarrow>\n             target (w || r1 || r2) (p1, p2) = (p1, p2);\n     0 < length w \\<Longrightarrow>\n     target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n     length w = 0\\<rbrakk>\n    \\<Longrightarrow> target (w || r1) p1 =\n                      fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                      target (w || r2) p2 =\n                      snd (target (w || r1 || r2) (p1, p2))\n 2. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "then"], ["proof (chain)\npicking this:\n  length w = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length w = 0\n\ngoal (1 subgoal):\n 1. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) \\<and>\n    target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "by simp"], ["proof (state)\nthis:\n  target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) \\<and>\n  target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "case (Suc nat)"], ["proof (state)\nthis:\n  length w = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "then"], ["proof (chain)\npicking this:\n  length w = Suc nat", "have \"length w > 0\""], ["proof (prove)\nusing this:\n  length w = Suc nat\n\ngoal (1 subgoal):\n 1. 0 < length w", "by simp"], ["proof (state)\nthis:\n  0 < length w\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "have \"target (w || r1 || r2) (p1,p2) = last (r1 || r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "have \"length w = length (r1 || r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length w = length (r1 || r2)", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  length w = length r1\n  length r1 = length r2\n\ngoal (1 subgoal):\n 1. length w = length (r1 || r2)", "by simp"], ["proof (state)\nthis:\n  length w = length (r1 || r2)\n\ngoal (1 subgoal):\n 1. target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "then"], ["proof (chain)\npicking this:\n  length w = length (r1 || r2)", "show ?thesis"], ["proof (prove)\nusing this:\n  length w = length (r1 || r2)\n\ngoal (1 subgoal):\n 1. target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "using \\<open>length w > 0\\<close> target_alt_def(2)[of w \"r1 || r2\" \"(p1,p2)\"]"], ["proof (prove)\nusing this:\n  length w = length (r1 || r2)\n  0 < length w\n  \\<lbrakk>length w = length (r1 || r2); 0 < length w\\<rbrakk>\n  \\<Longrightarrow> target (w || r1 || r2) (p1, p2) = last (r1 || r2)\n\ngoal (1 subgoal):\n 1. target (w || r1 || r2) (p1, p2) = last (r1 || r2)", "by simp"], ["proof (state)\nthis:\n  target (w || r1 || r2) (p1, p2) = last (r1 || r2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  target (w || r1 || r2) (p1, p2) = last (r1 || r2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "moreover"], ["proof (state)\nthis:\n  target (w || r1 || r2) (p1, p2) = last (r1 || r2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "have \"target (w || r1) p1 = last r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w || r1) p1 = last r1", "using \\<open>length w > 0\\<close> target_alt_def(2)[of w r1 p1] assms(1)"], ["proof (prove)\nusing this:\n  0 < length w\n  \\<lbrakk>length w = length r1; 0 < length w\\<rbrakk>\n  \\<Longrightarrow> target (w || r1) p1 = last r1\n  length w = length r1\n\ngoal (1 subgoal):\n 1. target (w || r1) p1 = last r1", "by simp"], ["proof (state)\nthis:\n  target (w || r1) p1 = last r1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "moreover"], ["proof (state)\nthis:\n  target (w || r1) p1 = last r1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "have \"target (w || r2) p2 = last r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w || r2) p2 = last r2", "using \\<open>length w > 0\\<close> target_alt_def(2)[of w r2 p2] assms(1) assms(2)"], ["proof (prove)\nusing this:\n  0 < length w\n  \\<lbrakk>length w = length r2; 0 < length w\\<rbrakk>\n  \\<Longrightarrow> target (w || r2) p2 = last r2\n  length w = length r1\n  length r1 = length r2\n\ngoal (1 subgoal):\n 1. target (w || r2) p2 = last r2", "by simp"], ["proof (state)\nthis:\n  target (w || r2) p2 = last r2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "moreover"], ["proof (state)\nthis:\n  target (w || r2) p2 = last r2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "have \"last (r1 || r2) = (last r1, last r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (r1 || r2) = (last r1, last r2)", "using \\<open>length w > 0\\<close> assms(1) assms(2) zip_last[of r1 r2]"], ["proof (prove)\nusing this:\n  0 < length w\n  length w = length r1\n  length r1 = length r2\n  \\<lbrakk>0 < length r1; length r1 = length r2\\<rbrakk>\n  \\<Longrightarrow> last (r1 || r2) = (last r1, last r2)\n\ngoal (1 subgoal):\n 1. last (r1 || r2) = (last r1, last r2)", "by simp"], ["proof (state)\nthis:\n  last (r1 || r2) = (last r1, last r2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>length w = 0 \\<Longrightarrow>\n                target (w || r1 || r2) (p1, p2) = (p1, p2);\n        0 < length w \\<Longrightarrow>\n        target (w || r1 || r2) (p1, p2) = last (r1 || r2);\n        length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> target (w || r1) p1 =\n                         fst (target (w || r1 || r2) (p1, p2)) \\<and>\n                         target (w || r2) p2 =\n                         snd (target (w || r1 || r2) (p1, p2))", "ultimately"], ["proof (chain)\npicking this:\n  target (w || r1 || r2) (p1, p2) = last (r1 || r2)\n  target (w || r1) p1 = last r1\n  target (w || r2) p2 = last r2\n  last (r1 || r2) = (last r1, last r2)", "show ?thesis"], ["proof (prove)\nusing this:\n  target (w || r1 || r2) (p1, p2) = last (r1 || r2)\n  target (w || r1) p1 = last r1\n  target (w || r2) p2 = last r2\n  last (r1 || r2) = (last r1, last r2)\n\ngoal (1 subgoal):\n 1. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) \\<and>\n    target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "by simp"], ["proof (state)\nthis:\n  target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) \\<and>\n  target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) \\<and>\n  target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))\n\ngoal (2 subgoals):\n 1. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n 2. target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "then"], ["proof (chain)\npicking this:\n  target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) \\<and>\n  target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "show \"target (w || r1) p1 = fst (target (w || r1 || r2) (p1,p2))\"\n            \"target (w || r2) p2 = snd (target (w || r1 || r2) (p1,p2))\""], ["proof (prove)\nusing this:\n  target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) \\<and>\n  target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))\n\ngoal (1 subgoal):\n 1. target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2)) &&&\n    target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))", "by simp+"], ["proof (state)\nthis:\n  target (w || r1) p1 = fst (target (w || r1 || r2) (p1, p2))\n  target (w || r2) p2 = snd (target (w || r1 || r2) (p1, p2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma productF_path_unzip :\n  assumes \"productF A B FAIL AB\"\n  and     \"path AB (w || tr) q\"\n  and     \"length tr = length w\"\nshows \"path AB (w || (map fst tr || map snd tr)) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB (w || map fst tr || map snd tr) q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path AB (w || map fst tr || map snd tr) q", "have \"map fst tr || map snd tr = tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst tr || map snd tr = tr", "by auto"], ["proof (state)\nthis:\n  map fst tr || map snd tr = tr\n\ngoal (1 subgoal):\n 1. path AB (w || map fst tr || map snd tr) q", "then"], ["proof (chain)\npicking this:\n  map fst tr || map snd tr = tr", "show ?thesis"], ["proof (prove)\nusing this:\n  map fst tr || map snd tr = tr\n\ngoal (1 subgoal):\n 1. path AB (w || map fst tr || map snd tr) q", "using assms"], ["proof (prove)\nusing this:\n  map fst tr || map snd tr = tr\n  productF A B FAIL AB\n  path AB (w || tr) q\n  length tr = length w\n\ngoal (1 subgoal):\n 1. path AB (w || map fst tr || map snd tr) q", "by auto"], ["proof (state)\nthis:\n  path AB (w || map fst tr || map snd tr) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma productF_path_io_targets :\n  assumes \"productF A B FAIL AB\"\n  and     \"io_targets AB (qA,qB) w = {(pA,pB)}\"\n  and     \"w \\<in> language_state A qA\"\n  and     \"w \\<in> language_state B qB\"\n  and     \"observable A\"\n  and     \"observable B\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"qA \\<in> nodes A\"\n  and     \"qB \\<in> nodes B\" \nshows \"pA \\<in> io_targets A qA w\" \"pB \\<in> io_targets B qB w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pA \\<in> io_targets A qA w &&& pB \\<in> io_targets B qB w", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. pA \\<in> io_targets A qA w\n 2. pB \\<in> io_targets B qB w", "obtain tr where tr_def : \"target (w || tr) (qA,qB) = (pA,pB) \n                            \\<and> path AB (w || tr) (qA,qB) \n                            \\<and> length w = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        target (w || tr) (qA, qB) = (pA, pB) \\<and>\n        path AB (w || tr) (qA, qB) \\<and>\n        length w = length tr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  io_targets AB (qA, qB) w = {(pA, pB)}\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        target (w || tr) (qA, qB) = (pA, pB) \\<and>\n        path AB (w || tr) (qA, qB) \\<and>\n        length w = length tr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  target (w || tr) (qA, qB) = (pA, pB) \\<and>\n  path AB (w || tr) (qA, qB) \\<and> length w = length tr\n\ngoal (2 subgoals):\n 1. pA \\<in> io_targets A qA w\n 2. pB \\<in> io_targets B qB w", "have path_A : \"path A (w || map fst tr) qA \\<and> length w = length (map fst tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path A (w || map fst tr) qA \\<and> length w = length (map fst tr)", "using productF_path_reverse_ob_2[of w \"map fst tr\" \"map snd tr\" A B FAIL AB qA qB] \n          assms tr_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>length w = length (map fst tr);\n   length (map fst tr) = length (map snd tr); productF A B FAIL AB;\n   well_formed A; well_formed B;\n   path AB (w || map fst tr || map snd tr) (qA, qB); qA \\<in> nodes A;\n   qB \\<in> nodes B; w \\<in> LS A qA; observable A\\<rbrakk>\n  \\<Longrightarrow> path A (w || map fst tr) qA \\<and>\n                    length w = length (map fst tr)\n  \\<lbrakk>length w = length (map fst tr);\n   length (map fst tr) = length (map snd tr); productF A B FAIL AB;\n   well_formed A; well_formed B;\n   path AB (w || map fst tr || map snd tr) (qA, qB); qA \\<in> nodes A;\n   qB \\<in> nodes B; w \\<in> LS A qA; observable A\\<rbrakk>\n  \\<Longrightarrow> path B (w || map snd tr) qB \\<and>\n                    length w = length (map snd tr)\n  \\<lbrakk>length w = length (map fst tr);\n   length (map fst tr) = length (map snd tr); productF A B FAIL AB;\n   well_formed A; well_formed B;\n   path AB (w || map fst tr || map snd tr) (qA, qB); qA \\<in> nodes A;\n   qB \\<in> nodes B; w \\<in> LS A qA; observable A\\<rbrakk>\n  \\<Longrightarrow> target (w || map fst tr) qA =\n                    fst (target (w || map fst tr || map snd tr) (qA, qB))\n  \\<lbrakk>length w = length (map fst tr);\n   length (map fst tr) = length (map snd tr); productF A B FAIL AB;\n   well_formed A; well_formed B;\n   path AB (w || map fst tr || map snd tr) (qA, qB); qA \\<in> nodes A;\n   qB \\<in> nodes B; w \\<in> LS A qA; observable A\\<rbrakk>\n  \\<Longrightarrow> target (w || map snd tr) qB =\n                    snd (target (w || map fst tr || map snd tr) (qA, qB))\n  productF A B FAIL AB\n  io_targets AB (qA, qB) w = {(pA, pB)}\n  w \\<in> LS A qA\n  w \\<in> LS B qB\n  observable A\n  observable B\n  well_formed A\n  well_formed B\n  qA \\<in> nodes A\n  qB \\<in> nodes B\n  target (w || tr) (qA, qB) = (pA, pB) \\<and>\n  path AB (w || tr) (qA, qB) \\<and> length w = length tr\n\ngoal (1 subgoal):\n 1. path A (w || map fst tr) qA \\<and> length w = length (map fst tr)", "by auto"], ["proof (state)\nthis:\n  path A (w || map fst tr) qA \\<and> length w = length (map fst tr)\n\ngoal (2 subgoals):\n 1. pA \\<in> io_targets A qA w\n 2. pB \\<in> io_targets B qB w", "have path_B : \"path B (w || map snd tr) qB \\<and> length w = length (map snd tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path B (w || map snd tr) qB \\<and> length w = length (map snd tr)", "using productF_path_reverse_ob_2[of w \"map fst tr\" \"map snd tr\" A B FAIL AB qA qB] \n          assms tr_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>length w = length (map fst tr);\n   length (map fst tr) = length (map snd tr); productF A B FAIL AB;\n   well_formed A; well_formed B;\n   path AB (w || map fst tr || map snd tr) (qA, qB); qA \\<in> nodes A;\n   qB \\<in> nodes B; w \\<in> LS A qA; observable A\\<rbrakk>\n  \\<Longrightarrow> path A (w || map fst tr) qA \\<and>\n                    length w = length (map fst tr)\n  \\<lbrakk>length w = length (map fst tr);\n   length (map fst tr) = length (map snd tr); productF A B FAIL AB;\n   well_formed A; well_formed B;\n   path AB (w || map fst tr || map snd tr) (qA, qB); qA \\<in> nodes A;\n   qB \\<in> nodes B; w \\<in> LS A qA; observable A\\<rbrakk>\n  \\<Longrightarrow> path B (w || map snd tr) qB \\<and>\n                    length w = length (map snd tr)\n  \\<lbrakk>length w = length (map fst tr);\n   length (map fst tr) = length (map snd tr); productF A B FAIL AB;\n   well_formed A; well_formed B;\n   path AB (w || map fst tr || map snd tr) (qA, qB); qA \\<in> nodes A;\n   qB \\<in> nodes B; w \\<in> LS A qA; observable A\\<rbrakk>\n  \\<Longrightarrow> target (w || map fst tr) qA =\n                    fst (target (w || map fst tr || map snd tr) (qA, qB))\n  \\<lbrakk>length w = length (map fst tr);\n   length (map fst tr) = length (map snd tr); productF A B FAIL AB;\n   well_formed A; well_formed B;\n   path AB (w || map fst tr || map snd tr) (qA, qB); qA \\<in> nodes A;\n   qB \\<in> nodes B; w \\<in> LS A qA; observable A\\<rbrakk>\n  \\<Longrightarrow> target (w || map snd tr) qB =\n                    snd (target (w || map fst tr || map snd tr) (qA, qB))\n  productF A B FAIL AB\n  io_targets AB (qA, qB) w = {(pA, pB)}\n  w \\<in> LS A qA\n  w \\<in> LS B qB\n  observable A\n  observable B\n  well_formed A\n  well_formed B\n  qA \\<in> nodes A\n  qB \\<in> nodes B\n  target (w || tr) (qA, qB) = (pA, pB) \\<and>\n  path AB (w || tr) (qA, qB) \\<and> length w = length tr\n\ngoal (1 subgoal):\n 1. path B (w || map snd tr) qB \\<and> length w = length (map snd tr)", "by auto"], ["proof (state)\nthis:\n  path B (w || map snd tr) qB \\<and> length w = length (map snd tr)\n\ngoal (2 subgoals):\n 1. pA \\<in> io_targets A qA w\n 2. pB \\<in> io_targets B qB w", "have targets : \"target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB", "proof (cases tr)"], ["proof (state)\ngoal (2 subgoals):\n 1. tr = [] \\<Longrightarrow>\n    target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB\n 2. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "case Nil"], ["proof (state)\nthis:\n  tr = []\n\ngoal (2 subgoals):\n 1. tr = [] \\<Longrightarrow>\n    target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB\n 2. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "then"], ["proof (chain)\npicking this:\n  tr = []", "have \"qA = pA \\<and> qB = pB\""], ["proof (prove)\nusing this:\n  tr = []\n\ngoal (1 subgoal):\n 1. qA = pA \\<and> qB = pB", "using tr_def"], ["proof (prove)\nusing this:\n  tr = []\n  target (w || tr) (qA, qB) = (pA, pB) \\<and>\n  path AB (w || tr) (qA, qB) \\<and> length w = length tr\n\ngoal (1 subgoal):\n 1. qA = pA \\<and> qB = pB", "by auto"], ["proof (state)\nthis:\n  qA = pA \\<and> qB = pB\n\ngoal (2 subgoals):\n 1. tr = [] \\<Longrightarrow>\n    target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB\n 2. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "then"], ["proof (chain)\npicking this:\n  qA = pA \\<and> qB = pB", "show ?thesis"], ["proof (prove)\nusing this:\n  qA = pA \\<and> qB = pB\n\ngoal (1 subgoal):\n 1. target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB", "by (simp add: local.Nil)"], ["proof (state)\nthis:\n  target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "case (Cons a list)"], ["proof (state)\nthis:\n  tr = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "then"], ["proof (chain)\npicking this:\n  tr = a # list", "have \"last tr = (pA,pB)\""], ["proof (prove)\nusing this:\n  tr = a # list\n\ngoal (1 subgoal):\n 1. last tr = (pA, pB)", "using tr_def"], ["proof (prove)\nusing this:\n  tr = a # list\n  target (w || tr) (qA, qB) = (pA, pB) \\<and>\n  path AB (w || tr) (qA, qB) \\<and> length w = length tr\n\ngoal (1 subgoal):\n 1. last tr = (pA, pB)", "by (simp add: tr_def FSM.target_alt_def states_alt_def)"], ["proof (state)\nthis:\n  last tr = (pA, pB)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "moreover"], ["proof (state)\nthis:\n  last tr = (pA, pB)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "have \"target (w || map fst tr) qA = last (map fst tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w || map fst tr) qA = last (map fst tr)", "using Cons"], ["proof (prove)\nusing this:\n  tr = a # list\n\ngoal (1 subgoal):\n 1. target (w || map fst tr) qA = last (map fst tr)", "by (simp add: FSM.target_alt_def states_alt_def tr_def)"], ["proof (state)\nthis:\n  target (w || map fst tr) qA = last (map fst tr)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "moreover"], ["proof (state)\nthis:\n  target (w || map fst tr) qA = last (map fst tr)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "have \"last (map fst tr) = fst (last tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (map fst tr) = fst (last tr)", "using last_map Cons"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> last (map ?f ?xs) = ?f (last ?xs)\n  tr = a # list\n\ngoal (1 subgoal):\n 1. last (map fst tr) = fst (last tr)", "by blast"], ["proof (state)\nthis:\n  last (map fst tr) = fst (last tr)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "moreover"], ["proof (state)\nthis:\n  last (map fst tr) = fst (last tr)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "have \"target (w || map snd tr) qB = last (map snd tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w || map snd tr) qB = last (map snd tr)", "using Cons"], ["proof (prove)\nusing this:\n  tr = a # list\n\ngoal (1 subgoal):\n 1. target (w || map snd tr) qB = last (map snd tr)", "by (simp add: FSM.target_alt_def states_alt_def tr_def)"], ["proof (state)\nthis:\n  target (w || map snd tr) qB = last (map snd tr)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "moreover"], ["proof (state)\nthis:\n  target (w || map snd tr) qB = last (map snd tr)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "have \"last (map snd tr) = snd (last tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (map snd tr) = snd (last tr)", "using last_map Cons"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> last (map ?f ?xs) = ?f (last ?xs)\n  tr = a # list\n\ngoal (1 subgoal):\n 1. last (map snd tr) = snd (last tr)", "by blast"], ["proof (state)\nthis:\n  last (map snd tr) = snd (last tr)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       target (w || map fst tr) qA = pA \\<and>\n       target (w || map snd tr) qB = pB", "ultimately"], ["proof (chain)\npicking this:\n  last tr = (pA, pB)\n  target (w || map fst tr) qA = last (map fst tr)\n  last (map fst tr) = fst (last tr)\n  target (w || map snd tr) qB = last (map snd tr)\n  last (map snd tr) = snd (last tr)", "show ?thesis"], ["proof (prove)\nusing this:\n  last tr = (pA, pB)\n  target (w || map fst tr) qA = last (map fst tr)\n  last (map fst tr) = fst (last tr)\n  target (w || map snd tr) qB = last (map snd tr)\n  last (map snd tr) = snd (last tr)\n\ngoal (1 subgoal):\n 1. target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB", "by simp"], ["proof (state)\nthis:\n  target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB\n\ngoal (2 subgoals):\n 1. pA \\<in> io_targets A qA w\n 2. pB \\<in> io_targets B qB w", "show \"pA \\<in> io_targets A qA w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pA \\<in> io_targets A qA w", "using path_A targets"], ["proof (prove)\nusing this:\n  path A (w || map fst tr) qA \\<and> length w = length (map fst tr)\n  target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB\n\ngoal (1 subgoal):\n 1. pA \\<in> io_targets A qA w", "by auto"], ["proof (state)\nthis:\n  pA \\<in> io_targets A qA w\n\ngoal (1 subgoal):\n 1. pB \\<in> io_targets B qB w", "show \"pB \\<in> io_targets B qB w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pB \\<in> io_targets B qB w", "using path_B targets"], ["proof (prove)\nusing this:\n  path B (w || map snd tr) qB \\<and> length w = length (map snd tr)\n  target (w || map fst tr) qA = pA \\<and> target (w || map snd tr) qB = pB\n\ngoal (1 subgoal):\n 1. pB \\<in> io_targets B qB w", "by auto"], ["proof (state)\nthis:\n  pB \\<in> io_targets B qB w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma productF_path_io_targets_reverse :\n  assumes \"productF A B FAIL AB\"\n  and     \"pA \\<in> io_targets A qA w\" \n  and     \"pB \\<in> io_targets B qB w\"\n  and     \"w \\<in> language_state A qA\"\n  and     \"w \\<in> language_state B qB\"\n  and     \"observable A\"\n  and     \"observable B\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"qA \\<in> nodes A\"\n  and     \"qB \\<in> nodes B\" \nshows \"io_targets AB (qA,qB) w = {(pA,pB)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets AB (qA, qB) w = {(pA, pB)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io_targets AB (qA, qB) w = {(pA, pB)}", "obtain trA where \"path A (w || trA) qA\" \n                   \"length w = length trA\" \n                   \"target (w || trA) qA = pA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trA.\n        \\<lbrakk>path A (w || trA) qA; length w = length trA;\n         target (w || trA) qA = pA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  pA \\<in> io_targets A qA w\n\ngoal (1 subgoal):\n 1. (\\<And>trA.\n        \\<lbrakk>path A (w || trA) qA; length w = length trA;\n         target (w || trA) qA = pA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path A (w || trA) qA\n  length w = length trA\n  target (w || trA) qA = pA\n\ngoal (1 subgoal):\n 1. io_targets AB (qA, qB) w = {(pA, pB)}", "obtain trB where \"path B (w || trB) qB\" \n                   \"length trA = length trB\" \n                   \"target (w || trB) qB = pB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trB.\n        \\<lbrakk>path B (w || trB) qB; length trA = length trB;\n         target (w || trB) qB = pB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>length w = length trA\\<close> assms(3)"], ["proof (prove)\nusing this:\n  length w = length trA\n  pB \\<in> io_targets B qB w\n\ngoal (1 subgoal):\n 1. (\\<And>trB.\n        \\<lbrakk>path B (w || trB) qB; length trA = length trB;\n         target (w || trB) qB = pB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path B (w || trB) qB\n  length trA = length trB\n  target (w || trB) qB = pB\n\ngoal (1 subgoal):\n 1. io_targets AB (qA, qB) w = {(pA, pB)}", "have \"path AB (w || trA || trB) (qA,qB)\"\n       \"length (trA || trB) = length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB (w || trA || trB) (qA, qB) &&& length (trA || trB) = length w", "using productF_path_inclusion\n          [OF \\<open>length w = length trA\\<close> \\<open>length trA = length trB\\<close> assms(1) assms(8,9) _ assms(10,11)]"], ["proof (prove)\nusing this:\n  path A (w || trA) qA \\<and> path B (w || trB) qB \\<Longrightarrow>\n  path AB (w || trA || trB) (qA, qB)\n\ngoal (1 subgoal):\n 1. path AB (w || trA || trB) (qA, qB) &&& length (trA || trB) = length w", "by (simp add: \\<open>length trA = length trB\\<close> \\<open>length w = length trA\\<close> \\<open>path A (w || trA) qA\\<close> \n          \\<open>path B (w || trB) qB\\<close>)+"], ["proof (state)\nthis:\n  path AB (w || trA || trB) (qA, qB)\n  length (trA || trB) = length w\n\ngoal (1 subgoal):\n 1. io_targets AB (qA, qB) w = {(pA, pB)}", "have \"target (w || trA || trB) (qA,qB) = (pA,pB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (w || trA || trB) (qA, qB) = (pA, pB)", "by (simp add: \\<open>length trA = length trB\\<close> \\<open>length w = length trA\\<close> \\<open>target (w || trA) qA = pA\\<close> \n        \\<open>target (w || trB) qB = pB\\<close>)"], ["proof (state)\nthis:\n  target (w || trA || trB) (qA, qB) = (pA, pB)\n\ngoal (1 subgoal):\n 1. io_targets AB (qA, qB) w = {(pA, pB)}", "have \"(pA,pB) \\<in> io_targets AB (qA,qB) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pA, pB) \\<in> io_targets AB (qA, qB) w", "by (metis \\<open>length (trA || trB) = length w\\<close> \\<open>path AB (w || trA || trB) (qA, qB)\\<close> \n        \\<open>target (w || trA || trB) (qA, qB) = (pA, pB)\\<close> io_target_from_path)"], ["proof (state)\nthis:\n  (pA, pB) \\<in> io_targets AB (qA, qB) w\n\ngoal (1 subgoal):\n 1. io_targets AB (qA, qB) w = {(pA, pB)}", "have \"observable AB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable AB", "by (metis (no_types) assms(1) assms(6) assms(7) observable_productF)"], ["proof (state)\nthis:\n  observable AB\n\ngoal (1 subgoal):\n 1. io_targets AB (qA, qB) w = {(pA, pB)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets AB (qA, qB) w = {(pA, pB)}", "by (meson \\<open>(pA, pB) \\<in> io_targets AB (qA, qB) w\\<close> \\<open>observable AB\\<close> \n        observable_io_target_is_singleton)"], ["proof (state)\nthis:\n  io_targets AB (qA, qB) w = {(pA, pB)}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Sequences to failure in the product machine \\<close>"], ["", "text \\<open>\nA sequence to a failure for @{verbatim A} and @{verbatim B} reaches the fail state of any product \nmachine of @{verbatim A} and @{verbatim B} with added fail state.\n\\<close>"], ["", "lemma fail_reachable_by_sequence_to_failure :\n  assumes \"sequence_to_failure M1 M2 io\"\n  and     \"well_formed M1\"\n  and     \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\nobtains p\nwhere \"path PM (io||p) (initial PM) \\<and> length p = length io \\<and> target (io||p) (initial PM) = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"io \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 io\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. io \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  io \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  io \\<noteq> []", "obtain io_init io_last where io_split[simp] : \"io = io_init @ [io_last]\""], ["proof (prove)\nusing this:\n  io \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>io_init io_last.\n        io = io_init @ [io_last] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id)"], ["proof (state)\nthis:\n  io = io_init @ [io_last]\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have io_init_inclusion : \"io_init \\<in> language_state M1 (initial M1) \n                            \\<and> io_init \\<in> language_state M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_init \\<in> L M1 \\<and> io_init \\<in> L M2", "using assms"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 io\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. io_init \\<in> L M1 \\<and> io_init \\<in> L M2", "by auto"], ["proof (state)\nthis:\n  io_init \\<in> L M1 \\<and> io_init \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"io_init @ [io_last] \\<in> language_state M1 (initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_init @ [io_last] \\<in> L M1", "using assms"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 io\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. io_init @ [io_last] \\<in> L M1", "by auto"], ["proof (state)\nthis:\n  io_init @ [io_last] \\<in> L M1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  io_init @ [io_last] \\<in> L M1", "obtain tr1_init tr1_last where tr1_def : \n    \"path M1 (io_init @ [io_last] || tr1_init @ [tr1_last]) (initial M1) \n      \\<and> length (tr1_init @ [tr1_last]) = length (io_init @ [io_last])\""], ["proof (prove)\nusing this:\n  io_init @ [io_last] \\<in> L M1\n\ngoal (1 subgoal):\n 1. (\\<And>tr1_init tr1_last.\n        path M1 (io_init @ [io_last] || tr1_init @ [tr1_last])\n         (initial M1) \\<and>\n        length (tr1_init @ [tr1_last]) =\n        length (io_init @ [io_last]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id language_state_elim length_0_conv length_append_singleton \n        nat.simps(3))"], ["proof (state)\nthis:\n  path M1 (io_init @ [io_last] || tr1_init @ [tr1_last]) (initial M1) \\<and>\n  length (tr1_init @ [tr1_last]) = length (io_init @ [io_last])\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  path M1 (io_init @ [io_last] || tr1_init @ [tr1_last]) (initial M1) \\<and>\n  length (tr1_init @ [tr1_last]) = length (io_init @ [io_last])", "have path_init_1 : \"path M1 (io_init || tr1_init) (initial M1) \n                            \\<and> length tr1_init = length io_init\""], ["proof (prove)\nusing this:\n  path M1 (io_init @ [io_last] || tr1_init @ [tr1_last]) (initial M1) \\<and>\n  length (tr1_init @ [tr1_last]) = length (io_init @ [io_last])\n\ngoal (1 subgoal):\n 1. path M1 (io_init || tr1_init) (initial M1) \\<and>\n    length tr1_init = length io_init", "by auto"], ["proof (state)\nthis:\n  path M1 (io_init || tr1_init) (initial M1) \\<and>\n  length tr1_init = length io_init\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  path M1 (io_init || tr1_init) (initial M1) \\<and>\n  length tr1_init = length io_init", "have \"path M1 ([io_last] || [tr1_last]) (target (io_init || tr1_init) (initial M1))\""], ["proof (prove)\nusing this:\n  path M1 (io_init || tr1_init) (initial M1) \\<and>\n  length tr1_init = length io_init\n\ngoal (1 subgoal):\n 1. path M1 ([io_last] || [tr1_last])\n     (target (io_init || tr1_init) (initial M1))", "using tr1_def"], ["proof (prove)\nusing this:\n  path M1 (io_init || tr1_init) (initial M1) \\<and>\n  length tr1_init = length io_init\n  path M1 (io_init @ [io_last] || tr1_init @ [tr1_last]) (initial M1) \\<and>\n  length (tr1_init @ [tr1_last]) = length (io_init @ [io_last])\n\ngoal (1 subgoal):\n 1. path M1 ([io_last] || [tr1_last])\n     (target (io_init || tr1_init) (initial M1))", "by auto"], ["proof (state)\nthis:\n  path M1 ([io_last] || [tr1_last])\n   (target (io_init || tr1_init) (initial M1))\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  path M1 ([io_last] || [tr1_last])\n   (target (io_init || tr1_init) (initial M1))", "have succ_1 : \"succ M1 io_last (target (io_init || tr1_init) (initial M1)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  path M1 ([io_last] || [tr1_last])\n   (target (io_init || tr1_init) (initial M1))\n\ngoal (1 subgoal):\n 1. succ M1 io_last (target (io_init || tr1_init) (initial M1)) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  succ M1 io_last (target (io_init || tr1_init) (initial M1)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain tr2 where tr2_def : \"path M2 (io_init || tr2) (initial M2) \\<and> length tr2 = length io_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr2.\n        path M2 (io_init || tr2) (initial M2) \\<and>\n        length tr2 = length io_init \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using io_init_inclusion"], ["proof (prove)\nusing this:\n  io_init \\<in> L M1 \\<and> io_init \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>tr2.\n        path M2 (io_init || tr2) (initial M2) \\<and>\n        length tr2 = length io_init \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M2 (io_init || tr2) (initial M2) \\<and> length tr2 = length io_init\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have succ_2 : \"succ M2 io_last (target (io_init || tr2) (initial M2)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ M2 io_last (target (io_init || tr2) (initial M2)) = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. succ M2 io_last (target (io_init || tr2) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"succ M2 io_last (target (io_init || tr2) (initial M2)) \\<noteq> {}\""], ["proof (state)\nthis:\n  succ M2 io_last (target (io_init || tr2) (initial M2)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. succ M2 io_last (target (io_init || tr2) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  succ M2 io_last (target (io_init || tr2) (initial M2)) \\<noteq> {}", "obtain tr2_last where \"tr2_last \\<in> succ M2 io_last (target (io_init || tr2) (initial M2))\""], ["proof (prove)\nusing this:\n  succ M2 io_last (target (io_init || tr2) (initial M2)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>tr2_last.\n        tr2_last\n        \\<in> succ M2 io_last\n               (target (io_init || tr2) (initial M2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tr2_last \\<in> succ M2 io_last (target (io_init || tr2) (initial M2))\n\ngoal (1 subgoal):\n 1. succ M2 io_last (target (io_init || tr2) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  tr2_last \\<in> succ M2 io_last (target (io_init || tr2) (initial M2))", "have \"path M2 ([io_last] || [tr2_last]) (target (io_init || tr2) (initial M2))\""], ["proof (prove)\nusing this:\n  tr2_last \\<in> succ M2 io_last (target (io_init || tr2) (initial M2))\n\ngoal (1 subgoal):\n 1. path M2 ([io_last] || [tr2_last]) (target (io_init || tr2) (initial M2))", "by auto"], ["proof (state)\nthis:\n  path M2 ([io_last] || [tr2_last]) (target (io_init || tr2) (initial M2))\n\ngoal (1 subgoal):\n 1. succ M2 io_last (target (io_init || tr2) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  path M2 ([io_last] || [tr2_last]) (target (io_init || tr2) (initial M2))", "have \"io_init @ [io_last] \\<in> language_state M2 (initial M2)\""], ["proof (prove)\nusing this:\n  path M2 ([io_last] || [tr2_last]) (target (io_init || tr2) (initial M2))\n\ngoal (1 subgoal):\n 1. io_init @ [io_last] \\<in> L M2", "by (metis FSM.path_append language_state length_Cons length_append list.size(3) tr2_def \n          zip_append)"], ["proof (state)\nthis:\n  io_init @ [io_last] \\<in> L M2\n\ngoal (1 subgoal):\n 1. succ M2 io_last (target (io_init || tr2) (initial M2)) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  io_init @ [io_last] \\<in> L M2", "show \"False\""], ["proof (prove)\nusing this:\n  io_init @ [io_last] \\<in> L M2\n\ngoal (1 subgoal):\n 1. False", "using assms io_split"], ["proof (prove)\nusing this:\n  io_init @ [io_last] \\<in> L M2\n  sequence_to_failure M1 M2 io\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  io = io_init @ [io_last]\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  succ M2 io_last (target (io_init || tr2) (initial M2)) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have fail_lengths : \"length (io_init @ [io_last]) = length (tr2 @ [fst FAIL]) \n                        \\<and> length (tr2 @ [fst FAIL]) = length (tr1_init @ [snd FAIL])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (io_init @ [io_last]) = length (tr2 @ [fst FAIL]) \\<and>\n    length (tr2 @ [fst FAIL]) = length (tr1_init @ [snd FAIL])", "using assms tr2_def tr1_def"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 io\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  path M2 (io_init || tr2) (initial M2) \\<and> length tr2 = length io_init\n  path M1 (io_init @ [io_last] || tr1_init @ [tr1_last]) (initial M1) \\<and>\n  length (tr1_init @ [tr1_last]) = length (io_init @ [io_last])\n\ngoal (1 subgoal):\n 1. length (io_init @ [io_last]) = length (tr2 @ [fst FAIL]) \\<and>\n    length (tr2 @ [fst FAIL]) = length (tr1_init @ [snd FAIL])", "by auto"], ["proof (state)\nthis:\n  length (io_init @ [io_last]) = length (tr2 @ [fst FAIL]) \\<and>\n  length (tr2 @ [fst FAIL]) = length (tr1_init @ [snd FAIL])\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  length (io_init @ [io_last]) = length (tr2 @ [fst FAIL]) \\<and>\n  length (tr2 @ [fst FAIL]) = length (tr1_init @ [snd FAIL])", "have fail_tgt : \"target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) \n                                (initial M2, initial M1) = FAIL\""], ["proof (prove)\nusing this:\n  length (io_init @ [io_last]) = length (tr2 @ [fst FAIL]) \\<and>\n  length (tr2 @ [fst FAIL]) = length (tr1_init @ [snd FAIL])\n\ngoal (1 subgoal):\n 1. target\n     (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n     (initial M2, initial M1) =\n    FAIL", "by auto"], ["proof (state)\nthis:\n  target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial M2, initial M1) =\n  FAIL\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have fail_butlast_simp[simp] : \n    \"butlast (io_init @ [io_last] || tr2 @ [fst FAIL]) = io_init || tr2\" \n    \"butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]) = io_init || tr1_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (io_init @ [io_last] || tr2 @ [fst FAIL]) = io_init || tr2 &&&\n    butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]) =\n    io_init || tr1_init", "using fail_lengths"], ["proof (prove)\nusing this:\n  length (io_init @ [io_last]) = length (tr2 @ [fst FAIL]) \\<and>\n  length (tr2 @ [fst FAIL]) = length (tr1_init @ [snd FAIL])\n\ngoal (1 subgoal):\n 1. butlast (io_init @ [io_last] || tr2 @ [fst FAIL]) = io_init || tr2 &&&\n    butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]) =\n    io_init || tr1_init", "by simp+"], ["proof (state)\nthis:\n  butlast (io_init @ [io_last] || tr2 @ [fst FAIL]) = io_init || tr2\n  butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]) =\n  io_init || tr1_init\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"path M2 (butlast (io_init @ [io_last] || tr2 @ [fst FAIL])) (initial M2) \n        \\<and> path M1 (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL])) (initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M2 (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n     (initial M2) \\<and>\n    path M1 (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n     (initial M1)", "using tr1_def tr2_def"], ["proof (prove)\nusing this:\n  path M1 (io_init @ [io_last] || tr1_init @ [tr1_last]) (initial M1) \\<and>\n  length (tr1_init @ [tr1_last]) = length (io_init @ [io_last])\n  path M2 (io_init || tr2) (initial M2) \\<and> length tr2 = length io_init\n\ngoal (1 subgoal):\n 1. path M2 (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n     (initial M2) \\<and>\n    path M1 (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n     (initial M1)", "by auto"], ["proof (state)\nthis:\n  path M2 (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n   (initial M2) \\<and>\n  path M1 (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n   (initial M1)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  path M2 (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n   (initial M2) \\<and>\n  path M1 (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n   (initial M1)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"succ M2 (last (io_init @ [io_last])) \n                    (target (butlast (io_init @ [io_last] || tr2 @ [fst FAIL])) (initial M2)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ M2 (last (io_init @ [io_last]))\n     (target (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n       (initial M2)) =\n    {}", "using succ_2"], ["proof (prove)\nusing this:\n  succ M2 io_last (target (io_init || tr2) (initial M2)) = {}\n\ngoal (1 subgoal):\n 1. succ M2 (last (io_init @ [io_last]))\n     (target (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n       (initial M2)) =\n    {}", "by simp"], ["proof (state)\nthis:\n  succ M2 (last (io_init @ [io_last]))\n   (target (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n     (initial M2)) =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  succ M2 (last (io_init @ [io_last]))\n   (target (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n     (initial M2)) =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"succ M1 (last (io_init @ [io_last])) \n                  (target (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL])) (initial M1)) \n                 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ M1 (last (io_init @ [io_last]))\n     (target (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n       (initial M1)) \\<noteq>\n    {}", "using succ_1"], ["proof (prove)\nusing this:\n  succ M1 io_last (target (io_init || tr1_init) (initial M1)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. succ M1 (last (io_init @ [io_last]))\n     (target (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n       (initial M1)) \\<noteq>\n    {}", "by simp"], ["proof (state)\nthis:\n  succ M1 (last (io_init @ [io_last]))\n   (target (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  succ M1 (last (io_init @ [io_last]))\n   (target (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"initial M2 \\<in> nodes M2 \\<and> initial M1 \\<in> nodes M1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial M2 \\<in> nodes M2 \\<and> initial M1 \\<in> nodes M1", "by auto"], ["proof (state)\nthis:\n  initial M2 \\<in> nodes M2 \\<and> initial M1 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  path M2 (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n   (initial M2) \\<and>\n  path M1 (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n   (initial M1)\n  succ M2 (last (io_init @ [io_last]))\n   (target (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n     (initial M2)) =\n  {}\n  succ M1 (last (io_init @ [io_last]))\n   (target (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n     (initial M1)) \\<noteq>\n  {}\n  initial M2 \\<in> nodes M2 \\<and> initial M1 \\<in> nodes M1", "have \"path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) \n                    (initial M2, initial M1)\""], ["proof (prove)\nusing this:\n  path M2 (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n   (initial M2) \\<and>\n  path M1 (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n   (initial M1)\n  succ M2 (last (io_init @ [io_last]))\n   (target (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n     (initial M2)) =\n  {}\n  succ M1 (last (io_init @ [io_last]))\n   (target (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n     (initial M1)) \\<noteq>\n  {}\n  initial M2 \\<in> nodes M2 \\<and> initial M1 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. path PM\n     (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n     (initial M2, initial M1)", "using fail_lengths fail_tgt assms path_init_1 tr2_def productF_path_forward\n          [of \"io_init @ [io_last]\" \"tr2 @ [fst FAIL]\" \"tr1_init @ [snd FAIL]\" M2 M1 FAIL PM \n              \"initial M2\" \"initial M1\" ]"], ["proof (prove)\nusing this:\n  path M2 (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n   (initial M2) \\<and>\n  path M1 (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n   (initial M1)\n  succ M2 (last (io_init @ [io_last]))\n   (target (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n     (initial M2)) =\n  {}\n  succ M1 (last (io_init @ [io_last]))\n   (target (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n     (initial M1)) \\<noteq>\n  {}\n  initial M2 \\<in> nodes M2 \\<and> initial M1 \\<in> nodes M1\n  length (io_init @ [io_last]) = length (tr2 @ [fst FAIL]) \\<and>\n  length (tr2 @ [fst FAIL]) = length (tr1_init @ [snd FAIL])\n  target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial M2, initial M1) =\n  FAIL\n  sequence_to_failure M1 M2 io\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  path M1 (io_init || tr1_init) (initial M1) \\<and>\n  length tr1_init = length io_init\n  path M2 (io_init || tr2) (initial M2) \\<and> length tr2 = length io_init\n  \\<lbrakk>length (io_init @ [io_last]) = length (tr2 @ [fst FAIL]);\n   length (tr2 @ [fst FAIL]) = length (tr1_init @ [snd FAIL]);\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path M2 (io_init @ [io_last] || tr2 @ [fst FAIL]) (initial M2) \\<and>\n   path M1 (io_init @ [io_last] || tr1_init @ [snd FAIL]) (initial M1) \\<or>\n   target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n    (initial M2, initial M1) =\n   FAIL \\<and>\n   0 < length (io_init @ [io_last]) \\<and>\n   path M2 (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n    (initial M2) \\<and>\n   path M1 (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n    (initial M1) \\<and>\n   succ M2 (last (io_init @ [io_last]))\n    (target (butlast (io_init @ [io_last] || tr2 @ [fst FAIL]))\n      (initial M2)) =\n   {} \\<and>\n   succ M1 (last (io_init @ [io_last]))\n    (target (butlast (io_init @ [io_last] || tr1_init @ [snd FAIL]))\n      (initial M1)) \\<noteq>\n   {};\n   initial M2 \\<in> nodes M2; initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> path PM\n                     (io_init @ [io_last] ||\n                      tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n                     (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. path PM\n     (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n     (initial M2, initial M1)", "by simp"], ["proof (state)\nthis:\n  path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"initial PM = (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial PM = (initial M2, initial M1)", "using assms(4) productF_simps(4)"], ["proof (prove)\nusing this:\n  productF M2 M1 FAIL PM\n  productF ?A ?B ?FAIL ?AB \\<Longrightarrow>\n  initial ?AB = (initial ?A, initial ?B)\n\ngoal (1 subgoal):\n 1. initial PM = (initial M2, initial M1)", "by blast"], ["proof (state)\nthis:\n  initial PM = (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial M2, initial M1)\n  initial PM = (initial M2, initial M1)", "have \n    \"path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) (initial PM)\n     \\<and> length (tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) = length (io_init @ [io_last])\n     \\<and> target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) (initial PM)= FAIL\""], ["proof (prove)\nusing this:\n  path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial M2, initial M1)\n  initial PM = (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. path PM\n     (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n     (initial PM) \\<and>\n    length (tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) =\n    length (io_init @ [io_last]) \\<and>\n    target\n     (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n     (initial PM) =\n    FAIL", "using fail_lengths fail_tgt"], ["proof (prove)\nusing this:\n  path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial M2, initial M1)\n  initial PM = (initial M2, initial M1)\n  length (io_init @ [io_last]) = length (tr2 @ [fst FAIL]) \\<and>\n  length (tr2 @ [fst FAIL]) = length (tr1_init @ [snd FAIL])\n  target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial M2, initial M1) =\n  FAIL\n\ngoal (1 subgoal):\n 1. path PM\n     (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n     (initial PM) \\<and>\n    length (tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) =\n    length (io_init @ [io_last]) \\<and>\n    target\n     (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n     (initial PM) =\n    FAIL", "by auto"], ["proof (state)\nthis:\n  path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial PM) \\<and>\n  length (tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) =\n  length (io_init @ [io_last]) \\<and>\n  target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial PM) =\n  FAIL\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial PM) \\<and>\n  length (tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) =\n  length (io_init @ [io_last]) \\<and>\n  target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial PM) =\n  FAIL", "show ?thesis"], ["proof (prove)\nusing this:\n  path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial PM) \\<and>\n  length (tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) =\n  length (io_init @ [io_last]) \\<and>\n  target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial PM) =\n  FAIL\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial PM) \\<and>\n  length (tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) =\n  length (io_init @ [io_last]) \\<and>\n  target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial PM) =\n  FAIL\n  path PM (io || ?p) (initial PM) \\<and>\n  length ?p = length io \\<and>\n  target (io || ?p) (initial PM) = FAIL \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "using io_split"], ["proof (prove)\nusing this:\n  path PM (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial PM) \\<and>\n  length (tr2 @ [fst FAIL] || tr1_init @ [snd FAIL]) =\n  length (io_init @ [io_last]) \\<and>\n  target (io_init @ [io_last] || tr2 @ [fst FAIL] || tr1_init @ [snd FAIL])\n   (initial PM) =\n  FAIL\n  path PM (io || ?p) (initial PM) \\<and>\n  length ?p = length io \\<and>\n  target (io || ?p) (initial PM) = FAIL \\<Longrightarrow>\n  thesis\n  io = io_init @ [io_last]\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fail_reachable :\n  assumes \"\\<not> M1 \\<preceq> M2\"\n  and     \"well_formed M1\"\n  and     \"well_formed M2\"\n  and \"productF M2 M1 FAIL PM\"\nshows \"FAIL \\<in> reachable PM (initial PM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<in> reachable PM (initial PM)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. FAIL \\<in> reachable PM (initial PM)", "obtain io where \"sequence_to_failure M1 M2 io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sequence_to_failure_ob assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?M1.0 \\<preceq> ?M2.0; well_formed ?M1.0;\n   well_formed ?M2.0;\n   \\<And>io.\n      sequence_to_failure ?M1.0 ?M2.0 io \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<not> M1 \\<preceq> M2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. (\\<And>io.\n        sequence_to_failure M1 M2 io \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 io\n\ngoal (1 subgoal):\n 1. FAIL \\<in> reachable PM (initial PM)", "then"], ["proof (chain)\npicking this:\n  sequence_to_failure M1 M2 io", "show ?thesis"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 io\n\ngoal (1 subgoal):\n 1. FAIL \\<in> reachable PM (initial PM)", "using assms fail_reachable_by_sequence_to_failure[of M1 M2 io FAIL PM]"], ["proof (prove)\nusing this:\n  sequence_to_failure M1 M2 io\n  \\<not> M1 \\<preceq> M2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  \\<lbrakk>sequence_to_failure M1 M2 io; well_formed M1; well_formed M2;\n   productF M2 M1 FAIL PM;\n   \\<And>p.\n      path PM (io || p) (initial PM) \\<and>\n      length p = length io \\<and>\n      target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. FAIL \\<in> reachable PM (initial PM)", "by (metis FSM.reachable.reflexive FSM.reachable_target)"], ["proof (state)\nthis:\n  FAIL \\<in> reachable PM (initial PM)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fail_reachable_ob :\n  assumes \"\\<not> M1 \\<preceq> M2\"\n  and     \"well_formed M1\"\n  and     \"well_formed M2\"\n  and     \"observable M2\"\n  and \"productF M2 M1 FAIL PM\"\nobtains p\nwhere \"path PM p (initial PM)\" \"target p (initial PM) = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path PM p (initial PM);\n         target p (initial PM) = FAIL\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms fail_reachable"], ["proof (prove)\nusing this:\n  \\<not> M1 \\<preceq> M2\n  well_formed M1\n  well_formed M2\n  observable M2\n  productF M2 M1 FAIL PM\n  \\<lbrakk>\\<not> ?M1.0 \\<preceq> ?M2.0; well_formed ?M1.0;\n   well_formed ?M2.0; productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> ?FAIL \\<in> reachable ?PM (initial ?PM)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path PM p (initial PM);\n         target p (initial PM) = FAIL\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis FSM.reachable_target_elim)"], ["", "lemma fail_reachable_reverse : \n  assumes \"well_formed M1\"\n  and     \"well_formed M2\" \n  and     \"productF M2 M1 FAIL PM\"\n  and     \"FAIL \\<in> reachable PM (initial PM)\"\n  and     \"observable M2\"\nshows \"\\<not> M1 \\<preceq> M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "obtain pathF where pathF_def : \"path PM pathF (initial PM) \\<and> target pathF (initial PM) = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pathF.\n        path PM pathF (initial PM) \\<and>\n        target pathF (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  FAIL \\<in> reachable PM (initial PM)\n  observable M2\n\ngoal (1 subgoal):\n 1. (\\<And>pathF.\n        path PM pathF (initial PM) \\<and>\n        target pathF (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path PM pathF (initial PM) \\<and> target pathF (initial PM) = FAIL\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "let ?io = \"map fst pathF\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "let ?tr2 = \"map fst (map snd pathF)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "let ?tr1 = \"map snd (map snd pathF)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "have \"initial PM \\<noteq> FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial PM \\<noteq> FAIL", "using assms"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  FAIL \\<in> reachable PM (initial PM)\n  observable M2\n\ngoal (1 subgoal):\n 1. initial PM \\<noteq> FAIL", "by auto"], ["proof (state)\nthis:\n  initial PM \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "then"], ["proof (chain)\npicking this:\n  initial PM \\<noteq> FAIL", "have \"pathF \\<noteq> []\""], ["proof (prove)\nusing this:\n  initial PM \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. pathF \\<noteq> []", "using pathF_def"], ["proof (prove)\nusing this:\n  initial PM \\<noteq> FAIL\n  path PM pathF (initial PM) \\<and> target pathF (initial PM) = FAIL\n\ngoal (1 subgoal):\n 1. pathF \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  pathF \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "moreover"], ["proof (state)\nthis:\n  pathF \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "have \"initial PM = (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial PM = (initial M2, initial M1)", "using assms"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  FAIL \\<in> reachable PM (initial PM)\n  observable M2\n\ngoal (1 subgoal):\n 1. initial PM = (initial M2, initial M1)", "by simp"], ["proof (state)\nthis:\n  initial PM = (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "ultimately"], ["proof (chain)\npicking this:\n  pathF \\<noteq> []\n  initial PM = (initial M2, initial M1)", "have \"path M2 (?io || ?tr2) (initial M2) \\<and> path M1 (?io || ?tr1) (initial M1) \\<or>\n                    target (?io || ?tr2 || ?tr1) (initial M2, initial M1) = FAIL \\<and>\n                    0 < length (?io) \\<and>\n                    path M2 (butlast (?io || ?tr2)) (initial M2) \\<and>\n                    path M1 (butlast (?io || ?tr1)) (initial M1) \\<and>\n                    succ M2 (last (?io)) (target (butlast (?io || ?tr2)) (initial M2)) = {} \\<and>\n                    succ M1 (last (?io)) (target (butlast (?io || ?tr1)) (initial M1)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  pathF \\<noteq> []\n  initial PM = (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. path M2 (map fst pathF || map fst (map snd pathF)) (initial M2) \\<and>\n    path M1 (map fst pathF || map snd (map snd pathF)) (initial M1) \\<or>\n    target\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1) =\n    FAIL \\<and>\n    0 < length (map fst pathF) \\<and>\n    path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2) \\<and>\n    path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1) \\<and>\n    succ M2 (last (map fst pathF))\n     (target (butlast (map fst pathF || map fst (map snd pathF)))\n       (initial M2)) =\n    {} \\<and>\n    succ M1 (last (map fst pathF))\n     (target (butlast (map fst pathF || map snd (map snd pathF)))\n       (initial M1)) \\<noteq>\n    {}", "using productF_path_reverse[of ?io ?tr2 ?tr1 M2 M1 FAIL PM \"initial M2\" \"initial M1\"]"], ["proof (prove)\nusing this:\n  pathF \\<noteq> []\n  initial PM = (initial M2, initial M1)\n  \\<lbrakk>length (map fst pathF) = length (map fst (map snd pathF));\n   length (map fst (map snd pathF)) = length (map snd (map snd pathF));\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path PM\n    (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n    (initial M2, initial M1);\n   initial M2 \\<in> nodes M2; initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> path M2 (map fst pathF || map fst (map snd pathF))\n                     (initial M2) \\<and>\n                    path M1 (map fst pathF || map snd (map snd pathF))\n                     (initial M1) \\<or>\n                    target\n                     (map fst pathF ||\n                      map fst (map snd pathF) || map snd (map snd pathF))\n                     (initial M2, initial M1) =\n                    FAIL \\<and>\n                    0 < length (map fst pathF) \\<and>\n                    path M2\n                     (butlast (map fst pathF || map fst (map snd pathF)))\n                     (initial M2) \\<and>\n                    path M1\n                     (butlast (map fst pathF || map snd (map snd pathF)))\n                     (initial M1) \\<and>\n                    succ M2 (last (map fst pathF))\n                     (target\n                       (butlast (map fst pathF || map fst (map snd pathF)))\n                       (initial M2)) =\n                    {} \\<and>\n                    succ M1 (last (map fst pathF))\n                     (target\n                       (butlast (map fst pathF || map snd (map snd pathF)))\n                       (initial M1)) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. path M2 (map fst pathF || map fst (map snd pathF)) (initial M2) \\<and>\n    path M1 (map fst pathF || map snd (map snd pathF)) (initial M1) \\<or>\n    target\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1) =\n    FAIL \\<and>\n    0 < length (map fst pathF) \\<and>\n    path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2) \\<and>\n    path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1) \\<and>\n    succ M2 (last (map fst pathF))\n     (target (butlast (map fst pathF || map fst (map snd pathF)))\n       (initial M2)) =\n    {} \\<and>\n    succ M1 (last (map fst pathF))\n     (target (butlast (map fst pathF || map snd (map snd pathF)))\n       (initial M1)) \\<noteq>\n    {}", "using assms pathF_def"], ["proof (prove)\nusing this:\n  pathF \\<noteq> []\n  initial PM = (initial M2, initial M1)\n  \\<lbrakk>length (map fst pathF) = length (map fst (map snd pathF));\n   length (map fst (map snd pathF)) = length (map snd (map snd pathF));\n   productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n   path PM\n    (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n    (initial M2, initial M1);\n   initial M2 \\<in> nodes M2; initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> path M2 (map fst pathF || map fst (map snd pathF))\n                     (initial M2) \\<and>\n                    path M1 (map fst pathF || map snd (map snd pathF))\n                     (initial M1) \\<or>\n                    target\n                     (map fst pathF ||\n                      map fst (map snd pathF) || map snd (map snd pathF))\n                     (initial M2, initial M1) =\n                    FAIL \\<and>\n                    0 < length (map fst pathF) \\<and>\n                    path M2\n                     (butlast (map fst pathF || map fst (map snd pathF)))\n                     (initial M2) \\<and>\n                    path M1\n                     (butlast (map fst pathF || map snd (map snd pathF)))\n                     (initial M1) \\<and>\n                    succ M2 (last (map fst pathF))\n                     (target\n                       (butlast (map fst pathF || map fst (map snd pathF)))\n                       (initial M2)) =\n                    {} \\<and>\n                    succ M1 (last (map fst pathF))\n                     (target\n                       (butlast (map fst pathF || map snd (map snd pathF)))\n                       (initial M1)) \\<noteq>\n                    {}\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  FAIL \\<in> reachable PM (initial PM)\n  observable M2\n  path PM pathF (initial PM) \\<and> target pathF (initial PM) = FAIL\n\ngoal (1 subgoal):\n 1. path M2 (map fst pathF || map fst (map snd pathF)) (initial M2) \\<and>\n    path M1 (map fst pathF || map snd (map snd pathF)) (initial M1) \\<or>\n    target\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1) =\n    FAIL \\<and>\n    0 < length (map fst pathF) \\<and>\n    path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2) \\<and>\n    path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1) \\<and>\n    succ M2 (last (map fst pathF))\n     (target (butlast (map fst pathF || map fst (map snd pathF)))\n       (initial M2)) =\n    {} \\<and>\n    succ M1 (last (map fst pathF))\n     (target (butlast (map fst pathF || map snd (map snd pathF)))\n       (initial M1)) \\<noteq>\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>pathF \\<noteq> []; initial PM = (initial M2, initial M1);\n     \\<lbrakk>length (map fst pathF) = length (map fst (map snd pathF));\n      length (map fst (map snd pathF)) = length (map snd (map snd pathF));\n      productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n      path PM\n       (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n       (initial M2, initial M1);\n      initial M2 \\<in> nodes M2; initial M1 \\<in> nodes M1\\<rbrakk>\n     \\<Longrightarrow> path M2 (map fst pathF || map fst (map snd pathF))\n                        (initial M2) \\<and>\n                       path M1 (map fst pathF || map snd (map snd pathF))\n                        (initial M1) \\<or>\n                       target\n                        (map fst pathF ||\n                         map fst (map snd pathF) || map snd (map snd pathF))\n                        (initial M2, initial M1) =\n                       FAIL \\<and>\n                       0 < length (map fst pathF) \\<and>\n                       path M2\n                        (butlast (map fst pathF || map fst (map snd pathF)))\n                        (initial M2) \\<and>\n                       path M1\n                        (butlast (map fst pathF || map snd (map snd pathF)))\n                        (initial M1) \\<and>\n                       succ M2 (last (map fst pathF))\n                        (target\n                          (butlast\n                            (map fst pathF || map fst (map snd pathF)))\n                          (initial M2)) =\n                       {} \\<and>\n                       succ M1 (last (map fst pathF))\n                        (target\n                          (butlast\n                            (map fst pathF || map snd (map snd pathF)))\n                          (initial M1)) \\<noteq>\n                       {};\n     well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n     FAIL \\<in> reachable PM (initial PM); observable M2;\n     path PM pathF (initial PM) \\<and>\n     target pathF (initial PM) = FAIL\\<rbrakk>\n    \\<Longrightarrow> path M2 (map fst pathF || map fst (map snd pathF))\n                       (initial M2) \\<and>\n                      path M1 (map fst pathF || map snd (map snd pathF))\n                       (initial M1) \\<or>\n                      target\n                       (map fst pathF ||\n                        map fst (map snd pathF) || map snd (map snd pathF))\n                       (initial M2, initial M1) =\n                      FAIL \\<and>\n                      0 < length (map fst pathF) \\<and>\n                      path M2\n                       (butlast (map fst pathF || map fst (map snd pathF)))\n                       (initial M2) \\<and>\n                      path M1\n                       (butlast (map fst pathF || map snd (map snd pathF)))\n                       (initial M1) \\<and>\n                      succ M2 (last (map fst pathF))\n                       (target\n                         (butlast\n                           (map fst pathF || map fst (map snd pathF)))\n                         (initial M2)) =\n                      {} \\<and>\n                      succ M1 (last (map fst pathF))\n                       (target\n                         (butlast\n                           (map fst pathF || map snd (map snd pathF)))\n                         (initial M1)) \\<noteq>\n                      {}", "have f1: \"path PM (?io || ?tr2 || ?tr1) (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1)", "by (metis (no_types) \\<open>initial PM = (initial M2, initial M1)\\<close> pathF_def zip_map_fst_snd)"], ["proof (state)\nthis:\n  path PM\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pathF \\<noteq> []; initial PM = (initial M2, initial M1);\n     \\<lbrakk>length (map fst pathF) = length (map fst (map snd pathF));\n      length (map fst (map snd pathF)) = length (map snd (map snd pathF));\n      productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n      path PM\n       (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n       (initial M2, initial M1);\n      initial M2 \\<in> nodes M2; initial M1 \\<in> nodes M1\\<rbrakk>\n     \\<Longrightarrow> path M2 (map fst pathF || map fst (map snd pathF))\n                        (initial M2) \\<and>\n                       path M1 (map fst pathF || map snd (map snd pathF))\n                        (initial M1) \\<or>\n                       target\n                        (map fst pathF ||\n                         map fst (map snd pathF) || map snd (map snd pathF))\n                        (initial M2, initial M1) =\n                       FAIL \\<and>\n                       0 < length (map fst pathF) \\<and>\n                       path M2\n                        (butlast (map fst pathF || map fst (map snd pathF)))\n                        (initial M2) \\<and>\n                       path M1\n                        (butlast (map fst pathF || map snd (map snd pathF)))\n                        (initial M1) \\<and>\n                       succ M2 (last (map fst pathF))\n                        (target\n                          (butlast\n                            (map fst pathF || map fst (map snd pathF)))\n                          (initial M2)) =\n                       {} \\<and>\n                       succ M1 (last (map fst pathF))\n                        (target\n                          (butlast\n                            (map fst pathF || map snd (map snd pathF)))\n                          (initial M1)) \\<noteq>\n                       {};\n     well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n     FAIL \\<in> reachable PM (initial PM); observable M2;\n     path PM pathF (initial PM) \\<and>\n     target pathF (initial PM) = FAIL\\<rbrakk>\n    \\<Longrightarrow> path M2 (map fst pathF || map fst (map snd pathF))\n                       (initial M2) \\<and>\n                      path M1 (map fst pathF || map snd (map snd pathF))\n                       (initial M1) \\<or>\n                      target\n                       (map fst pathF ||\n                        map fst (map snd pathF) || map snd (map snd pathF))\n                       (initial M2, initial M1) =\n                      FAIL \\<and>\n                      0 < length (map fst pathF) \\<and>\n                      path M2\n                       (butlast (map fst pathF || map fst (map snd pathF)))\n                       (initial M2) \\<and>\n                      path M1\n                       (butlast (map fst pathF || map snd (map snd pathF)))\n                       (initial M1) \\<and>\n                      succ M2 (last (map fst pathF))\n                       (target\n                         (butlast\n                           (map fst pathF || map fst (map snd pathF)))\n                         (initial M2)) =\n                      {} \\<and>\n                      succ M1 (last (map fst pathF))\n                       (target\n                         (butlast\n                           (map fst pathF || map snd (map snd pathF)))\n                         (initial M1)) \\<noteq>\n                      {}", "have f2: \"length (?io) = length pathF \\<longrightarrow> length (?io) = length (?tr2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst pathF) = length pathF \\<longrightarrow>\n    length (map fst pathF) = length (map fst (map snd pathF))", "by auto"], ["proof (state)\nthis:\n  length (map fst pathF) = length pathF \\<longrightarrow>\n  length (map fst pathF) = length (map fst (map snd pathF))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pathF \\<noteq> []; initial PM = (initial M2, initial M1);\n     \\<lbrakk>length (map fst pathF) = length (map fst (map snd pathF));\n      length (map fst (map snd pathF)) = length (map snd (map snd pathF));\n      productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n      path PM\n       (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n       (initial M2, initial M1);\n      initial M2 \\<in> nodes M2; initial M1 \\<in> nodes M1\\<rbrakk>\n     \\<Longrightarrow> path M2 (map fst pathF || map fst (map snd pathF))\n                        (initial M2) \\<and>\n                       path M1 (map fst pathF || map snd (map snd pathF))\n                        (initial M1) \\<or>\n                       target\n                        (map fst pathF ||\n                         map fst (map snd pathF) || map snd (map snd pathF))\n                        (initial M2, initial M1) =\n                       FAIL \\<and>\n                       0 < length (map fst pathF) \\<and>\n                       path M2\n                        (butlast (map fst pathF || map fst (map snd pathF)))\n                        (initial M2) \\<and>\n                       path M1\n                        (butlast (map fst pathF || map snd (map snd pathF)))\n                        (initial M1) \\<and>\n                       succ M2 (last (map fst pathF))\n                        (target\n                          (butlast\n                            (map fst pathF || map fst (map snd pathF)))\n                          (initial M2)) =\n                       {} \\<and>\n                       succ M1 (last (map fst pathF))\n                        (target\n                          (butlast\n                            (map fst pathF || map snd (map snd pathF)))\n                          (initial M1)) \\<noteq>\n                       {};\n     well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n     FAIL \\<in> reachable PM (initial PM); observable M2;\n     path PM pathF (initial PM) \\<and>\n     target pathF (initial PM) = FAIL\\<rbrakk>\n    \\<Longrightarrow> path M2 (map fst pathF || map fst (map snd pathF))\n                       (initial M2) \\<and>\n                      path M1 (map fst pathF || map snd (map snd pathF))\n                       (initial M1) \\<or>\n                      target\n                       (map fst pathF ||\n                        map fst (map snd pathF) || map snd (map snd pathF))\n                       (initial M2, initial M1) =\n                      FAIL \\<and>\n                      0 < length (map fst pathF) \\<and>\n                      path M2\n                       (butlast (map fst pathF || map fst (map snd pathF)))\n                       (initial M2) \\<and>\n                      path M1\n                       (butlast (map fst pathF || map snd (map snd pathF)))\n                       (initial M1) \\<and>\n                      succ M2 (last (map fst pathF))\n                       (target\n                         (butlast\n                           (map fst pathF || map fst (map snd pathF)))\n                         (initial M2)) =\n                      {} \\<and>\n                      succ M1 (last (map fst pathF))\n                       (target\n                         (butlast\n                           (map fst pathF || map snd (map snd pathF)))\n                         (initial M1)) \\<noteq>\n                      {}", "have \"length (?io) = length pathF \\<and> length (?tr2) = length (?tr1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst pathF) = length pathF \\<and>\n    length (map fst (map snd pathF)) = length (map snd (map snd pathF))", "by auto"], ["proof (state)\nthis:\n  length (map fst pathF) = length pathF \\<and>\n  length (map fst (map snd pathF)) = length (map snd (map snd pathF))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pathF \\<noteq> []; initial PM = (initial M2, initial M1);\n     \\<lbrakk>length (map fst pathF) = length (map fst (map snd pathF));\n      length (map fst (map snd pathF)) = length (map snd (map snd pathF));\n      productF M2 M1 FAIL PM; well_formed M2; well_formed M1;\n      path PM\n       (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n       (initial M2, initial M1);\n      initial M2 \\<in> nodes M2; initial M1 \\<in> nodes M1\\<rbrakk>\n     \\<Longrightarrow> path M2 (map fst pathF || map fst (map snd pathF))\n                        (initial M2) \\<and>\n                       path M1 (map fst pathF || map snd (map snd pathF))\n                        (initial M1) \\<or>\n                       target\n                        (map fst pathF ||\n                         map fst (map snd pathF) || map snd (map snd pathF))\n                        (initial M2, initial M1) =\n                       FAIL \\<and>\n                       0 < length (map fst pathF) \\<and>\n                       path M2\n                        (butlast (map fst pathF || map fst (map snd pathF)))\n                        (initial M2) \\<and>\n                       path M1\n                        (butlast (map fst pathF || map snd (map snd pathF)))\n                        (initial M1) \\<and>\n                       succ M2 (last (map fst pathF))\n                        (target\n                          (butlast\n                            (map fst pathF || map fst (map snd pathF)))\n                          (initial M2)) =\n                       {} \\<and>\n                       succ M1 (last (map fst pathF))\n                        (target\n                          (butlast\n                            (map fst pathF || map snd (map snd pathF)))\n                          (initial M1)) \\<noteq>\n                       {};\n     well_formed M1; well_formed M2; productF M2 M1 FAIL PM;\n     FAIL \\<in> reachable PM (initial PM); observable M2;\n     path PM pathF (initial PM) \\<and>\n     target pathF (initial PM) = FAIL\\<rbrakk>\n    \\<Longrightarrow> path M2 (map fst pathF || map fst (map snd pathF))\n                       (initial M2) \\<and>\n                      path M1 (map fst pathF || map snd (map snd pathF))\n                       (initial M1) \\<or>\n                      target\n                       (map fst pathF ||\n                        map fst (map snd pathF) || map snd (map snd pathF))\n                       (initial M2, initial M1) =\n                      FAIL \\<and>\n                      0 < length (map fst pathF) \\<and>\n                      path M2\n                       (butlast (map fst pathF || map fst (map snd pathF)))\n                       (initial M2) \\<and>\n                      path M1\n                       (butlast (map fst pathF || map snd (map snd pathF)))\n                       (initial M1) \\<and>\n                      succ M2 (last (map fst pathF))\n                       (target\n                         (butlast\n                           (map fst pathF || map fst (map snd pathF)))\n                         (initial M2)) =\n                      {} \\<and>\n                      succ M1 (last (map fst pathF))\n                       (target\n                         (butlast\n                           (map fst pathF || map snd (map snd pathF)))\n                         (initial M1)) \\<noteq>\n                      {}", "then"], ["proof (chain)\npicking this:\n  length (map fst pathF) = length pathF \\<and>\n  length (map fst (map snd pathF)) = length (map snd (map snd pathF))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (map fst pathF) = length pathF \\<and>\n  length (map fst (map snd pathF)) = length (map snd (map snd pathF))\n\ngoal (1 subgoal):\n 1. path M2 (map fst pathF || map fst (map snd pathF)) (initial M2) \\<and>\n    path M1 (map fst pathF || map snd (map snd pathF)) (initial M1) \\<or>\n    target\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1) =\n    FAIL \\<and>\n    0 < length (map fst pathF) \\<and>\n    path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2) \\<and>\n    path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1) \\<and>\n    succ M2 (last (map fst pathF))\n     (target (butlast (map fst pathF || map fst (map snd pathF)))\n       (initial M2)) =\n    {} \\<and>\n    succ M1 (last (map fst pathF))\n     (target (butlast (map fst pathF || map snd (map snd pathF)))\n       (initial M1)) \\<noteq>\n    {}", "using f2 f1 \\<open>productF M2 M1 FAIL PM\\<close> \\<open>well_formed M1\\<close> \\<open>well_formed M2\\<close>"], ["proof (prove)\nusing this:\n  length (map fst pathF) = length pathF \\<and>\n  length (map fst (map snd pathF)) = length (map snd (map snd pathF))\n  length (map fst pathF) = length pathF \\<longrightarrow>\n  length (map fst pathF) = length (map fst (map snd pathF))\n  path PM\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1)\n  productF M2 M1 FAIL PM\n  well_formed M1\n  well_formed M2\n\ngoal (1 subgoal):\n 1. path M2 (map fst pathF || map fst (map snd pathF)) (initial M2) \\<and>\n    path M1 (map fst pathF || map snd (map snd pathF)) (initial M1) \\<or>\n    target\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1) =\n    FAIL \\<and>\n    0 < length (map fst pathF) \\<and>\n    path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2) \\<and>\n    path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1) \\<and>\n    succ M2 (last (map fst pathF))\n     (target (butlast (map fst pathF || map fst (map snd pathF)))\n       (initial M2)) =\n    {} \\<and>\n    succ M1 (last (map fst pathF))\n     (target (butlast (map fst pathF || map snd (map snd pathF)))\n       (initial M1)) \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  path M2 (map fst pathF || map fst (map snd pathF)) (initial M2) \\<and>\n  path M1 (map fst pathF || map snd (map snd pathF)) (initial M1) \\<or>\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path M2 (map fst pathF || map fst (map snd pathF)) (initial M2) \\<and>\n  path M1 (map fst pathF || map snd (map snd pathF)) (initial M1) \\<or>\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "moreover"], ["proof (state)\nthis:\n  path M2 (map fst pathF || map fst (map snd pathF)) (initial M2) \\<and>\n  path M1 (map fst pathF || map snd (map snd pathF)) (initial M1) \\<or>\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "have \"\\<not> (path M2 (?io || ?tr2) (initial M2) \\<and> path M1 (?io || ?tr1) (initial M1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n             (initial M2) \\<and>\n            path M1 (map fst pathF || map snd (map snd pathF)) (initial M1))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n                    (initial M2) \\<and>\n                   path M1 (map fst pathF || map snd (map snd pathF))\n                    (initial M1)) \\<Longrightarrow>\n    False", "assume \" \\<not> \\<not> (path M2 (?io || ?tr2) (initial M2) \\<and>\n          path M1 (?io || ?tr1) (initial M1))\""], ["proof (state)\nthis:\n  \\<not> \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n                  (initial M2) \\<and>\n                 path M1 (map fst pathF || map snd (map snd pathF))\n                  (initial M1))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n                    (initial M2) \\<and>\n                   path M1 (map fst pathF || map snd (map snd pathF))\n                    (initial M1)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n                  (initial M2) \\<and>\n                 path M1 (map fst pathF || map snd (map snd pathF))\n                  (initial M1))", "have \"path M2 (?io || ?tr2) (initial M2)\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n                  (initial M2) \\<and>\n                 path M1 (map fst pathF || map snd (map snd pathF))\n                  (initial M1))\n\ngoal (1 subgoal):\n 1. path M2 (map fst pathF || map fst (map snd pathF)) (initial M2)", "by simp"], ["proof (state)\nthis:\n  path M2 (map fst pathF || map fst (map snd pathF)) (initial M2)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n                    (initial M2) \\<and>\n                   path M1 (map fst pathF || map snd (map snd pathF))\n                    (initial M1)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  path M2 (map fst pathF || map fst (map snd pathF)) (initial M2)", "have \"target (?io || ?tr2) (initial M2) \\<in> nodes M2\""], ["proof (prove)\nusing this:\n  path M2 (map fst pathF || map fst (map snd pathF)) (initial M2)\n\ngoal (1 subgoal):\n 1. target (map fst pathF || map fst (map snd pathF)) (initial M2)\n    \\<in> nodes M2", "by auto"], ["proof (state)\nthis:\n  target (map fst pathF || map fst (map snd pathF)) (initial M2)\n  \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n                    (initial M2) \\<and>\n                   path M1 (map fst pathF || map snd (map snd pathF))\n                    (initial M1)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  target (map fst pathF || map fst (map snd pathF)) (initial M2)\n  \\<in> nodes M2", "have \"target (?io || ?tr2) (initial M2) \\<noteq> fst FAIL\""], ["proof (prove)\nusing this:\n  target (map fst pathF || map fst (map snd pathF)) (initial M2)\n  \\<in> nodes M2\n\ngoal (1 subgoal):\n 1. target (map fst pathF || map fst (map snd pathF)) (initial M2) \\<noteq>\n    fst FAIL", "using assms"], ["proof (prove)\nusing this:\n  target (map fst pathF || map fst (map snd pathF)) (initial M2)\n  \\<in> nodes M2\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  FAIL \\<in> reachable PM (initial PM)\n  observable M2\n\ngoal (1 subgoal):\n 1. target (map fst pathF || map fst (map snd pathF)) (initial M2) \\<noteq>\n    fst FAIL", "by auto"], ["proof (state)\nthis:\n  target (map fst pathF || map fst (map snd pathF)) (initial M2) \\<noteq>\n  fst FAIL\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n                    (initial M2) \\<and>\n                   path M1 (map fst pathF || map snd (map snd pathF))\n                    (initial M1)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  target (map fst pathF || map fst (map snd pathF)) (initial M2) \\<noteq>\n  fst FAIL", "show \"False\""], ["proof (prove)\nusing this:\n  target (map fst pathF || map fst (map snd pathF)) (initial M2) \\<noteq>\n  fst FAIL\n\ngoal (1 subgoal):\n 1. False", "using pathF_def"], ["proof (prove)\nusing this:\n  target (map fst pathF || map fst (map snd pathF)) (initial M2) \\<noteq>\n  fst FAIL\n  path PM pathF (initial PM) \\<and> target pathF (initial PM) = FAIL\n\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>target (map fst pathF || map fst (map snd pathF))\n              (initial M2) \\<noteq>\n             fst FAIL;\n     path PM pathF (initial PM) \\<and>\n     target pathF (initial PM) = FAIL\\<rbrakk>\n    \\<Longrightarrow> False", "have \"FAIL = target (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF)) \n                          (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL =\n    target\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1)", "by (metis (no_types) \\<open>initial PM = (initial M2, initial M1)\\<close> \n            \\<open>path PM pathF (initial PM) \\<and> target pathF (initial PM) = FAIL\\<close> zip_map_fst_snd)"], ["proof (state)\nthis:\n  FAIL =\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>target (map fst pathF || map fst (map snd pathF))\n              (initial M2) \\<noteq>\n             fst FAIL;\n     path PM pathF (initial PM) \\<and>\n     target pathF (initial PM) = FAIL\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  FAIL =\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1)", "show ?thesis"], ["proof (prove)\nusing this:\n  FAIL =\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>target (map fst pathF || map fst (map snd pathF)) (initial M2) \\<noteq> fst FAIL\\<close>"], ["proof (prove)\nusing this:\n  FAIL =\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1)\n  target (map fst pathF || map fst (map snd pathF)) (initial M2) \\<noteq>\n  fst FAIL\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n           (initial M2) \\<and>\n          path M1 (map fst pathF || map snd (map snd pathF)) (initial M1))\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "ultimately"], ["proof (chain)\npicking this:\n  path M2 (map fst pathF || map fst (map snd pathF)) (initial M2) \\<and>\n  path M1 (map fst pathF || map snd (map snd pathF)) (initial M1) \\<or>\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n  \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n           (initial M2) \\<and>\n          path M1 (map fst pathF || map snd (map snd pathF)) (initial M1))", "have fail_prop : \n          \"target (?io || ?tr2 || ?tr1) (initial M2, initial M1) = FAIL \\<and>\n            0 < length (?io) \\<and>\n            path M2 (butlast (?io || ?tr2)) (initial M2) \\<and>\n            path M1 (butlast (?io || ?tr1)) (initial M1) \\<and>\n            succ M2 (last (?io)) (target (butlast (?io || ?tr2)) (initial M2)) = {} \\<and>\n            succ M1 (last (?io)) (target (butlast (?io || ?tr1)) (initial M1)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  path M2 (map fst pathF || map fst (map snd pathF)) (initial M2) \\<and>\n  path M1 (map fst pathF || map snd (map snd pathF)) (initial M1) \\<or>\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n  \\<not> (path M2 (map fst pathF || map fst (map snd pathF))\n           (initial M2) \\<and>\n          path M1 (map fst pathF || map snd (map snd pathF)) (initial M1))\n\ngoal (1 subgoal):\n 1. target\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1) =\n    FAIL \\<and>\n    0 < length (map fst pathF) \\<and>\n    path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2) \\<and>\n    path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1) \\<and>\n    succ M2 (last (map fst pathF))\n     (target (butlast (map fst pathF || map fst (map snd pathF)))\n       (initial M2)) =\n    {} \\<and>\n    succ M1 (last (map fst pathF))\n     (target (butlast (map fst pathF || map snd (map snd pathF)))\n       (initial M1)) \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "then"], ["proof (chain)\npicking this:\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}", "have \"?io \\<in> language_state M1 (initial M1)\""], ["proof (prove)\nusing this:\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. map fst pathF \\<in> L M1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. target\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1) =\n    FAIL \\<and>\n    0 < length (map fst pathF) \\<and>\n    path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2) \\<and>\n    path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1) \\<and>\n    succ M2 (last (map fst pathF))\n     (target (butlast (map fst pathF || map fst (map snd pathF)))\n       (initial M2)) =\n    {} \\<and>\n    succ M1 (last (map fst pathF))\n     (target (butlast (map fst pathF || map snd (map snd pathF)))\n       (initial M1)) \\<noteq>\n    {} \\<Longrightarrow>\n    map fst pathF \\<in> L M1", "have f1: \"path PM (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF)) \n                        (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1)", "by (metis (no_types) \\<open>initial PM = (initial M2, initial M1)\\<close> pathF_def zip_map_fst_snd)"], ["proof (state)\nthis:\n  path PM\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. target\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1) =\n    FAIL \\<and>\n    0 < length (map fst pathF) \\<and>\n    path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2) \\<and>\n    path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1) \\<and>\n    succ M2 (last (map fst pathF))\n     (target (butlast (map fst pathF || map fst (map snd pathF)))\n       (initial M2)) =\n    {} \\<and>\n    succ M1 (last (map fst pathF))\n     (target (butlast (map fst pathF || map snd (map snd pathF)))\n       (initial M1)) \\<noteq>\n    {} \\<Longrightarrow>\n    map fst pathF \\<in> L M1", "have \"\\<forall>c f. c \\<noteq> initial (f::('a, 'b, 'c) FSM) \\<or> c \\<in> nodes f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c f. c \\<noteq> initial f \\<or> c \\<in> nodes f", "by blast"], ["proof (state)\nthis:\n  \\<forall>c f. c \\<noteq> initial f \\<or> c \\<in> nodes f\n\ngoal (1 subgoal):\n 1. target\n     (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n     (initial M2, initial M1) =\n    FAIL \\<and>\n    0 < length (map fst pathF) \\<and>\n    path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2) \\<and>\n    path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1) \\<and>\n    succ M2 (last (map fst pathF))\n     (target (butlast (map fst pathF || map fst (map snd pathF)))\n       (initial M2)) =\n    {} \\<and>\n    succ M1 (last (map fst pathF))\n     (target (butlast (map fst pathF || map snd (map snd pathF)))\n       (initial M1)) \\<noteq>\n    {} \\<Longrightarrow>\n    map fst pathF \\<in> L M1", "then"], ["proof (chain)\npicking this:\n  \\<forall>c f. c \\<noteq> initial f \\<or> c \\<in> nodes f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>c f. c \\<noteq> initial f \\<or> c \\<in> nodes f\n\ngoal (1 subgoal):\n 1. map fst pathF \\<in> L M1", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>c f. c \\<noteq> initial f \\<or> c \\<in> nodes f\n  path PM\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. map fst pathF \\<in> L M1", "by (metis (no_types) assms(1) assms(2) assms(3) language_state length_map \n                    productF_path_reverse_ob)"], ["proof (state)\nthis:\n  map fst pathF \\<in> L M1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map fst pathF \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "moreover"], ["proof (state)\nthis:\n  map fst pathF \\<in> L M1\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "have \"?io \\<notin> language_state M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst pathF \\<notin> L M2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "assume \"\\<not> ?io \\<notin> language_state M2 (initial M2)\""], ["proof (state)\nthis:\n  \\<not> map fst pathF \\<notin> L M2\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> map fst pathF \\<notin> L M2", "have assm : \"?io \\<in> language_state M2 (initial M2)\""], ["proof (prove)\nusing this:\n  \\<not> map fst pathF \\<notin> L M2\n\ngoal (1 subgoal):\n 1. map fst pathF \\<in> L M2", "by simp"], ["proof (state)\nthis:\n  map fst pathF \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  map fst pathF \\<in> L M2", "obtain tr2' where tr2'_def : \"path M2 (?io || tr2') (initial M2) \n                                        \\<and> length ?io = length tr2'\""], ["proof (prove)\nusing this:\n  map fst pathF \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>tr2'.\n        path M2 (map fst pathF || tr2') (initial M2) \\<and>\n        length (map fst pathF) = length tr2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M2 (map fst pathF || tr2') (initial M2) \\<and>\n  length (map fst pathF) = length tr2'\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path M2 (map fst pathF || tr2') (initial M2) \\<and>\n  length (map fst pathF) = length tr2'", "obtain tr2'_init tr2'_last where tr2'_split : \"tr2' = tr2'_init @ [tr2'_last]\""], ["proof (prove)\nusing this:\n  path M2 (map fst pathF || tr2') (initial M2) \\<and>\n  length (map fst pathF) = length tr2'\n\ngoal (1 subgoal):\n 1. (\\<And>tr2'_init tr2'_last.\n        tr2' = tr2'_init @ [tr2'_last] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using fail_prop"], ["proof (prove)\nusing this:\n  path M2 (map fst pathF || tr2') (initial M2) \\<and>\n  length (map fst pathF) = length tr2'\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>tr2'_init tr2'_last.\n        tr2' = tr2'_init @ [tr2'_last] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>pathF \\<noteq> []\\<close> append_butlast_last_id length_0_conv map_is_Nil_conv)"], ["proof (state)\nthis:\n  tr2' = tr2'_init @ [tr2'_last]\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "have \"butlast ?io \\<in> language_state M2 (initial M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (map fst pathF) \\<in> L M2", "using fail_prop"], ["proof (prove)\nusing this:\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. butlast (map fst pathF) \\<in> L M2", "by auto"], ["proof (state)\nthis:\n  butlast (map fst pathF) \\<in> L M2\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  butlast (map fst pathF) \\<in> L M2", "have \"{t. path M2 (butlast ?io || t) (initial M2) \\<and> length (butlast ?io) = length t} \n                = {butlast ?tr2}\""], ["proof (prove)\nusing this:\n  butlast (map fst pathF) \\<in> L M2\n\ngoal (1 subgoal):\n 1. {t. path M2 (butlast (map fst pathF) || t) (initial M2) \\<and>\n        length (butlast (map fst pathF)) = length t} =\n    {butlast (map fst (map snd pathF))}", "using assms(5) observable_path_unique[of \"butlast ?io\" M2 \"initial M2\" \"butlast ?tr2\"] \n            fail_prop"], ["proof (prove)\nusing this:\n  butlast (map fst pathF) \\<in> L M2\n  observable M2\n  \\<lbrakk>butlast (map fst pathF) \\<in> L M2; observable M2;\n   path M2 (butlast (map fst pathF) || butlast (map fst (map snd pathF)))\n    (initial M2);\n   length (butlast (map fst pathF)) =\n   length (butlast (map fst (map snd pathF)));\n   path M2 (butlast (map fst pathF) || ?tr2.0) (initial M2);\n   length (butlast (map fst pathF)) = length ?tr2.0\\<rbrakk>\n  \\<Longrightarrow> butlast (map fst (map snd pathF)) = ?tr2.0\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. {t. path M2 (butlast (map fst pathF) || t) (initial M2) \\<and>\n        length (butlast (map fst pathF)) = length t} =\n    {butlast (map fst (map snd pathF))}", "by fastforce"], ["proof (state)\nthis:\n  {t. path M2 (butlast (map fst pathF) || t) (initial M2) \\<and>\n      length (butlast (map fst pathF)) = length t} =\n  {butlast (map fst (map snd pathF))}\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {t. path M2 (butlast (map fst pathF) || t) (initial M2) \\<and>\n      length (butlast (map fst pathF)) = length t} =\n  {butlast (map fst (map snd pathF))}", "have \"\\<forall> t ts . path M2 ((butlast ?io) @ [last ?io] || ts @ [t]) (initial M2) \n                          \\<and> length ((butlast ?io) @ [last ?io]) = length (ts @ [t]) \n                        \\<longrightarrow> ts = butlast ?tr2\""], ["proof (prove)\nusing this:\n  {t. path M2 (butlast (map fst pathF) || t) (initial M2) \\<and>\n      length (butlast (map fst pathF)) = length t} =\n  {butlast (map fst (map snd pathF))}\n\ngoal (1 subgoal):\n 1. \\<forall>t ts.\n       path M2\n        (butlast (map fst pathF) @ [last (map fst pathF)] || ts @ [t])\n        (initial M2) \\<and>\n       length (butlast (map fst pathF) @ [last (map fst pathF)]) =\n       length (ts @ [t]) \\<longrightarrow>\n       ts = butlast (map fst (map snd pathF))", "by (metis (no_types, lifting) FSM.path_append_elim \n          \\<open>butlast (map fst pathF) \\<in> language_state M2 (initial M2)\\<close> assms(5) butlast_snoc \n          butlast_zip fail_prop length_butlast length_map observable_path_unique zip_append)"], ["proof (state)\nthis:\n  \\<forall>t ts.\n     path M2 (butlast (map fst pathF) @ [last (map fst pathF)] || ts @ [t])\n      (initial M2) \\<and>\n     length (butlast (map fst pathF) @ [last (map fst pathF)]) =\n     length (ts @ [t]) \\<longrightarrow>\n     ts = butlast (map fst (map snd pathF))\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>t ts.\n     path M2 (butlast (map fst pathF) @ [last (map fst pathF)] || ts @ [t])\n      (initial M2) \\<and>\n     length (butlast (map fst pathF) @ [last (map fst pathF)]) =\n     length (ts @ [t]) \\<longrightarrow>\n     ts = butlast (map fst (map snd pathF))", "have \"tr2'_init = butlast ?tr2\""], ["proof (prove)\nusing this:\n  \\<forall>t ts.\n     path M2 (butlast (map fst pathF) @ [last (map fst pathF)] || ts @ [t])\n      (initial M2) \\<and>\n     length (butlast (map fst pathF) @ [last (map fst pathF)]) =\n     length (ts @ [t]) \\<longrightarrow>\n     ts = butlast (map fst (map snd pathF))\n\ngoal (1 subgoal):\n 1. tr2'_init = butlast (map fst (map snd pathF))", "using tr2'_def tr2'_split \\<open>pathF \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t ts.\n     path M2 (butlast (map fst pathF) @ [last (map fst pathF)] || ts @ [t])\n      (initial M2) \\<and>\n     length (butlast (map fst pathF) @ [last (map fst pathF)]) =\n     length (ts @ [t]) \\<longrightarrow>\n     ts = butlast (map fst (map snd pathF))\n  path M2 (map fst pathF || tr2') (initial M2) \\<and>\n  length (map fst pathF) = length tr2'\n  tr2' = tr2'_init @ [tr2'_last]\n  pathF \\<noteq> []\n\ngoal (1 subgoal):\n 1. tr2'_init = butlast (map fst (map snd pathF))", "by auto"], ["proof (state)\nthis:\n  tr2'_init = butlast (map fst (map snd pathF))\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  tr2'_init = butlast (map fst (map snd pathF))", "have \"path M2 ((butlast ?io) @ [last ?io] || (butlast ?tr2) @ [tr2'_last]) (initial M2) \n                \\<and> length ((butlast ?io) @ [last ?io]) = length ((butlast ?tr2) @ [tr2'_last])\""], ["proof (prove)\nusing this:\n  tr2'_init = butlast (map fst (map snd pathF))\n\ngoal (1 subgoal):\n 1. path M2\n     (butlast (map fst pathF) @ [last (map fst pathF)] ||\n      butlast (map fst (map snd pathF)) @ [tr2'_last])\n     (initial M2) \\<and>\n    length (butlast (map fst pathF) @ [last (map fst pathF)]) =\n    length (butlast (map fst (map snd pathF)) @ [tr2'_last])", "using tr2'_def fail_prop tr2'_split"], ["proof (prove)\nusing this:\n  tr2'_init = butlast (map fst (map snd pathF))\n  path M2 (map fst pathF || tr2') (initial M2) \\<and>\n  length (map fst pathF) = length tr2'\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n  tr2' = tr2'_init @ [tr2'_last]\n\ngoal (1 subgoal):\n 1. path M2\n     (butlast (map fst pathF) @ [last (map fst pathF)] ||\n      butlast (map fst (map snd pathF)) @ [tr2'_last])\n     (initial M2) \\<and>\n    length (butlast (map fst pathF) @ [last (map fst pathF)]) =\n    length (butlast (map fst (map snd pathF)) @ [tr2'_last])", "by auto"], ["proof (state)\nthis:\n  path M2\n   (butlast (map fst pathF) @ [last (map fst pathF)] ||\n    butlast (map fst (map snd pathF)) @ [tr2'_last])\n   (initial M2) \\<and>\n  length (butlast (map fst pathF) @ [last (map fst pathF)]) =\n  length (butlast (map fst (map snd pathF)) @ [tr2'_last])\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path M2\n   (butlast (map fst pathF) @ [last (map fst pathF)] ||\n    butlast (map fst (map snd pathF)) @ [tr2'_last])\n   (initial M2) \\<and>\n  length (butlast (map fst pathF) @ [last (map fst pathF)]) =\n  length (butlast (map fst (map snd pathF)) @ [tr2'_last])", "have \"path M2 ([last ?io] || [tr2'_last]) \n                        (target (butlast ?io || butlast ?tr2) (initial M2)) \n                \\<and> length [last ?io] = length [tr2'_last]\""], ["proof (prove)\nusing this:\n  path M2\n   (butlast (map fst pathF) @ [last (map fst pathF)] ||\n    butlast (map fst (map snd pathF)) @ [tr2'_last])\n   (initial M2) \\<and>\n  length (butlast (map fst pathF) @ [last (map fst pathF)]) =\n  length (butlast (map fst (map snd pathF)) @ [tr2'_last])\n\ngoal (1 subgoal):\n 1. path M2 ([last (map fst pathF)] || [tr2'_last])\n     (target (butlast (map fst pathF) || butlast (map fst (map snd pathF)))\n       (initial M2)) \\<and>\n    length [last (map fst pathF)] = length [tr2'_last]", "by auto"], ["proof (state)\nthis:\n  path M2 ([last (map fst pathF)] || [tr2'_last])\n   (target (butlast (map fst pathF) || butlast (map fst (map snd pathF)))\n     (initial M2)) \\<and>\n  length [last (map fst pathF)] = length [tr2'_last]\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path M2 ([last (map fst pathF)] || [tr2'_last])\n   (target (butlast (map fst pathF) || butlast (map fst (map snd pathF)))\n     (initial M2)) \\<and>\n  length [last (map fst pathF)] = length [tr2'_last]", "have \"tr2'_last \\<in> succ M2 (last (?io)) (target (butlast (?io || ?tr2)) (initial M2))\""], ["proof (prove)\nusing this:\n  path M2 ([last (map fst pathF)] || [tr2'_last])\n   (target (butlast (map fst pathF) || butlast (map fst (map snd pathF)))\n     (initial M2)) \\<and>\n  length [last (map fst pathF)] = length [tr2'_last]\n\ngoal (1 subgoal):\n 1. tr2'_last\n    \\<in> succ M2 (last (map fst pathF))\n           (target (butlast (map fst pathF || map fst (map snd pathF)))\n             (initial M2))", "by auto"], ["proof (state)\nthis:\n  tr2'_last\n  \\<in> succ M2 (last (map fst pathF))\n         (target (butlast (map fst pathF || map fst (map snd pathF)))\n           (initial M2))\n\ngoal (1 subgoal):\n 1. \\<not> map fst pathF \\<notin> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  tr2'_last\n  \\<in> succ M2 (last (map fst pathF))\n         (target (butlast (map fst pathF || map fst (map snd pathF)))\n           (initial M2))", "show \"False\""], ["proof (prove)\nusing this:\n  tr2'_last\n  \\<in> succ M2 (last (map fst pathF))\n         (target (butlast (map fst pathF || map fst (map snd pathF)))\n           (initial M2))\n\ngoal (1 subgoal):\n 1. False", "using fail_prop"], ["proof (prove)\nusing this:\n  tr2'_last\n  \\<in> succ M2 (last (map fst pathF))\n         (target (butlast (map fst pathF || map fst (map snd pathF)))\n           (initial M2))\n  target\n   (map fst pathF || map fst (map snd pathF) || map snd (map snd pathF))\n   (initial M2, initial M1) =\n  FAIL \\<and>\n  0 < length (map fst pathF) \\<and>\n  path M2 (butlast (map fst pathF || map fst (map snd pathF)))\n   (initial M2) \\<and>\n  path M1 (butlast (map fst pathF || map snd (map snd pathF)))\n   (initial M1) \\<and>\n  succ M2 (last (map fst pathF))\n   (target (butlast (map fst pathF || map fst (map snd pathF)))\n     (initial M2)) =\n  {} \\<and>\n  succ M1 (last (map fst pathF))\n   (target (butlast (map fst pathF || map snd (map snd pathF)))\n     (initial M1)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map fst pathF \\<notin> L M2\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "ultimately"], ["proof (chain)\npicking this:\n  map fst pathF \\<in> L M1\n  map fst pathF \\<notin> L M2", "show ?thesis"], ["proof (prove)\nusing this:\n  map fst pathF \\<in> L M1\n  map fst pathF \\<notin> L M2\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2", "by auto"], ["proof (state)\nthis:\n  \\<not> M1 \\<preceq> M2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fail_reachable_iff[iff] : \n  assumes \"well_formed M1\"\n  and     \"well_formed M2\" \n  and     \"productF M2 M1 FAIL PM\"\n  and     \"observable M2\"\nshows \"FAIL \\<in> reachable PM (initial PM) \\<longleftrightarrow> \\<not> M1 \\<preceq> M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FAIL \\<in> reachable PM (initial PM)) = (\\<not> M1 \\<preceq> M2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. FAIL \\<in> reachable PM (initial PM) \\<Longrightarrow>\n    \\<not> M1 \\<preceq> M2\n 2. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    FAIL \\<in> reachable PM (initial PM)", "show \"FAIL \\<in> reachable PM (initial PM) \\<Longrightarrow> \\<not> M1 \\<preceq> M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<in> reachable PM (initial PM) \\<Longrightarrow>\n    \\<not> M1 \\<preceq> M2", "using assms fail_reachable_reverse"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  observable M2\n  \\<lbrakk>well_formed ?M1.0; well_formed ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM; ?FAIL \\<in> reachable ?PM (initial ?PM);\n   observable ?M2.0\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?M1.0 \\<preceq> ?M2.0\n\ngoal (1 subgoal):\n 1. FAIL \\<in> reachable PM (initial PM) \\<Longrightarrow>\n    \\<not> M1 \\<preceq> M2", "by blast"], ["proof (state)\nthis:\n  FAIL \\<in> reachable PM (initial PM) \\<Longrightarrow>\n  \\<not> M1 \\<preceq> M2\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    FAIL \\<in> reachable PM (initial PM)", "show \"\\<not> M1 \\<preceq> M2 \\<Longrightarrow> FAIL \\<in> reachable PM (initial PM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    FAIL \\<in> reachable PM (initial PM)", "using assms fail_reachable"], ["proof (prove)\nusing this:\n  well_formed M1\n  well_formed M2\n  productF M2 M1 FAIL PM\n  observable M2\n  \\<lbrakk>\\<not> ?M1.0 \\<preceq> ?M2.0; well_formed ?M1.0;\n   well_formed ?M2.0; productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> ?FAIL \\<in> reachable ?PM (initial ?PM)\n\ngoal (1 subgoal):\n 1. \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n    FAIL \\<in> reachable PM (initial PM)", "by blast"], ["proof (state)\nthis:\n  \\<not> M1 \\<preceq> M2 \\<Longrightarrow>\n  FAIL \\<in> reachable PM (initial PM)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reaching_path_length :\n  assumes \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"q2 \\<in> reachable AB q1\"\n  and     \"q2 \\<noteq> FAIL\"\n  and     \"q1 \\<in> nodes AB\"\nshows \"\\<exists> p . path AB p q1 \\<and> target p q1 = q2 \\<and> length p < card (nodes A) * card (nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "obtain p where p_def : \"path AB p q1 \\<and> target p q1 = q2 \\<and> distinct (q1 # states p q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path AB p q1 \\<and>\n        target p q1 = q2 \\<and>\n        distinct (q1 # states p q1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms reaching_path_without_repetition"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  q2 \\<in> reachable AB q1\n  q2 \\<noteq> FAIL\n  q1 \\<in> nodes AB\n  \\<lbrakk>well_formed ?M; ?q2.0 \\<in> reachable ?M ?q1.0;\n   ?q1.0 \\<in> nodes ?M\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       path ?M p ?q1.0 \\<and>\n                       target p ?q1.0 = ?q2.0 \\<and>\n                       distinct (?q1.0 # states p ?q1.0)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path AB p q1 \\<and>\n        target p q1 = q2 \\<and>\n        distinct (q1 # states p q1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis well_formed_productF)"], ["proof (state)\nthis:\n  path AB p q1 \\<and> target p q1 = q2 \\<and> distinct (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "have \"FAIL \\<notin> set (q1 # states p q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<notin> set (q1 # states p q1)", "proof(cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)", "then"], ["proof (chain)\npicking this:\n  p = []", "have \"q1 = q2\""], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. q1 = q2", "using p_def"], ["proof (prove)\nusing this:\n  p = []\n  path AB p q1 \\<and> target p q1 = q2 \\<and> distinct (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. q1 = q2", "by auto"], ["proof (state)\nthis:\n  q1 = q2\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)", "then"], ["proof (chain)\npicking this:\n  q1 = q2", "have \"q1 \\<noteq> FAIL\""], ["proof (prove)\nusing this:\n  q1 = q2\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> FAIL", "using assms"], ["proof (prove)\nusing this:\n  q1 = q2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  q2 \\<in> reachable AB q1\n  q2 \\<noteq> FAIL\n  q1 \\<in> nodes AB\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> FAIL", "by auto"], ["proof (state)\nthis:\n  q1 \\<noteq> FAIL\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)", "then"], ["proof (chain)\npicking this:\n  q1 \\<noteq> FAIL", "show ?thesis"], ["proof (prove)\nusing this:\n  q1 \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. FAIL \\<notin> set (q1 # states p q1)", "using Nil"], ["proof (prove)\nusing this:\n  q1 \\<noteq> FAIL\n  p = []\n\ngoal (1 subgoal):\n 1. FAIL \\<notin> set (q1 # states p q1)", "by auto"], ["proof (state)\nthis:\n  FAIL \\<notin> set (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)", "case (Cons a list)"], ["proof (state)\nthis:\n  p = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)", "have \"FAIL \\<notin> set (butlast (q1 # states p q1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<notin> set (butlast (q1 # states p q1))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> FAIL \\<notin> set (butlast (q1 # states p q1)) \\<Longrightarrow>\n    False", "assume assm : \"\\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\""], ["proof (state)\nthis:\n  \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\n\ngoal (1 subgoal):\n 1. \\<not> FAIL \\<notin> set (butlast (q1 # states p q1)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))", "obtain i where i_def : \"i < length (butlast (q1 # states p q1))\n                                   \\<and> butlast (q1 # states p q1) ! i = FAIL\""], ["proof (prove)\nusing this:\n  \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length (butlast (q1 # states p q1)) \\<and>\n        butlast (q1 # states p q1) ! i = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis distinct_Ex1 distinct_butlast p_def)"], ["proof (state)\nthis:\n  i < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! i = FAIL\n\ngoal (1 subgoal):\n 1. \\<not> FAIL \\<notin> set (butlast (q1 # states p q1)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  i < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! i = FAIL", "have \"i < Suc (length (butlast p))\""], ["proof (prove)\nusing this:\n  i < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! i = FAIL\n\ngoal (1 subgoal):\n 1. i < Suc (length (butlast p))", "using local.Cons"], ["proof (prove)\nusing this:\n  i < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! i = FAIL\n  p = a # list\n\ngoal (1 subgoal):\n 1. i < Suc (length (butlast p))", "by fastforce"], ["proof (state)\nthis:\n  i < Suc (length (butlast p))\n\ngoal (1 subgoal):\n 1. \\<not> FAIL \\<notin> set (butlast (q1 # states p q1)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  i < Suc (length (butlast p))", "have \"i < length p\""], ["proof (prove)\nusing this:\n  i < Suc (length (butlast p))\n\ngoal (1 subgoal):\n 1. i < length p", "by (metis append_butlast_last_id length_append_singleton list.simps(3) local.Cons)"], ["proof (state)\nthis:\n  i < length p\n\ngoal (1 subgoal):\n 1. \\<not> FAIL \\<notin> set (butlast (q1 # states p q1)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  i < length p", "have \"butlast (q1 # states p q1) ! i = target (take i p) q1\""], ["proof (prove)\nusing this:\n  i < length p\n\ngoal (1 subgoal):\n 1. butlast (q1 # states p q1) ! i = target (take i p) q1", "using i_def assm"], ["proof (prove)\nusing this:\n  i < length p\n  i < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! i = FAIL\n  \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\n\ngoal (1 subgoal):\n 1. butlast (q1 # states p q1) ! i = target (take i p) q1", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < length p;\n     0 < length (butlast (q1 # states p q1)) \\<and>\n     butlast (q1 # states p q1) ! 0 = FAIL;\n     \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n    \\<Longrightarrow> butlast (q1 # states p q1) ! 0 = target (take 0 p) q1\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length p;\n                 i < length (butlast (q1 # states p q1)) \\<and>\n                 butlast (q1 # states p q1) ! i = FAIL;\n                 \\<not> FAIL\n                        \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n                \\<Longrightarrow> butlast (q1 # states p q1) ! i =\n                                  target (take i p) q1;\n        Suc i < length p;\n        Suc i < length (butlast (q1 # states p q1)) \\<and>\n        butlast (q1 # states p q1) ! Suc i = FAIL;\n        \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n       \\<Longrightarrow> butlast (q1 # states p q1) ! Suc i =\n                         target (take (Suc i) p) q1", "case 0"], ["proof (state)\nthis:\n  0 < length p\n  0 < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! 0 = FAIL\n  \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < length p;\n     0 < length (butlast (q1 # states p q1)) \\<and>\n     butlast (q1 # states p q1) ! 0 = FAIL;\n     \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n    \\<Longrightarrow> butlast (q1 # states p q1) ! 0 = target (take 0 p) q1\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length p;\n                 i < length (butlast (q1 # states p q1)) \\<and>\n                 butlast (q1 # states p q1) ! i = FAIL;\n                 \\<not> FAIL\n                        \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n                \\<Longrightarrow> butlast (q1 # states p q1) ! i =\n                                  target (take i p) q1;\n        Suc i < length p;\n        Suc i < length (butlast (q1 # states p q1)) \\<and>\n        butlast (q1 # states p q1) ! Suc i = FAIL;\n        \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n       \\<Longrightarrow> butlast (q1 # states p q1) ! Suc i =\n                         target (take (Suc i) p) q1", "then"], ["proof (chain)\npicking this:\n  0 < length p\n  0 < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! 0 = FAIL\n  \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))", "show ?case"], ["proof (prove)\nusing this:\n  0 < length p\n  0 < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! 0 = FAIL\n  \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\n\ngoal (1 subgoal):\n 1. butlast (q1 # states p q1) ! 0 = target (take 0 p) q1", "by auto"], ["proof (state)\nthis:\n  butlast (q1 # states p q1) ! 0 = target (take 0 p) q1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length p;\n                 i < length (butlast (q1 # states p q1)) \\<and>\n                 butlast (q1 # states p q1) ! i = FAIL;\n                 \\<not> FAIL\n                        \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n                \\<Longrightarrow> butlast (q1 # states p q1) ! i =\n                                  target (take i p) q1;\n        Suc i < length p;\n        Suc i < length (butlast (q1 # states p q1)) \\<and>\n        butlast (q1 # states p q1) ! Suc i = FAIL;\n        \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n       \\<Longrightarrow> butlast (q1 # states p q1) ! Suc i =\n                         target (take (Suc i) p) q1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length p;\n                 i < length (butlast (q1 # states p q1)) \\<and>\n                 butlast (q1 # states p q1) ! i = FAIL;\n                 \\<not> FAIL\n                        \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n                \\<Longrightarrow> butlast (q1 # states p q1) ! i =\n                                  target (take i p) q1;\n        Suc i < length p;\n        Suc i < length (butlast (q1 # states p q1)) \\<and>\n        butlast (q1 # states p q1) ! Suc i = FAIL;\n        \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n       \\<Longrightarrow> butlast (q1 # states p q1) ! Suc i =\n                         target (take (Suc i) p) q1", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>i < length p;\n   i < length (butlast (q1 # states p q1)) \\<and>\n   butlast (q1 # states p q1) ! i = FAIL;\n   \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n  \\<Longrightarrow> butlast (q1 # states p q1) ! i = target (take i p) q1\n  Suc i < length p\n  Suc i < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! Suc i = FAIL\n  \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>i < length p;\n                 i < length (butlast (q1 # states p q1)) \\<and>\n                 butlast (q1 # states p q1) ! i = FAIL;\n                 \\<not> FAIL\n                        \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n                \\<Longrightarrow> butlast (q1 # states p q1) ! i =\n                                  target (take i p) q1;\n        Suc i < length p;\n        Suc i < length (butlast (q1 # states p q1)) \\<and>\n        butlast (q1 # states p q1) ! Suc i = FAIL;\n        \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n       \\<Longrightarrow> butlast (q1 # states p q1) ! Suc i =\n                         target (take (Suc i) p) q1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < length p;\n   i < length (butlast (q1 # states p q1)) \\<and>\n   butlast (q1 # states p q1) ! i = FAIL;\n   \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n  \\<Longrightarrow> butlast (q1 # states p q1) ! i = target (take i p) q1\n  Suc i < length p\n  Suc i < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! Suc i = FAIL\n  \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length p;\n   i < length (butlast (q1 # states p q1)) \\<and>\n   butlast (q1 # states p q1) ! i = FAIL;\n   \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\\<rbrakk>\n  \\<Longrightarrow> butlast (q1 # states p q1) ! i = target (take i p) q1\n  Suc i < length p\n  Suc i < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! Suc i = FAIL\n  \\<not> FAIL \\<notin> set (butlast (q1 # states p q1))\n\ngoal (1 subgoal):\n 1. butlast (q1 # states p q1) ! Suc i = target (take (Suc i) p) q1", "by (metis Suc_lessD nth_Cons_Suc nth_butlast states_target_index)"], ["proof (state)\nthis:\n  butlast (q1 # states p q1) ! Suc i = target (take (Suc i) p) q1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  butlast (q1 # states p q1) ! i = target (take i p) q1\n\ngoal (1 subgoal):\n 1. \\<not> FAIL \\<notin> set (butlast (q1 # states p q1)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  butlast (q1 # states p q1) ! i = target (take i p) q1", "have \"target (take i p) q1 = FAIL\""], ["proof (prove)\nusing this:\n  butlast (q1 # states p q1) ! i = target (take i p) q1\n\ngoal (1 subgoal):\n 1. target (take i p) q1 = FAIL", "using i_def"], ["proof (prove)\nusing this:\n  butlast (q1 # states p q1) ! i = target (take i p) q1\n  i < length (butlast (q1 # states p q1)) \\<and>\n  butlast (q1 # states p q1) ! i = FAIL\n\ngoal (1 subgoal):\n 1. target (take i p) q1 = FAIL", "by auto"], ["proof (state)\nthis:\n  target (take i p) q1 = FAIL\n\ngoal (1 subgoal):\n 1. \\<not> FAIL \\<notin> set (butlast (q1 # states p q1)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  target (take i p) q1 = FAIL\n\ngoal (1 subgoal):\n 1. \\<not> FAIL \\<notin> set (butlast (q1 # states p q1)) \\<Longrightarrow>\n    False", "have \"\\<forall> k . k < length p \\<longrightarrow> target (take k p) q1 \\<noteq> FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length p. target (take k p) q1 \\<noteq> FAIL", "using no_prefix_targets_FAIL[of A B FAIL AB p q1] assms p_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>productF A B FAIL AB; path AB p q1; ?k < length p\\<rbrakk>\n  \\<Longrightarrow> target (take ?k p) q1 \\<noteq> FAIL\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  q2 \\<in> reachable AB q1\n  q2 \\<noteq> FAIL\n  q1 \\<in> nodes AB\n  path AB p q1 \\<and> target p q1 = q2 \\<and> distinct (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. \\<forall>k<length p. target (take k p) q1 \\<noteq> FAIL", "by auto"], ["proof (state)\nthis:\n  \\<forall>k<length p. target (take k p) q1 \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. \\<not> FAIL \\<notin> set (butlast (q1 # states p q1)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  target (take i p) q1 = FAIL\n  \\<forall>k<length p. target (take k p) q1 \\<noteq> FAIL", "show \"False\""], ["proof (prove)\nusing this:\n  target (take i p) q1 = FAIL\n  \\<forall>k<length p. target (take k p) q1 \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. False", "by (metis assms(5) linorder_neqE_nat nat_less_le order_refl p_def take_all)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  FAIL \\<notin> set (butlast (q1 # states p q1))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)", "moreover"], ["proof (state)\nthis:\n  FAIL \\<notin> set (butlast (q1 # states p q1))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)", "have \"last (q1 # states p q1) \\<noteq> FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (q1 # states p q1) \\<noteq> FAIL", "using assms(5) local.Cons p_def transition_system_universal.target_alt_def"], ["proof (prove)\nusing this:\n  q2 \\<noteq> FAIL\n  p = a # list\n  path AB p q1 \\<and> target p q1 = q2 \\<and> distinct (q1 # states p q1)\n  fold ?execute ?r ?p = last (?p # scan ?execute ?r ?p)\n\ngoal (1 subgoal):\n 1. last (q1 # states p q1) \\<noteq> FAIL", "by force"], ["proof (state)\nthis:\n  last (q1 # states p q1) \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow> FAIL \\<notin> set (q1 # states p q1)", "ultimately"], ["proof (chain)\npicking this:\n  FAIL \\<notin> set (butlast (q1 # states p q1))\n  last (q1 # states p q1) \\<noteq> FAIL", "show ?thesis"], ["proof (prove)\nusing this:\n  FAIL \\<notin> set (butlast (q1 # states p q1))\n  last (q1 # states p q1) \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. FAIL \\<notin> set (q1 # states p q1)", "by (metis (no_types, lifting) UnE append_butlast_last_id list.set(1) list.set(2) \n          list.simps(3) set_append singletonD)"], ["proof (state)\nthis:\n  FAIL \\<notin> set (q1 # states p q1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  FAIL \\<notin> set (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "moreover"], ["proof (state)\nthis:\n  FAIL \\<notin> set (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "have \"set (q1 # states p q1) \\<subseteq> nodes AB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (q1 # states p q1) \\<subseteq> nodes AB", "using assms"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  q2 \\<in> reachable AB q1\n  q2 \\<noteq> FAIL\n  q1 \\<in> nodes AB\n\ngoal (1 subgoal):\n 1. set (q1 # states p q1) \\<subseteq> nodes AB", "by (metis FSM.nodes_states insert_subset list.simps(15) p_def)"], ["proof (state)\nthis:\n  set (q1 # states p q1) \\<subseteq> nodes AB\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "ultimately"], ["proof (chain)\npicking this:\n  FAIL \\<notin> set (q1 # states p q1)\n  set (q1 # states p q1) \\<subseteq> nodes AB", "have states_subset : \"set (q1 # states p q1) \\<subseteq> nodes A \\<times> nodes B\""], ["proof (prove)\nusing this:\n  FAIL \\<notin> set (q1 # states p q1)\n  set (q1 # states p q1) \\<subseteq> nodes AB\n\ngoal (1 subgoal):\n 1. set (q1 # states p q1) \\<subseteq> nodes A \\<times> nodes B", "using nodes_productF assms"], ["proof (prove)\nusing this:\n  FAIL \\<notin> set (q1 # states p q1)\n  set (q1 # states p q1) \\<subseteq> nodes AB\n  \\<lbrakk>well_formed ?M1.0; well_formed ?M2.0;\n   productF ?M2.0 ?M1.0 ?FAIL ?PM\\<rbrakk>\n  \\<Longrightarrow> nodes ?PM\n                    \\<subseteq> insert ?FAIL\n                                 (nodes ?M2.0 \\<times> nodes ?M1.0)\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  q2 \\<in> reachable AB q1\n  q2 \\<noteq> FAIL\n  q1 \\<in> nodes AB\n\ngoal (1 subgoal):\n 1. set (q1 # states p q1) \\<subseteq> nodes A \\<times> nodes B", "by blast"], ["proof (state)\nthis:\n  set (q1 # states p q1) \\<subseteq> nodes A \\<times> nodes B\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "have finite_nodes : \"finite (nodes A \\<times> nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes A \\<times> nodes B)", "using assms(2) assms(3)"], ["proof (prove)\nusing this:\n  well_formed A\n  well_formed B\n\ngoal (1 subgoal):\n 1. finite (nodes A \\<times> nodes B)", "by auto"], ["proof (state)\nthis:\n  finite (nodes A \\<times> nodes B)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "have \"length p \\<le> length (states p q1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p \\<le> length (states p q1)", "by simp"], ["proof (state)\nthis:\n  length p \\<le> length (states p q1)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "then"], ["proof (chain)\npicking this:\n  length p \\<le> length (states p q1)", "have \"length p < card (nodes A) * card (nodes B)\""], ["proof (prove)\nusing this:\n  length p \\<le> length (states p q1)\n\ngoal (1 subgoal):\n 1. length p < |A| * |B|", "by (metis (no_types) finite_nodes states_subset card_cartesian_product card_mono distinct_card \n        impossible_Cons less_le_trans not_less p_def)"], ["proof (state)\nthis:\n  length p < |A| * |B|\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "then"], ["proof (chain)\npicking this:\n  length p < |A| * |B|", "show ?thesis"], ["proof (prove)\nusing this:\n  length p < |A| * |B|\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "using p_def"], ["proof (prove)\nusing this:\n  length p < |A| * |B|\n  path AB p q1 \\<and> target p q1 = q2 \\<and> distinct (q1 # states p q1)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|", "by blast"], ["proof (state)\nthis:\n  \\<exists>p.\n     path AB p q1 \\<and> target p q1 = q2 \\<and> length p < |A| * |B|\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reaching_path_fail_length :\n  assumes \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"q2 \\<in> reachable AB q1\"\n  and     \"q1 \\<in> nodes AB\"\nshows \"\\<exists> p . path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> card (nodes A) * card (nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "proof (cases \"q2 = FAIL\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q2 = FAIL \\<Longrightarrow>\n    \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|\n 2. q2 \\<noteq> FAIL \\<Longrightarrow>\n    \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "case True"], ["proof (state)\nthis:\n  q2 = FAIL\n\ngoal (2 subgoals):\n 1. q2 = FAIL \\<Longrightarrow>\n    \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|\n 2. q2 \\<noteq> FAIL \\<Longrightarrow>\n    \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "then"], ["proof (chain)\npicking this:\n  q2 = FAIL", "have q2_def : \"q2 = FAIL\""], ["proof (prove)\nusing this:\n  q2 = FAIL\n\ngoal (1 subgoal):\n 1. q2 = FAIL", "by simp"], ["proof (state)\nthis:\n  q2 = FAIL\n\ngoal (2 subgoals):\n 1. q2 = FAIL \\<Longrightarrow>\n    \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|\n 2. q2 \\<noteq> FAIL \\<Longrightarrow>\n    \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "then"], ["proof (chain)\npicking this:\n  q2 = FAIL", "show ?thesis"], ["proof (prove)\nusing this:\n  q2 = FAIL\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "proof (cases \"q1 = q2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>q2 = FAIL; q1 = q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|\n 2. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "case True"], ["proof (state)\nthis:\n  q1 = q2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>q2 = FAIL; q1 = q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|\n 2. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "then"], ["proof (chain)\npicking this:\n  q1 = q2", "show ?thesis"], ["proof (prove)\nusing this:\n  q1 = q2\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "by auto"], ["proof (state)\nthis:\n  \\<exists>p.\n     path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "case False"], ["proof (state)\nthis:\n  q1 \\<noteq> q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "then"], ["proof (chain)\npicking this:\n  q1 \\<noteq> q2", "obtain px where px_def : \"path AB px q1 \\<and> target px q1 = q2\""], ["proof (prove)\nusing this:\n  q1 \\<noteq> q2\n\ngoal (1 subgoal):\n 1. (\\<And>px.\n        path AB px q1 \\<and> target px q1 = q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  q1 \\<noteq> q2\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  q2 \\<in> reachable AB q1\n  q1 \\<in> nodes AB\n\ngoal (1 subgoal):\n 1. (\\<And>px.\n        path AB px q1 \\<and> target px q1 = q2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path AB px q1 \\<and> target px q1 = q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "then"], ["proof (chain)\npicking this:\n  path AB px q1 \\<and> target px q1 = q2", "have px_nonempty : \"px \\<noteq> []\""], ["proof (prove)\nusing this:\n  path AB px q1 \\<and> target px q1 = q2\n\ngoal (1 subgoal):\n 1. px \\<noteq> []", "using q2_def False"], ["proof (prove)\nusing this:\n  path AB px q1 \\<and> target px q1 = q2\n  q2 = FAIL\n  q1 \\<noteq> q2\n\ngoal (1 subgoal):\n 1. px \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  px \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "let ?qx = \"target (butlast px) q1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "have \"?qx \\<in> reachable AB q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (butlast px) q1 \\<in> reachable AB q1", "using px_def px_nonempty"], ["proof (prove)\nusing this:\n  path AB px q1 \\<and> target px q1 = q2\n  px \\<noteq> []\n\ngoal (1 subgoal):\n 1. target (butlast px) q1 \\<in> reachable AB q1", "by (metis FSM.path_append_elim FSM.reachable.reflexive FSM.reachable_target \n          append_butlast_last_id)"], ["proof (state)\nthis:\n  target (butlast px) q1 \\<in> reachable AB q1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "moreover"], ["proof (state)\nthis:\n  target (butlast px) q1 \\<in> reachable AB q1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "have \"?qx \\<noteq> FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (butlast px) q1 \\<noteq> FAIL", "using False q2_def assms"], ["proof (prove)\nusing this:\n  q1 \\<noteq> q2\n  q2 = FAIL\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  q2 \\<in> reachable AB q1\n  q1 \\<in> nodes AB\n\ngoal (1 subgoal):\n 1. target (butlast px) q1 \\<noteq> FAIL", "by (metis One_nat_def Suc_pred butlast_conv_take length_greater_0_conv lessI \n          no_prefix_targets_FAIL px_def px_nonempty)"], ["proof (state)\nthis:\n  target (butlast px) q1 \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "ultimately"], ["proof (chain)\npicking this:\n  target (butlast px) q1 \\<in> reachable AB q1\n  target (butlast px) q1 \\<noteq> FAIL", "obtain px' where px'_def : \"path AB px' q1 \n                                            \\<and> target px' q1 = ?qx \n                                            \\<and> length px' < card (nodes A) * card (nodes B)\""], ["proof (prove)\nusing this:\n  target (butlast px) q1 \\<in> reachable AB q1\n  target (butlast px) q1 \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. (\\<And>px'.\n        path AB px' q1 \\<and>\n        target px' q1 = target (butlast px) q1 \\<and>\n        length px' < |A| * |B| \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms reaching_path_length[of A B FAIL AB ?qx q1]"], ["proof (prove)\nusing this:\n  target (butlast px) q1 \\<in> reachable AB q1\n  target (butlast px) q1 \\<noteq> FAIL\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  q2 \\<in> reachable AB q1\n  q1 \\<in> nodes AB\n  \\<lbrakk>productF A B FAIL AB; well_formed A; well_formed B;\n   target (butlast px) q1 \\<in> reachable AB q1;\n   target (butlast px) q1 \\<noteq> FAIL; q1 \\<in> nodes AB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       path AB p q1 \\<and>\n                       target p q1 = target (butlast px) q1 \\<and>\n                       length p < |A| * |B|\n\ngoal (1 subgoal):\n 1. (\\<And>px'.\n        path AB px' q1 \\<and>\n        target px' q1 = target (butlast px) q1 \\<and>\n        length px' < |A| * |B| \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path AB px' q1 \\<and>\n  target px' q1 = target (butlast px) q1 \\<and> length px' < |A| * |B|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "have px_split : \"path AB ((butlast px) @ [last px]) q1 \n                      \\<and> target ((butlast px) @ [last px]) q1 = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path AB (butlast px @ [last px]) q1 \\<and>\n    target (butlast px @ [last px]) q1 = q2", "using px_def px_nonempty"], ["proof (prove)\nusing this:\n  path AB px q1 \\<and> target px q1 = q2\n  px \\<noteq> []\n\ngoal (1 subgoal):\n 1. path AB (butlast px @ [last px]) q1 \\<and>\n    target (butlast px @ [last px]) q1 = q2", "by auto"], ["proof (state)\nthis:\n  path AB (butlast px @ [last px]) q1 \\<and>\n  target (butlast px @ [last px]) q1 = q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "then"], ["proof (chain)\npicking this:\n  path AB (butlast px @ [last px]) q1 \\<and>\n  target (butlast px @ [last px]) q1 = q2", "have \"path AB [last px] ?qx \\<and> target [last px] ?qx = q2\""], ["proof (prove)\nusing this:\n  path AB (butlast px @ [last px]) q1 \\<and>\n  target (butlast px @ [last px]) q1 = q2\n\ngoal (1 subgoal):\n 1. path AB [last px] (target (butlast px) q1) \\<and>\n    target [last px] (target (butlast px) q1) = q2", "using px_nonempty"], ["proof (prove)\nusing this:\n  path AB (butlast px @ [last px]) q1 \\<and>\n  target (butlast px @ [last px]) q1 = q2\n  px \\<noteq> []\n\ngoal (1 subgoal):\n 1. path AB [last px] (target (butlast px) q1) \\<and>\n    target [last px] (target (butlast px) q1) = q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>path AB (butlast px @ [last px]) q1 \\<and>\n             target (butlast px @ [last px]) q1 = q2;\n     px \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> path AB [last px] (target (butlast px) q1) \\<and>\n                      target [last px] (target (butlast px) q1) = q2", "have \"target [last px] (target (butlast px) q1) = q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target [last px] (target (butlast px) q1) = q2", "using px_split"], ["proof (prove)\nusing this:\n  path AB (butlast px @ [last px]) q1 \\<and>\n  target (butlast px @ [last px]) q1 = q2\n\ngoal (1 subgoal):\n 1. target [last px] (target (butlast px) q1) = q2", "by force"], ["proof (state)\nthis:\n  target [last px] (target (butlast px) q1) = q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path AB (butlast px @ [last px]) q1 \\<and>\n             target (butlast px @ [last px]) q1 = q2;\n     px \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> path AB [last px] (target (butlast px) q1) \\<and>\n                      target [last px] (target (butlast px) q1) = q2", "then"], ["proof (chain)\npicking this:\n  target [last px] (target (butlast px) q1) = q2", "show ?thesis"], ["proof (prove)\nusing this:\n  target [last px] (target (butlast px) q1) = q2\n\ngoal (1 subgoal):\n 1. path AB [last px] (target (butlast px) q1) \\<and>\n    target [last px] (target (butlast px) q1) = q2", "using px_split"], ["proof (prove)\nusing this:\n  target [last px] (target (butlast px) q1) = q2\n  path AB (butlast px @ [last px]) q1 \\<and>\n  target (butlast px @ [last px]) q1 = q2\n\ngoal (1 subgoal):\n 1. path AB [last px] (target (butlast px) q1) \\<and>\n    target [last px] (target (butlast px) q1) = q2", "by blast"], ["proof (state)\nthis:\n  path AB [last px] (target (butlast px) q1) \\<and>\n  target [last px] (target (butlast px) q1) = q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path AB [last px] (target (butlast px) q1) \\<and>\n  target [last px] (target (butlast px) q1) = q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "then"], ["proof (chain)\npicking this:\n  path AB [last px] (target (butlast px) q1) \\<and>\n  target [last px] (target (butlast px) q1) = q2", "have \"path AB (px' @ [last px]) q1 \\<and> target (px' @ [last px]) q1 = q2\""], ["proof (prove)\nusing this:\n  path AB [last px] (target (butlast px) q1) \\<and>\n  target [last px] (target (butlast px) q1) = q2\n\ngoal (1 subgoal):\n 1. path AB (px' @ [last px]) q1 \\<and> target (px' @ [last px]) q1 = q2", "using px'_def"], ["proof (prove)\nusing this:\n  path AB [last px] (target (butlast px) q1) \\<and>\n  target [last px] (target (butlast px) q1) = q2\n  path AB px' q1 \\<and>\n  target px' q1 = target (butlast px) q1 \\<and> length px' < |A| * |B|\n\ngoal (1 subgoal):\n 1. path AB (px' @ [last px]) q1 \\<and> target (px' @ [last px]) q1 = q2", "by auto"], ["proof (state)\nthis:\n  path AB (px' @ [last px]) q1 \\<and> target (px' @ [last px]) q1 = q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "moreover"], ["proof (state)\nthis:\n  path AB (px' @ [last px]) q1 \\<and> target (px' @ [last px]) q1 = q2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "have \"length (px' @ [last px]) \\<le> card (nodes A) * card (nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (px' @ [last px]) \\<le> |A| * |B|", "using px'_def"], ["proof (prove)\nusing this:\n  path AB px' q1 \\<and>\n  target px' q1 = target (butlast px) q1 \\<and> length px' < |A| * |B|\n\ngoal (1 subgoal):\n 1. length (px' @ [last px]) \\<le> |A| * |B|", "by auto"], ["proof (state)\nthis:\n  length (px' @ [last px]) \\<le> |A| * |B|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q2 = FAIL; q1 \\<noteq> q2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         path AB p q1 \\<and>\n                         target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "ultimately"], ["proof (chain)\npicking this:\n  path AB (px' @ [last px]) q1 \\<and> target (px' @ [last px]) q1 = q2\n  length (px' @ [last px]) \\<le> |A| * |B|", "show ?thesis"], ["proof (prove)\nusing this:\n  path AB (px' @ [last px]) q1 \\<and> target (px' @ [last px]) q1 = q2\n  length (px' @ [last px]) \\<le> |A| * |B|\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "by blast"], ["proof (state)\nthis:\n  \\<exists>p.\n     path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p.\n     path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|\n\ngoal (1 subgoal):\n 1. q2 \\<noteq> FAIL \\<Longrightarrow>\n    \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q2 \\<noteq> FAIL \\<Longrightarrow>\n    \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "case False"], ["proof (state)\nthis:\n  q2 \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. q2 \\<noteq> FAIL \\<Longrightarrow>\n    \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "then"], ["proof (chain)\npicking this:\n  q2 \\<noteq> FAIL", "show ?thesis"], ["proof (prove)\nusing this:\n  q2 \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "using assms reaching_path_length"], ["proof (prove)\nusing this:\n  q2 \\<noteq> FAIL\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  q2 \\<in> reachable AB q1\n  q1 \\<in> nodes AB\n  \\<lbrakk>productF ?A ?B ?FAIL ?AB; well_formed ?A; well_formed ?B;\n   ?q2.0 \\<in> reachable ?AB ?q1.0; ?q2.0 \\<noteq> ?FAIL;\n   ?q1.0 \\<in> nodes ?AB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p.\n                       path ?AB p ?q1.0 \\<and>\n                       target p ?q1.0 = ?q2.0 \\<and> length p < |?A| * |?B|\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|", "by (metis less_imp_le)"], ["proof (state)\nthis:\n  \\<exists>p.\n     path AB p q1 \\<and> target p q1 = q2 \\<and> length p \\<le> |A| * |B|\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma productF_language :\n  assumes \"productF A B FAIL AB\"\n  and     \"well_formed A\"\n  and     \"well_formed B\"\n  and     \"io \\<in> L A \\<inter> L B\"\nshows \"io \\<in> L AB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<in> L AB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io \\<in> L AB", "obtain trA trB where tr_def : \"path A (io || trA) (initial A) \\<and> length io = length trA\" \n                                \"path B (io || trB) (initial B) \\<and> length io = length trB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>trA trB.\n        \\<lbrakk>path A (io || trA) (initial A) \\<and>\n                 length io = length trA;\n         path B (io || trB) (initial B) \\<and>\n         length io = length trB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  io \\<in> L A \\<inter> L B\n\ngoal (1 subgoal):\n 1. (\\<And>trA trB.\n        \\<lbrakk>path A (io || trA) (initial A) \\<and>\n                 length io = length trA;\n         path B (io || trB) (initial B) \\<and>\n         length io = length trB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path A (io || trA) (initial A) \\<and> length io = length trA\n  path B (io || trB) (initial B) \\<and> length io = length trB\n\ngoal (1 subgoal):\n 1. io \\<in> L AB", "then"], ["proof (chain)\npicking this:\n  path A (io || trA) (initial A) \\<and> length io = length trA\n  path B (io || trB) (initial B) \\<and> length io = length trB", "have \"path AB (io || trA || trB) (initial A, initial B)\""], ["proof (prove)\nusing this:\n  path A (io || trA) (initial A) \\<and> length io = length trA\n  path B (io || trB) (initial B) \\<and> length io = length trB\n\ngoal (1 subgoal):\n 1. path AB (io || trA || trB) (initial A, initial B)", "using assms"], ["proof (prove)\nusing this:\n  path A (io || trA) (initial A) \\<and> length io = length trA\n  path B (io || trB) (initial B) \\<and> length io = length trB\n  productF A B FAIL AB\n  well_formed A\n  well_formed B\n  io \\<in> L A \\<inter> L B\n\ngoal (1 subgoal):\n 1. path AB (io || trA || trB) (initial A, initial B)", "by (metis FSM.nodes.initial productF_path_inclusion)"], ["proof (state)\nthis:\n  path AB (io || trA || trB) (initial A, initial B)\n\ngoal (1 subgoal):\n 1. io \\<in> L AB", "then"], ["proof (chain)\npicking this:\n  path AB (io || trA || trB) (initial A, initial B)", "show ?thesis"], ["proof (prove)\nusing this:\n  path AB (io || trA || trB) (initial A, initial B)\n\ngoal (1 subgoal):\n 1. io \\<in> L AB", "using tr_def"], ["proof (prove)\nusing this:\n  path AB (io || trA || trB) (initial A, initial B)\n  path A (io || trA) (initial A) \\<and> length io = length trA\n  path B (io || trB) (initial B) \\<and> length io = length trB\n\ngoal (1 subgoal):\n 1. io \\<in> L AB", "by (metis assms(1) language_state length_zip min.idem productF_simps(4))"], ["proof (state)\nthis:\n  io \\<in> L AB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma productF_language_state_intermediate :\n  assumes \"vs @ xs \\<in> L M2 \\<inter> L M1\"\n  and     \"productF M2 M1 FAIL PM\"\n  and     \"observable M2\"\n  and     \"well_formed M2\"\n  and     \"observable M1\"\n  and     \"well_formed M1\"\nobtains q2 q1 tr \nwhere \"io_targets PM (initial PM) vs = {(q2,q1)}\"\n      \"path PM (xs || tr) (q2,q1)\" \n      \"length xs = length tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"vs @ xs \\<in> L PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L PM", "using productF_language[OF assms(2,4,6,1)]"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L PM\n\ngoal (1 subgoal):\n 1. vs @ xs \\<in> L PM", "by simp"], ["proof (state)\nthis:\n  vs @ xs \\<in> L PM\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  vs @ xs \\<in> L PM", "obtain trVX where \"path PM (vs@xs || trVX) (initial PM) \\<and> length trVX = length (vs@xs)\""], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L PM\n\ngoal (1 subgoal):\n 1. (\\<And>trVX.\n        path PM (vs @ xs || trVX) (initial PM) \\<and>\n        length trVX = length (vs @ xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path PM (vs @ xs || trVX) (initial PM) \\<and>\n  length trVX = length (vs @ xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  path PM (vs @ xs || trVX) (initial PM) \\<and>\n  length trVX = length (vs @ xs)", "have tgt_VX : \"io_targets PM (initial PM) (vs@xs) = {target (vs@xs || trVX) (initial PM)}\""], ["proof (prove)\nusing this:\n  path PM (vs @ xs || trVX) (initial PM) \\<and>\n  length trVX = length (vs @ xs)\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) (vs @ xs) =\n    {target (vs @ xs || trVX) (initial PM)}", "by (metis assms(2) assms(3) assms(5) obs_target_is_io_targets observable_productF)"], ["proof (state)\nthis:\n  io_targets PM (initial PM) (vs @ xs) =\n  {target (vs @ xs || trVX) (initial PM)}\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"vs \\<in> L PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> L PM", "using \\<open>vs@xs \\<in> L PM\\<close>"], ["proof (prove)\nusing this:\n  vs @ xs \\<in> L PM\n\ngoal (1 subgoal):\n 1. vs \\<in> L PM", "by (meson language_state_prefix)"], ["proof (state)\nthis:\n  vs \\<in> L PM\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  vs \\<in> L PM", "obtain trV where \"path PM (vs || trV) (initial PM) \\<and> length trV = length vs\""], ["proof (prove)\nusing this:\n  vs \\<in> L PM\n\ngoal (1 subgoal):\n 1. (\\<And>trV.\n        path PM (vs || trV) (initial PM) \\<and>\n        length trV = length vs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path PM (vs || trV) (initial PM) \\<and> length trV = length vs\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  path PM (vs || trV) (initial PM) \\<and> length trV = length vs", "have tgt_V : \"io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}\""], ["proof (prove)\nusing this:\n  path PM (vs || trV) (initial PM) \\<and> length trV = length vs\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}", "by (metis assms(2) assms(3) assms(5) obs_target_is_io_targets observable_productF)"], ["proof (state)\nthis:\n  io_targets PM (initial PM) vs = {target (vs || trV) (initial PM)}\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?q2 = \"fst (target (vs || trV) (initial PM))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?q1 = \"snd (target (vs || trV) (initial PM))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable PM", "by (meson assms(2,3,5) observable_productF)"], ["proof (state)\nthis:\n  observable PM\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"io_targets PM (?q2,?q1) xs = {target (vs @ xs || trVX) (initial PM)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets PM\n     (fst (target (vs || trV) (initial PM)),\n      snd (target (vs || trV) (initial PM)))\n     xs =\n    {target (vs @ xs || trVX) (initial PM)}", "using observable_io_targets_split[OF \\<open>observable PM\\<close> tgt_VX tgt_V]"], ["proof (prove)\nusing this:\n  io_targets PM (target (vs || trV) (initial PM)) xs =\n  {target (vs @ xs || trVX) (initial PM)}\n\ngoal (1 subgoal):\n 1. io_targets PM\n     (fst (target (vs || trV) (initial PM)),\n      snd (target (vs || trV) (initial PM)))\n     xs =\n    {target (vs @ xs || trVX) (initial PM)}", "by simp"], ["proof (state)\nthis:\n  io_targets PM\n   (fst (target (vs || trV) (initial PM)),\n    snd (target (vs || trV) (initial PM)))\n   xs =\n  {target (vs @ xs || trVX) (initial PM)}\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  io_targets PM\n   (fst (target (vs || trV) (initial PM)),\n    snd (target (vs || trV) (initial PM)))\n   xs =\n  {target (vs @ xs || trVX) (initial PM)}", "have \"xs \\<in> language_state PM (?q2,?q1)\""], ["proof (prove)\nusing this:\n  io_targets PM\n   (fst (target (vs || trV) (initial PM)),\n    snd (target (vs || trV) (initial PM)))\n   xs =\n  {target (vs @ xs || trVX) (initial PM)}\n\ngoal (1 subgoal):\n 1. xs \\<in> LS PM\n              (fst (target (vs || trV) (initial PM)),\n               snd (target (vs || trV) (initial PM)))", "by auto"], ["proof (state)\nthis:\n  xs \\<in> LS PM\n            (fst (target (vs || trV) (initial PM)),\n             snd (target (vs || trV) (initial PM)))\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  xs \\<in> LS PM\n            (fst (target (vs || trV) (initial PM)),\n             snd (target (vs || trV) (initial PM)))", "obtain tr where \"path PM (xs || tr) (?q2,?q1)\" \n                       \"length xs = length tr\""], ["proof (prove)\nusing this:\n  xs \\<in> LS PM\n            (fst (target (vs || trV) (initial PM)),\n             snd (target (vs || trV) (initial PM)))\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>path PM (xs || tr)\n                  (fst (target (vs || trV) (initial PM)),\n                   snd (target (vs || trV) (initial PM)));\n         length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path PM (xs || tr)\n   (fst (target (vs || trV) (initial PM)),\n    snd (target (vs || trV) (initial PM)))\n  length xs = length tr\n\ngoal (1 subgoal):\n 1. (\\<And>q2 q1 tr.\n        \\<lbrakk>io_targets PM (initial PM) vs = {(q2, q1)};\n         path PM (xs || tr) (q2, q1); length xs = length tr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  path PM (xs || tr)\n   (fst (target (vs || trV) (initial PM)),\n    snd (target (vs || trV) (initial PM)))\n  length xs = length tr", "show ?thesis"], ["proof (prove)\nusing this:\n  path PM (xs || tr)\n   (fst (target (vs || trV) (initial PM)),\n    snd (target (vs || trV) (initial PM)))\n  length xs = length tr\n\ngoal (1 subgoal):\n 1. thesis", "by (metis prod.collapse tgt_V that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sequence_to_failure_reaches_FAIL :\n  assumes \"sequence_to_failure M1 M2 io\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"FAIL \\<in> io_targets PM (initial PM) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<in> io_targets PM (initial PM) io", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. FAIL \\<in> io_targets PM (initial PM) io", "obtain p where \"path PM (io || p) (initial PM) \n                    \\<and> length p = length io \n                    \\<and> target (io || p) (initial PM) = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using fail_reachable_by_sequence_to_failure[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 ?FAIL ?PM;\n   \\<And>p.\n      path ?PM (io || p) (initial ?PM) \\<and>\n      length p = length io \\<and>\n      target (io || p) (initial ?PM) = ?FAIL \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) assms(3) assms(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed M1; well_formed M2; productF M2 M1 ?FAIL ?PM;\n   \\<And>p.\n      path ?PM (io || p) (initial ?PM) \\<and>\n      length p = length io \\<and>\n      target (io || p) (initial ?PM) = ?FAIL \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  OFSM M1\n  OFSM M2\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        path PM (io || p) (initial PM) \\<and>\n        length p = length io \\<and>\n        target (io || p) (initial PM) = FAIL \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path PM (io || p) (initial PM) \\<and>\n  length p = length io \\<and> target (io || p) (initial PM) = FAIL\n\ngoal (1 subgoal):\n 1. FAIL \\<in> io_targets PM (initial PM) io", "then"], ["proof (chain)\npicking this:\n  path PM (io || p) (initial PM) \\<and>\n  length p = length io \\<and> target (io || p) (initial PM) = FAIL", "show ?thesis"], ["proof (prove)\nusing this:\n  path PM (io || p) (initial PM) \\<and>\n  length p = length io \\<and> target (io || p) (initial PM) = FAIL\n\ngoal (1 subgoal):\n 1. FAIL \\<in> io_targets PM (initial PM) io", "by auto"], ["proof (state)\nthis:\n  FAIL \\<in> io_targets PM (initial PM) io\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sequence_to_failure_reaches_FAIL_ob :\n  assumes \"sequence_to_failure M1 M2 io\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"io_targets PM (initial PM) io = {FAIL}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {FAIL}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {FAIL}", "have \"FAIL \\<in> io_targets PM (initial PM) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<in> io_targets PM (initial PM) io", "using sequence_to_failure_reaches_FAIL[OF assms(1-4)]"], ["proof (prove)\nusing this:\n  FAIL \\<in> io_targets PM (initial PM) io\n\ngoal (1 subgoal):\n 1. FAIL \\<in> io_targets PM (initial PM) io", "by assumption"], ["proof (state)\nthis:\n  FAIL \\<in> io_targets PM (initial PM) io\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {FAIL}", "have \"observable PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable PM", "by (meson assms(2) assms(3) assms(4) observable_productF)"], ["proof (state)\nthis:\n  observable PM\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {FAIL}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {FAIL}", "by (meson \\<open>FAIL \\<in> io_targets PM (initial PM) io\\<close> \\<open>observable PM\\<close> \n        observable_io_target_is_singleton)"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io = {FAIL}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sequence_to_failure_alt_def :\n  assumes \"io_targets PM (initial PM) io = {FAIL}\"\n  and     \"OFSM M1\"\n  and     \"OFSM M2\"\n  and     \"productF M2 M1 FAIL PM\"\nshows \"sequence_to_failure M1 M2 io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "obtain p where \"path PM (io || p) (initial PM)\" \n                 \"length p = length io\" \n                 \"target (io || p) (initial PM) = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path PM (io || p) (initial PM); length p = length io;\n         target (io || p) (initial PM) = FAIL\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io = {FAIL}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>path PM (io || p) (initial PM); length p = length io;\n         target (io || p) (initial PM) = FAIL\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis io_targets_elim singletonI)"], ["proof (state)\nthis:\n  path PM (io || p) (initial PM)\n  length p = length io\n  target (io || p) (initial PM) = FAIL\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"io \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. io = [] \\<Longrightarrow> False", "assume \"io = []\""], ["proof (state)\nthis:\n  io = []\n\ngoal (1 subgoal):\n 1. io = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io = []", "have \"io_targets PM (initial PM) io = {initial PM}\""], ["proof (prove)\nusing this:\n  io = []\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io = {initial PM}", "by auto"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io = {initial PM}\n\ngoal (1 subgoal):\n 1. io = [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io = {initial PM}\n\ngoal (1 subgoal):\n 1. io = [] \\<Longrightarrow> False", "have \"initial PM \\<noteq> FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial PM \\<noteq> FAIL", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. initial PM \\<noteq> FAIL", "have \"initial PM = (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial PM = (initial M2, initial M1)", "using assms(4)"], ["proof (prove)\nusing this:\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. initial PM = (initial M2, initial M1)", "by auto"], ["proof (state)\nthis:\n  initial PM = (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. initial PM \\<noteq> FAIL", "then"], ["proof (chain)\npicking this:\n  initial PM = (initial M2, initial M1)", "have \"initial PM \\<in> (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\nusing this:\n  initial PM = (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. initial PM \\<in> nodes M2 \\<times> nodes M1", "by (simp add: FSM.nodes.initial)"], ["proof (state)\nthis:\n  initial PM \\<in> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. initial PM \\<noteq> FAIL", "moreover"], ["proof (state)\nthis:\n  initial PM \\<in> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. initial PM \\<noteq> FAIL", "have \"FAIL \\<notin> (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<notin> nodes M2 \\<times> nodes M1", "using assms(4)"], ["proof (prove)\nusing this:\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. FAIL \\<notin> nodes M2 \\<times> nodes M1", "by auto"], ["proof (state)\nthis:\n  FAIL \\<notin> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. initial PM \\<noteq> FAIL", "ultimately"], ["proof (chain)\npicking this:\n  initial PM \\<in> nodes M2 \\<times> nodes M1\n  FAIL \\<notin> nodes M2 \\<times> nodes M1", "show ?thesis"], ["proof (prove)\nusing this:\n  initial PM \\<in> nodes M2 \\<times> nodes M1\n  FAIL \\<notin> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. initial PM \\<noteq> FAIL", "by auto"], ["proof (state)\nthis:\n  initial PM \\<noteq> FAIL\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  initial PM \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. io = [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  io_targets PM (initial PM) io = {initial PM}\n  initial PM \\<noteq> FAIL", "show \"False\""], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io = {initial PM}\n  initial PM \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. False", "using assms(1)"], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io = {initial PM}\n  initial PM \\<noteq> FAIL\n  io_targets PM (initial PM) io = {FAIL}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  io \\<noteq> []\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "then"], ["proof (chain)\npicking this:\n  io \\<noteq> []", "have \"0 < length io\""], ["proof (prove)\nusing this:\n  io \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length io", "by blast"], ["proof (state)\nthis:\n  0 < length io\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"target (butlast (io||p)) (initial PM) \\<noteq> FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (butlast (io || p)) (initial PM) \\<noteq> FAIL", "using no_prefix_targets_FAIL[OF assms(4) \\<open>path PM (io || p) (initial PM)\\<close>, of \"(length io) - 1\"]"], ["proof (prove)\nusing this:\n  length io - 1 < length (io || p) \\<Longrightarrow>\n  target (take (length io - 1) (io || p)) (initial PM) \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. target (butlast (io || p)) (initial PM) \\<noteq> FAIL", "by (metis (no_types, lifting) \\<open>0 < length io\\<close> \\<open>length p = length io\\<close> butlast_conv_take \n        diff_less length_map less_numeral_extra(1) map_fst_zip)"], ["proof (state)\nthis:\n  target (butlast (io || p)) (initial PM) \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"target (butlast (io||p)) (initial PM) \\<in> nodes PM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (butlast (io || p)) (initial PM) \\<in> nodes PM", "by (metis FSM.nodes.initial FSM.nodes_target FSM.path_append_elim \n        \\<open>path PM (io || p) (initial PM)\\<close> append_butlast_last_id butlast.simps(1))"], ["proof (state)\nthis:\n  target (butlast (io || p)) (initial PM) \\<in> nodes PM\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "moreover"], ["proof (state)\nthis:\n  target (butlast (io || p)) (initial PM) \\<in> nodes PM\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)", "using nodes_productF[OF _ _ assms(4)] assms(2) assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed M1; well_formed M2\\<rbrakk>\n  \\<Longrightarrow> nodes PM\n                    \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\n  OFSM M1\n  OFSM M2\n\ngoal (1 subgoal):\n 1. nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)", "by linarith"], ["proof (state)\nthis:\n  nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "ultimately"], ["proof (chain)\npicking this:\n  target (butlast (io || p)) (initial PM) \\<in> nodes PM\n  nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)", "have \"target (butlast (io||p)) (initial PM) \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\nusing this:\n  target (butlast (io || p)) (initial PM) \\<in> nodes PM\n  nodes PM \\<subseteq> insert FAIL (nodes M2 \\<times> nodes M1)\n\ngoal (1 subgoal):\n 1. target (butlast (io || p)) (initial PM)\n    \\<in> insert FAIL (nodes M2 \\<times> nodes M1)", "by blast"], ["proof (state)\nthis:\n  target (butlast (io || p)) (initial PM)\n  \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"target (butlast (io||p)) (initial PM) \\<in> (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (butlast (io || p)) (initial PM) \\<in> nodes M2 \\<times> nodes M1", "using \\<open>target (butlast (io || p)) (initial PM) \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\\<close> \n          \\<open>target (butlast (io || p)) (initial PM) \\<noteq> FAIL\\<close>"], ["proof (prove)\nusing this:\n  target (butlast (io || p)) (initial PM)\n  \\<in> insert FAIL (nodes M2 \\<times> nodes M1)\n  target (butlast (io || p)) (initial PM) \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. target (butlast (io || p)) (initial PM) \\<in> nodes M2 \\<times> nodes M1", "by blast"], ["proof (state)\nthis:\n  target (butlast (io || p)) (initial PM) \\<in> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "then"], ["proof (chain)\npicking this:\n  target (butlast (io || p)) (initial PM) \\<in> nodes M2 \\<times> nodes M1", "obtain s2 s1 where \"target (butlast (io||p)) (initial PM) = (s2,s1)\" \n                          \"s2 \\<in> nodes M2\" \"s1 \\<in> nodes M1\""], ["proof (prove)\nusing this:\n  target (butlast (io || p)) (initial PM) \\<in> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. (\\<And>s2 s1.\n        \\<lbrakk>target (butlast (io || p)) (initial PM) = (s2, s1);\n         s2 \\<in> nodes M2; s1 \\<in> nodes M1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  target (butlast (io || p)) (initial PM) = (s2, s1)\n  s2 \\<in> nodes M2\n  s1 \\<in> nodes M1\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"length (butlast io) = length (map fst (butlast p))\" \n       \"length (map fst (butlast p)) = length (map snd (butlast p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (butlast io) = length (map fst (butlast p)) &&&\n    length (map fst (butlast p)) = length (map snd (butlast p))", "by (simp add: \\<open>length p = length io\\<close>)+"], ["proof (state)\nthis:\n  length (butlast io) = length (map fst (butlast p))\n  length (map fst (butlast p)) = length (map snd (butlast p))\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"path PM (butlast (io||p)) (initial PM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (butlast (io || p)) (initial PM)", "by (metis FSM.path_append_elim \\<open>path PM (io || p) (initial PM)\\<close> append_butlast_last_id \n        butlast.simps(1))"], ["proof (state)\nthis:\n  path PM (butlast (io || p)) (initial PM)\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "then"], ["proof (chain)\npicking this:\n  path PM (butlast (io || p)) (initial PM)", "have \"path PM ((butlast io) || (map fst (butlast p)) || (map snd (butlast p))) \n                      (initial M2, initial M1)\""], ["proof (prove)\nusing this:\n  path PM (butlast (io || p)) (initial PM)\n\ngoal (1 subgoal):\n 1. path PM (butlast io || map fst (butlast p) || map snd (butlast p))\n     (initial M2, initial M1)", "using \\<open>length p = length io\\<close> assms(4)"], ["proof (prove)\nusing this:\n  path PM (butlast (io || p)) (initial PM)\n  length p = length io\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. path PM (butlast io || map fst (butlast p) || map snd (butlast p))\n     (initial M2, initial M1)", "by auto"], ["proof (state)\nthis:\n  path PM (butlast io || map fst (butlast p) || map snd (butlast p))\n   (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"target (butlast io || map fst (butlast p) || map snd (butlast p)) (initial M2, initial M1) \n        \\<noteq> FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (butlast io || map fst (butlast p) || map snd (butlast p))\n     (initial M2, initial M1) \\<noteq>\n    FAIL", "using \\<open>length p = length io\\<close> \\<open>target (butlast (io || p)) (initial PM) \\<noteq> FAIL\\<close> assms(4)"], ["proof (prove)\nusing this:\n  length p = length io\n  target (butlast (io || p)) (initial PM) \\<noteq> FAIL\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. target (butlast io || map fst (butlast p) || map snd (butlast p))\n     (initial M2, initial M1) \\<noteq>\n    FAIL", "by auto"], ["proof (state)\nthis:\n  target (butlast io || map fst (butlast p) || map snd (butlast p))\n   (initial M2, initial M1) \\<noteq>\n  FAIL\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"path M2 (butlast io || map fst (butlast p)) (initial M2) \\<and>\n          path M1 (butlast io || map snd (butlast p)) (initial M1) \\<or>\n        target (butlast io || map fst (butlast p) || map snd (butlast p)) (initial M2, initial M1) \n          = FAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path M2 (butlast io || map fst (butlast p)) (initial M2) \\<and>\n    path M1 (butlast io || map snd (butlast p)) (initial M1) \\<or>\n    target (butlast io || map fst (butlast p) || map snd (butlast p))\n     (initial M2, initial M1) =\n    FAIL", "using productF_path_reverse\n          [OF \\<open>length (butlast io) = length (map fst (butlast p))\\<close> \n              \\<open>length (map fst (butlast p)) = length (map snd (butlast p))\\<close> \n              assms(4) _ _ \n              \\<open>path PM ((butlast io) || (map fst (butlast p)) || (map snd (butlast p))) \n                (initial M2, initial M1)\\<close> _ _]"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed M2; well_formed M1; initial M2 \\<in> nodes M2;\n   initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> path M2 (butlast io || map fst (butlast p))\n                     (initial M2) \\<and>\n                    path M1 (butlast io || map snd (butlast p))\n                     (initial M1) \\<or>\n                    target\n                     (butlast io ||\n                      map fst (butlast p) || map snd (butlast p))\n                     (initial M2, initial M1) =\n                    FAIL \\<and>\n                    0 < length (butlast io) \\<and>\n                    path M2 (butlast (butlast io || map fst (butlast p)))\n                     (initial M2) \\<and>\n                    path M1 (butlast (butlast io || map snd (butlast p)))\n                     (initial M1) \\<and>\n                    succ M2 (last (butlast io))\n                     (target (butlast (butlast io || map fst (butlast p)))\n                       (initial M2)) =\n                    {} \\<and>\n                    succ M1 (last (butlast io))\n                     (target (butlast (butlast io || map snd (butlast p)))\n                       (initial M1)) \\<noteq>\n                    {}\n\ngoal (1 subgoal):\n 1. path M2 (butlast io || map fst (butlast p)) (initial M2) \\<and>\n    path M1 (butlast io || map snd (butlast p)) (initial M1) \\<or>\n    target (butlast io || map fst (butlast p) || map snd (butlast p))\n     (initial M2, initial M1) =\n    FAIL", "using assms(2) assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed M2; well_formed M1; initial M2 \\<in> nodes M2;\n   initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> path M2 (butlast io || map fst (butlast p))\n                     (initial M2) \\<and>\n                    path M1 (butlast io || map snd (butlast p))\n                     (initial M1) \\<or>\n                    target\n                     (butlast io ||\n                      map fst (butlast p) || map snd (butlast p))\n                     (initial M2, initial M1) =\n                    FAIL \\<and>\n                    0 < length (butlast io) \\<and>\n                    path M2 (butlast (butlast io || map fst (butlast p)))\n                     (initial M2) \\<and>\n                    path M1 (butlast (butlast io || map snd (butlast p)))\n                     (initial M1) \\<and>\n                    succ M2 (last (butlast io))\n                     (target (butlast (butlast io || map fst (butlast p)))\n                       (initial M2)) =\n                    {} \\<and>\n                    succ M1 (last (butlast io))\n                     (target (butlast (butlast io || map snd (butlast p)))\n                       (initial M1)) \\<noteq>\n                    {}\n  OFSM M1\n  OFSM M2\n\ngoal (1 subgoal):\n 1. path M2 (butlast io || map fst (butlast p)) (initial M2) \\<and>\n    path M1 (butlast io || map snd (butlast p)) (initial M1) \\<or>\n    target (butlast io || map fst (butlast p) || map snd (butlast p))\n     (initial M2, initial M1) =\n    FAIL", "by auto"], ["proof (state)\nthis:\n  path M2 (butlast io || map fst (butlast p)) (initial M2) \\<and>\n  path M1 (butlast io || map snd (butlast p)) (initial M1) \\<or>\n  target (butlast io || map fst (butlast p) || map snd (butlast p))\n   (initial M2, initial M1) =\n  FAIL\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "then"], ["proof (chain)\npicking this:\n  path M2 (butlast io || map fst (butlast p)) (initial M2) \\<and>\n  path M1 (butlast io || map snd (butlast p)) (initial M1) \\<or>\n  target (butlast io || map fst (butlast p) || map snd (butlast p))\n   (initial M2, initial M1) =\n  FAIL", "have \"path M2 (butlast io || map fst (butlast p)) (initial M2)\"\n            \"path M1 (butlast io || map snd (butlast p)) (initial M1)\""], ["proof (prove)\nusing this:\n  path M2 (butlast io || map fst (butlast p)) (initial M2) \\<and>\n  path M1 (butlast io || map snd (butlast p)) (initial M1) \\<or>\n  target (butlast io || map fst (butlast p) || map snd (butlast p))\n   (initial M2, initial M1) =\n  FAIL\n\ngoal (1 subgoal):\n 1. path M2 (butlast io || map fst (butlast p)) (initial M2) &&&\n    path M1 (butlast io || map snd (butlast p)) (initial M1)", "using \\<open>target (butlast io || map fst (butlast p) || map snd (butlast p)) \n              (initial M2, initial M1) \\<noteq> FAIL\\<close>"], ["proof (prove)\nusing this:\n  path M2 (butlast io || map fst (butlast p)) (initial M2) \\<and>\n  path M1 (butlast io || map snd (butlast p)) (initial M1) \\<or>\n  target (butlast io || map fst (butlast p) || map snd (butlast p))\n   (initial M2, initial M1) =\n  FAIL\n  target (butlast io || map fst (butlast p) || map snd (butlast p))\n   (initial M2, initial M1) \\<noteq>\n  FAIL\n\ngoal (1 subgoal):\n 1. path M2 (butlast io || map fst (butlast p)) (initial M2) &&&\n    path M1 (butlast io || map snd (butlast p)) (initial M1)", "by auto"], ["proof (state)\nthis:\n  path M2 (butlast io || map fst (butlast p)) (initial M2)\n  path M1 (butlast io || map snd (butlast p)) (initial M1)\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "then"], ["proof (chain)\npicking this:\n  path M2 (butlast io || map fst (butlast p)) (initial M2)\n  path M1 (butlast io || map snd (butlast p)) (initial M1)", "have \"butlast io \\<in> L M2 \\<inter> L M1\""], ["proof (prove)\nusing this:\n  path M2 (butlast io || map fst (butlast p)) (initial M2)\n  path M1 (butlast io || map snd (butlast p)) (initial M1)\n\ngoal (1 subgoal):\n 1. butlast io \\<in> L M2 \\<inter> L M1", "using \\<open>length (butlast io) = length (map fst (butlast p))\\<close>"], ["proof (prove)\nusing this:\n  path M2 (butlast io || map fst (butlast p)) (initial M2)\n  path M1 (butlast io || map snd (butlast p)) (initial M1)\n  length (butlast io) = length (map fst (butlast p))\n\ngoal (1 subgoal):\n 1. butlast io \\<in> L M2 \\<inter> L M1", "by auto"], ["proof (state)\nthis:\n  butlast io \\<in> L M2 \\<inter> L M1\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"path PM (io || map fst p || map snd p) (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (io || map fst p || map snd p) (initial M2, initial M1)", "using \\<open>path PM (io || p) (initial PM)\\<close> assms(4)"], ["proof (prove)\nusing this:\n  path PM (io || p) (initial PM)\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. path PM (io || map fst p || map snd p) (initial M2, initial M1)", "by auto"], ["proof (state)\nthis:\n  path PM (io || map fst p || map snd p) (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"length io = length (map fst p)\"\n       \"length (map fst p) = length (map snd p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length io = length (map fst p) &&&\n    length (map fst p) = length (map snd p)", "by (simp add: \\<open>length p = length io\\<close>)+"], ["proof (state)\nthis:\n  length io = length (map fst p)\n  length (map fst p) = length (map snd p)\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "obtain p1' where \"path M1 (io || p1') (initial M1) \\<and> length io = length p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1'.\n        path M1 (io || p1') (initial M1) \\<and>\n        length io = length p1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using productF_path_reverse_ob\n          [OF \\<open>length io = length (map fst p)\\<close> \n              \\<open>length (map fst p) = length (map snd p)\\<close> assms(4) _ _ \n              \\<open>path PM (io || map fst p || map snd p) (initial M2, initial M1)\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed M2; well_formed M1; initial M2 \\<in> nodes M2;\n   initial M1 \\<in> nodes M1;\n   \\<And>r2'.\n      path M1 (io || r2') (initial M1) \\<and>\n      length io = length r2' \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p1'.\n        path M1 (io || p1') (initial M1) \\<and>\n        length io = length p1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed M2; well_formed M1; initial M2 \\<in> nodes M2;\n   initial M1 \\<in> nodes M1;\n   \\<And>r2'.\n      path M1 (io || r2') (initial M1) \\<and>\n      length io = length r2' \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  OFSM M1\n  OFSM M2\n\ngoal (1 subgoal):\n 1. (\\<And>p1'.\n        path M1 (io || p1') (initial M1) \\<and>\n        length io = length p1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path M1 (io || p1') (initial M1) \\<and> length io = length p1'\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "then"], ["proof (chain)\npicking this:\n  path M1 (io || p1') (initial M1) \\<and> length io = length p1'", "have \"io \\<in> L M1\""], ["proof (prove)\nusing this:\n  path M1 (io || p1') (initial M1) \\<and> length io = length p1'\n\ngoal (1 subgoal):\n 1. io \\<in> L M1", "by auto"], ["proof (state)\nthis:\n  io \\<in> L M1\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "moreover"], ["proof (state)\nthis:\n  io \\<in> L M1\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "have \"io \\<notin> L M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io \\<notin> L M2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "assume \"io \\<in> L M2\" \\<comment> \\<open> only possible if io does not target FAIL \\<close>"], ["proof (state)\nthis:\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io \\<in> L M2", "obtain p2' where \"path M2 (io || p2') (initial M2)\" \"length io = length p2'\""], ["proof (prove)\nusing this:\n  io \\<in> L M2\n\ngoal (1 subgoal):\n 1. (\\<And>p2'.\n        \\<lbrakk>path M2 (io || p2') (initial M2);\n         length io = length p2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  path M2 (io || p2') (initial M2)\n  length io = length p2'\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  path M2 (io || p2') (initial M2)\n  length io = length p2'", "have \"length p2' = length p1'\""], ["proof (prove)\nusing this:\n  path M2 (io || p2') (initial M2)\n  length io = length p2'\n\ngoal (1 subgoal):\n 1. length p2' = length p1'", "using \\<open>path M1 (io || p1') (initial M1) \\<and> length io = length p1'\\<close>"], ["proof (prove)\nusing this:\n  path M2 (io || p2') (initial M2)\n  length io = length p2'\n  path M1 (io || p1') (initial M1) \\<and> length io = length p1'\n\ngoal (1 subgoal):\n 1. length p2' = length p1'", "by auto"], ["proof (state)\nthis:\n  length p2' = length p1'\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "have \"path PM (io || p2' || p1') (initial M2, initial M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path PM (io || p2' || p1') (initial M2, initial M1)", "using productF_path_inclusion[OF \\<open>length io = length p2'\\<close> \\<open>length p2' = length p1'\\<close> assms(4), \n                                    of \"initial M2\" \"initial M1\"]\n            \\<open>path M1 (io || p1') (initial M1) \\<and> length io = length p1'\\<close> \n            \\<open>path M2 (io || p2') (initial M2)\\<close> assms(2) assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_formed M2; well_formed M1;\n   path M2 (io || p2') (initial M2) \\<and> path M1 (io || p1') (initial M1);\n   initial M2 \\<in> nodes M2; initial M1 \\<in> nodes M1\\<rbrakk>\n  \\<Longrightarrow> path PM (io || p2' || p1') (initial M2, initial M1)\n  path M1 (io || p1') (initial M1) \\<and> length io = length p1'\n  path M2 (io || p2') (initial M2)\n  OFSM M1\n  OFSM M2\n\ngoal (1 subgoal):\n 1. path PM (io || p2' || p1') (initial M2, initial M1)", "by blast"], ["proof (state)\nthis:\n  path PM (io || p2' || p1') (initial M2, initial M1)\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "have \"target (io || p2' || p1') (initial M2, initial M1) \\<in> (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || p2' || p1') (initial M2, initial M1)\n    \\<in> nodes M2 \\<times> nodes M1", "using \\<open>length io = length p2'\\<close> \\<open>path M1 (io || p1') (initial M1) \\<and> length io = length p1'\\<close> \n            \\<open>path M2 (io || p2') (initial M2)\\<close>"], ["proof (prove)\nusing this:\n  length io = length p2'\n  path M1 (io || p1') (initial M1) \\<and> length io = length p1'\n  path M2 (io || p2') (initial M2)\n\ngoal (1 subgoal):\n 1. target (io || p2' || p1') (initial M2, initial M1)\n    \\<in> nodes M2 \\<times> nodes M1", "by auto"], ["proof (state)\nthis:\n  target (io || p2' || p1') (initial M2, initial M1)\n  \\<in> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  target (io || p2' || p1') (initial M2, initial M1)\n  \\<in> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "have \"FAIL \\<notin> (nodes M2 \\<times> nodes M1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FAIL \\<notin> nodes M2 \\<times> nodes M1", "using assms(4)"], ["proof (prove)\nusing this:\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. FAIL \\<notin> nodes M2 \\<times> nodes M1", "by auto"], ["proof (state)\nthis:\n  FAIL \\<notin> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  target (io || p2' || p1') (initial M2, initial M1)\n  \\<in> nodes M2 \\<times> nodes M1\n  FAIL \\<notin> nodes M2 \\<times> nodes M1", "have \"target (io || p2' || p1') (initial M2, initial M1) \\<noteq> FAIL\""], ["proof (prove)\nusing this:\n  target (io || p2' || p1') (initial M2, initial M1)\n  \\<in> nodes M2 \\<times> nodes M1\n  FAIL \\<notin> nodes M2 \\<times> nodes M1\n\ngoal (1 subgoal):\n 1. target (io || p2' || p1') (initial M2, initial M1) \\<noteq> FAIL", "by blast"], ["proof (state)\nthis:\n  target (io || p2' || p1') (initial M2, initial M1) \\<noteq> FAIL\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "have \"length io = length (p2' || p1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length io = length (p2' || p1')", "by (simp add: \\<open>length io = length p2'\\<close> \\<open>length p2' = length p1'\\<close>)"], ["proof (state)\nthis:\n  length io = length (p2' || p1')\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "have \"target (io || p2' || p1') (initial M2, initial M1) \n            \\<in> io_targets PM (initial M2, initial M1) io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (io || p2' || p1') (initial M2, initial M1)\n    \\<in> io_targets PM (initial M2, initial M1) io", "using \\<open>path PM (io || p2' || p1') (initial M2, initial M1)\\<close> \\<open>length io = length (p2' || p1')\\<close>"], ["proof (prove)\nusing this:\n  path PM (io || p2' || p1') (initial M2, initial M1)\n  length io = length (p2' || p1')\n\ngoal (1 subgoal):\n 1. target (io || p2' || p1') (initial M2, initial M1)\n    \\<in> io_targets PM (initial M2, initial M1) io", "unfolding io_targets.simps"], ["proof (prove)\nusing this:\n  path PM (io || p2' || p1') (initial M2, initial M1)\n  length io = length (p2' || p1')\n\ngoal (1 subgoal):\n 1. target (io || p2' || p1') (initial M2, initial M1)\n    \\<in> {target (io || tr) (initial M2, initial M1) |tr.\n           path PM (io || tr) (initial M2, initial M1) \\<and>\n           length io = length tr}", "by blast"], ["proof (state)\nthis:\n  target (io || p2' || p1') (initial M2, initial M1)\n  \\<in> io_targets PM (initial M2, initial M1) io\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "have \"io_targets PM (initial PM) io \\<noteq> {FAIL}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io \\<noteq> {FAIL}", "using \\<open>target (io || p2' || p1') (initial M2, initial M1) \n              \\<in> io_targets PM (initial M2, initial M1) io\\<close> \n            \\<open>target (io || p2' || p1') (initial M2, initial M1) \\<noteq> FAIL\\<close> assms(4)"], ["proof (prove)\nusing this:\n  target (io || p2' || p1') (initial M2, initial M1)\n  \\<in> io_targets PM (initial M2, initial M1) io\n  target (io || p2' || p1') (initial M2, initial M1) \\<noteq> FAIL\n  productF M2 M1 FAIL PM\n\ngoal (1 subgoal):\n 1. io_targets PM (initial PM) io \\<noteq> {FAIL}", "by auto"], ["proof (state)\nthis:\n  io_targets PM (initial PM) io \\<noteq> {FAIL}\n\ngoal (1 subgoal):\n 1. io \\<in> L M2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  io_targets PM (initial PM) io \\<noteq> {FAIL}", "show \"False\""], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io \\<noteq> {FAIL}\n\ngoal (1 subgoal):\n 1. False", "using assms(1)"], ["proof (prove)\nusing this:\n  io_targets PM (initial PM) io \\<noteq> {FAIL}\n  io_targets PM (initial PM) io = {FAIL}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  io \\<notin> L M2\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "ultimately"], ["proof (chain)\npicking this:\n  io \\<in> L M1\n  io \\<notin> L M2", "have \"io \\<in> L M1 - L M2\""], ["proof (prove)\nusing this:\n  io \\<in> L M1\n  io \\<notin> L M2\n\ngoal (1 subgoal):\n 1. io \\<in> L M1 - L M2", "by blast"], ["proof (state)\nthis:\n  io \\<in> L M1 - L M2\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "show \"sequence_to_failure M1 M2 io\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "using \\<open>butlast io \\<in> L M2 \\<inter> L M1\\<close> \\<open>io \\<in> L M1 - L M2\\<close>"], ["proof (prove)\nusing this:\n  butlast io \\<in> L M2 \\<inter> L M1\n  io \\<in> L M1 - L M2\n\ngoal (1 subgoal):\n 1. sequence_to_failure M1 M2 io", "by auto"], ["proof (state)\nthis:\n  sequence_to_failure M1 M2 io\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}