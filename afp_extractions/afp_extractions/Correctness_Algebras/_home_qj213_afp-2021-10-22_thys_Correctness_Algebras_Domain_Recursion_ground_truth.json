{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Domain_Recursion.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma apx_transitive:\n  assumes \"x \\<sqsubseteq> y\"\n      and \"y \\<sqsubseteq> z\"\n    shows \"x \\<sqsubseteq> z\"", "lemma apx_meet_L:\n  assumes \"y \\<sqsubseteq> x\"\n    shows \"x \\<sqinter> L \\<le> y \\<sqinter> L\"", "lemma sup_apx_left_isotone:\n  assumes \"x \\<sqsubseteq> y\"\n    shows \"x \\<squnion> z \\<sqsubseteq> y \\<squnion> z\"", "lemma mult_apx_left_isotone:\n  assumes \"x \\<sqsubseteq> y\"\n    shows \"x * z \\<sqsubseteq> y * z\"", "lemma mult_apx_right_isotone:\n  assumes \"x \\<sqsubseteq> y\"\n    shows \"z * x \\<sqsubseteq> z * y\"", "lemma meet_L_apx_isotone:\n  \"x \\<sqsubseteq> y \\<Longrightarrow> x \\<sqinter> L \\<sqsubseteq> y \\<sqinter> L\"", "lemma mu_below_l:\n  \"\\<mu> f \\<le> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)\"", "lemma l_below_nu:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<le> \\<nu> f\"", "lemma n_l_nu:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> (\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)) \\<sqinter> L = \\<nu> f \\<sqinter> L\"", "lemma l_apx_mu:\n  \"\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<mu> f\"", "lemma nu_below_mu_nu_nu_below_mu_nu_2:\n  assumes \"nu_below_mu_nu f\"\n    shows \"nu_below_mu_nu_2 f\"", "lemma nu_below_mu_nu_2_nu_below_mu_nu:\n  assumes \"has_least_fixpoint f\"\n      and \"has_greatest_fixpoint f\"\n      and \"nu_below_mu_nu_2 f\"\n    shows \"nu_below_mu_nu f\"", "lemma nu_below_mu_nu_equivalent:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> (nu_below_mu_nu f \\<longleftrightarrow> nu_below_mu_nu_2 f)\"", "lemma nu_below_mu_nu_2_mu_nu_apx_nu:\n  assumes \"has_least_fixpoint f\"\n      and \"has_greatest_fixpoint f\"\n      and \"nu_below_mu_nu_2 f\"\n    shows \"mu_nu_apx_nu f\"", "lemma mu_nu_apx_nu_mu_nu_apx_meet:\n  assumes \"mu_nu_apx_nu f\"\n    shows \"mu_nu_apx_meet f\"", "lemma mu_nu_apx_meet_apx_meet_below_nu:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> mu_nu_apx_meet f \\<Longrightarrow> apx_meet_below_nu f\"", "lemma apx_meet_below_nu_nu_below_mu_nu_2:\n  assumes \"apx_meet_below_nu f\"\n    shows \"nu_below_mu_nu_2 f\"", "lemma has_apx_least_fixpoint_kappa_apx_meet:\n  assumes \"has_least_fixpoint f\"\n      and \"has_greatest_fixpoint f\"\n      and \"apx.has_least_fixpoint f\"\n    shows \"kappa_apx_meet f\"", "lemma kappa_apx_meet_apx_meet_below_nu:\n  \"has_greatest_fixpoint f \\<Longrightarrow> kappa_apx_meet f \\<Longrightarrow> apx_meet_below_nu f\"", "lemma apx_meet_below_nu_kappa_mu_nu:\n  assumes \"has_least_fixpoint f\"\n      and \"has_greatest_fixpoint f\"\n      and \"isotone f\"\n      and \"apx.isotone f\"\n      and \"apx_meet_below_nu f\"\n    shows \"kappa_mu_nu f\"", "lemma kappa_mu_nu_has_apx_least_fixpoint:\n  \"kappa_mu_nu f \\<Longrightarrow> apx.has_least_fixpoint f\"", "lemma nu_below_mu_nu_kappa_mu_nu:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> isotone f \\<Longrightarrow> apx.isotone f \\<Longrightarrow> nu_below_mu_nu f \\<Longrightarrow> kappa_mu_nu f\"", "lemma kappa_mu_nu_nu_below_mu_nu:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> kappa_mu_nu f \\<Longrightarrow> nu_below_mu_nu f\"", "lemma n_below_l:\n  \"x \\<squnion> d(y * bot) * L \\<le> x \\<squnion> (y \\<sqinter> L)\"", "lemma n_equal_l:\n  assumes \"nu_below_mu_nu_L f\"\n    shows\"\\<mu> f \\<squnion> d(\\<nu> f * bot) * L = \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)\"", "lemma nu_below_mu_nu_L_nu_below_mu_nu:\n  \"nu_below_mu_nu_L f \\<Longrightarrow> nu_below_mu_nu f\"", "lemma nu_below_mu_nu_L_kappa_mu_nu_L:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> isotone f \\<Longrightarrow> apx.isotone f \\<Longrightarrow> nu_below_mu_nu_L f \\<Longrightarrow> kappa_mu_nu_L f\"", "lemma nu_below_mu_nu_L_mu_nu_apx_nu_L:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> nu_below_mu_nu_L f \\<Longrightarrow> mu_nu_apx_nu_L f\"", "lemma nu_below_mu_nu_L_mu_nu_apx_meet_L:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> nu_below_mu_nu_L f \\<Longrightarrow> mu_nu_apx_meet_L f\"", "lemma mu_nu_apx_nu_L_nu_below_mu_nu_L:\n  assumes \"has_least_fixpoint f\"\n      and \"has_greatest_fixpoint f\"\n      and \"mu_nu_apx_nu_L f\"\n    shows \"nu_below_mu_nu_L f\"", "lemma kappa_mu_nu_L_mu_nu_apx_nu_L:\n  \"has_greatest_fixpoint f \\<Longrightarrow> kappa_mu_nu_L f \\<Longrightarrow> mu_nu_apx_nu_L f\"", "lemma mu_nu_apx_meet_L_mu_nu_apx_nu_L:\n  \"mu_nu_apx_meet_L f \\<Longrightarrow> mu_nu_apx_nu_L f\"", "lemma kappa_mu_nu_L_nu_below_mu_nu_L:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> kappa_mu_nu_L f \\<Longrightarrow> nu_below_mu_nu_L f\"", "lemma circ_apx_isotone:\n  assumes \"x \\<sqsubseteq> y\"\n    shows \"x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>\"", "lemma omega_apx_isotone:\n  assumes \"x \\<sqsubseteq> y\"\n    shows \"x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>\"", "lemma combined_apx_isotone:\n  \"x \\<sqsubseteq> y \\<Longrightarrow> (x\\<^sup>\\<omega> \\<sqinter> L) \\<squnion> x\\<^sup>\\<star> * z \\<sqsubseteq> (y\\<^sup>\\<omega> \\<sqinter> L) \\<squnion> y\\<^sup>\\<star> * z\"", "lemma d_split_nu_mu:\n  \"d(L) * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<le> y\\<^sup>\\<star> * z \\<squnion> ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter> L) \\<squnion> d((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top\"", "lemma loop_exists:\n  \"d(L) * \\<nu> (\\<lambda>x . y * x \\<squnion> z) \\<le> \\<mu> (\\<lambda>x . y * x \\<squnion> z) \\<squnion> (\\<nu> (\\<lambda>x . y * x \\<squnion> z) \\<sqinter> L) \\<squnion> d(\\<nu> (\\<lambda>x . y * x \\<squnion> z) * bot) * top\"", "lemma loop_apx_least_fixpoint:\n  \"apx.is_least_fixpoint (\\<lambda>x . y * x \\<squnion> z) (\\<mu> (\\<lambda>x . y * x \\<squnion> z) \\<squnion> (\\<nu> (\\<lambda>x . y * x \\<squnion> z) \\<sqinter> L))\"", "lemma loop_has_apx_least_fixpoint:\n  \"apx.has_least_fixpoint (\\<lambda>x . y * x \\<squnion> z)\"", "lemma loop_semantics:\n  \"\\<kappa> (\\<lambda>x . y * x \\<squnion> z) = \\<mu> (\\<lambda>x . y * x \\<squnion> z) \\<squnion> (\\<nu> (\\<lambda>x . y * x \\<squnion> z) \\<sqinter> L)\"", "lemma loop_semantics_kappa_mu_nu:\n  \"\\<kappa> (\\<lambda>x . y * x \\<squnion> z) = (y\\<^sup>\\<omega> \\<sqinter> L) \\<squnion> y\\<^sup>\\<star> * z\"", "lemma loop_semantics_kappa_mu_nu_domain:\n  \"\\<kappa> (\\<lambda>x . y * x \\<squnion> z) = d(y\\<^sup>\\<omega>) * L \\<squnion> y\\<^sup>\\<star> * z\"", "lemma loop_semantics_apx_isotone:\n  \"w \\<sqsubseteq> y \\<Longrightarrow> \\<kappa> (\\<lambda>x . w * x \\<squnion> z) \\<sqsubseteq> \\<kappa> (\\<lambda>x . y * x \\<squnion> z)\""], "translations": [["", "lemma apx_transitive:\n  assumes \"x \\<sqsubseteq> y\"\n      and \"y \\<sqsubseteq> z\"\n    shows \"x \\<sqsubseteq> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "have 1: \"x \\<le> z \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> z \\<squnion> L", "by (smt assms sup_assoc sup_commute apx_def le_iff_sup)"], ["proof (state)\nthis:\n  x \\<le> z \\<squnion> L\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "have \"d(d(L) * y * bot) * top \\<le> d((x \\<squnion> d(x * bot) * top) * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d L * y * bot) * top\n    \\<le> d ((x \\<squnion> d (x * bot) * top) * bot) * top", "by (metis assms(1) apx_def d_isotone mult_left_isotone)"], ["proof (state)\nthis:\n  d (d L * y * bot) * top\n  \\<le> d ((x \\<squnion> d (x * bot) * top) * bot) * top\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "also"], ["proof (state)\nthis:\n  d (d L * y * bot) * top\n  \\<le> d ((x \\<squnion> d (x * bot) * top) * bot) * top\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "have \"... \\<le> d(x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d ((x \\<squnion> d (x * bot) * top) * bot) * top \\<le> d (x * bot) * top", "by (metis le_sup_iff d_galois mult_left_isotone mult_right_dist_sup order_refl zero_right_mult_decreasing)"], ["proof (state)\nthis:\n  d ((x \\<squnion> d (x * bot) * top) * bot) * top \\<le> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "finally"], ["proof (chain)\npicking this:\n  d (d L * y * bot) * top \\<le> d (x * bot) * top", "have 2: \"d(d(L) * y * bot) * top \\<le> d(x * bot) * top\""], ["proof (prove)\nusing this:\n  d (d L * y * bot) * top \\<le> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. d (d L * y * bot) * top \\<le> d (x * bot) * top", "."], ["proof (state)\nthis:\n  d (d L * y * bot) * top \\<le> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "have \"d(L) * z = d(L) * (d(L) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * z = d L * (d L * z)", "by (simp add: d_idempotent ils.il_inf_associative)"], ["proof (state)\nthis:\n  d L * z = d L * (d L * z)\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "also"], ["proof (state)\nthis:\n  d L * z = d L * (d L * z)\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "have \"... \\<le> d(L) * y \\<squnion> d(d(L) * y * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * (d L * z) \\<le> d L * y \\<squnion> d (d L * y * bot) * top", "by (metis assms(2) apx_def d_export mult_assoc mult_left_dist_sup mult_right_isotone)"], ["proof (state)\nthis:\n  d L * (d L * z) \\<le> d L * y \\<squnion> d (d L * y * bot) * top\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "also"], ["proof (state)\nthis:\n  d L * (d L * z) \\<le> d L * y \\<squnion> d (d L * y * bot) * top\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "have \"... \\<le> x \\<squnion> d(x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * y \\<squnion> d (d L * y * bot) * top\n    \\<le> x \\<squnion> d (x * bot) * top", "using 2"], ["proof (prove)\nusing this:\n  d (d L * y * bot) * top \\<le> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. d L * y \\<squnion> d (d L * y * bot) * top\n    \\<le> x \\<squnion> d (x * bot) * top", "by (meson assms(1) apx_def le_supI2 sup_least)"], ["proof (state)\nthis:\n  d L * y \\<squnion> d (d L * y * bot) * top\n  \\<le> x \\<squnion> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "finally"], ["proof (chain)\npicking this:\n  d L * z \\<le> x \\<squnion> d (x * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d L * z \\<le> x \\<squnion> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "using 1"], ["proof (prove)\nusing this:\n  d L * z \\<le> x \\<squnion> d (x * bot) * top\n  x \\<le> z \\<squnion> L\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "by (simp add: apx_def)"], ["proof (state)\nthis:\n  x \\<sqsubseteq> z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apx_meet_L:\n  assumes \"y \\<sqsubseteq> x\"\n    shows \"x \\<sqinter> L \\<le> y \\<sqinter> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> L \\<le> y \\<sqinter> L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<sqinter> L \\<le> y \\<sqinter> L", "have \"x \\<sqinter> L = d(L) * x \\<sqinter> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> L = d L * x \\<sqinter> L", "using meet_intro_domain"], ["proof (prove)\nusing this:\n  ?x \\<sqinter> ?y = d ?y * ?x \\<sqinter> ?y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> L = d L * x \\<sqinter> L", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter> L = d L * x \\<sqinter> L\n\ngoal (1 subgoal):\n 1. x \\<sqinter> L \\<le> y \\<sqinter> L", "also"], ["proof (state)\nthis:\n  x \\<sqinter> L = d L * x \\<sqinter> L\n\ngoal (1 subgoal):\n 1. x \\<sqinter> L \\<le> y \\<sqinter> L", "have \"... \\<le> (y \\<squnion> d(y * bot) * top) \\<sqinter> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * x \\<sqinter> L \\<le> (y \\<squnion> d (y * bot) * top) \\<sqinter> L", "using assms apx_def inf.sup_left_isotone"], ["proof (prove)\nusing this:\n  y \\<sqsubseteq> x\n  (?x \\<sqsubseteq> ?y) =\n  (?x \\<le> ?y \\<squnion> L \\<and>\n   d L * ?y \\<le> ?x \\<squnion> d (?x * bot) * top)\n  ?y \\<le> ?x \\<Longrightarrow> ?y \\<sqinter> ?z \\<le> ?x \\<sqinter> ?z\n\ngoal (1 subgoal):\n 1. d L * x \\<sqinter> L \\<le> (y \\<squnion> d (y * bot) * top) \\<sqinter> L", "by blast"], ["proof (state)\nthis:\n  d L * x \\<sqinter> L \\<le> (y \\<squnion> d (y * bot) * top) \\<sqinter> L\n\ngoal (1 subgoal):\n 1. x \\<sqinter> L \\<le> y \\<sqinter> L", "also"], ["proof (state)\nthis:\n  d L * x \\<sqinter> L \\<le> (y \\<squnion> d (y * bot) * top) \\<sqinter> L\n\ngoal (1 subgoal):\n 1. x \\<sqinter> L \\<le> y \\<sqinter> L", "have \"... \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<squnion> d (y * bot) * top) \\<sqinter> L \\<le> y", "by (simp add: inf.sup_monoid.add_commute inf_sup_distrib1 l13 meet_domain_top)"], ["proof (state)\nthis:\n  (y \\<squnion> d (y * bot) * top) \\<sqinter> L \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> L \\<le> y \\<sqinter> L", "finally"], ["proof (chain)\npicking this:\n  x \\<sqinter> L \\<le> y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<sqinter> L \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> L \\<le> y \\<sqinter> L", "by simp"], ["proof (state)\nthis:\n  x \\<sqinter> L \\<le> y \\<sqinter> L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sup_apx_left_isotone:\n  assumes \"x \\<sqsubseteq> y\"\n    shows \"x \\<squnion> z \\<sqsubseteq> y \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "have 1: \"x \\<squnion> z \\<le> y \\<squnion> z \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<le> y \\<squnion> z \\<squnion> L", "by (smt assms sup_assoc sup_commute sup_left_isotone apx_def)"], ["proof (state)\nthis:\n  x \\<squnion> z \\<le> y \\<squnion> z \\<squnion> L\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "have \"d(L) * (y \\<squnion> z) = d(L) * y \\<squnion> d(L) * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * (y \\<squnion> z) = d L * y \\<squnion> d L * z", "by (simp add: mult_left_dist_sup)"], ["proof (state)\nthis:\n  d L * (y \\<squnion> z) = d L * y \\<squnion> d L * z\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "also"], ["proof (state)\nthis:\n  d L * (y \\<squnion> z) = d L * y \\<squnion> d L * z\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "have \"... \\<le> d(L) * y \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * y \\<squnion> d L * z \\<le> d L * y \\<squnion> z", "by (simp add: d_mult_below le_supI1 sup_commute)"], ["proof (state)\nthis:\n  d L * y \\<squnion> d L * z \\<le> d L * y \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "also"], ["proof (state)\nthis:\n  d L * y \\<squnion> d L * z \\<le> d L * y \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "have \"... \\<le> x \\<squnion> d(x * bot) * top \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * y \\<squnion> z \\<le> x \\<squnion> d (x * bot) * top \\<squnion> z", "using assms apx_def sup_left_isotone"], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> y\n  (?x \\<sqsubseteq> ?y) =\n  (?x \\<le> ?y \\<squnion> L \\<and>\n   d L * ?y \\<le> ?x \\<squnion> d (?x * bot) * top)\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> ?z \\<le> ?y \\<squnion> ?z\n\ngoal (1 subgoal):\n 1. d L * y \\<squnion> z \\<le> x \\<squnion> d (x * bot) * top \\<squnion> z", "by blast"], ["proof (state)\nthis:\n  d L * y \\<squnion> z \\<le> x \\<squnion> d (x * bot) * top \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "also"], ["proof (state)\nthis:\n  d L * y \\<squnion> z \\<le> x \\<squnion> d (x * bot) * top \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "have \"... \\<le> x \\<squnion> z \\<squnion> d((x \\<squnion> z) * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> d (x * bot) * top \\<squnion> z\n    \\<le> x \\<squnion> z \\<squnion> d ((x \\<squnion> z) * bot) * top", "by (simp add: d_dist_sup le_iff_sup semiring.distrib_right sup.left_commute sup_monoid.add_assoc)"], ["proof (state)\nthis:\n  x \\<squnion> d (x * bot) * top \\<squnion> z\n  \\<le> x \\<squnion> z \\<squnion> d ((x \\<squnion> z) * bot) * top\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "finally"], ["proof (chain)\npicking this:\n  d L * (y \\<squnion> z)\n  \\<le> x \\<squnion> z \\<squnion> d ((x \\<squnion> z) * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d L * (y \\<squnion> z)\n  \\<le> x \\<squnion> z \\<squnion> d ((x \\<squnion> z) * bot) * top\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "using 1"], ["proof (prove)\nusing this:\n  d L * (y \\<squnion> z)\n  \\<le> x \\<squnion> z \\<squnion> d ((x \\<squnion> z) * bot) * top\n  x \\<squnion> z \\<le> y \\<squnion> z \\<squnion> L\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<sqsubseteq> y \\<squnion> z", "by (simp add: apx_def)"], ["proof (state)\nthis:\n  x \\<squnion> z \\<sqsubseteq> y \\<squnion> z\n\ngoal:\nNo subgoals!", "qed"], ["", "subclass apx_biorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.apx_biorder (\\<sqsubseteq>) (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y.\n       x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> x \\<longrightarrow> x = y\n 3. \\<And>x y z.\n       x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> z \\<longrightarrow>\n       x \\<sqsubseteq> z", "apply (metis le_sup_iff sup_ge1 apx_def d_plus_one mult_left_one mult_right_dist_sup)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> x \\<longrightarrow> x = y\n 2. \\<And>x y z.\n       x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> z \\<longrightarrow>\n       x \\<sqsubseteq> z", "apply (meson apx_meet_L order.antisym apx_def relative_equality sup_same_context)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> z \\<longrightarrow>\n       x \\<sqsubseteq> z", "using apx_transitive"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<sqsubseteq> ?y; ?y \\<sqsubseteq> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sqsubseteq> ?z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> z \\<longrightarrow>\n       x \\<sqsubseteq> z", "by blast"], ["", "lemma mult_apx_left_isotone:\n  assumes \"x \\<sqsubseteq> y\"\n    shows \"x * z \\<sqsubseteq> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<sqsubseteq> y * z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * z \\<sqsubseteq> y * z", "have \"x * z \\<le> y * z \\<squnion> L * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<le> y * z \\<squnion> L * z", "by (metis assms apx_def mult_left_isotone mult_right_dist_sup)"], ["proof (state)\nthis:\n  x * z \\<le> y * z \\<squnion> L * z\n\ngoal (1 subgoal):\n 1. x * z \\<sqsubseteq> y * z", "hence 1: \"x * z \\<le> y * z \\<squnion> L\""], ["proof (prove)\nusing this:\n  x * z \\<le> y * z \\<squnion> L * z\n\ngoal (1 subgoal):\n 1. x * z \\<le> y * z \\<squnion> L", "using l40 order_lesseq_imp semiring.add_left_mono"], ["proof (prove)\nusing this:\n  x * z \\<le> y * z \\<squnion> L * z\n  L * ?x \\<le> L\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  ?a \\<le> ?b \\<Longrightarrow> ?c \\<squnion> ?a \\<le> ?c \\<squnion> ?b\n\ngoal (1 subgoal):\n 1. x * z \\<le> y * z \\<squnion> L", "by blast"], ["proof (state)\nthis:\n  x * z \\<le> y * z \\<squnion> L\n\ngoal (1 subgoal):\n 1. x * z \\<sqsubseteq> y * z", "have \"d(L) * y * z \\<le> x * z \\<squnion> d(x * bot) * top * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * y * z \\<le> x * z \\<squnion> d (x * bot) * top * z", "by (metis assms apx_def mult_left_isotone mult_right_dist_sup)"], ["proof (state)\nthis:\n  d L * y * z \\<le> x * z \\<squnion> d (x * bot) * top * z\n\ngoal (1 subgoal):\n 1. x * z \\<sqsubseteq> y * z", "also"], ["proof (state)\nthis:\n  d L * y * z \\<le> x * z \\<squnion> d (x * bot) * top * z\n\ngoal (1 subgoal):\n 1. x * z \\<sqsubseteq> y * z", "have \"... \\<le> x * z \\<squnion> d(x * z * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<squnion> d (x * bot) * top * z\n    \\<le> x * z \\<squnion> d (x * z * bot) * top", "by (metis sup_right_isotone d_isotone mult_assoc mult_isotone mult_right_isotone top_greatest bot_least)"], ["proof (state)\nthis:\n  x * z \\<squnion> d (x * bot) * top * z\n  \\<le> x * z \\<squnion> d (x * z * bot) * top\n\ngoal (1 subgoal):\n 1. x * z \\<sqsubseteq> y * z", "finally"], ["proof (chain)\npicking this:\n  d L * y * z \\<le> x * z \\<squnion> d (x * z * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d L * y * z \\<le> x * z \\<squnion> d (x * z * bot) * top\n\ngoal (1 subgoal):\n 1. x * z \\<sqsubseteq> y * z", "using 1"], ["proof (prove)\nusing this:\n  d L * y * z \\<le> x * z \\<squnion> d (x * z * bot) * top\n  x * z \\<le> y * z \\<squnion> L\n\ngoal (1 subgoal):\n 1. x * z \\<sqsubseteq> y * z", "by (simp add: apx_def mult_assoc)"], ["proof (state)\nthis:\n  x * z \\<sqsubseteq> y * z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_apx_right_isotone:\n  assumes \"x \\<sqsubseteq> y\"\n    shows \"z * x \\<sqsubseteq> z * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "have \"z * x \\<le> z * y \\<squnion> z * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x \\<le> z * y \\<squnion> z * L", "by (metis assms apx_def mult_left_dist_sup mult_right_isotone)"], ["proof (state)\nthis:\n  z * x \\<le> z * y \\<squnion> z * L\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "also"], ["proof (state)\nthis:\n  z * x \\<le> z * y \\<squnion> z * L\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "have \"... \\<le> z * y \\<squnion> z * bot \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * y \\<squnion> z * L \\<le> z * y \\<squnion> z * bot \\<squnion> L", "using l14 semiring.add_left_mono sup_monoid.add_assoc"], ["proof (prove)\nusing this:\n  ?x * L \\<le> ?x * bot \\<squnion> L\n  ?a \\<le> ?b \\<Longrightarrow> ?c \\<squnion> ?a \\<le> ?c \\<squnion> ?b\n  ?a \\<squnion> ?b \\<squnion> ?c = ?a \\<squnion> (?b \\<squnion> ?c)\n\ngoal (1 subgoal):\n 1. z * y \\<squnion> z * L \\<le> z * y \\<squnion> z * bot \\<squnion> L", "by auto"], ["proof (state)\nthis:\n  z * y \\<squnion> z * L \\<le> z * y \\<squnion> z * bot \\<squnion> L\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "finally"], ["proof (chain)\npicking this:\n  z * x \\<le> z * y \\<squnion> z * bot \\<squnion> L", "have 1: \"z * x \\<le> z * y \\<squnion> L\""], ["proof (prove)\nusing this:\n  z * x \\<le> z * y \\<squnion> z * bot \\<squnion> L\n\ngoal (1 subgoal):\n 1. z * x \\<le> z * y \\<squnion> L", "using mult_right_isotone sup.order_iff"], ["proof (prove)\nusing this:\n  z * x \\<le> z * y \\<squnion> z * bot \\<squnion> L\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  (?b \\<le> ?a) = (?a = ?a \\<squnion> ?b)\n\ngoal (1 subgoal):\n 1. z * x \\<le> z * y \\<squnion> L", "by auto"], ["proof (state)\nthis:\n  z * x \\<le> z * y \\<squnion> L\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "have \"d(L) * z * y \\<le> z * d(L) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * z * y \\<le> z * d L * y", "by (simp add: l2 mult_left_isotone)"], ["proof (state)\nthis:\n  d L * z * y \\<le> z * d L * y\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "also"], ["proof (state)\nthis:\n  d L * z * y \\<le> z * d L * y\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "have \"... \\<le> z * (x \\<squnion> d(x * bot) * top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * d L * y \\<le> z * (x \\<squnion> d (x * bot) * top)", "by (metis assms apx_def mult_assoc mult_right_isotone)"], ["proof (state)\nthis:\n  z * d L * y \\<le> z * (x \\<squnion> d (x * bot) * top)\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "also"], ["proof (state)\nthis:\n  z * d L * y \\<le> z * (x \\<squnion> d (x * bot) * top)\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "have \"... = z * x \\<squnion> z * d(x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * (x \\<squnion> d (x * bot) * top) =\n    z * x \\<squnion> z * d (x * bot) * top", "by (simp add: mult_left_dist_sup mult_assoc)"], ["proof (state)\nthis:\n  z * (x \\<squnion> d (x * bot) * top) =\n  z * x \\<squnion> z * d (x * bot) * top\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "also"], ["proof (state)\nthis:\n  z * (x \\<squnion> d (x * bot) * top) =\n  z * x \\<squnion> z * d (x * bot) * top\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "have \"... \\<le> z * x \\<squnion> d(z * x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x \\<squnion> z * d (x * bot) * top\n    \\<le> z * x \\<squnion> d (z * x * bot) * top", "by (metis sup_right_isotone mult_assoc mult_domain_top)"], ["proof (state)\nthis:\n  z * x \\<squnion> z * d (x * bot) * top\n  \\<le> z * x \\<squnion> d (z * x * bot) * top\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "finally"], ["proof (chain)\npicking this:\n  d L * z * y \\<le> z * x \\<squnion> d (z * x * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d L * z * y \\<le> z * x \\<squnion> d (z * x * bot) * top\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "using 1"], ["proof (prove)\nusing this:\n  d L * z * y \\<le> z * x \\<squnion> d (z * x * bot) * top\n  z * x \\<le> z * y \\<squnion> L\n\ngoal (1 subgoal):\n 1. z * x \\<sqsubseteq> z * y", "by (simp add: apx_def mult_assoc)"], ["proof (state)\nthis:\n  z * x \\<sqsubseteq> z * y\n\ngoal:\nNo subgoals!", "qed"], ["", "subclass apx_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.apx_semiring (\\<sqsubseteq>) (\\<le>) (<) L (1::'a) (*)\n     (\\<squnion>) bot", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. L \\<sqsubseteq> x\n 2. \\<And>x y z.\n       x \\<sqsubseteq> y \\<longrightarrow>\n       x \\<squnion> z \\<sqsubseteq> y \\<squnion> z\n 3. \\<And>x y z.\n       x \\<sqsubseteq> y \\<longrightarrow> x * z \\<sqsubseteq> y * z\n 4. \\<And>x y z.\n       x \\<sqsubseteq> y \\<longrightarrow> z * x \\<sqsubseteq> z * y", "apply (metis sup_ge2 apx_def l3 mult_right_isotone order_trans top_greatest)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<sqsubseteq> y \\<longrightarrow>\n       x \\<squnion> z \\<sqsubseteq> y \\<squnion> z\n 2. \\<And>x y z.\n       x \\<sqsubseteq> y \\<longrightarrow> x * z \\<sqsubseteq> y * z\n 3. \\<And>x y z.\n       x \\<sqsubseteq> y \\<longrightarrow> z * x \\<sqsubseteq> z * y", "apply (simp add: sup_apx_left_isotone)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       x \\<sqsubseteq> y \\<longrightarrow> x * z \\<sqsubseteq> y * z\n 2. \\<And>x y z.\n       x \\<sqsubseteq> y \\<longrightarrow> z * x \\<sqsubseteq> z * y", "apply (simp add: mult_apx_left_isotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<sqsubseteq> y \\<longrightarrow> z * x \\<sqsubseteq> z * y", "by (simp add: mult_apx_right_isotone)"], ["", "lemma meet_L_apx_isotone:\n  \"x \\<sqsubseteq> y \\<Longrightarrow> x \\<sqinter> L \\<sqsubseteq> y \\<sqinter> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y \\<Longrightarrow>\n    x \\<sqinter> L \\<sqsubseteq> y \\<sqinter> L", "by (smt (z3) inf.cobounded2 sup.coboundedI1 sup_absorb sup_commute apx_def apx_meet_L d_restrict_equals l20 inf_commute meet_domain)"], ["", "definition kappa_apx_meet :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"kappa_apx_meet f \\<equiv> apx.has_least_fixpoint f \\<and> has_apx_meet (\\<mu> f) (\\<nu> f) \\<and> \\<kappa> f = \\<mu> f \\<triangle> \\<nu> f\""], ["", "definition kappa_mu_nu :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"kappa_mu_nu f \\<equiv> apx.has_least_fixpoint f \\<and> \\<kappa> f = \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)\""], ["", "definition nu_below_mu_nu :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"nu_below_mu_nu f \\<equiv> d(L) * \\<nu> f \\<le> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<squnion> d(\\<nu> f * bot) * top\""], ["", "definition nu_below_mu_nu_2 :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"nu_below_mu_nu_2 f \\<equiv> d(L) * \\<nu> f \\<le> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<squnion> d((\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)) * bot) * top\""], ["", "definition mu_nu_apx_nu :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"mu_nu_apx_nu f \\<equiv> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<nu> f\""], ["", "definition mu_nu_apx_meet :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"mu_nu_apx_meet f \\<equiv> has_apx_meet (\\<mu> f) (\\<nu> f) \\<and> \\<mu> f \\<triangle> \\<nu> f = \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)\""], ["", "definition apx_meet_below_nu :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"apx_meet_below_nu f \\<equiv> has_apx_meet (\\<mu> f) (\\<nu> f) \\<and> \\<mu> f \\<triangle> \\<nu> f \\<le> \\<nu> f\""], ["", "lemma mu_below_l:\n  \"\\<mu> f \\<le> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "by simp"], ["", "lemma l_below_nu:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<le> \\<nu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f\\<rbrakk>\n    \\<Longrightarrow> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> \\<nu> f", "by (simp add: mu_below_nu)"], ["", "lemma n_l_nu:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> (\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)) \\<sqinter> L = \\<nu> f \\<sqinter> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f\\<rbrakk>\n    \\<Longrightarrow> (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqinter>\n                      L =\n                      \\<nu> f \\<sqinter> L", "by (meson l_below_nu inf.sup_same_context inf_le1 order_trans sup.cobounded2)"], ["", "lemma l_apx_mu:\n  \"\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<mu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<mu> f", "by (simp add: apx_def d_mult_below le_supI1 sup_inf_distrib1)"], ["", "lemma nu_below_mu_nu_nu_below_mu_nu_2:\n  assumes \"nu_below_mu_nu f\"\n    shows \"nu_below_mu_nu_2 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "have \"d(L) * \\<nu> f = d(L) * (d(L) * \\<nu> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * \\<nu> f = d L * (d L * \\<nu> f)", "by (simp add: d_idempotent ils.il_inf_associative)"], ["proof (state)\nthis:\n  d L * \\<nu> f = d L * (d L * \\<nu> f)\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "also"], ["proof (state)\nthis:\n  d L * \\<nu> f = d L * (d L * \\<nu> f)\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "have \"... \\<le> d(L) * (\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<squnion> d(\\<nu> f * bot) * top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * (d L * \\<nu> f)\n    \\<le> d L *\n          (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n           d (\\<nu> f * bot) * top)", "using assms mult_isotone nu_below_mu_nu_def"], ["proof (prove)\nusing this:\n  nu_below_mu_nu f\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w * ?x \\<le> ?y * ?z\n  nu_below_mu_nu ?f \\<equiv>\n  d L * \\<nu> ?f\n  \\<le> \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<squnion>\n        d (\\<nu> ?f * bot) * top\n\ngoal (1 subgoal):\n 1. d L * (d L * \\<nu> f)\n    \\<le> d L *\n          (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n           d (\\<nu> f * bot) * top)", "by blast"], ["proof (state)\nthis:\n  d L * (d L * \\<nu> f)\n  \\<le> d L *\n        (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n         d (\\<nu> f * bot) * top)\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "also"], ["proof (state)\nthis:\n  d L * (d L * \\<nu> f)\n  \\<le> d L *\n        (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n         d (\\<nu> f * bot) * top)\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "have \"... = d(L) * (\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)) \\<squnion> d(L) * d(\\<nu> f * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L *\n    (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n     d (\\<nu> f * bot) * top) =\n    d L * (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion>\n    d L * d (\\<nu> f * bot) * top", "by (simp add: ils.il_inf_associative mult_left_dist_sup)"], ["proof (state)\nthis:\n  d L *\n  (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n   d (\\<nu> f * bot) * top) =\n  d L * (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion>\n  d L * d (\\<nu> f * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "also"], ["proof (state)\nthis:\n  d L *\n  (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n   d (\\<nu> f * bot) * top) =\n  d L * (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion>\n  d L * d (\\<nu> f * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "have \"... \\<le> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<squnion> d(L) * d(\\<nu> f * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion>\n    d L * d (\\<nu> f * bot) * top\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d L * d (\\<nu> f * bot) * top", "using d_mult_below sup_left_isotone"], ["proof (prove)\nusing this:\n  d ?x * ?y \\<le> ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> ?z \\<le> ?y \\<squnion> ?z\n\ngoal (1 subgoal):\n 1. d L * (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion>\n    d L * d (\\<nu> f * bot) * top\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d L * d (\\<nu> f * bot) * top", "by auto"], ["proof (state)\nthis:\n  d L * (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion>\n  d L * d (\\<nu> f * bot) * top\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d L * d (\\<nu> f * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "also"], ["proof (state)\nthis:\n  d L * (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion>\n  d L * d (\\<nu> f * bot) * top\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d L * d (\\<nu> f * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "have \"... = \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<squnion> d(d(\\<nu> f * bot) * L) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n    d L * d (\\<nu> f * bot) * top =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n    d (d (\\<nu> f * bot) * L) * top", "by (simp add: d_commutative d_export)"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n  d L * d (\\<nu> f * bot) * top =\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n  d (d (\\<nu> f * bot) * L) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "also"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n  d L * d (\\<nu> f * bot) * top =\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n  d (d (\\<nu> f * bot) * L) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "have \"... = \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<squnion> d((\\<nu> f \\<sqinter> L) * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n    d (d (\\<nu> f * bot) * L) * top =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n    d ((\\<nu> f \\<sqinter> L) * bot) * top", "using l51"], ["proof (prove)\nusing this:\n  d (?x * bot) * L = (?x \\<sqinter> L) * bot\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n    d (d (\\<nu> f * bot) * L) * top =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n    d ((\\<nu> f \\<sqinter> L) * bot) * top", "by auto"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n  d (d (\\<nu> f * bot) * L) * top =\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n  d ((\\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "also"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n  d (d (\\<nu> f * bot) * L) * top =\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n  d ((\\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "have \"... \\<le> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<squnion> d((\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)) * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n    d ((\\<nu> f \\<sqinter> L) * bot) * top\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "by (meson d_isotone inf.eq_refl mult_isotone semiring.add_left_mono sup.cobounded2)"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n  d ((\\<nu> f \\<sqinter> L) * bot) * top\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "finally"], ["proof (chain)\npicking this:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "using nu_below_mu_nu_2_def"], ["proof (prove)\nusing this:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n  nu_below_mu_nu_2 ?f \\<equiv>\n  d L * \\<nu> ?f\n  \\<le> \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<squnion>\n        d ((\\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "by auto"], ["proof (state)\nthis:\n  nu_below_mu_nu_2 f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nu_below_mu_nu_2_nu_below_mu_nu:\n  assumes \"has_least_fixpoint f\"\n      and \"has_greatest_fixpoint f\"\n      and \"nu_below_mu_nu_2 f\"\n    shows \"nu_below_mu_nu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nu_below_mu_nu f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nu_below_mu_nu f", "have \"d(L) * \\<nu> f \\<le> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<squnion> d((\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)) * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "using assms(3) nu_below_mu_nu_2_def"], ["proof (prove)\nusing this:\n  nu_below_mu_nu_2 f\n  nu_below_mu_nu_2 ?f \\<equiv>\n  d L * \\<nu> ?f\n  \\<le> \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<squnion>\n        d ((\\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "by blast"], ["proof (state)\nthis:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu f", "also"], ["proof (state)\nthis:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu f", "have \"... \\<le> \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<squnion> d(\\<nu> f * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n    d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d (\\<nu> f * bot) * top", "by (metis assms(1,2) d_isotone inf.sup_monoid.add_commute inf.sup_right_divisibility le_supI le_supI2 mu_below_nu mult_left_isotone sup_left_divisibility)"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n  d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d (\\<nu> f * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu f", "finally"], ["proof (chain)\npicking this:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d (\\<nu> f * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d (\\<nu> f * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu f", "by (simp add: nu_below_mu_nu_def)"], ["proof (state)\nthis:\n  nu_below_mu_nu f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nu_below_mu_nu_equivalent:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> (nu_below_mu_nu f \\<longleftrightarrow> nu_below_mu_nu_2 f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f\\<rbrakk>\n    \\<Longrightarrow> nu_below_mu_nu f = nu_below_mu_nu_2 f", "using nu_below_mu_nu_2_nu_below_mu_nu nu_below_mu_nu_nu_below_mu_nu_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f;\n   nu_below_mu_nu_2 ?f\\<rbrakk>\n  \\<Longrightarrow> nu_below_mu_nu ?f\n  nu_below_mu_nu ?f \\<Longrightarrow> nu_below_mu_nu_2 ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f\\<rbrakk>\n    \\<Longrightarrow> nu_below_mu_nu f = nu_below_mu_nu_2 f", "by blast"], ["", "lemma nu_below_mu_nu_2_mu_nu_apx_nu:\n  assumes \"has_least_fixpoint f\"\n      and \"has_greatest_fixpoint f\"\n      and \"nu_below_mu_nu_2 f\"\n    shows \"mu_nu_apx_nu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu_nu_apx_nu f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mu_nu_apx_nu f", "have \"\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<le> \\<nu> f \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> \\<nu> f \\<squnion> L", "using assms(1,2) l_below_nu le_supI1"], ["proof (prove)\nusing this:\n  has_least_fixpoint f\n  has_greatest_fixpoint f\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f\\<rbrakk>\n  \\<Longrightarrow> \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<le> \\<nu> ?f\n  ?x \\<le> ?a \\<Longrightarrow> ?x \\<le> ?a \\<squnion> ?b\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> \\<nu> f \\<squnion> L", "by blast"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> \\<nu> f \\<squnion> L\n\ngoal (1 subgoal):\n 1. mu_nu_apx_nu f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> \\<nu> f \\<squnion> L\n\ngoal (1 subgoal):\n 1. mu_nu_apx_nu f", "using assms(3) apx_def mu_nu_apx_nu_def nu_below_mu_nu_2_def"], ["proof (prove)\nusing this:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> \\<nu> f \\<squnion> L\n  nu_below_mu_nu_2 f\n  (?x \\<sqsubseteq> ?y) =\n  (?x \\<le> ?y \\<squnion> L \\<and>\n   d L * ?y \\<le> ?x \\<squnion> d (?x * bot) * top)\n  mu_nu_apx_nu ?f \\<equiv>\n  \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<sqsubseteq> \\<nu> ?f\n  nu_below_mu_nu_2 ?f \\<equiv>\n  d L * \\<nu> ?f\n  \\<le> \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<squnion>\n        d ((\\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. mu_nu_apx_nu f", "by blast"], ["proof (state)\nthis:\n  mu_nu_apx_nu f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mu_nu_apx_nu_mu_nu_apx_meet:\n  assumes \"mu_nu_apx_nu f\"\n    shows \"mu_nu_apx_meet f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu_nu_apx_meet f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mu_nu_apx_meet f", "let ?l = \"\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)\""], ["proof (state)\ngoal (1 subgoal):\n 1. mu_nu_apx_meet f", "have \"is_apx_meet (\\<mu> f) (\\<nu> f) ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_apx_meet (\\<mu> f) (\\<nu> f)\n     (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)", "apply (unfold is_apx_meet_def, intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<mu> f\n 2. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<nu> f\n 3. \\<forall>w.\n       w \\<sqsubseteq> \\<mu> f \\<and>\n       w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n       w \\<sqsubseteq> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "apply (simp add: l_apx_mu)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<nu> f\n 2. \\<forall>w.\n       w \\<sqsubseteq> \\<mu> f \\<and>\n       w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n       w \\<sqsubseteq> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "using assms mu_nu_apx_nu_def"], ["proof (prove)\nusing this:\n  mu_nu_apx_nu f\n  mu_nu_apx_nu ?f \\<equiv>\n  \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<sqsubseteq> \\<nu> ?f\n\ngoal (2 subgoals):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<nu> f\n 2. \\<forall>w.\n       w \\<sqsubseteq> \\<mu> f \\<and>\n       w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n       w \\<sqsubseteq> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w.\n       w \\<sqsubseteq> \\<mu> f \\<and>\n       w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n       w \\<sqsubseteq> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "by (metis apx_meet_L le_supI2 sup.order_iff sup_apx_left_isotone sup_inf_absorb)"], ["proof (state)\nthis:\n  is_apx_meet (\\<mu> f) (\\<nu> f) (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n\ngoal (1 subgoal):\n 1. mu_nu_apx_meet f", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_apx_meet (\\<mu> f) (\\<nu> f) (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n\ngoal (1 subgoal):\n 1. mu_nu_apx_meet f", "by (smt apx_meet_char mu_nu_apx_meet_def)"], ["proof (state)\nthis:\n  mu_nu_apx_meet f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mu_nu_apx_meet_apx_meet_below_nu:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> mu_nu_apx_meet f \\<Longrightarrow> apx_meet_below_nu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f;\n     mu_nu_apx_meet f\\<rbrakk>\n    \\<Longrightarrow> apx_meet_below_nu f", "using apx_meet_below_nu_def l_below_nu mu_nu_apx_meet_def"], ["proof (prove)\nusing this:\n  apx_meet_below_nu ?f \\<equiv>\n  has_apx_meet (\\<mu> ?f) (\\<nu> ?f) \\<and>\n  \\<mu> ?f \\<triangle> \\<nu> ?f \\<le> \\<nu> ?f\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f\\<rbrakk>\n  \\<Longrightarrow> \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<le> \\<nu> ?f\n  mu_nu_apx_meet ?f \\<equiv>\n  has_apx_meet (\\<mu> ?f) (\\<nu> ?f) \\<and>\n  \\<mu> ?f \\<triangle> \\<nu> ?f = \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f;\n     mu_nu_apx_meet f\\<rbrakk>\n    \\<Longrightarrow> apx_meet_below_nu f", "by auto"], ["", "lemma apx_meet_below_nu_nu_below_mu_nu_2:\n  assumes \"apx_meet_below_nu f\"\n    shows \"nu_below_mu_nu_2 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "let ?l = \"\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)\""], ["proof (state)\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "have \"\\<forall>m . m \\<sqsubseteq> \\<mu> f \\<and> m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<longrightarrow> d(L) * \\<nu> f \\<le> ?l \\<squnion> d(?l * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m.\n       m \\<sqsubseteq> \\<mu> f \\<and>\n       m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<longrightarrow>\n       d L * \\<nu> f\n       \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n             d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<sqsubseteq> \\<mu> f \\<and>\n       m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<longrightarrow>\n       d L * \\<nu> f\n       \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n             d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<sqsubseteq> \\<mu> f \\<and>\n       m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<longrightarrow>\n       d L * \\<nu> f\n       \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n             d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "show \"m \\<sqsubseteq> \\<mu> f \\<and> m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<longrightarrow> d(L) * \\<nu> f \\<le> ?l \\<squnion> d(?l * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<sqsubseteq> \\<mu> f \\<and>\n    m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<longrightarrow>\n    d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<sqsubseteq> \\<mu> f \\<and>\n    m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<Longrightarrow>\n    d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "assume 1: \"m \\<sqsubseteq> \\<mu> f \\<and> m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f\""], ["proof (state)\nthis:\n  m \\<sqsubseteq> \\<mu> f \\<and>\n  m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f\n\ngoal (1 subgoal):\n 1. m \\<sqsubseteq> \\<mu> f \\<and>\n    m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<Longrightarrow>\n    d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "hence \"m \\<le> ?l\""], ["proof (prove)\nusing this:\n  m \\<sqsubseteq> \\<mu> f \\<and>\n  m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f\n\ngoal (1 subgoal):\n 1. m \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "by (metis apx_def ils.il_associative sup.orderE sup.orderI sup_inf_distrib1 sup_inf_distrib2)"], ["proof (state)\nthis:\n  m \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n\ngoal (1 subgoal):\n 1. m \\<sqsubseteq> \\<mu> f \\<and>\n    m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<Longrightarrow>\n    d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "hence \"m \\<squnion> d(m * bot) * top \\<le> ?l \\<squnion> d(?l * bot) * top\""], ["proof (prove)\nusing this:\n  m \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n\ngoal (1 subgoal):\n 1. m \\<squnion> d (m * bot) * top\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "by (meson d_isotone order.trans le_supI le_supI2 mult_left_isotone sup.cobounded1)"], ["proof (state)\nthis:\n  m \\<squnion> d (m * bot) * top\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. m \\<sqsubseteq> \\<mu> f \\<and>\n    m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<Longrightarrow>\n    d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "thus \"d(L) * \\<nu> f \\<le> ?l \\<squnion> d(?l * bot) * top\""], ["proof (prove)\nusing this:\n  m \\<squnion> d (m * bot) * top\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "using 1 apx_def order_lesseq_imp"], ["proof (prove)\nusing this:\n  m \\<squnion> d (m * bot) * top\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n  m \\<sqsubseteq> \\<mu> f \\<and>\n  m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f\n  (?x \\<sqsubseteq> ?y) =\n  (?x \\<le> ?y \\<squnion> L \\<and>\n   d L * ?y \\<le> ?x \\<squnion> d (?x * bot) * top)\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "by blast"], ["proof (state)\nthis:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<sqsubseteq> \\<mu> f \\<and>\n  m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<longrightarrow>\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m.\n     m \\<sqsubseteq> \\<mu> f \\<and>\n     m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<longrightarrow>\n     d L * \\<nu> f\n     \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n           d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m.\n     m \\<sqsubseteq> \\<mu> f \\<and>\n     m \\<sqsubseteq> \\<nu> f \\<and> m \\<le> \\<nu> f \\<longrightarrow>\n     d L * \\<nu> f\n     \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n           d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_2 f", "by (smt (verit) assms apx_meet_below_nu_def apx_meet_same apx_meet_unique is_apx_meet_def nu_below_mu_nu_2_def)"], ["proof (state)\nthis:\n  nu_below_mu_nu_2 f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_apx_least_fixpoint_kappa_apx_meet:\n  assumes \"has_least_fixpoint f\"\n      and \"has_greatest_fixpoint f\"\n      and \"apx.has_least_fixpoint f\"\n    shows \"kappa_apx_meet f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kappa_apx_meet f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. kappa_apx_meet f", "have 1: \"\\<forall>w . w \\<sqsubseteq> \\<mu> f \\<and> w \\<sqsubseteq> \\<nu> f \\<longrightarrow> d(L) * \\<kappa> f \\<le> w \\<squnion> d(w * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w.\n       w \\<sqsubseteq> \\<mu> f \\<and>\n       w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n       d L * \\<kappa> f \\<le> w \\<squnion> d (w * bot) * top", "by (metis assms(2,3) apx_def mult_right_isotone order_trans kappa_below_nu)"], ["proof (state)\nthis:\n  \\<forall>w.\n     w \\<sqsubseteq> \\<mu> f \\<and>\n     w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n     d L * \\<kappa> f \\<le> w \\<squnion> d (w * bot) * top\n\ngoal (1 subgoal):\n 1. kappa_apx_meet f", "have \"\\<forall>w . w \\<sqsubseteq> \\<mu> f \\<and> w \\<sqsubseteq> \\<nu> f \\<longrightarrow> w \\<le> \\<kappa> f \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w.\n       w \\<sqsubseteq> \\<mu> f \\<and>\n       w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n       w \\<le> \\<kappa> f \\<squnion> L", "by (metis assms(1,3) sup_left_isotone apx_def mu_below_kappa order_trans)"], ["proof (state)\nthis:\n  \\<forall>w.\n     w \\<sqsubseteq> \\<mu> f \\<and>\n     w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n     w \\<le> \\<kappa> f \\<squnion> L\n\ngoal (1 subgoal):\n 1. kappa_apx_meet f", "hence \"\\<forall>w . w \\<sqsubseteq> \\<mu> f \\<and> w \\<sqsubseteq> \\<nu> f \\<longrightarrow> w \\<sqsubseteq> \\<kappa> f\""], ["proof (prove)\nusing this:\n  \\<forall>w.\n     w \\<sqsubseteq> \\<mu> f \\<and>\n     w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n     w \\<le> \\<kappa> f \\<squnion> L\n\ngoal (1 subgoal):\n 1. \\<forall>w.\n       w \\<sqsubseteq> \\<mu> f \\<and>\n       w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n       w \\<sqsubseteq> \\<kappa> f", "using 1 apx_def"], ["proof (prove)\nusing this:\n  \\<forall>w.\n     w \\<sqsubseteq> \\<mu> f \\<and>\n     w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n     w \\<le> \\<kappa> f \\<squnion> L\n  \\<forall>w.\n     w \\<sqsubseteq> \\<mu> f \\<and>\n     w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n     d L * \\<kappa> f \\<le> w \\<squnion> d (w * bot) * top\n  (?x \\<sqsubseteq> ?y) =\n  (?x \\<le> ?y \\<squnion> L \\<and>\n   d L * ?y \\<le> ?x \\<squnion> d (?x * bot) * top)\n\ngoal (1 subgoal):\n 1. \\<forall>w.\n       w \\<sqsubseteq> \\<mu> f \\<and>\n       w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n       w \\<sqsubseteq> \\<kappa> f", "by blast"], ["proof (state)\nthis:\n  \\<forall>w.\n     w \\<sqsubseteq> \\<mu> f \\<and>\n     w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n     w \\<sqsubseteq> \\<kappa> f\n\ngoal (1 subgoal):\n 1. kappa_apx_meet f", "hence \"is_apx_meet (\\<mu> f) (\\<nu> f) (\\<kappa> f)\""], ["proof (prove)\nusing this:\n  \\<forall>w.\n     w \\<sqsubseteq> \\<mu> f \\<and>\n     w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n     w \\<sqsubseteq> \\<kappa> f\n\ngoal (1 subgoal):\n 1. is_apx_meet (\\<mu> f) (\\<nu> f) (\\<kappa> f)", "using assms apx_meet_char is_apx_meet_def kappa_apx_below_mu kappa_apx_below_nu kappa_apx_meet_def"], ["proof (prove)\nusing this:\n  \\<forall>w.\n     w \\<sqsubseteq> \\<mu> f \\<and>\n     w \\<sqsubseteq> \\<nu> f \\<longrightarrow>\n     w \\<sqsubseteq> \\<kappa> f\n  has_least_fixpoint f\n  has_greatest_fixpoint f\n  order.has_least_fixpoint (\\<sqsubseteq>) f\n  is_apx_meet ?x ?y ?z = (has_apx_meet ?x ?y \\<and> ?z = ?x \\<triangle> ?y)\n  is_apx_meet ?x ?y ?z \\<equiv>\n  ?z \\<sqsubseteq> ?x \\<and>\n  ?z \\<sqsubseteq> ?y \\<and>\n  (\\<forall>w.\n      w \\<sqsubseteq> ?x \\<and> w \\<sqsubseteq> ?y \\<longrightarrow>\n      w \\<sqsubseteq> ?z)\n  \\<lbrakk>has_least_fixpoint ?f;\n   order.has_least_fixpoint (\\<sqsubseteq>) ?f\\<rbrakk>\n  \\<Longrightarrow> \\<kappa> ?f \\<sqsubseteq> \\<mu> ?f\n  \\<lbrakk>has_greatest_fixpoint ?f;\n   order.has_least_fixpoint (\\<sqsubseteq>) ?f\\<rbrakk>\n  \\<Longrightarrow> \\<kappa> ?f \\<sqsubseteq> \\<nu> ?f\n  kappa_apx_meet ?f \\<equiv>\n  order.has_least_fixpoint (\\<sqsubseteq>) ?f \\<and>\n  has_apx_meet (\\<mu> ?f) (\\<nu> ?f) \\<and>\n  \\<kappa> ?f = \\<mu> ?f \\<triangle> \\<nu> ?f\n\ngoal (1 subgoal):\n 1. is_apx_meet (\\<mu> f) (\\<nu> f) (\\<kappa> f)", "by presburger"], ["proof (state)\nthis:\n  is_apx_meet (\\<mu> f) (\\<nu> f) (\\<kappa> f)\n\ngoal (1 subgoal):\n 1. kappa_apx_meet f", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_apx_meet (\\<mu> f) (\\<nu> f) (\\<kappa> f)\n\ngoal (1 subgoal):\n 1. kappa_apx_meet f", "by (simp add: assms(3) kappa_apx_meet_def apx_meet_char)"], ["proof (state)\nthis:\n  kappa_apx_meet f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kappa_apx_meet_apx_meet_below_nu:\n  \"has_greatest_fixpoint f \\<Longrightarrow> kappa_apx_meet f \\<Longrightarrow> apx_meet_below_nu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_greatest_fixpoint f; kappa_apx_meet f\\<rbrakk>\n    \\<Longrightarrow> apx_meet_below_nu f", "using apx_meet_below_nu_def kappa_apx_meet_def kappa_below_nu"], ["proof (prove)\nusing this:\n  apx_meet_below_nu ?f \\<equiv>\n  has_apx_meet (\\<mu> ?f) (\\<nu> ?f) \\<and>\n  \\<mu> ?f \\<triangle> \\<nu> ?f \\<le> \\<nu> ?f\n  kappa_apx_meet ?f \\<equiv>\n  order.has_least_fixpoint (\\<sqsubseteq>) ?f \\<and>\n  has_apx_meet (\\<mu> ?f) (\\<nu> ?f) \\<and>\n  \\<kappa> ?f = \\<mu> ?f \\<triangle> \\<nu> ?f\n  \\<lbrakk>has_greatest_fixpoint ?f;\n   order.has_least_fixpoint (\\<sqsubseteq>) ?f\\<rbrakk>\n  \\<Longrightarrow> \\<kappa> ?f \\<le> \\<nu> ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_greatest_fixpoint f; kappa_apx_meet f\\<rbrakk>\n    \\<Longrightarrow> apx_meet_below_nu f", "by force"], ["", "lemma apx_meet_below_nu_kappa_mu_nu:\n  assumes \"has_least_fixpoint f\"\n      and \"has_greatest_fixpoint f\"\n      and \"isotone f\"\n      and \"apx.isotone f\"\n      and \"apx_meet_below_nu f\"\n    shows \"kappa_mu_nu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "let ?l = \"\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)\""], ["proof (state)\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "let ?m = \"\\<mu> f \\<triangle> \\<nu> f\""], ["proof (state)\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "have 1: \"?m = ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<triangle> \\<nu> f = \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "by (metis assms(1,2,5) apx_meet_below_nu_nu_below_mu_nu_2 mu_nu_apx_meet_def mu_nu_apx_nu_mu_nu_apx_meet nu_below_mu_nu_2_mu_nu_apx_nu)"], ["proof (state)\nthis:\n  \\<mu> f \\<triangle> \\<nu> f = \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "have 2: \"?l \\<le> f(?l) \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n    \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n    \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L", "have \"?l \\<le> \\<mu> f \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> \\<mu> f \\<squnion> L", "using sup_right_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> \\<mu> f \\<squnion> L", "by auto"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> \\<mu> f \\<squnion> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n    \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L", "also"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> \\<mu> f \\<squnion> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n    \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L", "have \"... = f(\\<mu> f) \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> L = f (\\<mu> f) \\<squnion> L", "by (simp add: assms(1) mu_unfold)"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> L = f (\\<mu> f) \\<squnion> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n    \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L", "also"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> L = f (\\<mu> f) \\<squnion> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n    \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L", "have \"... \\<le> f(?l) \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<mu> f) \\<squnion> L\n    \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L", "by (metis assms(3) sup_left_isotone sup_ge1 isotone_def)"], ["proof (state)\nthis:\n  f (\\<mu> f) \\<squnion> L\n  \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n    \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L", "finally"], ["proof (chain)\npicking this:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n  \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n  \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n    \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L", "."], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n  \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n  \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "have \"d(L) * f(?l) \\<le> ?l \\<squnion> d(?l * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "have \"d(L) * f(?l) \\<le> d(L) * f(\\<nu> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n    \\<le> d L * f (\\<nu> f)", "by (metis assms(1-3) l_below_nu mult_right_isotone ord.isotone_def)"], ["proof (state)\nthis:\n  d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<le> d L * f (\\<nu> f)\n\ngoal (1 subgoal):\n 1. d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "also"], ["proof (state)\nthis:\n  d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<le> d L * f (\\<nu> f)\n\ngoal (1 subgoal):\n 1. d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "have \"... = d(L) * \\<nu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * f (\\<nu> f) = d L * \\<nu> f", "by (metis assms(2) nu_unfold)"], ["proof (state)\nthis:\n  d L * f (\\<nu> f) = d L * \\<nu> f\n\ngoal (1 subgoal):\n 1. d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "also"], ["proof (state)\nthis:\n  d L * f (\\<nu> f) = d L * \\<nu> f\n\ngoal (1 subgoal):\n 1. d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "have \"... \\<le> ?l \\<squnion> d(?l * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "using apx_meet_below_nu_nu_below_mu_nu_2 assms(5) nu_below_mu_nu_2_def"], ["proof (prove)\nusing this:\n  apx_meet_below_nu ?f \\<Longrightarrow> nu_below_mu_nu_2 ?f\n  apx_meet_below_nu f\n  nu_below_mu_nu_2 ?f \\<equiv>\n  d L * \\<nu> ?f\n  \\<le> \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<squnion>\n        d ((\\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "by blast"], ["proof (state)\nthis:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "finally"], ["proof (chain)\npicking this:\n  d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "."], ["proof (state)\nthis:\n  d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "hence 3: \"?l \\<sqsubseteq> f(?l)\""], ["proof (prove)\nusing this:\n  d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq>\n    f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)", "using 2"], ["proof (prove)\nusing this:\n  d L * f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n  \\<le> f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<squnion> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq>\n    f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)", "by (simp add: apx_def)"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq>\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "have 4: \"f(?l) \\<sqsubseteq> \\<mu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<mu> f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<mu> f", "have \"?l \\<sqsubseteq> \\<mu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<mu> f", "by (simp add: l_apx_mu)"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<mu> f\n\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<mu> f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<mu> f\n\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<mu> f", "by (metis assms(1,4) mu_unfold ord.isotone_def)"], ["proof (state)\nthis:\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<mu> f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<mu> f\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "have 5: \"f(?l) \\<sqsubseteq> \\<nu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<nu> f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<nu> f", "have \"?l \\<sqsubseteq> \\<nu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<nu> f", "by (meson apx_meet_below_nu_nu_below_mu_nu_2 assms(1,2,5) l_below_nu apx_def le_supI1 nu_below_mu_nu_2_def)"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<nu> f\n\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<nu> f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> \\<nu> f\n\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<nu> f", "by (metis assms(2,4) nu_unfold ord.isotone_def)"], ["proof (state)\nthis:\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<nu> f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<nu> f\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "hence \"f(?l) \\<sqsubseteq> ?l\""], ["proof (prove)\nusing this:\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<nu> f\n\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq>\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "using 1 4 apx_meet_below_nu_def assms(5) apx_greatest_lower_bound"], ["proof (prove)\nusing this:\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<nu> f\n  \\<mu> f \\<triangle> \\<nu> f = \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<mu> f\n  apx_meet_below_nu ?f \\<equiv>\n  has_apx_meet (\\<mu> ?f) (\\<nu> ?f) \\<and>\n  \\<mu> ?f \\<triangle> \\<nu> ?f \\<le> \\<nu> ?f\n  apx_meet_below_nu f\n  has_apx_meet ?x ?y \\<Longrightarrow>\n  (?w \\<sqsubseteq> ?x \\<and> ?w \\<sqsubseteq> ?y) =\n  (?w \\<sqsubseteq> ?x \\<triangle> ?y)\n\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq>\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "by fastforce"], ["proof (state)\nthis:\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq>\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "hence 6: \"f(?l) = ?l\""], ["proof (prove)\nusing this:\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq>\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "using 3 apx.order.antisym"], ["proof (prove)\nusing this:\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq>\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq>\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n  \\<lbrakk>?a \\<sqsubseteq> ?b; ?b \\<sqsubseteq> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "by blast"], ["proof (state)\nthis:\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) =\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "have \"\\<forall>y . f(y) = y \\<longrightarrow> ?l \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       f y = y \\<longrightarrow>\n       \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       f y = y \\<longrightarrow>\n       \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       f y = y \\<longrightarrow>\n       \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "show \"f(y) = y \\<longrightarrow> ?l \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f y = y \\<longrightarrow>\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. f y = y \\<Longrightarrow>\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "assume 7: \"f(y) = y\""], ["proof (state)\nthis:\n  f y = y\n\ngoal (1 subgoal):\n 1. f y = y \\<Longrightarrow>\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "hence 8: \"?l \\<le> y \\<squnion> L\""], ["proof (prove)\nusing this:\n  f y = y\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> y \\<squnion> L", "using assms(1) inf.cobounded2 is_least_fixpoint_def least_fixpoint semiring.add_mono"], ["proof (prove)\nusing this:\n  f y = y\n  has_least_fixpoint f\n  ?a \\<sqinter> ?b \\<le> ?b\n  is_least_fixpoint ?f ?x \\<equiv>\n  ?f ?x = ?x \\<and> (\\<forall>y. ?f y = y \\<longrightarrow> ?x \\<le> y)\n  has_least_fixpoint ?f \\<Longrightarrow> is_least_fixpoint ?f (\\<mu> ?f)\n  \\<lbrakk>?a \\<le> ?b; ?c \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a \\<squnion> ?c \\<le> ?b \\<squnion> ?d\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> y \\<squnion> L", "by blast"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> y \\<squnion> L\n\ngoal (1 subgoal):\n 1. f y = y \\<Longrightarrow>\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "have \"y \\<le> \\<nu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> \\<nu> f", "using 7 assms(2) greatest_fixpoint is_greatest_fixpoint_def"], ["proof (prove)\nusing this:\n  f y = y\n  has_greatest_fixpoint f\n  has_greatest_fixpoint ?f \\<Longrightarrow>\n  is_greatest_fixpoint ?f (\\<nu> ?f)\n  is_greatest_fixpoint ?f ?x \\<equiv>\n  ?f ?x = ?x \\<and> (\\<forall>y. ?f y = y \\<longrightarrow> y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. y \\<le> \\<nu> f", "by auto"], ["proof (state)\nthis:\n  y \\<le> \\<nu> f\n\ngoal (1 subgoal):\n 1. f y = y \\<Longrightarrow>\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "hence \"d(L) * y \\<le> ?l \\<squnion> d(?l * bot) * top\""], ["proof (prove)\nusing this:\n  y \\<le> \\<nu> f\n\ngoal (1 subgoal):\n 1. d L * y\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "using 3 5"], ["proof (prove)\nusing this:\n  y \\<le> \\<nu> f\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq>\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L)\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) \\<sqsubseteq> \\<nu> f\n\ngoal (1 subgoal):\n 1. d L * y\n    \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "by (smt (z3) apx.order.trans apx_def semiring.distrib_left sup.absorb_iff2 sup_assoc)"], ["proof (state)\nthis:\n  d L * y\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. f y = y \\<Longrightarrow>\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "thus \"?l \\<sqsubseteq> y\""], ["proof (prove)\nusing this:\n  d L * y\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "using 8"], ["proof (prove)\nusing this:\n  d L * y\n  \\<le> \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<le> y \\<squnion> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y", "by (simp add: apx_def)"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f y = y \\<longrightarrow>\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y.\n     f y = y \\<longrightarrow>\n     \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     f y = y \\<longrightarrow>\n     \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "using 1 6"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     f y = y \\<longrightarrow>\n     \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L \\<sqsubseteq> y\n  \\<mu> f \\<triangle> \\<nu> f = \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n  f (\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) =\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n\ngoal (1 subgoal):\n 1. kappa_mu_nu f", "by (smt (verit) kappa_mu_nu_def apx.is_least_fixpoint_def apx.least_fixpoint_char)"], ["proof (state)\nthis:\n  kappa_mu_nu f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kappa_mu_nu_has_apx_least_fixpoint:\n  \"kappa_mu_nu f \\<Longrightarrow> apx.has_least_fixpoint f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kappa_mu_nu f \\<Longrightarrow>\n    order.has_least_fixpoint (\\<sqsubseteq>) f", "by (simp add: kappa_mu_nu_def)"], ["", "lemma nu_below_mu_nu_kappa_mu_nu:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> isotone f \\<Longrightarrow> apx.isotone f \\<Longrightarrow> nu_below_mu_nu f \\<Longrightarrow> kappa_mu_nu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f; isotone f;\n     ord.isotone (\\<sqsubseteq>) f; nu_below_mu_nu f\\<rbrakk>\n    \\<Longrightarrow> kappa_mu_nu f", "using apx_meet_below_nu_kappa_mu_nu mu_nu_apx_meet_apx_meet_below_nu mu_nu_apx_nu_mu_nu_apx_meet nu_below_mu_nu_2_mu_nu_apx_nu nu_below_mu_nu_nu_below_mu_nu_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f; isotone ?f;\n   ord.isotone (\\<sqsubseteq>) ?f; apx_meet_below_nu ?f\\<rbrakk>\n  \\<Longrightarrow> kappa_mu_nu ?f\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f;\n   mu_nu_apx_meet ?f\\<rbrakk>\n  \\<Longrightarrow> apx_meet_below_nu ?f\n  mu_nu_apx_nu ?f \\<Longrightarrow> mu_nu_apx_meet ?f\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f;\n   nu_below_mu_nu_2 ?f\\<rbrakk>\n  \\<Longrightarrow> mu_nu_apx_nu ?f\n  nu_below_mu_nu ?f \\<Longrightarrow> nu_below_mu_nu_2 ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f; isotone f;\n     ord.isotone (\\<sqsubseteq>) f; nu_below_mu_nu f\\<rbrakk>\n    \\<Longrightarrow> kappa_mu_nu f", "by blast"], ["", "lemma kappa_mu_nu_nu_below_mu_nu:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> kappa_mu_nu f \\<Longrightarrow> nu_below_mu_nu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f;\n     kappa_mu_nu f\\<rbrakk>\n    \\<Longrightarrow> nu_below_mu_nu f", "by (simp add: apx_meet_below_nu_nu_below_mu_nu_2 has_apx_least_fixpoint_kappa_apx_meet kappa_apx_meet_apx_meet_below_nu kappa_mu_nu_def nu_below_mu_nu_2_nu_below_mu_nu)"], ["", "definition kappa_mu_nu_L :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"kappa_mu_nu_L f \\<equiv> apx.has_least_fixpoint f \\<and> \\<kappa> f = \\<mu> f \\<squnion> d(\\<nu> f * bot) * L\""], ["", "definition nu_below_mu_nu_L :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"nu_below_mu_nu_L f \\<equiv> d(L) * \\<nu> f \\<le> \\<mu> f \\<squnion> d(\\<nu> f * bot) * top\""], ["", "definition mu_nu_apx_nu_L :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"mu_nu_apx_nu_L f \\<equiv> \\<mu> f \\<squnion> d(\\<nu> f * bot) * L \\<sqsubseteq> \\<nu> f\""], ["", "definition mu_nu_apx_meet_L :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"mu_nu_apx_meet_L f \\<equiv> has_apx_meet (\\<mu> f) (\\<nu> f) \\<and> \\<mu> f \\<triangle> \\<nu> f = \\<mu> f \\<squnion> d(\\<nu> f * bot) * L\""], ["", "lemma n_below_l:\n  \"x \\<squnion> d(y * bot) * L \\<le> x \\<squnion> (y \\<sqinter> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> d (y * bot) * L \\<le> x \\<squnion> y \\<sqinter> L", "using d_mult_below l13 sup_right_isotone"], ["proof (prove)\nusing this:\n  d ?x * ?y \\<le> ?y\n  d (?x * bot) * L \\<le> ?x\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n\ngoal (1 subgoal):\n 1. x \\<squnion> d (y * bot) * L \\<le> x \\<squnion> y \\<sqinter> L", "by auto"], ["", "lemma n_equal_l:\n  assumes \"nu_below_mu_nu_L f\"\n    shows\"\\<mu> f \\<squnion> d(\\<nu> f * bot) * L = \\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> d (\\<nu> f * bot) * L =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> d (\\<nu> f * bot) * L =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "have \"\\<nu> f \\<sqinter> L \\<le> (\\<mu> f \\<squnion> d(\\<nu> f * bot) * top) \\<sqinter> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> f \\<sqinter> L\n    \\<le> (\\<mu> f \\<squnion> d (\\<nu> f * bot) * top) \\<sqinter> L", "using assms l31 nu_below_mu_nu_L_def"], ["proof (prove)\nusing this:\n  nu_below_mu_nu_L f\n  d L * ?x = ?x \\<sqinter> L \\<squnion> d (L * bot) * ?x\n  nu_below_mu_nu_L ?f \\<equiv>\n  d L * \\<nu> ?f \\<le> \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * top\n\ngoal (1 subgoal):\n 1. \\<nu> f \\<sqinter> L\n    \\<le> (\\<mu> f \\<squnion> d (\\<nu> f * bot) * top) \\<sqinter> L", "by force"], ["proof (state)\nthis:\n  \\<nu> f \\<sqinter> L\n  \\<le> (\\<mu> f \\<squnion> d (\\<nu> f * bot) * top) \\<sqinter> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> d (\\<nu> f * bot) * L =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "also"], ["proof (state)\nthis:\n  \\<nu> f \\<sqinter> L\n  \\<le> (\\<mu> f \\<squnion> d (\\<nu> f * bot) * top) \\<sqinter> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> d (\\<nu> f * bot) * L =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "have \"... \\<le> \\<mu> f \\<squnion> d(\\<nu> f * bot) * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> f \\<squnion> d (\\<nu> f * bot) * top) \\<sqinter> L\n    \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L", "using distrib(4) inf.sup_monoid.add_commute meet_domain_top sup_left_isotone"], ["proof (prove)\nusing this:\n  (?y \\<squnion> ?z) \\<sqinter> ?x =\n  ?y \\<sqinter> ?x \\<squnion> ?z \\<sqinter> ?x\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  ?x \\<sqinter> d ?y * top = d ?y * ?x\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> ?z \\<le> ?y \\<squnion> ?z\n\ngoal (1 subgoal):\n 1. (\\<mu> f \\<squnion> d (\\<nu> f * bot) * top) \\<sqinter> L\n    \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L", "by force"], ["proof (state)\nthis:\n  (\\<mu> f \\<squnion> d (\\<nu> f * bot) * top) \\<sqinter> L\n  \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> d (\\<nu> f * bot) * L =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "finally"], ["proof (chain)\npicking this:\n  \\<nu> f \\<sqinter> L \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L", "have \"\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L) \\<le> \\<mu> f \\<squnion> d(\\<nu> f * bot) * L\""], ["proof (prove)\nusing this:\n  \\<nu> f \\<sqinter> L \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n    \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L", "by auto"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n  \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> d (\\<nu> f * bot) * L =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n  \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> d (\\<nu> f * bot) * L =\n    \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L", "by (meson order.antisym n_below_l)"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> d (\\<nu> f * bot) * L =\n  \\<mu> f \\<squnion> \\<nu> f \\<sqinter> L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nu_below_mu_nu_L_nu_below_mu_nu:\n  \"nu_below_mu_nu_L f \\<Longrightarrow> nu_below_mu_nu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f \\<Longrightarrow> nu_below_mu_nu f", "using order_lesseq_imp sup.cobounded1 sup_left_isotone nu_below_mu_nu_L_def nu_below_mu_nu_def"], ["proof (prove)\nusing this:\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  ?a \\<le> ?a \\<squnion> ?b\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> ?z \\<le> ?y \\<squnion> ?z\n  nu_below_mu_nu_L ?f \\<equiv>\n  d L * \\<nu> ?f \\<le> \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * top\n  nu_below_mu_nu ?f \\<equiv>\n  d L * \\<nu> ?f\n  \\<le> \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<squnion>\n        d (\\<nu> ?f * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f \\<Longrightarrow> nu_below_mu_nu f", "by blast"], ["", "lemma nu_below_mu_nu_L_kappa_mu_nu_L:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> isotone f \\<Longrightarrow> apx.isotone f \\<Longrightarrow> nu_below_mu_nu_L f \\<Longrightarrow> kappa_mu_nu_L f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f; isotone f;\n     ord.isotone (\\<sqsubseteq>) f; nu_below_mu_nu_L f\\<rbrakk>\n    \\<Longrightarrow> kappa_mu_nu_L f", "using kappa_mu_nu_L_def kappa_mu_nu_def n_equal_l nu_below_mu_nu_L_nu_below_mu_nu nu_below_mu_nu_kappa_mu_nu"], ["proof (prove)\nusing this:\n  kappa_mu_nu_L ?f \\<equiv>\n  order.has_least_fixpoint (\\<sqsubseteq>) ?f \\<and>\n  \\<kappa> ?f = \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L\n  kappa_mu_nu ?f \\<equiv>\n  order.has_least_fixpoint (\\<sqsubseteq>) ?f \\<and>\n  \\<kappa> ?f = \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L\n  nu_below_mu_nu_L ?f \\<Longrightarrow>\n  \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L =\n  \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L\n  nu_below_mu_nu_L ?f \\<Longrightarrow> nu_below_mu_nu ?f\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f; isotone ?f;\n   ord.isotone (\\<sqsubseteq>) ?f; nu_below_mu_nu ?f\\<rbrakk>\n  \\<Longrightarrow> kappa_mu_nu ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f; isotone f;\n     ord.isotone (\\<sqsubseteq>) f; nu_below_mu_nu_L f\\<rbrakk>\n    \\<Longrightarrow> kappa_mu_nu_L f", "by auto"], ["", "lemma nu_below_mu_nu_L_mu_nu_apx_nu_L:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> nu_below_mu_nu_L f \\<Longrightarrow> mu_nu_apx_nu_L f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f;\n     nu_below_mu_nu_L f\\<rbrakk>\n    \\<Longrightarrow> mu_nu_apx_nu_L f", "using mu_nu_apx_nu_L_def mu_nu_apx_nu_def n_equal_l nu_below_mu_nu_2_mu_nu_apx_nu nu_below_mu_nu_L_nu_below_mu_nu nu_below_mu_nu_nu_below_mu_nu_2"], ["proof (prove)\nusing this:\n  mu_nu_apx_nu_L ?f \\<equiv>\n  \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L \\<sqsubseteq> \\<nu> ?f\n  mu_nu_apx_nu ?f \\<equiv>\n  \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<sqsubseteq> \\<nu> ?f\n  nu_below_mu_nu_L ?f \\<Longrightarrow>\n  \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L =\n  \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f;\n   nu_below_mu_nu_2 ?f\\<rbrakk>\n  \\<Longrightarrow> mu_nu_apx_nu ?f\n  nu_below_mu_nu_L ?f \\<Longrightarrow> nu_below_mu_nu ?f\n  nu_below_mu_nu ?f \\<Longrightarrow> nu_below_mu_nu_2 ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f;\n     nu_below_mu_nu_L f\\<rbrakk>\n    \\<Longrightarrow> mu_nu_apx_nu_L f", "by auto"], ["", "lemma nu_below_mu_nu_L_mu_nu_apx_meet_L:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> nu_below_mu_nu_L f \\<Longrightarrow> mu_nu_apx_meet_L f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f;\n     nu_below_mu_nu_L f\\<rbrakk>\n    \\<Longrightarrow> mu_nu_apx_meet_L f", "using mu_nu_apx_meet_L_def mu_nu_apx_meet_def mu_nu_apx_nu_mu_nu_apx_meet n_equal_l nu_below_mu_nu_2_mu_nu_apx_nu nu_below_mu_nu_L_nu_below_mu_nu nu_below_mu_nu_nu_below_mu_nu_2"], ["proof (prove)\nusing this:\n  mu_nu_apx_meet_L ?f \\<equiv>\n  has_apx_meet (\\<mu> ?f) (\\<nu> ?f) \\<and>\n  \\<mu> ?f \\<triangle> \\<nu> ?f = \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L\n  mu_nu_apx_meet ?f \\<equiv>\n  has_apx_meet (\\<mu> ?f) (\\<nu> ?f) \\<and>\n  \\<mu> ?f \\<triangle> \\<nu> ?f = \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L\n  mu_nu_apx_nu ?f \\<Longrightarrow> mu_nu_apx_meet ?f\n  nu_below_mu_nu_L ?f \\<Longrightarrow>\n  \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L =\n  \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f;\n   nu_below_mu_nu_2 ?f\\<rbrakk>\n  \\<Longrightarrow> mu_nu_apx_nu ?f\n  nu_below_mu_nu_L ?f \\<Longrightarrow> nu_below_mu_nu ?f\n  nu_below_mu_nu ?f \\<Longrightarrow> nu_below_mu_nu_2 ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f;\n     nu_below_mu_nu_L f\\<rbrakk>\n    \\<Longrightarrow> mu_nu_apx_meet_L f", "by auto"], ["", "lemma mu_nu_apx_nu_L_nu_below_mu_nu_L:\n  assumes \"has_least_fixpoint f\"\n      and \"has_greatest_fixpoint f\"\n      and \"mu_nu_apx_nu_L f\"\n    shows \"nu_below_mu_nu_L f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f", "let ?n = \"\\<mu> f \\<squnion> d(\\<nu> f * bot) * L\""], ["proof (state)\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f", "let ?l = \"\\<mu> f \\<squnion> (\\<nu> f \\<sqinter> L)\""], ["proof (state)\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f", "have \"d(L) * \\<nu> f \\<le> ?n \\<squnion> d(?n * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n          d ((\\<mu> f \\<squnion> d (\\<nu> f * bot) * L) * bot) * top", "using assms(3) apx_def mu_nu_apx_nu_L_def"], ["proof (prove)\nusing this:\n  mu_nu_apx_nu_L f\n  (?x \\<sqsubseteq> ?y) =\n  (?x \\<le> ?y \\<squnion> L \\<and>\n   d L * ?y \\<le> ?x \\<squnion> d (?x * bot) * top)\n  mu_nu_apx_nu_L ?f \\<equiv>\n  \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L \\<sqsubseteq> \\<nu> ?f\n\ngoal (1 subgoal):\n 1. d L * \\<nu> f\n    \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n          d ((\\<mu> f \\<squnion> d (\\<nu> f * bot) * L) * bot) * top", "by blast"], ["proof (state)\nthis:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n        d ((\\<mu> f \\<squnion> d (\\<nu> f * bot) * L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f", "also"], ["proof (state)\nthis:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n        d ((\\<mu> f \\<squnion> d (\\<nu> f * bot) * L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f", "have \"... \\<le> ?n \\<squnion> d(?l * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n    d ((\\<mu> f \\<squnion> d (\\<nu> f * bot) * L) * bot) * top\n    \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "using d_isotone mult_left_isotone semiring.add_left_mono n_below_l"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> d ?x \\<le> d ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  ?a \\<le> ?b \\<Longrightarrow> ?c \\<squnion> ?a \\<le> ?c \\<squnion> ?b\n  ?x \\<squnion> d (?y * bot) * L \\<le> ?x \\<squnion> ?y \\<sqinter> L\n\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n    d ((\\<mu> f \\<squnion> d (\\<nu> f * bot) * L) * bot) * top\n    \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n          d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top", "by auto"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n  d ((\\<mu> f \\<squnion> d (\\<nu> f * bot) * L) * bot) * top\n  \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f", "also"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n  d ((\\<mu> f \\<squnion> d (\\<nu> f * bot) * L) * bot) * top\n  \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n        d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f", "have \"... \\<le> ?n \\<squnion> d(\\<nu> f * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n    d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n    \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n          d (\\<nu> f * bot) * top", "by (meson assms(1,2) l_below_nu d_isotone mult_left_isotone sup_right_isotone)"], ["proof (state)\nthis:\n  \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n  d ((\\<mu> f \\<squnion> \\<nu> f \\<sqinter> L) * bot) * top\n  \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n        d (\\<nu> f * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f", "finally"], ["proof (chain)\npicking this:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n        d (\\<nu> f * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d L * \\<nu> f\n  \\<le> \\<mu> f \\<squnion> d (\\<nu> f * bot) * L \\<squnion>\n        d (\\<nu> f * bot) * top\n\ngoal (1 subgoal):\n 1. nu_below_mu_nu_L f", "by (metis sup_assoc sup_right_top mult_left_dist_sup nu_below_mu_nu_L_def)"], ["proof (state)\nthis:\n  nu_below_mu_nu_L f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kappa_mu_nu_L_mu_nu_apx_nu_L:\n  \"has_greatest_fixpoint f \\<Longrightarrow> kappa_mu_nu_L f \\<Longrightarrow> mu_nu_apx_nu_L f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_greatest_fixpoint f; kappa_mu_nu_L f\\<rbrakk>\n    \\<Longrightarrow> mu_nu_apx_nu_L f", "using kappa_mu_nu_L_def kappa_apx_below_nu mu_nu_apx_nu_L_def"], ["proof (prove)\nusing this:\n  kappa_mu_nu_L ?f \\<equiv>\n  order.has_least_fixpoint (\\<sqsubseteq>) ?f \\<and>\n  \\<kappa> ?f = \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L\n  \\<lbrakk>has_greatest_fixpoint ?f;\n   order.has_least_fixpoint (\\<sqsubseteq>) ?f\\<rbrakk>\n  \\<Longrightarrow> \\<kappa> ?f \\<sqsubseteq> \\<nu> ?f\n  mu_nu_apx_nu_L ?f \\<equiv>\n  \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L \\<sqsubseteq> \\<nu> ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_greatest_fixpoint f; kappa_mu_nu_L f\\<rbrakk>\n    \\<Longrightarrow> mu_nu_apx_nu_L f", "by force"], ["", "lemma mu_nu_apx_meet_L_mu_nu_apx_nu_L:\n  \"mu_nu_apx_meet_L f \\<Longrightarrow> mu_nu_apx_nu_L f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu_nu_apx_meet_L f \\<Longrightarrow> mu_nu_apx_nu_L f", "using apx_greatest_lower_bound mu_nu_apx_meet_L_def mu_nu_apx_nu_L_def"], ["proof (prove)\nusing this:\n  has_apx_meet ?x ?y \\<Longrightarrow>\n  (?w \\<sqsubseteq> ?x \\<and> ?w \\<sqsubseteq> ?y) =\n  (?w \\<sqsubseteq> ?x \\<triangle> ?y)\n  mu_nu_apx_meet_L ?f \\<equiv>\n  has_apx_meet (\\<mu> ?f) (\\<nu> ?f) \\<and>\n  \\<mu> ?f \\<triangle> \\<nu> ?f = \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L\n  mu_nu_apx_nu_L ?f \\<equiv>\n  \\<mu> ?f \\<squnion> d (\\<nu> ?f * bot) * L \\<sqsubseteq> \\<nu> ?f\n\ngoal (1 subgoal):\n 1. mu_nu_apx_meet_L f \\<Longrightarrow> mu_nu_apx_nu_L f", "by fastforce"], ["", "lemma kappa_mu_nu_L_nu_below_mu_nu_L:\n  \"has_least_fixpoint f \\<Longrightarrow> has_greatest_fixpoint f \\<Longrightarrow> kappa_mu_nu_L f \\<Longrightarrow> nu_below_mu_nu_L f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f;\n     kappa_mu_nu_L f\\<rbrakk>\n    \\<Longrightarrow> nu_below_mu_nu_L f", "using kappa_mu_nu_L_mu_nu_apx_nu_L mu_nu_apx_nu_L_nu_below_mu_nu_L"], ["proof (prove)\nusing this:\n  \\<lbrakk>has_greatest_fixpoint ?f; kappa_mu_nu_L ?f\\<rbrakk>\n  \\<Longrightarrow> mu_nu_apx_nu_L ?f\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f;\n   mu_nu_apx_nu_L ?f\\<rbrakk>\n  \\<Longrightarrow> nu_below_mu_nu_L ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f; has_greatest_fixpoint f;\n     kappa_mu_nu_L f\\<rbrakk>\n    \\<Longrightarrow> nu_below_mu_nu_L f", "by auto"], ["", "end"], ["", "class itering_apx = domain_itering_lattice_L + domain_semiring_lattice_apx\nbegin"], ["", "lemma circ_apx_isotone:\n  assumes \"x \\<sqsubseteq> y\"\n    shows \"x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "have 1: \"x \\<le> y \\<squnion> L \\<and> d(L) * y \\<le> x \\<squnion> d(x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> L \\<and>\n    d L * y \\<le> x \\<squnion> d (x * bot) * top", "using assms apx_def"], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> y\n  (?x \\<sqsubseteq> ?y) =\n  (?x \\<le> ?y \\<squnion> L \\<and>\n   d L * ?y \\<le> ?x \\<squnion> d (?x * bot) * top)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> L \\<and>\n    d L * y \\<le> x \\<squnion> d (x * bot) * top", "by auto"], ["proof (state)\nthis:\n  x \\<le> y \\<squnion> L \\<and> d L * y \\<le> x \\<squnion> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "have \"d(L) * y\\<^sup>\\<circ> \\<le> (d(L) * y)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * y\\<^sup>\\<circ> \\<le> (d L * y)\\<^sup>\\<circ>", "by (metis d_circ_import d_mult_below l2)"], ["proof (state)\nthis:\n  d L * y\\<^sup>\\<circ> \\<le> (d L * y)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  d L * y\\<^sup>\\<circ> \\<le> (d L * y)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "have \"... \\<le> x\\<^sup>\\<circ> * (d(x * bot) * top * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d L * y)\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> *\n          (d (x * bot) * top * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "using 1"], ["proof (prove)\nusing this:\n  x \\<le> y \\<squnion> L \\<and> d L * y \\<le> x \\<squnion> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. (d L * y)\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> *\n          (d (x * bot) * top * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by (metis circ_sup_1 circ_isotone)"], ["proof (state)\nthis:\n  (d L * y)\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> *\n        (d (x * bot) * top * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  (d L * y)\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> *\n        (d (x * bot) * top * x\\<^sup>\\<circ>)\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "have \"... = x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * d(x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * (d (x * bot) * top * x\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n    x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * d (x * bot) * top", "by (metis circ_left_top mult_assoc mult_left_dist_sup mult_1_right mult_top_circ)"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> * (d (x * bot) * top * x\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n  x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> * (d (x * bot) * top * x\\<^sup>\\<circ>)\\<^sup>\\<circ> =\n  x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "have \"... \\<le> x\\<^sup>\\<circ> \\<squnion> d(x\\<^sup>\\<circ> * x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * d (x * bot) * top\n    \\<le> x\\<^sup>\\<circ> \\<squnion> d (x\\<^sup>\\<circ> * x * bot) * top", "by (metis sup_right_isotone mult_assoc mult_domain_top)"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> \\<squnion> x\\<^sup>\\<circ> * d (x * bot) * top\n  \\<le> x\\<^sup>\\<circ> \\<squnion> d (x\\<^sup>\\<circ> * x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "finally"], ["proof (chain)\npicking this:\n  d L * y\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> \\<squnion> d (x\\<^sup>\\<circ> * x * bot) * top", "have 2: \"d(L) * y\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> \\<squnion> d(x\\<^sup>\\<circ> * bot) * top\""], ["proof (prove)\nusing this:\n  d L * y\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> \\<squnion> d (x\\<^sup>\\<circ> * x * bot) * top\n\ngoal (1 subgoal):\n 1. d L * y\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> \\<squnion> d (x\\<^sup>\\<circ> * bot) * top", "using circ_plus_same d0_circ_left_unfold"], ["proof (prove)\nusing this:\n  d L * y\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> \\<squnion> d (x\\<^sup>\\<circ> * x * bot) * top\n  ?x\\<^sup>\\<circ> * ?x = ?x * ?x\\<^sup>\\<circ>\n  d (?x\\<^sup>\\<circ> * bot) = d (?x * ?x\\<^sup>\\<circ> * bot)\n\ngoal (1 subgoal):\n 1. d L * y\\<^sup>\\<circ>\n    \\<le> x\\<^sup>\\<circ> \\<squnion> d (x\\<^sup>\\<circ> * bot) * top", "by auto"], ["proof (state)\nthis:\n  d L * y\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> \\<squnion> d (x\\<^sup>\\<circ> * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "have \"x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * L\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * L\\<^sup>\\<circ>", "using 1"], ["proof (prove)\nusing this:\n  x \\<le> y \\<squnion> L \\<and> d L * y \\<le> x \\<squnion> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * L\\<^sup>\\<circ>", "by (metis circ_sup_1 circ_back_loop_fixpoint circ_isotone l40 le_iff_sup mult_assoc)"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * L\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> * L\\<^sup>\\<circ>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "have \"... = y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> * L\\<^sup>\\<circ> =\n    y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * L", "by (simp add: circ_L mult_left_dist_sup sup_commute)"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * L\\<^sup>\\<circ> =\n  y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> * L\\<^sup>\\<circ> =\n  y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "have \"... \\<le> y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * L\n    \\<le> y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot \\<squnion> L", "using l14 semiring.add_left_mono sup_monoid.add_assoc"], ["proof (prove)\nusing this:\n  ?x * L \\<le> ?x * bot \\<squnion> L\n  ?a \\<le> ?b \\<Longrightarrow> ?c \\<squnion> ?a \\<le> ?c \\<squnion> ?b\n  ?a \\<squnion> ?b \\<squnion> ?c = ?a \\<squnion> (?b \\<squnion> ?c)\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * L\n    \\<le> y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot \\<squnion> L", "by auto"], ["proof (state)\nthis:\n  y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * L\n  \\<le> y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot \\<squnion> L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>\\<circ>\n  \\<le> y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot \\<squnion> L", "have \"x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> \\<squnion> L\""], ["proof (prove)\nusing this:\n  x\\<^sup>\\<circ>\n  \\<le> y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot \\<squnion> L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> \\<squnion> L", "using sup.absorb_iff1 zero_right_mult_decreasing"], ["proof (prove)\nusing this:\n  x\\<^sup>\\<circ>\n  \\<le> y\\<^sup>\\<circ> \\<squnion> y\\<^sup>\\<circ> * bot \\<squnion> L\n  (?b \\<le> ?a) = (?a \\<squnion> ?b = ?a)\n  ?x * bot \\<le> ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> \\<squnion> L", "by auto"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> \\<squnion> L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "thus ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> \\<squnion> L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "using 2"], ["proof (prove)\nusing this:\n  x\\<^sup>\\<circ> \\<le> y\\<^sup>\\<circ> \\<squnion> L\n  d L * y\\<^sup>\\<circ>\n  \\<le> x\\<^sup>\\<circ> \\<squnion> d (x\\<^sup>\\<circ> * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>", "by (simp add: apx_def)"], ["proof (state)\nthis:\n  x\\<^sup>\\<circ> \\<sqsubseteq> y\\<^sup>\\<circ>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class omega_algebra_apx = domain_omega_algebra_lattice_L + domain_semiring_lattice_apx"], ["", "sublocale omega_algebra_apx < star: itering_apx where circ = star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.itering_apx (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot d\n     (\\<sqinter>) top L star (\\<sqsubseteq>)", ".."], ["", "context omega_algebra_apx\nbegin"], ["", "lemma omega_apx_isotone:\n  assumes \"x \\<sqsubseteq> y\"\n    shows \"x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have 1: \"x \\<le> y \\<squnion> L \\<and> d(L) * y \\<le> x \\<squnion> d(x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> L \\<and>\n    d L * y \\<le> x \\<squnion> d (x * bot) * top", "using assms apx_def"], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> y\n  (?x \\<sqsubseteq> ?y) =\n  (?x \\<le> ?y \\<squnion> L \\<and>\n   d L * ?y \\<le> ?x \\<squnion> d (?x * bot) * top)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> L \\<and>\n    d L * y \\<le> x \\<squnion> d (x * bot) * top", "by auto"], ["proof (state)\nthis:\n  x \\<le> y \\<squnion> L \\<and> d L * y \\<le> x \\<squnion> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"d(L) * y\\<^sup>\\<omega> = (d(L) * y)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * y\\<^sup>\\<omega> = (d L * y)\\<^sup>\\<omega>", "by (simp add: d_omega_export l2)"], ["proof (state)\nthis:\n  d L * y\\<^sup>\\<omega> = (d L * y)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  d L * y\\<^sup>\\<omega> = (d L * y)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... \\<le> (x \\<squnion> d(x * bot) * top)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d L * y)\\<^sup>\\<omega>\n    \\<le> (x \\<squnion> d (x * bot) * top)\\<^sup>\\<omega>", "using 1"], ["proof (prove)\nusing this:\n  x \\<le> y \\<squnion> L \\<and> d L * y \\<le> x \\<squnion> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. (d L * y)\\<^sup>\\<omega>\n    \\<le> (x \\<squnion> d (x * bot) * top)\\<^sup>\\<omega>", "by (simp add: omega_isotone)"], ["proof (state)\nthis:\n  (d L * y)\\<^sup>\\<omega>\n  \\<le> (x \\<squnion> d (x * bot) * top)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  (d L * y)\\<^sup>\\<omega>\n  \\<le> (x \\<squnion> d (x * bot) * top)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... = (x\\<^sup>\\<star> * d(x * bot) * top)\\<^sup>\\<omega> \\<squnion> (x\\<^sup>\\<star> * d(x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> d (x * bot) * top)\\<^sup>\\<omega> =\n    (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<omega> \\<squnion>\n    (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega>", "by (simp add: ils.il_inf_associative omega_decompose)"], ["proof (state)\nthis:\n  (x \\<squnion> d (x * bot) * top)\\<^sup>\\<omega> =\n  (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<omega> \\<squnion>\n  (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  (x \\<squnion> d (x * bot) * top)\\<^sup>\\<omega> =\n  (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<omega> \\<squnion>\n  (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... \\<le> x\\<^sup>\\<star> * d(x * bot) * top \\<squnion> (x\\<^sup>\\<star> * d(x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<omega> \\<squnion>\n    (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega>\n    \\<le> x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n          (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> *\n          x\\<^sup>\\<omega>", "using mult_top_omega sup_left_isotone"], ["proof (prove)\nusing this:\n  (?x * top)\\<^sup>\\<omega> \\<le> ?x * top\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> ?z \\<le> ?y \\<squnion> ?z\n\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<omega> \\<squnion>\n    (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega>\n    \\<le> x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n          (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> *\n          x\\<^sup>\\<omega>", "by blast"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<omega> \\<squnion>\n  (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega>\n  \\<le> x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n        (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> *\n        x\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<omega> \\<squnion>\n  (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega>\n  \\<le> x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n        (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> *\n        x\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... = x\\<^sup>\\<star> * d(x * bot) * top \\<squnion> (1 \\<squnion> x\\<^sup>\\<star> * d(x * bot) * top * (x\\<^sup>\\<star> * d(x * bot) * top)\\<^sup>\\<star>) * x\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n    (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega> =\n    x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n    ((1::'a) \\<squnion> (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>+) *\n    x\\<^sup>\\<omega>", "by (simp add: star_left_unfold_equal)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n  (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega> =\n  x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n  ((1::'a) \\<squnion> (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>+) *\n  x\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n  (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>\\<star> * x\\<^sup>\\<omega> =\n  x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n  ((1::'a) \\<squnion> (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>+) *\n  x\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... \\<le> x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star> * d(x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n    ((1::'a) \\<squnion> (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>+) *\n    x\\<^sup>\\<omega>\n    \\<le> x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star> * d (x * bot) * top", "by (smt (verit, ccfv_threshold) sup_mono le_sup_iff mult_assoc mult_left_one mult_right_dist_sup mult_right_isotone order_refl top_greatest)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n  ((1::'a) \\<squnion> (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>+) *\n  x\\<^sup>\\<omega>\n  \\<le> x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star> * d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * d (x * bot) * top \\<squnion>\n  ((1::'a) \\<squnion> (x\\<^sup>\\<star> * d (x * bot) * top)\\<^sup>+) *\n  x\\<^sup>\\<omega>\n  \\<le> x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star> * d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... \\<le> x\\<^sup>\\<omega> \\<squnion> d(x\\<^sup>\\<star> * x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star> * d (x * bot) * top\n    \\<le> x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<star> * x * bot) * top", "by (metis sup_right_isotone mult_assoc mult_domain_top)"], ["proof (state)\nthis:\n  x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star> * d (x * bot) * top\n  \\<le> x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<star> * x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star> * d (x * bot) * top\n  \\<le> x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<star> * x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... \\<le> x\\<^sup>\\<omega> \\<squnion> d(x\\<^sup>\\<star> * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<star> * x * bot) * top\n    \\<le> x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<star> * bot) * top", "by (simp add: dL_star.d0_circ_left_unfold star_plus)"], ["proof (state)\nthis:\n  x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<star> * x * bot) * top\n  \\<le> x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<star> * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "finally"], ["proof (chain)\npicking this:\n  d L * y\\<^sup>\\<omega>\n  \\<le> x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<star> * bot) * top", "have 2: \"d(L) * y\\<^sup>\\<omega> \\<le> x\\<^sup>\\<omega> \\<squnion> d(x\\<^sup>\\<omega> * bot) * top\""], ["proof (prove)\nusing this:\n  d L * y\\<^sup>\\<omega>\n  \\<le> x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<star> * bot) * top\n\ngoal (1 subgoal):\n 1. d L * y\\<^sup>\\<omega>\n    \\<le> x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<omega> * bot) * top", "by (meson sup_right_isotone d0_star_below_d0_omega mult_left_isotone order_trans)"], ["proof (state)\nthis:\n  d L * y\\<^sup>\\<omega>\n  \\<le> x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<omega> * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"x\\<^sup>\\<omega> \\<le> (y \\<squnion> L)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<le> (y \\<squnion> L)\\<^sup>\\<omega>", "using 1"], ["proof (prove)\nusing this:\n  x \\<le> y \\<squnion> L \\<and> d L * y \\<le> x \\<squnion> d (x * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<le> (y \\<squnion> L)\\<^sup>\\<omega>", "by (simp add: omega_isotone)"], ["proof (state)\nthis:\n  x\\<^sup>\\<omega> \\<le> (y \\<squnion> L)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<omega> \\<le> (y \\<squnion> L)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... = (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion> (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<squnion> L)\\<^sup>\\<omega> =\n    (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n    (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>", "by (simp add: omega_decompose)"], ["proof (state)\nthis:\n  (y \\<squnion> L)\\<^sup>\\<omega> =\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  (y \\<squnion> L)\\<^sup>\\<omega> =\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... = y\\<^sup>\\<star> * L * (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion> (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n    (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega> =\n    y\\<^sup>\\<star> * L * (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n    (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>", "using omega_unfold"], ["proof (prove)\nusing this:\n  ?y\\<^sup>\\<omega> = ?y * ?y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n    (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega> =\n    y\\<^sup>\\<star> * L * (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n    (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>", "by auto"], ["proof (state)\nthis:\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega> =\n  y\\<^sup>\\<star> * L * (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega> =\n  y\\<^sup>\\<star> * L * (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... \\<le> y\\<^sup>\\<star> * L \\<squnion> (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * L * (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n    (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<star> * L \\<squnion>\n          (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>", "using mult_L_omega omega_unfold sup_left_isotone"], ["proof (prove)\nusing this:\n  (?x * L)\\<^sup>\\<omega> \\<le> ?x * L\n  ?y\\<^sup>\\<omega> = ?y * ?y\\<^sup>\\<omega>\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> ?z \\<le> ?y \\<squnion> ?z\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * L * (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n    (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<star> * L \\<squnion>\n          (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>", "by auto"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * L * (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<star> * L \\<squnion>\n        (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * L * (y\\<^sup>\\<star> * L)\\<^sup>\\<omega> \\<squnion>\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<star> * L \\<squnion>\n        (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... = y\\<^sup>\\<star> * L \\<squnion> (1 \\<squnion> y\\<^sup>\\<star> * L * (y\\<^sup>\\<star> * L)\\<^sup>\\<star>) * y\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * L \\<squnion>\n    (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega> =\n    y\\<^sup>\\<star> * L \\<squnion>\n    ((1::'a) \\<squnion> (y\\<^sup>\\<star> * L)\\<^sup>+) * y\\<^sup>\\<omega>", "by (simp add: star_left_unfold_equal)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * L \\<squnion>\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega> =\n  y\\<^sup>\\<star> * L \\<squnion>\n  ((1::'a) \\<squnion> (y\\<^sup>\\<star> * L)\\<^sup>+) * y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * L \\<squnion>\n  (y\\<^sup>\\<star> * L)\\<^sup>\\<star> * y\\<^sup>\\<omega> =\n  y\\<^sup>\\<star> * L \\<squnion>\n  ((1::'a) \\<squnion> (y\\<^sup>\\<star> * L)\\<^sup>+) * y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... \\<le> y\\<^sup>\\<star> * L \\<squnion> y\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * L \\<squnion>\n    ((1::'a) \\<squnion> (y\\<^sup>\\<star> * L)\\<^sup>+) * y\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<star> * L \\<squnion> y\\<^sup>\\<omega>", "by (simp add: dL_star.mult_L_circ_mult_below star_left_unfold_equal sup_commute)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * L \\<squnion>\n  ((1::'a) \\<squnion> (y\\<^sup>\\<star> * L)\\<^sup>+) * y\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<star> * L \\<squnion> y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * L \\<squnion>\n  ((1::'a) \\<squnion> (y\\<^sup>\\<star> * L)\\<^sup>+) * y\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<star> * L \\<squnion> y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "have \"... \\<le> y\\<^sup>\\<star> * bot \\<squnion> L \\<squnion> y\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * L \\<squnion> y\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<star> * bot \\<squnion> L \\<squnion> y\\<^sup>\\<omega>", "by (simp add: l14 le_supI1)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * L \\<squnion> y\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<star> * bot \\<squnion> L \\<squnion> y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<star> * bot \\<squnion> L \\<squnion> y\\<^sup>\\<omega>", "have \"x\\<^sup>\\<omega> \\<le> y\\<^sup>\\<omega> \\<squnion> L\""], ["proof (prove)\nusing this:\n  x\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<star> * bot \\<squnion> L \\<squnion> y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<le> y\\<^sup>\\<omega> \\<squnion> L", "using star_bot_below_omega sup.left_commute sup.order_iff sup_commute"], ["proof (prove)\nusing this:\n  x\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<star> * bot \\<squnion> L \\<squnion> y\\<^sup>\\<omega>\n  ?x\\<^sup>\\<star> * bot \\<le> ?x\\<^sup>\\<omega>\n  ?b \\<squnion> (?a \\<squnion> ?c) = ?a \\<squnion> (?b \\<squnion> ?c)\n  (?b \\<le> ?a) = (?a = ?a \\<squnion> ?b)\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<le> y\\<^sup>\\<omega> \\<squnion> L", "by auto"], ["proof (state)\nthis:\n  x\\<^sup>\\<omega> \\<le> y\\<^sup>\\<omega> \\<squnion> L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "thus ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>\\<omega> \\<le> y\\<^sup>\\<omega> \\<squnion> L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "using 2"], ["proof (prove)\nusing this:\n  x\\<^sup>\\<omega> \\<le> y\\<^sup>\\<omega> \\<squnion> L\n  d L * y\\<^sup>\\<omega>\n  \\<le> x\\<^sup>\\<omega> \\<squnion> d (x\\<^sup>\\<omega> * bot) * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>", "by (simp add: apx_def)"], ["proof (state)\nthis:\n  x\\<^sup>\\<omega> \\<sqsubseteq> y\\<^sup>\\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma combined_apx_isotone:\n  \"x \\<sqsubseteq> y \\<Longrightarrow> (x\\<^sup>\\<omega> \\<sqinter> L) \\<squnion> x\\<^sup>\\<star> * z \\<sqsubseteq> (y\\<^sup>\\<omega> \\<sqinter> L) \\<squnion> y\\<^sup>\\<star> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y \\<Longrightarrow>\n    x\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n    x\\<^sup>\\<star> * z \\<sqsubseteq>\n    y\\<^sup>\\<omega> \\<sqinter> L \\<squnion> y\\<^sup>\\<star> * z", "using meet_L_apx_isotone mult_apx_left_isotone star.circ_apx_isotone sup_apx_isotone omega_apx_isotone"], ["proof (prove)\nusing this:\n  ?x \\<sqsubseteq> ?y \\<Longrightarrow>\n  ?x \\<sqinter> L \\<sqsubseteq> ?y \\<sqinter> L\n  ?x \\<sqsubseteq> ?y \\<Longrightarrow> ?x * ?z \\<sqsubseteq> ?y * ?z\n  ?x \\<sqsubseteq> ?y \\<Longrightarrow>\n  ?x\\<^sup>\\<star> \\<sqsubseteq> ?y\\<^sup>\\<star>\n  \\<lbrakk>?w \\<sqsubseteq> ?y; ?x \\<sqsubseteq> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w \\<squnion> ?x \\<sqsubseteq> ?y \\<squnion> ?z\n  ?x \\<sqsubseteq> ?y \\<Longrightarrow>\n  ?x\\<^sup>\\<omega> \\<sqsubseteq> ?y\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y \\<Longrightarrow>\n    x\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n    x\\<^sup>\\<star> * z \\<sqsubseteq>\n    y\\<^sup>\\<omega> \\<sqinter> L \\<squnion> y\\<^sup>\\<star> * z", "by auto"], ["", "lemma d_split_nu_mu:\n  \"d(L) * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<le> y\\<^sup>\\<star> * z \\<squnion> ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter> L) \\<squnion> d((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "have \"d(L) * y\\<^sup>\\<omega> \\<le> (y\\<^sup>\\<omega> \\<sqinter> L) \\<squnion> d(y\\<^sup>\\<omega> * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * y\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n          d (y\\<^sup>\\<omega> * bot) * top", "using l31 l91 omega_vector sup_right_isotone"], ["proof (prove)\nusing this:\n  d L * ?x = ?x \\<sqinter> L \\<squnion> d (L * bot) * ?x\n  ?x = ?x * top \\<Longrightarrow> d (L * bot) * ?x \\<le> d (?x * bot) * top\n  vector (?x\\<^sup>\\<omega>)\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n\ngoal (1 subgoal):\n 1. d L * y\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n          d (y\\<^sup>\\<omega> * bot) * top", "by auto"], ["proof (state)\nthis:\n  d L * y\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n        d (y\\<^sup>\\<omega> * bot) * top\n\ngoal (1 subgoal):\n 1. d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "hence \"d(L) * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<le> y\\<^sup>\\<star> * z \\<squnion> (y\\<^sup>\\<omega> \\<sqinter> L) \\<squnion> d(y\\<^sup>\\<omega> * bot) * top\""], ["proof (prove)\nusing this:\n  d L * y\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n        d (y\\<^sup>\\<omega> * bot) * top\n\ngoal (1 subgoal):\n 1. d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          y\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n          d (y\\<^sup>\\<omega> * bot) * top", "by (smt sup_assoc sup_commute sup_mono d_mult_below mult_left_dist_sup)"], ["proof (state)\nthis:\n  d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n  \\<le> y\\<^sup>\\<star> * z \\<squnion>\n        y\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n        d (y\\<^sup>\\<omega> * bot) * top\n\ngoal (1 subgoal):\n 1. d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "also"], ["proof (state)\nthis:\n  d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n  \\<le> y\\<^sup>\\<star> * z \\<squnion>\n        y\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n        d (y\\<^sup>\\<omega> * bot) * top\n\ngoal (1 subgoal):\n 1. d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "have \"... \\<le> y\\<^sup>\\<star> * z \\<squnion> ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter> L) \\<squnion> d(y\\<^sup>\\<omega> * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * z \\<squnion> y\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n    d (y\\<^sup>\\<omega> * bot) * top\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d (y\\<^sup>\\<omega> * bot) * top", "by (simp add: le_supI1 le_supI2)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * z \\<squnion> y\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n  d (y\\<^sup>\\<omega> * bot) * top\n  \\<le> y\\<^sup>\\<star> * z \\<squnion>\n        (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n        L \\<squnion>\n        d (y\\<^sup>\\<omega> * bot) * top\n\ngoal (1 subgoal):\n 1. d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * z \\<squnion> y\\<^sup>\\<omega> \\<sqinter> L \\<squnion>\n  d (y\\<^sup>\\<omega> * bot) * top\n  \\<le> y\\<^sup>\\<star> * z \\<squnion>\n        (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n        L \\<squnion>\n        d (y\\<^sup>\\<omega> * bot) * top\n\ngoal (1 subgoal):\n 1. d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "have \"... \\<le> y\\<^sup>\\<star> * z \\<squnion> ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter> L) \\<squnion> d((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> * z \\<squnion>\n    (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n    L \\<squnion>\n    d (y\\<^sup>\\<omega> * bot) * top\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "by (meson d_isotone mult_left_isotone sup.cobounded1 sup_right_isotone)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> * z \\<squnion>\n  (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter> L \\<squnion>\n  d (y\\<^sup>\\<omega> * bot) * top\n  \\<le> y\\<^sup>\\<star> * z \\<squnion>\n        (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n        L \\<squnion>\n        d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top\n\ngoal (1 subgoal):\n 1. d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "finally"], ["proof (chain)\npicking this:\n  d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n  \\<le> y\\<^sup>\\<star> * z \\<squnion>\n        (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n        L \\<squnion>\n        d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n  \\<le> y\\<^sup>\\<star> * z \\<squnion>\n        (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n        L \\<squnion>\n        d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top\n\ngoal (1 subgoal):\n 1. d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n    \\<le> y\\<^sup>\\<star> * z \\<squnion>\n          (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n          L \\<squnion>\n          d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top", "."], ["proof (state)\nthis:\n  d L * (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z)\n  \\<le> y\\<^sup>\\<star> * z \\<squnion>\n        (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter>\n        L \\<squnion>\n        d ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) * bot) * top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loop_exists:\n  \"d(L) * \\<nu> (\\<lambda>x . y * x \\<squnion> z) \\<le> \\<mu> (\\<lambda>x . y * x \\<squnion> z) \\<squnion> (\\<nu> (\\<lambda>x . y * x \\<squnion> z) \\<sqinter> L) \\<squnion> d(\\<nu> (\\<lambda>x . y * x \\<squnion> z) * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * \\<nu> (\\<lambda>x. y * x \\<squnion> z)\n    \\<le> \\<mu> (\\<lambda>x. y * x \\<squnion> z) \\<squnion>\n          \\<nu> (\\<lambda>x. y * x \\<squnion> z) \\<sqinter> L \\<squnion>\n          d (\\<nu> (\\<lambda>x. y * x \\<squnion> z) * bot) * top", "by (simp add: d_split_nu_mu omega_loop_nu star_loop_mu)"], ["", "lemma loop_apx_least_fixpoint:\n  \"apx.is_least_fixpoint (\\<lambda>x . y * x \\<squnion> z) (\\<mu> (\\<lambda>x . y * x \\<squnion> z) \\<squnion> (\\<nu> (\\<lambda>x . y * x \\<squnion> z) \\<sqinter> L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.is_least_fixpoint (\\<sqsubseteq>) (\\<lambda>x. y * x \\<squnion> z)\n     (\\<mu> (\\<lambda>x. y * x \\<squnion> z) \\<squnion>\n      \\<nu> (\\<lambda>x. y * x \\<squnion> z) \\<sqinter> L)", "using apx.least_fixpoint_char affine_apx_isotone loop_exists affine_has_greatest_fixpoint affine_has_least_fixpoint affine_isotone nu_below_mu_nu_def nu_below_mu_nu_kappa_mu_nu kappa_mu_nu_def"], ["proof (prove)\nusing this:\n  order.is_least_fixpoint (\\<sqsubseteq>) ?f ?x =\n  (order.has_least_fixpoint (\\<sqsubseteq>) ?f \\<and> ?x = \\<kappa> ?f)\n  ord.isotone (\\<sqsubseteq>) (\\<lambda>x. ?y * x \\<squnion> ?z)\n  d L * \\<nu> (\\<lambda>x. ?y * x \\<squnion> ?z)\n  \\<le> \\<mu> (\\<lambda>x. ?y * x \\<squnion> ?z) \\<squnion>\n        \\<nu> (\\<lambda>x. ?y * x \\<squnion> ?z) \\<sqinter> L \\<squnion>\n        d (\\<nu> (\\<lambda>x. ?y * x \\<squnion> ?z) * bot) * top\n  has_greatest_fixpoint (\\<lambda>x. ?y * x \\<squnion> ?z)\n  has_least_fixpoint (\\<lambda>x. ?y * x \\<squnion> ?z)\n  isotone (\\<lambda>x. ?y * x \\<squnion> ?z)\n  nu_below_mu_nu ?f \\<equiv>\n  d L * \\<nu> ?f\n  \\<le> \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L \\<squnion>\n        d (\\<nu> ?f * bot) * top\n  \\<lbrakk>has_least_fixpoint ?f; has_greatest_fixpoint ?f; isotone ?f;\n   ord.isotone (\\<sqsubseteq>) ?f; nu_below_mu_nu ?f\\<rbrakk>\n  \\<Longrightarrow> kappa_mu_nu ?f\n  kappa_mu_nu ?f \\<equiv>\n  order.has_least_fixpoint (\\<sqsubseteq>) ?f \\<and>\n  \\<kappa> ?f = \\<mu> ?f \\<squnion> \\<nu> ?f \\<sqinter> L\n\ngoal (1 subgoal):\n 1. order.is_least_fixpoint (\\<sqsubseteq>) (\\<lambda>x. y * x \\<squnion> z)\n     (\\<mu> (\\<lambda>x. y * x \\<squnion> z) \\<squnion>\n      \\<nu> (\\<lambda>x. y * x \\<squnion> z) \\<sqinter> L)", "by auto"], ["", "lemma loop_has_apx_least_fixpoint:\n  \"apx.has_least_fixpoint (\\<lambda>x . y * x \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.has_least_fixpoint (\\<sqsubseteq>)\n     (\\<lambda>x. y * x \\<squnion> z)", "by (metis apx.has_least_fixpoint_def loop_apx_least_fixpoint)"], ["", "lemma loop_semantics:\n  \"\\<kappa> (\\<lambda>x . y * x \\<squnion> z) = \\<mu> (\\<lambda>x . y * x \\<squnion> z) \\<squnion> (\\<nu> (\\<lambda>x . y * x \\<squnion> z) \\<sqinter> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n    \\<mu> (\\<lambda>x. y * x \\<squnion> z) \\<squnion>\n    \\<nu> (\\<lambda>x. y * x \\<squnion> z) \\<sqinter> L", "using apx.least_fixpoint_char loop_apx_least_fixpoint"], ["proof (prove)\nusing this:\n  order.is_least_fixpoint (\\<sqsubseteq>) ?f ?x =\n  (order.has_least_fixpoint (\\<sqsubseteq>) ?f \\<and> ?x = \\<kappa> ?f)\n  order.is_least_fixpoint (\\<sqsubseteq>) (\\<lambda>x. ?y * x \\<squnion> ?z)\n   (\\<mu> (\\<lambda>x. ?y * x \\<squnion> ?z) \\<squnion>\n    \\<nu> (\\<lambda>x. ?y * x \\<squnion> ?z) \\<sqinter> L)\n\ngoal (1 subgoal):\n 1. \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n    \\<mu> (\\<lambda>x. y * x \\<squnion> z) \\<squnion>\n    \\<nu> (\\<lambda>x. y * x \\<squnion> z) \\<sqinter> L", "by auto"], ["", "lemma loop_semantics_kappa_mu_nu:\n  \"\\<kappa> (\\<lambda>x . y * x \\<squnion> z) = (y\\<^sup>\\<omega> \\<sqinter> L) \\<squnion> y\\<^sup>\\<star> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n    y\\<^sup>\\<omega> \\<sqinter> L \\<squnion> y\\<^sup>\\<star> * z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n    y\\<^sup>\\<omega> \\<sqinter> L \\<squnion> y\\<^sup>\\<star> * z", "have \"\\<kappa> (\\<lambda>x . y * x \\<squnion> z) = y\\<^sup>\\<star> * z \\<squnion> ((y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n    y\\<^sup>\\<star> * z \\<squnion>\n    (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter> L", "by (metis loop_semantics omega_loop_nu star_loop_mu)"], ["proof (state)\nthis:\n  \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n  y\\<^sup>\\<star> * z \\<squnion>\n  (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter> L\n\ngoal (1 subgoal):\n 1. \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n    y\\<^sup>\\<omega> \\<sqinter> L \\<squnion> y\\<^sup>\\<star> * z", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n  y\\<^sup>\\<star> * z \\<squnion>\n  (y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z) \\<sqinter> L\n\ngoal (1 subgoal):\n 1. \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n    y\\<^sup>\\<omega> \\<sqinter> L \\<squnion> y\\<^sup>\\<star> * z", "by (metis sup.absorb2 sup_commute sup_ge2 sup_inf_distrib1)"], ["proof (state)\nthis:\n  \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n  y\\<^sup>\\<omega> \\<sqinter> L \\<squnion> y\\<^sup>\\<star> * z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loop_semantics_kappa_mu_nu_domain:\n  \"\\<kappa> (\\<lambda>x . y * x \\<squnion> z) = d(y\\<^sup>\\<omega>) * L \\<squnion> y\\<^sup>\\<star> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> (\\<lambda>x. y * x \\<squnion> z) =\n    d (y\\<^sup>\\<omega>) * L \\<squnion> y\\<^sup>\\<star> * z", "by (simp add: omega_meet_L loop_semantics_kappa_mu_nu)"], ["", "lemma loop_semantics_apx_isotone:\n  \"w \\<sqsubseteq> y \\<Longrightarrow> \\<kappa> (\\<lambda>x . w * x \\<squnion> z) \\<sqsubseteq> \\<kappa> (\\<lambda>x . y * x \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<sqsubseteq> y \\<Longrightarrow>\n    \\<kappa> (\\<lambda>x. w * x \\<squnion> z) \\<sqsubseteq>\n    \\<kappa> (\\<lambda>x. y * x \\<squnion> z)", "by (metis loop_semantics_kappa_mu_nu combined_apx_isotone)"], ["", "end"], ["", "end"]]}