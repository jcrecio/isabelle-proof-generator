{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Domain_Iterings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma d_top:\n  \"d(top) = 1\"", "lemma mult_domain_top:\n  \"x * d(y) * top \\<le> d(x * y) * top\"", "lemma domain_meet_domain:\n  \"d(x \\<sqinter> d(y) * z) \\<le> d(y)\"", "lemma meet_domain:\n  \"x \\<sqinter> d(y) * z = d(y) * (x \\<sqinter> z)\"", "lemma meet_intro_domain:\n  \"x \\<sqinter> y = d(y) * x \\<sqinter> y\"", "lemma meet_domain_top:\n  \"x \\<sqinter> d(y) * top = d(y) * x\"", "lemma d_galois:\n  \"d(x) \\<le> d(y) \\<longleftrightarrow> x \\<le> d(y) * top\"", "lemma vector_meet:\n  \"x * top \\<sqinter> y \\<le> d(x) * y\"", "lemma l8:\n  \"(x \\<sqinter> L) * bot \\<le> x * bot \\<sqinter> L\"", "lemma l9:\n  \"x * bot \\<sqinter> L \\<le> d(x * bot) * L\"", "lemma l10:\n  \"L * L = L\"", "lemma l11:\n  \"d(x) * L \\<le> x * L\"", "lemma l12:\n  \"d(x * bot) * L \\<le> x * bot\"", "lemma l13:\n  \"d(x * bot) * L \\<le> x\"", "lemma l14:\n  \"x * L \\<le> x * bot \\<squnion> L\"", "lemma l15:\n  \"x * d(y) * L = x * bot \\<squnion> d(x * y) * L\"", "lemma l16:\n  \"x * top \\<sqinter> L \\<le> x * L\"", "lemma l17:\n  \"d(x) * L \\<le> d(x * L) * L\"", "lemma l18:\n  \"d(x) * L = d(x * L) * L\"", "lemma l19:\n  \"d(x * top * bot) * L \\<le> d(x * L) * L\"", "lemma l20:\n  \"x \\<le> y \\<longleftrightarrow> x \\<le> y \\<squnion> L \\<and> x \\<le> y \\<squnion> d(y * bot) * top\"", "lemma l21:\n  \"d(x * bot) * L \\<le> x * bot \\<sqinter> L\"", "lemma l22:\n  \"x * bot \\<sqinter> L = d(x * bot) * L\"", "lemma l23:\n  \"x * top \\<sqinter> L = d(x) * L\"", "lemma l29:\n  \"L * d(L) = L\"", "lemma l30:\n  \"d(L) * x \\<le> (x \\<sqinter> L) \\<squnion> d(L * bot) * x\"", "lemma l31:\n  \"d(L) * x = (x \\<sqinter> L) \\<squnion> d(L * bot) * x\"", "lemma l40:\n  \"L * x \\<le> L\"", "lemma l41:\n  \"L * top = L\"", "lemma l50:\n  \"x * bot \\<sqinter> L = (x \\<sqinter> L) * bot\"", "lemma l51:\n  \"d(x * bot) * L = (x \\<sqinter> L) * bot\"", "lemma l90:\n  \"L * top * L = L\"", "lemma l91:\n  assumes \"x = x * top\"\n    shows \"d(L * bot) * x \\<le> d(x * bot) * top\"", "lemma l92:\n  assumes \"x = x * top\"\n    shows \"d(L * bot) * x \\<le> d((x \\<sqinter> L) * bot) * top\"", "lemma mult_L_circ:\n  \"(x * L)\\<^sup>\\<circ> = 1 \\<squnion> x * L\"", "lemma mult_L_circ_mult_below:\n  \"(x * L)\\<^sup>\\<circ> * y \\<le> y \\<squnion> x * L\"", "lemma circ_L:\n  \"L\\<^sup>\\<circ> = L \\<squnion> 1\"", "lemma circ_d0_L:\n  \"x\\<^sup>\\<circ> * d(x * bot) * L = x\\<^sup>\\<circ> * bot\"", "lemma d0_circ_left_unfold:\n  \"d(x\\<^sup>\\<circ> * bot) = d(x * x\\<^sup>\\<circ> * bot)\"", "lemma d_circ_import:\n  \"d(y) * x \\<le> x * d(y) \\<Longrightarrow> d(y) * x\\<^sup>\\<circ> = d(y) * (d(y) * x)\\<^sup>\\<circ>\"", "lemma mult_L_star:\n  \"(x * L)\\<^sup>\\<star> = 1 \\<squnion> x * L\"", "lemma mult_L_omega:\n  \"(x * L)\\<^sup>\\<omega> \\<le> x * L\"", "lemma mult_L_sup_star:\n  \"(x * L \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\"", "lemma mult_L_sup_omega:\n  \"(x * L \\<squnion> y)\\<^sup>\\<omega> \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L\"", "lemma d0_star_below_d0_omega:\n  \"d(x\\<^sup>\\<star> * bot) \\<le> d(x\\<^sup>\\<omega> * bot)\"", "lemma d0_below_d0_omega:\n  \"d(x * bot) \\<le> d(x\\<^sup>\\<omega> * bot)\"", "lemma star_L_split:\n  assumes \"y \\<le> z\"\n      and \"x * z * L \\<le> x * bot \\<squnion> z * L\"\n    shows \"x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L\"", "lemma star_L_split_same:\n  \"x * y * L \\<le> x * bot \\<squnion> y * L \\<Longrightarrow> x\\<^sup>\\<star> * y * L = x\\<^sup>\\<star> * bot \\<squnion> y * L\"", "lemma star_d_L_split_equal:\n  \"d(x * y) \\<le> d(y) \\<Longrightarrow> x\\<^sup>\\<star> * d(y) * L = x\\<^sup>\\<star> * bot \\<squnion> d(y) * L\"", "lemma d0_omega_mult:\n  \"d(x\\<^sup>\\<omega> * y * bot) = d(x\\<^sup>\\<omega> * bot)\"", "lemma d_omega_export:\n  \"d(y) * x \\<le> x * d(y) \\<Longrightarrow> d(y) * x\\<^sup>\\<omega> = (d(y) * x)\\<^sup>\\<omega>\"", "lemma d_omega_import:\n  \"d(y) * x \\<le> x * d(y) \\<Longrightarrow> d(y) * x\\<^sup>\\<omega> = d(y) * (d(y) * x)\\<^sup>\\<omega>\"", "lemma star_d_omega_top:\n  \"x\\<^sup>\\<star> * d(x\\<^sup>\\<omega>) * top = x\\<^sup>\\<star> * bot \\<squnion> d(x\\<^sup>\\<omega>) * top\"", "lemma omega_meet_L:\n  \"x\\<^sup>\\<omega> \\<sqinter> L = d(x\\<^sup>\\<omega>) * L\""], "translations": [["", "lemma d_top:\n  \"d(top) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d top = (1::'a)", "by (metis sup_left_top d_dist_sup d_one d_plus_one)"], ["", "lemma mult_domain_top:\n  \"x * d(y) * top \\<le> d(x * y) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * d y * top \\<le> d (x * y) * top", "by (smt d_mult_d d_restrict_equals mult_assoc mult_right_isotone top_greatest)"], ["", "lemma domain_meet_domain:\n  \"d(x \\<sqinter> d(y) * z) \\<le> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x \\<sqinter> d y * z) \\<le> d y", "by (metis d_export d_isotone d_mult_greatest_lower_bound inf.cobounded2)"], ["", "lemma meet_domain:\n  \"x \\<sqinter> d(y) * z = d(y) * (x \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> d y * z = d y * (x \\<sqinter> z)", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<sqinter> d y * z \\<le> d y * (x \\<sqinter> z)\n 2. d y * (x \\<sqinter> z) \\<le> x \\<sqinter> d y * z", "apply (metis domain_meet_domain d_mult_below d_restrict_equals inf_mono mult_isotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d y * (x \\<sqinter> z) \\<le> x \\<sqinter> d y * z", "by (meson d_mult_below le_inf_iff mult_left_sub_dist_inf_right)"], ["", "lemma meet_intro_domain:\n  \"x \\<sqinter> y = d(y) * x \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y = d y * x \\<sqinter> y", "by (metis d_restrict_equals inf_commute meet_domain)"], ["", "lemma meet_domain_top:\n  \"x \\<sqinter> d(y) * top = d(y) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> d y * top = d y * x", "by (simp add: meet_domain)"], ["", "(*\nlemma \"d(x) = x * top \\<sqinter> 1\" nitpick [expect=genuine,card=3] oops\n*)"], ["", "lemma d_galois:\n  \"d(x) \\<le> d(y) \\<longleftrightarrow> x \\<le> d(y) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x \\<le> d y) = (x \\<le> d y * top)", "by (metis d_export d_isotone d_mult_left_absorb_sup d_plus_one d_restrict_equals d_top mult_isotone top.extremum)"], ["", "lemma vector_meet:\n  \"x * top \\<sqinter> y \\<le> d(x) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter> y \\<le> d x * y", "by (metis d_galois d_mult_sub inf.sup_monoid.add_commute inf.sup_right_isotone meet_domain_top)"], ["", "end"], ["", "class domain_semiring_lattice_L = domain_semiring_lattice + L +\n  assumes l1: \"x * L = x * bot \\<squnion> d(x) * L\"\n  assumes l2: \"d(L) * x \\<le> x * d(L)\"\n  assumes l3: \"d(L) * top \\<le> L \\<squnion> d(L * bot) * top\"\n  assumes l4: \"L * top \\<le> L\"\n  assumes l5: \"x * bot \\<sqinter> L \\<le> (x \\<sqinter> L) * bot\"\nbegin"], ["", "lemma l8:\n  \"(x \\<sqinter> L) * bot \\<le> x * bot \\<sqinter> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> L) * bot \\<le> x * bot \\<sqinter> L", "by (meson inf.boundedE inf.boundedI mult_right_sub_dist_inf_left zero_right_mult_decreasing)"], ["", "lemma l9:\n  \"x * bot \\<sqinter> L \\<le> d(x * bot) * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> L \\<le> d (x * bot) * L", "by (metis vector_meet vector_mult_closed zero_vector)"], ["", "lemma l10:\n  \"L * L = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent L", "by (metis d_restrict_equals l1 le_iff_sup zero_right_mult_decreasing)"], ["", "lemma l11:\n  \"d(x) * L \\<le> x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * L \\<le> x * L", "by (metis l1 sup.cobounded2)"], ["", "lemma l12:\n  \"d(x * bot) * L \\<le> x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x * bot) * L \\<le> x * bot", "by (metis sup_right_divisibility l1 mult_assoc mult_left_zero)"], ["", "lemma l13:\n  \"d(x * bot) * L \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x * bot) * L \\<le> x", "using l12 order_trans zero_right_mult_decreasing"], ["proof (prove)\nusing this:\n  d (?x * bot) * L \\<le> ?x * bot\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?x * bot \\<le> ?x\n\ngoal (1 subgoal):\n 1. d (x * bot) * L \\<le> x", "by blast"], ["", "lemma l14:\n  \"x * L \\<le> x * bot \\<squnion> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * L \\<le> x * bot \\<squnion> L", "by (metis d_mult_below l1 sup_right_isotone)"], ["", "lemma l15:\n  \"x * d(y) * L = x * bot \\<squnion> d(x * y) * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * d y * L = x * bot \\<squnion> d (x * y) * L", "by (metis d_commutative d_mult_d d_zero l1 mult_assoc mult_left_zero)"], ["", "lemma l16:\n  \"x * top \\<sqinter> L \\<le> x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter> L \\<le> x * L", "using inf.order_lesseq_imp l11 vector_meet"], ["proof (prove)\nusing this:\n  (\\<forall>z\\<le>?x. z \\<le> ?y) = (?x \\<le> ?y)\n  d ?x * L \\<le> ?x * L\n  ?x * top \\<sqinter> ?y \\<le> d ?x * ?y\n\ngoal (1 subgoal):\n 1. x * top \\<sqinter> L \\<le> x * L", "by blast"], ["", "lemma l17:\n  \"d(x) * L \\<le> d(x * L) * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * L \\<le> d (x * L) * L", "by (metis d_mult_below l11 le_infE le_infI meet_intro_domain)"], ["", "lemma l18:\n  \"d(x) * L = d(x * L) * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * L = d (x * L) * L", "by (simp add: order.antisym d_mult_sub l17 mult_left_isotone)"], ["", "lemma l19:\n  \"d(x * top * bot) * L \\<le> d(x * L) * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x * top * bot) * L \\<le> d (x * L) * L", "by (metis d_mult_sub l18 mult_assoc mult_left_isotone)"], ["", "lemma l20:\n  \"x \\<le> y \\<longleftrightarrow> x \\<le> y \\<squnion> L \\<and> x \\<le> y \\<squnion> d(y * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) =\n    (x \\<le> y \\<squnion> L \\<and> x \\<le> y \\<squnion> d (y * bot) * top)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    x \\<le> y \\<squnion> L \\<and> x \\<le> y \\<squnion> d (y * bot) * top\n 2. x \\<le> y \\<squnion> L \\<and>\n    x \\<le> y \\<squnion> d (y * bot) * top \\<Longrightarrow>\n    x \\<le> y", "apply (simp add: le_supI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> L \\<and>\n    x \\<le> y \\<squnion> d (y * bot) * top \\<Longrightarrow>\n    x \\<le> y", "by (smt sup_commute sup_inf_distrib1 l13 le_iff_sup meet_domain_top)"], ["", "lemma l21:\n  \"d(x * bot) * L \\<le> x * bot \\<sqinter> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x * bot) * L \\<le> x * bot \\<sqinter> L", "by (simp add: d_mult_below l12)"], ["", "lemma l22:\n  \"x * bot \\<sqinter> L = d(x * bot) * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> L = d (x * bot) * L", "using l21 order.antisym l9"], ["proof (prove)\nusing this:\n  d (?x * bot) * L \\<le> ?x * bot \\<sqinter> L\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  ?x * bot \\<sqinter> L \\<le> d (?x * bot) * L\n\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> L = d (x * bot) * L", "by auto"], ["", "lemma l23:\n  \"x * top \\<sqinter> L = d(x) * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter> L = d x * L", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * top \\<sqinter> L \\<le> d x * L\n 2. d x * L \\<le> x * top \\<sqinter> L", "apply (simp add: vector_meet)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * L \\<le> x * top \\<sqinter> L", "by (metis d_mult_below inf.le_sup_iff inf_top.left_neutral l1 le_supE mult_left_sub_dist_inf_left)"], ["", "lemma l29:\n  \"L * d(L) = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L * d L = L", "by (metis d_preserves_equation d_restrict_equals l2)"], ["", "lemma l30:\n  \"d(L) * x \\<le> (x \\<sqinter> L) \\<squnion> d(L * bot) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * x \\<le> x \\<sqinter> L \\<squnion> d (L * bot) * x", "by (metis inf.sup_right_divisibility inf_left_commute inf_sup_distrib1 l3 meet_domain_top)"], ["", "lemma l31:\n  \"d(L) * x = (x \\<sqinter> L) \\<squnion> d(L * bot) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * x = x \\<sqinter> L \\<squnion> d (L * bot) * x", "by (smt (z3) l30 d_dist_sup le_iff_sup meet_intro_domain semiring.combine_common_factor sup_commute sup_inf_absorb zero_right_mult_decreasing)"], ["", "lemma l40:\n  \"L * x \\<le> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L * x \\<le> L", "by (meson bot_least inf.order_trans l4 semiring.mult_left_mono top.extremum)"], ["", "lemma l41:\n  \"L * top = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector L", "by (simp add: l40 order.antisym top_right_mult_increasing)"], ["", "lemma l50:\n  \"x * bot \\<sqinter> L = (x \\<sqinter> L) * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> L = (x \\<sqinter> L) * bot", "using order.antisym l5 l8"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  ?x * bot \\<sqinter> L \\<le> (?x \\<sqinter> L) * bot\n  (?x \\<sqinter> L) * bot \\<le> ?x * bot \\<sqinter> L\n\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> L = (x \\<sqinter> L) * bot", "by force"], ["", "lemma l51:\n  \"d(x * bot) * L = (x \\<sqinter> L) * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x * bot) * L = (x \\<sqinter> L) * bot", "using l22 l50"], ["proof (prove)\nusing this:\n  ?x * bot \\<sqinter> L = d (?x * bot) * L\n  ?x * bot \\<sqinter> L = (?x \\<sqinter> L) * bot\n\ngoal (1 subgoal):\n 1. d (x * bot) * L = (x \\<sqinter> L) * bot", "by auto"], ["", "lemma l90:\n  \"L * top * L = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L * top * L = L", "by (simp add: l41 l10)"], ["", "lemma l91:\n  assumes \"x = x * top\"\n    shows \"d(L * bot) * x \\<le> d(x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "have \"d(L * bot) * x \\<le> d(d(L * bot) * x) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (d (L * bot) * x) * top", "using d_galois"], ["proof (prove)\nusing this:\n  (d ?x \\<le> d ?y) = (?x \\<le> d ?y * top)\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (d (L * bot) * x) * top", "by blast"], ["proof (state)\nthis:\n  d (L * bot) * x \\<le> d (d (L * bot) * x) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "also"], ["proof (state)\nthis:\n  d (L * bot) * x \\<le> d (d (L * bot) * x) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "have \"... = d(d(L * bot) * d(x)) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d (L * bot) * x) * top = d (d (L * bot) * d x) * top", "using d_mult_d"], ["proof (prove)\nusing this:\n  d (?x * ?y) = d (?x * d ?y)\n\ngoal (1 subgoal):\n 1. d (d (L * bot) * x) * top = d (d (L * bot) * d x) * top", "by auto"], ["proof (state)\nthis:\n  d (d (L * bot) * x) * top = d (d (L * bot) * d x) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "also"], ["proof (state)\nthis:\n  d (d (L * bot) * x) * top = d (d (L * bot) * d x) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "have \"... = d(d(x) * L * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d (L * bot) * d x) * top = d (d x * L * bot) * top", "using d_commutative d_mult_d ils.il_inf_associative"], ["proof (prove)\nusing this:\n  d ?x * d ?y = d ?y * d ?x\n  d (?x * ?y) = d (?x * d ?y)\n  ?x * (?y * ?z) = ?x * ?y * ?z\n\ngoal (1 subgoal):\n 1. d (d (L * bot) * d x) * top = d (d x * L * bot) * top", "by auto"], ["proof (state)\nthis:\n  d (d (L * bot) * d x) * top = d (d x * L * bot) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "also"], ["proof (state)\nthis:\n  d (d (L * bot) * d x) * top = d (d x * L * bot) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "have \"... \\<le> d(x * L * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d x * L * bot) * top \\<le> d (x * L * bot) * top", "by (metis d_isotone l11 mult_left_isotone)"], ["proof (state)\nthis:\n  d (d x * L * bot) * top \\<le> d (x * L * bot) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "also"], ["proof (state)\nthis:\n  d (d x * L * bot) * top \\<le> d (x * L * bot) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "have \"... \\<le> d(x * top * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x * L * bot) * top \\<le> d (x * top * bot) * top", "by (simp add: d_isotone mult_left_isotone mult_right_isotone)"], ["proof (state)\nthis:\n  d (x * L * bot) * top \\<le> d (x * top * bot) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "finally"], ["proof (chain)\npicking this:\n  d (L * bot) * x \\<le> d (x * top * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d (L * bot) * x \\<le> d (x * top * bot) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "using assms"], ["proof (prove)\nusing this:\n  d (L * bot) * x \\<le> d (x * top * bot) * top\n  x = x * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d (x * bot) * top", "by auto"], ["proof (state)\nthis:\n  d (L * bot) * x \\<le> d (x * bot) * top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l92:\n  assumes \"x = x * top\"\n    shows \"d(L * bot) * x \\<le> d((x \\<sqinter> L) * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "have \"d(L * bot) * x = d(L) * d(L * bot) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (L * bot) * x = d L * d (L * bot) * x", "using d_commutative d_mult_sub d_order"], ["proof (prove)\nusing this:\n  d ?x * d ?y = d ?y * d ?x\n  d (?x * ?y) \\<le> d ?x\n  (d ?x \\<le> d ?y) = (d ?x = d ?x * d ?y)\n\ngoal (1 subgoal):\n 1. d (L * bot) * x = d L * d (L * bot) * x", "by auto"], ["proof (state)\nthis:\n  d (L * bot) * x = d L * d (L * bot) * x\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "also"], ["proof (state)\nthis:\n  d (L * bot) * x = d L * d (L * bot) * x\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "have \"... \\<le> d(L) * d(x * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * d (L * bot) * x \\<le> d L * d (x * bot) * top", "by (metis assms order.eq_iff l91 mult_assoc mult_isotone)"], ["proof (state)\nthis:\n  d L * d (L * bot) * x \\<le> d L * d (x * bot) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "also"], ["proof (state)\nthis:\n  d L * d (L * bot) * x \\<le> d L * d (x * bot) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "have \"... = d(d(x * bot) * L) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d L * d (x * bot) * top = d (d (x * bot) * L) * top", "by (simp add: d_commutative d_export)"], ["proof (state)\nthis:\n  d L * d (x * bot) * top = d (d (x * bot) * L) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "also"], ["proof (state)\nthis:\n  d L * d (x * bot) * top = d (d (x * bot) * L) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "have \"... \\<le> d((x \\<sqinter> L) * bot) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d (x * bot) * L) * top \\<le> d ((x \\<sqinter> L) * bot) * top", "by (simp add: l51)"], ["proof (state)\nthis:\n  d (d (x * bot) * L) * top \\<le> d ((x \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "finally"], ["proof (chain)\npicking this:\n  d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top\n\ngoal (1 subgoal):\n 1. d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top", "."], ["proof (state)\nthis:\n  d (L * bot) * x \\<le> d ((x \\<sqinter> L) * bot) * top\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class domain_itering_lattice_L = bounded_itering + domain_semiring_lattice_L\nbegin"], ["", "lemma mult_L_circ:\n  \"(x * L)\\<^sup>\\<circ> = 1 \\<squnion> x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * L)\\<^sup>\\<circ> = Rf x L", "by (metis circ_back_loop_fixpoint circ_mult l40 le_iff_sup mult_assoc)"], ["", "lemma mult_L_circ_mult_below:\n  \"(x * L)\\<^sup>\\<circ> * y \\<le> y \\<squnion> x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * L)\\<^sup>\\<circ> * y \\<le> y \\<squnion> x * L", "by (smt sup_right_isotone l40 mult_L_circ mult_assoc mult_left_one mult_right_dist_sup mult_right_isotone)"], ["", "lemma circ_L:\n  \"L\\<^sup>\\<circ> = L \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L\\<^sup>\\<circ> = L \\<squnion> (1::'a)", "by (metis sup_commute l10 mult_L_circ)"], ["", "lemma circ_d0_L:\n  \"x\\<^sup>\\<circ> * d(x * bot) * L = x\\<^sup>\\<circ> * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> * d (x * bot) * L = x\\<^sup>\\<circ> * bot", "by (metis sup_bot_right circ_loop_fixpoint circ_plus_same d_zero l15 mult_assoc mult_left_zero)"], ["", "lemma d0_circ_left_unfold:\n  \"d(x\\<^sup>\\<circ> * bot) = d(x * x\\<^sup>\\<circ> * bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x\\<^sup>\\<circ> * bot) = d (x * x\\<^sup>\\<circ> * bot)", "by (metis sup_commute sup_bot_left circ_loop_fixpoint mult_assoc)"], ["", "lemma d_circ_import:\n  \"d(y) * x \\<le> x * d(y) \\<Longrightarrow> d(y) * x\\<^sup>\\<circ> = d(y) * (d(y) * x)\\<^sup>\\<circ>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d y * x \\<le> x * d y \\<Longrightarrow>\n    d y * x\\<^sup>\\<circ> = d y * (d y * x)\\<^sup>\\<circ>", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d y * x \\<le> x * d y \\<Longrightarrow>\n    d y * x\\<^sup>\\<circ> \\<le> d y * (d y * x)\\<^sup>\\<circ>\n 2. d y * x \\<le> x * d y \\<Longrightarrow>\n    d y * (d y * x)\\<^sup>\\<circ> \\<le> d y * x\\<^sup>\\<circ>", "apply (simp add: circ_import d_idempotent d_plus_one le_iff_sup)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d y * x \\<le> x * d y \\<Longrightarrow>\n    d y * (d y * x)\\<^sup>\\<circ> \\<le> d y * x\\<^sup>\\<circ>", "using circ_isotone d_mult_below mult_right_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<circ> \\<le> ?y\\<^sup>\\<circ>\n  d ?x * ?y \\<le> ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (1 subgoal):\n 1. d y * x \\<le> x * d y \\<Longrightarrow>\n    d y * (d y * x)\\<^sup>\\<circ> \\<le> d y * x\\<^sup>\\<circ>", "by auto"], ["", "end"], ["", "class domain_omega_algebra_lattice_L = bounded_left_zero_omega_algebra + domain_semiring_lattice_L\nbegin"], ["", "lemma mult_L_star:\n  \"(x * L)\\<^sup>\\<star> = 1 \\<squnion> x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * L)\\<^sup>\\<star> = Rf x L", "by (metis l40 le_iff_sup mult_assoc star.circ_back_loop_fixpoint star.circ_mult)"], ["", "lemma mult_L_omega:\n  \"(x * L)\\<^sup>\\<omega> \\<le> x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * L)\\<^sup>\\<omega> \\<le> x * L", "by (metis l40 mult_right_isotone omega_slide)"], ["", "lemma mult_L_sup_star:\n  \"(x * L \\<squnion> y)\\<^sup>\\<star> = y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star> =\n    y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L", "proof (rule order.antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "have \"(x * L \\<squnion> y) * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) = x * L * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) \\<squnion> y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * L \\<squnion> y) *\n    (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) =\n    x * L * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) \\<squnion>\n    y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)", "by (simp add: mult_right_dist_sup)"], ["proof (state)\nthis:\n  (x * L \\<squnion> y) *\n  (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) =\n  x * L * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) \\<squnion>\n  y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  (x * L \\<squnion> y) *\n  (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) =\n  x * L * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) \\<squnion>\n  y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "have \"... \\<le> x * L \\<squnion> y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * L * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) \\<squnion>\n    y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n    \\<le> x * L \\<squnion>\n          y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)", "by (metis sup_left_isotone l40 mult_assoc mult_right_isotone)"], ["proof (state)\nthis:\n  x * L * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) \\<squnion>\n  y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n  \\<le> x * L \\<squnion>\n        y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x * L * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) \\<squnion>\n  y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n  \\<le> x * L \\<squnion>\n        y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "have \"... \\<le> x * L \\<squnion> y * y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * L \\<squnion>\n    y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n    \\<le> x * L \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>\\<star> * x * L", "by (smt sup_assoc sup_commute sup_ge2 mult_assoc mult_left_dist_sup star.circ_loop_fixpoint)"], ["proof (state)\nthis:\n  x * L \\<squnion> y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n  \\<le> x * L \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x * L \\<squnion> y * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n  \\<le> x * L \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "have \"... \\<le> x * L \\<squnion> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * L \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> x * L \\<squnion> y\\<^sup>\\<star> \\<squnion>\n          y\\<^sup>\\<star> * x * L", "by (meson order_refl star.left_plus_below_circ sup_mono)"], ["proof (state)\nthis:\n  x * L \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>\\<star> * x * L\n  \\<le> x * L \\<squnion> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "also"], ["proof (state)\nthis:\n  x * L \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>\\<star> * x * L\n  \\<le> x * L \\<squnion> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "have \"... = y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * L \\<squnion> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L =\n    y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L", "by (metis sup_assoc sup_commute mult_assoc star.circ_loop_fixpoint star.circ_reflexive star.circ_sup_one_right_unfold star_involutive)"], ["proof (state)\nthis:\n  x * L \\<squnion> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L =\n  y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "finally"], ["proof (chain)\npicking this:\n  (x * L \\<squnion> y) *\n  (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n  \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L", "have \"1 \\<squnion> (x * L \\<squnion> y) * (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L) \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\""], ["proof (prove)\nusing this:\n  (x * L \\<squnion> y) *\n  (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n  \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (1 subgoal):\n 1. Rf (x * L \\<squnion> y)\n     (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L", "by (meson le_supI le_supI1 star.circ_reflexive)"], ["proof (state)\nthis:\n  Rf (x * L \\<squnion> y)\n   (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n  \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (2 subgoals):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n 2. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "thus \"(x * L \\<squnion> y)\\<^sup>\\<star> \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\""], ["proof (prove)\nusing this:\n  Rf (x * L \\<squnion> y)\n   (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n  \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (1 subgoal):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L", "using star_left_induct"], ["proof (prove)\nusing this:\n  Rf (x * L \\<squnion> y)\n   (y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L)\n  \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n  ?z \\<squnion> ?y * ?x \\<le> ?x \\<longrightarrow>\n  ?y\\<^sup>\\<star> * ?z \\<le> ?x\n\ngoal (1 subgoal):\n 1. (x * L \\<squnion> y)\\<^sup>\\<star>\n    \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L", "by fastforce"], ["proof (state)\nthis:\n  (x * L \\<squnion> y)\\<^sup>\\<star>\n  \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "show \"y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n    \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>", "by (metis sup_commute le_sup_iff mult_assoc star.circ_increasing star.circ_mult_upper_bound star.circ_sub_dist)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star> * x * L\n  \\<le> (x * L \\<squnion> y)\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_L_sup_omega:\n  \"(x * L \\<squnion> y)\\<^sup>\\<omega> \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * L \\<squnion> y)\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x * L \\<squnion> y)\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L", "have 1: \"(y\\<^sup>\\<star> * x * L)\\<^sup>\\<omega> \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>\\<star> * x * L)\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L", "by (simp add: le_supI2 mult_L_omega)"], ["proof (state)\nthis:\n  (y\\<^sup>\\<star> * x * L)\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (1 subgoal):\n 1. (x * L \\<squnion> y)\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L", "have \"(y\\<^sup>\\<star> * x * L)\\<^sup>\\<star> * y\\<^sup>\\<omega> \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>\\<star> * x * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L", "by (metis sup_right_isotone l40 mult_assoc mult_right_isotone star_left_induct)"], ["proof (state)\nthis:\n  (y\\<^sup>\\<star> * x * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (1 subgoal):\n 1. (x * L \\<squnion> y)\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L", "thus ?thesis"], ["proof (prove)\nusing this:\n  (y\\<^sup>\\<star> * x * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (1 subgoal):\n 1. (x * L \\<squnion> y)\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L", "using 1"], ["proof (prove)\nusing this:\n  (y\\<^sup>\\<star> * x * L)\\<^sup>\\<star> * y\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L\n  (y\\<^sup>\\<star> * x * L)\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal (1 subgoal):\n 1. (x * L \\<squnion> y)\\<^sup>\\<omega>\n    \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L", "by (simp add: ils.il_inf_associative omega_decompose sup_monoid.add_commute)"], ["proof (state)\nthis:\n  (x * L \\<squnion> y)\\<^sup>\\<omega>\n  \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * x * L\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale domain_omega_algebra_lattice_L < dL_star: itering where circ = star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.itering star (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", ".."], ["", "sublocale domain_omega_algebra_lattice_L < dL_star: domain_itering_lattice_L where circ = star"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.domain_itering_lattice_L (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot\n     d (\\<sqinter>) top L star", ".."], ["", "context domain_omega_algebra_lattice_L\nbegin"], ["", "lemma d0_star_below_d0_omega:\n  \"d(x\\<^sup>\\<star> * bot) \\<le> d(x\\<^sup>\\<omega> * bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x\\<^sup>\\<star> * bot) \\<le> d (x\\<^sup>\\<omega> * bot)", "by (simp add: d_isotone star_bot_below_omega_bot)"], ["", "lemma d0_below_d0_omega:\n  \"d(x * bot) \\<le> d(x\\<^sup>\\<omega> * bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x * bot) \\<le> d (x\\<^sup>\\<omega> * bot)", "by (metis d0_star_below_d0_omega d_isotone mult_left_isotone order_trans star.circ_increasing)"], ["", "lemma star_L_split:\n  assumes \"y \\<le> z\"\n      and \"x * z * L \\<le> x * bot \\<squnion> z * L\"\n    shows \"x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "have \"x * (x\\<^sup>\\<star> * bot \\<squnion> z * L) \\<le> x\\<^sup>\\<star> * bot \\<squnion> x * z * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (x\\<^sup>\\<star> * bot \\<squnion> z * L)\n    \\<le> x\\<^sup>\\<star> * bot \\<squnion> x * z * L", "by (metis sup_bot_right order.eq_iff mult_assoc mult_left_dist_sup star.circ_loop_fixpoint)"], ["proof (state)\nthis:\n  x * (x\\<^sup>\\<star> * bot \\<squnion> z * L)\n  \\<le> x\\<^sup>\\<star> * bot \\<squnion> x * z * L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "also"], ["proof (state)\nthis:\n  x * (x\\<^sup>\\<star> * bot \\<squnion> z * L)\n  \\<le> x\\<^sup>\\<star> * bot \\<squnion> x * z * L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "have \"... \\<le> x\\<^sup>\\<star> * bot \\<squnion> x * bot \\<squnion> z * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * bot \\<squnion> x * z * L\n    \\<le> x\\<^sup>\\<star> * bot \\<squnion> x * bot \\<squnion> z * L", "using assms(2) semiring.add_left_mono sup_monoid.add_assoc"], ["proof (prove)\nusing this:\n  x * z * L \\<le> x * bot \\<squnion> z * L\n  ?a \\<le> ?b \\<Longrightarrow> ?c \\<squnion> ?a \\<le> ?c \\<squnion> ?b\n  ?a \\<squnion> ?b \\<squnion> ?c = ?a \\<squnion> (?b \\<squnion> ?c)\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * bot \\<squnion> x * z * L\n    \\<le> x\\<^sup>\\<star> * bot \\<squnion> x * bot \\<squnion> z * L", "by auto"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * bot \\<squnion> x * z * L\n  \\<le> x\\<^sup>\\<star> * bot \\<squnion> x * bot \\<squnion> z * L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * bot \\<squnion> x * z * L\n  \\<le> x\\<^sup>\\<star> * bot \\<squnion> x * bot \\<squnion> z * L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "have \"... = x\\<^sup>\\<star> * bot \\<squnion> z * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * bot \\<squnion> x * bot \\<squnion> z * L =\n    x\\<^sup>\\<star> * bot \\<squnion> z * L", "using mult_isotone star.circ_increasing sup.absorb_iff1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w * ?x \\<le> ?y * ?z\n  ?x \\<le> ?x\\<^sup>\\<star>\n  (?b \\<le> ?a) = (?a \\<squnion> ?b = ?a)\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * bot \\<squnion> x * bot \\<squnion> z * L =\n    x\\<^sup>\\<star> * bot \\<squnion> z * L", "by force"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * bot \\<squnion> x * bot \\<squnion> z * L =\n  x\\<^sup>\\<star> * bot \\<squnion> z * L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "finally"], ["proof (chain)\npicking this:\n  x * (x\\<^sup>\\<star> * bot \\<squnion> z * L)\n  \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "have \"y * L \\<squnion> x * (x\\<^sup>\\<star> * bot \\<squnion> z * L) \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L\""], ["proof (prove)\nusing this:\n  x * (x\\<^sup>\\<star> * bot \\<squnion> z * L)\n  \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L\n\ngoal (1 subgoal):\n 1. y * L \\<squnion> x * (x\\<^sup>\\<star> * bot \\<squnion> z * L)\n    \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "by (simp add: assms(1) le_supI1 mult_left_isotone sup_monoid.add_commute)"], ["proof (state)\nthis:\n  y * L \\<squnion> x * (x\\<^sup>\\<star> * bot \\<squnion> z * L)\n  \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "thus ?thesis"], ["proof (prove)\nusing this:\n  y * L \\<squnion> x * (x\\<^sup>\\<star> * bot \\<squnion> z * L)\n  \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L", "by (simp add: star_left_induct mult.assoc)"], ["proof (state)\nthis:\n  x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> z * L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma star_L_split_same:\n  \"x * y * L \\<le> x * bot \\<squnion> y * L \\<Longrightarrow> x\\<^sup>\\<star> * y * L = x\\<^sup>\\<star> * bot \\<squnion> y * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * L \\<le> x * bot \\<squnion> y * L \\<Longrightarrow>\n    x\\<^sup>\\<star> * y * L = x\\<^sup>\\<star> * bot \\<squnion> y * L", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * y * L \\<le> x * bot \\<squnion> y * L \\<Longrightarrow>\n    x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> y * L\n 2. x * y * L \\<le> x * bot \\<squnion> y * L \\<Longrightarrow>\n    x\\<^sup>\\<star> * bot \\<squnion> y * L \\<le> x\\<^sup>\\<star> * y * L", "using star_L_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<le> ?z;\n   ?x * ?z * L \\<le> ?x * bot \\<squnion> ?z * L\\<rbrakk>\n  \\<Longrightarrow> ?x\\<^sup>\\<star> * ?y * L\n                    \\<le> ?x\\<^sup>\\<star> * bot \\<squnion> ?z * L\n\ngoal (2 subgoals):\n 1. x * y * L \\<le> x * bot \\<squnion> y * L \\<Longrightarrow>\n    x\\<^sup>\\<star> * y * L \\<le> x\\<^sup>\\<star> * bot \\<squnion> y * L\n 2. x * y * L \\<le> x * bot \\<squnion> y * L \\<Longrightarrow>\n    x\\<^sup>\\<star> * bot \\<squnion> y * L \\<le> x\\<^sup>\\<star> * y * L", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * L \\<le> x * bot \\<squnion> y * L \\<Longrightarrow>\n    x\\<^sup>\\<star> * bot \\<squnion> y * L \\<le> x\\<^sup>\\<star> * y * L", "by (metis bot_least ils.il_inf_associative le_supI mult_isotone mult_left_one order_refl star.circ_reflexive)"], ["", "lemma star_d_L_split_equal:\n  \"d(x * y) \\<le> d(y) \\<Longrightarrow> x\\<^sup>\\<star> * d(y) * L = x\\<^sup>\\<star> * bot \\<squnion> d(y) * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x * y) \\<le> d y \\<Longrightarrow>\n    x\\<^sup>\\<star> * d y * L = x\\<^sup>\\<star> * bot \\<squnion> d y * L", "by (metis sup_right_isotone l15 le_iff_sup mult_right_sub_dist_sup_left star_L_split_same)"], ["", "lemma d0_omega_mult:\n  \"d(x\\<^sup>\\<omega> * y * bot) = d(x\\<^sup>\\<omega> * bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x\\<^sup>\\<omega> * y * bot) = d (x\\<^sup>\\<omega> * bot)", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d (x\\<^sup>\\<omega> * y * bot) \\<le> d (x\\<^sup>\\<omega> * bot)\n 2. d (x\\<^sup>\\<omega> * bot) \\<le> d (x\\<^sup>\\<omega> * y * bot)", "apply (simp add: d_isotone mult_isotone omega_sub_vector)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x\\<^sup>\\<omega> * bot) \\<le> d (x\\<^sup>\\<omega> * y * bot)", "by (metis d_isotone mult_assoc mult_right_isotone bot_least)"], ["", "lemma d_omega_export:\n  \"d(y) * x \\<le> x * d(y) \\<Longrightarrow> d(y) * x\\<^sup>\\<omega> = (d(y) * x)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d y * x \\<le> x * d y \\<Longrightarrow>\n    d y * x\\<^sup>\\<omega> = (d y * x)\\<^sup>\\<omega>", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d y * x \\<le> x * d y \\<Longrightarrow>\n    d y * x\\<^sup>\\<omega> \\<le> (d y * x)\\<^sup>\\<omega>\n 2. d y * x \\<le> x * d y \\<Longrightarrow>\n    (d y * x)\\<^sup>\\<omega> \\<le> d y * x\\<^sup>\\<omega>", "apply (simp add: d_preserves_equation omega_simulation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d y * x \\<le> x * d y \\<Longrightarrow>\n    (d y * x)\\<^sup>\\<omega> \\<le> d y * x\\<^sup>\\<omega>", "by (smt le_iff_sup mult_left_dist_sup omega_simulation_2 omega_slide)"], ["", "lemma d_omega_import:\n  \"d(y) * x \\<le> x * d(y) \\<Longrightarrow> d(y) * x\\<^sup>\\<omega> = d(y) * (d(y) * x)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d y * x \\<le> x * d y \\<Longrightarrow>\n    d y * x\\<^sup>\\<omega> = d y * (d y * x)\\<^sup>\\<omega>", "using d_idempotent omega_import order.refl"], ["proof (prove)\nusing this:\n  idempotent (d ?x)\n  \\<lbrakk>dense_rel ?p; ?p * ?x \\<le> ?x * ?p\\<rbrakk>\n  \\<Longrightarrow> ?p * ?x\\<^sup>\\<omega> = ?p * (?p * ?x)\\<^sup>\\<omega>\n  ?a \\<le> ?a\n\ngoal (1 subgoal):\n 1. d y * x \\<le> x * d y \\<Longrightarrow>\n    d y * x\\<^sup>\\<omega> = d y * (d y * x)\\<^sup>\\<omega>", "by auto"], ["", "lemma star_d_omega_top:\n  \"x\\<^sup>\\<star> * d(x\\<^sup>\\<omega>) * top = x\\<^sup>\\<star> * bot \\<squnion> d(x\\<^sup>\\<omega>) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * d (x\\<^sup>\\<omega>) * top =\n    x\\<^sup>\\<star> * bot \\<squnion> d (x\\<^sup>\\<omega>) * top", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x\\<^sup>\\<star> * d (x\\<^sup>\\<omega>) * top\n    \\<le> x\\<^sup>\\<star> * bot \\<squnion> d (x\\<^sup>\\<omega>) * top\n 2. x\\<^sup>\\<star> * bot \\<squnion> d (x\\<^sup>\\<omega>) * top\n    \\<le> x\\<^sup>\\<star> * d (x\\<^sup>\\<omega>) * top", "apply (metis le_supI2 mult_domain_top star_mult_omega)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> * bot \\<squnion> d (x\\<^sup>\\<omega>) * top\n    \\<le> x\\<^sup>\\<star> * d (x\\<^sup>\\<omega>) * top", "by (metis ils.il_inf_associative le_supI mult_left_one mult_left_sub_dist_sup_right mult_right_sub_dist_sup_left star.circ_right_unfold_1 sup_monoid.add_0_right)"], ["", "lemma omega_meet_L:\n  \"x\\<^sup>\\<omega> \\<sqinter> L = d(x\\<^sup>\\<omega>) * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> \\<sqinter> L = d (x\\<^sup>\\<omega>) * L", "by (metis l23 omega_vector)"], ["", "(*\nlemma d_star_mult: \"d(x * y) \\<le> d(y) \\<Longrightarrow> d(x\\<^sup>\\<star> * y) = d(x\\<^sup>\\<star> * bot) \\<squnion> d(y)\" oops\nlemma d0_split_omega_omega: \"x\\<^sup>\\<omega> \\<le> x\\<^sup>\\<omega> * bot \\<squnion> d(x\\<^sup>\\<omega> \\<sqinter> L) * top\" nitpick [expect=genuine,card=2] oops\n*)"], ["", "end"], ["", "end"]]}