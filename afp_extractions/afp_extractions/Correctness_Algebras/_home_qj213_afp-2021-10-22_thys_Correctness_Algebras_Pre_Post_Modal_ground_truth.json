{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Pre_Post_Modal.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma nat_test_pre_post:\n  \"nat_test t s \\<Longrightarrow> -q \\<le> s \\<Longrightarrow> (\\<forall>n . x \\<le> t n*-p*-q\\<stileturn>(pSum t n*-q)) \\<Longrightarrow> -p\\<star>x \\<le> -q\\<stileturn>--p*-q\"", "lemma nat_test_pre_post_2:\n  \"nat_test t s \\<Longrightarrow> -r \\<le> s \\<Longrightarrow> (\\<forall>n . x \\<le> t n*-p\\<stileturn>(pSum t n)) \\<Longrightarrow> -p\\<star>x \\<le> -r\\<stileturn>1\"", "lemma pre_post_while:\n  \"x \\<le> -p*-q\\<stileturn>-q \\<longrightarrow> -p\\<star>x \\<le> aL*-q\\<stileturn>-q\"", "lemma while_soundness_3:\n  \"test_seq t \\<Longrightarrow> -q \\<le> Sum t \\<Longrightarrow> x \\<le> t 0*-p*-q\\<stileturn>aL*-q \\<Longrightarrow> (\\<forall>n>0 . x \\<le> t n*-p*-q\\<stileturn>pSum t n*-q) \\<Longrightarrow> -p\\<star>x \\<le> -q\\<stileturn>--p*-q\"", "lemma while_soundness_4:\n  \"test_seq t \\<Longrightarrow> -r \\<le> Sum t \\<Longrightarrow> (\\<forall>n . x \\<le> t n*-p\\<stileturn>pSum t n) \\<Longrightarrow> -p\\<star>x \\<le> -r\\<stileturn>1\"", "lemma pre_post_while_pc:\n  \"x \\<le> -p*-q\\<stileturn>-q \\<longrightarrow> -p\\<star>x \\<le> -q\\<stileturn>--p*-q\"", "lemma pre_post_one_one_top:\n  \"1\\<stileturn>1 = top\"", "lemma pre_post_def_iff:\n  \"-p * x * --q \\<le> Z \\<longleftrightarrow> x \\<le> Z \\<squnion> --p * top \\<squnion> H * -q\"", "lemma pre_post_def:\n  \"-p\\<stileturn>-q = Z \\<squnion> --p*top \\<squnion> H*-q\"", "lemma body_abort_loop:\n  assumes \"Z = L\"\n      and \"x \\<le> -p\\<stileturn>1\"\n    shows \"-p\\<star>x \\<le> 1\\<stileturn>1\""], "translations": [["", "lemma nat_test_pre_post:\n  \"nat_test t s \\<Longrightarrow> -q \\<le> s \\<Longrightarrow> (\\<forall>n . x \\<le> t n*-p*-q\\<stileturn>(pSum t n*-q)) \\<Longrightarrow> -p\\<star>x \\<le> -q\\<stileturn>--p*-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nat_test t s; - q \\<le> s;\n     \\<forall>n.\n        x \\<le> t n * - p * - q \\<stileturn> pSum t n * - q\\<rbrakk>\n    \\<Longrightarrow> - p \\<star> x \\<le> - q \\<stileturn> - - p * - q", "by (smt (verit, ccfv_threshold) nat_test_def nat_test_pre pSum_test_nat pre_post_galois tests_dual.sub_sup_closed)"], ["", "lemma nat_test_pre_post_2:\n  \"nat_test t s \\<Longrightarrow> -r \\<le> s \\<Longrightarrow> (\\<forall>n . x \\<le> t n*-p\\<stileturn>(pSum t n)) \\<Longrightarrow> -p\\<star>x \\<le> -r\\<stileturn>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nat_test t s; - r \\<le> s;\n     \\<forall>n. x \\<le> t n * - p \\<stileturn> pSum t n\\<rbrakk>\n    \\<Longrightarrow> - p \\<star> x \\<le> - r \\<stileturn> (1::'a)", "by (smt (verit, ccfv_threshold) nat_test_def nat_test_pre_2 one_def pSum_test_nat pre_post_galois tests_dual.sub_sup_closed)"], ["", "end"], ["", "class pre_post_spec_hoare = pre_post_spec_whiledo + hoare_calculus_sound\nbegin"], ["", "lemma pre_post_while:\n  \"x \\<le> -p*-q\\<stileturn>-q \\<longrightarrow> -p\\<star>x \\<le> aL*-q\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - p * - q \\<stileturn> - q \\<longrightarrow>\n    - p \\<star> x \\<le> aL * - q \\<stileturn> - q", "by (smt aL_test pre_post_galois sub_mult_closed while_soundness)"], ["", "text \\<open>Theorem 43.1\\<close>"], ["", "lemma while_soundness_3:\n  \"test_seq t \\<Longrightarrow> -q \\<le> Sum t \\<Longrightarrow> x \\<le> t 0*-p*-q\\<stileturn>aL*-q \\<Longrightarrow> (\\<forall>n>0 . x \\<le> t n*-p*-q\\<stileturn>pSum t n*-q) \\<Longrightarrow> -p\\<star>x \\<le> -q\\<stileturn>--p*-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>test_seq t; - q \\<le> complete_tests_class.Sum t;\n     x \\<le> t 0 * - p * - q \\<stileturn> aL * - q;\n     \\<forall>n>0.\n        x \\<le> t n * - p * - q \\<stileturn> pSum t n * - q\\<rbrakk>\n    \\<Longrightarrow> - p \\<star> x \\<le> - q \\<stileturn> - - p * - q", "by (smt (verit, del_insts) aL_test pSum_test tests_dual.inf_closed pre_post_galois sub_mult_closed test_seq_def while_soundness_1)"], ["", "text \\<open>Theorem 43.2\\<close>"], ["", "lemma while_soundness_4:\n  \"test_seq t \\<Longrightarrow> -r \\<le> Sum t \\<Longrightarrow> (\\<forall>n . x \\<le> t n*-p\\<stileturn>pSum t n) \\<Longrightarrow> -p\\<star>x \\<le> -r\\<stileturn>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>test_seq t; - r \\<le> complete_tests_class.Sum t;\n     \\<forall>n. x \\<le> t n * - p \\<stileturn> pSum t n\\<rbrakk>\n    \\<Longrightarrow> - p \\<star> x \\<le> - r \\<stileturn> (1::'a)", "by (smt one_def pSum_test pre_post_galois sub_mult_closed test_seq_def while_soundness_2)"], ["", "end"], ["", "class pre_post_spec_hoare_pc_2 = pre_post_spec_hoare + hoare_calculus_pc_2\nbegin"], ["", "text \\<open>Theorem 43.3\\<close>"], ["", "lemma pre_post_while_pc:\n  \"x \\<le> -p*-q\\<stileturn>-q \\<longrightarrow> -p\\<star>x \\<le> -q\\<stileturn>--p*-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - p * - q \\<stileturn> - q \\<longrightarrow>\n    - p \\<star> x \\<le> - q \\<stileturn> - - p * - q", "by (metis pre_post_galois sub_mult_closed while_soundness_pc)"], ["", "end"], ["", "class pre_post_spec_hoare_pc = pre_post_spec_hoare + hoare_calculus_pc\nbegin"], ["", "subclass pre_post_spec_hoare_pc_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pre_post_spec_hoare_pc_2 Sup (1::'a) (*) a (\\<squnion>) bot\n     (\\<le>) (<) Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)\n     (\\<stileturn>) top", ".."], ["", "lemma pre_post_one_one_top:\n  \"1\\<stileturn>1 = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<stileturn> (1::'a) = top", "using order.eq_iff pre_one_one pre_post_one_one"], ["proof (prove)\nusing this:\n  (?a = ?b) = (?a \\<le> ?b \\<and> ?b \\<le> ?a)\n  ?x \\<guillemotleft> (1::'a) = (1::'a)\n  (?x \\<guillemotleft> (1::'a) = (1::'a)) =\n  (?x \\<le> (1::'a) \\<stileturn> (1::'a))\n\ngoal (1 subgoal):\n 1. (1::'a) \\<stileturn> (1::'a) = top", "by auto"], ["", "end"], ["", "class pre_post_spec_H = pre_post_spec_greatest + box_precondition + havoc +\n  assumes H_zero_2: \"H * bot = bot\"\n  assumes H_split_2: \"x \\<le> x * -q * top \\<squnion> H * --q\"\nbegin"], ["", "subclass idempotent_left_semiring_H"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.idempotent_left_semiring_H H top (1::'a) (*) (\\<squnion>) (\\<le>)\n     (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. H * bot = bot\n 2. \\<And>x. x \\<le> x * bot \\<squnion> H", "apply (rule H_zero_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<le> x * bot \\<squnion> H", "by (smt H_split_2 tests_dual.complement_bot mult_assoc mult_left_zero mult_1_right one_def)"], ["", "lemma pre_post_def_iff:\n  \"-p * x * --q \\<le> Z \\<longleftrightarrow> x \\<le> Z \\<squnion> --p * top \\<squnion> H * -q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a p * x * a (a q) \\<le> Z) =\n    (x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. a p * x * a (a q) \\<le> Z \\<Longrightarrow>\n    x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q\n 2. x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q \\<Longrightarrow>\n    a p * x * a (a q) \\<le> Z", "assume \"-p * x * --q \\<le> Z\""], ["proof (state)\nthis:\n  a p * x * a (a q) \\<le> Z\n\ngoal (2 subgoals):\n 1. a p * x * a (a q) \\<le> Z \\<Longrightarrow>\n    x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q\n 2. x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q \\<Longrightarrow>\n    a p * x * a (a q) \\<le> Z", "hence \"x * --q * top \\<le> Z \\<squnion> --p * top\""], ["proof (prove)\nusing this:\n  a p * x * a (a q) \\<le> Z\n\ngoal (1 subgoal):\n 1. x * a (a q) * top \\<le> Z \\<squnion> a (a p) * top", "by (smt (verit, ccfv_threshold) Z_left_zero_above_one case_split_left_sup mult_assoc mult_left_isotone mult_right_dist_sup mult_right_isotone top_greatest top_mult_top)"], ["proof (state)\nthis:\n  x * a (a q) * top \\<le> Z \\<squnion> a (a p) * top\n\ngoal (2 subgoals):\n 1. a p * x * a (a q) \\<le> Z \\<Longrightarrow>\n    x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q\n 2. x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q \\<Longrightarrow>\n    a p * x * a (a q) \\<le> Z", "thus \"x \\<le> Z \\<squnion> --p * top \\<squnion> H * -q\""], ["proof (prove)\nusing this:\n  x * a (a q) * top \\<le> Z \\<squnion> a (a p) * top\n\ngoal (1 subgoal):\n 1. x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q", "by (metis sup_left_isotone order_trans H_split_2 tests_dual.double_negation)"], ["proof (state)\nthis:\n  x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q\n\ngoal (1 subgoal):\n 1. x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q \\<Longrightarrow>\n    a p * x * a (a q) \\<le> Z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q \\<Longrightarrow>\n    a p * x * a (a q) \\<le> Z", "assume \"x \\<le> Z \\<squnion> --p * top \\<squnion> H * -q\""], ["proof (state)\nthis:\n  x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q\n\ngoal (1 subgoal):\n 1. x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q \\<Longrightarrow>\n    a p * x * a (a q) \\<le> Z", "hence \"-p * x * --q \\<le> -p * (Z * --q \\<squnion> --p * top * --q \\<squnion> H * -q * --q)\""], ["proof (prove)\nusing this:\n  x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q\n\ngoal (1 subgoal):\n 1. a p * x * a (a q)\n    \\<le> a p *\n          (Z * a (a q) \\<squnion> a (a p) * top * a (a q) \\<squnion>\n           H * a q * a (a q))", "by (metis mult_left_isotone mult_right_dist_sup mult_right_isotone mult_assoc)"], ["proof (state)\nthis:\n  a p * x * a (a q)\n  \\<le> a p *\n        (Z * a (a q) \\<squnion> a (a p) * top * a (a q) \\<squnion>\n         H * a q * a (a q))\n\ngoal (1 subgoal):\n 1. x \\<le> Z \\<squnion> a (a p) * top \\<squnion> H * a q \\<Longrightarrow>\n    a p * x * a (a q) \\<le> Z", "thus \"-p * x * --q \\<le> Z\""], ["proof (prove)\nusing this:\n  a p * x * a (a q)\n  \\<le> a p *\n        (Z * a (a q) \\<squnion> a (a p) * top * a (a q) \\<squnion>\n         H * a q * a (a q))\n\ngoal (1 subgoal):\n 1. a p * x * a (a q) \\<le> Z", "by (metis H_zero_2 Z_mult_decreasing sup_commute sup_bot_left mult_assoc mult_right_dist_sup mult_right_isotone order_trans test_mult_left_dist_shunt test_mult_left_sub_dist_shunt tests_dual.top_def)"], ["proof (state)\nthis:\n  a p * x * a (a q) \\<le> Z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_post_def:\n  \"-p\\<stileturn>-q = Z \\<squnion> --p*top \\<squnion> H*-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p \\<stileturn> a q = Z \\<squnion> a (a p) * top \\<squnion> H * a q", "by (meson order.antisym order_refl pre_Z pre_post_galois pre_post_def_iff)"], ["", "end"], ["", "class pre_post_L = pre_post_spec_greatest + box_while + left_conway_semiring_L + left_kleene_conway_semiring +\n  assumes circ_below_L_add_star: \"x\\<^sup>\\<circ> \\<le> L \\<squnion> x\\<^sup>\\<star>\"\nbegin"], ["", "text \\<open>a loop does not abort if its body does not abort\\<close>"], ["", "text \\<open>this avoids abortion from all states* alternatively from states in -r if -r is an invariant\\<close>"], ["", "lemma body_abort_loop:\n  assumes \"Z = L\"\n      and \"x \\<le> -p\\<stileturn>1\"\n    shows \"-p\\<star>x \\<le> 1\\<stileturn>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p \\<star> x \\<le> (1::'a) \\<stileturn> (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a p \\<star> x \\<le> (1::'a) \\<stileturn> (1::'a)", "have \"-p * x * bot \\<le> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p * x * bot \\<le> L", "by (metis assms pre_Z pre_post_galois tests_dual.sba_dual.one_def tests_dual.top_double_complement)"], ["proof (state)\nthis:\n  a p * x * bot \\<le> L\n\ngoal (1 subgoal):\n 1. a p \\<star> x \\<le> (1::'a) \\<stileturn> (1::'a)", "hence \"(-p * x)\\<^sup>\\<star> * bot \\<le> L\""], ["proof (prove)\nusing this:\n  a p * x * bot \\<le> L\n\ngoal (1 subgoal):\n 1. (a p * x)\\<^sup>\\<star> * bot \\<le> L", "by (metis L_split le_iff_sup star_left_induct sup_bot_left)"], ["proof (state)\nthis:\n  (a p * x)\\<^sup>\\<star> * bot \\<le> L\n\ngoal (1 subgoal):\n 1. a p \\<star> x \\<le> (1::'a) \\<stileturn> (1::'a)", "hence \"(-p * x)\\<^sup>\\<circ> * bot \\<le> L\""], ["proof (prove)\nusing this:\n  (a p * x)\\<^sup>\\<star> * bot \\<le> L\n\ngoal (1 subgoal):\n 1. (a p * x)\\<^sup>\\<circ> * bot \\<le> L", "by (smt L_left_zero L_split sup_commute circ_below_L_add_star le_iff_sup mult_right_dist_sup)"], ["proof (state)\nthis:\n  (a p * x)\\<^sup>\\<circ> * bot \\<le> L\n\ngoal (1 subgoal):\n 1. a p \\<star> x \\<le> (1::'a) \\<stileturn> (1::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (a p * x)\\<^sup>\\<circ> * bot \\<le> L\n\ngoal (1 subgoal):\n 1. a p \\<star> x \\<le> (1::'a) \\<stileturn> (1::'a)", "by (metis assms(1) a_restrict mult_isotone pre_pc_Z pre_post_compose_2 pre_post_one_one tests_dual.sba_dual.one_def while_def tests_dual.sup_right_zero)"], ["proof (state)\nthis:\n  a p \\<star> x \\<le> (1::'a) \\<stileturn> (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class pre_post_spec_Hd = pre_post_spec_least + diamond_precondition + idempotent_left_semiring_Hd +\n  assumes d_mult_top: \"d(x) * top = x * top\"\nbegin"], ["", "subclass pre_post_spec_least_Hd"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pre_post_spec_least_Hd Hd top (1::'a) (*) (\\<squnion>) (\\<le>) (<)\n     bot (\\<stileturn>) (\\<guillemotleft>) a", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<guillemotleft> (1::'a)) * top = x * top", "by (simp add: d_mult_top diamond_x_1 pre_def)"], ["", "end"], ["", "end"]]}