{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Pre_Post.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma post_pre_left_antitone:\n  \"x \\<le> y \\<Longrightarrow> y\\<guillemotleft>-q \\<le> x\\<guillemotleft>-q\"", "lemma pre_left_sub_dist:\n  \"x\\<squnion>y\\<guillemotleft>-q \\<le> x\\<guillemotleft>-q\"", "lemma pre_post_left_antitone:\n  \"-p \\<le> -q \\<Longrightarrow> -q\\<stileturn>-r \\<le> -p\\<stileturn>-r\"", "lemma pre_post_left_sub_dist:\n  \"-p\\<squnion>-q\\<stileturn>-r \\<le> -p\\<stileturn>-r\"", "lemma pre_post_left_sup_dist:\n  \"-p\\<stileturn>-r \\<le> -p*-q\\<stileturn>-r\"", "lemma pre_pre_post:\n  \"x \\<le> (x\\<guillemotleft>-p)\\<stileturn>-p\"", "lemma pre_post_pre:\n  \"-p \\<le> (-p\\<stileturn>-q)\\<guillemotleft>-q\"", "lemma pre_post_zero_top:\n  \"bot\\<stileturn>-q = top\"", "lemma pre_post_pre_one:\n  \"(1\\<stileturn>-q)\\<guillemotleft>-q = 1\"", "lemma pre_post_right_isotone:\n  \"-p \\<le> -q \\<Longrightarrow> -r\\<stileturn>-p \\<le> -r\\<stileturn>-q\"", "lemma pre_post_right_sub_dist:\n  \"-r\\<stileturn>-p \\<le> -r\\<stileturn>-p\\<squnion>-q\"", "lemma pre_post_right_sup_dist:\n  \"-r\\<stileturn>-p*-q \\<le> -r\\<stileturn>-p\"", "lemma pre_post_reflexive:\n  \"1 \\<le> -p\\<stileturn>-p\"", "lemma pre_post_compose:\n  \"-q \\<le> -r \\<Longrightarrow> (-p\\<stileturn>-q)*(-r\\<stileturn>-s) \\<le> -p\\<stileturn>-s\"", "lemma pre_post_compose_1:\n  \"(-p\\<stileturn>-q)*(-q\\<stileturn>-r) \\<le> -p\\<stileturn>-r\"", "lemma pre_post_compose_2:\n  \"(-p\\<stileturn>-p)*(-p\\<stileturn>-q) = -p\\<stileturn>-q\"", "lemma pre_post_compose_3:\n  \"(-p\\<stileturn>-q)*(-q\\<stileturn>-q) = -p\\<stileturn>-q\"", "lemma pre_post_compose_4:\n  \"(-p\\<stileturn>-p)*(-p\\<stileturn>-p) = -p\\<stileturn>-p\"", "lemma pre_post_one_one:\n  \"x\\<guillemotleft>1 = 1 \\<longleftrightarrow> x \\<le> 1\\<stileturn>1\"", "lemma post_pre_left_dist_sup:\n  \"x\\<squnion>y\\<guillemotleft>-q = (x\\<guillemotleft>-q)*(y\\<guillemotleft>-q)\"", "lemma pre_post_seq_sub_associative:\n  \"(-p\\<stileturn>-q)*-r \\<le> -p\\<stileturn>-q*-r\"", "lemma pre_post_right_import_mult:\n  \"(-p\\<stileturn>-q)*-r = (-p\\<stileturn>-q*-r)*-r\"", "lemma seq_pre_post_sub_associative:\n  \"-r*(-p\\<stileturn>-q) \\<le> --r\\<squnion>-p\\<stileturn>-q\"", "lemma pre_post_left_import_sup:\n  \"-r*(-p\\<stileturn>-q) = -r*(--r\\<squnion>-p\\<stileturn>-q)\"", "lemma pre_post_import_same:\n  \"-p*(-p\\<stileturn>-q) = -p*(1\\<stileturn>-q)\"", "lemma pre_post_import_complement:\n  \"--p*(-p\\<stileturn>-q) = --p*top\"", "lemma pre_post_export:\n  \"-p\\<stileturn>-q = (1\\<stileturn>-q) \\<squnion> --p*top\"", "lemma pre_post_left_dist_mult:\n  \"-p*-q\\<stileturn>-r = (-p\\<stileturn>-r) \\<squnion> (-q\\<stileturn>-r)\"", "lemma pre_post_left_import_mult:\n  \"-r*(-p\\<stileturn>-q) = -r*(-r*-p\\<stileturn>-q)\"", "lemma pre_post_right_import_sup:\n  \"(-p\\<stileturn>-q)*-r = (-p\\<stileturn>-q\\<squnion>--r)*-r\"", "lemma pre_post_shunting:\n  \"x \\<le> -p*-q\\<stileturn>-r \\<longleftrightarrow> -p*x \\<le> -q\\<stileturn>-r\"", "lemma pre_post_right_dist_sup:\n  \"-p\\<stileturn>-q\\<squnion>-r = (-p\\<stileturn>-q) \\<squnion> (-p\\<stileturn>-r)\"", "lemma H_galois:\n  \"x * bot \\<le> y \\<longleftrightarrow> x \\<le> y \\<squnion> H\"", "lemma H_greatest_finite:\n  \"x * bot = bot \\<longleftrightarrow> x \\<le> H\"", "lemma H_reflexive:\n  \"1 \\<le> H\"", "lemma H_transitive:\n  \"H = H * H\"", "lemma T_split_H:\n  \"top * bot \\<squnion> H = top\"", "lemma shunting_top:\n  \"-p * x \\<le> y \\<longleftrightarrow> x \\<le> y \\<squnion> --p * top\"", "lemma post_pre_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x\\<guillemotleft>-q \\<le> y\\<guillemotleft>-q\"", "lemma pre_left_sub_dist:\n  \"x\\<guillemotleft>-q \\<le> x\\<squnion>y\\<guillemotleft>-q\"", "lemma pre_post_left_isotone:\n  \"-p \\<le> -q \\<Longrightarrow> -p\\<stileturn>-r \\<le> -q\\<stileturn>-r\"", "lemma pre_post_left_sub_dist:\n  \"-p\\<stileturn>-r \\<le> -p\\<squnion>-q\\<stileturn>-r\"", "lemma pre_post_left_sup_dist:\n  \"-p*-q\\<stileturn>-r \\<le> -p\\<stileturn>-r\"", "lemma pre_pre_post:\n  \"(x\\<guillemotleft>-p)\\<stileturn>-p \\<le> x\"", "lemma pre_post_pre:\n  \"-p \\<le> (-p\\<stileturn>-q)\\<guillemotleft>-q\"", "lemma pre_post_zero_top:\n  \"bot\\<stileturn>-q = bot\"", "lemma pre_post_pre_one:\n  \"(1\\<stileturn>-q)\\<guillemotleft>-q = 1\"", "lemma pre_post_right_antitone:\n  \"-p \\<le> -q \\<Longrightarrow> -r\\<stileturn>-q \\<le> -r\\<stileturn>-p\"", "lemma pre_post_right_sub_dist:\n  \"-r\\<stileturn>-p\\<squnion>-q \\<le> -r\\<stileturn>-p\"", "lemma pre_post_right_sup_dist:\n  \"-r\\<stileturn>-p \\<le> -r\\<stileturn>-p*-q\"", "lemma pre_top:\n  \"top\\<guillemotleft>-q = 1\"", "lemma pre_mult_top_increasing:\n  \"-p \\<le> -p*top\\<guillemotleft>-q\"", "lemma pre_post_below_mult_top:\n  \"-p\\<stileturn>-q \\<le> -p*top\"", "lemma pre_post_import_complement:\n  \"--p*(-p\\<stileturn>-q) = bot\"", "lemma pre_post_import_same:\n  \"-p*(-p\\<stileturn>-q) = -p\\<stileturn>-q\"", "lemma pre_post_export:\n  \"-p\\<stileturn>-q = -p*(1\\<stileturn>-q)\"", "lemma pre_post_seq_associative:\n  \"-r*(-p\\<stileturn>-q) = -r*-p\\<stileturn>-q\"", "lemma pre_post_left_import_mult:\n  \"-r*(-p\\<stileturn>-q) = -r*(-r*-p\\<stileturn>-q)\"", "lemma seq_pre_post_sub_associative:\n  \"-r*(-p\\<stileturn>-q) \\<le> --r\\<squnion>-p\\<stileturn>-q\"", "lemma pre_post_left_import_sup:\n  \"-r*(-p\\<stileturn>-q) = -r*(--r\\<squnion>-p\\<stileturn>-q)\"", "lemma pre_post_left_dist_sup:\n  \"-p\\<squnion>-q\\<stileturn>-r = (-p\\<stileturn>-r) \\<squnion> (-q\\<stileturn>-r)\"", "lemma pre_post_reflexive:\n  \"-p\\<stileturn>-p \\<le> 1\"", "lemma pre_post_compose:\n  \"-q \\<le> -r \\<Longrightarrow> -p\\<stileturn>-s \\<le> (-p\\<stileturn>-q)*(-r\\<stileturn>-s)\"", "lemma pre_post_compose_1:\n  \"-p\\<stileturn>-r \\<le> (-p\\<stileturn>-q)*(-q\\<stileturn>-r)\"", "lemma pre_post_compose_2:\n  \"(-p\\<stileturn>-p)*(-p\\<stileturn>-q) = -p\\<stileturn>-q\"", "lemma pre_post_compose_3:\n  \"(-p\\<stileturn>-q)*(-q\\<stileturn>-q) = -p\\<stileturn>-q\"", "lemma pre_post_compose_4:\n  \"(-p\\<stileturn>-p)*(-p\\<stileturn>-p) = -p\\<stileturn>-p\"", "lemma pre_post_one_one:\n  \"x\\<guillemotleft>1 = 1 \\<longleftrightarrow> 1\\<stileturn>1 \\<le> x\"", "lemma pre_one_right:\n  \"-p\\<guillemotleft>1 = -p\"", "lemma pre_pre_one:\n  \"x\\<guillemotleft>-q = x*-q\\<guillemotleft>1\"", "lemma Hd_least_total:\n  \"x * top = top \\<longleftrightarrow> Hd \\<le> x\"", "lemma Hd_reflexive:\n  \"Hd \\<le> 1\"", "lemma Hd_transitive:\n  \"Hd = Hd * Hd\"", "lemma Hd_pre_one:\n  \"Hd\\<guillemotleft>1 = 1\"", "lemma pre_post_below_Hd:\n  \"1\\<stileturn>1 \\<le> Hd\"", "lemma Hd_pre_post:\n  \"Hd = 1\\<stileturn>1\"", "lemma top_left_zero:\n  \"top*x = top\"", "lemma test_dual_test:\n  \"(-p\\<squnion>--p*top)*-p = -p\\<squnion>--p*top\"", "lemma pre_zero_mult_top:\n  \"(x\\<guillemotleft>bot)*top = x*bot\"", "lemma pre_one_mult_Hd:\n  \"(x\\<guillemotleft>1)*Hd \\<le> x\"", "lemma Hd_mult_pre_one:\n  \"Hd*(x\\<guillemotleft>1) \\<le> x\"", "lemma pre_post_one_def_1:\n  assumes \"1 \\<le> x\\<guillemotleft>-q\"\n    shows \"Hd*(-q\\<squnion>--q*top) \\<le> x\"", "lemma pre_post_one_def:\n  \"1\\<stileturn>-q = Hd*(-q\\<squnion>--q*top)\"", "lemma pre_post_def:\n  \"-p\\<stileturn>-q = -p*Hd*(-q\\<squnion>--q*top)\""], "translations": [["", "lemma post_pre_left_antitone:\n  \"x \\<le> y \\<Longrightarrow> y\\<guillemotleft>-q \\<le> x\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    y \\<guillemotleft> - q \\<le> x \\<guillemotleft> - q", "by (smt order_refl order_trans pre_closed pre_post_galois)"], ["", "lemma pre_left_sub_dist:\n  \"x\\<squnion>y\\<guillemotleft>-q \\<le> x\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<guillemotleft> - q \\<le> x \\<guillemotleft> - q", "by (simp add: post_pre_left_antitone)"], ["", "text \\<open>Theorem 42.2\\<close>"], ["", "lemma pre_post_left_antitone:\n  \"-p \\<le> -q \\<Longrightarrow> -q\\<stileturn>-r \\<le> -p\\<stileturn>-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<le> - q \\<Longrightarrow>\n    - q \\<stileturn> - r \\<le> - p \\<stileturn> - r", "using order_lesseq_imp pre_post_galois"], ["proof (prove)\nusing this:\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (?x \\<le> - ?p \\<stileturn> - ?q)\n\ngoal (1 subgoal):\n 1. - p \\<le> - q \\<Longrightarrow>\n    - q \\<stileturn> - r \\<le> - p \\<stileturn> - r", "by blast"], ["", "lemma pre_post_left_sub_dist:\n  \"-p\\<squnion>-q\\<stileturn>-r \\<le> -p\\<stileturn>-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<squnion> - q \\<stileturn> - r \\<le> - p \\<stileturn> - r", "by (metis sup.cobounded1 tests_dual.sba_dual.sub_sup_closed pre_post_left_antitone)"], ["", "lemma pre_post_left_sup_dist:\n  \"-p\\<stileturn>-r \\<le> -p*-q\\<stileturn>-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - r \\<le> - p * - q \\<stileturn> - r", "by (metis tests_dual.sba_dual.sub_inf_def pre_post_left_sub_dist tests_dual.inf_absorb)"], ["", "text \\<open>Theorem 42.5\\<close>"], ["", "lemma pre_pre_post:\n  \"x \\<le> (x\\<guillemotleft>-p)\\<stileturn>-p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> (x \\<guillemotleft> - p) \\<stileturn> - p", "by (metis order_refl pre_closed pre_post_galois)"], ["", "text \\<open>Theorem 42.6\\<close>"], ["", "lemma pre_post_pre:\n  \"-p \\<le> (-p\\<stileturn>-q)\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<le> (- p \\<stileturn> - q) \\<guillemotleft> - q", "by (simp add: pre_post_galois)"], ["", "text \\<open>Theorem 42.8\\<close>"], ["", "lemma pre_post_zero_top:\n  \"bot\\<stileturn>-q = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<stileturn> - q = top", "by (metis order.eq_iff pre_post_galois sup.cobounded2 sup_monoid.add_0_right top_greatest tests_dual.top_double_complement)"], ["", "text \\<open>Theorem 42.7\\<close>"], ["", "lemma pre_post_pre_one:\n  \"(1\\<stileturn>-q)\\<guillemotleft>-q = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<stileturn> - q) \\<guillemotleft> - q = (1::'a)", "by (metis order.eq_iff pre_below_one tests_dual.sba_dual.top_double_complement pre_post_pre)"], ["", "text \\<open>Theorem 42.3\\<close>"], ["", "lemma pre_post_right_isotone:\n  \"-p \\<le> -q \\<Longrightarrow> -r\\<stileturn>-p \\<le> -r\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<le> - q \\<Longrightarrow>\n    - r \\<stileturn> - p \\<le> - r \\<stileturn> - q", "using order_lesseq_imp pre_iso pre_post_galois"], ["proof (prove)\nusing this:\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  - ?p \\<le> - ?q \\<Longrightarrow>\n  ?x \\<guillemotleft> - ?p \\<le> ?x \\<guillemotleft> - ?q\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (?x \\<le> - ?p \\<stileturn> - ?q)\n\ngoal (1 subgoal):\n 1. - p \\<le> - q \\<Longrightarrow>\n    - r \\<stileturn> - p \\<le> - r \\<stileturn> - q", "by blast"], ["", "lemma pre_post_right_sub_dist:\n  \"-r\\<stileturn>-p \\<le> -r\\<stileturn>-p\\<squnion>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r \\<stileturn> - p \\<le> - r \\<stileturn> - p \\<squnion> - q", "by (metis sup.cobounded1 tests_dual.sba_dual.sub_sup_closed pre_post_right_isotone)"], ["", "lemma pre_post_right_sup_dist:\n  \"-r\\<stileturn>-p*-q \\<le> -r\\<stileturn>-p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r \\<stileturn> - p * - q \\<le> - r \\<stileturn> - p", "by (metis tests_dual.sub_sup_closed pre_post_right_isotone tests_dual.upper_bound_left)"], ["", "text \\<open>Theorem 42.7\\<close>"], ["", "lemma pre_post_reflexive:\n  \"1 \\<le> -p\\<stileturn>-p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive (- p \\<stileturn> - p)", "using pre_one_increasing pre_post_galois"], ["proof (prove)\nusing this:\n  - ?q \\<le> (1::'a) \\<guillemotleft> - ?q\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (?x \\<le> - ?p \\<stileturn> - ?q)\n\ngoal (1 subgoal):\n 1. reflexive (- p \\<stileturn> - p)", "by auto"], ["", "text \\<open>Theorem 42.9\\<close>"], ["", "lemma pre_post_compose:\n  \"-q \\<le> -r \\<Longrightarrow> (-p\\<stileturn>-q)*(-r\\<stileturn>-s) \\<le> -p\\<stileturn>-s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - q \\<le> - r \\<Longrightarrow>\n    (- p \\<stileturn> - q) * (- r \\<stileturn> - s)\n    \\<le> - p \\<stileturn> - s", "using order_lesseq_imp pre_compose pre_post_galois"], ["proof (prove)\nusing this:\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  \\<lbrakk>- ?p \\<le> ?x \\<guillemotleft> - ?q;\n   - ?q \\<le> ?y \\<guillemotleft> - ?r\\<rbrakk>\n  \\<Longrightarrow> - ?p \\<le> ?x * ?y \\<guillemotleft> - ?r\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (?x \\<le> - ?p \\<stileturn> - ?q)\n\ngoal (1 subgoal):\n 1. - q \\<le> - r \\<Longrightarrow>\n    (- p \\<stileturn> - q) * (- r \\<stileturn> - s)\n    \\<le> - p \\<stileturn> - s", "by blast"], ["", "text \\<open>Theorem 42.10\\<close>"], ["", "lemma pre_post_compose_1:\n  \"(-p\\<stileturn>-q)*(-q\\<stileturn>-r) \\<le> -p\\<stileturn>-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - q) * (- q \\<stileturn> - r)\n    \\<le> - p \\<stileturn> - r", "by (simp add: pre_post_compose)"], ["", "text \\<open>Theorem 42.11\\<close>"], ["", "lemma pre_post_compose_2:\n  \"(-p\\<stileturn>-p)*(-p\\<stileturn>-q) = -p\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - p) * (- p \\<stileturn> - q) = - p \\<stileturn> - q", "by (meson case_split_left order.eq_iff le_supI1 pre_post_compose_1 pre_post_reflexive)"], ["", "text \\<open>Theorem 42.12\\<close>"], ["", "lemma pre_post_compose_3:\n  \"(-p\\<stileturn>-q)*(-q\\<stileturn>-q) = -p\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - q) * (- q \\<stileturn> - q) = - p \\<stileturn> - q", "by (meson order.eq_iff order.trans mult_right_isotone mult_sub_right_one pre_post_compose_1 pre_post_reflexive)"], ["", "text \\<open>Theorem 42.13\\<close>"], ["", "lemma pre_post_compose_4:\n  \"(-p\\<stileturn>-p)*(-p\\<stileturn>-p) = -p\\<stileturn>-p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent (- p \\<stileturn> - p)", "by (simp add: pre_post_compose_3)"], ["", "text \\<open>Theorem 42.14\\<close>"], ["", "lemma pre_post_one_one:\n  \"x\\<guillemotleft>1 = 1 \\<longleftrightarrow> x \\<le> 1\\<stileturn>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> (1::'a) = (1::'a)) =\n    (x \\<le> (1::'a) \\<stileturn> (1::'a))", "by (metis order.eq_iff one_def pre_below_one pre_post_galois)"], ["", "text \\<open>Theorem 42.4\\<close>"], ["", "lemma post_pre_left_dist_sup:\n  \"x\\<squnion>y\\<guillemotleft>-q = (x\\<guillemotleft>-q)*(y\\<guillemotleft>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<guillemotleft> - q =\n    (x \\<guillemotleft> - q) * (y \\<guillemotleft> - q)", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<squnion> y \\<guillemotleft> - q\n    \\<le> (x \\<guillemotleft> - q) * (y \\<guillemotleft> - q)\n 2. (x \\<guillemotleft> - q) * (y \\<guillemotleft> - q)\n    \\<le> x \\<squnion> y \\<guillemotleft> - q", "apply (metis mult_isotone pre_closed sup_commute tests_dual.sup_idempotent pre_left_sub_dist)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> - q) * (y \\<guillemotleft> - q)\n    \\<le> x \\<squnion> y \\<guillemotleft> - q", "by (smt (z3) order.refl pre_closed pre_post_galois sup.boundedI tests_dual.sba_dual.greatest_lower_bound tests_dual.sub_sup_closed)"], ["", "(*\nlemma pre_post_right_dist_sup: \"-p\\<stileturn>-q\\<squnion>-r = (-p\\<stileturn>-q) \\<squnion> (-p\\<stileturn>-r)\" nitpick [expect=genuine,card=4] oops\n*)"], ["", "end"], ["", "class pre_post_spec_greatest_2 = pre_post_spec_greatest + precondition_test_test\nbegin"], ["", "subclass precondition_test_box"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.precondition_test_box (\\<guillemotleft>) (1::'a) (*) uminus\n     (\\<squnion>) bot (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q. - p \\<guillemotleft> - q = - - p \\<squnion> - q", "by (smt (verit) sup_commute mult_1_right tests_dual.double_negation order.eq_iff mult_left_one mult_right_dist_sup one_def tests_dual.inf_complement tests_dual.inf_complement_intro pre_below_one pre_import pre_post_galois pre_test_test tests_dual.top_def bot_least)"], ["", "lemma pre_post_seq_sub_associative:\n  \"(-p\\<stileturn>-q)*-r \\<le> -p\\<stileturn>-q*-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - q) * - r \\<le> - p \\<stileturn> - q * - r", "by (smt (z3) pre_compose pre_post_galois pre_post_pre sub_comm test_below_pre_test_mult tests_dual.sub_sup_closed)"], ["", "lemma pre_post_right_import_mult:\n  \"(-p\\<stileturn>-q)*-r = (-p\\<stileturn>-q*-r)*-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - q) * - r = (- p \\<stileturn> - q * - r) * - r", "by (metis order.antisym mult_assoc tests_dual.sup_idempotent mult_left_isotone pre_post_right_sup_dist pre_post_seq_sub_associative)"], ["", "lemma seq_pre_post_sub_associative:\n  \"-r*(-p\\<stileturn>-q) \\<le> --r\\<squnion>-p\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * (- p \\<stileturn> - q) \\<le> - - r \\<squnion> - p \\<stileturn> - q", "by (smt (z3) pre_compose pre_post_galois pre_post_pre pre_test tests_dual.sba_dual.reflexive tests_dual.sba_dual.sub_sup_closed)"], ["", "lemma pre_post_left_import_sup:\n  \"-r*(-p\\<stileturn>-q) = -r*(--r\\<squnion>-p\\<stileturn>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * (- p \\<stileturn> - q) =\n    - r * (- - r \\<squnion> - p \\<stileturn> - q)", "by (metis sup_commute order.antisym mult_assoc tests_dual.sup_idempotent mult_right_isotone pre_post_left_sub_dist seq_pre_post_sub_associative)"], ["", "lemma pre_post_import_same:\n  \"-p*(-p\\<stileturn>-q) = -p*(1\\<stileturn>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p * (- p \\<stileturn> - q) = - p * ((1::'a) \\<stileturn> - q)", "using pre_test pre_test_test_same pre_post_left_import_sup"], ["proof (prove)\nusing this:\n  - ?p \\<guillemotleft> - ?q = - - ?p \\<squnion> - ?q\n  - ?p \\<guillemotleft> - ?p = (1::'a)\n  - ?r * (- ?p \\<stileturn> - ?q) =\n  - ?r * (- - ?r \\<squnion> - ?p \\<stileturn> - ?q)\n\ngoal (1 subgoal):\n 1. - p * (- p \\<stileturn> - q) = - p * ((1::'a) \\<stileturn> - q)", "by auto"], ["", "lemma pre_post_import_complement:\n  \"--p*(-p\\<stileturn>-q) = --p*top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - p * (- p \\<stileturn> - q) = - - p * top", "by (metis tests_dual.sup_idempotent tests_dual.inf_cases tests_dual.inf_closed pre_post_left_import_sup pre_post_zero_top tests_dual.top_def tests_dual.top_double_complement)"], ["", "lemma pre_post_export:\n  \"-p\\<stileturn>-q = (1\\<stileturn>-q) \\<squnion> --p*top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q = ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top", "proof (rule order.antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. - p \\<stileturn> - q\n    \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n 2. ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n    \\<le> - p \\<stileturn> - q", "have 1: \"-p*(-p\\<stileturn>-q) \\<le> (1\\<stileturn>-q) \\<squnion> --p*top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p * (- p \\<stileturn> - q)\n    \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top", "by (metis le_supI1 pre_test pre_test_test_same seq_pre_post_sub_associative)"], ["proof (state)\nthis:\n  - p * (- p \\<stileturn> - q)\n  \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n\ngoal (2 subgoals):\n 1. - p \\<stileturn> - q\n    \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n 2. ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n    \\<le> - p \\<stileturn> - q", "have \"--p*(-p\\<stileturn>-q) \\<le> (1\\<stileturn>-q) \\<squnion> --p*top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - p * (- p \\<stileturn> - q)\n    \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top", "by (simp add: pre_post_import_complement)"], ["proof (state)\nthis:\n  - - p * (- p \\<stileturn> - q)\n  \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n\ngoal (2 subgoals):\n 1. - p \\<stileturn> - q\n    \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n 2. ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n    \\<le> - p \\<stileturn> - q", "thus \"-p\\<stileturn>-q \\<le> (1\\<stileturn>-q) \\<squnion> --p*top\""], ["proof (prove)\nusing this:\n  - - p * (- p \\<stileturn> - q)\n  \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q\n    \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top", "using 1"], ["proof (prove)\nusing this:\n  - - p * (- p \\<stileturn> - q)\n  \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n  - p * (- p \\<stileturn> - q)\n  \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q\n    \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top", "by (smt case_split_left eq_refl tests_dual.inf_complement)"], ["proof (state)\nthis:\n  - p \\<stileturn> - q\n  \\<le> ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n\ngoal (1 subgoal):\n 1. ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n    \\<le> - p \\<stileturn> - q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n    \\<le> - p \\<stileturn> - q", "show \"(1\\<stileturn>-q) \\<squnion> --p*top \\<le> -p\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n    \\<le> - p \\<stileturn> - q", "by (metis le_sup_iff tests_dual.double_negation tests_dual.sub_bot_least pre_neg_mult pre_post_galois pre_post_pre_one)"], ["proof (state)\nthis:\n  ((1::'a) \\<stileturn> - q) \\<squnion> - - p * top\n  \\<le> - p \\<stileturn> - q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_post_left_dist_mult:\n  \"-p*-q\\<stileturn>-r = (-p\\<stileturn>-r) \\<squnion> (-q\\<stileturn>-r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p * - q \\<stileturn> - r =\n    (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - p * - q \\<stileturn> - r =\n    (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "have \"\\<forall>p q . -p*(-p*-q\\<stileturn>-r) = -p*(-q\\<stileturn>-r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p q.\n       - p * (- p * - q \\<stileturn> - r) = - p * (- q \\<stileturn> - r)", "using sup_monoid.add_commute tests_dual.sba_dual.sub_inf_def pre_post_left_import_sup tests_dual.inf_complement_intro"], ["proof (prove)\nusing this:\n  ?a \\<squnion> ?b = ?b \\<squnion> ?a\n  - ?x * - ?y = - (- - ?x \\<squnion> - - ?y)\n  - ?r * (- ?p \\<stileturn> - ?q) =\n  - ?r * (- - ?r \\<squnion> - ?p \\<stileturn> - ?q)\n  - ?x * - ?y \\<squnion> - - ?x = - ?y \\<squnion> - - ?x\n\ngoal (1 subgoal):\n 1. \\<forall>p q.\n       - p * (- p * - q \\<stileturn> - r) = - p * (- q \\<stileturn> - r)", "by auto"], ["proof (state)\nthis:\n  \\<forall>p q.\n     - p * (- p * - q \\<stileturn> - r) = - p * (- q \\<stileturn> - r)\n\ngoal (1 subgoal):\n 1. - p * - q \\<stileturn> - r =\n    (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "hence 1: \"(-p\\<squnion>-q)*(-p*-q\\<stileturn>-r) \\<le> (-p\\<stileturn>-r) \\<squnion> (-q\\<stileturn>-r)\""], ["proof (prove)\nusing this:\n  \\<forall>p q.\n     - p * (- p * - q \\<stileturn> - r) = - p * (- q \\<stileturn> - r)\n\ngoal (1 subgoal):\n 1. (- p \\<squnion> - q) * (- p * - q \\<stileturn> - r)\n    \\<le> (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "by (metis sup_commute le_sup_iff sup_ge2 mult_left_one mult_right_dist_sup tests_dual.inf_left_unit sub_comm)"], ["proof (state)\nthis:\n  (- p \\<squnion> - q) * (- p * - q \\<stileturn> - r)\n  \\<le> (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)\n\ngoal (1 subgoal):\n 1. - p * - q \\<stileturn> - r =\n    (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "have \"-(-p\\<squnion>-q)*(-p*-q\\<stileturn>-r) = -(-p\\<squnion>-q)*top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- p \\<squnion> - q) * (- p * - q \\<stileturn> - r) =\n    - (- p \\<squnion> - q) * top", "by (smt (z3) sup.left_commute sup_commute tests_dual.sba_dual.sub_sup_closed tests_dual.sub_sup_closed pre_post_import_complement pre_post_left_import_sup tests_dual.inf_absorb)"], ["proof (state)\nthis:\n  - (- p \\<squnion> - q) * (- p * - q \\<stileturn> - r) =\n  - (- p \\<squnion> - q) * top\n\ngoal (1 subgoal):\n 1. - p * - q \\<stileturn> - r =\n    (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "hence \"-(-p\\<squnion>-q)*(-p*-q\\<stileturn>-r) \\<le> (-p\\<stileturn>-r) \\<squnion> (-q\\<stileturn>-r)\""], ["proof (prove)\nusing this:\n  - (- p \\<squnion> - q) * (- p * - q \\<stileturn> - r) =\n  - (- p \\<squnion> - q) * top\n\ngoal (1 subgoal):\n 1. - (- p \\<squnion> - q) * (- p * - q \\<stileturn> - r)\n    \\<le> (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "by (smt (z3) order.trans le_supI1 pre_post_left_sub_dist tests_dual.sba_dual.sub_sup_closed tests_dual.sub_sup_closed seq_pre_post_sub_associative)"], ["proof (state)\nthis:\n  - (- p \\<squnion> - q) * (- p * - q \\<stileturn> - r)\n  \\<le> (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)\n\ngoal (1 subgoal):\n 1. - p * - q \\<stileturn> - r =\n    (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  - (- p \\<squnion> - q) * (- p * - q \\<stileturn> - r)\n  \\<le> (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)\n\ngoal (1 subgoal):\n 1. - p * - q \\<stileturn> - r =\n    (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "using 1"], ["proof (prove)\nusing this:\n  - (- p \\<squnion> - q) * (- p * - q \\<stileturn> - r)\n  \\<le> (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)\n  (- p \\<squnion> - q) * (- p * - q \\<stileturn> - r)\n  \\<le> (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)\n\ngoal (1 subgoal):\n 1. - p * - q \\<stileturn> - r =\n    (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "by (smt (z3) le_sup_iff order.antisym case_split_left order_refl tests_dual.inf_closed tests_dual.inf_complement pre_post_left_sup_dist sub_comm)"], ["proof (state)\nthis:\n  - p * - q \\<stileturn> - r =\n  (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_post_left_import_mult:\n  \"-r*(-p\\<stileturn>-q) = -r*(-r*-p\\<stileturn>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * (- p \\<stileturn> - q) = - r * (- r * - p \\<stileturn> - q)", "by (metis sup_commute tests_dual.inf_complement_intro pre_post_left_import_sup sub_mult_closed)"], ["", "lemma pre_post_right_import_sup:\n  \"(-p\\<stileturn>-q)*-r = (-p\\<stileturn>-q\\<squnion>--r)*-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - q) * - r =\n    (- p \\<stileturn> - q \\<squnion> - - r) * - r", "by (smt (z3) sup_monoid.add_commute tests_dual.sba_dual.inf_cases_2 tests_dual.sba_dual.inf_complement_intro tests_dual.sub_complement tests_dual.sub_inf_def pre_post_right_import_mult)"], ["", "lemma pre_post_shunting:\n  \"x \\<le> -p*-q\\<stileturn>-r \\<longleftrightarrow> -p*x \\<le> -q\\<stileturn>-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> - p * - q \\<stileturn> - r) =\n    (- p * x \\<le> - q \\<stileturn> - r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<le> - p * - q \\<stileturn> - r) =\n    (- p * x \\<le> - q \\<stileturn> - r)", "have \"--p*x \\<le> -p*-q\\<stileturn>-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - p * x \\<le> - p * - q \\<stileturn> - r", "by (metis tests_dual.double_negation order_trans pre_neg_mult pre_post_galois pre_post_left_sup_dist)"], ["proof (state)\nthis:\n  - - p * x \\<le> - p * - q \\<stileturn> - r\n\ngoal (1 subgoal):\n 1. (x \\<le> - p * - q \\<stileturn> - r) =\n    (- p * x \\<le> - q \\<stileturn> - r)", "hence 1: \"-p*x \\<le> -q\\<stileturn>-r \\<longrightarrow> x \\<le> -p*-q\\<stileturn>-r\""], ["proof (prove)\nusing this:\n  - - p * x \\<le> - p * - q \\<stileturn> - r\n\ngoal (1 subgoal):\n 1. - p * x \\<le> - q \\<stileturn> - r \\<longrightarrow>\n    x \\<le> - p * - q \\<stileturn> - r", "by (smt case_split_left eq_refl order_trans tests_dual.inf_complement pre_post_left_sup_dist sub_comm)"], ["proof (state)\nthis:\n  - p * x \\<le> - q \\<stileturn> - r \\<longrightarrow>\n  x \\<le> - p * - q \\<stileturn> - r\n\ngoal (1 subgoal):\n 1. (x \\<le> - p * - q \\<stileturn> - r) =\n    (- p * x \\<le> - q \\<stileturn> - r)", "have \"-p*(-p*-q\\<stileturn>-r) \\<le> -q\\<stileturn>-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p * (- p * - q \\<stileturn> - r) \\<le> - q \\<stileturn> - r", "by (metis mult_left_isotone mult_left_one tests_dual.sub_bot_least pre_post_left_import_mult)"], ["proof (state)\nthis:\n  - p * (- p * - q \\<stileturn> - r) \\<le> - q \\<stileturn> - r\n\ngoal (1 subgoal):\n 1. (x \\<le> - p * - q \\<stileturn> - r) =\n    (- p * x \\<le> - q \\<stileturn> - r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  - p * (- p * - q \\<stileturn> - r) \\<le> - q \\<stileturn> - r\n\ngoal (1 subgoal):\n 1. (x \\<le> - p * - q \\<stileturn> - r) =\n    (- p * x \\<le> - q \\<stileturn> - r)", "using 1 mult_right_isotone order_lesseq_imp"], ["proof (prove)\nusing this:\n  - p * (- p * - q \\<stileturn> - r) \\<le> - q \\<stileturn> - r\n  - p * x \\<le> - q \\<stileturn> - r \\<longrightarrow>\n  x \\<le> - p * - q \\<stileturn> - r\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. (x \\<le> - p * - q \\<stileturn> - r) =\n    (- p * x \\<le> - q \\<stileturn> - r)", "by blast"], ["proof (state)\nthis:\n  (x \\<le> - p * - q \\<stileturn> - r) =\n  (- p * x \\<le> - q \\<stileturn> - r)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma pre_post_right_dist_sup: \"-p\\<stileturn>-q\\<squnion>-r = (-p\\<stileturn>-q) \\<squnion> (-p\\<stileturn>-r)\" oops\n*)"], ["", "end"], ["", "class left_zero_pre_post_spec_greatest_2 = pre_post_spec_greatest_2 + bounded_idempotent_left_zero_semiring\nbegin"], ["", "lemma pre_post_right_dist_sup:\n  \"-p\\<stileturn>-q\\<squnion>-r = (-p\\<stileturn>-q) \\<squnion> (-p\\<stileturn>-r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q \\<squnion> - r =\n    (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q \\<squnion> - r =\n    (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)", "have 1: \"(-p\\<stileturn>-q\\<squnion>-r)*-q \\<le> (-p\\<stileturn>-q) \\<squnion> (-p\\<stileturn>-r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - q \\<squnion> - r) * - q\n    \\<le> (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)", "by (metis le_supI1 pre_post_seq_sub_associative tests_dual.sba_dual.inf_absorb tests_dual.sba_dual.sub_sup_closed)"], ["proof (state)\nthis:\n  (- p \\<stileturn> - q \\<squnion> - r) * - q\n  \\<le> (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)\n\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q \\<squnion> - r =\n    (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)", "have \"(-p\\<stileturn>-q\\<squnion>-r)*--q = (-p\\<stileturn>-r)*--q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - q \\<squnion> - r) * - - q =\n    (- p \\<stileturn> - r) * - - q", "by (simp add: pre_post_right_import_sup sup_commute)"], ["proof (state)\nthis:\n  (- p \\<stileturn> - q \\<squnion> - r) * - - q =\n  (- p \\<stileturn> - r) * - - q\n\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q \\<squnion> - r =\n    (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)", "hence \"(-p\\<stileturn>-q\\<squnion>-r)*--q \\<le> (-p\\<stileturn>-q) \\<squnion> (-p\\<stileturn>-r)\""], ["proof (prove)\nusing this:\n  (- p \\<stileturn> - q \\<squnion> - r) * - - q =\n  (- p \\<stileturn> - r) * - - q\n\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - q \\<squnion> - r) * - - q\n    \\<le> (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)", "by (metis sup_ge2 mult_left_sub_dist_sup_right mult_1_right order_trans tests_dual.inf_left_unit)"], ["proof (state)\nthis:\n  (- p \\<stileturn> - q \\<squnion> - r) * - - q\n  \\<le> (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)\n\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q \\<squnion> - r =\n    (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (- p \\<stileturn> - q \\<squnion> - r) * - - q\n  \\<le> (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)\n\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q \\<squnion> - r =\n    (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)", "using 1"], ["proof (prove)\nusing this:\n  (- p \\<stileturn> - q \\<squnion> - r) * - - q\n  \\<le> (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)\n  (- p \\<stileturn> - q \\<squnion> - r) * - q\n  \\<le> (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)\n\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q \\<squnion> - r =\n    (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)", "by (metis le_sup_iff order.antisym case_split_right tests_dual.sub_bot_least tests_dual.inf_commutative tests_dual.inf_complement pre_post_right_sub_dist)"], ["proof (state)\nthis:\n  - p \\<stileturn> - q \\<squnion> - r =\n  (- p \\<stileturn> - q) \\<squnion> (- p \\<stileturn> - r)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class havoc =\n  fixes H :: \"'a\""], ["", "class idempotent_left_semiring_H = bounded_idempotent_left_semiring + havoc +\n  assumes H_zero : \"H * bot = bot\"\n  assumes H_split: \"x \\<le> x * bot \\<squnion> H\"\nbegin"], ["", "lemma H_galois:\n  \"x * bot \\<le> y \\<longleftrightarrow> x \\<le> y \\<squnion> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * bot \\<le> y) = (x \\<le> y \\<squnion> H)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * bot \\<le> y \\<Longrightarrow> x \\<le> y \\<squnion> H\n 2. x \\<le> y \\<squnion> H \\<Longrightarrow> x * bot \\<le> y", "using H_split order_lesseq_imp sup_mono"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x * bot \\<squnion> H\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  \\<lbrakk>?a \\<le> ?c; ?b \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a \\<squnion> ?b \\<le> ?c \\<squnion> ?d\n\ngoal (2 subgoals):\n 1. x * bot \\<le> y \\<Longrightarrow> x \\<le> y \\<squnion> H\n 2. x \\<le> y \\<squnion> H \\<Longrightarrow> x * bot \\<le> y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> H \\<Longrightarrow> x * bot \\<le> y", "by (smt (verit, ccfv_threshold) H_zero mult_right_dist_sup sup.cobounded2 sup.orderE sup_assoc sup_bot_left sup_commute zero_right_mult_decreasing)"], ["", "lemma H_greatest_finite:\n  \"x * bot = bot \\<longleftrightarrow> x \\<le> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * bot = bot) = (x \\<le> H)", "by (metis H_galois le_iff_sup sup_bot_left sup_monoid.add_0_right)"], ["", "lemma H_reflexive:\n  \"1 \\<le> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive H", "using H_greatest_finite mult_left_one"], ["proof (prove)\nusing this:\n  (?x * bot = bot) = (?x \\<le> H)\n  (1::'a) * ?x = ?x\n\ngoal (1 subgoal):\n 1. reflexive H", "by blast"], ["", "lemma H_transitive:\n  \"H = H * H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = H * H", "by (metis H_greatest_finite H_reflexive H_zero preorder_idempotent mult_assoc)"], ["", "lemma T_split_H:\n  \"top * bot \\<squnion> H = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * bot \\<squnion> H = top", "by (simp add: H_split order.antisym)"], ["", "(*\nlemma \"H * (x \\<squnion> y) = H * x \\<squnion> H * y\" nitpick [expect=genuine,card=6] oops\n*)"], ["", "end"], ["", "class pre_post_spec_least = bounded_idempotent_left_semiring + precondition_test_test + precondition_promote + pre_post +\n  assumes test_mult_right_distr_sup: \"-p * (x \\<squnion> y) = -p * x \\<squnion> -p * y\"\n  assumes pre_post_galois: \"-p \\<le> x\\<guillemotleft>-q \\<longleftrightarrow> -p\\<stileturn>-q \\<le> x\"\nbegin"], ["", "lemma shunting_top:\n  \"-p * x \\<le> y \\<longleftrightarrow> x \\<le> y \\<squnion> --p * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p * x \\<le> y) = (x \\<le> y \\<squnion> - - p * top)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. - p * x \\<le> y \\<Longrightarrow> x \\<le> y \\<squnion> - - p * top\n 2. x \\<le> y \\<squnion> - - p * top \\<Longrightarrow> - p * x \\<le> y", "assume \"-p * x \\<le> y\""], ["proof (state)\nthis:\n  - p * x \\<le> y\n\ngoal (2 subgoals):\n 1. - p * x \\<le> y \\<Longrightarrow> x \\<le> y \\<squnion> - - p * top\n 2. x \\<le> y \\<squnion> - - p * top \\<Longrightarrow> - p * x \\<le> y", "thus \"x \\<le> y \\<squnion> --p * top\""], ["proof (prove)\nusing this:\n  - p * x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> - - p * top", "by (smt (verit, ccfv_SIG) case_split_left eq_refl le_supI1 le_supI2 mult_right_isotone tests_dual.sba_dual.top_def top_greatest)"], ["proof (state)\nthis:\n  x \\<le> y \\<squnion> - - p * top\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> - - p * top \\<Longrightarrow> - p * x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> - - p * top \\<Longrightarrow> - p * x \\<le> y", "assume \"x \\<le> y \\<squnion> --p * top\""], ["proof (state)\nthis:\n  x \\<le> y \\<squnion> - - p * top\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> - - p * top \\<Longrightarrow> - p * x \\<le> y", "hence \"-p * x \\<le> -p * y\""], ["proof (prove)\nusing this:\n  x \\<le> y \\<squnion> - - p * top\n\ngoal (1 subgoal):\n 1. - p * x \\<le> - p * y", "by (metis sup_bot_right mult_assoc tests_dual.sup_complement mult_left_zero mult_right_isotone test_mult_right_distr_sup)"], ["proof (state)\nthis:\n  - p * x \\<le> - p * y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> - - p * top \\<Longrightarrow> - p * x \\<le> y", "thus \"-p * x \\<le> y\""], ["proof (prove)\nusing this:\n  - p * x \\<le> - p * y\n\ngoal (1 subgoal):\n 1. - p * x \\<le> y", "by (metis mult_left_isotone mult_left_one tests_dual.sub_bot_least order_trans)"], ["proof (state)\nthis:\n  - p * x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma post_pre_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x\\<guillemotleft>-q \\<le> y\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    x \\<guillemotleft> - q \\<le> y \\<guillemotleft> - q", "by (smt order_refl order_trans pre_closed pre_post_galois)"], ["", "lemma pre_left_sub_dist:\n  \"x\\<guillemotleft>-q \\<le> x\\<squnion>y\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<guillemotleft> - q \\<le> x \\<squnion> y \\<guillemotleft> - q", "by (simp add: post_pre_left_isotone)"], ["", "lemma pre_post_left_isotone:\n  \"-p \\<le> -q \\<Longrightarrow> -p\\<stileturn>-r \\<le> -q\\<stileturn>-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<le> - q \\<Longrightarrow>\n    - p \\<stileturn> - r \\<le> - q \\<stileturn> - r", "using order_lesseq_imp pre_post_galois"], ["proof (prove)\nusing this:\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (- ?p \\<stileturn> - ?q \\<le> ?x)\n\ngoal (1 subgoal):\n 1. - p \\<le> - q \\<Longrightarrow>\n    - p \\<stileturn> - r \\<le> - q \\<stileturn> - r", "by blast"], ["", "lemma pre_post_left_sub_dist:\n  \"-p\\<stileturn>-r \\<le> -p\\<squnion>-q\\<stileturn>-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - r \\<le> - p \\<squnion> - q \\<stileturn> - r", "by (metis sup_ge1 tests_dual.inf_closed pre_post_left_isotone)"], ["", "lemma pre_post_left_sup_dist:\n  \"-p*-q\\<stileturn>-r \\<le> -p\\<stileturn>-r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p * - q \\<stileturn> - r \\<le> - p \\<stileturn> - r", "by (metis tests_dual.upper_bound_left pre_post_left_isotone sub_mult_closed)"], ["", "lemma pre_pre_post:\n  \"(x\\<guillemotleft>-p)\\<stileturn>-p \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> - p) \\<stileturn> - p \\<le> x", "by (metis order_refl pre_closed pre_post_galois)"], ["", "lemma pre_post_pre:\n  \"-p \\<le> (-p\\<stileturn>-q)\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<le> (- p \\<stileturn> - q) \\<guillemotleft> - q", "by (simp add: pre_post_galois)"], ["", "lemma pre_post_zero_top:\n  \"bot\\<stileturn>-q = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<stileturn> - q = bot", "using bot_least order.eq_iff pre_post_galois tests_dual.sba_dual.sub_bot_def"], ["proof (prove)\nusing this:\n  bot \\<le> ?a\n  (?a = ?b) = (?a \\<le> ?b \\<and> ?b \\<le> ?a)\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (- ?p \\<stileturn> - ?q \\<le> ?x)\n  bot = - (THE x. \\<forall>y. x = - y \\<squnion> - - y)\n\ngoal (1 subgoal):\n 1. bot \\<stileturn> - q = bot", "by blast"], ["", "lemma pre_post_pre_one:\n  \"(1\\<stileturn>-q)\\<guillemotleft>-q = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<stileturn> - q) \\<guillemotleft> - q = (1::'a)", "by (metis order.eq_iff pre_below_one pre_post_pre tests_dual.sba_dual.top_double_complement)"], ["", "lemma pre_post_right_antitone:\n  \"-p \\<le> -q \\<Longrightarrow> -r\\<stileturn>-q \\<le> -r\\<stileturn>-p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<le> - q \\<Longrightarrow>\n    - r \\<stileturn> - q \\<le> - r \\<stileturn> - p", "using order_lesseq_imp pre_iso pre_post_galois"], ["proof (prove)\nusing this:\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  - ?p \\<le> - ?q \\<Longrightarrow>\n  ?x \\<guillemotleft> - ?p \\<le> ?x \\<guillemotleft> - ?q\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (- ?p \\<stileturn> - ?q \\<le> ?x)\n\ngoal (1 subgoal):\n 1. - p \\<le> - q \\<Longrightarrow>\n    - r \\<stileturn> - q \\<le> - r \\<stileturn> - p", "by blast"], ["", "lemma pre_post_right_sub_dist:\n  \"-r\\<stileturn>-p\\<squnion>-q \\<le> -r\\<stileturn>-p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r \\<stileturn> - p \\<squnion> - q \\<le> - r \\<stileturn> - p", "by (metis sup_ge1 tests_dual.inf_closed pre_post_right_antitone)"], ["", "lemma pre_post_right_sup_dist:\n  \"-r\\<stileturn>-p \\<le> -r\\<stileturn>-p*-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r \\<stileturn> - p \\<le> - r \\<stileturn> - p * - q", "by (metis tests_dual.upper_bound_left pre_post_right_antitone sub_mult_closed)"], ["", "lemma pre_top:\n  \"top\\<guillemotleft>-q = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top \\<guillemotleft> - q = (1::'a)", "using order.eq_iff pre_below_one pre_post_galois tests_dual.sba_dual.one_def top_greatest"], ["proof (prove)\nusing this:\n  (?a = ?b) = (?a \\<le> ?b \\<and> ?b \\<le> ?a)\n  coreflexive (?x \\<guillemotleft> - ?p)\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (- ?p \\<stileturn> - ?q \\<le> ?x)\n  (1::'a) = - bot\n  ?x \\<le> top\n\ngoal (1 subgoal):\n 1. top \\<guillemotleft> - q = (1::'a)", "by blast"], ["", "lemma pre_mult_top_increasing:\n  \"-p \\<le> -p*top\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<le> - p * top \\<guillemotleft> - q", "using pre_import_equiv pre_top tests_dual.sub_bot_least"], ["proof (prove)\nusing this:\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) =\n  (- ?p \\<le> - ?p * ?x \\<guillemotleft> - ?q)\n  top \\<guillemotleft> - ?q = (1::'a)\n  coreflexive (- ?x)\n\ngoal (1 subgoal):\n 1. - p \\<le> - p * top \\<guillemotleft> - q", "by auto"], ["", "lemma pre_post_below_mult_top:\n  \"-p\\<stileturn>-q \\<le> -p*top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q \\<le> - p * top", "using pre_import_equiv pre_post_galois"], ["proof (prove)\nusing this:\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) =\n  (- ?p \\<le> - ?p * ?x \\<guillemotleft> - ?q)\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (- ?p \\<stileturn> - ?q \\<le> ?x)\n\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q \\<le> - p * top", "by auto"], ["", "lemma pre_post_import_complement:\n  \"--p*(-p\\<stileturn>-q) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - p * (- p \\<stileturn> - q) = bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - - p * (- p \\<stileturn> - q) = bot", "have \"--p*(-p\\<stileturn>-q) \\<le> --p*(-p*top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - p * (- p \\<stileturn> - q) \\<le> - - p * (- p * top)", "by (simp add: mult_right_isotone pre_post_below_mult_top)"], ["proof (state)\nthis:\n  - - p * (- p \\<stileturn> - q) \\<le> - - p * (- p * top)\n\ngoal (1 subgoal):\n 1. - - p * (- p \\<stileturn> - q) = bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  - - p * (- p \\<stileturn> - q) \\<le> - - p * (- p * top)\n\ngoal (1 subgoal):\n 1. - - p * (- p \\<stileturn> - q) = bot", "by (metis mult_assoc mult_left_zero sub_comm tests_dual.top_def order.antisym bot_least)"], ["proof (state)\nthis:\n  - - p * (- p \\<stileturn> - q) = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_post_import_same:\n  \"-p*(-p\\<stileturn>-q) = -p\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p * (- p \\<stileturn> - q) = - p \\<stileturn> - q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - p * (- p \\<stileturn> - q) = - p \\<stileturn> - q", "have \"-p\\<stileturn>-q = -p*(-p\\<stileturn>-q) \\<squnion> --p*(-p\\<stileturn>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q =\n    - p * (- p \\<stileturn> - q) \\<squnion> - - p * (- p \\<stileturn> - q)", "by (metis mult_left_one mult_right_dist_sup tests_dual.inf_complement)"], ["proof (state)\nthis:\n  - p \\<stileturn> - q =\n  - p * (- p \\<stileturn> - q) \\<squnion> - - p * (- p \\<stileturn> - q)\n\ngoal (1 subgoal):\n 1. - p * (- p \\<stileturn> - q) = - p \\<stileturn> - q", "thus ?thesis"], ["proof (prove)\nusing this:\n  - p \\<stileturn> - q =\n  - p * (- p \\<stileturn> - q) \\<squnion> - - p * (- p \\<stileturn> - q)\n\ngoal (1 subgoal):\n 1. - p * (- p \\<stileturn> - q) = - p \\<stileturn> - q", "using pre_post_import_complement"], ["proof (prove)\nusing this:\n  - p \\<stileturn> - q =\n  - p * (- p \\<stileturn> - q) \\<squnion> - - p * (- p \\<stileturn> - q)\n  - - ?p * (- ?p \\<stileturn> - ?q) = bot\n\ngoal (1 subgoal):\n 1. - p * (- p \\<stileturn> - q) = - p \\<stileturn> - q", "by auto"], ["proof (state)\nthis:\n  - p * (- p \\<stileturn> - q) = - p \\<stileturn> - q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_post_export:\n  \"-p\\<stileturn>-q = -p*(1\\<stileturn>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q = - p * ((1::'a) \\<stileturn> - q)", "proof (rule order.antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. - p \\<stileturn> - q \\<le> - p * ((1::'a) \\<stileturn> - q)\n 2. - p * ((1::'a) \\<stileturn> - q) \\<le> - p \\<stileturn> - q", "show \"-p\\<stileturn>-q \\<le> -p*(1\\<stileturn>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q \\<le> - p * ((1::'a) \\<stileturn> - q)", "by (metis tests_dual.sub_bot_least pre_import_equiv pre_post_galois pre_post_pre_one)"], ["proof (state)\nthis:\n  - p \\<stileturn> - q \\<le> - p * ((1::'a) \\<stileturn> - q)\n\ngoal (1 subgoal):\n 1. - p * ((1::'a) \\<stileturn> - q) \\<le> - p \\<stileturn> - q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - p * ((1::'a) \\<stileturn> - q) \\<le> - p \\<stileturn> - q", "have 1: \"-p \\<le> ((-p\\<stileturn>-q) \\<squnion> --p*top)\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p\n    \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q", "by (simp add: pre_post_galois)"], ["proof (state)\nthis:\n  - p\n  \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q\n\ngoal (1 subgoal):\n 1. - p * ((1::'a) \\<stileturn> - q) \\<le> - p \\<stileturn> - q", "have \"--p \\<le> ((-p\\<stileturn>-q) \\<squnion> --p*top)\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - p\n    \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q", "by (simp add: le_supI2 pre_post_galois pre_post_below_mult_top)"], ["proof (state)\nthis:\n  - - p\n  \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q\n\ngoal (1 subgoal):\n 1. - p * ((1::'a) \\<stileturn> - q) \\<le> - p \\<stileturn> - q", "hence \"-p \\<squnion> --p \\<le> ((-p\\<stileturn>-q) \\<squnion> --p*top)\\<guillemotleft>-q\""], ["proof (prove)\nusing this:\n  - - p\n  \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q\n\ngoal (1 subgoal):\n 1. - p \\<squnion> - - p\n    \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q", "using 1 le_supI"], ["proof (prove)\nusing this:\n  - - p\n  \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q\n  - p\n  \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q\n  \\<lbrakk>?a \\<le> ?x; ?b \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> ?a \\<squnion> ?b \\<le> ?x\n\ngoal (1 subgoal):\n 1. - p \\<squnion> - - p\n    \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q", "by blast"], ["proof (state)\nthis:\n  - p \\<squnion> - - p\n  \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q\n\ngoal (1 subgoal):\n 1. - p * ((1::'a) \\<stileturn> - q) \\<le> - p \\<stileturn> - q", "hence \"1 \\<le> ((-p\\<stileturn>-q) \\<squnion> --p*top)\\<guillemotleft>-q\""], ["proof (prove)\nusing this:\n  - p \\<squnion> - - p\n  \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q\n\ngoal (1 subgoal):\n 1. reflexive\n     ((- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q)", "by simp"], ["proof (state)\nthis:\n  reflexive\n   ((- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q)\n\ngoal (1 subgoal):\n 1. - p * ((1::'a) \\<stileturn> - q) \\<le> - p \\<stileturn> - q", "hence \"1\\<stileturn>-q \\<le> (-p\\<stileturn>-q) \\<squnion> --p*top\""], ["proof (prove)\nusing this:\n  reflexive\n   ((- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q)\n\ngoal (1 subgoal):\n 1. (1::'a) \\<stileturn> - q\n    \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top", "using pre_post_galois tests_dual.sba_dual.one_def"], ["proof (prove)\nusing this:\n  reflexive\n   ((- p \\<stileturn> - q) \\<squnion> - - p * top \\<guillemotleft> - q)\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (- ?p \\<stileturn> - ?q \\<le> ?x)\n  (1::'a) = - bot\n\ngoal (1 subgoal):\n 1. (1::'a) \\<stileturn> - q\n    \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top", "by blast"], ["proof (state)\nthis:\n  (1::'a) \\<stileturn> - q\n  \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top\n\ngoal (1 subgoal):\n 1. - p * ((1::'a) \\<stileturn> - q) \\<le> - p \\<stileturn> - q", "thus \"-p*(1\\<stileturn>-q) \\<le> -p\\<stileturn>-q\""], ["proof (prove)\nusing this:\n  (1::'a) \\<stileturn> - q\n  \\<le> (- p \\<stileturn> - q) \\<squnion> - - p * top\n\ngoal (1 subgoal):\n 1. - p * ((1::'a) \\<stileturn> - q) \\<le> - p \\<stileturn> - q", "by (simp add: shunting_top)"], ["proof (state)\nthis:\n  - p * ((1::'a) \\<stileturn> - q) \\<le> - p \\<stileturn> - q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_post_seq_associative:\n  \"-r*(-p\\<stileturn>-q) = -r*-p\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * (- p \\<stileturn> - q) = - r * - p \\<stileturn> - q", "by (metis pre_post_export tests_dual.sub_sup_closed mult_assoc)"], ["", "lemma pre_post_left_import_mult:\n  \"-r*(-p\\<stileturn>-q) = -r*(-r*-p\\<stileturn>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * (- p \\<stileturn> - q) = - r * (- r * - p \\<stileturn> - q)", "by (metis mult_assoc tests_dual.sup_idempotent pre_post_seq_associative)"], ["", "lemma seq_pre_post_sub_associative:\n  \"-r*(-p\\<stileturn>-q) \\<le> --r\\<squnion>-p\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * (- p \\<stileturn> - q) \\<le> - - r \\<squnion> - p \\<stileturn> - q", "by (metis le_supI1 pre_post_left_sub_dist sup_commute shunting_top)"], ["", "lemma pre_post_left_import_sup:\n  \"-r*(-p\\<stileturn>-q) = -r*(--r\\<squnion>-p\\<stileturn>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - r * (- p \\<stileturn> - q) =\n    - r * (- - r \\<squnion> - p \\<stileturn> - q)", "by (metis tests_dual.sba_dual.sub_sup_closed pre_post_seq_associative tests_dual.sup_complement_intro)"], ["", "lemma pre_post_left_dist_sup:\n  \"-p\\<squnion>-q\\<stileturn>-r = (-p\\<stileturn>-r) \\<squnion> (-q\\<stileturn>-r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<squnion> - q \\<stileturn> - r =\n    (- p \\<stileturn> - r) \\<squnion> (- q \\<stileturn> - r)", "by (metis mult_right_dist_sup tests_dual.inf_closed pre_post_export)"], ["", "lemma pre_post_reflexive:\n  \"-p\\<stileturn>-p \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (- p \\<stileturn> - p)", "using pre_one_increasing pre_post_galois"], ["proof (prove)\nusing this:\n  - ?q \\<le> (1::'a) \\<guillemotleft> - ?q\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (- ?p \\<stileturn> - ?q \\<le> ?x)\n\ngoal (1 subgoal):\n 1. coreflexive (- p \\<stileturn> - p)", "by auto"], ["", "lemma pre_post_compose:\n  \"-q \\<le> -r \\<Longrightarrow> -p\\<stileturn>-s \\<le> (-p\\<stileturn>-q)*(-r\\<stileturn>-s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - q \\<le> - r \\<Longrightarrow>\n    - p \\<stileturn> - s\n    \\<le> (- p \\<stileturn> - q) * (- r \\<stileturn> - s)", "by (meson pre_compose pre_post_galois pre_post_pre pre_post_right_antitone)"], ["", "lemma pre_post_compose_1:\n  \"-p\\<stileturn>-r \\<le> (-p\\<stileturn>-q)*(-q\\<stileturn>-r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - r\n    \\<le> (- p \\<stileturn> - q) * (- q \\<stileturn> - r)", "by (simp add: pre_post_compose)"], ["", "lemma pre_post_compose_2:\n  \"(-p\\<stileturn>-p)*(-p\\<stileturn>-q) = -p\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - p) * (- p \\<stileturn> - q) = - p \\<stileturn> - q", "using order.eq_iff mult_left_isotone pre_post_compose_1 pre_post_reflexive"], ["proof (prove)\nusing this:\n  (?a = ?b) = (?a \\<le> ?b \\<and> ?b \\<le> ?a)\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  - ?p \\<stileturn> - ?r\n  \\<le> (- ?p \\<stileturn> - ?q) * (- ?q \\<stileturn> - ?r)\n  coreflexive (- ?p \\<stileturn> - ?p)\n\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - p) * (- p \\<stileturn> - q) = - p \\<stileturn> - q", "by fastforce"], ["", "lemma pre_post_compose_3:\n  \"(-p\\<stileturn>-q)*(-q\\<stileturn>-q) = -p\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<stileturn> - q) * (- q \\<stileturn> - q) = - p \\<stileturn> - q", "by (metis order.antisym mult_right_isotone mult_1_right pre_post_compose_1 pre_post_reflexive)"], ["", "lemma pre_post_compose_4:\n  \"(-p\\<stileturn>-p)*(-p\\<stileturn>-p) = -p\\<stileturn>-p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent (- p \\<stileturn> - p)", "by (simp add: pre_post_compose_3)"], ["", "lemma pre_post_one_one:\n  \"x\\<guillemotleft>1 = 1 \\<longleftrightarrow> 1\\<stileturn>1 \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> (1::'a) = (1::'a)) =\n    ((1::'a) \\<stileturn> (1::'a) \\<le> x)", "using order.eq_iff pre_below_one pre_post_galois tests_dual.sub_bot_def"], ["proof (prove)\nusing this:\n  (?a = ?b) = (?a \\<le> ?b \\<and> ?b \\<le> ?a)\n  coreflexive (?x \\<guillemotleft> - ?p)\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (- ?p \\<stileturn> - ?q \\<le> ?x)\n  (1::'a) = - (THE x. \\<forall>y. x = - y * - - y)\n\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> (1::'a) = (1::'a)) =\n    ((1::'a) \\<stileturn> (1::'a) \\<le> x)", "by force"], ["", "lemma pre_one_right:\n  \"-p\\<guillemotleft>1 = -p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<guillemotleft> (1::'a) = - p", "by (metis order.antisym mult_1_right one_def tests_dual.inf_complement pre_left_sub_dist pre_mult_top_increasing pre_one pre_seq pre_test_promote pre_top)"], ["", "lemma pre_pre_one:\n  \"x\\<guillemotleft>-q = x*-q\\<guillemotleft>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<guillemotleft> - q = x * - q \\<guillemotleft> (1::'a)", "by (metis one_def pre_one_right pre_seq)"], ["", "subclass precondition_test_diamond"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.precondition_test_diamond (\\<guillemotleft>) (1::'a) (*) uminus\n     (\\<squnion>) bot (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q. - p \\<guillemotleft> - q = - p * - q", "using tests_dual.sba_dual.sub_inf_def pre_one_right pre_pre_one"], ["proof (prove)\nusing this:\n  - ?x * - ?y = - (- - ?x \\<squnion> - - ?y)\n  - ?p \\<guillemotleft> (1::'a) = - ?p\n  ?x \\<guillemotleft> - ?q = ?x * - ?q \\<guillemotleft> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>p q. - p \\<guillemotleft> - q = - p * - q", "by auto"], ["", "(*\nlemma pre_post_shunting: \"x \\<le> -p*-q\\<stileturn>-r \\<longleftrightarrow> -p*x \\<le> -q\\<stileturn>-r\" nitpick [expect=genuine,card=3] oops\nlemma \"(-p\\<stileturn>-q)*-r = (-p\\<stileturn>-q\\<squnion>-r)*-r\" nitpick [expect=genuine,card=3] oops\nlemma \"(-p\\<stileturn>-q)*-r = (-p\\<stileturn>-q\\<squnion>--r)*-r\" nitpick [expect=genuine,card=3] oops\nlemma \"(-p\\<stileturn>-q)*-r = (-p\\<stileturn>-q*-r)*-r\" nitpick [expect=genuine,card=3] oops\nlemma \"(-p\\<stileturn>-q)*-r = (-p\\<stileturn>-q*--r)*-r\" nitpick [expect=genuine,card=3] oops\nlemma \"-p\\<stileturn>-q\\<squnion>-r = (-p\\<stileturn>-q) \\<squnion> (-p\\<stileturn>-r)\" nitpick [expect=genuine,card=3] oops\nlemma \"-p\\<stileturn>-q\\<squnion>-r = (-p\\<stileturn>-q) * (-p\\<stileturn>-r)\" nitpick [expect=genuine,card=3] oops\nlemma pre_post_right_dist_mult: \"-p\\<stileturn>-q*-r = (-p\\<stileturn>-q) * (-p\\<stileturn>-r)\" oops\nlemma pre_post_right_dist_mult: \"-p\\<stileturn>-q*-r = (-p\\<stileturn>-q) \\<squnion> (-p\\<stileturn>-r)\" oops\nlemma post_pre_left_dist_sup: \"x\\<squnion>y\\<guillemotleft>-q = (x\\<guillemotleft>-q) \\<squnion> (y\\<guillemotleft>-q)\" oops\n*)"], ["", "end"], ["", "class havoc_dual =\n  fixes Hd :: \"'a\""], ["", "class idempotent_left_semiring_Hd = bounded_idempotent_left_semiring + havoc_dual +\n  assumes Hd_total: \"Hd * top = top\"\n  assumes Hd_least: \"x * top = top \\<longrightarrow> Hd \\<le> x\"\nbegin"], ["", "lemma Hd_least_total:\n  \"x * top = top \\<longleftrightarrow> Hd \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_top_class.total x = (Hd \\<le> x)", "by (metis Hd_least Hd_total order.antisym mult_left_isotone top_greatest)"], ["", "lemma Hd_reflexive:\n  \"Hd \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive Hd", "by (simp add: Hd_least)"], ["", "lemma Hd_transitive:\n  \"Hd = Hd * Hd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hd = Hd * Hd", "by (simp add: Hd_least Hd_total order.antisym coreflexive_transitive total_mult_closed)"], ["", "end"], ["", "class pre_post_spec_least_Hd = idempotent_left_semiring_Hd + pre_post_spec_least +\n  assumes pre_one_mult_top: \"(x\\<guillemotleft>1)*top = x*top\"\nbegin"], ["", "lemma Hd_pre_one:\n  \"Hd\\<guillemotleft>1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hd \\<guillemotleft> (1::'a) = (1::'a)", "by (metis Hd_total pre_seq pre_top)"], ["", "lemma pre_post_below_Hd:\n  \"1\\<stileturn>1 \\<le> Hd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<stileturn> (1::'a) \\<le> Hd", "using Hd_pre_one pre_post_one_one"], ["proof (prove)\nusing this:\n  Hd \\<guillemotleft> (1::'a) = (1::'a)\n  (?x \\<guillemotleft> (1::'a) = (1::'a)) =\n  ((1::'a) \\<stileturn> (1::'a) \\<le> ?x)\n\ngoal (1 subgoal):\n 1. (1::'a) \\<stileturn> (1::'a) \\<le> Hd", "by auto"], ["", "lemma Hd_pre_post:\n  \"Hd = 1\\<stileturn>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hd = (1::'a) \\<stileturn> (1::'a)", "by (metis Hd_least Hd_pre_one Hd_total order.eq_iff pre_one_mult_top pre_post_one_one)"], ["", "lemma top_left_zero:\n  \"top*x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective x", "by (metis mult_assoc mult_left_one mult_left_zero pre_closed pre_one_mult_top pre_seq pre_top)"], ["", "lemma test_dual_test:\n  \"(-p\\<squnion>--p*top)*-p = -p\\<squnion>--p*top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- p \\<squnion> - - p * top) * - p = - p \\<squnion> - - p * top", "by (simp add: top_left_zero mult_right_dist_sup mult_assoc)"], ["", "lemma pre_zero_mult_top:\n  \"(x\\<guillemotleft>bot)*top = x*bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> bot) * top = x * bot", "by (metis mult_assoc mult_left_zero one_def pre_one_mult_top pre_seq pre_bot)"], ["", "lemma pre_one_mult_Hd:\n  \"(x\\<guillemotleft>1)*Hd \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> (1::'a)) * Hd \\<le> x", "by (metis Hd_pre_post one_def pre_closed pre_post_export pre_pre_post)"], ["", "lemma Hd_mult_pre_one:\n  \"Hd*(x\\<guillemotleft>1) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hd * (x \\<guillemotleft> (1::'a)) \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hd * (x \\<guillemotleft> (1::'a)) \\<le> x", "have 1: \"-(x\\<guillemotleft>1)*Hd*(x\\<guillemotleft>1) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<guillemotleft> (1::'a)) * Hd * (x \\<guillemotleft> (1::'a))\n    \\<le> x", "by (metis Hd_pre_post le_iff_sup mult_left_isotone pre_closed pre_one_right pre_post_export pre_pre_post sup_commute sup_monoid.add_0_right tests_dual.sba_dual.one_def tests_dual.top_def)"], ["proof (state)\nthis:\n  - (x \\<guillemotleft> (1::'a)) * Hd * (x \\<guillemotleft> (1::'a)) \\<le> x\n\ngoal (1 subgoal):\n 1. Hd * (x \\<guillemotleft> (1::'a)) \\<le> x", "have \"(x\\<guillemotleft>1)*Hd*(x\\<guillemotleft>1) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> (1::'a)) * Hd * (x \\<guillemotleft> (1::'a)) \\<le> x", "by (metis mult_isotone mult_1_right one_def pre_below_one pre_one_mult_Hd)"], ["proof (state)\nthis:\n  (x \\<guillemotleft> (1::'a)) * Hd * (x \\<guillemotleft> (1::'a)) \\<le> x\n\ngoal (1 subgoal):\n 1. Hd * (x \\<guillemotleft> (1::'a)) \\<le> x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x \\<guillemotleft> (1::'a)) * Hd * (x \\<guillemotleft> (1::'a)) \\<le> x\n\ngoal (1 subgoal):\n 1. Hd * (x \\<guillemotleft> (1::'a)) \\<le> x", "using 1"], ["proof (prove)\nusing this:\n  (x \\<guillemotleft> (1::'a)) * Hd * (x \\<guillemotleft> (1::'a)) \\<le> x\n  - (x \\<guillemotleft> (1::'a)) * Hd * (x \\<guillemotleft> (1::'a)) \\<le> x\n\ngoal (1 subgoal):\n 1. Hd * (x \\<guillemotleft> (1::'a)) \\<le> x", "by (metis case_split_left pre_closed reflexive_one_closed tests_dual.sba_dual.one_def tests_dual.sba_dual.top_def mult_assoc)"], ["proof (state)\nthis:\n  Hd * (x \\<guillemotleft> (1::'a)) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_post_one_def_1:\n  assumes \"1 \\<le> x\\<guillemotleft>-q\"\n    shows \"Hd*(-q\\<squnion>--q*top) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hd * (- q \\<squnion> - - q * top) \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Hd * (- q \\<squnion> - - q * top) \\<le> x", "have \"Hd*(-q\\<squnion>--q*top) \\<le> x*-q*(-q\\<squnion>--q*top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hd * (- q \\<squnion> - - q * top)\n    \\<le> x * - q * (- q \\<squnion> - - q * top)", "by (metis assms Hd_pre_post order.antisym pre_below_one pre_post_one_one pre_pre_one mult_left_isotone)"], ["proof (state)\nthis:\n  Hd * (- q \\<squnion> - - q * top)\n  \\<le> x * - q * (- q \\<squnion> - - q * top)\n\ngoal (1 subgoal):\n 1. Hd * (- q \\<squnion> - - q * top) \\<le> x", "thus ?thesis"], ["proof (prove)\nusing this:\n  Hd * (- q \\<squnion> - - q * top)\n  \\<le> x * - q * (- q \\<squnion> - - q * top)\n\ngoal (1 subgoal):\n 1. Hd * (- q \\<squnion> - - q * top) \\<le> x", "by (metis mult_assoc tests_dual.sup_complement mult_left_sub_dist_sup_left mult_left_zero mult_1_right tests_dual.inf_complement test_mult_right_distr_sup order_trans)"], ["proof (state)\nthis:\n  Hd * (- q \\<squnion> - - q * top) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_post_one_def:\n  \"1\\<stileturn>-q = Hd*(-q\\<squnion>--q*top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<stileturn> - q = Hd * (- q \\<squnion> - - q * top)", "proof (rule order.antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (1::'a) \\<stileturn> - q \\<le> Hd * (- q \\<squnion> - - q * top)\n 2. Hd * (- q \\<squnion> - - q * top) \\<le> (1::'a) \\<stileturn> - q", "have \"1 \\<le> (1\\<stileturn>1)*(-q\\<squnion>--q)\\<guillemotleft>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive\n     (((1::'a) \\<stileturn> (1::'a)) *\n      (- q \\<squnion> - - q) \\<guillemotleft>\n      (1::'a))", "by (metis pre_post_pre one_def mult_1_right tests_dual.inf_complement)"], ["proof (state)\nthis:\n  reflexive\n   (((1::'a) \\<stileturn> (1::'a)) * (- q \\<squnion> - - q) \\<guillemotleft>\n    (1::'a))\n\ngoal (2 subgoals):\n 1. (1::'a) \\<stileturn> - q \\<le> Hd * (- q \\<squnion> - - q * top)\n 2. Hd * (- q \\<squnion> - - q * top) \\<le> (1::'a) \\<stileturn> - q", "also"], ["proof (state)\nthis:\n  reflexive\n   (((1::'a) \\<stileturn> (1::'a)) * (- q \\<squnion> - - q) \\<guillemotleft>\n    (1::'a))\n\ngoal (2 subgoals):\n 1. (1::'a) \\<stileturn> - q \\<le> Hd * (- q \\<squnion> - - q * top)\n 2. Hd * (- q \\<squnion> - - q * top) \\<le> (1::'a) \\<stileturn> - q", "have \"... \\<le> (1\\<stileturn>1)*(-q\\<squnion>--q*top)\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<stileturn> (1::'a)) * (- q \\<squnion> - - q) \\<guillemotleft>\n    (1::'a)\n    \\<le> ((1::'a) \\<stileturn> (1::'a)) *\n          (- q \\<squnion> - - q * top) \\<guillemotleft>\n          - q", "by (metis sup_right_isotone mult_right_isotone mult_1_right one_def post_pre_left_isotone pre_seq pre_test_promote test_dual_test top_right_mult_increasing)"], ["proof (state)\nthis:\n  ((1::'a) \\<stileturn> (1::'a)) * (- q \\<squnion> - - q) \\<guillemotleft>\n  (1::'a)\n  \\<le> ((1::'a) \\<stileturn> (1::'a)) *\n        (- q \\<squnion> - - q * top) \\<guillemotleft>\n        - q\n\ngoal (2 subgoals):\n 1. (1::'a) \\<stileturn> - q \\<le> Hd * (- q \\<squnion> - - q * top)\n 2. Hd * (- q \\<squnion> - - q * top) \\<le> (1::'a) \\<stileturn> - q", "finally"], ["proof (chain)\npicking this:\n  reflexive\n   (((1::'a) \\<stileturn> (1::'a)) *\n    (- q \\<squnion> - - q * top) \\<guillemotleft>\n    - q)", "show \"1\\<stileturn>-q \\<le> Hd*(-q\\<squnion>--q*top)\""], ["proof (prove)\nusing this:\n  reflexive\n   (((1::'a) \\<stileturn> (1::'a)) *\n    (- q \\<squnion> - - q * top) \\<guillemotleft>\n    - q)\n\ngoal (1 subgoal):\n 1. (1::'a) \\<stileturn> - q \\<le> Hd * (- q \\<squnion> - - q * top)", "using Hd_pre_post pre_post_galois tests_dual.sub_bot_def"], ["proof (prove)\nusing this:\n  reflexive\n   (((1::'a) \\<stileturn> (1::'a)) *\n    (- q \\<squnion> - - q * top) \\<guillemotleft>\n    - q)\n  Hd = (1::'a) \\<stileturn> (1::'a)\n  (- ?p \\<le> ?x \\<guillemotleft> - ?q) = (- ?p \\<stileturn> - ?q \\<le> ?x)\n  (1::'a) = - (THE x. \\<forall>y. x = - y * - - y)\n\ngoal (1 subgoal):\n 1. (1::'a) \\<stileturn> - q \\<le> Hd * (- q \\<squnion> - - q * top)", "by blast"], ["proof (state)\nthis:\n  (1::'a) \\<stileturn> - q \\<le> Hd * (- q \\<squnion> - - q * top)\n\ngoal (1 subgoal):\n 1. Hd * (- q \\<squnion> - - q * top) \\<le> (1::'a) \\<stileturn> - q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Hd * (- q \\<squnion> - - q * top) \\<le> (1::'a) \\<stileturn> - q", "show \"Hd*(-q\\<squnion>--q*top) \\<le> 1\\<stileturn>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hd * (- q \\<squnion> - - q * top) \\<le> (1::'a) \\<stileturn> - q", "by (simp add: pre_post_pre_one pre_post_one_def_1)"], ["proof (state)\nthis:\n  Hd * (- q \\<squnion> - - q * top) \\<le> (1::'a) \\<stileturn> - q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_post_def:\n  \"-p\\<stileturn>-q = -p*Hd*(-q\\<squnion>--q*top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - p \\<stileturn> - q = - p * Hd * (- q \\<squnion> - - q * top)", "by (simp add: pre_post_export mult_assoc pre_post_one_def)"], ["", "end"], ["", "end"]]}