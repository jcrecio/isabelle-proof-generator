{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Relative_Domain.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma d_plus_one: \n  \"d(x) \\<squnion> 1 = 1\"", "lemma d_zero:\n  \"d(bot) = bot\"", "lemma d_involutive:\n  \"d(d(x)) = d(x)\"", "lemma d_fixpoint:\n  \"(\\<exists>y . x = d(y)) \\<longleftrightarrow> x = d(x)\"", "lemma d_type:\n  \"\\<forall>P . (\\<forall>x . x = d(x) \\<longrightarrow> P(x)) \\<longleftrightarrow> (\\<forall>x . P(d(x)))\"", "lemma d_mult_sub:\n  \"d(x * y) \\<le> d(x)\"", "lemma d_sub_one:\n  \"x \\<le> 1 \\<Longrightarrow> x \\<le> d(x) \\<squnion> Z\"", "lemma d_one:\n  \"d(1) \\<squnion> Z = 1 \\<squnion> Z\"", "lemma d_strict:\n  \"d(x) = bot \\<longleftrightarrow> x \\<le> Z\"", "lemma d_isotone:\n  \"x \\<le> y \\<Longrightarrow> d(x) \\<le> d(y)\"", "lemma d_plus_left_upper_bound:\n  \"d(x) \\<le> d(x \\<squnion> y)\"", "lemma d_idempotent:\n  \"d(x) * d(x) = d(x)\"", "lemma d_least_left_preserver:\n  \"x \\<le> d(y) * x \\<squnion> Z \\<longleftrightarrow> d(x) \\<le> d(y)\"", "lemma d_weak_locality:\n  \"x * y \\<le> Z \\<longleftrightarrow> x * d(y) \\<le> Z\"", "lemma d_sup_closed:\n  \"d(d(x) \\<squnion> d(y)) = d(x) \\<squnion> d(y)\"", "lemma d_mult_closed:\n  \"d(d(x) * d(y)) = d(x) * d(y)\"", "lemma d_mult_left_lower_bound:\n  \"d(x) * d(y) \\<le> d(x)\"", "lemma d_mult_left_absorb_sup:\n  \"d(x) * (d(x) \\<squnion> d(y)) = d(x)\"", "lemma d_sup_left_absorb_mult:\n  \"d(x) \\<squnion> d(x) * d(y) = d(x)\"", "lemma d_commutative:\n  \"d(x) * d(y) = d(y) * d(x)\"", "lemma d_mult_greatest_lower_bound:\n  \"d(x) \\<le> d(y) * d(z) \\<longleftrightarrow> d(x) \\<le> d(y) \\<and> d(x) \\<le> d(z)\"", "lemma d_sup_left_dist_mult:\n  \"d(x) \\<squnion> d(y) * d(z) = (d(x) \\<squnion> d(y)) * (d(x) \\<squnion> d(z))\"", "lemma d_order:\n  \"d(x) \\<le> d(y) \\<longleftrightarrow> d(x) = d(x) * d(y)\"", "lemma Z_mult_decreasing:\n  \"Z * x \\<le> Z\"", "lemma d_below_d_one:\n  \"d(x) \\<le> d(1)\"", "lemma d_relative_Z:\n  \"d(x) * x \\<squnion> Z = x \\<squnion> Z\"", "lemma Z_left_zero_above_one:\n  \"1 \\<le> x \\<Longrightarrow> Z * x = Z\"", "lemma kat_4:\n  \"d(x) * y = d(x) * y * d(z) \\<Longrightarrow> d(x) * y \\<le> y * d(z)\"", "lemma kat_4_equiv:\n  \"d(x) * y = d(x) * y * d(z) \\<longleftrightarrow> d(x) * y \\<le> y * d(z)\"", "lemma kat_4_equiv_opp:\n  \"y * d(x) = d(z) * y * d(x) \\<longleftrightarrow> y * d(x) \\<le> d(z) * y\"", "lemma d_restrict_iff_1:\n  \"d(x) * y \\<le> z \\<longleftrightarrow> d(x) * y \\<le> d(x) * z\"", "lemma simp_dImage[simp]:\n  \"\\<exists>y . Rep_dImage x = d(y)\"", "lemma Z_top:\n  \"Z * top = Z\"", "lemma d_restrict_top:\n  \"x \\<le> d(x) * top \\<squnion> Z\"", "lemma d_restrict_iff:\n  \"(x \\<le> y \\<squnion> Z) \\<longleftrightarrow> (x \\<le> d(x) * y \\<squnion> Z)\"", "lemma a_complement_one:\n  \"--x \\<squnion> -x = 1\"", "lemma a_d_closed:\n  \"d(a(x)) = a(x)\"", "lemma a_below_one:\n  \"a(x) \\<le> 1\"", "lemma a_export_a:\n  \"a(a(x) * y) = d(x) \\<squnion> a(y)\"", "lemma a_sup_absorb:\n  \"(x \\<squnion> a(y)) * a(a(y)) = x * a(a(y))\"", "lemma a_greatest_left_absorber:\n  \"a(x) * y \\<le> Z \\<longleftrightarrow> a(x) \\<le> a(y)\"", "lemma a_plus_left_lower_bound:\n  \"a(x \\<squnion> y) \\<le> a(x)\"", "lemma a_plus_mult_d:\n  \"-(x * y) \\<squnion> -(x * --y) = -(x * --y)\"", "lemma a_mult_d_2:\n  \"a(x * y) = a(x * d(y))\"", "lemma a_3:\n  \"a(x) * a(y) * d(x \\<squnion> y) = bot\"", "lemma a_fixpoint:\n  \"\\<forall>x . (a(x) = x \\<longrightarrow> (\\<forall>y . y = bot))\"", "lemma a_strict:\n  \"a(x) = 1 \\<longleftrightarrow> x \\<le> Z\"", "lemma d_complement_zero:\n  \"d(x) * a(x) = bot\"", "lemma a_complement_zero:\n  \"a(x) * d(x) = bot\"", "lemma a_shunting_zero:\n  \"a(x) * d(y) = bot \\<longleftrightarrow> a(x) \\<le> a(y)\"", "lemma a_antitone:\n  \"x \\<le> y \\<Longrightarrow> a(y) \\<le> a(x)\"", "lemma a_mult_deMorgan:\n  \"a(a(x) * a(y)) = d(x \\<squnion> y)\"", "lemma a_mult_deMorgan_1:\n  \"a(a(x) * a(y)) = d(x) \\<squnion> d(y)\"", "lemma a_mult_deMorgan_2:\n  \"a(d(x) * d(y)) = a(x) \\<squnion> a(y)\"", "lemma a_plus_deMorgan:\n  \"a(a(x) \\<squnion> a(y)) = d(x) * d(y)\"", "lemma a_plus_deMorgan_1:\n  \"a(d(x) \\<squnion> d(y)) = a(x) * a(y)\"", "lemma a_mult_left_upper_bound:\n  \"a(x) \\<le> a(x * y)\"", "lemma d_a_closed:\n  \"a(d(x)) = a(x)\"", "lemma a_export_d:\n  \"a(d(x) * y) = a(x) \\<squnion> a(y)\"", "lemma a_7:\n  \"d(x) * a(d(y) \\<squnion> d(z)) = d(x) * a(y) * a(z)\"", "lemma d_a_shunting:\n  \"d(x) * a(y) \\<le> d(z) \\<longleftrightarrow> d(x) \\<le> d(z) \\<squnion> d(y)\"", "lemma d_d_shunting:\n  \"d(x) * d(y) \\<le> d(z) \\<longleftrightarrow> d(x) \\<le> d(z) \\<squnion> a(y)\"", "lemma d_cancellation_1:\n  \"d(x) \\<le> d(y) \\<squnion> (d(x) * a(y))\"", "lemma d_cancellation_2:\n  \"(d(z) \\<squnion> d(y)) * a(y) \\<le> d(z)\"", "lemma a_sup_closed:\n  \"d(a(x) \\<squnion> a(y)) = a(x) \\<squnion> a(y)\"", "lemma a_mult_closed:\n  \"d(a(x) * a(y)) = a(x) * a(y)\"", "lemma d_a_shunting_zero:\n  \"d(x) * a(y) = bot \\<longleftrightarrow> d(x) \\<le> d(y)\"", "lemma d_d_shunting_zero:\n  \"d(x) * d(y) = bot \\<longleftrightarrow> d(x) \\<le> a(y)\"", "lemma d_compl_intro:\n  \"d(x) \\<squnion> d(y) = d(x) \\<squnion> a(x) * d(y)\"", "lemma a_compl_intro:\n  \"a(x) \\<squnion> a(y) = a(x) \\<squnion> d(x) * a(y)\"", "lemma kat_2:\n  \"y * a(z) \\<le> a(x) * y \\<Longrightarrow> d(x) * y * a(z) = bot\"", "lemma kat_2_equiv:\n  \"y * a(z) \\<le> a(x) * y \\<longleftrightarrow> d(x) * y * a(z) = bot\"", "lemma kat_3_equiv_opp:\n  \"a(z) * y * d(x) = bot \\<longleftrightarrow> y * d(x) = d(z) * y * d(x)\"", "lemma kat_3_equiv_opp_2:\n  \"d(z) * y * a(x) = bot \\<longleftrightarrow> y * a(x) = a(z) * y * a(x)\"", "lemma kat_equiv_6:\n  \"d(x) * y * a(z) = d(x) * y * bot \\<longleftrightarrow> d(x) * y * a(z) \\<le> y * bot\"", "lemma d_one_one:\n  \"d(1) = 1\"", "lemma case_split_left_sup:\n  \"-p * x \\<le> y \\<and> --p * x \\<le> z \\<Longrightarrow> x \\<le> y \\<squnion> z\"", "lemma test_mult_left_sub_dist_shunt:\n  \"-p * (--p * x \\<squnion> Z) \\<le> Z\"", "lemma test_mult_left_dist_shunt:\n  \"-p * (--p * x \\<squnion> Z) = -p * Z\"", "lemma simp_aImage[simp]:\n  \"\\<exists>y . Rep_aImage x = a(y)\"", "lemma a_top:\n  \"a(top) = bot\"", "lemma d_top:\n  \"d(top) = 1\"", "lemma shunting_top_1:\n  \"-p * x \\<le> y \\<Longrightarrow> x \\<le> --p * top \\<squnion> y\"", "lemma shunting_Z:\n  \"-p * x \\<le> Z \\<longleftrightarrow> x \\<le> --p * top \\<squnion> Z\"", "lemma kat_3:\n  \"d(x) * y * a(z) = bot \\<Longrightarrow> d(x) * y = d(x) * y * d(z)\"", "lemma a_a_below:\n  \"a(a(x)) * y \\<le> y\"", "lemma kat_equiv_5:\n  \"d(x) * y \\<le> y * d(z) \\<longleftrightarrow> d(x) * y * a(z) = d(x) * y * bot\"", "lemma case_split_right_sup:\n  \"x * -p \\<le> y \\<Longrightarrow> x * --p \\<le> z \\<Longrightarrow> x \\<le> y \\<squnion> z\"", "lemma shunting_top:\n  \"-p * x \\<le> y \\<longleftrightarrow> x \\<le> --p * top \\<squnion> y\""], "translations": [["", "lemma d_plus_one: \n  \"d(x) \\<squnion> 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<squnion> (1::'a) = (1::'a)", "by (simp add: d_below_one sup_absorb2)"], ["", "text \\<open>Theorem 44.2\\<close>"], ["", "lemma d_zero:\n  \"d(bot) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d bot = bot", "by (metis d_Z d_export mult_left_zero)"], ["", "text \\<open>Theorem 44.3\\<close>"], ["", "lemma d_involutive:\n  \"d(d(x)) = d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d x) = d x", "by (metis d_mult_d mult_left_one)"], ["", "lemma d_fixpoint:\n  \"(\\<exists>y . x = d(y)) \\<longleftrightarrow> x = d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y. x = d y) = (x = d x)", "using d_involutive"], ["proof (prove)\nusing this:\n  d (d ?x) = d ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>y. x = d y) = (x = d x)", "by auto"], ["", "lemma d_type:\n  \"\\<forall>P . (\\<forall>x . x = d(x) \\<longrightarrow> P(x)) \\<longleftrightarrow> (\\<forall>x . P(d(x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P.\n       (\\<forall>x. x = d x \\<longrightarrow> P x) = (\\<forall>x. P (d x))", "by (metis d_involutive)"], ["", "text \\<open>Theorem 44.4\\<close>"], ["", "lemma d_mult_sub:\n  \"d(x * y) \\<le> d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x * y) \\<le> d x", "by (smt (verit, ccfv_threshold) d_plus_one d_dist_sup d_mult_d le_iff_sup mult.right_neutral mult_left_sub_dist_sup_right sup_commute)"], ["", "lemma d_sub_one:\n  \"x \\<le> 1 \\<Longrightarrow> x \\<le> d(x) \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> x \\<le> d x \\<squnion> Z", "by (metis sup_left_isotone d_restrict mult_right_isotone mult_1_right order_trans)"], ["", "lemma d_one:\n  \"d(1) \\<squnion> Z = 1 \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (1::'a) \\<squnion> Z = (1::'a) \\<squnion> Z", "by (meson d_sub_one d_below_one order.trans preorder_one_closed sup.cobounded1 sup_same_context)"], ["", "text \\<open>Theorem 44.8\\<close>"], ["", "lemma d_strict:\n  \"d(x) = bot \\<longleftrightarrow> x \\<le> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x = bot) = (x \\<le> Z)", "by (metis sup_commute sup_bot_right d_Z d_dist_sup d_restrict le_iff_sup mult_left_zero)"], ["", "text \\<open>Theorem 44.1\\<close>"], ["", "lemma d_isotone:\n  \"x \\<le> y \\<Longrightarrow> d(x) \\<le> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> d x \\<le> d y", "using d_dist_sup sup_right_divisibility"], ["proof (prove)\nusing this:\n  d (?x \\<squnion> ?y) = d ?x \\<squnion> d ?y\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> d x \\<le> d y", "by force"], ["", "lemma d_plus_left_upper_bound:\n  \"d(x) \\<le> d(x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<le> d (x \\<squnion> y)", "by (simp add: d_isotone)"], ["", "lemma d_idempotent:\n  \"d(x) * d(x) = d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent (d x)", "by (smt (verit, ccfv_threshold) d_involutive d_mult_sub d_Z d_dist_sup d_export d_restrict le_iff_sup sup_bot_left sup_commute)"], ["", "text \\<open>Theorem 44.12\\<close>"], ["", "lemma d_least_left_preserver:\n  \"x \\<le> d(y) * x \\<squnion> Z \\<longleftrightarrow> d(x) \\<le> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> d y * x \\<squnion> Z) = (d x \\<le> d y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<le> d y * x \\<squnion> Z \\<Longrightarrow> d x \\<le> d y\n 2. d x \\<le> d y \\<Longrightarrow> x \\<le> d y * x \\<squnion> Z", "apply (smt (z3) comm_monoid.comm_neutral d_involutive d_mult_sub d_plus_left_upper_bound d_Z d_dist_sup order_trans sup_absorb2 sup_bot.comm_monoid_axioms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<le> d y \\<Longrightarrow> x \\<le> d y * x \\<squnion> Z", "by (smt (verit, del_insts) d_restrict mult_right_dist_sup sup.cobounded1 sup.orderE sup_assoc sup_commute)"], ["", "text \\<open>Theorem 44.9\\<close>"], ["", "lemma d_weak_locality:\n  \"x * y \\<le> Z \\<longleftrightarrow> x * d(y) \\<le> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<le> Z) = (x * d y \\<le> Z)", "by (metis d_mult_d d_strict)"], ["", "lemma d_sup_closed:\n  \"d(d(x) \\<squnion> d(y)) = d(x) \\<squnion> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d x \\<squnion> d y) = d x \\<squnion> d y", "by (simp add: d_involutive d_dist_sup)"], ["", "lemma d_mult_closed:\n  \"d(d(x) * d(y)) = d(x) * d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d x * d y) = d x * d y", "using d_export d_mult_d"], ["proof (prove)\nusing this:\n  d (d ?x * ?y) = d ?x * d ?y\n  d (?x * ?y) = d (?x * d ?y)\n\ngoal (1 subgoal):\n 1. d (d x * d y) = d x * d y", "by auto"], ["", "lemma d_mult_left_lower_bound:\n  \"d(x) * d(y) \\<le> d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * d y \\<le> d x", "by (metis d_export d_involutive d_mult_sub)"], ["", "lemma d_mult_left_absorb_sup:\n  \"d(x) * (d(x) \\<squnion> d(y)) = d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * (d x \\<squnion> d y) = d x", "by (smt d_sup_closed d_export d_idempotent d_involutive d_mult_sub order.eq_iff mult_left_sub_dist_sup_left)"], ["", "lemma d_sup_left_absorb_mult:\n  \"d(x) \\<squnion> d(x) * d(y) = d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<squnion> d x * d y = d x", "using d_mult_left_lower_bound sup.absorb_iff1"], ["proof (prove)\nusing this:\n  d ?x * d ?y \\<le> d ?x\n  (?b \\<le> ?a) = (?a \\<squnion> ?b = ?a)\n\ngoal (1 subgoal):\n 1. d x \\<squnion> d x * d y = d x", "by auto"], ["", "lemma d_commutative:\n  \"d(x) * d(y) = d(y) * d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * d y = d y * d x", "by (metis sup_commute order.antisym d_sup_left_absorb_mult d_below_one d_export d_mult_left_absorb_sup mult_assoc mult_left_isotone mult_left_one)"], ["", "lemma d_mult_greatest_lower_bound:\n  \"d(x) \\<le> d(y) * d(z) \\<longleftrightarrow> d(x) \\<le> d(y) \\<and> d(x) \\<le> d(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x \\<le> d y * d z) = (d x \\<le> d y \\<and> d x \\<le> d z)", "by (metis d_commutative d_idempotent d_mult_left_lower_bound mult_isotone order_trans)"], ["", "lemma d_sup_left_dist_mult:\n  \"d(x) \\<squnion> d(y) * d(z) = (d(x) \\<squnion> d(y)) * (d(x) \\<squnion> d(z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<squnion> d y * d z = (d x \\<squnion> d y) * (d x \\<squnion> d z)", "by (metis sup_assoc d_commutative d_dist_sup d_idempotent d_mult_left_absorb_sup mult_right_dist_sup)"], ["", "lemma d_order:\n  \"d(x) \\<le> d(y) \\<longleftrightarrow> d(x) = d(x) * d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x \\<le> d y) = (d x = d x * d y)", "by (metis d_mult_greatest_lower_bound d_mult_left_absorb_sup le_iff_sup order_refl)"], ["", "text \\<open>Theorem 44.6\\<close>"], ["", "lemma Z_mult_decreasing:\n  \"Z * x \\<le> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z * x \\<le> Z", "by (metis d_mult_sub bot.extremum d_strict order.eq_iff)"], ["", "text \\<open>Theorem 44.5\\<close>"], ["", "lemma d_below_d_one:\n  \"d(x) \\<le> d(1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<le> d (1::'a)", "by (metis d_mult_sub mult_left_one)"], ["", "text \\<open>Theorem 44.7\\<close>"], ["", "lemma d_relative_Z:\n  \"d(x) * x \\<squnion> Z = x \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * x \\<squnion> Z = x \\<squnion> Z", "by (metis sup_ge1 sup_same_context d_below_one d_restrict mult_isotone mult_left_one)"], ["", "lemma Z_left_zero_above_one:\n  \"1 \\<le> x \\<Longrightarrow> Z * x = Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> Z * x = Z", "by (metis Z_mult_decreasing order.eq_iff mult_right_isotone mult_1_right)"], ["", "text \\<open>Theorem 44.11\\<close>"], ["", "lemma kat_4:\n  \"d(x) * y = d(x) * y * d(z) \\<Longrightarrow> d(x) * y \\<le> y * d(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y = d x * y * d z \\<Longrightarrow> d x * y \\<le> y * d z", "by (metis d_below_one mult_left_isotone mult_left_one)"], ["", "lemma kat_4_equiv:\n  \"d(x) * y = d(x) * y * d(z) \\<longleftrightarrow> d(x) * y \\<le> y * d(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * y = d x * y * d z) = (d x * y \\<le> y * d z)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d x * y = d x * y * d z \\<Longrightarrow> d x * y \\<le> y * d z\n 2. d x * y \\<le> y * d z \\<Longrightarrow> d x * y = d x * y * d z", "apply (simp add: kat_4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y \\<le> y * d z \\<Longrightarrow> d x * y = d x * y * d z", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d x * y \\<le> y * d z \\<Longrightarrow> d x * y \\<le> d x * y * d z\n 2. d x * y \\<le> y * d z \\<Longrightarrow> d x * y * d z \\<le> d x * y", "apply (metis d_idempotent mult_assoc mult_right_isotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y \\<le> y * d z \\<Longrightarrow> d x * y * d z \\<le> d x * y", "by (metis d_below_one mult_right_isotone mult_1_right)"], ["", "lemma kat_4_equiv_opp:\n  \"y * d(x) = d(z) * y * d(x) \\<longleftrightarrow> y * d(x) \\<le> d(z) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * d x = d z * y * d x) = (y * d x \\<le> d z * y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y * d x = d z * y * d x \\<Longrightarrow> y * d x \\<le> d z * y\n 2. y * d x \\<le> d z * y \\<Longrightarrow> y * d x = d z * y * d x", "using d_below_one mult_right_isotone"], ["proof (prove)\nusing this:\n  coreflexive (d ?x)\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (2 subgoals):\n 1. y * d x = d z * y * d x \\<Longrightarrow> y * d x \\<le> d z * y\n 2. y * d x \\<le> d z * y \\<Longrightarrow> y * d x = d z * y * d x", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. y * d x \\<le> d z * y \\<Longrightarrow> y * d x = d z * y * d x", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y * d x \\<le> d z * y \\<Longrightarrow> y * d x \\<le> d z * y * d x\n 2. y * d x \\<le> d z * y \\<Longrightarrow> d z * y * d x \\<le> y * d x", "apply (metis d_idempotent mult_assoc mult_left_isotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y * d x \\<le> d z * y \\<Longrightarrow> d z * y * d x \\<le> y * d x", "by (metis d_below_one mult_left_isotone mult_left_one)"], ["", "text \\<open>Theorem 44.10\\<close>"], ["", "lemma d_restrict_iff_1:\n  \"d(x) * y \\<le> z \\<longleftrightarrow> d(x) * y \\<le> d(x) * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * y \\<le> z) = (d x * y \\<le> d x * z)", "by (smt (verit, del_insts) d_below_one d_idempotent mult_assoc mult_left_isotone mult_left_one mult_right_isotone order_trans)"], ["", "(* independence of axioms, checked in relative_domain_semiring without the respective axiom:\nlemma d_restrict : \"x \\<le> d(x) * x \\<squnion> Z\" nitpick [expect=genuine,card=2] oops\nlemma d_mult_d   : \"d(x * y) = d(x * d(y))\" nitpick [expect=genuine,card=3] oops\nlemma d_below_one: \"d(x) \\<le> 1\" nitpick [expect=genuine,card=3] oops\nlemma d_Z        : \"d(Z) = bot\" nitpick [expect=genuine,card=2] oops\nlemma d_dist_sup : \"d(x \\<squnion> y) = d(x) \\<squnion> d(y)\" nitpick [expect=genuine,card=3] oops\nlemma d_export   : \"d(d(x) * y) = d(x) * d(y)\" nitpick [expect=genuine,card=5] oops\n*)"], ["", "end"], ["", "typedef (overloaded) 'a dImage = \"{ x::'a::relative_domain_semiring . (\\<exists>y::'a . x = d(y)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {x. \\<exists>y. x = d y}", "by auto"], ["", "lemma simp_dImage[simp]:\n  \"\\<exists>y . Rep_dImage x = d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. Rep_dImage x = d y", "using Rep_dImage"], ["proof (prove)\nusing this:\n  Rep_dImage ?x \\<in> {x. \\<exists>y. x = d y}\n\ngoal (1 subgoal):\n 1. \\<exists>y. Rep_dImage x = d y", "by simp"], ["", "setup_lifting type_definition_dImage"], ["", "text \\<open>Theorem 44\\<close>"], ["", "instantiation dImage :: (relative_domain_semiring) bounded_distrib_lattice\nbegin"], ["", "lift_definition sup_dImage :: \"'a dImage \\<Rightarrow> 'a dImage \\<Rightarrow> 'a dImage\" is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>y. a1 = d y; \\<exists>y. a2 = d y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a1 \\<squnion> a2 = d y", "by (metis d_dist_sup)"], ["", "lift_definition inf_dImage :: \"'a dImage \\<Rightarrow> 'a dImage \\<Rightarrow> 'a dImage\" is times"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>y. a1 = d y; \\<exists>y. a2 = d y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a1 * a2 = d y", "by (metis d_export)"], ["", "lift_definition bot_dImage :: \"'a dImage\" is bot"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. bot = d y", "by (metis d_zero)"], ["", "lift_definition top_dImage :: \"'a dImage\" is \"d(1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. d (1::'a) = d y", "by auto"], ["", "lift_definition less_eq_dImage :: \"'a dImage \\<Rightarrow> 'a dImage \\<Rightarrow> bool\" is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_dImage :: \"'a dImage \\<Rightarrow> 'a dImage \\<Rightarrow> bool\" is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dImage, bounded_distrib_lattice_class)", "apply intro_classes"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 13 subgoals...", "apply (simp add: less_dImage.rep_eq less_eq_dImage.rep_eq less_le_not_le)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 12 subgoals...", "apply (simp add: less_eq_dImage.rep_eq)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 11 subgoals...", "using less_eq_dImage.rep_eq"], ["proof (prove)\nusing this:\n  (?x \\<le> ?xa) = (Rep_dImage ?x \\<le> Rep_dImage ?xa)\n\ngoal (11 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 11 subgoals...", "apply simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (simp add: Rep_dImage_inject less_eq_dImage.rep_eq)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (metis (mono_tags) d_involutive d_mult_sub inf_dImage.rep_eq less_eq_dImage.rep_eq simp_dImage)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (metis (mono_tags) d_mult_greatest_lower_bound inf_dImage.rep_eq less_eq_dImage.rep_eq order_refl simp_dImage)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (metis (mono_tags) d_mult_greatest_lower_bound inf_dImage.rep_eq less_eq_dImage.rep_eq simp_dImage)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (simp add: less_eq_dImage.rep_eq sup_dImage.rep_eq)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (simp add: less_eq_dImage.rep_eq sup_dImage.rep_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (simp add: less_eq_dImage.rep_eq sup_dImage.rep_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (simp add: bot_dImage.rep_eq less_eq_dImage.rep_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "apply (smt (z3) d_below_d_one less_eq_dImage.rep_eq simp_dImage top_dImage.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "by (smt (z3) inf_dImage.rep_eq sup_dImage.rep_eq simp_dImage Rep_dImage_inject d_sup_left_dist_mult)"], ["", "end"], ["", "class bounded_relative_domain_semiring = relative_domain_semiring + bounded_idempotent_left_semiring\nbegin"], ["", "lemma Z_top:\n  \"Z * top = Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector Z", "by (simp add: Z_left_zero_above_one)"], ["", "lemma d_restrict_top:\n  \"x \\<le> d(x) * top \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> d x * top \\<squnion> Z", "by (metis sup_left_isotone d_restrict mult_right_isotone order_trans top_greatest)"], ["", "(*\nlemma d_one_one: \"d(1) = 1\" nitpick [expect=genuine,card=2] oops\n*)"], ["", "end"], ["", "class relative_domain_semiring_split = relative_domain_semiring +\n  assumes split_Z: \"x * (y \\<squnion> Z) \\<le> x * y \\<squnion> Z\"\nbegin"], ["", "lemma d_restrict_iff:\n  \"(x \\<le> y \\<squnion> Z) \\<longleftrightarrow> (x \\<le> d(x) * y \\<squnion> Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y \\<squnion> Z) = (x \\<le> d x * y \\<squnion> Z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<le> y \\<squnion> Z) = (x \\<le> d x * y \\<squnion> Z)", "have \"x \\<le> y \\<squnion> Z \\<longrightarrow> x \\<le> d(x) * (y \\<squnion> Z) \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> Z \\<longrightarrow>\n    x \\<le> d x * (y \\<squnion> Z) \\<squnion> Z", "by (smt sup_left_isotone d_restrict le_iff_sup mult_left_sub_dist_sup_left order_trans)"], ["proof (state)\nthis:\n  x \\<le> y \\<squnion> Z \\<longrightarrow>\n  x \\<le> d x * (y \\<squnion> Z) \\<squnion> Z\n\ngoal (1 subgoal):\n 1. (x \\<le> y \\<squnion> Z) = (x \\<le> d x * y \\<squnion> Z)", "hence \"x \\<le> y \\<squnion> Z \\<longrightarrow> x \\<le> d(x) * y \\<squnion> Z\""], ["proof (prove)\nusing this:\n  x \\<le> y \\<squnion> Z \\<longrightarrow>\n  x \\<le> d x * (y \\<squnion> Z) \\<squnion> Z\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> Z \\<longrightarrow> x \\<le> d x * y \\<squnion> Z", "by (meson le_supI order_lesseq_imp split_Z sup.cobounded2)"], ["proof (state)\nthis:\n  x \\<le> y \\<squnion> Z \\<longrightarrow> x \\<le> d x * y \\<squnion> Z\n\ngoal (1 subgoal):\n 1. (x \\<le> y \\<squnion> Z) = (x \\<le> d x * y \\<squnion> Z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y \\<squnion> Z \\<longrightarrow> x \\<le> d x * y \\<squnion> Z\n\ngoal (1 subgoal):\n 1. (x \\<le> y \\<squnion> Z) = (x \\<le> d x * y \\<squnion> Z)", "by (meson d_restrict_iff_1 le_supI mult_left_sub_dist_sup_left order_lesseq_imp sup.cobounded2)"], ["proof (state)\nthis:\n  (x \\<le> y \\<squnion> Z) = (x \\<le> d x * y \\<squnion> Z)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class relative_antidomain_semiring = idempotent_left_semiring + dom + Z + uminus +\n  assumes a_restrict  : \"-x * x \\<le> Z\"\n  assumes a_mult_d    : \"-(x * y) = -(x * --y)\"\n  assumes a_complement: \"-x * --x = bot\"\n  assumes a_Z         : \"-Z = 1\"\n  assumes a_export    : \"-(--x * y) = -x \\<squnion> -y\"\n  assumes a_dist_sup  : \"-(x \\<squnion> y) = -x * -y\"\n  assumes d_def       : \"d(x) = --x\"\nbegin"], ["", "notation\n  uminus (\"a\")"], ["", "text \\<open>Theorem 45.7\\<close>"], ["", "lemma a_complement_one:\n  \"--x \\<squnion> -x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x) \\<squnion> a x = (1::'a)", "by (metis a_Z a_complement a_export a_mult_d mult_left_one)"], ["", "text \\<open>Theorem 45.5 and Theorem 45.6\\<close>"], ["", "lemma a_d_closed:\n  \"d(a(x)) = a(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (a x) = a x", "by (metis a_mult_d d_def mult_left_one)"], ["", "lemma a_below_one:\n  \"a(x) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (a x)", "using a_complement_one sup_right_divisibility"], ["proof (prove)\nusing this:\n  a (a ?x) \\<squnion> a ?x = (1::'a)\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n\ngoal (1 subgoal):\n 1. coreflexive (a x)", "by auto"], ["", "lemma a_export_a:\n  \"a(a(x) * y) = d(x) \\<squnion> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x * y) = d x \\<squnion> a y", "by (metis a_d_closed a_export d_def)"], ["", "lemma a_sup_absorb:\n  \"(x \\<squnion> a(y)) * a(a(y)) = x * a(a(y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> a y) * a (a y) = x * a (a y)", "by (simp add: a_complement mult_right_dist_sup)"], ["", "text \\<open>Theorem 45.10\\<close>"], ["", "lemma a_greatest_left_absorber:\n  \"a(x) * y \\<le> Z \\<longleftrightarrow> a(x) \\<le> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a x * y \\<le> Z) = (a x \\<le> a y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a x * y \\<le> Z \\<Longrightarrow> a x \\<le> a y\n 2. a x \\<le> a y \\<Longrightarrow> a x * y \\<le> Z", "apply (smt a_Z a_sup_absorb a_dist_sup a_export_a a_mult_d sup_commute d_def le_iff_sup mult_left_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<le> a y \\<Longrightarrow> a x * y \\<le> Z", "by (meson a_restrict mult_isotone order.refl order_trans)"], ["", "lemma a_plus_left_lower_bound:\n  \"a(x \\<squnion> y) \\<le> a(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (x \\<squnion> y) \\<le> a x", "by (metis a_greatest_left_absorber a_restrict sup_commute mult_left_sub_dist_sup_right order_trans)"], ["", "text \\<open>Theorem 45.2\\<close>"], ["", "subclass relative_domain_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.relative_domain_semiring Z (1::'a) (*) (\\<squnion>) (\\<le>) (<)\n     bot d", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x. x \\<le> d x * x \\<squnion> Z\n 2. \\<And>x y. d (x * y) = d (x * d y)\n 3. \\<And>x. coreflexive (d x)\n 4. d Z = bot\n 5. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y\n 6. \\<And>x y. d (d x * y) = d x * d y", "apply (smt (verit) a_Z a_complement_one a_restrict sup_commute sup_ge1 case_split_left d_def order_trans)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. d (x * y) = d (x * d y)\n 2. \\<And>x. coreflexive (d x)\n 3. d Z = bot\n 4. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y\n 5. \\<And>x y. d (d x * y) = d x * d y", "using a_mult_d d_def"], ["proof (prove)\nusing this:\n  a (?x * ?y) = a (?x * a (a ?y))\n  d ?x = a (a ?x)\n\ngoal (5 subgoals):\n 1. \\<And>x y. d (x * y) = d (x * d y)\n 2. \\<And>x. coreflexive (d x)\n 3. d Z = bot\n 4. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y\n 5. \\<And>x y. d (d x * y) = d x * d y", "apply force"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. coreflexive (d x)\n 2. d Z = bot\n 3. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y\n 4. \\<And>x y. d (d x * y) = d x * d y", "apply (simp add: a_below_one d_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. d Z = bot\n 2. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y\n 3. \\<And>x y. d (d x * y) = d x * d y", "apply (metis a_Z a_complement d_def mult_left_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y\n 2. \\<And>x y. d (d x * y) = d x * d y", "apply (simp add: a_export_a a_dist_sup d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. d (d x * y) = d x * d y", "using a_dist_sup a_export d_def"], ["proof (prove)\nusing this:\n  a (?x \\<squnion> ?y) = a ?x * a ?y\n  a (a (a ?x) * ?y) = a ?x \\<squnion> a ?y\n  d ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x y. d (d x * y) = d x * d y", "by auto"], ["", "text \\<open>Theorem 45.1\\<close>"], ["", "subclass tests"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.tests (1::'a) (*) a (\\<squnion>) bot (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y z. a x * (a y * a z) = a x * a y * a z\n 2. \\<And>x y. a x * a y = a y * a x\n 3. \\<And>x y. a x = a (a (a x) * a y) * a (a (a x) * a (a y))\n 4. \\<And>x y. a x * a y = a (a (a x * a y))\n 5. bot = (THE x. \\<forall>y. x = a y * a (a y))\n 6. (1::'a) = a bot\n 7. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 8. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 9. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "apply (simp add: mult_assoc)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y. a x * a y = a y * a x\n 2. \\<And>x y. a x = a (a (a x) * a y) * a (a (a x) * a (a y))\n 3. \\<And>x y. a x * a y = a (a (a x * a y))\n 4. bot = (THE x. \\<forall>y. x = a y * a (a y))\n 5. (1::'a) = a bot\n 6. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 7. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 8. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "apply (metis a_dist_sup sup_commute)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y. a x = a (a (a x) * a y) * a (a (a x) * a (a y))\n 2. \\<And>x y. a x * a y = a (a (a x * a y))\n 3. bot = (THE x. \\<forall>y. x = a y * a (a y))\n 4. (1::'a) = a bot\n 5. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 6. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 7. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "apply (smt a_complement a_d_closed a_export_a sup_bot_right d_sup_left_dist_mult)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y. a x * a y = a (a (a x * a y))\n 2. bot = (THE x. \\<forall>y. x = a y * a (a y))\n 3. (1::'a) = a bot\n 4. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 5. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 6. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "apply (metis a_d_closed a_dist_sup d_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. bot = (THE x. \\<forall>y. x = a y * a (a y))\n 2. (1::'a) = a bot\n 3. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 4. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 5. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "apply (rule the_equality[THEN sym])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<forall>y. bot = a y * a (a y)\n 2. \\<And>x. \\<forall>y. x = a y * a (a y) \\<Longrightarrow> x = bot\n 3. (1::'a) = a bot\n 4. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 5. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 6. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "apply (simp add: a_complement)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. \\<forall>y. x = a y * a (a y) \\<Longrightarrow> x = bot\n 2. (1::'a) = a bot\n 3. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 4. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 5. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "apply (simp add: a_complement)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (1::'a) = a bot\n 2. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 3. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 4. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "using a_d_closed a_Z d_Z d_def"], ["proof (prove)\nusing this:\n  d (a ?x) = a ?x\n  a Z = (1::'a)\n  d Z = bot\n  d ?x = a (a ?x)\n\ngoal (4 subgoals):\n 1. (1::'a) = a bot\n 2. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 3. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 4. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "apply force"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 2. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 3. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "using a_export a_mult_d"], ["proof (prove)\nusing this:\n  a (a (a ?x) * ?y) = a ?x \\<squnion> a ?y\n  a (?x * ?y) = a (?x * a (a ?y))\n\ngoal (3 subgoals):\n 1. \\<And>x y. a x \\<squnion> a y = a (a (a x) * a (a y))\n 2. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 3. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (a x \\<le> a y) = (a x * a y = a x)\n 2. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "apply (metis a_d_closed d_order)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (a x < a y) = (a x \\<le> a y \\<and> \\<not> a y \\<le> a x)", "by (simp add: less_le_not_le)"], ["", "lemma a_plus_mult_d:\n  \"-(x * y) \\<squnion> -(x * --y) = -(x * --y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (x * y) \\<squnion> a (x * a (a y)) = a (x * a (a y))", "using a_mult_d"], ["proof (prove)\nusing this:\n  a (?x * ?y) = a (?x * a (a ?y))\n\ngoal (1 subgoal):\n 1. a (x * y) \\<squnion> a (x * a (a y)) = a (x * a (a y))", "by auto"], ["", "lemma a_mult_d_2:\n  \"a(x * y) = a(x * d(y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (x * y) = a (x * d y)", "using a_mult_d d_def"], ["proof (prove)\nusing this:\n  a (?x * ?y) = a (?x * a (a ?y))\n  d ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. a (x * y) = a (x * d y)", "by auto"], ["", "lemma a_3:\n  \"a(x) * a(y) * d(x \\<squnion> y) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x * a y * d (x \\<squnion> y) = bot", "by (metis a_complement a_dist_sup d_def)"], ["", "lemma a_fixpoint:\n  \"\\<forall>x . (a(x) = x \\<longrightarrow> (\\<forall>y . y = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. a x = x \\<longrightarrow> (\\<forall>y. y = bot)", "by (metis a_complement_one mult_1_left mult_left_zero order.refl sup.order_iff tests_dual.one_def)"], ["", "text \\<open>Theorem 45.9\\<close>"], ["", "lemma a_strict:\n  \"a(x) = 1 \\<longleftrightarrow> x \\<le> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a x = (1::'a)) = (x \\<le> Z)", "by (metis a_Z d_def d_strict order.refl tests_dual.sba_dual.double_negation)"], ["", "lemma d_complement_zero:\n  \"d(x) * a(x) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * a x = bot", "by (simp add: d_def tests_dual.sub_commutative)"], ["", "lemma a_complement_zero:\n  \"a(x) * d(x) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x * d x = bot", "by (simp add: d_def)"], ["", "lemma a_shunting_zero:\n  \"a(x) * d(y) = bot \\<longleftrightarrow> a(x) \\<le> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a x * d y = bot) = (a x \\<le> a y)", "by (simp add: d_def tests_dual.sba_dual.less_eq_inf_bot)"], ["", "lemma a_antitone:\n  \"x \\<le> y \\<Longrightarrow> a(y) \\<le> a(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> a y \\<le> a x", "using a_plus_left_lower_bound sup_commute sup_right_divisibility"], ["proof (prove)\nusing this:\n  a (?x \\<squnion> ?y) \\<le> a ?x\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> a y \\<le> a x", "by fastforce"], ["", "lemma a_mult_deMorgan:\n  \"a(a(x) * a(y)) = d(x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x * a y) = d (x \\<squnion> y)", "by (simp add: a_dist_sup d_def)"], ["", "lemma a_mult_deMorgan_1:\n  \"a(a(x) * a(y)) = d(x) \\<squnion> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x * a y) = d x \\<squnion> d y", "by (simp add: a_mult_deMorgan d_dist_sup)"], ["", "lemma a_mult_deMorgan_2:\n  \"a(d(x) * d(y)) = a(x) \\<squnion> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (d x * d y) = a x \\<squnion> a y", "using a_export d_def"], ["proof (prove)\nusing this:\n  a (a (a ?x) * ?y) = a ?x \\<squnion> a ?y\n  d ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. a (d x * d y) = a x \\<squnion> a y", "by auto"], ["", "lemma a_plus_deMorgan:\n  \"a(a(x) \\<squnion> a(y)) = d(x) * d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x \\<squnion> a y) = d x * d y", "by (simp add: a_dist_sup d_def)"], ["", "lemma a_plus_deMorgan_1:\n  \"a(d(x) \\<squnion> d(y)) = a(x) * a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (d x \\<squnion> d y) = a x * a y", "by (simp add: a_dist_sup d_def)"], ["", "text \\<open>Theorem 45.8\\<close>"], ["", "lemma a_mult_left_upper_bound:\n  \"a(x) \\<le> a(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<le> a (x * y)", "using a_shunting_zero d_def d_mult_sub tests_dual.less_eq_sup_top"], ["proof (prove)\nusing this:\n  (a ?x * d ?y = bot) = (a ?x \\<le> a ?y)\n  d ?x = a (a ?x)\n  d (?x * ?y) \\<le> d ?x\n  (a ?y \\<le> a ?x) = (a (a ?x) * a ?y = bot)\n\ngoal (1 subgoal):\n 1. a x \\<le> a (x * y)", "by auto"], ["", "text \\<open>Theorem 45.6\\<close>"], ["", "lemma d_a_closed:\n  \"a(d(x)) = a(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (d x) = a x", "by (simp add: d_def)"], ["", "lemma a_export_d:\n  \"a(d(x) * y) = a(x) \\<squnion> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (d x * y) = a x \\<squnion> a y", "by (simp add: a_export d_def)"], ["", "lemma a_7:\n  \"d(x) * a(d(y) \\<squnion> d(z)) = d(x) * a(y) * a(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * a (d y \\<squnion> d z) = d x * a y * a z", "by (simp add: a_plus_deMorgan_1 mult_assoc)"], ["", "lemma d_a_shunting:\n  \"d(x) * a(y) \\<le> d(z) \\<longleftrightarrow> d(x) \\<le> d(z) \\<squnion> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * a y \\<le> d z) = (d x \\<le> d z \\<squnion> d y)", "by (simp add: d_def tests_dual.sba_dual.shunting_right)"], ["", "lemma d_d_shunting:\n  \"d(x) * d(y) \\<le> d(z) \\<longleftrightarrow> d(x) \\<le> d(z) \\<squnion> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * d y \\<le> d z) = (d x \\<le> d z \\<squnion> a y)", "by (simp add: d_def tests_dual.sba_dual.shunting_right)"], ["", "lemma d_cancellation_1:\n  \"d(x) \\<le> d(y) \\<squnion> (d(x) * a(y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<le> d y \\<squnion> d x * a y", "by (smt (z3) a_d_closed d_a_shunting d_export eq_refl sup_commute)"], ["", "lemma d_cancellation_2:\n  \"(d(z) \\<squnion> d(y)) * a(y) \\<le> d(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d z \\<squnion> d y) * a y \\<le> d z", "by (metis d_a_shunting d_dist_sup eq_refl)"], ["", "lemma a_sup_closed:\n  \"d(a(x) \\<squnion> a(y)) = a(x) \\<squnion> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (a x \\<squnion> a y) = a x \\<squnion> a y", "using a_mult_deMorgan tests_dual.sub_inf_def"], ["proof (prove)\nusing this:\n  a (a ?x * a ?y) = d (?x \\<squnion> ?y)\n  a ?x \\<squnion> a ?y = a (a (a ?x) * a (a ?y))\n\ngoal (1 subgoal):\n 1. d (a x \\<squnion> a y) = a x \\<squnion> a y", "by auto"], ["", "lemma a_mult_closed:\n  \"d(a(x) * a(y)) = a(x) * a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (a x * a y) = a x * a y", "using d_def tests_dual.sub_sup_closed"], ["proof (prove)\nusing this:\n  d ?x = a (a ?x)\n  a ?x * a ?y = a (a (a ?x * a ?y))\n\ngoal (1 subgoal):\n 1. d (a x * a y) = a x * a y", "by auto"], ["", "lemma d_a_shunting_zero:\n  \"d(x) * a(y) = bot \\<longleftrightarrow> d(x) \\<le> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * a y = bot) = (d x \\<le> d y)", "using a_shunting_zero d_def"], ["proof (prove)\nusing this:\n  (a ?x * d ?y = bot) = (a ?x \\<le> a ?y)\n  d ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. (d x * a y = bot) = (d x \\<le> d y)", "by force"], ["", "lemma d_d_shunting_zero:\n  \"d(x) * d(y) = bot \\<longleftrightarrow> d(x) \\<le> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * d y = bot) = (d x \\<le> a y)", "using d_a_shunting_zero d_def"], ["proof (prove)\nusing this:\n  (d ?x * a ?y = bot) = (d ?x \\<le> d ?y)\n  d ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. (d x * d y = bot) = (d x \\<le> a y)", "by auto"], ["", "lemma d_compl_intro:\n  \"d(x) \\<squnion> d(y) = d(x) \\<squnion> a(x) * d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<squnion> d y = d x \\<squnion> a x * d y", "by (simp add: d_def tests_dual.sba_dual.sup_complement_intro)"], ["", "lemma a_compl_intro:\n  \"a(x) \\<squnion> a(y) = a(x) \\<squnion> d(x) * a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<squnion> a y = a x \\<squnion> d x * a y", "by (simp add: d_def tests_dual.sba_dual.sup_complement_intro)"], ["", "lemma kat_2:\n  \"y * a(z) \\<le> a(x) * y \\<Longrightarrow> d(x) * y * a(z) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * a z \\<le> a x * y \\<Longrightarrow> d x * y * a z = bot", "by (metis d_complement_zero order.eq_iff mult_assoc mult_left_zero mult_right_isotone bot_least)"], ["", "text \\<open>Theorem 45.4\\<close>"], ["", "lemma kat_2_equiv:\n  \"y * a(z) \\<le> a(x) * y \\<longleftrightarrow> d(x) * y * a(z) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * a z \\<le> a x * y) = (d x * y * a z = bot)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y * a z \\<le> a x * y \\<Longrightarrow> d x * y * a z = bot\n 2. d x * y * a z = bot \\<Longrightarrow> y * a z \\<le> a x * y", "apply (simp add: kat_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y * a z = bot \\<Longrightarrow> y * a z \\<le> a x * y", "by (smt (verit, best) a_Z a_below_one a_complement_one case_split_left d_def mult_assoc mult_right_isotone mult_1_right bot_least)"], ["", "lemma kat_3_equiv_opp:\n  \"a(z) * y * d(x) = bot \\<longleftrightarrow> y * d(x) = d(z) * y * d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a z * y * d x = bot) = (y * d x = d z * y * d x)", "using kat_2_equiv d_def kat_4_equiv_opp"], ["proof (prove)\nusing this:\n  (?y * a ?z \\<le> a ?x * ?y) = (d ?x * ?y * a ?z = bot)\n  d ?x = a (a ?x)\n  (?y * d ?x = d ?z * ?y * d ?x) = (?y * d ?x \\<le> d ?z * ?y)\n\ngoal (1 subgoal):\n 1. (a z * y * d x = bot) = (y * d x = d z * y * d x)", "by auto"], ["", "text \\<open>Theorem 45.4\\<close>"], ["", "lemma kat_3_equiv_opp_2:\n  \"d(z) * y * a(x) = bot \\<longleftrightarrow> y * a(x) = a(z) * y * a(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d z * y * a x = bot) = (y * a x = a z * y * a x)", "by (metis a_d_closed kat_3_equiv_opp d_def)"], ["", "lemma kat_equiv_6:\n  \"d(x) * y * a(z) = d(x) * y * bot \\<longleftrightarrow> d(x) * y * a(z) \\<le> y * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * y * a z = d x * y * bot) = (d x * y * a z \\<le> y * bot)", "by (metis d_restrict_iff_1 order.eq_iff mult_left_sub_dist_sup_right tests_dual.sba_dual.sup_right_unit mult_assoc)"], ["", "lemma d_one_one:\n  \"d(1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (1::'a) = (1::'a)", "by (simp add: d_def)"], ["", "lemma case_split_left_sup:\n  \"-p * x \\<le> y \\<and> --p * x \\<le> z \\<Longrightarrow> x \\<le> y \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p * x \\<le> y \\<and> a (a p) * x \\<le> z \\<Longrightarrow>\n    x \\<le> y \\<squnion> z", "by (smt (z3) a_complement_one case_split_left order_lesseq_imp sup.cobounded2 sup_ge1)"], ["", "lemma test_mult_left_sub_dist_shunt:\n  \"-p * (--p * x \\<squnion> Z) \\<le> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p * (a (a p) * x \\<squnion> Z) \\<le> Z", "by (simp add: a_greatest_left_absorber a_Z a_dist_sup a_export)"], ["", "lemma test_mult_left_dist_shunt:\n  \"-p * (--p * x \\<squnion> Z) = -p * Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p * (a (a p) * x \\<squnion> Z) = a p * Z", "by (smt (verit, ccfv_SIG) order.antisym mult_left_sub_dist_sup_right sup.orderE tests_dual.sba_dual.sup_idempotent mult_assoc test_mult_left_sub_dist_shunt tests_dual.sup_absorb)"], ["", "(* independence of axioms, checked in relative_antidomain_semiring without the respective axiom:\nlemma a_restrict  : \"-x * x \\<le> Z\" nitpick [expect=genuine,card=3] oops\nlemma a_mult_d    : \"-(x * y) = -(x * --y)\" nitpick [expect=genuine,card=3] oops\nlemma a_complement: \"-x * --x = bot\" nitpick [expect=genuine,card=2] oops\nlemma a_Z         : \"-Z = 1\" nitpick [expect=genuine,card=2] oops\nlemma a_export    : \"-(--x * y) = -x \\<squnion> -y\" nitpick [expect=genuine,card=5] oops\nlemma a_dist_sup  : \"-(x \\<squnion> y) = -x * -y\" nitpick [expect=genuine,card=3] oops\nlemma d_def       : \"d(x) = --x\" nitpick [expect=genuine,card=2] oops\n*)"], ["", "end"], ["", "typedef (overloaded) 'a aImage = \"{ x::'a::relative_antidomain_semiring . (\\<exists>y::'a . x = a(y)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {x. \\<exists>y. x = a y}", "by auto"], ["", "lemma simp_aImage[simp]:\n  \"\\<exists>y . Rep_aImage x = a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. Rep_aImage x = a y", "using Rep_aImage"], ["proof (prove)\nusing this:\n  Rep_aImage ?x \\<in> {x. \\<exists>y. x = a y}\n\ngoal (1 subgoal):\n 1. \\<exists>y. Rep_aImage x = a y", "by simp"], ["", "setup_lifting type_definition_aImage"], ["", "text \\<open>Theorem 45.3\\<close>"], ["", "instantiation aImage :: (relative_antidomain_semiring) boolean_algebra\nbegin"], ["", "lift_definition sup_aImage :: \"'a aImage \\<Rightarrow> 'a aImage \\<Rightarrow> 'a aImage\" is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>y. a1 = a y; \\<exists>y. a2 = a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a1 \\<squnion> a2 = a y", "using tests_dual.sba_dual.sba_dual.inf_closed"], ["proof (prove)\nusing this:\n  a ?x \\<squnion> a ?y = a (a (a ?x \\<squnion> a ?y))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>y. a1 = a y; \\<exists>y. a2 = a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a1 \\<squnion> a2 = a y", "by auto"], ["", "lift_definition inf_aImage :: \"'a aImage \\<Rightarrow> 'a aImage \\<Rightarrow> 'a aImage\" is times"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>y. a1 = a y; \\<exists>y. a2 = a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a1 * a2 = a y", "using tests_dual.sba_dual.inf_closed"], ["proof (prove)\nusing this:\n  a ?x * a ?y = a (a (a ?x * a ?y))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>y. a1 = a y; \\<exists>y. a2 = a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a1 * a2 = a y", "by auto"], ["", "lift_definition minus_aImage :: \"'a aImage \\<Rightarrow> 'a aImage \\<Rightarrow> 'a aImage\" is \"\\<lambda>x y . x * a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>y. a1 = a y; \\<exists>y. a2 = a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a1 * a a2 = a y", "using tests_dual.sba_dual.inf_closed"], ["proof (prove)\nusing this:\n  a ?x * a ?y = a (a (a ?x * a ?y))\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<exists>y. a1 = a y; \\<exists>y. a2 = a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a1 * a a2 = a y", "by blast"], ["", "lift_definition uminus_aImage :: \"'a aImage \\<Rightarrow> 'a aImage\" is a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. \\<exists>y. a = a y \\<Longrightarrow> \\<exists>y. a a = a y", "by auto"], ["", "lift_definition bot_aImage :: \"'a aImage\" is bot"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. bot = a y", "by (metis tests_dual.sba_dual.sba_dual.complement_bot)"], ["", "lift_definition top_aImage :: \"'a aImage\" is 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. (1::'a) = a y", "using a_Z"], ["proof (prove)\nusing this:\n  a Z = (1::?'a)\n\ngoal (1 subgoal):\n 1. \\<exists>y. (1::'a) = a y", "by auto"], ["", "lift_definition less_eq_aImage :: \"'a aImage \\<Rightarrow> 'a aImage \\<Rightarrow> bool\" is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_aImage :: \"'a aImage \\<Rightarrow> 'a aImage \\<Rightarrow> bool\" is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a aImage, boolean_algebra_class)", "apply intro_classes"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 16 subgoals...", "apply (simp add: less_aImage.rep_eq less_eq_aImage.rep_eq less_le_not_le)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 15 subgoals...", "apply (simp add: less_eq_aImage.rep_eq)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 14 subgoals...", "using less_eq_aImage.rep_eq"], ["proof (prove)\nusing this:\n  (?x \\<le> ?xa) = (Rep_aImage ?x \\<le> Rep_aImage ?xa)\n\ngoal (14 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 14 subgoals...", "apply simp"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 13 subgoals...", "apply (simp add: Rep_aImage_inject less_eq_aImage.rep_eq)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x. x \\<sqinter> a x = bot\nA total of 12 subgoals...", "apply (metis (mono_tags) a_below_one inf_aImage.rep_eq less_eq_aImage.rep_eq mult.right_neutral mult_right_isotone simp_aImage)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x. x \\<sqinter> a x = bot\n 10. \\<And>x. x \\<squnion> a x = top\nA total of 11 subgoals...", "apply (metis (mono_tags, lifting) less_eq_aImage.rep_eq a_d_closed a_export bot.extremum_unique inf_aImage.rep_eq kat_equiv_6 mult.assoc mult.left_neutral mult_left_isotone mult_left_zero simp_aImage sup.cobounded1 tests_dual.sba_dual.sba_dual.complement_top)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x. x \\<sqinter> a x = bot\n 9. \\<And>x. x \\<squnion> a x = top\n 10. \\<And>x y. x - y = x \\<sqinter> a y", "apply (smt (z3) less_eq_aImage.rep_eq inf_aImage.rep_eq mult_isotone simp_aImage tests_dual.sba_dual.inf_idempotent)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x. x \\<sqinter> a x = bot\n 8. \\<And>x. x \\<squnion> a x = top\n 9. \\<And>x y. x - y = x \\<sqinter> a y", "apply (simp add: less_eq_aImage.rep_eq sup_aImage.rep_eq)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x. x \\<sqinter> a x = bot\n 7. \\<And>x. x \\<squnion> a x = top\n 8. \\<And>x y. x - y = x \\<sqinter> a y", "apply (simp add: less_eq_aImage.rep_eq sup_aImage.rep_eq)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x. x \\<sqinter> a x = bot\n 6. \\<And>x. x \\<squnion> a x = top\n 7. \\<And>x y. x - y = x \\<sqinter> a y", "using less_eq_aImage.rep_eq sup_aImage.rep_eq"], ["proof (prove)\nusing this:\n  (?x \\<le> ?xa) = (Rep_aImage ?x \\<le> Rep_aImage ?xa)\n  Rep_aImage (?x \\<squnion> ?xa) = Rep_aImage ?x \\<squnion> Rep_aImage ?xa\n\ngoal (7 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x. x \\<sqinter> a x = bot\n 6. \\<And>x. x \\<squnion> a x = top\n 7. \\<And>x y. x - y = x \\<sqinter> a y", "apply force"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x. x \\<sqinter> a x = bot\n 5. \\<And>x. x \\<squnion> a x = top\n 6. \\<And>x y. x - y = x \\<sqinter> a y", "apply (simp add: less_eq_aImage.rep_eq bot_aImage.rep_eq)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x. x \\<sqinter> a x = bot\n 4. \\<And>x. x \\<squnion> a x = top\n 5. \\<And>x y. x - y = x \\<sqinter> a y", "apply (smt (z3) less_eq_aImage.rep_eq a_below_one simp_aImage top_aImage.rep_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x. x \\<sqinter> a x = bot\n 3. \\<And>x. x \\<squnion> a x = top\n 4. \\<And>x y. x - y = x \\<sqinter> a y", "apply (metis (mono_tags, lifting) tests_dual.sba_dual.sba_dual.inf_left_dist_sup Rep_aImage_inject inf_aImage.rep_eq sup_aImage.rep_eq simp_aImage)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqinter> a x = bot\n 2. \\<And>x. x \\<squnion> a x = top\n 3. \\<And>x y. x - y = x \\<sqinter> a y", "apply (smt (z3) inf_aImage.rep_eq uminus_aImage.rep_eq Rep_aImage_inject a_complement bot_aImage.rep_eq simp_aImage)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<squnion> a x = top\n 2. \\<And>x y. x - y = x \\<sqinter> a y", "apply (smt (z3) top_aImage.rep_eq Rep_aImage_inject a_complement_one simp_aImage sup_aImage.rep_eq sup_commute uminus_aImage.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x - y = x \\<sqinter> a y", "by (metis (mono_tags) inf_aImage.rep_eq Rep_aImage_inject minus_aImage.rep_eq uminus_aImage.rep_eq)"], ["", "end"], ["", "class bounded_relative_antidomain_semiring = relative_antidomain_semiring + bounded_idempotent_left_semiring\nbegin"], ["", "subclass bounded_relative_domain_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_relative_domain_semiring Z (1::'a) (*) (\\<squnion>)\n     (\\<le>) (<) bot d top", ".."], ["", "lemma a_top:\n  \"a(top) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a top = bot", "by (metis a_plus_left_lower_bound bot_unique sup_right_top tests_dual.sba_dual.complement_top)"], ["", "lemma d_top:\n  \"d(top) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d top = (1::'a)", "using a_top d_def"], ["proof (prove)\nusing this:\n  a top = bot\n  d ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. d top = (1::'a)", "by auto"], ["", "lemma shunting_top_1:\n  \"-p * x \\<le> y \\<Longrightarrow> x \\<le> --p * top \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p * x \\<le> y \\<Longrightarrow> x \\<le> a (a p) * top \\<squnion> y", "by (metis sup_commute case_split_left_sup mult_right_isotone top_greatest)"], ["", "lemma shunting_Z:\n  \"-p * x \\<le> Z \\<longleftrightarrow> x \\<le> --p * top \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a p * x \\<le> Z) = (x \\<le> a (a p) * top \\<squnion> Z)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a p * x \\<le> Z \\<Longrightarrow> x \\<le> a (a p) * top \\<squnion> Z\n 2. x \\<le> a (a p) * top \\<squnion> Z \\<Longrightarrow> a p * x \\<le> Z", "apply (simp add: shunting_top_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> a (a p) * top \\<squnion> Z \\<Longrightarrow> a p * x \\<le> Z", "by (smt a_top a_Z a_antitone a_dist_sup a_export a_greatest_left_absorber sup_commute sup_bot_right mult_left_one)"], ["", "(*\nlemma a_left_dist_sup: \"-p * (y \\<squnion> z) = -p * y \\<squnion> -p * z\" nitpick [expect=genuine,card=7] oops\nlemma shunting_top: \"-p * x \\<le> y \\<longleftrightarrow> x \\<le> --p * top \\<squnion> y\" nitpick [expect=genuine,card=7] oops\n*)"], ["", "end"], ["", "class relative_left_zero_antidomain_semiring = relative_antidomain_semiring + idempotent_left_zero_semiring\nbegin"], ["", "lemma kat_3:\n  \"d(x) * y * a(z) = bot \\<Longrightarrow> d(x) * y = d(x) * y * d(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y * a z = bot \\<Longrightarrow> d x * y = d x * y * d z", "by (metis d_def mult_1_right mult_left_dist_sup sup_monoid.add_0_left tests_dual.inf_complement)"], ["", "lemma a_a_below:\n  \"a(a(x)) * y \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x) * y \\<le> y", "using d_def d_restrict_iff_1"], ["proof (prove)\nusing this:\n  d ?x = a (a ?x)\n  (d ?x * ?y \\<le> ?z) = (d ?x * ?y \\<le> d ?x * ?z)\n\ngoal (1 subgoal):\n 1. a (a x) * y \\<le> y", "by auto"], ["", "lemma kat_equiv_5:\n  \"d(x) * y \\<le> y * d(z) \\<longleftrightarrow> d(x) * y * a(z) = d(x) * y * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * y \\<le> y * d z) = (d x * y * a z = d x * y * bot)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. d x * y \\<le> y * d z \\<Longrightarrow> d x * y * a z = d x * y * bot\n 2. d x * y * a z = d x * y * bot \\<Longrightarrow> d x * y \\<le> y * d z", "assume \"d(x) * y \\<le> y * d(z)\""], ["proof (state)\nthis:\n  d x * y \\<le> y * d z\n\ngoal (2 subgoals):\n 1. d x * y \\<le> y * d z \\<Longrightarrow> d x * y * a z = d x * y * bot\n 2. d x * y * a z = d x * y * bot \\<Longrightarrow> d x * y \\<le> y * d z", "thus \"d(x) * y * a(z) = d(x) * y * bot\""], ["proof (prove)\nusing this:\n  d x * y \\<le> y * d z\n\ngoal (1 subgoal):\n 1. d x * y * a z = d x * y * bot", "by (metis d_complement_zero kat_4_equiv mult_assoc)"], ["proof (state)\nthis:\n  d x * y * a z = d x * y * bot\n\ngoal (1 subgoal):\n 1. d x * y * a z = d x * y * bot \\<Longrightarrow> d x * y \\<le> y * d z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d x * y * a z = d x * y * bot \\<Longrightarrow> d x * y \\<le> y * d z", "assume \"d(x) * y * a(z) = d(x) * y * bot\""], ["proof (state)\nthis:\n  d x * y * a z = d x * y * bot\n\ngoal (1 subgoal):\n 1. d x * y * a z = d x * y * bot \\<Longrightarrow> d x * y \\<le> y * d z", "hence \"a(a(x)) * y * a(z) \\<le> y * a(a(z))\""], ["proof (prove)\nusing this:\n  d x * y * a z = d x * y * bot\n\ngoal (1 subgoal):\n 1. a (a x) * y * a z \\<le> y * a (a z)", "by (simp add: a_a_below d_def mult_isotone)"], ["proof (state)\nthis:\n  a (a x) * y * a z \\<le> y * a (a z)\n\ngoal (1 subgoal):\n 1. d x * y * a z = d x * y * bot \\<Longrightarrow> d x * y \\<le> y * d z", "thus \"d(x) * y \\<le> y * d(z)\""], ["proof (prove)\nusing this:\n  a (a x) * y * a z \\<le> y * a (a z)\n\ngoal (1 subgoal):\n 1. d x * y \\<le> y * d z", "by (metis a_a_below a_complement_one case_split_right d_def mult_isotone order_refl)"], ["proof (state)\nthis:\n  d x * y \\<le> y * d z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma case_split_right_sup:\n  \"x * -p \\<le> y \\<Longrightarrow> x * --p \\<le> z \\<Longrightarrow> x \\<le> y \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x * a p \\<le> y; x * a (a p) \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y \\<squnion> z", "by (smt (verit, ccfv_SIG) a_complement_one order.trans mult_1_right mult_left_dist_sup sup_commute sup_right_isotone)"], ["", "end"], ["", "class bounded_relative_left_zero_antidomain_semiring = relative_left_zero_antidomain_semiring + bounded_idempotent_left_zero_semiring\nbegin"], ["", "lemma shunting_top:\n  \"-p * x \\<le> y \\<longleftrightarrow> x \\<le> --p * top \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a p * x \\<le> y) = (x \\<le> a (a p) * top \\<squnion> y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a p * x \\<le> y \\<Longrightarrow> x \\<le> a (a p) * top \\<squnion> y\n 2. x \\<le> a (a p) * top \\<squnion> y \\<Longrightarrow> a p * x \\<le> y", "apply (metis sup_commute case_split_left_sup mult_right_isotone top_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> a (a p) * top \\<squnion> y \\<Longrightarrow> a p * x \\<le> y", "by (metis a_complement sup_bot_left sup_right_divisibility mult_assoc mult_left_dist_sup mult_left_one mult_left_zero mult_right_dist_sup mult_right_isotone order_trans tests_dual.inf_left_unit)"], ["", "end"], ["", "end"]]}