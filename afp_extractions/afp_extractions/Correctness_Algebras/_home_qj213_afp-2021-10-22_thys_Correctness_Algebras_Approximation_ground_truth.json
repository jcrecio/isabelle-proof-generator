{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Approximation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma apx_meet_unique:\n  \"has_apx_meet x y \\<Longrightarrow> \\<exists>!z . is_apx_meet x y z\"", "lemma apx_meet:\n  assumes \"has_apx_meet x y\"\n    shows \"is_apx_meet x y (x \\<triangle> y)\"", "lemma apx_greatest_lower_bound:\n  \"has_apx_meet x y \\<Longrightarrow> (w \\<sqsubseteq> x \\<and> w \\<sqsubseteq> y \\<longleftrightarrow> w \\<sqsubseteq> x \\<triangle> y)\"", "lemma apx_meet_same:\n  \"is_apx_meet x y z \\<Longrightarrow> z = x \\<triangle> y\"", "lemma apx_meet_char:\n  \"is_apx_meet x y z \\<longleftrightarrow> has_apx_meet x y \\<and> z = x \\<triangle> y\"", "lemma mu_below_kappa:\n  \"has_least_fixpoint f \\<Longrightarrow> apx.has_least_fixpoint f \\<Longrightarrow> \\<mu> f \\<le> \\<kappa> f\"", "lemma kappa_below_nu:\n  \"has_greatest_fixpoint f \\<Longrightarrow> apx.has_least_fixpoint f \\<Longrightarrow> \\<kappa> f \\<le> \\<nu> f\"", "lemma kappa_apx_below_mu:\n  \"has_least_fixpoint f \\<Longrightarrow> apx.has_least_fixpoint f \\<Longrightarrow> \\<kappa> f \\<sqsubseteq> \\<mu> f\"", "lemma kappa_apx_below_nu:\n  \"has_greatest_fixpoint f \\<Longrightarrow> apx.has_least_fixpoint f \\<Longrightarrow> \\<kappa> f \\<sqsubseteq> \\<nu> f\"", "lemma sup_apx_right_isotone:\n  \"x \\<sqsubseteq> y \\<Longrightarrow> z \\<squnion> x \\<sqsubseteq> z \\<squnion> y\"", "lemma sup_apx_isotone:\n  \"w \\<sqsubseteq> y \\<Longrightarrow> x \\<sqsubseteq> z \\<Longrightarrow> w \\<squnion> x \\<sqsubseteq> y \\<squnion> z\"", "lemma mult_apx_isotone:\n  \"w \\<sqsubseteq> y \\<Longrightarrow> x \\<sqsubseteq> z \\<Longrightarrow> w * x \\<sqsubseteq> y * z\"", "lemma affine_apx_isotone:\n  \"apx.isotone (\\<lambda>x . y * x \\<squnion> z)\""], "translations": [["", "lemma apx_meet_unique:\n  \"has_apx_meet x y \\<Longrightarrow> \\<exists>!z . is_apx_meet x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_apx_meet x y \\<Longrightarrow> \\<exists>!z. is_apx_meet x y z", "by (meson apx_antisymmetric has_apx_meet_def is_apx_meet_def)"], ["", "lemma apx_meet:\n  assumes \"has_apx_meet x y\"\n    shows \"is_apx_meet x y (x \\<triangle> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_apx_meet x y (x \\<triangle> y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_apx_meet x y (x \\<triangle> y)", "have \"is_apx_meet x y (THE z . is_apx_meet x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_apx_meet x y (THE z. is_apx_meet x y z)", "by (metis apx_meet_unique assms theI)"], ["proof (state)\nthis:\n  is_apx_meet x y (THE z. is_apx_meet x y z)\n\ngoal (1 subgoal):\n 1. is_apx_meet x y (x \\<triangle> y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_apx_meet x y (THE z. is_apx_meet x y z)\n\ngoal (1 subgoal):\n 1. is_apx_meet x y (x \\<triangle> y)", "by (simp add: the_apx_meet_def)"], ["proof (state)\nthis:\n  is_apx_meet x y (x \\<triangle> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apx_greatest_lower_bound:\n  \"has_apx_meet x y \\<Longrightarrow> (w \\<sqsubseteq> x \\<and> w \\<sqsubseteq> y \\<longleftrightarrow> w \\<sqsubseteq> x \\<triangle> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_apx_meet x y \\<Longrightarrow>\n    (w \\<sqsubseteq> x \\<and> w \\<sqsubseteq> y) =\n    (w \\<sqsubseteq> x \\<triangle> y)", "by (meson apx_meet apx_transitive is_apx_meet_def)"], ["", "lemma apx_meet_same:\n  \"is_apx_meet x y z \\<Longrightarrow> z = x \\<triangle> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_apx_meet x y z \\<Longrightarrow> z = x \\<triangle> y", "using apx_meet apx_meet_unique has_apx_meet_def"], ["proof (prove)\nusing this:\n  has_apx_meet ?x ?y \\<Longrightarrow> is_apx_meet ?x ?y (?x \\<triangle> ?y)\n  has_apx_meet ?x ?y \\<Longrightarrow> \\<exists>!z. is_apx_meet ?x ?y z\n  has_apx_meet ?x ?y \\<equiv> \\<exists>z. is_apx_meet ?x ?y z\n\ngoal (1 subgoal):\n 1. is_apx_meet x y z \\<Longrightarrow> z = x \\<triangle> y", "by blast"], ["", "lemma apx_meet_char:\n  \"is_apx_meet x y z \\<longleftrightarrow> has_apx_meet x y \\<and> z = x \\<triangle> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_apx_meet x y z = (has_apx_meet x y \\<and> z = x \\<triangle> y)", "using apx_meet_same has_apx_meet_def"], ["proof (prove)\nusing this:\n  is_apx_meet ?x ?y ?z \\<Longrightarrow> ?z = ?x \\<triangle> ?y\n  has_apx_meet ?x ?y \\<equiv> \\<exists>z. is_apx_meet ?x ?y z\n\ngoal (1 subgoal):\n 1. is_apx_meet x y z = (has_apx_meet x y \\<and> z = x \\<triangle> y)", "by auto"], ["", "end"], ["", "class apx_biorder = apx_order + order\nbegin"], ["", "lemma mu_below_kappa:\n  \"has_least_fixpoint f \\<Longrightarrow> apx.has_least_fixpoint f \\<Longrightarrow> \\<mu> f \\<le> \\<kappa> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f;\n     order.has_least_fixpoint (\\<sqsubseteq>) f\\<rbrakk>\n    \\<Longrightarrow> \\<mu> f \\<le> \\<kappa> f", "using apx.mu_unfold is_least_fixpoint_def least_fixpoint"], ["proof (prove)\nusing this:\n  order.has_least_fixpoint (\\<sqsubseteq>) ?f \\<Longrightarrow>\n  ?f (\\<kappa> ?f) = \\<kappa> ?f\n  is_least_fixpoint ?f ?x \\<equiv>\n  ?f ?x = ?x \\<and> (\\<forall>y. ?f y = y \\<longrightarrow> ?x \\<le> y)\n  has_least_fixpoint ?f \\<Longrightarrow> is_least_fixpoint ?f (\\<mu> ?f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f;\n     order.has_least_fixpoint (\\<sqsubseteq>) f\\<rbrakk>\n    \\<Longrightarrow> \\<mu> f \\<le> \\<kappa> f", "by auto"], ["", "lemma kappa_below_nu:\n  \"has_greatest_fixpoint f \\<Longrightarrow> apx.has_least_fixpoint f \\<Longrightarrow> \\<kappa> f \\<le> \\<nu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_greatest_fixpoint f;\n     order.has_least_fixpoint (\\<sqsubseteq>) f\\<rbrakk>\n    \\<Longrightarrow> \\<kappa> f \\<le> \\<nu> f", "by (meson apx.mu_unfold greatest_fixpoint is_greatest_fixpoint_def)"], ["", "lemma kappa_apx_below_mu:\n  \"has_least_fixpoint f \\<Longrightarrow> apx.has_least_fixpoint f \\<Longrightarrow> \\<kappa> f \\<sqsubseteq> \\<mu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f;\n     order.has_least_fixpoint (\\<sqsubseteq>) f\\<rbrakk>\n    \\<Longrightarrow> \\<kappa> f \\<sqsubseteq> \\<mu> f", "using apx.is_least_fixpoint_def apx.least_fixpoint mu_unfold"], ["proof (prove)\nusing this:\n  order.is_least_fixpoint (\\<sqsubseteq>) ?f ?x \\<equiv>\n  ?f ?x = ?x \\<and>\n  (\\<forall>y. ?f y = y \\<longrightarrow> ?x \\<sqsubseteq> y)\n  order.has_least_fixpoint (\\<sqsubseteq>) ?f \\<Longrightarrow>\n  order.is_least_fixpoint (\\<sqsubseteq>) ?f (\\<kappa> ?f)\n  has_least_fixpoint ?f \\<Longrightarrow> ?f (\\<mu> ?f) = \\<mu> ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_least_fixpoint f;\n     order.has_least_fixpoint (\\<sqsubseteq>) f\\<rbrakk>\n    \\<Longrightarrow> \\<kappa> f \\<sqsubseteq> \\<mu> f", "by auto"], ["", "lemma kappa_apx_below_nu:\n  \"has_greatest_fixpoint f \\<Longrightarrow> apx.has_least_fixpoint f \\<Longrightarrow> \\<kappa> f \\<sqsubseteq> \\<nu> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_greatest_fixpoint f;\n     order.has_least_fixpoint (\\<sqsubseteq>) f\\<rbrakk>\n    \\<Longrightarrow> \\<kappa> f \\<sqsubseteq> \\<nu> f", "by (metis apx.is_least_fixpoint_def apx.least_fixpoint nu_unfold)"], ["", "end"], ["", "class apx_semiring = apx_biorder + idempotent_left_semiring + L +\n  assumes apx_L_least: \"L \\<sqsubseteq> x\"\n  assumes sup_apx_left_isotone: \"x \\<sqsubseteq> y \\<longrightarrow> x \\<squnion> z \\<sqsubseteq> y \\<squnion> z\"\n  assumes mult_apx_left_isotone: \"x \\<sqsubseteq> y \\<longrightarrow> x * z \\<sqsubseteq> y * z\"\n  assumes mult_apx_right_isotone: \"x \\<sqsubseteq> y \\<longrightarrow> z * x \\<sqsubseteq> z * y\"\nbegin"], ["", "lemma sup_apx_right_isotone:\n  \"x \\<sqsubseteq> y \\<Longrightarrow> z \\<squnion> x \\<sqsubseteq> z \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y \\<Longrightarrow>\n    z \\<squnion> x \\<sqsubseteq> z \\<squnion> y", "by (simp add: sup_apx_left_isotone sup_commute)"], ["", "lemma sup_apx_isotone:\n  \"w \\<sqsubseteq> y \\<Longrightarrow> x \\<sqsubseteq> z \\<Longrightarrow> w \\<squnion> x \\<sqsubseteq> y \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<sqsubseteq> y; x \\<sqsubseteq> z\\<rbrakk>\n    \\<Longrightarrow> w \\<squnion> x \\<sqsubseteq> y \\<squnion> z", "by (meson apx_transitive sup_apx_left_isotone sup_apx_right_isotone)"], ["", "lemma mult_apx_isotone:\n  \"w \\<sqsubseteq> y \\<Longrightarrow> x \\<sqsubseteq> z \\<Longrightarrow> w * x \\<sqsubseteq> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<sqsubseteq> y; x \\<sqsubseteq> z\\<rbrakk>\n    \\<Longrightarrow> w * x \\<sqsubseteq> y * z", "by (meson apx_transitive mult_apx_left_isotone mult_apx_right_isotone)"], ["", "lemma affine_apx_isotone:\n  \"apx.isotone (\\<lambda>x . y * x \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.isotone (\\<sqsubseteq>) (\\<lambda>x. y * x \\<squnion> z)", "by (simp add: apx.isotone_def mult_apx_right_isotone sup_apx_left_isotone)"], ["", "end"], ["", "end"]]}