{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/N_Relation_Algebras.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma lres_mult_lres_lres:\n  \"x / (z * y) = (x / y) / z\"", "lemma lres_dist_inf:\n  \"(x \\<sqinter> y) / z = (x / z) \\<sqinter> (y / z)\"", "lemma lres_add_export_vector:\n  assumes \"vector x\"\n    shows \"(x \\<squnion> y) / z = x \\<squnion> (y / z)\"", "lemma lres_top_vector:\n  \"vector (x / top)\"", "lemma lres_top_export_inf_mult:\n  \"((x / top) \\<sqinter> y) * z = (x / top) \\<sqinter> (y * z)\"", "lemma N_lres:\n  \"N(x) = x / top \\<sqinter> 1\"", "lemma mu_lower_bound:\n  \"f x \\<le> x \\<Longrightarrow> mu f \\<le> x\"", "lemma mu_greatest_lower_bound:\n  \"(\\<forall>y . f y \\<le> y \\<longrightarrow> x \\<le> y) \\<Longrightarrow> x \\<le> mu f\"", "lemma mu_unfold_1:\n  \"isotone f \\<Longrightarrow> f (mu f) \\<le> mu f\"", "lemma mu_unfold_2:\n  \"isotone f \\<Longrightarrow> mu f \\<le> f (mu f)\"", "lemma mu_unfold:\n  \"isotone f \\<Longrightarrow> mu f = f (mu f)\"", "lemma mu_const:\n  \"mu (\\<lambda>x . y) = y\"", "lemma mu_lpfp:\n  \"isotone f \\<Longrightarrow> is_least_prefixpoint f (mu f)\"", "lemma mu_lfp:\n  \"isotone f \\<Longrightarrow> is_least_fixpoint f (mu f)\"", "lemma mu_pmu:\n  \"isotone f \\<Longrightarrow> p\\<mu> f = mu f\"", "lemma mu_mu:\n  \"isotone f \\<Longrightarrow> \\<mu> f = mu f\""], "translations": [["", "lemma lres_mult_lres_lres:\n  \"x / (z * y) = (x / y) / z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_divide x (z * y) = inverse_divide (inverse_divide x y) z", "by (metis conv_dist_comp double_compl lres_def mult_assoc)"], ["", "text \\<open>Theorem 32.5\\<close>"], ["", "lemma lres_dist_inf:\n  \"(x \\<sqinter> y) / z = (x / z) \\<sqinter> (y / z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_divide (x \\<sqinter> y) z =\n    inverse_divide x z \\<sqinter> inverse_divide y z", "by (metis compl_inf compl_sup lres_def mult_right_dist_sup)"], ["", "text \\<open>Theorem 32.6\\<close>"], ["", "lemma lres_add_export_vector:\n  assumes \"vector x\"\n    shows \"(x \\<squnion> y) / z = x \\<squnion> (y / z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z", "have \"(x \\<squnion> y) / z = -((-x \\<sqinter> -y) * z\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_divide (x \\<squnion> y) z = - ((- x \\<sqinter> - y) * z\\<^sup>T)", "by (simp add: lres_def)"], ["proof (state)\nthis:\n  inverse_divide (x \\<squnion> y) z = - ((- x \\<sqinter> - y) * z\\<^sup>T)\n\ngoal (1 subgoal):\n 1. inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z", "also"], ["proof (state)\nthis:\n  inverse_divide (x \\<squnion> y) z = - ((- x \\<sqinter> - y) * z\\<^sup>T)\n\ngoal (1 subgoal):\n 1. inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z", "have \"... = -(-x \\<sqinter> (-y * z\\<^sup>T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ((- x \\<sqinter> - y) * z\\<^sup>T) =\n    - (- x \\<sqinter> - y * z\\<^sup>T)", "using assms vector_complement_closed vector_inf_comp"], ["proof (prove)\nusing this:\n  vector x\n  vector ?x \\<Longrightarrow> vector (- ?x)\n  vector ?x \\<Longrightarrow>\n  (?x \\<sqinter> ?y) * ?z = ?x \\<sqinter> ?y * ?z\n\ngoal (1 subgoal):\n 1. - ((- x \\<sqinter> - y) * z\\<^sup>T) =\n    - (- x \\<sqinter> - y * z\\<^sup>T)", "by auto"], ["proof (state)\nthis:\n  - ((- x \\<sqinter> - y) * z\\<^sup>T) = - (- x \\<sqinter> - y * z\\<^sup>T)\n\ngoal (1 subgoal):\n 1. inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z", "also"], ["proof (state)\nthis:\n  - ((- x \\<sqinter> - y) * z\\<^sup>T) = - (- x \\<sqinter> - y * z\\<^sup>T)\n\ngoal (1 subgoal):\n 1. inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z", "have \"... = x \\<squnion> (y / z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- x \\<sqinter> - y * z\\<^sup>T) = x \\<squnion> inverse_divide y z", "by (simp add: lres_def)"], ["proof (state)\nthis:\n  - (- x \\<sqinter> - y * z\\<^sup>T) = x \\<squnion> inverse_divide y z\n\ngoal (1 subgoal):\n 1. inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z", "finally"], ["proof (chain)\npicking this:\n  inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z", "show ?thesis"], ["proof (prove)\nusing this:\n  inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z\n\ngoal (1 subgoal):\n 1. inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z", "."], ["proof (state)\nthis:\n  inverse_divide (x \\<squnion> y) z = x \\<squnion> inverse_divide y z\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 32.7\\<close>"], ["", "lemma lres_top_vector:\n  \"vector (x / top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector (inverse_divide x top)", "using equivalence_top_closed lres_def vector_complement_closed vector_mult_closed vector_top_closed"], ["proof (prove)\nusing this:\n  equivalence top\n  inverse_divide ?x ?y = - (- ?x * ?y\\<^sup>T)\n  vector ?x \\<Longrightarrow> vector (- ?x)\n  vector ?y \\<Longrightarrow> vector (?x * ?y)\n  surjective top\n\ngoal (1 subgoal):\n 1. vector (inverse_divide x top)", "by auto"], ["", "text \\<open>Theorem 32.10\\<close>"], ["", "lemma lres_top_export_inf_mult:\n  \"((x / top) \\<sqinter> y) * z = (x / top) \\<sqinter> (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse_divide x top \\<sqinter> y) * z =\n    inverse_divide x top \\<sqinter> y * z", "by (simp add: vector_inf_comp lres_top_vector)"], ["", "lemma N_lres:\n  \"N(x) = x / top \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N x = inverse_divide x top \\<sqinter> (1::'a)", "using lres_def"], ["proof (prove)\nusing this:\n  inverse_divide ?x ?y = - (- ?x * ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. N x = inverse_divide x top \\<sqinter> (1::'a)", "by auto"], ["", "end"], ["", "class complete_relation_algebra = relation_algebra + complete_lattice\nbegin"], ["", "definition mu :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a\" where \"mu f \\<equiv> Inf { y . f y \\<le> y }\""], ["", "definition nu :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a\" where \"nu f \\<equiv> Sup { y . y \\<le> f y }\""], ["", "lemma mu_lower_bound:\n  \"f x \\<le> x \\<Longrightarrow> mu f \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> x \\<Longrightarrow> mu f \\<le> x", "by (auto simp add: mu_def intro: Inf_lower)"], ["", "lemma mu_greatest_lower_bound:\n  \"(\\<forall>y . f y \\<le> y \\<longrightarrow> x \\<le> y) \\<Longrightarrow> x \\<le> mu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. f y \\<le> y \\<longrightarrow> x \\<le> y \\<Longrightarrow>\n    x \\<le> mu f", "using lfp_def lfp_greatest mu_def"], ["proof (prove)\nusing this:\n  lfp ?f = Inf {u. ?f u \\<le> u}\n  (\\<And>u. ?f u \\<le> u \\<Longrightarrow> ?A \\<le> u) \\<Longrightarrow>\n  ?A \\<le> lfp ?f\n  mu ?f \\<equiv> Inf {y. ?f y \\<le> y}\n\ngoal (1 subgoal):\n 1. \\<forall>y. f y \\<le> y \\<longrightarrow> x \\<le> y \\<Longrightarrow>\n    x \\<le> mu f", "by auto"], ["", "lemma mu_unfold_1:\n  \"isotone f \\<Longrightarrow> f (mu f) \\<le> mu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone f \\<Longrightarrow> f (mu f) \\<le> mu f", "by (metis mu_greatest_lower_bound order_trans mu_lower_bound isotone_def)"], ["", "lemma mu_unfold_2:\n  \"isotone f \\<Longrightarrow> mu f \\<le> f (mu f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone f \\<Longrightarrow> mu f \\<le> f (mu f)", "by (simp add: mu_lower_bound mu_unfold_1 ord.isotone_def)"], ["", "lemma mu_unfold:\n  \"isotone f \\<Longrightarrow> mu f = f (mu f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone f \\<Longrightarrow> mu f = f (mu f)", "by (simp add: order.antisym mu_unfold_1 mu_unfold_2)"], ["", "lemma mu_const:\n  \"mu (\\<lambda>x . y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mu (\\<lambda>x. y) = y", "by (simp add: isotone_def mu_unfold)"], ["", "lemma mu_lpfp:\n  \"isotone f \\<Longrightarrow> is_least_prefixpoint f (mu f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone f \\<Longrightarrow> is_least_prefixpoint f (mu f)", "by (simp add: is_least_prefixpoint_def mu_lower_bound mu_unfold_1)"], ["", "lemma mu_lfp:\n  \"isotone f \\<Longrightarrow> is_least_fixpoint f (mu f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone f \\<Longrightarrow> is_least_fixpoint f (mu f)", "by (metis is_least_fixpoint_def mu_lower_bound mu_unfold order_refl)"], ["", "lemma mu_pmu:\n  \"isotone f \\<Longrightarrow> p\\<mu> f = mu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone f \\<Longrightarrow> p\\<mu> f = mu f", "using least_prefixpoint_same mu_lpfp"], ["proof (prove)\nusing this:\n  is_least_prefixpoint ?f ?x \\<Longrightarrow> ?x = p\\<mu> ?f\n  isotone ?f \\<Longrightarrow> is_least_prefixpoint ?f (mu ?f)\n\ngoal (1 subgoal):\n 1. isotone f \\<Longrightarrow> p\\<mu> f = mu f", "by force"], ["", "lemma mu_mu:\n  \"isotone f \\<Longrightarrow> \\<mu> f = mu f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone f \\<Longrightarrow> \\<mu> f = mu f", "using least_fixpoint_same mu_lfp"], ["proof (prove)\nusing this:\n  is_least_fixpoint ?f ?x \\<Longrightarrow> ?x = \\<mu> ?f\n  isotone ?f \\<Longrightarrow> is_least_fixpoint ?f (mu ?f)\n\ngoal (1 subgoal):\n 1. isotone f \\<Longrightarrow> \\<mu> f = mu f", "by fastforce"], ["", "end"], ["", "class omega_relation_algebra = relation_algebra + star + omega +\n  assumes ra_star_left_unfold : \"1 \\<squnion> y * y\\<^sup>\\<star> \\<le> y\\<^sup>\\<star>\"\n  assumes ra_star_left_induct : \"z \\<squnion> y * x \\<le> x \\<longrightarrow> y\\<^sup>\\<star> * z \\<le> x\"\n  assumes ra_star_right_induct: \"z \\<squnion> x * y \\<le> x \\<longrightarrow> z * y\\<^sup>\\<star> \\<le> x\"\n  assumes ra_omega_unfold: \"y\\<^sup>\\<omega> = y * y\\<^sup>\\<omega>\"\n  assumes ra_omega_induct: \"x \\<le> z \\<squnion> y * x \\<longrightarrow> x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z\"\nbegin"], ["", "subclass bounded_omega_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_omega_algebra star (1::'a) (*) (\\<squnion>) (\\<le>) (<)\n     bot top omega", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>y. Rf y (y\\<^sup>\\<star>) \\<le> y\\<^sup>\\<star>\n 2. \\<And>z y x.\n       z \\<squnion> y * x \\<le> x \\<longrightarrow>\n       y\\<^sup>\\<star> * z \\<le> x\n 3. \\<And>z x y.\n       z \\<squnion> x * y \\<le> x \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> x\n 4. \\<And>y. y\\<^sup>\\<omega> = y * y\\<^sup>\\<omega>\n 5. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z", "using ra_star_left_unfold"], ["proof (prove)\nusing this:\n  Rf ?y (?y\\<^sup>\\<star>) \\<le> ?y\\<^sup>\\<star>\n\ngoal (5 subgoals):\n 1. \\<And>y. Rf y (y\\<^sup>\\<star>) \\<le> y\\<^sup>\\<star>\n 2. \\<And>z y x.\n       z \\<squnion> y * x \\<le> x \\<longrightarrow>\n       y\\<^sup>\\<star> * z \\<le> x\n 3. \\<And>z x y.\n       z \\<squnion> x * y \\<le> x \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> x\n 4. \\<And>y. y\\<^sup>\\<omega> = y * y\\<^sup>\\<omega>\n 5. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>z y x.\n       z \\<squnion> y * x \\<le> x \\<longrightarrow>\n       y\\<^sup>\\<star> * z \\<le> x\n 2. \\<And>z x y.\n       z \\<squnion> x * y \\<le> x \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> x\n 3. \\<And>y. y\\<^sup>\\<omega> = y * y\\<^sup>\\<omega>\n 4. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z", "using ra_star_left_induct"], ["proof (prove)\nusing this:\n  ?z \\<squnion> ?y * ?x \\<le> ?x \\<longrightarrow>\n  ?y\\<^sup>\\<star> * ?z \\<le> ?x\n\ngoal (4 subgoals):\n 1. \\<And>z y x.\n       z \\<squnion> y * x \\<le> x \\<longrightarrow>\n       y\\<^sup>\\<star> * z \\<le> x\n 2. \\<And>z x y.\n       z \\<squnion> x * y \\<le> x \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> x\n 3. \\<And>y. y\\<^sup>\\<omega> = y * y\\<^sup>\\<omega>\n 4. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>z x y.\n       z \\<squnion> x * y \\<le> x \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> x\n 2. \\<And>y. y\\<^sup>\\<omega> = y * y\\<^sup>\\<omega>\n 3. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z", "using ra_star_right_induct"], ["proof (prove)\nusing this:\n  ?z \\<squnion> ?x * ?y \\<le> ?x \\<longrightarrow>\n  ?z * ?y\\<^sup>\\<star> \\<le> ?x\n\ngoal (3 subgoals):\n 1. \\<And>z x y.\n       z \\<squnion> x * y \\<le> x \\<longrightarrow>\n       z * y\\<^sup>\\<star> \\<le> x\n 2. \\<And>y. y\\<^sup>\\<omega> = y * y\\<^sup>\\<omega>\n 3. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y. y\\<^sup>\\<omega> = y * y\\<^sup>\\<omega>\n 2. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z", "using ra_omega_unfold"], ["proof (prove)\nusing this:\n  ?y\\<^sup>\\<omega> = ?y * ?y\\<^sup>\\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>y. y\\<^sup>\\<omega> = y * y\\<^sup>\\<omega>\n 2. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z", "using ra_omega_induct"], ["proof (prove)\nusing this:\n  ?x \\<le> ?z \\<squnion> ?y * ?x \\<longrightarrow>\n  ?x \\<le> ?y\\<^sup>\\<omega> \\<squnion> ?y\\<^sup>\\<star> * ?z\n\ngoal (1 subgoal):\n 1. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<omega> \\<squnion> y\\<^sup>\\<star> * z", "by blast"], ["", "end"], ["", "text \\<open>Theorem 38\\<close>"], ["", "sublocale omega_relation_algebra < n_omega_algebra where sup = sup and bot = bot and top = top and inf = inf and n = N and L = top and apx = greater_eq and Omega = \"\\<lambda>x . N(x\\<^sup>\\<omega>) * top \\<squnion> x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.n_omega_algebra\n     (\\<lambda>x. N (x\\<^sup>\\<omega>) * top \\<squnion> x\\<^sup>\\<star>)\n     star (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot top omega\n     (\\<lambda>x y. y \\<le> x) N top (\\<sqinter>)", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       N (x\\<^sup>\\<omega>) * top \\<squnion> x\\<^sup>\\<star> =\n       N (x\\<^sup>\\<omega>) * top \\<squnion> x\\<^sup>\\<star>\n 2. \\<And>x.\n       N top * top \\<sqinter> x\\<^sup>\\<omega>\n       \\<le> x\\<^sup>\\<star> * N (x\\<^sup>\\<omega>) * top\n 3. \\<And>x. x * top \\<le> x * top * x * top", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       N top * top \\<sqinter> x\\<^sup>\\<omega>\n       \\<le> x\\<^sup>\\<star> * N (x\\<^sup>\\<omega>) * top\n 2. \\<And>x. x * top \\<le> x * top * x * top", "using n_split_omega_mult omega_vector star_mult_omega"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs * ?xo = ?xo; vector ?xo\\<rbrakk>\n  \\<Longrightarrow> N top * ?xo = ?xs * N ?xo * top\n  vector (?x\\<^sup>\\<omega>)\n  ?x\\<^sup>\\<star> * ?x\\<^sup>\\<omega> = ?x\\<^sup>\\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       N top * top \\<sqinter> x\\<^sup>\\<omega>\n       \\<le> x\\<^sup>\\<star> * N (x\\<^sup>\\<omega>) * top\n 2. \\<And>x. x * top \\<le> x * top * x * top", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x * top \\<le> x * top * x * top", "by simp"], ["", "end"]]}