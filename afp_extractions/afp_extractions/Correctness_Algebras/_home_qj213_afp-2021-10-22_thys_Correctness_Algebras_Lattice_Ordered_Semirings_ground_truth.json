{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Lattice_Ordered_Semirings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma top_mult_right_one:\n  \"x * top = x * top * 1\"", "lemma mult_left_sub_dist_inf_left:\n  \"x * (y \\<sqinter> z) \\<le> x * y\"", "lemma mult_left_sub_dist_inf_right:\n  \"x * (y \\<sqinter> z) \\<le> x * z\"", "lemma mult_right_sub_dist_inf_left:\n  \"(x \\<sqinter> y) * z \\<le> x * z\"", "lemma mult_right_sub_dist_inf_right:\n  \"(x \\<sqinter> y) * z \\<le> y * z\"", "lemma mult_right_sub_dist_inf:\n  \"(x \\<sqinter> y) * z \\<le> x * z \\<sqinter> y * z\"", "lemma reflexive_total:\n  \"reflexive x \\<Longrightarrow> total x\"", "lemma reflexive_dense:\n  \"reflexive x \\<Longrightarrow> dense_rel x\"", "lemma reflexive_transitive_up_closed:\n  \"reflexive x \\<Longrightarrow> transitive x \\<Longrightarrow> up_closed x\"", "lemma coreflexive_co_total:\n  \"coreflexive x \\<Longrightarrow> co_total x\"", "lemma coreflexive_transitive:\n  \"coreflexive x \\<Longrightarrow> transitive x\"", "lemma idempotent_transitive_dense:\n  \"idempotent x \\<longleftrightarrow> transitive x \\<and> dense_rel x\"", "lemma contact_reflexive:\n  \"contact x \\<Longrightarrow> reflexive x\"", "lemma contact_transitive:\n  \"contact x \\<Longrightarrow> transitive x\"", "lemma contact_dense:\n  \"contact x \\<Longrightarrow> dense_rel x\"", "lemma contact_idempotent:\n  \"contact x \\<Longrightarrow> idempotent x\"", "lemma contact_up_closed:\n  \"contact x \\<Longrightarrow> up_closed x\"", "lemma contact_reflexive_idempotent_up_closed:\n  \"contact x \\<longleftrightarrow> reflexive x \\<and> idempotent x \\<and> up_closed x\"", "lemma kernel_coreflexive:\n  \"kernel x \\<Longrightarrow> coreflexive x\"", "lemma kernel_transitive:\n  \"kernel x \\<Longrightarrow> transitive x\"", "lemma kernel_dense:\n  \"kernel x \\<Longrightarrow> dense_rel x\"", "lemma kernel_idempotent:\n  \"kernel x \\<Longrightarrow> idempotent x\"", "lemma kernel_up_closed:\n  \"kernel x \\<Longrightarrow> up_closed x\"", "lemma kernel_coreflexive_idempotent_up_closed:\n  \"kernel x \\<longleftrightarrow> coreflexive x \\<and> idempotent x \\<and> up_closed x\"", "lemma test_coreflexive:\n  \"test x \\<Longrightarrow> coreflexive x\"", "lemma test_up_closed:\n  \"test x \\<Longrightarrow> up_closed x\"", "lemma co_test_reflexive:\n  \"co_test x \\<Longrightarrow> reflexive x\"", "lemma co_test_transitive:\n  \"co_test x \\<Longrightarrow> transitive x\"", "lemma co_test_idempotent:\n  \"co_test x \\<Longrightarrow> idempotent x\"", "lemma co_test_up_closed:\n  \"co_test x \\<Longrightarrow> up_closed x\"", "lemma co_test_contact:\n  \"co_test x \\<Longrightarrow> contact x\"", "lemma vector_transitive:\n  \"vector x \\<Longrightarrow> transitive x\"", "lemma vector_up_closed:\n  \"vector x \\<Longrightarrow> up_closed x\"", "lemma one_total:\n  \"total 1\"", "lemma top_total:\n  \"total top\"", "lemma sup_total:\n  \"total x \\<Longrightarrow> total y \\<Longrightarrow> total (x \\<squnion> y)\"", "lemma zero_co_total:\n  \"co_total bot\"", "lemma one_co_total:\n  \"co_total 1\"", "lemma sup_co_total:\n  \"co_total x \\<Longrightarrow> co_total y \\<Longrightarrow> co_total (x \\<squnion> y)\"", "lemma inf_co_total:\n  \"co_total x \\<Longrightarrow> co_total y \\<Longrightarrow> co_total (x \\<sqinter> y)\"", "lemma comp_co_total:\n  \"co_total x \\<Longrightarrow> co_total y \\<Longrightarrow> co_total (x * y)\"", "lemma zero_transitive:\n  \"transitive bot\"", "lemma one_transitive:\n  \"transitive 1\"", "lemma top_transitive:\n  \"transitive top\"", "lemma inf_transitive:\n  \"transitive x \\<Longrightarrow> transitive y \\<Longrightarrow> transitive (x \\<sqinter> y)\"", "lemma zero_dense:\n  \"dense_rel bot\"", "lemma one_dense:\n  \"dense_rel 1\"", "lemma top_dense:\n  \"dense_rel top\"", "lemma sup_dense:\n  assumes \"dense_rel x\"\n      and \"dense_rel y\"\n    shows \"dense_rel (x \\<squnion> y)\"", "lemma one_reflexive:\n  \"reflexive 1\"", "lemma top_reflexive:\n  \"reflexive top\"", "lemma sup_reflexive:\n  \"reflexive x \\<Longrightarrow> reflexive y \\<Longrightarrow> reflexive (x \\<squnion> y)\"", "lemma inf_reflexive:\n  \"reflexive x \\<Longrightarrow> reflexive y \\<Longrightarrow> reflexive (x \\<sqinter> y)\"", "lemma comp_reflexive:\n  \"reflexive x \\<Longrightarrow> reflexive y \\<Longrightarrow> reflexive (x * y)\"", "lemma zero_coreflexive:\n  \"coreflexive bot\"", "lemma one_coreflexive:\n  \"coreflexive 1\"", "lemma sup_coreflexive:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive (x \\<squnion> y)\"", "lemma inf_coreflexive:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive (x \\<sqinter> y)\"", "lemma comp_coreflexive:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive (x * y)\"", "lemma zero_idempotent:\n  \"idempotent bot\"", "lemma one_idempotent:\n  \"idempotent 1\"", "lemma top_idempotent:\n  \"idempotent top\"", "lemma zero_up_closed:\n  \"up_closed bot\"", "lemma one_up_closed:\n  \"up_closed 1\"", "lemma top_up_closed:\n  \"up_closed top\"", "lemma sup_up_closed:\n  \"up_closed x \\<Longrightarrow> up_closed y \\<Longrightarrow> up_closed (x \\<squnion> y)\"", "lemma inf_up_closed:\n  \"up_closed x \\<Longrightarrow> up_closed y \\<Longrightarrow> up_closed (x \\<sqinter> y)\"", "lemma comp_up_closed:\n  \"up_closed x \\<Longrightarrow> up_closed y \\<Longrightarrow> up_closed (x * y)\"", "lemma zero_sup_distributive:\n  \"sup_distributive bot\"", "lemma one_sup_distributive:\n  \"sup_distributive 1\"", "lemma sup_sup_distributive:\n  \"sup_distributive x \\<Longrightarrow> sup_distributive y \\<Longrightarrow> sup_distributive (x \\<squnion> y)\"", "lemma zero_inf_distributive:\n  \"inf_distributive bot\"", "lemma one_inf_distributive:\n  \"inf_distributive 1\"", "lemma one_contact:\n  \"contact 1\"", "lemma top_contact:\n  \"contact top\"", "lemma inf_contact:\n  \"contact x \\<Longrightarrow> contact y \\<Longrightarrow> contact (x \\<sqinter> y)\"", "lemma zero_kernel:\n  \"kernel bot\"", "lemma one_kernel:\n  \"kernel 1\"", "lemma sup_kernel:\n  \"kernel x \\<Longrightarrow> kernel y \\<Longrightarrow> kernel (x \\<squnion> y)\"", "lemma one_sup_dist_contact:\n  \"sup_dist_contact 1\"", "lemma zero_inf_dist_kernel:\n  \"inf_dist_kernel bot\"", "lemma one_inf_dist_kernel:\n  \"inf_dist_kernel 1\"", "lemma zero_test:\n  \"test bot\"", "lemma one_test:\n  \"test 1\"", "lemma sup_test:\n  \"test x \\<Longrightarrow> test y \\<Longrightarrow> test (x \\<squnion> y)\"", "lemma inf_test:\n  \"test x \\<Longrightarrow> test y \\<Longrightarrow> test (x \\<sqinter> y)\"", "lemma one_co_test:\n  \"co_test 1\"", "lemma sup_co_test:\n  \"co_test x \\<Longrightarrow> co_test y \\<Longrightarrow> co_test (x \\<squnion> y)\"", "lemma zero_vector:\n  \"vector bot\"", "lemma top_vector:\n  \"vector top\"", "lemma sup_vector:\n  \"vector x \\<Longrightarrow> vector y \\<Longrightarrow> vector (x \\<squnion> y)\"", "lemma inf_vector:\n  \"vector x \\<Longrightarrow> vector y \\<Longrightarrow> vector (x \\<sqinter> y)\"", "lemma comp_vector:\n  \"vector y \\<Longrightarrow> vector (x * y)\"", "lemma mult_zero_associative:\n  \"x * bot * y = x * bot\"", "lemma mult_zero_sup_one_dist:\n  \"(x * bot \\<squnion> 1) * z = x * bot \\<squnion> z\"", "lemma mult_zero_sup_dist:\n  \"(x * bot \\<squnion> y) * z = x * bot \\<squnion> y * z\"", "lemma vector_zero_inf_one_comp:\n  \"(x * bot \\<sqinter> 1) * y = x * bot \\<sqinter> y\"", "lemma co_test_inf_distributive:\n  \"co_test x \\<Longrightarrow> inf_distributive x\"", "lemma co_test_sup_distributive:\n  \"co_test x \\<Longrightarrow> sup_distributive x\"", "lemma co_test_sup_dist_contact:\n  \"co_test x \\<Longrightarrow> sup_dist_contact x\"", "lemma inf_co_test:\n  \"co_test x \\<Longrightarrow> co_test y \\<Longrightarrow> co_test (x \\<sqinter> y)\"", "lemma comp_co_test:\n  \"co_test x \\<Longrightarrow> co_test y \\<Longrightarrow> co_test (x * y)\"", "lemma top_sup_distributive:\n  \"sup_distributive top\"", "lemma top_inf_distributive:\n  \"inf_distributive top\"", "lemma top_sup_dist_contact:\n  \"sup_dist_contact top\"", "lemma top_co_test:\n  \"co_test top\"", "lemma mult_top_associative:\n  \"x * top * y = x * top\"", "lemma vector_inf_one_comp:\n  \"(x * top \\<sqinter> 1) * y = x * top \\<sqinter> y\"", "lemma vector_left_annihilator:\n  \"vector x \\<Longrightarrow> x * y = x\"", "lemma test_comp_inf:\n  \"test x \\<Longrightarrow> test y \\<Longrightarrow> x * y = x \\<sqinter> y\"", "lemma test_sup_distributive:\n  \"test x \\<Longrightarrow> sup_distributive x\"", "lemma test_inf_distributive:\n  \"test x \\<Longrightarrow> inf_distributive x\"", "lemma test_inf_dist_kernel:\n  \"test x \\<Longrightarrow> inf_dist_kernel x\"", "lemma vector_idempotent:\n  \"vector x \\<Longrightarrow> idempotent x\"", "lemma vector_sup_distributive:\n  \"vector x \\<Longrightarrow> sup_distributive x\"", "lemma vector_inf_distributive:\n  \"vector x \\<Longrightarrow> inf_distributive x\"", "lemma vector_co_vector:\n  \"vector x \\<longleftrightarrow> co_vector x\"", "lemma comp_test:\n  \"test x \\<Longrightarrow> test y \\<Longrightarrow> test (x * y)\"", "lemma dual_dist_inf:\n  \"(x \\<sqinter> y)\\<^sup>d = x\\<^sup>d \\<squnion> y\\<^sup>d\"", "lemma dual_antitone:\n  \"x \\<le> y \\<Longrightarrow> y\\<^sup>d \\<le> x\\<^sup>d\"", "lemma dual_zero:\n  \"bot\\<^sup>d = top\"", "lemma dual_top:\n  \"top\\<^sup>d = bot\"", "lemma reflexive_coreflexive_dual:\n  \"reflexive x \\<longleftrightarrow> coreflexive (x\\<^sup>d)\"", "lemma dual_sub_dist_comp_one:\n  \"(x * y)\\<^sup>d \\<le> (x * 1)\\<^sup>d * y\\<^sup>d\"", "lemma co_total_total_dual:\n  \"co_total x \\<Longrightarrow> total (x\\<^sup>d)\"", "lemma transitive_dense_dual:\n  \"transitive x \\<Longrightarrow> dense_rel (x\\<^sup>d)\"", "lemma strong_up_closed:\n  \"x * 1 \\<le> x \\<Longrightarrow> x\\<^sup>d * y\\<^sup>d \\<le> (x * y)\\<^sup>d\"", "lemma strong_up_closed_2:\n  \"up_closed x \\<Longrightarrow> (x * y)\\<^sup>d = x\\<^sup>d * y\\<^sup>d\"", "lemma dual_up_closed:\n  \"up_closed x \\<longleftrightarrow> up_closed (x\\<^sup>d)\"", "lemma contact_kernel_dual:\n  \"contact x \\<longleftrightarrow> kernel (x\\<^sup>d)\"", "lemma sup_dist_contact_inf_dist_kernel_dual:\n  \"sup_dist_contact x \\<longleftrightarrow> inf_dist_kernel (x\\<^sup>d)\"", "lemma test_co_test_dual:\n  \"test x \\<longleftrightarrow> co_test (x\\<^sup>d)\"", "lemma vector_dual:\n  \"vector x \\<longleftrightarrow> vector (x\\<^sup>d)\"", "lemma mult_right_dist_inf:\n  \"(x \\<sqinter> y) * z = x * z \\<sqinter> y * z\"", "lemma vector_inf_comp:\n  \"(x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z\"", "lemma vector_zero_inf_comp:\n  \"(x * bot \\<sqinter> y) * z = x * bot \\<sqinter> y * z\"", "lemma inf_total:\n  \"total x \\<Longrightarrow> total y \\<Longrightarrow> total (x \\<sqinter> y)\"", "lemma comp_total:\n  \"total x \\<Longrightarrow> total y \\<Longrightarrow> total (x * y)\"", "lemma total_co_total_dual:\n  \"total x \\<longleftrightarrow> co_total (x\\<^sup>d)\"", "lemma transitive_iff_dense_dual:\n  \"transitive x \\<longleftrightarrow> dense_rel (x\\<^sup>d)\"", "lemma idempotent_dual:\n  \"idempotent x \\<longleftrightarrow> idempotent (x\\<^sup>d)\"", "lemma comp_sup_distributive:\n  \"sup_distributive x \\<Longrightarrow> sup_distributive y \\<Longrightarrow> sup_distributive (x * y)\"", "lemma sup_inf_distributive_dual:\n  \"sup_distributive x \\<longleftrightarrow> inf_distributive (x\\<^sup>d)\"", "lemma inf_inf_distributive:\n  \"inf_distributive x \\<Longrightarrow> inf_distributive y \\<Longrightarrow> inf_distributive (x \\<sqinter> y)\"", "lemma comp_inf_distributive:\n  \"inf_distributive x \\<Longrightarrow> inf_distributive y \\<Longrightarrow> inf_distributive (x * y)\"", "lemma vector_zero_inf_comp:\n  \"(x * bot \\<sqinter> y) * z = x * bot \\<sqinter> y * z\"", "lemma test_sup_distributive:\n  \"test x \\<Longrightarrow> sup_distributive x\"", "lemma test_inf_distributive:\n  \"test x \\<Longrightarrow> inf_distributive x\"", "lemma test_inf_dist_kernel:\n  \"test x \\<Longrightarrow> inf_dist_kernel x\"", "lemma co_test_inf_distributive:\n  assumes \"co_test x\"\n    shows \"inf_distributive x\"", "lemma co_test_sup_distributive:\n  assumes \"co_test x\"\n    shows \"sup_distributive x\"", "lemma co_test_sup_dist_contact:\n  \"co_test x \\<Longrightarrow> sup_dist_contact x\""], "translations": [["", "lemma top_mult_right_one:\n  \"x * top = x * top * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top = x * top * (1::'a)", "by (metis order.antisym mult_sub_right_one mult_sup_associative_one surjective_one_closed)"], ["", "lemma mult_left_sub_dist_inf_left:\n  \"x * (y \\<sqinter> z) \\<le> x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> z) \\<le> x * y", "by (simp add: mult_right_isotone)"], ["", "lemma mult_left_sub_dist_inf_right:\n  \"x * (y \\<sqinter> z) \\<le> x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> z) \\<le> x * z", "by (simp add: mult_right_isotone)"], ["", "lemma mult_right_sub_dist_inf_left:\n  \"(x \\<sqinter> y) * z \\<le> x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y) * z \\<le> x * z", "by (simp add: mult_left_isotone)"], ["", "lemma mult_right_sub_dist_inf_right:\n  \"(x \\<sqinter> y) * z \\<le> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y) * z \\<le> y * z", "by (simp add: mult_left_isotone)"], ["", "lemma mult_right_sub_dist_inf:\n  \"(x \\<sqinter> y) * z \\<le> x * z \\<sqinter> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y) * z \\<le> x * z \\<sqinter> y * z", "by (simp add: mult_right_sub_dist_inf_left mult_right_sub_dist_inf_right)"], ["", "text \\<open>Figure 1: fundamental properties\\<close>"], ["", "definition co_total          :: \"'a \\<Rightarrow> bool\" where \"co_total x \\<equiv> x * bot = bot\""], ["", "definition up_closed         :: \"'a \\<Rightarrow> bool\" where \"up_closed x \\<equiv> x * 1 = x\""], ["", "definition sup_distributive  :: \"'a \\<Rightarrow> bool\" where \"sup_distributive x \\<equiv> (\\<forall>y z . x * (y \\<squnion> z) = x * y \\<squnion> x * z)\""], ["", "definition inf_distributive  :: \"'a \\<Rightarrow> bool\" where \"inf_distributive x \\<equiv> (\\<forall>y z . x * (y \\<sqinter> z) = x * y \\<sqinter> x * z)\""], ["", "definition contact           :: \"'a \\<Rightarrow> bool\" where \"contact x \\<equiv> x * x \\<squnion> 1 = x\""], ["", "definition kernel            :: \"'a \\<Rightarrow> bool\" where \"kernel x \\<equiv> x * x \\<sqinter> 1 = x * 1\""], ["", "definition sup_dist_contact  :: \"'a \\<Rightarrow> bool\" where \"sup_dist_contact x \\<equiv> sup_distributive x \\<and> contact x\""], ["", "definition inf_dist_kernel   :: \"'a \\<Rightarrow> bool\" where \"inf_dist_kernel x \\<equiv> inf_distributive x \\<and> kernel x\""], ["", "definition test              :: \"'a \\<Rightarrow> bool\" where \"test x \\<equiv> x * top \\<sqinter> 1 = x\""], ["", "definition co_test           :: \"'a \\<Rightarrow> bool\" where \"co_test x \\<equiv> x * bot \\<squnion> 1 = x\""], ["", "definition co_vector         :: \"'a \\<Rightarrow> bool\" where \"co_vector x \\<equiv> x * bot = x\""], ["", "text \\<open>AAMP Theorem 6 / Figure 2: relations between properties\\<close>"], ["", "lemma reflexive_total:\n  \"reflexive x \\<Longrightarrow> total x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> times_top_class.total x", "using sup_left_divisibility total_sup_closed"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (\\<exists>z. ?x \\<squnion> z = ?y)\n  times_top_class.total ?x \\<Longrightarrow>\n  times_top_class.total (?x \\<squnion> ?y)\n\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> times_top_class.total x", "by force"], ["", "lemma reflexive_dense:\n  \"reflexive x \\<Longrightarrow> dense_rel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> dense_rel x", "using mult_left_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> dense_rel x", "by fastforce"], ["", "lemma reflexive_transitive_up_closed:\n  \"reflexive x \\<Longrightarrow> transitive x \\<Longrightarrow> up_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reflexive x; transitive x\\<rbrakk>\n    \\<Longrightarrow> up_closed x", "by (metis antisym_conv mult_isotone mult_sub_right_one reflexive_dense up_closed_def)"], ["", "lemma coreflexive_co_total:\n  \"coreflexive x \\<Longrightarrow> co_total x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> co_total x", "by (metis co_total_def order.eq_iff mult_left_isotone mult_left_one bot_least)"], ["", "lemma coreflexive_transitive:\n  \"coreflexive x \\<Longrightarrow> transitive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> transitive x", "by (simp add: coreflexive_transitive)"], ["", "lemma idempotent_transitive_dense:\n  \"idempotent x \\<longleftrightarrow> transitive x \\<and> dense_rel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent x = (transitive x \\<and> dense_rel x)", "by (simp add: order.eq_iff)"], ["", "lemma contact_reflexive:\n  \"contact x \\<Longrightarrow> reflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contact x \\<Longrightarrow> reflexive x", "using contact_def sup_right_divisibility"], ["proof (prove)\nusing this:\n  contact ?x \\<equiv> ?x * ?x \\<squnion> (1::'a) = ?x\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n\ngoal (1 subgoal):\n 1. contact x \\<Longrightarrow> reflexive x", "by auto"], ["", "lemma contact_transitive:\n  \"contact x \\<Longrightarrow> transitive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contact x \\<Longrightarrow> transitive x", "using contact_def sup_left_divisibility"], ["proof (prove)\nusing this:\n  contact ?x \\<equiv> ?x * ?x \\<squnion> (1::'a) = ?x\n  (?x \\<le> ?y) = (\\<exists>z. ?x \\<squnion> z = ?y)\n\ngoal (1 subgoal):\n 1. contact x \\<Longrightarrow> transitive x", "by blast"], ["", "lemma contact_dense:\n  \"contact x \\<Longrightarrow> dense_rel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contact x \\<Longrightarrow> dense_rel x", "by (simp add: contact_reflexive reflexive_dense)"], ["", "lemma contact_idempotent:\n  \"contact x \\<Longrightarrow> idempotent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contact x \\<Longrightarrow> idempotent x", "by (simp add: contact_dense contact_transitive idempotent_transitive_dense)"], ["", "lemma contact_up_closed:\n  \"contact x \\<Longrightarrow> up_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contact x \\<Longrightarrow> up_closed x", "by (simp add: contact_reflexive contact_transitive reflexive_transitive_up_closed)"], ["", "lemma contact_reflexive_idempotent_up_closed:\n  \"contact x \\<longleftrightarrow> reflexive x \\<and> idempotent x \\<and> up_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contact x = (reflexive x \\<and> idempotent x \\<and> up_closed x)", "by (metis contact_def contact_idempotent contact_reflexive contact_up_closed sup_absorb2 sup_monoid.add_commute)"], ["", "lemma kernel_coreflexive:\n  \"kernel x \\<Longrightarrow> coreflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel x \\<Longrightarrow> coreflexive x", "by (metis kernel_def inf.boundedE mult_sub_right_one)"], ["", "lemma kernel_transitive:\n  \"kernel x \\<Longrightarrow> transitive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel x \\<Longrightarrow> transitive x", "by (simp add: coreflexive_transitive kernel_coreflexive)"], ["", "lemma kernel_dense:\n  \"kernel x \\<Longrightarrow> dense_rel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel x \\<Longrightarrow> dense_rel x", "by (metis kernel_def inf.boundedE mult_sub_right_one)"], ["", "lemma kernel_idempotent:\n  \"kernel x \\<Longrightarrow> idempotent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel x \\<Longrightarrow> idempotent x", "by (simp add: idempotent_transitive_dense kernel_dense kernel_transitive)"], ["", "lemma kernel_up_closed:\n  \"kernel x \\<Longrightarrow> up_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel x \\<Longrightarrow> up_closed x", "by (metis kernel_coreflexive kernel_def kernel_idempotent inf.absorb1 up_closed_def)"], ["", "lemma kernel_coreflexive_idempotent_up_closed:\n  \"kernel x \\<longleftrightarrow> coreflexive x \\<and> idempotent x \\<and> up_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel x = (coreflexive x \\<and> idempotent x \\<and> up_closed x)", "by (metis kernel_coreflexive kernel_def kernel_idempotent inf.absorb1 up_closed_def)"], ["", "lemma test_coreflexive:\n  \"test x \\<Longrightarrow> coreflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test x \\<Longrightarrow> coreflexive x", "using inf.sup_right_divisibility test_def"], ["proof (prove)\nusing this:\n  (?y \\<le> ?x) = (\\<exists>z. z \\<sqinter> ?x = ?y)\n  test ?x \\<equiv> ?x * top \\<sqinter> (1::'a) = ?x\n\ngoal (1 subgoal):\n 1. test x \\<Longrightarrow> coreflexive x", "by blast"], ["", "lemma test_up_closed:\n  \"test x \\<Longrightarrow> up_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test x \\<Longrightarrow> up_closed x", "by (metis order.eq_iff mult_left_one mult_sub_right_one mult_right_sub_dist_inf test_def top_mult_right_one up_closed_def)"], ["", "lemma co_test_reflexive:\n  \"co_test x \\<Longrightarrow> reflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test x \\<Longrightarrow> reflexive x", "using co_test_def sup_right_divisibility"], ["proof (prove)\nusing this:\n  co_test ?x \\<equiv> ?x * bot \\<squnion> (1::'a) = ?x\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n\ngoal (1 subgoal):\n 1. co_test x \\<Longrightarrow> reflexive x", "by blast"], ["", "lemma co_test_transitive:\n  \"co_test x \\<Longrightarrow> transitive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test x \\<Longrightarrow> transitive x", "by (smt co_test_def sup_assoc le_iff_sup mult_left_one mult_left_zero mult_right_dist_sup mult_semi_associative)"], ["", "lemma co_test_idempotent:\n  \"co_test x \\<Longrightarrow> idempotent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test x \\<Longrightarrow> idempotent x", "by (simp add: co_test_reflexive co_test_transitive idempotent_transitive_dense reflexive_dense)"], ["", "lemma co_test_up_closed:\n  \"co_test x \\<Longrightarrow> up_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test x \\<Longrightarrow> up_closed x", "by (simp add: co_test_reflexive co_test_transitive reflexive_transitive_up_closed)"], ["", "lemma co_test_contact:\n  \"co_test x \\<Longrightarrow> contact x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test x \\<Longrightarrow> contact x", "by (simp add: co_test_idempotent co_test_reflexive co_test_up_closed contact_reflexive_idempotent_up_closed)"], ["", "lemma vector_transitive:\n  \"vector x \\<Longrightarrow> transitive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> transitive x", "by (metis mult_right_isotone top.extremum)"], ["", "lemma vector_up_closed:\n  \"vector x \\<Longrightarrow> up_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> up_closed x", "by (metis top_mult_right_one up_closed_def)"], ["", "text \\<open>AAMP Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>total\\<close>"], ["", "lemma one_total:\n  \"total 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_top_class.total (1::'a)", "by simp"], ["", "lemma top_total:\n  \"total top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by simp"], ["", "lemma sup_total:\n  \"total x \\<Longrightarrow> total y \\<Longrightarrow> total (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>times_top_class.total x; times_top_class.total y\\<rbrakk>\n    \\<Longrightarrow> times_top_class.total (x \\<squnion> y)", "by (simp add: total_sup_closed)"], ["", "text \\<open>co-total\\<close>"], ["", "lemma zero_co_total:\n  \"co_total bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_total bot", "by (simp add: co_total_def)"], ["", "lemma one_co_total:\n  \"co_total 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_total (1::'a)", "by (simp add: co_total_def)"], ["", "lemma sup_co_total:\n  \"co_total x \\<Longrightarrow> co_total y \\<Longrightarrow> co_total (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>co_total x; co_total y\\<rbrakk>\n    \\<Longrightarrow> co_total (x \\<squnion> y)", "by (simp add: co_total_def mult_right_dist_sup)"], ["", "lemma inf_co_total:\n  \"co_total x \\<Longrightarrow> co_total y \\<Longrightarrow> co_total (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>co_total x; co_total y\\<rbrakk>\n    \\<Longrightarrow> co_total (x \\<sqinter> y)", "by (metis co_total_def order.antisym bot_least mult_right_sub_dist_inf_right)"], ["", "lemma comp_co_total:\n  \"co_total x \\<Longrightarrow> co_total y \\<Longrightarrow> co_total (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>co_total x; co_total y\\<rbrakk>\n    \\<Longrightarrow> co_total (x * y)", "by (metis co_total_def order.eq_iff mult_semi_associative bot_least)"], ["", "text \\<open>sub-transitive\\<close>"], ["", "lemma zero_transitive:\n  \"transitive bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive bot", "by (simp add: vector_transitive)"], ["", "lemma one_transitive:\n  \"transitive 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive (1::'a)", "by simp"], ["", "lemma top_transitive:\n  \"transitive top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive top", "by simp"], ["", "lemma inf_transitive:\n  \"transitive x \\<Longrightarrow> transitive y \\<Longrightarrow> transitive (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>transitive x; transitive y\\<rbrakk>\n    \\<Longrightarrow> transitive (x \\<sqinter> y)", "by (meson inf_mono order_trans mult_left_sub_dist_inf_left mult_left_sub_dist_inf_right mult_right_sub_dist_inf)"], ["", "text \\<open>dense\\<close>"], ["", "lemma zero_dense:\n  \"dense_rel bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_rel bot", "by simp"], ["", "lemma one_dense:\n  \"dense_rel 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_rel (1::'a)", "by simp"], ["", "lemma top_dense:\n  \"dense_rel top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_rel top", "by simp"], ["", "lemma sup_dense:\n  assumes \"dense_rel x\"\n      and \"dense_rel y\"\n    shows \"dense_rel (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_rel (x \\<squnion> y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dense_rel (x \\<squnion> y)", "have \"x \\<le> x * x \\<and> y \\<le> y * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_rel x \\<and> dense_rel y", "using assms"], ["proof (prove)\nusing this:\n  dense_rel x\n  dense_rel y\n\ngoal (1 subgoal):\n 1. dense_rel x \\<and> dense_rel y", "by auto"], ["proof (state)\nthis:\n  dense_rel x \\<and> dense_rel y\n\ngoal (1 subgoal):\n 1. dense_rel (x \\<squnion> y)", "hence \"x \\<le> (x \\<squnion> y) * (x \\<squnion> y) \\<and> y \\<le> (x \\<squnion> y) * (x \\<squnion> y)\""], ["proof (prove)\nusing this:\n  dense_rel x \\<and> dense_rel y\n\ngoal (1 subgoal):\n 1. x \\<le> (x \\<squnion> y) * (x \\<squnion> y) \\<and>\n    y \\<le> (x \\<squnion> y) * (x \\<squnion> y)", "by (meson dense_sup_closed order_trans sup.cobounded1 sup.cobounded2)"], ["proof (state)\nthis:\n  x \\<le> (x \\<squnion> y) * (x \\<squnion> y) \\<and>\n  y \\<le> (x \\<squnion> y) * (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. dense_rel (x \\<squnion> y)", "hence \"x \\<squnion> y \\<le> (x \\<squnion> y) * (x \\<squnion> y)\""], ["proof (prove)\nusing this:\n  x \\<le> (x \\<squnion> y) * (x \\<squnion> y) \\<and>\n  y \\<le> (x \\<squnion> y) * (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. dense_rel (x \\<squnion> y)", "by simp"], ["proof (state)\nthis:\n  dense_rel (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. dense_rel (x \\<squnion> y)", "thus \"dense_rel (x \\<squnion> y)\""], ["proof (prove)\nusing this:\n  dense_rel (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. dense_rel (x \\<squnion> y)", "by simp"], ["proof (state)\nthis:\n  dense_rel (x \\<squnion> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>reflexive\\<close>"], ["", "lemma one_reflexive:\n  \"reflexive 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (1::'a)", "by simp"], ["", "lemma top_reflexive:\n  \"reflexive top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive top", "by simp"], ["", "lemma sup_reflexive:\n  \"reflexive x \\<Longrightarrow> reflexive y \\<Longrightarrow> reflexive (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reflexive x; reflexive y\\<rbrakk>\n    \\<Longrightarrow> reflexive (x \\<squnion> y)", "by (simp add: reflexive_sup_closed)"], ["", "lemma inf_reflexive:\n  \"reflexive x \\<Longrightarrow> reflexive y \\<Longrightarrow> reflexive (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reflexive x; reflexive y\\<rbrakk>\n    \\<Longrightarrow> reflexive (x \\<sqinter> y)", "by simp"], ["", "lemma comp_reflexive:\n  \"reflexive x \\<Longrightarrow> reflexive y \\<Longrightarrow> reflexive (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reflexive x; reflexive y\\<rbrakk>\n    \\<Longrightarrow> reflexive (x * y)", "using reflexive_mult_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>reflexive ?x; reflexive ?y\\<rbrakk>\n  \\<Longrightarrow> reflexive (?x * ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reflexive x; reflexive y\\<rbrakk>\n    \\<Longrightarrow> reflexive (x * y)", "by auto"], ["", "text \\<open>co-reflexive\\<close>"], ["", "lemma zero_coreflexive:\n  \"coreflexive bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive bot", "by simp"], ["", "lemma one_coreflexive:\n  \"coreflexive 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (1::'a)", "by simp"], ["", "lemma sup_coreflexive:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coreflexive x; coreflexive y\\<rbrakk>\n    \\<Longrightarrow> coreflexive (x \\<squnion> y)", "by simp"], ["", "lemma inf_coreflexive:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coreflexive x; coreflexive y\\<rbrakk>\n    \\<Longrightarrow> coreflexive (x \\<sqinter> y)", "by (simp add: le_infI1)"], ["", "lemma comp_coreflexive:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coreflexive x; coreflexive y\\<rbrakk>\n    \\<Longrightarrow> coreflexive (x * y)", "by (simp add: coreflexive_mult_closed)"], ["", "text \\<open>idempotent\\<close>"], ["", "lemma zero_idempotent:\n  \"idempotent bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent bot", "by simp"], ["", "lemma one_idempotent:\n  \"idempotent 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent (1::'a)", "by simp"], ["", "lemma top_idempotent:\n  \"idempotent top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by simp"], ["", "text \\<open>up-closed\\<close>"], ["", "lemma zero_up_closed:\n  \"up_closed bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed bot", "by (simp add: up_closed_def)"], ["", "lemma one_up_closed:\n  \"up_closed 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed (1::'a)", "by (simp add: up_closed_def)"], ["", "lemma top_up_closed:\n  \"up_closed top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed top", "by (simp add: vector_up_closed)"], ["", "lemma sup_up_closed:\n  \"up_closed x \\<Longrightarrow> up_closed y \\<Longrightarrow> up_closed (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>up_closed x; up_closed y\\<rbrakk>\n    \\<Longrightarrow> up_closed (x \\<squnion> y)", "by (simp add: mult_right_dist_sup up_closed_def)"], ["", "lemma inf_up_closed:\n  \"up_closed x \\<Longrightarrow> up_closed y \\<Longrightarrow> up_closed (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>up_closed x; up_closed y\\<rbrakk>\n    \\<Longrightarrow> up_closed (x \\<sqinter> y)", "by (metis order.antisym mult_sub_right_one mult_right_sub_dist_inf up_closed_def)"], ["", "lemma comp_up_closed:\n  \"up_closed x \\<Longrightarrow> up_closed y \\<Longrightarrow> up_closed (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>up_closed x; up_closed y\\<rbrakk>\n    \\<Longrightarrow> up_closed (x * y)", "by (metis order.antisym mult_semi_associative mult_sub_right_one up_closed_def)"], ["", "text \\<open>add-distributive\\<close>"], ["", "lemma zero_sup_distributive:\n  \"sup_distributive bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_distributive bot", "by (simp add: sup_distributive_def)"], ["", "lemma one_sup_distributive:\n  \"sup_distributive 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_distributive (1::'a)", "by (simp add: sup_distributive_def)"], ["", "lemma sup_sup_distributive:\n  \"sup_distributive x \\<Longrightarrow> sup_distributive y \\<Longrightarrow> sup_distributive (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sup_distributive x; sup_distributive y\\<rbrakk>\n    \\<Longrightarrow> sup_distributive (x \\<squnion> y)", "using sup_distributive_def mult_right_dist_sup sup_monoid.add_assoc sup_monoid.add_commute"], ["proof (prove)\nusing this:\n  sup_distributive ?x \\<equiv>\n  \\<forall>y z. ?x * (y \\<squnion> z) = ?x * y \\<squnion> ?x * z\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n  ?a \\<squnion> ?b \\<squnion> ?c = ?a \\<squnion> (?b \\<squnion> ?c)\n  ?a \\<squnion> ?b = ?b \\<squnion> ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sup_distributive x; sup_distributive y\\<rbrakk>\n    \\<Longrightarrow> sup_distributive (x \\<squnion> y)", "by auto"], ["", "text \\<open>inf-distributive\\<close>"], ["", "lemma zero_inf_distributive:\n  \"inf_distributive bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_distributive bot", "by (simp add: inf_distributive_def)"], ["", "lemma one_inf_distributive:\n  \"inf_distributive 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_distributive (1::'a)", "by (simp add: inf_distributive_def)"], ["", "text \\<open>contact\\<close>"], ["", "lemma one_contact:\n  \"contact 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contact (1::'a)", "by (simp add: contact_def)"], ["", "lemma top_contact:\n  \"contact top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contact top", "by (simp add: contact_def)"], ["", "lemma inf_contact:\n  \"contact x \\<Longrightarrow> contact y \\<Longrightarrow> contact (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>contact x; contact y\\<rbrakk>\n    \\<Longrightarrow> contact (x \\<sqinter> y)", "by (meson contact_reflexive_idempotent_up_closed contact_transitive inf_reflexive inf_transitive inf_up_closed preorder_idempotent)"], ["", "text \\<open>kernel\\<close>"], ["", "lemma zero_kernel:\n  \"kernel bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel bot", "by (simp add: kernel_def)"], ["", "lemma one_kernel:\n  \"kernel 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel (1::'a)", "by (simp add: kernel_def)"], ["", "lemma sup_kernel:\n  \"kernel x \\<Longrightarrow> kernel y \\<Longrightarrow> kernel (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>kernel x; kernel y\\<rbrakk>\n    \\<Longrightarrow> kernel (x \\<squnion> y)", "using kernel_coreflexive_idempotent_up_closed order.antisym coreflexive_transitive sup_dense sup_up_closed"], ["proof (prove)\nusing this:\n  kernel ?x = (coreflexive ?x \\<and> idempotent ?x \\<and> up_closed ?x)\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  coreflexive ?x \\<Longrightarrow> transitive ?x\n  \\<lbrakk>dense_rel ?x; dense_rel ?y\\<rbrakk>\n  \\<Longrightarrow> dense_rel (?x \\<squnion> ?y)\n  \\<lbrakk>up_closed ?x; up_closed ?y\\<rbrakk>\n  \\<Longrightarrow> up_closed (?x \\<squnion> ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>kernel x; kernel y\\<rbrakk>\n    \\<Longrightarrow> kernel (x \\<squnion> y)", "by force"], ["", "text \\<open>add-distributive contact\\<close>"], ["", "lemma one_sup_dist_contact:\n  \"sup_dist_contact 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_dist_contact (1::'a)", "by (simp add: sup_dist_contact_def one_sup_distributive one_contact)"], ["", "text \\<open>inf-distributive kernel\\<close>"], ["", "lemma zero_inf_dist_kernel:\n  \"inf_dist_kernel bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_dist_kernel bot", "by (simp add: inf_dist_kernel_def zero_kernel zero_inf_distributive)"], ["", "lemma one_inf_dist_kernel:\n  \"inf_dist_kernel 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_dist_kernel (1::'a)", "by (simp add: inf_dist_kernel_def one_kernel one_inf_distributive)"], ["", "text \\<open>test\\<close>"], ["", "lemma zero_test:\n  \"test bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test bot", "by (simp add: test_def)"], ["", "lemma one_test:\n  \"test 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test (1::'a)", "by (simp add: test_def)"], ["", "lemma sup_test:\n  \"test x \\<Longrightarrow> test y \\<Longrightarrow> test (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>test x; test y\\<rbrakk> \\<Longrightarrow> test (x \\<squnion> y)", "by (simp add: inf_sup_distrib2 mult_right_dist_sup test_def)"], ["", "lemma inf_test:\n  \"test x \\<Longrightarrow> test y \\<Longrightarrow> test (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>test x; test y\\<rbrakk> \\<Longrightarrow> test (x \\<sqinter> y)", "by (smt (z3) inf.left_commute idempotent_one_closed inf.le_iff_sup inf_top.right_neutral mult_right_isotone mult_sub_right_one mult_right_sub_dist_inf test_def top_mult_right_one)"], ["", "text \\<open>co-test\\<close>"], ["", "lemma one_co_test:\n  \"co_test 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test (1::'a)", "by (simp add: co_test_def)"], ["", "lemma sup_co_test:\n  \"co_test x \\<Longrightarrow> co_test y \\<Longrightarrow> co_test (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>co_test x; co_test y\\<rbrakk>\n    \\<Longrightarrow> co_test (x \\<squnion> y)", "by (smt (z3) co_test_def mult_right_dist_sup sup.left_idem sup_assoc sup_commute)"], ["", "text \\<open>vector\\<close>"], ["", "lemma zero_vector:\n  \"vector bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector bot", "by simp"], ["", "lemma top_vector:\n  \"vector top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by simp"], ["", "lemma sup_vector:\n  \"vector x \\<Longrightarrow> vector y \\<Longrightarrow> vector (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vector x; vector y\\<rbrakk>\n    \\<Longrightarrow> vector (x \\<squnion> y)", "by (simp add: vector_sup_closed)"], ["", "lemma inf_vector:\n  \"vector x \\<Longrightarrow> vector y \\<Longrightarrow> vector (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vector x; vector y\\<rbrakk>\n    \\<Longrightarrow> vector (x \\<sqinter> y)", "by (metis order.antisym top_right_mult_increasing mult_right_sub_dist_inf)"], ["", "lemma comp_vector:\n  \"vector y \\<Longrightarrow> vector (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector y \\<Longrightarrow> vector (x * y)", "by (simp add: vector_mult_closed)"], ["", "end"], ["", "class lattice_ordered_pre_left_semiring_1 = non_associative_left_semiring + bounded_distrib_lattice +\n  assumes mult_associative_one: \"x * (y * z) = (x * (y * 1)) * z\"\n  assumes mult_right_dist_inf_one: \"(x * 1 \\<sqinter> y * 1) * z = x * z \\<sqinter> y * z\"\nbegin"], ["", "subclass pre_left_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pre_left_semiring (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z. x * y * z \\<le> x * (y * z)", "by (metis mult_associative_one mult_left_isotone mult_right_isotone mult_sub_right_one)"], ["", "subclass lattice_ordered_pre_left_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.lattice_ordered_pre_left_semiring (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) bot top (1::'a) (*)", ".."], ["", "lemma mult_zero_associative:\n  \"x * bot * y = x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot * y = x * bot", "by (metis mult_associative_one mult_left_zero)"], ["", "lemma mult_zero_sup_one_dist:\n  \"(x * bot \\<squnion> 1) * z = x * bot \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * bot \\<squnion> (1::'a)) * z = x * bot \\<squnion> z", "by (simp add: mult_right_dist_sup mult_zero_associative)"], ["", "lemma mult_zero_sup_dist:\n  \"(x * bot \\<squnion> y) * z = x * bot \\<squnion> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * bot \\<squnion> y) * z = x * bot \\<squnion> y * z", "by (simp add: mult_right_dist_sup mult_zero_associative)"], ["", "lemma vector_zero_inf_one_comp:\n  \"(x * bot \\<sqinter> 1) * y = x * bot \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * bot \\<sqinter> (1::'a)) * y = x * bot \\<sqinter> y", "by (metis mult_left_one mult_right_dist_inf_one mult_zero_associative)"], ["", "text \\<open>AAMP Theorem 6 / Figure 2: relations between properties\\<close>"], ["", "lemma co_test_inf_distributive:\n  \"co_test x \\<Longrightarrow> inf_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test x \\<Longrightarrow> inf_distributive x", "by (metis co_test_def distrib_imp1 inf_sup_distrib1 inf_distributive_def mult_zero_sup_one_dist)"], ["", "lemma co_test_sup_distributive:\n  \"co_test x \\<Longrightarrow> sup_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test x \\<Longrightarrow> sup_distributive x", "by (metis sup_sup_distributive sup_distributive_def co_test_def one_sup_distributive sup.idem mult_zero_associative)"], ["", "lemma co_test_sup_dist_contact:\n  \"co_test x \\<Longrightarrow> sup_dist_contact x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test x \\<Longrightarrow> sup_dist_contact x", "by (simp add: co_test_sup_distributive sup_dist_contact_def co_test_contact)"], ["", "text \\<open>AAMP Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>co-test\\<close>"], ["", "lemma inf_co_test:\n  \"co_test x \\<Longrightarrow> co_test y \\<Longrightarrow> co_test (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>co_test x; co_test y\\<rbrakk>\n    \\<Longrightarrow> co_test (x \\<sqinter> y)", "by (smt (z3) co_test_def co_test_up_closed mult_right_dist_inf_one sup_commute sup_inf_distrib1 up_closed_def)"], ["", "lemma comp_co_test:\n  \"co_test x \\<Longrightarrow> co_test y \\<Longrightarrow> co_test (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>co_test x; co_test y\\<rbrakk> \\<Longrightarrow> co_test (x * y)", "by (metis co_test_def mult_associative_one sup_assoc mult_zero_sup_one_dist)"], ["", "end"], ["", "class lattice_ordered_pre_left_semiring_2 = lattice_ordered_pre_left_semiring +\n  assumes mult_sub_associative_one: \"x * (y * z) \\<le> (x * (y * 1)) * z\"\n  assumes mult_right_dist_inf_one_sub: \"x * z \\<sqinter> y * z \\<le> (x * 1 \\<sqinter> y * 1) * z\"\nbegin"], ["", "subclass lattice_ordered_pre_left_semiring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.lattice_ordered_pre_left_semiring_1 (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) bot top (1::'a) (*)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z. x * (y * z) = x * (y * (1::'a)) * z\n 2. \\<And>x y z.\n       (x * (1::'a) \\<sqinter> y * (1::'a)) * z = x * z \\<sqinter> y * z", "apply (simp add: order.antisym mult_sub_associative_one mult_sup_associative_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (x * (1::'a) \\<sqinter> y * (1::'a)) * z = x * z \\<sqinter> y * z", "by (metis order.eq_iff mult_one_associative mult_right_dist_inf_one_sub mult_right_sub_dist_inf)"], ["", "end"], ["", "class multirelation_algebra_1 = lattice_ordered_pre_left_semiring +\n  assumes mult_left_top: \"top * x = top\"\nbegin"], ["", "text \\<open>AAMP Theorem 10 / Figure 3: closure properties\\<close>"], ["", "lemma top_sup_distributive:\n  \"sup_distributive top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_distributive top", "by (simp add: sup_distributive_def mult_left_top)"], ["", "lemma top_inf_distributive:\n  \"inf_distributive top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_distributive top", "by (simp add: inf_distributive_def mult_left_top)"], ["", "lemma top_sup_dist_contact:\n  \"sup_dist_contact top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_dist_contact top", "by (simp add: sup_dist_contact_def top_contact top_sup_distributive)"], ["", "lemma top_co_test:\n  \"co_test top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test top", "by (simp add: co_test_def mult_left_top)"], ["", "end"], ["", "text \\<open>M1-algebra\\<close>"], ["", "class multirelation_algebra_2 = multirelation_algebra_1 + lattice_ordered_pre_left_semiring_2\nbegin"], ["", "lemma mult_top_associative:\n  \"x * top * y = x * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top * y = x * top", "by (metis mult_left_top mult_associative_one)"], ["", "lemma vector_inf_one_comp:\n  \"(x * top \\<sqinter> 1) * y = x * top \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> (1::'a)) * y = x * top \\<sqinter> y", "by (metis vector_zero_inf_one_comp mult_top_associative)"], ["", "lemma vector_left_annihilator:\n  \"vector x \\<Longrightarrow> x * y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> x * y = x", "by (metis mult_top_associative)"], ["", "text \\<open>properties\\<close>"], ["", "lemma test_comp_inf:\n  \"test x \\<Longrightarrow> test y \\<Longrightarrow> x * y = x \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>test x; test y\\<rbrakk>\n    \\<Longrightarrow> x * y = x \\<sqinter> y", "by (metis inf.absorb1 inf.left_commute test_coreflexive test_def vector_inf_one_comp)"], ["", "text \\<open>AAMP Theorem 6 / Figure 2: relations between properties\\<close>"], ["", "lemma test_sup_distributive:\n  \"test x \\<Longrightarrow> sup_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test x \\<Longrightarrow> sup_distributive x", "by (metis sup_distributive_def inf_sup_distrib1 test_def vector_inf_one_comp)"], ["", "lemma test_inf_distributive:\n  \"test x \\<Longrightarrow> inf_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test x \\<Longrightarrow> inf_distributive x", "by (smt (verit, ccfv_SIG) inf.commute inf.sup_monoid.add_assoc inf_distributive_def test_def inf.idem vector_inf_one_comp)"], ["", "lemma test_inf_dist_kernel:\n  \"test x \\<Longrightarrow> inf_dist_kernel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test x \\<Longrightarrow> inf_dist_kernel x", "by (simp add: kernel_def inf_dist_kernel_def one_test test_comp_inf test_inf_distributive)"], ["", "lemma vector_idempotent:\n  \"vector x \\<Longrightarrow> idempotent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> idempotent x", "using vector_left_annihilator"], ["proof (prove)\nusing this:\n  vector ?x \\<Longrightarrow> ?x * ?y = ?x\n\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> idempotent x", "by blast"], ["", "lemma vector_sup_distributive:\n  \"vector x \\<Longrightarrow> sup_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> sup_distributive x", "by (simp add: sup_distributive_def vector_left_annihilator)"], ["", "lemma vector_inf_distributive:\n  \"vector x \\<Longrightarrow> inf_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> inf_distributive x", "by (simp add: inf_distributive_def vector_left_annihilator)"], ["", "lemma vector_co_vector:\n  \"vector x \\<longleftrightarrow> co_vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = co_vector x", "by (metis co_vector_def mult_zero_associative mult_top_associative)"], ["", "text \\<open>AAMP Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>test\\<close>"], ["", "lemma comp_test:\n  \"test x \\<Longrightarrow> test y \\<Longrightarrow> test (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>test x; test y\\<rbrakk> \\<Longrightarrow> test (x * y)", "by (simp add: inf_test test_comp_inf)"], ["", "end"], ["", "class dual =\n  fixes dual :: \"'a \\<Rightarrow> 'a\" (\"_\\<^sup>d\" [100] 100)"], ["", "class multirelation_algebra_3 = lattice_ordered_pre_left_semiring + dual +\n  assumes dual_involutive: \"x\\<^sup>d\\<^sup>d = x\"\n  assumes dual_dist_sup: \"(x \\<squnion> y)\\<^sup>d = x\\<^sup>d \\<sqinter> y\\<^sup>d\"\n  assumes dual_one: \"1\\<^sup>d = 1\"\nbegin"], ["", "lemma dual_dist_inf:\n  \"(x \\<sqinter> y)\\<^sup>d = x\\<^sup>d \\<squnion> y\\<^sup>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y)\\<^sup>d = x\\<^sup>d \\<squnion> y\\<^sup>d", "by (metis dual_dist_sup dual_involutive)"], ["", "lemma dual_antitone:\n  \"x \\<le> y \\<Longrightarrow> y\\<^sup>d \\<le> x\\<^sup>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> y\\<^sup>d \\<le> x\\<^sup>d", "using dual_dist_sup sup_right_divisibility"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y)\\<^sup>d = ?x\\<^sup>d \\<sqinter> ?y\\<^sup>d\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> y\\<^sup>d \\<le> x\\<^sup>d", "by fastforce"], ["", "lemma dual_zero:\n  \"bot\\<^sup>d = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot\\<^sup>d = top", "by (metis dual_antitone bot_least dual_involutive top_le)"], ["", "lemma dual_top:\n  \"top\\<^sup>d = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top\\<^sup>d = bot", "using dual_zero dual_involutive"], ["proof (prove)\nusing this:\n  bot\\<^sup>d = top\n  ?x\\<^sup>d\\<^sup>d = ?x\n\ngoal (1 subgoal):\n 1. top\\<^sup>d = bot", "by auto"], ["", "text \\<open>AAMP Theorem 10 / Figure 3: closure properties\\<close>"], ["", "lemma reflexive_coreflexive_dual:\n  \"reflexive x \\<longleftrightarrow> coreflexive (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive x = coreflexive (x\\<^sup>d)", "using dual_antitone dual_involutive dual_one"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?y\\<^sup>d \\<le> ?x\\<^sup>d\n  ?x\\<^sup>d\\<^sup>d = ?x\n  (1::'a)\\<^sup>d = (1::'a)\n\ngoal (1 subgoal):\n 1. reflexive x = coreflexive (x\\<^sup>d)", "by fastforce"], ["", "end"], ["", "class multirelation_algebra_4 = multirelation_algebra_3 +\n  assumes dual_sub_dist_comp: \"(x * y)\\<^sup>d \\<le> x\\<^sup>d * y\\<^sup>d\"\nbegin"], ["", "subclass multirelation_algebra_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.multirelation_algebra_1 (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot\n     top (1::'a) (*)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. surjective x", "by (metis order.antisym top.extremum dual_zero dual_sub_dist_comp dual_involutive mult_left_zero)"], ["", "lemma dual_sub_dist_comp_one:\n  \"(x * y)\\<^sup>d \\<le> (x * 1)\\<^sup>d * y\\<^sup>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>d \\<le> (x * (1::'a))\\<^sup>d * y\\<^sup>d", "by (metis dual_sub_dist_comp mult_one_associative)"], ["", "text \\<open>AAMP Theorem 10 / Figure 3: closure properties\\<close>"], ["", "lemma co_total_total_dual:\n  \"co_total x \\<Longrightarrow> total (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_total x \\<Longrightarrow> times_top_class.total (x\\<^sup>d)", "by (metis co_total_def dual_sub_dist_comp dual_zero top_le)"], ["", "lemma transitive_dense_dual:\n  \"transitive x \\<Longrightarrow> dense_rel (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> dense_rel (x\\<^sup>d)", "using dual_antitone dual_sub_dist_comp inf.order_lesseq_imp"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?y\\<^sup>d \\<le> ?x\\<^sup>d\n  (?x * ?y)\\<^sup>d \\<le> ?x\\<^sup>d * ?y\\<^sup>d\n  (\\<forall>z\\<le>?x. z \\<le> ?y) = (?x \\<le> ?y)\n\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> dense_rel (x\\<^sup>d)", "by blast"], ["", "end"], ["", "text \\<open>M2-algebra\\<close>"], ["", "class multirelation_algebra_5 = multirelation_algebra_3 +\n  assumes dual_dist_comp_one: \"(x * y)\\<^sup>d = (x * 1)\\<^sup>d * y\\<^sup>d\"\nbegin"], ["", "subclass multirelation_algebra_4"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.multirelation_algebra_4 dual (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n     bot top (1::'a) (*)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (x * y)\\<^sup>d \\<le> x\\<^sup>d * y\\<^sup>d", "by (metis dual_antitone mult_sub_right_one mult_left_isotone dual_dist_comp_one)"], ["", "lemma strong_up_closed:\n  \"x * 1 \\<le> x \\<Longrightarrow> x\\<^sup>d * y\\<^sup>d \\<le> (x * y)\\<^sup>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a) \\<le> x \\<Longrightarrow>\n    x\\<^sup>d * y\\<^sup>d \\<le> (x * y)\\<^sup>d", "by (simp add: dual_dist_comp_one antisym_conv mult_sub_right_one)"], ["", "lemma strong_up_closed_2:\n  \"up_closed x \\<Longrightarrow> (x * y)\\<^sup>d = x\\<^sup>d * y\\<^sup>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed x \\<Longrightarrow> (x * y)\\<^sup>d = x\\<^sup>d * y\\<^sup>d", "by (simp add: dual_dist_comp_one up_closed_def)"], ["", "subclass lattice_ordered_pre_left_semiring_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.lattice_ordered_pre_left_semiring_2 (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) bot top (1::'a) (*)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z. x * (y * z) \\<le> x * (y * (1::'a)) * z\n 2. \\<And>x z y.\n       x * z \\<sqinter> y * z \\<le> (x * (1::'a) \\<sqinter> y * (1::'a)) * z", "apply (smt comp_up_closed dual_antitone dual_dist_comp_one dual_involutive dual_one mult_left_one mult_one_associative mult_semi_associative up_closed_def strong_up_closed_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z y.\n       x * z \\<sqinter> y * z \\<le> (x * (1::'a) \\<sqinter> y * (1::'a)) * z", "by (smt dual_dist_comp_one dual_dist_inf dual_involutive eq_refl mult_one_associative mult_right_dist_sup)"], ["", "text \\<open>AAMP Theorem 8\\<close>"], ["", "subclass multirelation_algebra_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.multirelation_algebra_2 (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot\n     top (1::'a) (*)", ".."], ["", "text \\<open>AAMP Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>up-closed\\<close>"], ["", "lemma dual_up_closed:\n  \"up_closed x \\<longleftrightarrow> up_closed (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed x = up_closed (x\\<^sup>d)", "by (metis dual_involutive dual_one up_closed_def strong_up_closed_2)"], ["", "text \\<open>contact\\<close>"], ["", "lemma contact_kernel_dual:\n  \"contact x \\<longleftrightarrow> kernel (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contact x = kernel (x\\<^sup>d)", "by (metis contact_def contact_up_closed dual_dist_sup dual_involutive dual_one kernel_def kernel_up_closed up_closed_def strong_up_closed_2)"], ["", "text \\<open>add-distributive contact\\<close>"], ["", "lemma sup_dist_contact_inf_dist_kernel_dual:\n  \"sup_dist_contact x \\<longleftrightarrow> inf_dist_kernel (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_dist_contact x = inf_dist_kernel (x\\<^sup>d)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. sup_dist_contact x \\<Longrightarrow> inf_dist_kernel (x\\<^sup>d)\n 2. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "assume 1: \"sup_dist_contact x\""], ["proof (state)\nthis:\n  sup_dist_contact x\n\ngoal (2 subgoals):\n 1. sup_dist_contact x \\<Longrightarrow> inf_dist_kernel (x\\<^sup>d)\n 2. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "hence 2: \"up_closed x\""], ["proof (prove)\nusing this:\n  sup_dist_contact x\n\ngoal (1 subgoal):\n 1. up_closed x", "using sup_dist_contact_def contact_up_closed"], ["proof (prove)\nusing this:\n  sup_dist_contact x\n  sup_dist_contact ?x \\<equiv> sup_distributive ?x \\<and> contact ?x\n  contact ?x \\<Longrightarrow> up_closed ?x\n\ngoal (1 subgoal):\n 1. up_closed x", "by auto"], ["proof (state)\nthis:\n  up_closed x\n\ngoal (2 subgoals):\n 1. sup_dist_contact x \\<Longrightarrow> inf_dist_kernel (x\\<^sup>d)\n 2. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "have \"sup_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_distributive x", "using 1 sup_dist_contact_def"], ["proof (prove)\nusing this:\n  sup_dist_contact x\n  sup_dist_contact ?x \\<equiv> sup_distributive ?x \\<and> contact ?x\n\ngoal (1 subgoal):\n 1. sup_distributive x", "by auto"], ["proof (state)\nthis:\n  sup_distributive x\n\ngoal (2 subgoals):\n 1. sup_dist_contact x \\<Longrightarrow> inf_dist_kernel (x\\<^sup>d)\n 2. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "hence \"inf_distributive (x\\<^sup>d)\""], ["proof (prove)\nusing this:\n  sup_distributive x\n\ngoal (1 subgoal):\n 1. inf_distributive (x\\<^sup>d)", "using 2"], ["proof (prove)\nusing this:\n  sup_distributive x\n  up_closed x\n\ngoal (1 subgoal):\n 1. inf_distributive (x\\<^sup>d)", "by (smt sup_distributive_def dual_dist_comp_one dual_dist_inf dual_involutive inf_distributive_def up_closed_def)"], ["proof (state)\nthis:\n  inf_distributive (x\\<^sup>d)\n\ngoal (2 subgoals):\n 1. sup_dist_contact x \\<Longrightarrow> inf_dist_kernel (x\\<^sup>d)\n 2. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "thus \"inf_dist_kernel (x\\<^sup>d)\""], ["proof (prove)\nusing this:\n  inf_distributive (x\\<^sup>d)\n\ngoal (1 subgoal):\n 1. inf_dist_kernel (x\\<^sup>d)", "using 1 contact_kernel_dual sup_dist_contact_def inf_dist_kernel_def"], ["proof (prove)\nusing this:\n  inf_distributive (x\\<^sup>d)\n  sup_dist_contact x\n  contact ?x = kernel (?x\\<^sup>d)\n  sup_dist_contact ?x \\<equiv> sup_distributive ?x \\<and> contact ?x\n  inf_dist_kernel ?x \\<equiv> inf_distributive ?x \\<and> kernel ?x\n\ngoal (1 subgoal):\n 1. inf_dist_kernel (x\\<^sup>d)", "by blast"], ["proof (state)\nthis:\n  inf_dist_kernel (x\\<^sup>d)\n\ngoal (1 subgoal):\n 1. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "assume 3: \"inf_dist_kernel (x\\<^sup>d)\""], ["proof (state)\nthis:\n  inf_dist_kernel (x\\<^sup>d)\n\ngoal (1 subgoal):\n 1. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "hence 4: \"up_closed (x\\<^sup>d)\""], ["proof (prove)\nusing this:\n  inf_dist_kernel (x\\<^sup>d)\n\ngoal (1 subgoal):\n 1. up_closed (x\\<^sup>d)", "using kernel_up_closed inf_dist_kernel_def"], ["proof (prove)\nusing this:\n  inf_dist_kernel (x\\<^sup>d)\n  kernel ?x \\<Longrightarrow> up_closed ?x\n  inf_dist_kernel ?x \\<equiv> inf_distributive ?x \\<and> kernel ?x\n\ngoal (1 subgoal):\n 1. up_closed (x\\<^sup>d)", "by auto"], ["proof (state)\nthis:\n  up_closed (x\\<^sup>d)\n\ngoal (1 subgoal):\n 1. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "have \"inf_distributive (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_distributive (x\\<^sup>d)", "using 3 inf_dist_kernel_def"], ["proof (prove)\nusing this:\n  inf_dist_kernel (x\\<^sup>d)\n  inf_dist_kernel ?x \\<equiv> inf_distributive ?x \\<and> kernel ?x\n\ngoal (1 subgoal):\n 1. inf_distributive (x\\<^sup>d)", "by auto"], ["proof (state)\nthis:\n  inf_distributive (x\\<^sup>d)\n\ngoal (1 subgoal):\n 1. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "hence \"sup_distributive (x\\<^sup>d\\<^sup>d)\""], ["proof (prove)\nusing this:\n  inf_distributive (x\\<^sup>d)\n\ngoal (1 subgoal):\n 1. sup_distributive (x\\<^sup>d\\<^sup>d)", "using 4"], ["proof (prove)\nusing this:\n  inf_distributive (x\\<^sup>d)\n  up_closed (x\\<^sup>d)\n\ngoal (1 subgoal):\n 1. sup_distributive (x\\<^sup>d\\<^sup>d)", "by (smt inf_distributive_def sup_distributive_def dual_dist_sup dual_involutive strong_up_closed_2)"], ["proof (state)\nthis:\n  sup_distributive (x\\<^sup>d\\<^sup>d)\n\ngoal (1 subgoal):\n 1. inf_dist_kernel (x\\<^sup>d) \\<Longrightarrow> sup_dist_contact x", "thus \"sup_dist_contact x\""], ["proof (prove)\nusing this:\n  sup_distributive (x\\<^sup>d\\<^sup>d)\n\ngoal (1 subgoal):\n 1. sup_dist_contact x", "using 3 contact_kernel_dual sup_dist_contact_def dual_involutive inf_dist_kernel_def"], ["proof (prove)\nusing this:\n  sup_distributive (x\\<^sup>d\\<^sup>d)\n  inf_dist_kernel (x\\<^sup>d)\n  contact ?x = kernel (?x\\<^sup>d)\n  sup_dist_contact ?x \\<equiv> sup_distributive ?x \\<and> contact ?x\n  ?x\\<^sup>d\\<^sup>d = ?x\n  inf_dist_kernel ?x \\<equiv> inf_distributive ?x \\<and> kernel ?x\n\ngoal (1 subgoal):\n 1. sup_dist_contact x", "by auto"], ["proof (state)\nthis:\n  sup_dist_contact x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>test\\<close>"], ["", "lemma test_co_test_dual:\n  \"test x \\<longleftrightarrow> co_test (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test x = co_test (x\\<^sup>d)", "by (smt (z3) co_test_def co_test_up_closed dual_dist_comp_one dual_dist_inf dual_involutive dual_one dual_top test_def test_up_closed up_closed_def)"], ["", "text \\<open>vector\\<close>"], ["", "lemma vector_dual:\n  \"vector x \\<longleftrightarrow> vector (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = vector (x\\<^sup>d)", "by (metis dual_dist_comp_one dual_involutive mult_top_associative)"], ["", "end"], ["", "class multirelation_algebra_6 = multirelation_algebra_4 +\n  assumes dual_sub_dist_comp_one: \"(x * 1)\\<^sup>d * y\\<^sup>d \\<le> (x * y)\\<^sup>d\"\nbegin"], ["", "subclass multirelation_algebra_5"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.multirelation_algebra_5 dual (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n     bot top (1::'a) (*)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (x * y)\\<^sup>d = (x * (1::'a))\\<^sup>d * y\\<^sup>d", "by (metis dual_sub_dist_comp dual_sub_dist_comp_one order.eq_iff mult_one_associative)"], ["", "(*\nlemma \"dense_rel x \\<and> coreflexive x \\<longrightarrow> up_closed x\" nitpick [expect=genuine,card=5] oops\nlemma \"x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\" nitpick [expect=genuine,card=8] oops\n*)"], ["", "end"], ["", "text \\<open>M3-algebra\\<close>"], ["", "class up_closed_multirelation_algebra = multirelation_algebra_3 +\n  assumes dual_dist_comp: \"(x * y)\\<^sup>d = x\\<^sup>d * y\\<^sup>d\"\nbegin"], ["", "lemma mult_right_dist_inf:\n  \"(x \\<sqinter> y) * z = x * z \\<sqinter> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y) * z = x * z \\<sqinter> y * z", "by (metis dual_dist_sup dual_dist_comp dual_involutive mult_right_dist_sup)"], ["", "text \\<open>AAMP Theorem 9\\<close>"], ["", "subclass idempotent_left_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.idempotent_left_semiring (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a. (1::'a) * a = a\n 3. \\<And>a. a * (1::'a) = a", "apply (metis order.antisym dual_antitone dual_dist_comp dual_involutive mult_semi_associative)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. (1::'a) * a = a\n 2. \\<And>a. a * (1::'a) = a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. a * (1::'a) = a", "by (metis order.antisym dual_antitone dual_dist_comp dual_involutive dual_one mult_sub_right_one)"], ["", "subclass multirelation_algebra_6"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.multirelation_algebra_6 dual (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n     bot top (1::'a) (*)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (x * y)\\<^sup>d \\<le> x\\<^sup>d * y\\<^sup>d\n 2. \\<And>x y. (x * (1::'a))\\<^sup>d * y\\<^sup>d \\<le> (x * y)\\<^sup>d", "by (simp_all add: dual_dist_comp)"], ["", "lemma vector_inf_comp:\n  \"(x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z", "by (simp add: vector_left_annihilator mult_right_dist_inf mult.assoc)"], ["", "lemma vector_zero_inf_comp:\n  \"(x * bot \\<sqinter> y) * z = x * bot \\<sqinter> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * bot \\<sqinter> y) * z = x * bot \\<sqinter> y * z", "by (simp add: mult_right_dist_inf mult.assoc)"], ["", "text \\<open>AAMP Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>total\\<close>"], ["", "lemma inf_total:\n  \"total x \\<Longrightarrow> total y \\<Longrightarrow> total (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>times_top_class.total x; times_top_class.total y\\<rbrakk>\n    \\<Longrightarrow> times_top_class.total (x \\<sqinter> y)", "by (simp add: mult_right_dist_inf)"], ["", "lemma comp_total:\n  \"total x \\<Longrightarrow> total y \\<Longrightarrow> total (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>times_top_class.total x; times_top_class.total y\\<rbrakk>\n    \\<Longrightarrow> times_top_class.total (x * y)", "by (simp add: mult_assoc)"], ["", "lemma total_co_total_dual:\n  \"total x \\<longleftrightarrow> co_total (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_top_class.total x = co_total (x\\<^sup>d)", "by (metis co_total_def dual_dist_comp dual_involutive dual_top)"], ["", "text \\<open>dense\\<close>"], ["", "lemma transitive_iff_dense_dual:\n  \"transitive x \\<longleftrightarrow> dense_rel (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x = dense_rel (x\\<^sup>d)", "by (metis dual_antitone dual_dist_comp dual_involutive)"], ["", "text \\<open>idempotent\\<close>"], ["", "lemma idempotent_dual:\n  \"idempotent x \\<longleftrightarrow> idempotent (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent x = idempotent (x\\<^sup>d)", "using dual_involutive idempotent_transitive_dense transitive_iff_dense_dual"], ["proof (prove)\nusing this:\n  ?x\\<^sup>d\\<^sup>d = ?x\n  idempotent ?x = (transitive ?x \\<and> dense_rel ?x)\n  transitive ?x = dense_rel (?x\\<^sup>d)\n\ngoal (1 subgoal):\n 1. idempotent x = idempotent (x\\<^sup>d)", "by auto"], ["", "text \\<open>add-distributive\\<close>"], ["", "lemma comp_sup_distributive:\n  \"sup_distributive x \\<Longrightarrow> sup_distributive y \\<Longrightarrow> sup_distributive (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sup_distributive x; sup_distributive y\\<rbrakk>\n    \\<Longrightarrow> sup_distributive (x * y)", "by (simp add: sup_distributive_def mult.assoc)"], ["", "lemma sup_inf_distributive_dual:\n  \"sup_distributive x \\<longleftrightarrow> inf_distributive (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_distributive x = inf_distributive (x\\<^sup>d)", "by (smt (verit, ccfv_threshold) sup_distributive_def dual_dist_sup dual_dist_comp dual_dist_inf dual_involutive inf_distributive_def)"], ["", "text \\<open>inf-distributive\\<close>"], ["", "lemma inf_inf_distributive:\n  \"inf_distributive x \\<Longrightarrow> inf_distributive y \\<Longrightarrow> inf_distributive (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inf_distributive x; inf_distributive y\\<rbrakk>\n    \\<Longrightarrow> inf_distributive (x \\<sqinter> y)", "by (metis sup_inf_distributive_dual sup_sup_distributive dual_dist_inf dual_involutive)"], ["", "lemma comp_inf_distributive:\n  \"inf_distributive x \\<Longrightarrow> inf_distributive y \\<Longrightarrow> inf_distributive (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inf_distributive x; inf_distributive y\\<rbrakk>\n    \\<Longrightarrow> inf_distributive (x * y)", "by (simp add: inf_distributive_def mult.assoc)"], ["", "(*\nlemma \"co_total x \\<and> transitive x \\<and> up_closed x \\<longrightarrow> coreflexive x\" nitpick [expect=genuine,card=5] oops\nlemma \"total x \\<and> dense_rel x \\<and> up_closed x \\<longrightarrow> reflexive x\" nitpick [expect=genuine,card=5] oops\nlemma \"x * top \\<sqinter> x\\<^sup>d * bot = bot\" nitpick [expect=genuine,card=6] oops\n*)"], ["", "end"], ["", "class multirelation_algebra_7 = multirelation_algebra_4 +\n  assumes vector_inf_comp: \"(x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z\"\nbegin"], ["", "lemma vector_zero_inf_comp:\n  \"(x * bot \\<sqinter> y) * z = x * bot \\<sqinter> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * bot \\<sqinter> y) * z = x * bot \\<sqinter> y * z", "by (metis vector_inf_comp vector_mult_closed zero_vector)"], ["", "lemma test_sup_distributive:\n  \"test x \\<Longrightarrow> sup_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test x \\<Longrightarrow> sup_distributive x", "by (metis sup_distributive_def inf_sup_distrib1 mult_left_one test_def vector_inf_comp)"], ["", "lemma test_inf_distributive:\n  \"test x \\<Longrightarrow> inf_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test x \\<Longrightarrow> inf_distributive x", "by (smt (z3) inf.right_idem inf.sup_monoid.add_assoc inf.sup_monoid.add_commute inf_distributive_def mult_left_one test_def vector_inf_comp)"], ["", "lemma test_inf_dist_kernel:\n  \"test x \\<Longrightarrow> inf_dist_kernel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test x \\<Longrightarrow> inf_dist_kernel x", "by (metis inf.idem inf.sup_monoid.add_assoc kernel_def inf_dist_kernel_def mult_left_one test_def test_inf_distributive vector_inf_comp)"], ["", "lemma co_test_inf_distributive:\n  assumes \"co_test x\"\n    shows \"inf_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_distributive x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inf_distributive x", "have \"x = x * bot \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x * bot \\<squnion> (1::'a)", "using assms co_test_def"], ["proof (prove)\nusing this:\n  co_test x\n  co_test ?x \\<equiv> ?x * bot \\<squnion> (1::'a) = ?x\n\ngoal (1 subgoal):\n 1. x = x * bot \\<squnion> (1::'a)", "by auto"], ["proof (state)\nthis:\n  x = x * bot \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. inf_distributive x", "hence \"\\<forall>y z . x * y \\<sqinter> x * z = x * (y \\<sqinter> z)\""], ["proof (prove)\nusing this:\n  x = x * bot \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>y z. x * y \\<sqinter> x * z = x * (y \\<sqinter> z)", "by (metis distrib_imp1 inf_sup_absorb inf_sup_distrib1 mult_left_one mult_left_top mult_right_dist_sup sup_top_right vector_zero_inf_comp)"], ["proof (state)\nthis:\n  \\<forall>y z. x * y \\<sqinter> x * z = x * (y \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. inf_distributive x", "thus \"inf_distributive x\""], ["proof (prove)\nusing this:\n  \\<forall>y z. x * y \\<sqinter> x * z = x * (y \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. inf_distributive x", "by (simp add: inf_distributive_def)"], ["proof (state)\nthis:\n  inf_distributive x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma co_test_sup_distributive:\n  assumes \"co_test x\"\n    shows \"sup_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_distributive x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sup_distributive x", "have \"x = x * bot \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x * bot \\<squnion> (1::'a)", "using assms co_test_def"], ["proof (prove)\nusing this:\n  co_test x\n  co_test ?x \\<equiv> ?x * bot \\<squnion> (1::'a) = ?x\n\ngoal (1 subgoal):\n 1. x = x * bot \\<squnion> (1::'a)", "by auto"], ["proof (state)\nthis:\n  x = x * bot \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. sup_distributive x", "hence \"\\<forall>y z . x * (y \\<squnion> z) = x * y \\<squnion> x * z\""], ["proof (prove)\nusing this:\n  x = x * bot \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z", "by (metis sup_sup_distributive sup_distributive_def inf_sup_absorb mult_left_top one_sup_distributive sup.idem sup_top_right vector_zero_inf_comp)"], ["proof (state)\nthis:\n  \\<forall>y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n\ngoal (1 subgoal):\n 1. sup_distributive x", "thus \"sup_distributive x\""], ["proof (prove)\nusing this:\n  \\<forall>y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n\ngoal (1 subgoal):\n 1. sup_distributive x", "by (simp add: sup_distributive_def)"], ["proof (state)\nthis:\n  sup_distributive x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma co_test_sup_dist_contact:\n  \"co_test x \\<Longrightarrow> sup_dist_contact x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_test x \\<Longrightarrow> sup_dist_contact x", "by (simp add: sup_dist_contact_def co_test_sup_distributive co_test_contact)"], ["", "end"], ["", "end"]]}