{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Binary_Iterings_Strict.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma while_associative:\n  \"(x \\<star> y) * z = x \\<star> (y * z)\"", "lemma while_one_mult:\n  \"(x \\<star> 1) * x = x \\<star> x\"", "lemma while_back_loop_is_fixpoint:\n  \"is_fixpoint (\\<lambda>x . x * y \\<squnion> z) (z * (y \\<star> 1))\"", "lemma while_sumstar_var:\n  \"(x \\<squnion> y) \\<star> z = ((x \\<star> 1) * y) \\<star> ((x \\<star> 1) * z)\"", "lemma while_mult_1_assoc:\n  \"(x \\<star> 1) * y = x \\<star> y\"", "lemma while_top_2:\n  \"top \\<star> z = top * z\"", "lemma while_mult_top_2:\n  \"(x * top) \\<star> z = z \\<squnion> x * top * z\""], "translations": [["", "lemma while_associative:\n  \"(x \\<star> y) * z = x \\<star> (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<star> y) * z = x \\<star> y * z", "by (simp add: while_def mult_assoc)"], ["", "text \\<open>Theorem 13.3\\<close>"], ["", "lemma while_one_mult:\n  \"(x \\<star> 1) * x = x \\<star> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<star> (1::'a)) * x = x \\<star> x", "by (simp add: while_def)"], ["", "lemma while_back_loop_is_fixpoint:\n  \"is_fixpoint (\\<lambda>x . x * y \\<squnion> z) (z * (y \\<star> 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_fixpoint (\\<lambda>x. x * y \\<squnion> z) (z * (y \\<star> (1::'a)))", "by (simp add: circ_back_loop_is_fixpoint while_def)"], ["", "text \\<open>Theorem 13.4\\<close>"], ["", "lemma while_sumstar_var:\n  \"(x \\<squnion> y) \\<star> z = ((x \\<star> 1) * y) \\<star> ((x \\<star> 1) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<star> z =\n    (x \\<star> (1::'a)) * y \\<star> (x \\<star> (1::'a)) * z", "by (simp add: while_sumstar_3 while_associative)"], ["", "text \\<open>Theorem 13.2\\<close>"], ["", "lemma while_mult_1_assoc:\n  \"(x \\<star> 1) * y = x \\<star> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<star> (1::'a)) * y = x \\<star> y", "by (simp add: while_def)"], ["", "(*\nlemma \"y \\<star> (x \\<star> 1) \\<le> x \\<star> (y \\<star> 1) \\<Longrightarrow> (x \\<squnion> y) \\<star> 1 = x \\<star> (y \\<star> 1)\" oops\nlemma \"y * x \\<le> (1 \\<squnion> x) * (y \\<star> 1) \\<Longrightarrow> (x \\<squnion> y) \\<star> 1 = x \\<star> (y \\<star> 1)\" oops\nlemma while_square_1: \"x \\<star> 1 = (x * x) \\<star> (x \\<squnion> 1)\" oops\nlemma while_absorb_below_one: \"y * x \\<le> x \\<Longrightarrow> y \\<star> x \\<le> 1 \\<star> x\" oops\n*)"], ["", "end"], ["", "class bounded_strict_itering = bounded_itering + strict_itering\nbegin"], ["", "subclass bounded_extended_binary_itering"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_extended_binary_itering (\\<star>) (1::'a) (*) (\\<squnion>)\n     (\\<le>) (<) bot top", ".."], ["", "text \\<open>Theorem 13.6\\<close>"], ["", "lemma while_top_2:\n  \"top \\<star> z = top * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top \\<star> z = top * z", "by (simp add: circ_top while_def)"], ["", "text \\<open>Theorem 13.5\\<close>"], ["", "lemma while_mult_top_2:\n  \"(x * top) \\<star> z = z \\<squnion> x * top * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<star> z = z \\<squnion> x * top * z", "by (metis circ_left_top mult_assoc while_def while_left_unfold)"], ["", "text \\<open>Theorem 13 counterexamples\\<close>"], ["", "(*\nlemma while_one_top: \"1 \\<star> x = top\" nitpick [expect=genuine,card=2] oops\nlemma while_top: \"top \\<star> x = top\" nitpick [expect=genuine,card=2] oops\nlemma while_sub_mult_one: \"x * (1 \\<star> y) \\<le> 1 \\<star> x\" oops\nlemma while_unfold_below_1: \"x = y * x \\<Longrightarrow> x \\<le> y \\<star> 1\" oops\nlemma while_unfold_below: \"x = z \\<squnion> y * x \\<Longrightarrow> x \\<le> y \\<star> z\" nitpick [expect=genuine,card=2] oops\nlemma while_unfold_below: \"x \\<le> z \\<squnion> y * x \\<Longrightarrow> x \\<le> y \\<star> z\" nitpick [expect=genuine,card=2] oops\nlemma while_mult_top: \"(x * top) \\<star> z = z \\<squnion> x * top\" nitpick [expect=genuine,card=2] oops\nlemma tarski_mult_top_idempotent: \"x * top = x * top * x * top\" oops\n\nlemma while_loop_is_greatest_postfixpoint: \"is_greatest_postfixpoint (\\<lambda>x . y * x \\<squnion> z) (y \\<star> z)\" nitpick [expect=genuine,card=2] oops\nlemma while_loop_is_greatest_fixpoint: \"is_greatest_fixpoint (\\<lambda>x . y * x \\<squnion> z) (y \\<star> z)\" nitpick [expect=genuine,card=2] oops\nlemma while_sub_while_zero: \"x \\<star> z \\<le> (x \\<star> y) \\<star> z\" oops\nlemma while_while_sub_associative: \"x \\<star> (y \\<star> z) \\<le> (x \\<star> y) \\<star> z\" oops\nlemma tarski: \"x \\<le> x * top * x * top\" oops\nlemma tarski_top_omega_below: \"x * top \\<le> (x * top) \\<star> bot\" nitpick [expect=genuine,card=2] oops\nlemma tarski_top_omega: \"x * top = (x * top) \\<star> bot\" nitpick [expect=genuine,card=2] oops\nlemma tarski_below_top_omega: \"x \\<le> (x * top) \\<star> bot\" nitpick [expect=genuine,card=2] oops\nlemma tarski: \"x = bot \\<or> top * x * top = top\" oops\nlemma \"1 = (x * bot) \\<star> 1\" oops\nlemma \"1 \\<squnion> x * bot = x \\<star> 1\" oops\nlemma \"x = x * (x \\<star> 1)\" oops\nlemma \"x * (x \\<star> 1) = x \\<star> 1\" oops\nlemma \"x \\<star> 1 = x \\<star> (1 \\<star> 1)\" oops\nlemma \"(x \\<squnion> y) \\<star> 1 = (x \\<star> (y \\<star> 1)) \\<star> 1\" oops\nlemma \"z \\<squnion> y * x = x \\<Longrightarrow> y \\<star> z \\<le> x\" oops\nlemma \"y * x = x \\<Longrightarrow> y \\<star> x \\<le> x\" oops\nlemma \"z \\<squnion> x * y = x \\<Longrightarrow> z * (y \\<star> 1) \\<le> x\" oops\nlemma \"x * y = x \\<Longrightarrow> x * (y \\<star> 1) \\<le> x\" oops\nlemma \"x * z = z * y \\<Longrightarrow> x \\<star> z \\<le> z * (y \\<star> 1)\" oops\n*)"], ["", "end"], ["", "class binary_itering_unary = extended_binary_itering + circ +\n  assumes circ_def: \"x\\<^sup>\\<circ> = x \\<star> 1\"\nbegin"], ["", "text \\<open>Theorem 50.7\\<close>"], ["", "subclass left_conway_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.left_conway_semiring circ (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. Rf x (x\\<^sup>\\<circ>) = x\\<^sup>\\<circ>\n 2. \\<And>x y. (x * y)\\<^sup>\\<circ> * x \\<le> x * (y * x)\\<^sup>\\<circ>\n 3. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<circ> =\n       x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "using circ_def while_left_unfold"], ["proof (prove)\nusing this:\n  ?x\\<^sup>\\<circ> = ?x \\<star> (1::'a)\n  ?x \\<star> ?y = ?y \\<squnion> ?x * (?x \\<star> ?y)\n\ngoal (3 subgoals):\n 1. \\<And>x. Rf x (x\\<^sup>\\<circ>) = x\\<^sup>\\<circ>\n 2. \\<And>x y. (x * y)\\<^sup>\\<circ> * x \\<le> x * (y * x)\\<^sup>\\<circ>\n 3. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<circ> =\n       x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (x * y)\\<^sup>\\<circ> * x \\<le> x * (y * x)\\<^sup>\\<circ>\n 2. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<circ> =\n       x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "apply (metis circ_def mult_1_right while_one_mult_below while_slide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<circ> =\n       x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "using circ_def while_one_while while_sumstar_2"], ["proof (prove)\nusing this:\n  ?x\\<^sup>\\<circ> = ?x \\<star> (1::'a)\n  (?x \\<star> (1::'a)) * (?y \\<star> (1::'a)) =\n  ?x \\<star> ?y \\<star> (1::'a)\n  ?x \\<squnion> ?y \\<star> ?z =\n  ?x \\<star> ?y * (?x \\<star> (1::'a)) \\<star> ?z\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<circ> =\n       x\\<^sup>\\<circ> * (y * x\\<^sup>\\<circ>)\\<^sup>\\<circ>", "by auto"], ["", "end"], ["", "class strict_binary_itering = binary_itering + circ +\n  assumes while_associative: \"(x \\<star> y) * z = x \\<star> (y * z)\"\n  assumes circ_def: \"x\\<^sup>\\<circ> = x \\<star> 1\"\nbegin"], ["", "text \\<open>Theorem 2.8\\<close>"], ["", "subclass itering"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.itering circ (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<circ> =\n       (x\\<^sup>\\<circ> * y)\\<^sup>\\<circ> * x\\<^sup>\\<circ>\n 2. \\<And>x y. (x * y)\\<^sup>\\<circ> = Rf (x * (y * x)\\<^sup>\\<circ>) y\n 3. \\<And>z x y w.\n       z * x \\<le> y * y\\<^sup>\\<circ> * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<circ>\n       \\<le> y\\<^sup>\\<circ> * (z \\<squnion> w * x\\<^sup>\\<circ>)\n 4. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<circ> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<circ> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>", "apply (simp add: circ_def while_associative while_sumstar)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. (x * y)\\<^sup>\\<circ> = Rf (x * (y * x)\\<^sup>\\<circ>) y\n 2. \\<And>z x y w.\n       z * x \\<le> y * y\\<^sup>\\<circ> * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<circ>\n       \\<le> y\\<^sup>\\<circ> * (z \\<squnion> w * x\\<^sup>\\<circ>)\n 3. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<circ> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<circ> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>", "apply (metis circ_def mult_1_right while_associative while_productstar while_slide)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z x y w.\n       z * x \\<le> y * y\\<^sup>\\<circ> * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<circ>\n       \\<le> y\\<^sup>\\<circ> * (z \\<squnion> w * x\\<^sup>\\<circ>)\n 2. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<circ> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<circ> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>", "apply (metis circ_def mult_1_right while_associative mult_1_left while_slide while_simulate_right_plus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<circ> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<circ> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<circ> * w) * y\\<^sup>\\<circ>", "by (metis circ_def mult_1_right while_associative mult_1_left while_simulate_left_plus mult_right_dist_sup)"], ["", "text \\<open>Theorem 8.5\\<close>"], ["", "subclass extended_binary_itering"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.extended_binary_itering (\\<star>) (1::'a) (*) (\\<squnion>) (\\<le>)\n     (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w x y z.\n       w * (x \\<star> y * z)\n       \\<le> w * (x \\<star> y) \\<star> w * (x \\<star> y) * z", "by (simp add: while_associative while_increasing mult_assoc)"], ["", "end"], ["", "end"]]}