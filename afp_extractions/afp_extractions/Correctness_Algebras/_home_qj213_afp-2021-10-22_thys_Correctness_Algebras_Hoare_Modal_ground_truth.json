{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Hoare_Modal.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma pre_Z:\n  \"-p \\<le> x\\<guillemotleft>-q \\<longleftrightarrow> -p * x * --q \\<le> Z\"", "lemma pre_left_dist_add:\n  \"x\\<squnion>y\\<guillemotleft>-q = (x\\<guillemotleft>-q) * (y\\<guillemotleft>-q)\"", "lemma pre_left_antitone:\n  \"x \\<le> y \\<Longrightarrow> y\\<guillemotleft>-q \\<le> x\\<guillemotleft>-q\"", "lemma pre_promote_neg:\n  \"(x\\<guillemotleft>-q) * x * --q \\<le> Z\"", "lemma pre_pc_Z:\n  \"x\\<guillemotleft>1 = 1 \\<longleftrightarrow> x * bot \\<le> Z\"", "lemma pre_sub_promote:\n  \"(x\\<guillemotleft>-q) * x \\<le> (x\\<guillemotleft>-q) * x * -q \\<squnion> Z\"", "lemma pre_promote:\n  \"(x\\<guillemotleft>-q) * x \\<squnion> Z = (x\\<guillemotleft>-q) * x * -q \\<squnion> Z\"", "lemma pre_mult_sub_promote:\n  \"(x*y\\<guillemotleft>-q) * x \\<le> (x*y\\<guillemotleft>-q) * x * (y\\<guillemotleft>-q) \\<squnion> Z\"", "lemma pre_mult_promote_sub:\n  \"(x*y\\<guillemotleft>-q) * x * (y\\<guillemotleft>-q) \\<le> (x*y\\<guillemotleft>-q) * x\"", "lemma pre_mult_promote:\n  \"(x*y\\<guillemotleft>-q) * x * (y\\<guillemotleft>-q) \\<squnion> Z = (x*y\\<guillemotleft>-q) * x \\<squnion> Z\"", "lemma pre_left_dist_add:\n  \"x\\<squnion>y\\<guillemotleft>-q = (x\\<guillemotleft>-q) \\<squnion> (y\\<guillemotleft>-q)\"", "lemma pre_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x\\<guillemotleft>-q \\<le> y\\<guillemotleft>-q\"", "lemma Z_circ_left_zero:\n  \"Z * x\\<^sup>\\<circ> = Z\"", "lemma pre_while_1:\n  \"-p*(-p\\<star>x)\\<guillemotleft>1 = -p\\<star>x\\<guillemotleft>1\"", "lemma aL_one_circ:\n  \"aL = a(1\\<^sup>\\<circ>*bot)\"", "lemma Z_circ_left_zero:\n  \"Z * x\\<^sup>\\<circ> = Z\"", "lemma aL_one_circ:\n  \"aL = d(1\\<^sup>\\<circ>*bot)\"", "lemma aL_circ_ext:\n  \"|x\\<^sup>\\<star>]y \\<le> |aL * x\\<^sup>\\<circ>]y\"", "lemma box_star_induct:\n  assumes \"-p \\<le> |x](-p)\"\n    shows \"-p \\<le> |x\\<^sup>\\<star>](-p)\"", "lemma box_circ_induct:\n  \"-p \\<le> |x](-p) \\<Longrightarrow> -p*aL \\<le> |x\\<^sup>\\<circ>](-p)\"", "lemma a_while_soundness:\n  assumes \"-p*-q \\<le> |x](-q)\"\n    shows \"aL*-q \\<le> |(-p*x)\\<^sup>\\<circ>*--p](-q)\"", "lemma aL_circ_equal:\n  \"aL * x\\<^sup>\\<circ> = aL * x\\<^sup>\\<star>\"", "lemma aL_zero:\n  \"aL = bot\"", "lemma diamond_star_induct_var:\n  assumes \"|x>(d p) \\<le> d p\"\n    shows \"|x\\<^sup>\\<star>>(d p) \\<le> d p\"", "lemma diamond_star_induct:\n  \"d q \\<squnion> |x>(d p) \\<le> d p \\<Longrightarrow> |x\\<^sup>\\<star>>(d q) \\<le> d p\"", "lemma while_completeness_1:\n  assumes \"-p*(x\\<guillemotleft>-q) \\<le> -q\"\n    shows \"-p\\<star>x\\<guillemotleft>-q \\<le> -q\\<squnion>aL\"", "lemma rule_skip_valid:\n  \"-p\\<lbrace>1\\<rbrace>-p\"", "lemma circ_star_equal:\n  \"x\\<^sup>\\<circ> = x\\<^sup>\\<star>\""], "translations": [["", "lemma pre_Z:\n  \"-p \\<le> x\\<guillemotleft>-q \\<longleftrightarrow> -p * x * --q \\<le> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a p \\<le> x \\<guillemotleft> a q) = (a p * x * a (a q) \\<le> Z)", "by (simp add: box_demodalisation_2 pre_def)"], ["", "lemma pre_left_dist_add:\n  \"x\\<squnion>y\\<guillemotleft>-q = (x\\<guillemotleft>-q) * (y\\<guillemotleft>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<guillemotleft> a q =\n    (x \\<guillemotleft> a q) * (y \\<guillemotleft> a q)", "by (simp add: box_left_dist_sup pre_def)"], ["", "lemma pre_left_antitone:\n  \"x \\<le> y \\<Longrightarrow> y\\<guillemotleft>-q \\<le> x\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    y \\<guillemotleft> a q \\<le> x \\<guillemotleft> a q", "by (simp add: box_antitone_isotone pre_def)"], ["", "lemma pre_promote_neg:\n  \"(x\\<guillemotleft>-q) * x * --q \\<le> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> a q) * x * a (a q) \\<le> Z", "by (simp add: box_below_Z pre_def)"], ["", "lemma pre_pc_Z:\n  \"x\\<guillemotleft>1 = 1 \\<longleftrightarrow> x * bot \\<le> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> (1::'a) = (1::'a)) = (x * bot \\<le> Z)", "by (simp add: a_strict box_x_1 pre_def)"], ["", "(*\nlemma pre_sub_promote: \"(x\\<guillemotleft>-q) * x \\<le> (x\\<guillemotleft>-q) * x * -q \\<squnion> Z\" nitpick [expect=genuine,card=6] oops\nlemma pre_promote: \"(x\\<guillemotleft>-q) * x \\<squnion> Z = (x\\<guillemotleft>-q) * x * -q \\<squnion> Z\" nitpick [expect=genuine,card=6] oops\nlemma pre_mult_sub_promote: \"(x*y\\<guillemotleft>-q) * x \\<le> (x*y\\<guillemotleft>-q) * x * (y\\<guillemotleft>-q) \\<squnion> Z\" nitpick [expect=genuine,card=6] oops\nlemma pre_mult_promote: \"(x*y\\<guillemotleft>-q) * x * (y\\<guillemotleft>-q) \\<squnion> Z = (x*y\\<guillemotleft>-q) * x \\<squnion> Z\" nitpick [expect=genuine,card=6] oops\n*)"], ["", "end"], ["", "class left_zero_box_precondition = box_precondition + relative_left_zero_antidomain_semiring\nbegin"], ["", "lemma pre_sub_promote:\n  \"(x\\<guillemotleft>-q) * x \\<le> (x\\<guillemotleft>-q) * x * -q \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> a q) * x\n    \\<le> (x \\<guillemotleft> a q) * x * a q \\<squnion> Z", "using case_split_right_sup pre_promote_neg"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x * a ?p \\<le> ?y; ?x * a (a ?p) \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y \\<squnion> ?z\n  (?x \\<guillemotleft> a ?q) * ?x * a (a ?q) \\<le> Z\n\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> a q) * x\n    \\<le> (x \\<guillemotleft> a q) * x * a q \\<squnion> Z", "by blast"], ["", "lemma pre_promote:\n  \"(x\\<guillemotleft>-q) * x \\<squnion> Z = (x\\<guillemotleft>-q) * x * -q \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> a q) * x \\<squnion> Z =\n    (x \\<guillemotleft> a q) * x * a q \\<squnion> Z", "apply (rule sup_same_context)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x \\<guillemotleft> a q) * x\n    \\<le> (x \\<guillemotleft> a q) * x * a q \\<squnion> Z\n 2. (x \\<guillemotleft> a q) * x * a q\n    \\<le> (x \\<guillemotleft> a q) * x \\<squnion> Z", "apply (simp add: pre_sub_promote)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<guillemotleft> a q) * x * a q\n    \\<le> (x \\<guillemotleft> a q) * x \\<squnion> Z", "by (metis a_below_one le_supI1 mult_1_right mult_right_isotone)"], ["", "lemma pre_mult_sub_promote:\n  \"(x*y\\<guillemotleft>-q) * x \\<le> (x*y\\<guillemotleft>-q) * x * (y\\<guillemotleft>-q) \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<guillemotleft> a q) * x\n    \\<le> (x * y \\<guillemotleft> a q) * x *\n          (y \\<guillemotleft> a q) \\<squnion>\n          Z", "by (metis pre_closed pre_seq pre_sub_promote)"], ["", "lemma pre_mult_promote_sub:\n  \"(x*y\\<guillemotleft>-q) * x * (y\\<guillemotleft>-q) \\<le> (x*y\\<guillemotleft>-q) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<guillemotleft> a q) * x * (y \\<guillemotleft> a q)\n    \\<le> (x * y \\<guillemotleft> a q) * x", "by (metis mult_right_isotone mult_1_right pre_below_one)"], ["", "lemma pre_mult_promote:\n  \"(x*y\\<guillemotleft>-q) * x * (y\\<guillemotleft>-q) \\<squnion> Z = (x*y\\<guillemotleft>-q) * x \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<guillemotleft> a q) * x * (y \\<guillemotleft> a q) \\<squnion>\n    Z =\n    (x * y \\<guillemotleft> a q) * x \\<squnion> Z", "by (metis sup_ge1 sup_same_context order_trans pre_mult_sub_promote pre_mult_promote_sub)"], ["", "end"], ["", "class diamond_precondition = relative_box_semiring + pre +\n  assumes pre_def: \"x\\<guillemotleft>p = |x>p\"\nbegin"], ["", "text \\<open>Theorem 47\\<close>"], ["", "subclass precondition"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.precondition (\\<guillemotleft>) (1::'a) (*) a (\\<squnion>) bot\n     (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x q. x \\<guillemotleft> a q = a (a (x \\<guillemotleft> a q))\n 2. \\<And>x y q.\n       x * y \\<guillemotleft> a q =\n       x \\<guillemotleft> y \\<guillemotleft> a q\n 3. \\<And>x p q. x \\<guillemotleft> a p * a q \\<le> x \\<guillemotleft> a q\n 4. \\<And>q. a q \\<le> (1::'a) \\<guillemotleft> a q", "apply (simp add: d_def diamond_def pre_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y q.\n       x * y \\<guillemotleft> a q =\n       x \\<guillemotleft> y \\<guillemotleft> a q\n 2. \\<And>x p q. x \\<guillemotleft> a p * a q \\<le> x \\<guillemotleft> a q\n 3. \\<And>q. a q \\<le> (1::'a) \\<guillemotleft> a q", "apply (simp add: diamond_left_mult pre_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x p q. x \\<guillemotleft> a p * a q \\<le> x \\<guillemotleft> a q\n 2. \\<And>q. a q \\<le> (1::'a) \\<guillemotleft> a q", "apply (metis a_antitone a_dist_sup box_antitone_isotone box_deMorgan_1 order.refl pre_def sup_right_divisibility)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q. a q \\<le> (1::'a) \\<guillemotleft> a q", "by (simp add: diamond_1_a pre_def)"], ["", "subclass precondition_test_test"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.precondition_test_test (\\<guillemotleft>) (1::'a) (*) a\n     (\\<squnion>) bot (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q. a p * (a p \\<guillemotleft> a q) = a p * a q", "by (metis diamond_a_a_same diamond_a_export diamond_associative diamond_right_mult pre_def)"], ["", "subclass precondition_promote"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.precondition_promote (\\<guillemotleft>) (1::'a) (*) a (\\<squnion>)\n     bot (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q. a p \\<guillemotleft> a q = a p \\<guillemotleft> a p * a q", "using d_def diamond_def pre_def pre_test_test tests_dual.sub_sup_closed"], ["proof (prove)\nusing this:\n  d ?x = a (a ?x)\n  | ?x > ?y = d (?x * ?y)\n  ?x \\<guillemotleft> ?p = | ?x > ?p\n  a ?p * (a ?p \\<guillemotleft> a ?q) = a ?p * a ?q\n  a ?x * a ?y = a (a (a ?x * a ?y))\n\ngoal (1 subgoal):\n 1. \\<And>p q. a p \\<guillemotleft> a q = a p \\<guillemotleft> a p * a q", "by force"], ["", "subclass precondition_test_diamond"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.precondition_test_diamond (\\<guillemotleft>) (1::'a) (*) a\n     (\\<squnion>) bot (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q. a p \\<guillemotleft> a q = a p * a q", "by (simp add: diamond_a_a pre_def)"], ["", "lemma pre_left_dist_add:\n  \"x\\<squnion>y\\<guillemotleft>-q = (x\\<guillemotleft>-q) \\<squnion> (y\\<guillemotleft>-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<guillemotleft> a q =\n    (x \\<guillemotleft> a q) \\<squnion> (y \\<guillemotleft> a q)", "by (simp add: diamond_left_dist_sup pre_def)"], ["", "lemma pre_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x\\<guillemotleft>-q \\<le> y\\<guillemotleft>-q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    x \\<guillemotleft> a q \\<le> y \\<guillemotleft> a q", "by (metis diamond_left_isotone pre_def)"], ["", "end"], ["", "class box_while = box_precondition + bounded_left_conway_semiring + ite + while +\n  assumes ite_def:   \"x\\<lhd>p\\<rhd>y = p * x \\<squnion> -p * y\"\n  assumes while_def: \"p\\<star>x = (p * x)\\<^sup>\\<circ> * -p\"\nbegin"], ["", "subclass bounded_relative_antidomain_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_relative_antidomain_semiring a Z (1::'a) (*) (\\<squnion>)\n     (\\<le>) (<) bot d top", ".."], ["", "lemma Z_circ_left_zero:\n  \"Z * x\\<^sup>\\<circ> = Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z * x\\<^sup>\\<circ> = Z", "using Z_left_zero_above_one circ_plus_one sup.absorb_iff2"], ["proof (prove)\nusing this:\n  reflexive ?x \\<Longrightarrow> Z * ?x = Z\n  ?x\\<^sup>\\<circ> = (1::'a) \\<squnion> ?x\\<^sup>\\<circ>\n  (?a \\<le> ?b) = (?a \\<squnion> ?b = ?b)\n\ngoal (1 subgoal):\n 1. Z * x\\<^sup>\\<circ> = Z", "by auto"], ["", "subclass ifthenelse"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ifthenelse ite (\\<guillemotleft>) (1::'a) (*) a (\\<squnion>) bot\n     (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p y q.\n       x \\<lhd> a p \\<rhd> y \\<guillemotleft> a q =\n       a p * (x \\<guillemotleft> a q) \\<squnion>\n       a (a p) * (y \\<guillemotleft> a q)", "by (smt a_d_closed box_a_export box_left_dist_sup box_x_a tests_dual.case_duality d_def ite_def pre_def)"], ["", "text \\<open>Theorem 48.1\\<close>"], ["", "subclass whiledo"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.whiledo (\\<star>) ite (\\<guillemotleft>) (1::'a) (*) a\n     (\\<squnion>) bot (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p x q.\n       a p \\<star> x \\<guillemotleft> a q =\n       a p *\n       (x \\<guillemotleft> a p \\<star> x \\<guillemotleft> a q) \\<squnion>\n       a (a p) * a q\n 2. \\<And>p x q.\n       a p \\<star> x \\<guillemotleft> a q =\n       a p \\<star> x \\<guillemotleft> a (a p) * a q", "apply (smt circ_loop_fixpoint ite_def ite_pre mult_assoc mult_1_right pre_one pre_seq while_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x q.\n       a p \\<star> x \\<guillemotleft> a q =\n       a p \\<star> x \\<guillemotleft> a (a p) * a q", "using pre_mult_test_promote while_def"], ["proof (prove)\nusing this:\n  ?x * a ?p \\<guillemotleft> a ?q = ?x * a ?p \\<guillemotleft> a ?p * a ?q\n  ?p \\<star> ?x = (?p * ?x)\\<^sup>\\<circ> * a ?p\n\ngoal (1 subgoal):\n 1. \\<And>p x q.\n       a p \\<star> x \\<guillemotleft> a q =\n       a p \\<star> x \\<guillemotleft> a (a p) * a q", "by auto"], ["", "lemma pre_while_1:\n  \"-p*(-p\\<star>x)\\<guillemotleft>1 = -p\\<star>x\\<guillemotleft>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p * (a p \\<star> x) \\<guillemotleft> (1::'a) =\n    a p \\<star> x \\<guillemotleft> (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a p * (a p \\<star> x) \\<guillemotleft> (1::'a) =\n    a p \\<star> x \\<guillemotleft> (1::'a)", "have \"--p*(-p*(-p\\<star>x)\\<guillemotleft>1) = --p*(-p\\<star>x\\<guillemotleft>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a p) * (a p * (a p \\<star> x) \\<guillemotleft> (1::'a)) =\n    a (a p) * (a p \\<star> x \\<guillemotleft> (1::'a))", "by (metis mult_1_right pre_closed pre_seq pre_test_neg tests_dual.sba_dual.top_double_complement while_pre_else)"], ["proof (state)\nthis:\n  a (a p) * (a p * (a p \\<star> x) \\<guillemotleft> (1::'a)) =\n  a (a p) * (a p \\<star> x \\<guillemotleft> (1::'a))\n\ngoal (1 subgoal):\n 1. a p * (a p \\<star> x) \\<guillemotleft> (1::'a) =\n    a p \\<star> x \\<guillemotleft> (1::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a (a p) * (a p * (a p \\<star> x) \\<guillemotleft> (1::'a)) =\n  a (a p) * (a p \\<star> x \\<guillemotleft> (1::'a))\n\ngoal (1 subgoal):\n 1. a p * (a p \\<star> x) \\<guillemotleft> (1::'a) =\n    a p \\<star> x \\<guillemotleft> (1::'a)", "by (smt (z3) pre_closed pre_import tests_dual.sba_dual.top_double_complement tests_dual.sup_eq_cases)"], ["proof (state)\nthis:\n  a p * (a p \\<star> x) \\<guillemotleft> (1::'a) =\n  a p \\<star> x \\<guillemotleft> (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aL_one_circ:\n  \"aL = a(1\\<^sup>\\<circ>*bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aL = a ((1::'a)\\<^sup>\\<circ> * bot)", "by (metis aL_def box_left_mult box_x_a idempotent_bot_closed idempotent_one_closed pre_def tests_dual.sba_dual.one_def while_def tests_dual.one_def)"], ["", "end"], ["", "class diamond_while = diamond_precondition + bounded_left_conway_semiring + ite + while +\n  assumes ite_def:   \"x\\<lhd>p\\<rhd>y = p * x \\<squnion> -p * y\"\n  assumes while_def: \"p\\<star>x = (p * x)\\<^sup>\\<circ> * -p\"\nbegin"], ["", "subclass bounded_relative_antidomain_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_relative_antidomain_semiring a Z (1::'a) (*) (\\<squnion>)\n     (\\<le>) (<) bot d top", ".."], ["", "lemma Z_circ_left_zero:\n  \"Z * x\\<^sup>\\<circ> = Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z * x\\<^sup>\\<circ> = Z", "by (simp add: Z_left_zero_above_one circ_reflexive)"], ["", "subclass ifthenelse"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ifthenelse ite (\\<guillemotleft>) (1::'a) (*) a (\\<squnion>) bot\n     (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x p y q.\n       x \\<lhd> a p \\<rhd> y \\<guillemotleft> a q =\n       a p * (x \\<guillemotleft> a q) \\<squnion>\n       a (a p) * (y \\<guillemotleft> a q)", "by (simp add: ite_def pre_export pre_left_dist_add)"], ["", "text \\<open>Theorem 48.2\\<close>"], ["", "subclass whiledo"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.whiledo (\\<star>) ite (\\<guillemotleft>) (1::'a) (*) a\n     (\\<squnion>) bot (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p x q.\n       a p \\<star> x \\<guillemotleft> a q =\n       a p *\n       (x \\<guillemotleft> a p \\<star> x \\<guillemotleft> a q) \\<squnion>\n       a (a p) * a q\n 2. \\<And>p x q.\n       a p \\<star> x \\<guillemotleft> a q =\n       a p \\<star> x \\<guillemotleft> a (a p) * a q", "apply (smt circ_loop_fixpoint ite_def ite_pre mult_assoc mult_1_right pre_one pre_seq while_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x q.\n       a p \\<star> x \\<guillemotleft> a q =\n       a p \\<star> x \\<guillemotleft> a (a p) * a q", "by (simp add: pre_mult_test_promote while_def)"], ["", "lemma aL_one_circ:\n  \"aL = d(1\\<^sup>\\<circ>*bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aL = d ((1::'a)\\<^sup>\\<circ> * bot)", "by (metis aL_def tests_dual.complement_bot diamond_x_1 mult_left_one pre_def while_def)"], ["", "end"], ["", "class box_while_program = box_while + atoms\nbegin"], ["", "subclass while_program"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.while_program (1::'a) (*) a (\\<squnion>) bot (\\<le>) (<)\n     Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)", ".."], ["", "end"], ["", "class diamond_while_program = diamond_while + atoms\nbegin"], ["", "subclass while_program"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.while_program (1::'a) (*) a (\\<squnion>) bot (\\<le>) (<)\n     Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)", ".."], ["", "end"], ["", "class box_hoare_calculus = box_while_program + complete_antidomain_semiring\nbegin"], ["", "subclass hoare_calculus"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.hoare_calculus Sup (1::'a) (*) a (\\<squnion>) bot (\\<le>) (<)\n     Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)", ".."], ["", "end"], ["", "class diamond_hoare_calculus = diamond_while_program + complete_antidomain_semiring\nbegin"], ["", "subclass hoare_calculus"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.hoare_calculus Sup (1::'a) (*) a (\\<squnion>) bot (\\<le>) (<)\n     Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)", ".."], ["", "end"], ["", "class box_hoare_sound = box_hoare_calculus + relative_domain_semiring_split + left_kleene_conway_semiring +\n  assumes aL_circ: \"aL * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<star>\"\nbegin"], ["", "lemma aL_circ_ext:\n  \"|x\\<^sup>\\<star>]y \\<le> |aL * x\\<^sup>\\<circ>]y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. | x\\<^sup>\\<star> ] y \\<le> | aL * x\\<^sup>\\<circ> ] y", "by (simp add: aL_circ box_left_antitone)"], ["", "lemma box_star_induct:\n  assumes \"-p \\<le> |x](-p)\"\n    shows \"-p \\<le> |x\\<^sup>\\<star>](-p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p \\<le> | x\\<^sup>\\<star> ] a p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a p \\<le> | x\\<^sup>\\<star> ] a p", "have 1: \"x*--p*top \\<le> Z \\<squnion> --p*top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * a (a p) * top \\<le> Z \\<squnion> a (a p) * top", "by (metis assms Z_top sup_commute box_demodalisation_2 mult_assoc mult_left_isotone shunting_Z)"], ["proof (state)\nthis:\n  x * a (a p) * top \\<le> Z \\<squnion> a (a p) * top\n\ngoal (1 subgoal):\n 1. a p \\<le> | x\\<^sup>\\<star> ] a p", "have \"x*(Z \\<squnion> --p*top) \\<le> x*--p*top \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (Z \\<squnion> a (a p) * top) \\<le> x * a (a p) * top \\<squnion> Z", "using split_Z sup_monoid.add_commute mult_assoc"], ["proof (prove)\nusing this:\n  ?x * (?y \\<squnion> Z) \\<le> ?x * ?y \\<squnion> Z\n  ?a \\<squnion> ?b = ?b \\<squnion> ?a\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. x * (Z \\<squnion> a (a p) * top) \\<le> x * a (a p) * top \\<squnion> Z", "by force"], ["proof (state)\nthis:\n  x * (Z \\<squnion> a (a p) * top) \\<le> x * a (a p) * top \\<squnion> Z\n\ngoal (1 subgoal):\n 1. a p \\<le> | x\\<^sup>\\<star> ] a p", "also"], ["proof (state)\nthis:\n  x * (Z \\<squnion> a (a p) * top) \\<le> x * a (a p) * top \\<squnion> Z\n\ngoal (1 subgoal):\n 1. a p \\<le> | x\\<^sup>\\<star> ] a p", "have \"... \\<le> Z \\<squnion> --p*top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * a (a p) * top \\<squnion> Z \\<le> Z \\<squnion> a (a p) * top", "using 1"], ["proof (prove)\nusing this:\n  x * a (a p) * top \\<le> Z \\<squnion> a (a p) * top\n\ngoal (1 subgoal):\n 1. x * a (a p) * top \\<squnion> Z \\<le> Z \\<squnion> a (a p) * top", "by simp"], ["proof (state)\nthis:\n  x * a (a p) * top \\<squnion> Z \\<le> Z \\<squnion> a (a p) * top\n\ngoal (1 subgoal):\n 1. a p \\<le> | x\\<^sup>\\<star> ] a p", "finally"], ["proof (chain)\npicking this:\n  x * (Z \\<squnion> a (a p) * top) \\<le> Z \\<squnion> a (a p) * top", "have \"x*(Z \\<squnion> --p*top) \\<squnion> --p \\<le> Z \\<squnion> --p*top\""], ["proof (prove)\nusing this:\n  x * (Z \\<squnion> a (a p) * top) \\<le> Z \\<squnion> a (a p) * top\n\ngoal (1 subgoal):\n 1. x * (Z \\<squnion> a (a p) * top) \\<squnion> a (a p)\n    \\<le> Z \\<squnion> a (a p) * top", "using le_supI2 sup.bounded_iff top_right_mult_increasing"], ["proof (prove)\nusing this:\n  x * (Z \\<squnion> a (a p) * top) \\<le> Z \\<squnion> a (a p) * top\n  ?x \\<le> ?b \\<Longrightarrow> ?x \\<le> ?a \\<squnion> ?b\n  (?b \\<squnion> ?c \\<le> ?a) = (?b \\<le> ?a \\<and> ?c \\<le> ?a)\n  ?x \\<le> ?x * top\n\ngoal (1 subgoal):\n 1. x * (Z \\<squnion> a (a p) * top) \\<squnion> a (a p)\n    \\<le> Z \\<squnion> a (a p) * top", "by auto"], ["proof (state)\nthis:\n  x * (Z \\<squnion> a (a p) * top) \\<squnion> a (a p)\n  \\<le> Z \\<squnion> a (a p) * top\n\ngoal (1 subgoal):\n 1. a p \\<le> | x\\<^sup>\\<star> ] a p", "thus ?thesis"], ["proof (prove)\nusing this:\n  x * (Z \\<squnion> a (a p) * top) \\<squnion> a (a p)\n  \\<le> Z \\<squnion> a (a p) * top\n\ngoal (1 subgoal):\n 1. a p \\<le> | x\\<^sup>\\<star> ] a p", "by (metis sup_commute box_demodalisation_2 mult_assoc shunting_Z star_left_induct)"], ["proof (state)\nthis:\n  a p \\<le> | x\\<^sup>\\<star> ] a p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma box_circ_induct:\n  \"-p \\<le> |x](-p) \\<Longrightarrow> -p*aL \\<le> |x\\<^sup>\\<circ>](-p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p \\<le> | x ] a p \\<Longrightarrow>\n    a p * aL \\<le> | x\\<^sup>\\<circ> ] a p", "by (smt aL_circ_ext aL_test box_left_mult box_star_induct order_trans tests_dual.inf_commutative pre_closed pre_def pre_test tests_dual.shunting_right)"], ["", "lemma a_while_soundness:\n  assumes \"-p*-q \\<le> |x](-q)\"\n    shows \"aL*-q \\<le> |(-p*x)\\<^sup>\\<circ>*--p](-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aL * a q \\<le> | (a p * x)\\<^sup>\\<circ> * a (a p) ] a q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. aL * a q \\<le> | (a p * x)\\<^sup>\\<circ> * a (a p) ] a q", "have \"|(-p*x)\\<^sup>\\<circ>](-q) \\<le> |(-p*x)\\<^sup>\\<circ>*--p](-q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. | (a p * x)\\<^sup>\\<circ> ] a q\n    \\<le> | (a p * x)\\<^sup>\\<circ> * a (a p) ] a q", "by (meson box_left_antitone circ_mult_upper_bound circ_reflexive order.refl order.trans tests_dual.sub_bot_least)"], ["proof (state)\nthis:\n  | (a p * x)\\<^sup>\\<circ> ] a q\n  \\<le> | (a p * x)\\<^sup>\\<circ> * a (a p) ] a q\n\ngoal (1 subgoal):\n 1. aL * a q \\<le> | (a p * x)\\<^sup>\\<circ> * a (a p) ] a q", "thus ?thesis"], ["proof (prove)\nusing this:\n  | (a p * x)\\<^sup>\\<circ> ] a q\n  \\<le> | (a p * x)\\<^sup>\\<circ> * a (a p) ] a q\n\ngoal (1 subgoal):\n 1. aL * a q \\<le> | (a p * x)\\<^sup>\\<circ> * a (a p) ] a q", "by (smt assms box_import_shunting box_circ_induct order_trans sub_comm aL_test)"], ["proof (state)\nthis:\n  aL * a q \\<le> | (a p * x)\\<^sup>\\<circ> * a (a p) ] a q\n\ngoal:\nNo subgoals!", "qed"], ["", "subclass hoare_calculus_sound"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.hoare_calculus_sound Sup (1::'a) (*) a (\\<squnion>) bot (\\<le>)\n     (<) Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q x.\n       a p * a q \\<le> x \\<guillemotleft> a q \\<longrightarrow>\n       aL * a q \\<le> a p \\<star> x \\<guillemotleft> a q", "by (simp add: a_while_soundness pre_def while_def)"], ["", "end"], ["", "class diamond_hoare_sound = diamond_hoare_calculus + left_kleene_conway_semiring +\n  assumes aL_circ: \"aL * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<star>\"\nbegin"], ["", "lemma aL_circ_equal:\n  \"aL * x\\<^sup>\\<circ> = aL * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aL * x\\<^sup>\\<circ> = aL * x\\<^sup>\\<star>", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. aL * x\\<^sup>\\<circ> \\<le> aL * x\\<^sup>\\<star>\n 2. aL * x\\<^sup>\\<star> \\<le> aL * x\\<^sup>\\<circ>", "using aL_circ aL_one_circ d_restrict_iff_1"], ["proof (prove)\nusing this:\n  aL * ?x\\<^sup>\\<circ> \\<le> ?x\\<^sup>\\<star>\n  aL = d ((1::'a)\\<^sup>\\<circ> * bot)\n  (d ?x * ?y \\<le> ?z) = (d ?x * ?y \\<le> d ?x * ?z)\n\ngoal (2 subgoals):\n 1. aL * x\\<^sup>\\<circ> \\<le> aL * x\\<^sup>\\<star>\n 2. aL * x\\<^sup>\\<star> \\<le> aL * x\\<^sup>\\<circ>", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. aL * x\\<^sup>\\<star> \\<le> aL * x\\<^sup>\\<circ>", "by (simp add: mult_right_isotone star_below_circ)"], ["", "lemma aL_zero:\n  \"aL = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aL = bot", "by (smt aL_circ_equal aL_one_circ d_export d_idempotent diamond_d_bot diamond_def mult_assoc mult_1_right star_one)"], ["", "subclass hoare_calculus_sound"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.hoare_calculus_sound Sup (1::'a) (*) a (\\<squnion>) bot (\\<le>)\n     (<) Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q x.\n       a p * a q \\<le> x \\<guillemotleft> a q \\<longrightarrow>\n       aL * a q \\<le> a p \\<star> x \\<guillemotleft> a q", "using aL_zero"], ["proof (prove)\nusing this:\n  aL = bot\n\ngoal (1 subgoal):\n 1. \\<And>p q x.\n       a p * a q \\<le> x \\<guillemotleft> a q \\<longrightarrow>\n       aL * a q \\<le> a p \\<star> x \\<guillemotleft> a q", "by auto"], ["", "end"], ["", "class box_hoare_complete = box_hoare_calculus + left_kleene_conway_semiring +\n  assumes box_circ_induct_2: \"-p*|x](-q) \\<le> -q \\<longrightarrow> |x\\<^sup>\\<circ>](-p) \\<le> -q\\<squnion>aL\"\n  assumes aL_zero_or_one: \"aL = bot \\<or> aL = 1\"\n  assumes while_mult_left_dist_Prod: \"x \\<in> While_program \\<and> descending_chain t \\<and> test_seq t \\<longrightarrow> x*Prod t = Prod (\\<lambda>n . x*t n)\"\nbegin"], ["", "subclass hoare_calculus_complete"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.hoare_calculus_complete Sup (1::'a) (*) a (\\<squnion>) bot (\\<le>)\n     (<) Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x q.\n       (x \\<guillemotleft> a q) * aL \\<le> x \\<guillemotleft> a q * aL\n 2. \\<And>x t.\n       x \\<in> While_program \\<and>\n       ascending_chain t \\<and> test_seq t \\<longrightarrow>\n       x \\<guillemotleft> complete_tests_class.Sum t =\n       complete_tests_class.Sum (\\<lambda>n. x \\<guillemotleft> t n)\n 3. \\<And>p x q.\n       a p * (x \\<guillemotleft> a q) \\<le> a q \\<longrightarrow>\n       a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "apply (metis aL_zero_or_one bot_least order.eq_iff mult_1_right pre_closed tests_dual.sup_right_zero)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       x \\<in> While_program \\<and>\n       ascending_chain t \\<and> test_seq t \\<longrightarrow>\n       x \\<guillemotleft> complete_tests_class.Sum t =\n       complete_tests_class.Sum (\\<lambda>n. x \\<guillemotleft> t n)\n 2. \\<And>p x q.\n       a p * (x \\<guillemotleft> a q) \\<le> a q \\<longrightarrow>\n       a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> While_program \\<and>\n    ascending_chain t_ \\<and> test_seq t_ \\<longrightarrow>\n    x_ \\<guillemotleft> complete_tests_class.Sum t_ =\n    complete_tests_class.Sum (\\<lambda>n. x_ \\<guillemotleft> t_ n)", "apply (unfold pre_def box_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> While_program \\<and>\n    ascending_chain t_ \\<and> test_seq t_ \\<longrightarrow>\n    a (x_ * a (complete_tests_class.Sum t_)) =\n    complete_tests_class.Sum (\\<lambda>n. a (x_ * a (t_ n)))", "by (metis a_ascending_chain a_dist_Prod a_dist_Sum descending_chain_left_mult while_mult_left_dist_Prod test_seq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x q.\n       a p * (x \\<guillemotleft> a q) \\<le> a q \\<longrightarrow>\n       a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "by (smt box_circ_induct_2 tests_dual.double_negation tests_dual.greatest_lower_bound tests_dual.upper_bound_left mult_right_dist_sup pre_closed pre_def pre_import pre_seq pre_test sub_mult_closed while_def)"], ["", "end"], ["", "class diamond_hoare_complete = diamond_hoare_calculus + relative_domain_semiring_split + left_kleene_conway_semiring +\n  assumes dL_circ: \"-aL*x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<star>\"\n  assumes aL_zero_or_one: \"aL = bot \\<or> aL = 1\"\n  assumes while_mult_left_dist_Sum: \"x \\<in> While_program \\<and> ascending_chain t \\<and> test_seq t \\<longrightarrow> x*Sum t = Sum (\\<lambda>n . x*t n)\"\nbegin"], ["", "lemma diamond_star_induct_var:\n  assumes \"|x>(d p) \\<le> d p\"\n    shows \"|x\\<^sup>\\<star>>(d p) \\<le> d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. | x\\<^sup>\\<star> > d p \\<le> d p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. | x\\<^sup>\\<star> > d p \\<le> d p", "have \"x * (d p * x\\<^sup>\\<star> \\<squnion> Z) \\<le> d p * x * x\\<^sup>\\<star> \\<squnion> Z * x\\<^sup>\\<star> \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (d p * x\\<^sup>\\<star> \\<squnion> Z)\n    \\<le> d p * x * x\\<^sup>\\<star> \\<squnion>\n          Z * x\\<^sup>\\<star> \\<squnion>\n          Z", "by (metis assms sup_left_isotone d_mult_d diamond_def diamond_demodalisation_3 mult_assoc mult_left_isotone mult_right_dist_sup order_trans split_Z)"], ["proof (state)\nthis:\n  x * (d p * x\\<^sup>\\<star> \\<squnion> Z)\n  \\<le> d p * x * x\\<^sup>\\<star> \\<squnion> Z * x\\<^sup>\\<star> \\<squnion>\n        Z\n\ngoal (1 subgoal):\n 1. | x\\<^sup>\\<star> > d p \\<le> d p", "also"], ["proof (state)\nthis:\n  x * (d p * x\\<^sup>\\<star> \\<squnion> Z)\n  \\<le> d p * x * x\\<^sup>\\<star> \\<squnion> Z * x\\<^sup>\\<star> \\<squnion>\n        Z\n\ngoal (1 subgoal):\n 1. | x\\<^sup>\\<star> > d p \\<le> d p", "have \"... \\<le> d p * x\\<^sup>\\<star> \\<squnion> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d p * x * x\\<^sup>\\<star> \\<squnion> Z * x\\<^sup>\\<star> \\<squnion> Z\n    \\<le> d p * x\\<^sup>\\<star> \\<squnion> Z", "by (metis Z_mult_decreasing mult_right_isotone star.left_plus_below_circ sup.bounded_iff sup_ge1 sup_mono sup_monoid.add_commute mult_assoc)"], ["proof (state)\nthis:\n  d p * x * x\\<^sup>\\<star> \\<squnion> Z * x\\<^sup>\\<star> \\<squnion> Z\n  \\<le> d p * x\\<^sup>\\<star> \\<squnion> Z\n\ngoal (1 subgoal):\n 1. | x\\<^sup>\\<star> > d p \\<le> d p", "finally"], ["proof (chain)\npicking this:\n  x * (d p * x\\<^sup>\\<star> \\<squnion> Z)\n  \\<le> d p * x\\<^sup>\\<star> \\<squnion> Z", "show ?thesis"], ["proof (prove)\nusing this:\n  x * (d p * x\\<^sup>\\<star> \\<squnion> Z)\n  \\<le> d p * x\\<^sup>\\<star> \\<squnion> Z\n\ngoal (1 subgoal):\n 1. | x\\<^sup>\\<star> > d p \\<le> d p", "by (smt sup_commute le_sup_iff sup_ge2 d_mult_d diamond_def diamond_demodalisation_3 order_trans star.circ_back_loop_prefixpoint star_left_induct)"], ["proof (state)\nthis:\n  | x\\<^sup>\\<star> > d p \\<le> d p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diamond_star_induct:\n  \"d q \\<squnion> |x>(d p) \\<le> d p \\<Longrightarrow> |x\\<^sup>\\<star>>(d q) \\<le> d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d q \\<squnion> | x > d p \\<le> d p \\<Longrightarrow>\n    | x\\<^sup>\\<star> > d q \\<le> d p", "by (metis le_sup_iff diamond_star_induct_var diamond_right_isotone order_trans)"], ["", "lemma while_completeness_1:\n  assumes \"-p*(x\\<guillemotleft>-q) \\<le> -q\"\n    shows \"-p\\<star>x\\<guillemotleft>-q \\<le> -q\\<squnion>aL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "have \"--p*-q \\<squnion> |-p*x>(-q) \\<le> -q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a p) * a q \\<squnion> | a p * x > a q \\<le> a q", "using assms pre_def pre_export tests_dual.upper_bound_right"], ["proof (prove)\nusing this:\n  a p * (x \\<guillemotleft> a q) \\<le> a q\n  ?x \\<guillemotleft> ?p = | ?x > ?p\n  a ?p * ?x \\<guillemotleft> a ?q = a ?p * (?x \\<guillemotleft> a ?q)\n  a ?x * a ?y \\<le> a ?y\n\ngoal (1 subgoal):\n 1. a (a p) * a q \\<squnion> | a p * x > a q \\<le> a q", "by auto"], ["proof (state)\nthis:\n  a (a p) * a q \\<squnion> | a p * x > a q \\<le> a q\n\ngoal (1 subgoal):\n 1. a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "hence \"|(-p*x)\\<^sup>\\<star>>(--p*-q) \\<le> -q\""], ["proof (prove)\nusing this:\n  a (a p) * a q \\<squnion> | a p * x > a q \\<le> a q\n\ngoal (1 subgoal):\n 1. | (a p * x)\\<^sup>\\<star> > (a (a p) * a q) \\<le> a q", "by (smt diamond_star_induct d_def sub_mult_closed tests_dual.double_negation)"], ["proof (state)\nthis:\n  | (a p * x)\\<^sup>\\<star> > (a (a p) * a q) \\<le> a q\n\ngoal (1 subgoal):\n 1. a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "hence \"|-aL*(-p*x)\\<^sup>\\<circ>>(--p*-q) \\<le> -q\""], ["proof (prove)\nusing this:\n  | (a p * x)\\<^sup>\\<star> > (a (a p) * a q) \\<le> a q\n\ngoal (1 subgoal):\n 1. | a aL * (a p * x)\\<^sup>\\<circ> > (a (a p) * a q) \\<le> a q", "by (meson dL_circ diamond_isotone order.eq_iff order.trans)"], ["proof (state)\nthis:\n  | a aL * (a p * x)\\<^sup>\\<circ> > (a (a p) * a q) \\<le> a q\n\ngoal (1 subgoal):\n 1. a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "thus ?thesis"], ["proof (prove)\nusing this:\n  | a aL * (a p * x)\\<^sup>\\<circ> > (a (a p) * a q) \\<le> a q\n\ngoal (1 subgoal):\n 1. a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "by (smt aL_test diamond_a_export diamond_def mult_assoc tests_dual.inf_commutative pre_closed pre_def tests_dual.shunting while_def)"], ["proof (state)\nthis:\n  a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL\n\ngoal:\nNo subgoals!", "qed"], ["", "subclass hoare_calculus_complete"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.hoare_calculus_complete Sup (1::'a) (*) a (\\<squnion>) bot (\\<le>)\n     (<) Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x q.\n       (x \\<guillemotleft> a q) * aL \\<le> x \\<guillemotleft> a q * aL\n 2. \\<And>x t.\n       x \\<in> While_program \\<and>\n       ascending_chain t \\<and> test_seq t \\<longrightarrow>\n       x \\<guillemotleft> complete_tests_class.Sum t =\n       complete_tests_class.Sum (\\<lambda>n. x \\<guillemotleft> t n)\n 3. \\<And>p x q.\n       a p * (x \\<guillemotleft> a q) \\<le> a q \\<longrightarrow>\n       a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "apply (metis aL_test aL_zero_or_one bot_least order.eq_iff pre_closed pre_test pre_test_one tests_dual.sup_right_zero)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       x \\<in> While_program \\<and>\n       ascending_chain t \\<and> test_seq t \\<longrightarrow>\n       x \\<guillemotleft> complete_tests_class.Sum t =\n       complete_tests_class.Sum (\\<lambda>n. x \\<guillemotleft> t n)\n 2. \\<And>p x q.\n       a p * (x \\<guillemotleft> a q) \\<le> a q \\<longrightarrow>\n       a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> While_program \\<and>\n    ascending_chain t_ \\<and> test_seq t_ \\<longrightarrow>\n    x_ \\<guillemotleft> complete_tests_class.Sum t_ =\n    complete_tests_class.Sum (\\<lambda>n. x_ \\<guillemotleft> t_ n)", "apply (unfold pre_def diamond_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> While_program \\<and>\n    ascending_chain t_ \\<and> test_seq t_ \\<longrightarrow>\n    d (x_ * complete_tests_class.Sum t_) =\n    complete_tests_class.Sum (\\<lambda>n. d (x_ * t_ n))", "by (simp add: ascending_chain_left_mult d_dist_Sum while_mult_left_dist_Sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x q.\n       a p * (x \\<guillemotleft> a q) \\<le> a q \\<longrightarrow>\n       a p \\<star> x \\<guillemotleft> a q \\<le> a q \\<squnion> aL", "by (simp add: while_completeness_1)"], ["", "end"], ["", "class box_hoare_valid = box_hoare_sound + box_hoare_complete + hoare_triple +\n  assumes hoare_triple_def: \"p\\<lbrace>x\\<rbrace>q \\<longleftrightarrow> p \\<le> |x]q\"\nbegin"], ["", "text \\<open>Theorem 49.2\\<close>"], ["", "subclass hoare_calculus_valid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.hoare_calculus_valid Sup (1::'a) (*) a (\\<squnion>) bot (\\<le>)\n     (<) Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)\n     hoare_triple", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x q.\n       a p \\<lbrace> x \\<rbrace> a q = (a p \\<le> x \\<guillemotleft> a q)", "by (simp add: hoare_triple_def pre_def)"], ["", "lemma rule_skip_valid:\n  \"-p\\<lbrace>1\\<rbrace>-p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a p \\<lbrace> (1::'a) \\<rbrace> a p", "by (simp add: rule_skip)"], ["", "end"], ["", "class diamond_hoare_valid = diamond_hoare_sound + diamond_hoare_complete + hoare_triple +\n  assumes hoare_triple_def: \"p\\<lbrace>x\\<rbrace>q \\<longleftrightarrow> p \\<le> |x>q\"\nbegin"], ["", "lemma circ_star_equal:\n  \"x\\<^sup>\\<circ> = x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<circ> = x\\<^sup>\\<star>", "by (metis aL_zero order.antisym dL_circ mult_left_one one_def star_below_circ)"], ["", "text \\<open>Theorem 49.1\\<close>"], ["", "subclass hoare_calculus_valid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.hoare_calculus_valid Sup (1::'a) (*) a (\\<squnion>) bot (\\<le>)\n     (<) Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)\n     hoare_triple", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x q.\n       a p \\<lbrace> x \\<rbrace> a q = (a p \\<le> x \\<guillemotleft> a q)", "by (simp add: hoare_triple_def pre_def)"], ["", "end"], ["", "class diamond_hoare_sound_2 = diamond_hoare_calculus + left_kleene_conway_semiring +\n  assumes diamond_circ_induct_2: \"--p*-q \\<le> |x>(-q) \\<longrightarrow>  aL*-q \\<le> |x\\<^sup>\\<circ>>(-p)\"\nbegin"], ["", "subclass hoare_calculus_sound"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.hoare_calculus_sound Sup (1::'a) (*) a (\\<squnion>) bot (\\<le>)\n     (<) Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q x.\n       a p * a q \\<le> x \\<guillemotleft> a q \\<longrightarrow>\n       aL * a q \\<le> a p \\<star> x \\<guillemotleft> a q", "by (smt a_export diamond_associative diamond_circ_induct_2 tests_dual.double_negation tests_dual.sup_complement_intro pre_def pre_import_equiv_mult sub_comm sub_mult_closed while_def)"], ["", "end"], ["", "class diamond_hoare_valid_2 = diamond_hoare_sound_2 + diamond_hoare_complete + hoare_triple +\n  assumes hoare_triple_def: \"p\\<lbrace>x\\<rbrace>q \\<longleftrightarrow> p \\<le> |x>q\"\nbegin"], ["", "subclass hoare_calculus_valid"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.hoare_calculus_valid Sup (1::'a) (*) a (\\<squnion>) bot (\\<le>)\n     (<) Atomic_program Atomic_test (\\<star>) ite (\\<guillemotleft>)\n     hoare_triple", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x q.\n       a p \\<lbrace> x \\<rbrace> a q = (a p \\<le> x \\<guillemotleft> a q)", "by (simp add: hoare_triple_def pre_def)"], ["", "end"], ["", "end"]]}