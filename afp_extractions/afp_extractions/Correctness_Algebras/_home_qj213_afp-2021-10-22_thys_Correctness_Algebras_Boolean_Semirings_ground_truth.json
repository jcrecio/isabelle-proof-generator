{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Boolean_Semirings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma vector_1:\n  \"vector x \\<longleftrightarrow> x * top \\<le> x\"", "lemma zero_vector_left_zero:\n  assumes \"zero_vector x\"\n    shows \"x * y = x * bot\"", "lemma zero_vector_1:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y . x * y = x * bot)\"", "lemma zero_vector_2:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y . x * y \\<le> x * bot)\"", "lemma zero_vector_3:\n  \"zero_vector x \\<longleftrightarrow> x * 1 = x * bot\"", "lemma zero_vector_4:\n  \"zero_vector x \\<longleftrightarrow> x * 1 \\<le> x * bot\"", "lemma zero_vector_5:\n  \"zero_vector x \\<longleftrightarrow> x * top = x * bot\"", "lemma zero_vector_6:\n  \"zero_vector x \\<longleftrightarrow> x * top \\<le> x * bot\"", "lemma zero_vector_7:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y . x * top = x * y)\"", "lemma zero_vector_8:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y . x * top \\<le> x * y)\"", "lemma zero_vector_9:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y . x * 1 = x * y)\"", "lemma zero_vector_0:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y z . x * y = x * z)\"", "lemma co_vector_zero_vector_one_vector:\n  \"co_vector x \\<longleftrightarrow> zero_vector x \\<and> one_vector x\"", "lemma up_closed_one_vector:\n  \"up_closed x \\<Longrightarrow> one_vector x\"", "lemma zero_vector_dense:\n  \"zero_vector x \\<Longrightarrow> dense_rel x\"", "lemma zero_vector_sup_distributive:\n  \"zero_vector x \\<Longrightarrow> sup_distributive x\"", "lemma zero_vector_inf_distributive:\n  \"zero_vector x \\<Longrightarrow> inf_distributive x\"", "lemma up_closed_zero_vector_vector:\n  \"up_closed x \\<Longrightarrow> zero_vector x \\<Longrightarrow> vector x\"", "lemma zero_vector_one_vector_vector:\n  \"zero_vector x \\<Longrightarrow> one_vector x \\<Longrightarrow> vector x\"", "lemma co_vector_vector:\n  \"co_vector x \\<Longrightarrow> vector x\"", "lemma zero_zero_vector:\n  \"zero_vector bot\"", "lemma sup_zero_vector:\n  \"zero_vector x \\<Longrightarrow> zero_vector y \\<Longrightarrow> zero_vector (x \\<squnion> y)\"", "lemma comp_zero_vector:\n  \"zero_vector x \\<Longrightarrow> zero_vector y \\<Longrightarrow> zero_vector (x * y)\"", "lemma zero_one_vector:\n  \"one_vector bot\"", "lemma one_one_vector:\n  \"one_vector 1\"", "lemma top_one_vector:\n  \"one_vector top\"", "lemma sup_one_vector:\n  \"one_vector x \\<Longrightarrow> one_vector y \\<Longrightarrow> one_vector (x \\<squnion> y)\"", "lemma inf_one_vector:\n  \"one_vector x \\<Longrightarrow> one_vector y \\<Longrightarrow> one_vector (x \\<sqinter> y)\"", "lemma comp_one_vector:\n  \"one_vector x \\<Longrightarrow> one_vector y \\<Longrightarrow> one_vector (x * y)\"", "lemma top_zero_vector:\n   \"zero_vector top\"", "lemma zero_vector_10:\n  \"zero_vector x \\<longleftrightarrow> x * top = x * 1\"", "lemma zero_vector_11:\n  \"zero_vector x \\<longleftrightarrow> x * top \\<le> x * 1\"", "lemma vector_zero_vector:\n  \"vector x \\<Longrightarrow> zero_vector x\"", "lemma vector_up_closed_zero_vector:\n  \"vector x \\<longleftrightarrow> up_closed x \\<and> zero_vector x\"", "lemma vector_zero_vector_one_vector:\n  \"vector x \\<longleftrightarrow> zero_vector x \\<and> one_vector x\"", "lemma up_closed:\n  \"up_closed x\"", "lemma dedekind_1_left:\n  \"x * 1 \\<sqinter> y \\<le> (x \\<sqinter> y * 1) * 1\"", "lemma zero_vector_dual:\n  \"zero_vector x \\<longleftrightarrow> zero_vector (x\\<^sup>d)\"", "lemma zero_down_closed:\n  \"down_closed bot\"", "lemma top_down_closed:\n  \"down_closed top\"", "lemma complement_down_closed_up_closed:\n  \"down_closed x \\<longleftrightarrow> up_closed (-x)\"", "lemma sup_down_closed:\n  \"down_closed x \\<Longrightarrow> down_closed y \\<Longrightarrow> down_closed (x \\<squnion> y)\"", "lemma inf_down_closed:\n  \"down_closed x \\<Longrightarrow> down_closed y \\<Longrightarrow> down_closed (x \\<sqinter> y)\"", "lemma complement_mult_zero_sub:\n  \"-(x * bot) \\<le> -x * bot\"", "lemma transitive_zero_vector_complement:\n  \"transitive x \\<Longrightarrow> zero_vector (-x)\"", "lemma transitive_dense_complement:\n  \"transitive x \\<Longrightarrow> dense_rel (-x)\"", "lemma transitive_sup_distributive_complement:\n  \"transitive x \\<Longrightarrow> sup_distributive (-x)\"", "lemma transitive_inf_distributive_complement:\n  \"transitive x \\<Longrightarrow> inf_distributive (-x)\"", "lemma up_closed_zero_vector_complement:\n  \"up_closed x \\<Longrightarrow> zero_vector (-x)\"", "lemma up_closed_dense_complement:\n  \"up_closed x \\<Longrightarrow> dense_rel (-x)\"", "lemma up_closed_sup_distributive_complement:\n  \"up_closed x \\<Longrightarrow> sup_distributive (-x)\"", "lemma up_closed_inf_distributive_complement:\n  \"up_closed x \\<Longrightarrow> inf_distributive (-x)\"", "lemma co_total_total:\n  \"co_total x \\<Longrightarrow> total (-x)\"", "lemma complement_one_vector_zero_vector:\n  \"one_vector x \\<Longrightarrow> zero_vector (-x)\"", "lemma down_closed_zero_vector:\n  \"down_closed x \\<Longrightarrow> zero_vector x\"", "lemma down_closed_one_vector_vector:\n  \"down_closed x \\<Longrightarrow> one_vector x \\<Longrightarrow> vector x\"", "lemma schroeder_top_sub:\n  \"-(x * top) * top \\<le> -x\"", "lemma schroeder_top:\n  \"x * top \\<le> y \\<longleftrightarrow> -y * top \\<le> -x\"", "lemma schroeder_top_eq:\n  \"-(x * top) * top = -(x * top)\"", "lemma schroeder_one_eq:\n  \"-(x * top) * 1 = -(x * top)\"", "lemma vector_inf_comp:\n  \"x * top \\<sqinter> y * z = (x * top \\<sqinter> y) * z\"", "lemma vector_zero_inf_comp:\n  \"(x * bot \\<sqinter> y) * z = x * bot \\<sqinter> y * z\"", "lemma vector_zero_inf_comp_2:\n  \"(x * bot \\<sqinter> y) * z = (x * bot \\<sqinter> y * 1) * z\"", "lemma comp_zero_inf_2:\n  \"x * bot \\<sqinter> y * bot = (x \\<sqinter> y) * bot\"", "lemma comp_zero_inf_3:\n  \"x * bot \\<sqinter> y * bot = (x * bot \\<sqinter> y) * bot\"", "lemma comp_zero_inf_4:\n  \"x * bot \\<sqinter> y * bot = (x * bot \\<sqinter> y * bot) * bot\"", "lemma comp_zero_inf_5:\n  \"x * bot \\<sqinter> y * bot = (x * 1 \\<sqinter> y * 1) * bot\"", "lemma comp_zero_inf_6:\n  \"x * bot \\<sqinter> y * bot = (x * 1 \\<sqinter> y * bot) * bot\"", "lemma comp_zero_inf_7:\n  \"x * bot \\<sqinter> y * bot = (x * 1 \\<sqinter> y) * bot\"", "lemma inf_zero_vector:\n  \"zero_vector x \\<Longrightarrow> zero_vector y \\<Longrightarrow> zero_vector (x \\<sqinter> y)\"", "lemma comp_down_closed:\n  \"down_closed x \\<Longrightarrow> down_closed y \\<Longrightarrow> down_closed (x * y)\"", "lemma complement_vector:\n  \"vector x \\<longleftrightarrow> vector (-x)\"", "lemma complement_zero_vector_one_vector:\n  \"zero_vector x \\<Longrightarrow> one_vector (-x)\"", "lemma complement_zero_vector_one_vector_iff:\n  \"zero_vector x \\<longleftrightarrow> one_vector (-x)\"", "lemma complement_one_vector_zero_vector_iff:\n  \"one_vector x \\<longleftrightarrow> zero_vector (-x)\"", "lemma vector_down_closed:\n  \"vector x \\<Longrightarrow> down_closed x\"", "lemma co_vector_down_closed:\n  \"co_vector x \\<Longrightarrow> down_closed x\"", "lemma vector_down_closed_one_vector:\n  \"vector x \\<longleftrightarrow> down_closed x \\<and> one_vector x\"", "lemma vector_up_closed_down_closed:\n  \"vector x \\<longleftrightarrow> up_closed x \\<and> down_closed x\"", "lemma vector_b1:\n  \"vector x \\<longleftrightarrow> -x * top = -x\"", "lemma vector_b2:\n  \"vector x \\<longleftrightarrow> -x * bot = -x\"", "lemma covector_b1:\n  \"co_vector x \\<longleftrightarrow> -x * top = -x\"", "lemma covector_b2:\n  \"co_vector x \\<longleftrightarrow> -x * bot = -x\"", "lemma vector_co_vector_iff:\n  \"vector x \\<longleftrightarrow> co_vector x\"", "lemma zero_vector_b:\n  \"zero_vector x \\<longleftrightarrow> -x * bot \\<le> -x\"", "lemma one_vector_b1:\n  \"one_vector x \\<longleftrightarrow> -x \\<le> -x * bot\"", "lemma one_vector_b0:\n  \"one_vector x \\<longleftrightarrow> (\\<forall>y z . -x * y = -x * z)\"", "lemma dual_complement_commute:\n  \"-(x\\<^sup>d) = (-x)\\<^sup>d\"", "lemma dual_down_closed:\n  \"down_closed x \\<longleftrightarrow> down_closed (x\\<^sup>d)\"", "lemma complement_mult_zero_below:\n  \"-x * bot \\<le> -(x * bot)\"", "lemma complement_zero_vector:\n  \"zero_vector x \\<longleftrightarrow> zero_vector (-x)\"", "lemma down_closed:\n  \"down_closed x\"", "lemma vector:\n  \"vector x\""], "translations": [["", "lemma vector_1:\n  \"vector x \\<longleftrightarrow> x * top \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = (x * top \\<le> x)", "by (simp add: antisym_conv top_right_mult_increasing)"], ["", "definition zero_vector :: \"'a \\<Rightarrow> bool\" where \"zero_vector x \\<equiv> x \\<le> x * bot\""], ["", "definition one_vector :: \"'a \\<Rightarrow> bool\" where \"one_vector x \\<equiv> x * bot \\<le> x\""], ["", "lemma zero_vector_left_zero:\n  assumes \"zero_vector x\"\n    shows \"x * y = x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = x * bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y = x * bot", "have \"x * y \\<le> x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<le> x * bot", "by (metis assms mult_isotone top.extremum vector_mult_closed zero_vector zero_vector_def)"], ["proof (state)\nthis:\n  x * y \\<le> x * bot\n\ngoal (1 subgoal):\n 1. x * y = x * bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  x * y \\<le> x * bot\n\ngoal (1 subgoal):\n 1. x * y = x * bot", "by (simp add: order.antisym mult_right_isotone)"], ["proof (state)\nthis:\n  x * y = x * bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_vector_1:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y . x * y = x * bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (\\<forall>y. x * y = x * bot)", "by (metis top_right_mult_increasing zero_vector_def zero_vector_left_zero)"], ["", "lemma zero_vector_2:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y . x * y \\<le> x * bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (\\<forall>y. x * y \\<le> x * bot)", "by (metis eq_refl order_trans top_right_mult_increasing zero_vector_def zero_vector_left_zero)"], ["", "lemma zero_vector_3:\n  \"zero_vector x \\<longleftrightarrow> x * 1 = x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (x * (1::'a) = x * bot)", "by (metis mult_sub_right_one zero_vector_def zero_vector_left_zero)"], ["", "lemma zero_vector_4:\n  \"zero_vector x \\<longleftrightarrow> x * 1 \\<le> x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (x * (1::'a) \\<le> x * bot)", "using order.antisym mult_right_isotone zero_vector_3"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  zero_vector ?x = (?x * (1::'a) = ?x * bot)\n\ngoal (1 subgoal):\n 1. zero_vector x = (x * (1::'a) \\<le> x * bot)", "by auto"], ["", "lemma zero_vector_5:\n  \"zero_vector x \\<longleftrightarrow> x * top = x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (x * top = x * bot)", "by (metis top_right_mult_increasing zero_vector_def zero_vector_left_zero)"], ["", "lemma zero_vector_6:\n  \"zero_vector x \\<longleftrightarrow> x * top \\<le> x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (x * top \\<le> x * bot)", "by (meson mult_right_isotone order_trans top.extremum zero_vector_2)"], ["", "lemma zero_vector_7:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y . x * top = x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (\\<forall>y. x * top = x * y)", "by (metis zero_vector_1)"], ["", "lemma zero_vector_8:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y . x * top \\<le> x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (\\<forall>y. x * top \\<le> x * y)", "by (metis zero_vector_6 zero_vector_left_zero)"], ["", "lemma zero_vector_9:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y . x * 1 = x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (\\<forall>y. x * (1::'a) = x * y)", "by (metis zero_vector_1)"], ["", "lemma zero_vector_0:\n  \"zero_vector x \\<longleftrightarrow> (\\<forall>y z . x * y = x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (\\<forall>y z. x * y = x * z)", "by (metis zero_vector_5 zero_vector_left_zero)"], ["", "text \\<open>Theorem 6 / Figure 2: relations between properties\\<close>"], ["", "lemma co_vector_zero_vector_one_vector:\n  \"co_vector x \\<longleftrightarrow> zero_vector x \\<and> one_vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_vector x = (zero_vector x \\<and> one_vector x)", "using co_vector_def one_vector_def zero_vector_def"], ["proof (prove)\nusing this:\n  co_vector ?x \\<equiv> ?x * bot = ?x\n  one_vector ?x \\<equiv> ?x * bot \\<le> ?x\n  zero_vector ?x \\<equiv> ?x \\<le> ?x * bot\n\ngoal (1 subgoal):\n 1. co_vector x = (zero_vector x \\<and> one_vector x)", "by auto"], ["", "lemma up_closed_one_vector:\n  \"up_closed x \\<Longrightarrow> one_vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed x \\<Longrightarrow> one_vector x", "by (metis bot_least mult_right_isotone up_closed_def one_vector_def)"], ["", "lemma zero_vector_dense:\n  \"zero_vector x \\<Longrightarrow> dense_rel x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x \\<Longrightarrow> dense_rel x", "by (metis zero_vector_0 zero_vector_def)"], ["", "lemma zero_vector_sup_distributive:\n  \"zero_vector x \\<Longrightarrow> sup_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x \\<Longrightarrow> sup_distributive x", "by (metis sup_distributive_def sup_idem zero_vector_0)"], ["", "lemma zero_vector_inf_distributive:\n  \"zero_vector x \\<Longrightarrow> inf_distributive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x \\<Longrightarrow> inf_distributive x", "by (metis inf_idem inf_distributive_def zero_vector_0)"], ["", "lemma up_closed_zero_vector_vector:\n  \"up_closed x \\<Longrightarrow> zero_vector x \\<Longrightarrow> vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>up_closed x; zero_vector x\\<rbrakk> \\<Longrightarrow> vector x", "by (metis up_closed_def zero_vector_0)"], ["", "lemma zero_vector_one_vector_vector:\n  \"zero_vector x \\<Longrightarrow> one_vector x \\<Longrightarrow> vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>zero_vector x; one_vector x\\<rbrakk> \\<Longrightarrow> vector x", "by (metis one_vector_def vector_1 zero_vector_0)"], ["", "lemma co_vector_vector:\n  \"co_vector x \\<Longrightarrow> vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_vector x \\<Longrightarrow> vector x", "by (simp add: co_vector_zero_vector_one_vector zero_vector_one_vector_vector)"], ["", "text \\<open>Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>zero-vector\\<close>"], ["", "lemma zero_zero_vector:\n  \"zero_vector bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector bot", "by (simp add: zero_vector_def)"], ["", "lemma sup_zero_vector:\n  \"zero_vector x \\<Longrightarrow> zero_vector y \\<Longrightarrow> zero_vector (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>zero_vector x; zero_vector y\\<rbrakk>\n    \\<Longrightarrow> zero_vector (x \\<squnion> y)", "by (simp add: mult_right_dist_sup zero_vector_3)"], ["", "lemma comp_zero_vector:\n  \"zero_vector x \\<Longrightarrow> zero_vector y \\<Longrightarrow> zero_vector (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>zero_vector x; zero_vector y\\<rbrakk>\n    \\<Longrightarrow> zero_vector (x * y)", "by (metis mult_one_associative zero_vector_0)"], ["", "text \\<open>one-vector\\<close>"], ["", "lemma zero_one_vector:\n  \"one_vector bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_vector bot", "by (simp add: one_vector_def)"], ["", "lemma one_one_vector:\n  \"one_vector 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_vector (1::'a)", "by (simp add: one_up_closed up_closed_one_vector)"], ["", "lemma top_one_vector:\n  \"one_vector top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_vector top", "by (simp add: one_vector_def)"], ["", "lemma sup_one_vector:\n  \"one_vector x \\<Longrightarrow> one_vector y \\<Longrightarrow> one_vector (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>one_vector x; one_vector y\\<rbrakk>\n    \\<Longrightarrow> one_vector (x \\<squnion> y)", "by (simp add: mult_right_dist_sup order_trans one_vector_def)"], ["", "lemma inf_one_vector:\n  \"one_vector x \\<Longrightarrow> one_vector y \\<Longrightarrow> one_vector (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>one_vector x; one_vector y\\<rbrakk>\n    \\<Longrightarrow> one_vector (x \\<sqinter> y)", "by (meson order.trans inf.boundedI mult_right_sub_dist_inf_left mult_right_sub_dist_inf_right one_vector_def)"], ["", "lemma comp_one_vector:\n  \"one_vector x \\<Longrightarrow> one_vector y \\<Longrightarrow> one_vector (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>one_vector x; one_vector y\\<rbrakk>\n    \\<Longrightarrow> one_vector (x * y)", "using mult_isotone mult_semi_associative order_lesseq_imp one_vector_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w * ?x \\<le> ?y * ?z\n  ?x * ?y * ?z \\<le> ?x * (?y * ?z)\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  one_vector ?x \\<equiv> ?x * bot \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>one_vector x; one_vector y\\<rbrakk>\n    \\<Longrightarrow> one_vector (x * y)", "by blast"], ["", "end"], ["", "context multirelation_algebra_1\nbegin"], ["", "text \\<open>Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>zero-vector\\<close>"], ["", "lemma top_zero_vector:\n   \"zero_vector top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector top", "by (simp add: mult_left_top zero_vector_def)"], ["", "end"], ["", "text \\<open>M1-algebra\\<close>"], ["", "context multirelation_algebra_2\nbegin"], ["", "text \\<open>Section 7\\<close>"], ["", "lemma zero_vector_10:\n  \"zero_vector x \\<longleftrightarrow> x * top = x * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (x * top = x * (1::'a))", "by (metis mult_one_associative mult_top_associative zero_vector_7)"], ["", "lemma zero_vector_11:\n  \"zero_vector x \\<longleftrightarrow> x * top \\<le> x * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (x * top \\<le> x * (1::'a))", "using order.antisym mult_right_isotone zero_vector_10"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  zero_vector ?x = (?x * top = ?x * (1::'a))\n\ngoal (1 subgoal):\n 1. zero_vector x = (x * top \\<le> x * (1::'a))", "by fastforce"], ["", "text \\<open>Theorem 6 / Figure 2: relations between properties\\<close>"], ["", "lemma vector_zero_vector:\n  \"vector x \\<Longrightarrow> zero_vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> zero_vector x", "by (simp add: zero_vector_def vector_left_annihilator)"], ["", "lemma vector_up_closed_zero_vector:\n  \"vector x \\<longleftrightarrow> up_closed x \\<and> zero_vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = (up_closed x \\<and> zero_vector x)", "using up_closed_zero_vector_vector vector_up_closed vector_zero_vector"], ["proof (prove)\nusing this:\n  \\<lbrakk>up_closed ?x; zero_vector ?x\\<rbrakk> \\<Longrightarrow> vector ?x\n  vector ?x \\<Longrightarrow> up_closed ?x\n  vector ?x \\<Longrightarrow> zero_vector ?x\n\ngoal (1 subgoal):\n 1. vector x = (up_closed x \\<and> zero_vector x)", "by blast"], ["", "lemma vector_zero_vector_one_vector:\n  \"vector x \\<longleftrightarrow> zero_vector x \\<and> one_vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = (zero_vector x \\<and> one_vector x)", "by (simp add: co_vector_zero_vector_one_vector vector_co_vector)"], ["", "(*\nlemma \"(x * bot \\<sqinter> y) * 1 = x * bot \\<sqinter> y * 1\" nitpick [expect=genuine,card=7] oops\n*)"], ["", "end"], ["", "text \\<open>M3-algebra\\<close>"], ["", "context up_closed_multirelation_algebra\nbegin"], ["", "lemma up_closed:\n  \"up_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed x", "by (simp add: up_closed_def)"], ["", "lemma dedekind_1_left:\n  \"x * 1 \\<sqinter> y \\<le> (x \\<sqinter> y * 1) * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a) \\<sqinter> y \\<le> (x \\<sqinter> y * (1::'a)) * (1::'a)", "by simp"], ["", "text \\<open>Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>zero-vector\\<close>"], ["", "lemma zero_vector_dual:\n  \"zero_vector x \\<longleftrightarrow> zero_vector (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = zero_vector (x\\<^sup>d)", "using up_closed_zero_vector_vector vector_dual vector_zero_vector up_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>up_closed ?x; zero_vector ?x\\<rbrakk> \\<Longrightarrow> vector ?x\n  vector ?x = vector (?x\\<^sup>d)\n  vector ?x \\<Longrightarrow> zero_vector ?x\n  up_closed ?x\n\ngoal (1 subgoal):\n 1. zero_vector x = zero_vector (x\\<^sup>d)", "by blast"], ["", "end"], ["", "text \\<open>complemented M0-algebra\\<close>"], ["", "class lattice_ordered_pre_left_semiring_b = lattice_ordered_pre_left_semiring + complemented_distributive_lattice\nbegin"], ["", "definition down_closed :: \"'a \\<Rightarrow> bool\" where \"down_closed x \\<equiv> -x * 1 \\<le> -x\""], ["", "text \\<open>Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>down-closed\\<close>"], ["", "lemma zero_down_closed:\n  \"down_closed bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. down_closed bot", "by (simp add: down_closed_def)"], ["", "lemma top_down_closed:\n  \"down_closed top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. down_closed top", "by (simp add: down_closed_def)"], ["", "lemma complement_down_closed_up_closed:\n  \"down_closed x \\<longleftrightarrow> up_closed (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. down_closed x = up_closed (- x)", "using down_closed_def order.antisym mult_sub_right_one up_closed_def"], ["proof (prove)\nusing this:\n  down_closed ?x \\<equiv> - ?x * (1::'a) \\<le> - ?x\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  ?x \\<le> ?x * (1::'a)\n  up_closed ?x \\<equiv> ?x * (1::'a) = ?x\n\ngoal (1 subgoal):\n 1. down_closed x = up_closed (- x)", "by auto"], ["", "lemma sup_down_closed:\n  \"down_closed x \\<Longrightarrow> down_closed y \\<Longrightarrow> down_closed (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>down_closed x; down_closed y\\<rbrakk>\n    \\<Longrightarrow> down_closed (x \\<squnion> y)", "by (simp add: complement_down_closed_up_closed inf_up_closed)"], ["", "lemma inf_down_closed:\n  \"down_closed x \\<Longrightarrow> down_closed y \\<Longrightarrow> down_closed (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>down_closed x; down_closed y\\<rbrakk>\n    \\<Longrightarrow> down_closed (x \\<sqinter> y)", "by (simp add: complement_down_closed_up_closed sup_up_closed)"], ["", "end"], ["", "class multirelation_algebra_1b = multirelation_algebra_1 + complemented_distributive_lattice\nbegin"], ["", "subclass lattice_ordered_pre_left_semiring_b"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.lattice_ordered_pre_left_semiring_b uminus (\\<sqinter>) (\\<le>)\n     (<) (\\<squnion>) bot top (1::'a) (*)", ".."], ["", "text \\<open>Theorem 7.1\\<close>"], ["", "lemma complement_mult_zero_sub:\n  \"-(x * bot) \\<le> -x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x * bot) \\<le> - x * bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (x * bot) \\<le> - x * bot", "have \"top = -x * bot \\<squnion> x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top = - x * bot \\<squnion> x * bot", "by (metis compl_sup_top mult_left_top mult_right_dist_sup)"], ["proof (state)\nthis:\n  top = - x * bot \\<squnion> x * bot\n\ngoal (1 subgoal):\n 1. - (x * bot) \\<le> - x * bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  top = - x * bot \\<squnion> x * bot\n\ngoal (1 subgoal):\n 1. - (x * bot) \\<le> - x * bot", "by (simp add: heyting.implies_order sup.commute)"], ["proof (state)\nthis:\n  - (x * bot) \\<le> - x * bot\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 7.2\\<close>"], ["", "lemma transitive_zero_vector_complement:\n  \"transitive x \\<Longrightarrow> zero_vector (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> zero_vector (- x)", "by (meson complement_mult_zero_sub compl_mono mult_right_isotone order_trans zero_vector_def bot_least)"], ["", "lemma transitive_dense_complement:\n  \"transitive x \\<Longrightarrow> dense_rel (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> dense_rel (- x)", "by (simp add: zero_vector_dense transitive_zero_vector_complement)"], ["", "lemma transitive_sup_distributive_complement:\n  \"transitive x \\<Longrightarrow> sup_distributive (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> sup_distributive (- x)", "by (simp add: zero_vector_sup_distributive transitive_zero_vector_complement)"], ["", "lemma transitive_inf_distributive_complement:\n  \"transitive x \\<Longrightarrow> inf_distributive (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> inf_distributive (- x)", "by (simp add: zero_vector_inf_distributive transitive_zero_vector_complement)"], ["", "lemma up_closed_zero_vector_complement:\n  \"up_closed x \\<Longrightarrow> zero_vector (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed x \\<Longrightarrow> zero_vector (- x)", "by (meson complement_mult_zero_sub compl_le_swap2 one_vector_def order_trans up_closed_one_vector zero_vector_def)"], ["", "lemma up_closed_dense_complement:\n  \"up_closed x \\<Longrightarrow> dense_rel (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed x \\<Longrightarrow> dense_rel (- x)", "by (simp add: zero_vector_dense up_closed_zero_vector_complement)"], ["", "lemma up_closed_sup_distributive_complement:\n  \"up_closed x \\<Longrightarrow> sup_distributive (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed x \\<Longrightarrow> sup_distributive (- x)", "by (simp add: zero_vector_sup_distributive up_closed_zero_vector_complement)"], ["", "lemma up_closed_inf_distributive_complement:\n  \"up_closed x \\<Longrightarrow> inf_distributive (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_closed x \\<Longrightarrow> inf_distributive (- x)", "by (simp add: zero_vector_inf_distributive up_closed_zero_vector_complement)"], ["", "text \\<open>Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>closure under complement\\<close>"], ["", "lemma co_total_total:\n  \"co_total x \\<Longrightarrow> total (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_total x \\<Longrightarrow> times_top_class.total (- x)", "by (metis complement_mult_zero_sub co_total_def compl_bot_eq mult_left_sub_dist_sup_right sup_bot_right top_le)"], ["", "lemma complement_one_vector_zero_vector:\n  \"one_vector x \\<Longrightarrow> zero_vector (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_vector x \\<Longrightarrow> zero_vector (- x)", "using compl_mono complement_mult_zero_sub one_vector_def order_trans zero_vector_def"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n  - (?x * bot) \\<le> - ?x * bot\n  one_vector ?x \\<equiv> ?x * bot \\<le> ?x\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  zero_vector ?x \\<equiv> ?x \\<le> ?x * bot\n\ngoal (1 subgoal):\n 1. one_vector x \\<Longrightarrow> zero_vector (- x)", "by blast"], ["", "text \\<open>Theorem 6 / Figure 2: relations between properties\\<close>"], ["", "lemma down_closed_zero_vector:\n  \"down_closed x \\<Longrightarrow> zero_vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. down_closed x \\<Longrightarrow> zero_vector x", "using complement_down_closed_up_closed up_closed_zero_vector_complement"], ["proof (prove)\nusing this:\n  down_closed ?x = up_closed (- ?x)\n  up_closed ?x \\<Longrightarrow> zero_vector (- ?x)\n\ngoal (1 subgoal):\n 1. down_closed x \\<Longrightarrow> zero_vector x", "by force"], ["", "lemma down_closed_one_vector_vector:\n  \"down_closed x \\<Longrightarrow> one_vector x \\<Longrightarrow> vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>down_closed x; one_vector x\\<rbrakk> \\<Longrightarrow> vector x", "by (simp add: down_closed_zero_vector zero_vector_one_vector_vector)"], ["", "(*\nlemma complement_vector: \"vector x \\<longrightarrow> vector (-x)\" nitpick [expect=genuine,card=8] oops\n*)"], ["", "end"], ["", "class multirelation_algebra_1c = multirelation_algebra_1b +\n  assumes dedekind_top_left: \"x * top \\<sqinter> y \\<le> (x \\<sqinter> y * top) * top\"\n  assumes comp_zero_inf: \"(x * bot \\<sqinter> y) * bot \\<le> (x \\<sqinter> y) * bot\"\nbegin"], ["", "text \\<open>Theorem 7.3\\<close>"], ["", "lemma schroeder_top_sub:\n  \"-(x * top) * top \\<le> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x * top) * top \\<le> - x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (x * top) * top \\<le> - x", "have \"-(x * top) * top \\<sqinter> x \\<le> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x * top) * top \\<sqinter> x \\<le> bot", "by (metis dedekind_top_left p_inf zero_vector)"], ["proof (state)\nthis:\n  - (x * top) * top \\<sqinter> x \\<le> bot\n\ngoal (1 subgoal):\n 1. - (x * top) * top \\<le> - x", "thus ?thesis"], ["proof (prove)\nusing this:\n  - (x * top) * top \\<sqinter> x \\<le> bot\n\ngoal (1 subgoal):\n 1. - (x * top) * top \\<le> - x", "by (simp add: shunting_1)"], ["proof (state)\nthis:\n  - (x * top) * top \\<le> - x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 7.4\\<close>"], ["", "lemma schroeder_top:\n  \"x * top \\<le> y \\<longleftrightarrow> -y * top \\<le> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * top \\<le> y) = (- y * top \\<le> - x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * top \\<le> y \\<Longrightarrow> - y * top \\<le> - x\n 2. - y * top \\<le> - x \\<Longrightarrow> x * top \\<le> y", "using compl_mono inf.order_trans mult_left_isotone schroeder_top_sub"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n  \\<lbrakk>?y \\<le> ?x; ?z \\<le> ?y\\<rbrakk> \\<Longrightarrow> ?z \\<le> ?x\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  - (?x * top) * top \\<le> - ?x\n\ngoal (2 subgoals):\n 1. x * top \\<le> y \\<Longrightarrow> - y * top \\<le> - x\n 2. - y * top \\<le> - x \\<Longrightarrow> x * top \\<le> y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. - y * top \\<le> - x \\<Longrightarrow> x * top \\<le> y", "by (metis compl_mono double_compl mult_left_isotone order_trans schroeder_top_sub)"], ["", "text \\<open>Theorem 7.5\\<close>"], ["", "lemma schroeder_top_eq:\n  \"-(x * top) * top = -(x * top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector (- (x * top))", "using vector_1 vector_mult_closed vector_top_closed schroeder_top"], ["proof (prove)\nusing this:\n  vector ?x = (?x * top \\<le> ?x)\n  vector ?y \\<Longrightarrow> vector (?x * ?y)\n  surjective top\n  (?x * top \\<le> ?y) = (- ?y * top \\<le> - ?x)\n\ngoal (1 subgoal):\n 1. vector (- (x * top))", "by auto"], ["", "lemma schroeder_one_eq:\n  \"-(x * top) * 1 = -(x * top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x * top) * (1::'a) = - (x * top)", "by (metis top_mult_right_one schroeder_top_eq)"], ["", "text \\<open>Theorem 7.6\\<close>"], ["", "lemma vector_inf_comp:\n  \"x * top \\<sqinter> y * z = (x * top \\<sqinter> y) * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter> y * z = (x * top \\<sqinter> y) * z", "proof (rule order.antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "have \"x * top \\<sqinter> y * z = x * top \\<sqinter> ((x * top \\<sqinter> y) \\<squnion> (-(x * top) \\<sqinter> y)) * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter> y * z =\n    x * top \\<sqinter>\n    (x * top \\<sqinter> y \\<squnion> - (x * top) \\<sqinter> y) * z", "by (simp add: inf_commute)"], ["proof (state)\nthis:\n  x * top \\<sqinter> y * z =\n  x * top \\<sqinter>\n  (x * top \\<sqinter> y \\<squnion> - (x * top) \\<sqinter> y) * z\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "also"], ["proof (state)\nthis:\n  x * top \\<sqinter> y * z =\n  x * top \\<sqinter>\n  (x * top \\<sqinter> y \\<squnion> - (x * top) \\<sqinter> y) * z\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "have \"... = x * top \\<sqinter> ((x * top \\<sqinter> y) * z \\<squnion> (-(x * top) \\<sqinter> y) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter>\n    (x * top \\<sqinter> y \\<squnion> - (x * top) \\<sqinter> y) * z =\n    x * top \\<sqinter>\n    ((x * top \\<sqinter> y) * z \\<squnion> (- (x * top) \\<sqinter> y) * z)", "by (simp add: inf_sup_distrib2 mult_right_dist_sup)"], ["proof (state)\nthis:\n  x * top \\<sqinter>\n  (x * top \\<sqinter> y \\<squnion> - (x * top) \\<sqinter> y) * z =\n  x * top \\<sqinter>\n  ((x * top \\<sqinter> y) * z \\<squnion> (- (x * top) \\<sqinter> y) * z)\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "also"], ["proof (state)\nthis:\n  x * top \\<sqinter>\n  (x * top \\<sqinter> y \\<squnion> - (x * top) \\<sqinter> y) * z =\n  x * top \\<sqinter>\n  ((x * top \\<sqinter> y) * z \\<squnion> (- (x * top) \\<sqinter> y) * z)\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "have \"... = (x * top \\<sqinter> (x * top \\<sqinter> y) * z) \\<squnion> (x * top \\<sqinter> (-(x * top) \\<sqinter> y) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter>\n    ((x * top \\<sqinter> y) * z \\<squnion> (- (x * top) \\<sqinter> y) * z) =\n    x * top \\<sqinter> (x * top \\<sqinter> y) * z \\<squnion>\n    x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z", "by (simp add: inf_sup_distrib1)"], ["proof (state)\nthis:\n  x * top \\<sqinter>\n  ((x * top \\<sqinter> y) * z \\<squnion> (- (x * top) \\<sqinter> y) * z) =\n  x * top \\<sqinter> (x * top \\<sqinter> y) * z \\<squnion>\n  x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "also"], ["proof (state)\nthis:\n  x * top \\<sqinter>\n  ((x * top \\<sqinter> y) * z \\<squnion> (- (x * top) \\<sqinter> y) * z) =\n  x * top \\<sqinter> (x * top \\<sqinter> y) * z \\<squnion>\n  x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "have \"... \\<le> (x * top \\<sqinter> y) * z \\<squnion> (x * top \\<sqinter> (-(x * top) \\<sqinter> y) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter> (x * top \\<sqinter> y) * z \\<squnion>\n    x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z\n    \\<le> (x * top \\<sqinter> y) * z \\<squnion>\n          x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z", "by (simp add: le_infI2)"], ["proof (state)\nthis:\n  x * top \\<sqinter> (x * top \\<sqinter> y) * z \\<squnion>\n  x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z\n  \\<le> (x * top \\<sqinter> y) * z \\<squnion>\n        x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "also"], ["proof (state)\nthis:\n  x * top \\<sqinter> (x * top \\<sqinter> y) * z \\<squnion>\n  x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z\n  \\<le> (x * top \\<sqinter> y) * z \\<squnion>\n        x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "have \"... \\<le> (x * top \\<sqinter> y) * z \\<squnion> (x * top \\<sqinter> -(x * top) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z \\<squnion>\n    x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z\n    \\<le> (x * top \\<sqinter> y) * z \\<squnion>\n          x * top \\<sqinter> - (x * top) * z", "by (metis inf.sup_left_isotone inf_commute mult_right_sub_dist_inf_left sup_right_isotone)"], ["proof (state)\nthis:\n  (x * top \\<sqinter> y) * z \\<squnion>\n  x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z\n  \\<le> (x * top \\<sqinter> y) * z \\<squnion>\n        x * top \\<sqinter> - (x * top) * z\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "also"], ["proof (state)\nthis:\n  (x * top \\<sqinter> y) * z \\<squnion>\n  x * top \\<sqinter> (- (x * top) \\<sqinter> y) * z\n  \\<le> (x * top \\<sqinter> y) * z \\<squnion>\n        x * top \\<sqinter> - (x * top) * z\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "have \"... \\<le> (x * top \\<sqinter> y) * z \\<squnion> (x * top \\<sqinter> -(x * top) * top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z \\<squnion> x * top \\<sqinter> - (x * top) * z\n    \\<le> (x * top \\<sqinter> y) * z \\<squnion>\n          x * top \\<sqinter> - (x * top) * top", "using inf.sup_right_isotone mult_right_isotone sup_right_isotone"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> ?z \\<sqinter> ?y \\<le> ?z \\<sqinter> ?x\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z \\<squnion> x * top \\<sqinter> - (x * top) * z\n    \\<le> (x * top \\<sqinter> y) * z \\<squnion>\n          x * top \\<sqinter> - (x * top) * top", "by auto"], ["proof (state)\nthis:\n  (x * top \\<sqinter> y) * z \\<squnion> x * top \\<sqinter> - (x * top) * z\n  \\<le> (x * top \\<sqinter> y) * z \\<squnion>\n        x * top \\<sqinter> - (x * top) * top\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "also"], ["proof (state)\nthis:\n  (x * top \\<sqinter> y) * z \\<squnion> x * top \\<sqinter> - (x * top) * z\n  \\<le> (x * top \\<sqinter> y) * z \\<squnion>\n        x * top \\<sqinter> - (x * top) * top\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "have \"... = (x * top \\<sqinter> y) * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z \\<squnion>\n    x * top \\<sqinter> - (x * top) * top =\n    (x * top \\<sqinter> y) * z", "by (simp add: schroeder_top_eq)"], ["proof (state)\nthis:\n  (x * top \\<sqinter> y) * z \\<squnion>\n  x * top \\<sqinter> - (x * top) * top =\n  (x * top \\<sqinter> y) * z\n\ngoal (2 subgoals):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n 2. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "finally"], ["proof (chain)\npicking this:\n  x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z", "show \"x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\""], ["proof (prove)\nusing this:\n  x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n\ngoal (1 subgoal):\n 1. x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z", "."], ["proof (state)\nthis:\n  x * top \\<sqinter> y * z \\<le> (x * top \\<sqinter> y) * z\n\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "show \"(x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z", "by (metis inf.bounded_iff mult_left_top mult_right_sub_dist_inf_left mult_right_sub_dist_inf_right mult_semi_associative order_lesseq_imp)"], ["proof (state)\nthis:\n  (x * top \\<sqinter> y) * z \\<le> x * top \\<sqinter> y * z\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma dedekind_top_left:\n  \"x * top \\<sqinter> y \\<le> (x \\<sqinter> y * top) * top\"\n  by (metis inf.commute top_right_mult_increasing vector_inf_comp)\n*)"], ["", "text \\<open>Theorem 7.7\\<close>"], ["", "lemma vector_zero_inf_comp:\n  \"(x * bot \\<sqinter> y) * z = x * bot \\<sqinter> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * bot \\<sqinter> y) * z = x * bot \\<sqinter> y * z", "by (metis vector_inf_comp vector_mult_closed zero_vector)"], ["", "lemma vector_zero_inf_comp_2:\n  \"(x * bot \\<sqinter> y) * z = (x * bot \\<sqinter> y * 1) * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * bot \\<sqinter> y) * z = (x * bot \\<sqinter> y * (1::'a)) * z", "by (simp add: vector_zero_inf_comp)"], ["", "text \\<open>Theorem 7.8\\<close>"], ["", "lemma comp_zero_inf_2:\n  \"x * bot \\<sqinter> y * bot = (x \\<sqinter> y) * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> y * bot = (x \\<sqinter> y) * bot", "using order.antisym mult_right_sub_dist_inf comp_zero_inf vector_zero_inf_comp"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  (?x \\<sqinter> ?y) * ?z \\<le> ?x * ?z \\<sqinter> ?y * ?z\n  (?x * bot \\<sqinter> ?y) * bot \\<le> (?x \\<sqinter> ?y) * bot\n  (?x * bot \\<sqinter> ?y) * ?z = ?x * bot \\<sqinter> ?y * ?z\n\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> y * bot = (x \\<sqinter> y) * bot", "by auto"], ["", "lemma comp_zero_inf_3:\n  \"x * bot \\<sqinter> y * bot = (x * bot \\<sqinter> y) * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> y * bot = (x * bot \\<sqinter> y) * bot", "by (simp add: vector_zero_inf_comp)"], ["", "lemma comp_zero_inf_4:\n  \"x * bot \\<sqinter> y * bot = (x * bot \\<sqinter> y * bot) * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> y * bot = (x * bot \\<sqinter> y * bot) * bot", "by (metis comp_zero_inf_2 inf.commute vector_zero_inf_comp)"], ["", "lemma comp_zero_inf_5:\n  \"x * bot \\<sqinter> y * bot = (x * 1 \\<sqinter> y * 1) * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> y * bot = (x * (1::'a) \\<sqinter> y * (1::'a)) * bot", "by (metis comp_zero_inf_2 mult_one_associative)"], ["", "lemma comp_zero_inf_6:\n  \"x * bot \\<sqinter> y * bot = (x * 1 \\<sqinter> y * bot) * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> y * bot = (x * (1::'a) \\<sqinter> y * bot) * bot", "using inf.sup_monoid.add_commute vector_zero_inf_comp"], ["proof (prove)\nusing this:\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  (?x * bot \\<sqinter> ?y) * ?z = ?x * bot \\<sqinter> ?y * ?z\n\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> y * bot = (x * (1::'a) \\<sqinter> y * bot) * bot", "by fastforce"], ["", "lemma comp_zero_inf_7:\n  \"x * bot \\<sqinter> y * bot = (x * 1 \\<sqinter> y) * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot \\<sqinter> y * bot = (x * (1::'a) \\<sqinter> y) * bot", "by (metis comp_zero_inf_2 mult_one_associative)"], ["", "text \\<open>Theorem 10 / Figure 3: closure properties\\<close>"], ["", "text \\<open>zero-vector\\<close>"], ["", "lemma inf_zero_vector:\n  \"zero_vector x \\<Longrightarrow> zero_vector y \\<Longrightarrow> zero_vector (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>zero_vector x; zero_vector y\\<rbrakk>\n    \\<Longrightarrow> zero_vector (x \\<sqinter> y)", "by (metis comp_zero_inf_2 inf.sup_mono zero_vector_def)"], ["", "text \\<open>down-closed\\<close>"], ["", "lemma comp_down_closed:\n  \"down_closed x \\<Longrightarrow> down_closed y \\<Longrightarrow> down_closed (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>down_closed x; down_closed y\\<rbrakk>\n    \\<Longrightarrow> down_closed (x * y)", "by (metis complement_down_closed_up_closed down_closed_zero_vector up_closed_def zero_vector_0 schroeder_one_eq)"], ["", "text \\<open>closure under complement\\<close>"], ["", "lemma complement_vector:\n  \"vector x \\<longleftrightarrow> vector (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = vector (- x)", "using vector_1 schroeder_top"], ["proof (prove)\nusing this:\n  vector ?x = (?x * top \\<le> ?x)\n  (?x * top \\<le> ?y) = (- ?y * top \\<le> - ?x)\n\ngoal (1 subgoal):\n 1. vector x = vector (- x)", "by blast"], ["", "lemma complement_zero_vector_one_vector:\n  \"zero_vector x \\<Longrightarrow> one_vector (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x \\<Longrightarrow> one_vector (- x)", "by (metis comp_zero_inf_2 order.antisym complement_mult_zero_sub double_compl inf.sup_monoid.add_commute mult_left_zero one_vector_def order.refl pseudo_complement top_right_mult_increasing zero_vector_0)"], ["", "lemma complement_zero_vector_one_vector_iff:\n  \"zero_vector x \\<longleftrightarrow> one_vector (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = one_vector (- x)", "using complement_zero_vector_one_vector complement_one_vector_zero_vector"], ["proof (prove)\nusing this:\n  zero_vector ?x \\<Longrightarrow> one_vector (- ?x)\n  one_vector ?x \\<Longrightarrow> zero_vector (- ?x)\n\ngoal (1 subgoal):\n 1. zero_vector x = one_vector (- x)", "by force"], ["", "lemma complement_one_vector_zero_vector_iff:\n  \"one_vector x \\<longleftrightarrow> zero_vector (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_vector x = zero_vector (- x)", "using complement_zero_vector_one_vector complement_one_vector_zero_vector"], ["proof (prove)\nusing this:\n  zero_vector ?x \\<Longrightarrow> one_vector (- ?x)\n  one_vector ?x \\<Longrightarrow> zero_vector (- ?x)\n\ngoal (1 subgoal):\n 1. one_vector x = zero_vector (- x)", "by force"], ["", "text \\<open>Theorem 6 / Figure 2: relations between properties\\<close>"], ["", "lemma vector_down_closed:\n  \"vector x \\<Longrightarrow> down_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> down_closed x", "using complement_vector complement_down_closed_up_closed vector_up_closed"], ["proof (prove)\nusing this:\n  vector ?x = vector (- ?x)\n  down_closed ?x = up_closed (- ?x)\n  vector ?x \\<Longrightarrow> up_closed ?x\n\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> down_closed x", "by blast"], ["", "lemma co_vector_down_closed:\n  \"co_vector x \\<Longrightarrow> down_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_vector x \\<Longrightarrow> down_closed x", "by (simp add: co_vector_vector vector_down_closed)"], ["", "lemma vector_down_closed_one_vector:\n  \"vector x \\<longleftrightarrow> down_closed x \\<and> one_vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = (down_closed x \\<and> one_vector x)", "using down_closed_one_vector_vector up_closed_one_vector vector_up_closed vector_down_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>down_closed ?x; one_vector ?x\\<rbrakk>\n  \\<Longrightarrow> vector ?x\n  up_closed ?x \\<Longrightarrow> one_vector ?x\n  vector ?x \\<Longrightarrow> up_closed ?x\n  vector ?x \\<Longrightarrow> down_closed ?x\n\ngoal (1 subgoal):\n 1. vector x = (down_closed x \\<and> one_vector x)", "by blast"], ["", "lemma vector_up_closed_down_closed:\n  \"vector x \\<longleftrightarrow> up_closed x \\<and> down_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = (up_closed x \\<and> down_closed x)", "using down_closed_zero_vector up_closed_zero_vector_vector vector_up_closed vector_down_closed"], ["proof (prove)\nusing this:\n  down_closed ?x \\<Longrightarrow> zero_vector ?x\n  \\<lbrakk>up_closed ?x; zero_vector ?x\\<rbrakk> \\<Longrightarrow> vector ?x\n  vector ?x \\<Longrightarrow> up_closed ?x\n  vector ?x \\<Longrightarrow> down_closed ?x\n\ngoal (1 subgoal):\n 1. vector x = (up_closed x \\<and> down_closed x)", "by blast"], ["", "text \\<open>Section 7\\<close>"], ["", "lemma vector_b1:\n  \"vector x \\<longleftrightarrow> -x * top = -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = vector (- x)", "using complement_vector"], ["proof (prove)\nusing this:\n  vector ?x = vector (- ?x)\n\ngoal (1 subgoal):\n 1. vector x = vector (- x)", "by auto"], ["", "lemma vector_b2:\n  \"vector x \\<longleftrightarrow> -x * bot = -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = (- x * bot = - x)", "by (metis down_closed_zero_vector vector_mult_closed zero_vector zero_vector_left_zero vector_b1 vector_down_closed)"], ["", "lemma covector_b1:\n  \"co_vector x \\<longleftrightarrow> -x * top = -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_vector x = vector (- x)", "using co_vector_def co_vector_vector vector_b1 vector_b2"], ["proof (prove)\nusing this:\n  co_vector ?x \\<equiv> ?x * bot = ?x\n  co_vector ?x \\<Longrightarrow> vector ?x\n  vector ?x = vector (- ?x)\n  vector ?x = (- ?x * bot = - ?x)\n\ngoal (1 subgoal):\n 1. co_vector x = vector (- x)", "by force"], ["", "lemma covector_b2:\n  \"co_vector x \\<longleftrightarrow> -x * bot = -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_vector x = (- x * bot = - x)", "using covector_b1 vector_b1 vector_b2"], ["proof (prove)\nusing this:\n  co_vector ?x = vector (- ?x)\n  vector ?x = vector (- ?x)\n  vector ?x = (- ?x * bot = - ?x)\n\ngoal (1 subgoal):\n 1. co_vector x = (- x * bot = - x)", "by auto"], ["", "lemma vector_co_vector_iff:\n  \"vector x \\<longleftrightarrow> co_vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x = co_vector x", "by (simp add: covector_b2 vector_b2)"], ["", "lemma zero_vector_b:\n  \"zero_vector x \\<longleftrightarrow> -x * bot \\<le> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = (- x * bot \\<le> - x)", "by (simp add: complement_zero_vector_one_vector_iff one_vector_def)"], ["", "lemma one_vector_b1:\n  \"one_vector x \\<longleftrightarrow> -x \\<le> -x * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_vector x = (- x \\<le> - x * bot)", "by (simp add: complement_one_vector_zero_vector_iff zero_vector_def)"], ["", "lemma one_vector_b0:\n  \"one_vector x \\<longleftrightarrow> (\\<forall>y z . -x * y = -x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_vector x = (\\<forall>y z. - x * y = - x * z)", "by (simp add: complement_one_vector_zero_vector_iff zero_vector_0)"], ["", "(*\nlemma schroeder_one: \"x * -1 \\<le> y \\<longleftrightarrow> -y * -1 \\<le> -x\" nitpick [expect=genuine,card=8] oops\n*)"], ["", "end"], ["", "class multirelation_algebra_2b = multirelation_algebra_2 + complemented_distributive_lattice\nbegin"], ["", "subclass multirelation_algebra_1b"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.multirelation_algebra_1b uminus (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) bot top (1::'a) (*)", ".."], ["", "(*\nlemma \"-x * bot \\<le> -(x * bot)\" nitpick [expect=genuine,card=8] oops\n*)"], ["", "end"], ["", "text \\<open>complemented M1-algebra\\<close>"], ["", "class multirelation_algebra_2c = multirelation_algebra_2b + multirelation_algebra_1c"], ["", "class multirelation_algebra_3b = multirelation_algebra_3 + complemented_distributive_lattice\nbegin"], ["", "subclass lattice_ordered_pre_left_semiring_b"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.lattice_ordered_pre_left_semiring_b uminus (\\<sqinter>) (\\<le>)\n     (<) (\\<squnion>) bot top (1::'a) (*)", ".."], ["", "lemma dual_complement_commute:\n  \"-(x\\<^sup>d) = (-x)\\<^sup>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x\\<^sup>d = (- x)\\<^sup>d", "by (metis compl_unique dual_dist_sup dual_dist_inf dual_top dual_zero inf_complement sup_compl_top)"], ["", "end"], ["", "text \\<open>complemented M2-algebra\\<close>"], ["", "class multirelation_algebra_5b = multirelation_algebra_5 + complemented_distributive_lattice\nbegin"], ["", "subclass multirelation_algebra_2b"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.multirelation_algebra_2b uminus (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) bot top (1::'a) (*)", ".."], ["", "subclass multirelation_algebra_3b"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.multirelation_algebra_3b uminus (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) bot top dual (1::'a) (*)", ".."], ["", "lemma dual_down_closed:\n  \"down_closed x \\<longleftrightarrow> down_closed (x\\<^sup>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. down_closed x = down_closed (x\\<^sup>d)", "using complement_down_closed_up_closed dual_complement_commute dual_up_closed"], ["proof (prove)\nusing this:\n  down_closed ?x = up_closed (- ?x)\n  - ?x\\<^sup>d = (- ?x)\\<^sup>d\n  up_closed ?x = up_closed (?x\\<^sup>d)\n\ngoal (1 subgoal):\n 1. down_closed x = down_closed (x\\<^sup>d)", "by auto"], ["", "end"], ["", "class multirelation_algebra_5c = multirelation_algebra_5b + multirelation_algebra_1c\nbegin"], ["", "lemma complement_mult_zero_below:\n  \"-x * bot \\<le> -(x * bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x * bot \\<le> - (x * bot)", "by (simp add: comp_zero_inf_2 shunting_1)"], ["", "(*\nlemma \"x * 1 \\<sqinter> y * 1 \\<le> (x \\<sqinter> y) * 1\" nitpick [expect=genuine,card=4] oops\nlemma \"x * 1 \\<sqinter> (y * 1) \\<le> (x * 1 \\<sqinter> y) * 1\" nitpick [expect=genuine,card=4] oops\n*)"], ["", "end"], ["", "class up_closed_multirelation_algebra_b = up_closed_multirelation_algebra + complemented_distributive_lattice\nbegin"], ["", "subclass multirelation_algebra_5c"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.multirelation_algebra_5c uminus (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) bot top (1::'a) (*) dual", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x * top \\<sqinter> y \\<le> (x \\<sqinter> y * top) * top\n 2. \\<And>x y. (x * bot \\<sqinter> y) * bot \\<le> (x \\<sqinter> y) * bot", "apply (metis inf.sup_monoid.add_commute top_right_mult_increasing vector_inf_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (x * bot \\<sqinter> y) * bot \\<le> (x \\<sqinter> y) * bot", "using mult_right_dist_inf vector_zero_inf_comp"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y) * ?z = ?x * ?z \\<sqinter> ?y * ?z\n  (?x * bot \\<sqinter> ?y) * ?z = ?x * bot \\<sqinter> ?y * ?z\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x * bot \\<sqinter> y) * bot \\<le> (x \\<sqinter> y) * bot", "by auto"], ["", "lemma complement_zero_vector:\n  \"zero_vector x \\<longleftrightarrow> zero_vector (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_vector x = zero_vector (- x)", "by (simp add: zero_right_mult_decreasing zero_vector_b)"], ["", "lemma down_closed:\n  \"down_closed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. down_closed x", "by (simp add: down_closed_def)"], ["", "lemma vector:\n  \"vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x", "by (simp add: down_closed up_closed_def vector_up_closed_down_closed)"], ["", "end"], ["", "end"]]}