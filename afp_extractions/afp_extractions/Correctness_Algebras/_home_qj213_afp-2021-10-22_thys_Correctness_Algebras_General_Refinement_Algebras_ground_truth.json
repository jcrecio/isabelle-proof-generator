{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/General_Refinement_Algebras.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma Omega_unfold_equal:\n  \"y\\<^sup>\\<Omega> = 1 \\<squnion> y * y\\<^sup>\\<Omega>\"", "lemma Omega_sup_1:\n  \"(x \\<squnion> y)\\<^sup>\\<Omega> = x\\<^sup>\\<Omega> * (y * x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>\"", "lemma Omega_left_slide:\n  \"(x * y)\\<^sup>\\<Omega> * x \\<le> x * (y * x)\\<^sup>\\<Omega>\"", "lemma star_below_Omega:\n  \"x\\<^sup>\\<star> \\<le> x\\<^sup>\\<Omega>\"", "lemma star_mult_Omega:\n  \"x\\<^sup>\\<Omega> = x\\<^sup>\\<star> * x\\<^sup>\\<Omega>\"", "lemma Omega_one_greatest:\n  \"x \\<le> 1\\<^sup>\\<Omega>\"", "lemma greatest_left_zero:\n  \"1\\<^sup>\\<Omega> * x = 1\\<^sup>\\<Omega>\"", "lemma Omega_one:\n  \"1\\<^sup>\\<Omega> = top\"", "lemma top_left_zero:\n  \"top * x = top\"", "lemma Omega_isolate_equal:\n  \"y\\<^sup>\\<Omega> = y\\<^sup>\\<Omega> * bot \\<squnion> y\\<^sup>\\<star>\"", "lemma Omega_mult:\n  \"(x * y)\\<^sup>\\<Omega> = 1 \\<squnion> x * (y * x)\\<^sup>\\<Omega> * y\"", "lemma Omega_sup:\n  \"(x \\<squnion> y)\\<^sup>\\<Omega> = (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\"", "lemma Omega_simulate:\n  \"z * x \\<le> y * z \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z\"", "lemma Omega_sum_unfold_1:\n  \"(x \\<squnion> y)\\<^sup>\\<Omega> = y\\<^sup>\\<Omega> \\<squnion> y\\<^sup>\\<star> * x * (x \\<squnion> y)\\<^sup>\\<Omega>\"", "lemma Omega_sup_3:\n  \"(x \\<squnion> y)\\<^sup>\\<Omega> = (x\\<^sup>\\<star> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\"", "lemma Omega_separate_2:\n  \"y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow> (x \\<squnion> y)\\<^sup>\\<Omega> = x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega>\"", "lemma Omega_circ_simulate_right_plus:\n  assumes \"z * x \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w\"\n    shows \"z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\"", "lemma Omega_circ_simulate_left_plus:\n  assumes \"x * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> w\"\n    shows \"x\\<^sup>\\<Omega> * z \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\"", "lemma Omega_circ_simulate_right:\n  assumes \"z * x \\<le> y * z \\<squnion> w\"\n    shows \"z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\"", "lemma Omega_one:\n  \"1\\<^sup>\\<Omega> = top\"", "lemma top_left_zero:\n  \"top * x = top\"", "lemma omega_left_zero_equal:\n  \"x\\<^sup>\\<omega> * y = x\\<^sup>\\<omega>\"", "lemma Omega_mult:\n  \"(x * y)\\<^sup>\\<Omega> = 1 \\<squnion> x * (y * x)\\<^sup>\\<Omega> * y\"", "lemma Omega_sup:\n  \"(x \\<squnion> y)\\<^sup>\\<Omega> = (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\"", "lemma Omega_simulate:\n  \"z * x \\<le> y * z \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z\""], "translations": [["", "lemma Omega_unfold_equal:\n  \"y\\<^sup>\\<Omega> = 1 \\<squnion> y * y\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<Omega> = Rf y (y\\<^sup>\\<Omega>)", "by (smt Omega_induct Omega_unfold sup_right_isotone order.antisym mult_right_isotone mult_1_right)"], ["", "lemma Omega_sup_1:\n  \"(x \\<squnion> y)\\<^sup>\\<Omega> = x\\<^sup>\\<Omega> * (y * x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega> =\n    x\\<^sup>\\<Omega> * (y * x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega>\n    \\<le> x\\<^sup>\\<Omega> * (y * x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>\n 2. x\\<^sup>\\<Omega> * (y * x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<Omega>", "apply (smt Omega_induct Omega_unfold_equal sup_assoc sup_commute sup_right_isotone mult_assoc mult_right_dist_sup mult_right_isotone mult_1_right order_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * (y * x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<Omega>", "by (smt Omega_induct Omega_unfold_equal sup_assoc sup_commute mult_assoc mult_left_one mult_right_dist_sup mult_1_right order_refl)"], ["", "lemma Omega_left_slide:\n  \"(x * y)\\<^sup>\\<Omega> * x \\<le> x * (y * x)\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<Omega> * x \\<le> x * (y * x)\\<^sup>\\<Omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<Omega> * x \\<le> x * (y * x)\\<^sup>\\<Omega>", "have \"1 \\<squnion> y * (x * y)\\<^sup>\\<Omega> * x \\<le> 1 \\<squnion> y * x * (1 \\<squnion> (y * (x * y)\\<^sup>\\<Omega>) * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rf (y * (x * y)\\<^sup>\\<Omega>) x\n    \\<le> Rf (y * x) (Rf (y * (x * y)\\<^sup>\\<Omega>) x)", "by (smt Omega_unfold_equal sup_right_isotone mult_assoc mult_left_one mult_left_sub_dist_sup mult_right_dist_sup mult_right_isotone mult_1_right)"], ["proof (state)\nthis:\n  Rf (y * (x * y)\\<^sup>\\<Omega>) x\n  \\<le> Rf (y * x) (Rf (y * (x * y)\\<^sup>\\<Omega>) x)\n\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<Omega> * x \\<le> x * (y * x)\\<^sup>\\<Omega>", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rf (y * (x * y)\\<^sup>\\<Omega>) x\n  \\<le> Rf (y * x) (Rf (y * (x * y)\\<^sup>\\<Omega>) x)\n\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<Omega> * x \\<le> x * (y * x)\\<^sup>\\<Omega>", "by (smt Omega_induct Omega_unfold_equal le_sup_iff mult_assoc mult_left_one mult_right_dist_sup mult_right_isotone mult_1_right)"], ["proof (state)\nthis:\n  (x * y)\\<^sup>\\<Omega> * x \\<le> x * (y * x)\\<^sup>\\<Omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>Theorem 50.3\\<close>"], ["", "sublocale general_refinement_algebra < Omega: left_conway_semiring where circ = Omega"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.left_conway_semiring Omega (1::'a) (*) (\\<squnion>) (\\<le>) (<)\n     bot", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. Rf x (x\\<^sup>\\<Omega>) = x\\<^sup>\\<Omega>\n 2. \\<And>x y. (x * y)\\<^sup>\\<Omega> * x \\<le> x * (y * x)\\<^sup>\\<Omega>\n 3. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<Omega> =\n       x\\<^sup>\\<Omega> * (y * x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>", "using Omega_unfold_equal"], ["proof (prove)\nusing this:\n  ?y\\<^sup>\\<Omega> = Rf ?y (?y\\<^sup>\\<Omega>)\n\ngoal (3 subgoals):\n 1. \\<And>x. Rf x (x\\<^sup>\\<Omega>) = x\\<^sup>\\<Omega>\n 2. \\<And>x y. (x * y)\\<^sup>\\<Omega> * x \\<le> x * (y * x)\\<^sup>\\<Omega>\n 3. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<Omega> =\n       x\\<^sup>\\<Omega> * (y * x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (x * y)\\<^sup>\\<Omega> * x \\<le> x * (y * x)\\<^sup>\\<Omega>\n 2. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<Omega> =\n       x\\<^sup>\\<Omega> * (y * x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>", "apply (simp add: Omega_left_slide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<Omega> =\n       x\\<^sup>\\<Omega> * (y * x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>", "by (simp add: Omega_sup_1)"], ["", "context general_refinement_algebra\nbegin"], ["", "lemma star_below_Omega:\n  \"x\\<^sup>\\<star> \\<le> x\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<le> x\\<^sup>\\<Omega>", "by (metis Omega_induct mult_1_right order_refl star.circ_left_unfold)"], ["", "lemma star_mult_Omega:\n  \"x\\<^sup>\\<Omega> = x\\<^sup>\\<star> * x\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> = x\\<^sup>\\<star> * x\\<^sup>\\<Omega>", "by (metis Omega.left_plus_below_circ sup_commute sup_ge1 order.eq_iff star.circ_loop_fixpoint star_left_induct_mult_iff)"], ["", "lemma Omega_one_greatest:\n  \"x \\<le> 1\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> (1::'a)\\<^sup>\\<Omega>", "by (metis Omega_induct sup_bot_left mult_left_one order_refl order_trans zero_right_mult_decreasing)"], ["", "lemma greatest_left_zero:\n  \"1\\<^sup>\\<Omega> * x = 1\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<Omega> * x = (1::'a)\\<^sup>\\<Omega>", "by (simp add: Omega_one_greatest Omega_induct order.antisym)"], ["", "(*\nlemma circ_right_unfold: \"1 \\<squnion> x\\<^sup>\\<Omega> * x = x\\<^sup>\\<Omega>\" nitpick [expect=genuine,card=8] oops\nlemma circ_slide: \"(x * y)\\<^sup>\\<Omega> * x = x * (y * x)\\<^sup>\\<Omega>\" nitpick [expect=genuine,card=6] oops\nlemma circ_simulate: \"z * x \\<le> y * z \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z\" nitpick [expect=genuine,card=6] oops\nlemma circ_simulate_right: \"z * x \\<le> y * z \\<squnion> w \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\" nitpick [expect=genuine,card=6] oops\nlemma circ_simulate_right_1: \"z * x \\<le> y * z \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z\" nitpick [expect=genuine,card=6] oops\nlemma circ_simulate_right_plus: \"z * x \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\" nitpick [expect=genuine,card=6] oops\nlemma circ_simulate_right_plus_1: \"z * x \\<le> y * y\\<^sup>\\<Omega> * z \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z\" nitpick [expect=genuine,card=6] oops\nlemma circ_simulate_left_1: \"x * z \\<le> z * y \\<Longrightarrow> x\\<^sup>\\<Omega> * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> x\\<^sup>\\<Omega> * bot\" oops (* holds in LKA, counterexample exists in GRA *)\nlemma circ_simulate_left_plus_1: \"x * z \\<le> z * y\\<^sup>\\<Omega> \\<Longrightarrow> x\\<^sup>\\<Omega> * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> x\\<^sup>\\<Omega> * bot\" oops (* holds in LKA, counterexample exists in GRA *)\nlemma circ_simulate_absorb: \"y * x \\<le> x \\<Longrightarrow> y\\<^sup>\\<Omega> * x \\<le> x \\<squnion> y\\<^sup>\\<Omega> * bot\" nitpick [expect=genuine,card=8] oops (* holds in LKA, counterexample exists in GRA *)\n*)"], ["", "end"], ["", "class bounded_general_refinement_algebra = general_refinement_algebra + bounded_left_kleene_algebra\nbegin"], ["", "lemma Omega_one:\n  \"1\\<^sup>\\<Omega> = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<Omega> = top", "by (simp add: Omega_one_greatest order.antisym)"], ["", "lemma top_left_zero:\n  \"top * x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective x", "using Omega_one greatest_left_zero"], ["proof (prove)\nusing this:\n  (1::'a)\\<^sup>\\<Omega> = top\n  (1::'a)\\<^sup>\\<Omega> * ?x = (1::'a)\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. surjective x", "by blast"], ["", "end"], ["", "sublocale bounded_general_refinement_algebra < Omega: bounded_left_conway_semiring where circ = Omega"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_left_conway_semiring Omega (1::'a) (*) (\\<squnion>)\n     (\\<le>) (<) bot top", ".."], ["", "class left_demonic_refinement_algebra = general_refinement_algebra +\n  assumes Omega_isolate: \"y\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * bot \\<squnion> y\\<^sup>\\<star>\"\nbegin"], ["", "lemma Omega_isolate_equal:\n  \"y\\<^sup>\\<Omega> = y\\<^sup>\\<Omega> * bot \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<Omega> = y\\<^sup>\\<Omega> * bot \\<squnion> y\\<^sup>\\<star>", "using Omega_isolate order.antisym le_sup_iff star_below_Omega zero_right_mult_decreasing"], ["proof (prove)\nusing this:\n  ?y\\<^sup>\\<Omega>\n  \\<le> ?y\\<^sup>\\<Omega> * bot \\<squnion> ?y\\<^sup>\\<star>\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  (?x \\<squnion> ?y \\<le> ?z) = (?x \\<le> ?z \\<and> ?y \\<le> ?z)\n  ?x\\<^sup>\\<star> \\<le> ?x\\<^sup>\\<Omega>\n  ?x * bot \\<le> ?x\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<Omega> = y\\<^sup>\\<Omega> * bot \\<squnion> y\\<^sup>\\<star>", "by auto"], ["", "(*\nlemma Omega_sum_unfold_1: \"(x \\<squnion> y)\\<^sup>\\<Omega> = y\\<^sup>\\<Omega> \\<squnion> y\\<^sup>\\<star> * x * (x \\<squnion> y)\\<^sup>\\<Omega>\" oops\nlemma Omega_sup_3: \"(x \\<squnion> y)\\<^sup>\\<Omega> = (x\\<^sup>\\<star> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\" oops\n*)"], ["", "end"], ["", "class bounded_left_demonic_refinement_algebra = left_demonic_refinement_algebra + bounded_left_kleene_algebra\nbegin"], ["", "(*\nlemma Omega_mult: \"(x * y)\\<^sup>\\<Omega> = 1 \\<squnion> x * (y * x)\\<^sup>\\<Omega> * y\" oops\nlemma Omega_sup: \"(x \\<squnion> y)\\<^sup>\\<Omega> = (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\" oops\nlemma Omega_simulate: \"z * x \\<le> y * z \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z\" nitpick [expect=genuine,card=6] oops\nlemma Omega_separate_2: \"y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow> (x \\<squnion> y)\\<^sup>\\<Omega> = x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega>\" oops\nlemma Omega_circ_simulate_right_plus: \"z * x \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\" nitpick [expect=genuine,card=6] oops\nlemma Omega_circ_simulate_left_plus: \"x * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> w \\<Longrightarrow> x\\<^sup>\\<Omega> * z \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\" oops\n*)"], ["", "end"], ["", "sublocale bounded_left_demonic_refinement_algebra < Omega: bounded_left_conway_semiring where circ = Omega"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_left_conway_semiring Omega (1::'a) (*) (\\<squnion>)\n     (\\<le>) (<) bot top", ".."], ["", "class demonic_refinement_algebra = left_zero_kleene_algebra + left_demonic_refinement_algebra\nbegin"], ["", "lemma Omega_mult:\n  \"(x * y)\\<^sup>\\<Omega> = 1 \\<squnion> x * (y * x)\\<^sup>\\<Omega> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<Omega> = Rf (x * (y * x)\\<^sup>\\<Omega>) y", "by (smt (verit, del_insts) Omega.circ_left_slide Omega_induct Omega_unfold_equal order.eq_iff mult_assoc mult_left_dist_sup mult_1_right)"], ["", "lemma Omega_sup:\n  \"(x \\<squnion> y)\\<^sup>\\<Omega> = (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega> =\n    (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>", "by (smt Omega_sup_1 Omega_mult mult_assoc mult_left_dist_sup mult_left_one mult_right_dist_sup mult_1_right)"], ["", "lemma Omega_simulate:\n  \"z * x \\<le> y * z \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x \\<le> y * z \\<Longrightarrow>\n    z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z", "by (smt Omega_induct Omega_unfold_equal sup_right_isotone mult_assoc mult_left_dist_sup mult_left_isotone mult_1_right)"], ["", "end"], ["", "text \\<open>Theorem 2.4\\<close>"], ["", "sublocale demonic_refinement_algebra < Omega1: itering_1 where circ = Omega"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.itering_1 Omega (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x * (y * x)\\<^sup>\\<Omega> \\<le> (x * y)\\<^sup>\\<Omega> * x\n 2. \\<And>z x y.\n       z * x \\<le> y * z \\<longrightarrow>\n       z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z", "apply (simp add: Omega_simulate mult_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z x y.\n       z * x \\<le> y * z \\<longrightarrow>\n       z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z", "by (simp add: Omega_simulate)"], ["", "sublocale demonic_refinement_algebra < Omega1: left_zero_conway_semiring_1 where circ = Omega"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.left_zero_conway_semiring_1 Omega (1::'a) (*) (\\<squnion>) (\\<le>)\n     (<) bot", ".."], ["", "context demonic_refinement_algebra\nbegin"], ["", "lemma Omega_sum_unfold_1:\n  \"(x \\<squnion> y)\\<^sup>\\<Omega> = y\\<^sup>\\<Omega> \\<squnion> y\\<^sup>\\<star> * x * (x \\<squnion> y)\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega> =\n    y\\<^sup>\\<Omega> \\<squnion>\n    y\\<^sup>\\<star> * x * (x \\<squnion> y)\\<^sup>\\<Omega>", "by (smt Omega1.circ_sup_9 Omega.circ_loop_fixpoint Omega_isolate_equal sup_assoc sup_commute mult_assoc mult_left_zero mult_right_dist_sup)"], ["", "lemma Omega_sup_3:\n  \"(x \\<squnion> y)\\<^sup>\\<Omega> = (x\\<^sup>\\<star> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega> =\n    (x\\<^sup>\\<star> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega>\n    \\<le> (x\\<^sup>\\<star> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\n 2. (x\\<^sup>\\<star> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<Omega>", "apply (metis Omega_sum_unfold_1 Omega_induct eq_refl sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<star> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<Omega>", "by (simp add: Omega.circ_isotone Omega_sup mult_left_isotone star_below_Omega)"], ["", "lemma Omega_separate_2:\n  \"y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow> (x \\<squnion> y)\\<^sup>\\<Omega> = x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow>\n    (x \\<squnion> y)\\<^sup>\\<Omega> = x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega>", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow>\n    (x \\<squnion> y)\\<^sup>\\<Omega>\n    \\<le> x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega>\n 2. y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow>\n    x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<Omega>", "apply (smt (verit, del_insts) Omega_induct Omega_sum_unfold_1 sup_right_isotone mult_assoc mult_left_isotone star_mult_Omega star_simulation_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<le> x * (x \\<squnion> y) \\<Longrightarrow>\n    x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega>\n    \\<le> (x \\<squnion> y)\\<^sup>\\<Omega>", "by (simp add: Omega.circ_sub_dist_3)"], ["", "lemma Omega_circ_simulate_right_plus:\n  assumes \"z * x \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w\"\n    shows \"z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "have \"z * x\\<^sup>\\<Omega> = z \\<squnion> z * x * x\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega> = z \\<squnion> z * x * x\\<^sup>\\<Omega>", "using Omega1.circ_back_loop_fixpoint Omega1.circ_plus_same sup_commute mult_assoc"], ["proof (prove)\nusing this:\n  ?z * ?y\\<^sup>\\<Omega> * ?y \\<squnion> ?z = ?z * ?y\\<^sup>\\<Omega>\n  ?x\\<^sup>\\<Omega> * ?x = ?x * ?x\\<^sup>\\<Omega>\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega> = z \\<squnion> z * x * x\\<^sup>\\<Omega>", "by auto"], ["proof (state)\nthis:\n  z * x\\<^sup>\\<Omega> = z \\<squnion> z * x * x\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "also"], ["proof (state)\nthis:\n  z * x\\<^sup>\\<Omega> = z \\<squnion> z * x * x\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "have \"... \\<le> y * y\\<^sup>\\<Omega> * z * x\\<^sup>\\<Omega> \\<squnion> z \\<squnion> w * x\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<squnion> z * x * x\\<^sup>\\<Omega>\n    \\<le> y * y\\<^sup>\\<Omega> * z * x\\<^sup>\\<Omega> \\<squnion>\n          z \\<squnion>\n          w * x\\<^sup>\\<Omega>", "by (smt assms sup_assoc sup_commute sup_right_isotone le_iff_sup mult_right_dist_sup)"], ["proof (state)\nthis:\n  z \\<squnion> z * x * x\\<^sup>\\<Omega>\n  \\<le> y * y\\<^sup>\\<Omega> * z * x\\<^sup>\\<Omega> \\<squnion> z \\<squnion>\n        w * x\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "finally"], ["proof (chain)\npicking this:\n  z * x\\<^sup>\\<Omega>\n  \\<le> y * y\\<^sup>\\<Omega> * z * x\\<^sup>\\<Omega> \\<squnion> z \\<squnion>\n        w * x\\<^sup>\\<Omega>", "have \"z * x\\<^sup>\\<Omega> \\<le> (y * y\\<^sup>\\<Omega>)\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\""], ["proof (prove)\nusing this:\n  z * x\\<^sup>\\<Omega>\n  \\<le> y * y\\<^sup>\\<Omega> * z * x\\<^sup>\\<Omega> \\<squnion> z \\<squnion>\n        w * x\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> (y * y\\<^sup>\\<Omega>)\\<^sup>\\<Omega> *\n          (z \\<squnion> w * x\\<^sup>\\<Omega>)", "by (smt Omega_induct sup_assoc sup_commute mult_assoc)"], ["proof (state)\nthis:\n  z * x\\<^sup>\\<Omega>\n  \\<le> (y * y\\<^sup>\\<Omega>)\\<^sup>\\<Omega> *\n        (z \\<squnion> w * x\\<^sup>\\<Omega>)\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  z * x\\<^sup>\\<Omega>\n  \\<le> (y * y\\<^sup>\\<Omega>)\\<^sup>\\<Omega> *\n        (z \\<squnion> w * x\\<^sup>\\<Omega>)\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "by (simp add: Omega.left_plus_circ)"], ["proof (state)\nthis:\n  z * x\\<^sup>\\<Omega>\n  \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Omega_circ_simulate_left_plus:\n  assumes \"x * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> w\"\n    shows \"x\\<^sup>\\<Omega> * z \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "have \"x * ((z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>) \\<le> (z * y\\<^sup>\\<Omega> \\<squnion> w \\<squnion> x * x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * ((z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>)\n    \\<le> (z * y\\<^sup>\\<Omega> \\<squnion> w \\<squnion>\n           x * x\\<^sup>\\<Omega> * w) *\n          y\\<^sup>\\<Omega>", "by (smt assms mult_assoc mult_left_dist_sup sup_left_isotone mult_left_isotone)"], ["proof (state)\nthis:\n  x * ((z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>)\n  \\<le> (z * y\\<^sup>\\<Omega> \\<squnion> w \\<squnion>\n         x * x\\<^sup>\\<Omega> * w) *\n        y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "also"], ["proof (state)\nthis:\n  x * ((z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>)\n  \\<le> (z * y\\<^sup>\\<Omega> \\<squnion> w \\<squnion>\n         x * x\\<^sup>\\<Omega> * w) *\n        y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "have \"... \\<le> z * y\\<^sup>\\<Omega> * y\\<^sup>\\<Omega> \\<squnion> w * y\\<^sup>\\<Omega> \\<squnion> x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z * y\\<^sup>\\<Omega> \\<squnion> w \\<squnion>\n     x * x\\<^sup>\\<Omega> * w) *\n    y\\<^sup>\\<Omega>\n    \\<le> z * y\\<^sup>\\<Omega> * y\\<^sup>\\<Omega> \\<squnion>\n          w * y\\<^sup>\\<Omega> \\<squnion>\n          x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega>", "by (smt Omega.left_plus_below_circ sup_right_isotone mult_left_isotone mult_right_dist_sup)"], ["proof (state)\nthis:\n  (z * y\\<^sup>\\<Omega> \\<squnion> w \\<squnion> x * x\\<^sup>\\<Omega> * w) *\n  y\\<^sup>\\<Omega>\n  \\<le> z * y\\<^sup>\\<Omega> * y\\<^sup>\\<Omega> \\<squnion>\n        w * y\\<^sup>\\<Omega> \\<squnion>\n        x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "finally"], ["proof (chain)\npicking this:\n  x * ((z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>)\n  \\<le> z * y\\<^sup>\\<Omega> * y\\<^sup>\\<Omega> \\<squnion>\n        w * y\\<^sup>\\<Omega> \\<squnion>\n        x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega>", "have 1: \"x * ((z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>) \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\""], ["proof (prove)\nusing this:\n  x * ((z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>)\n  \\<le> z * y\\<^sup>\\<Omega> * y\\<^sup>\\<Omega> \\<squnion>\n        w * y\\<^sup>\\<Omega> \\<squnion>\n        x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. x * ((z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>)\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "by (metis Omega.circ_transitive_equal mult_assoc Omega.circ_reflexive sup_assoc le_iff_sup mult_left_one mult_right_dist_sup)"], ["proof (state)\nthis:\n  x * ((z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>)\n  \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "have \"x\\<^sup>\\<Omega> * z  = x\\<^sup>\\<Omega> * bot \\<squnion> x\\<^sup>\\<star> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z =\n    x\\<^sup>\\<Omega> * bot \\<squnion> x\\<^sup>\\<star> * z", "by (metis Omega_isolate_equal mult_assoc mult_left_zero mult_right_dist_sup)"], ["proof (state)\nthis:\n  x\\<^sup>\\<Omega> * z =\n  x\\<^sup>\\<Omega> * bot \\<squnion> x\\<^sup>\\<star> * z\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<Omega> * z =\n  x\\<^sup>\\<Omega> * bot \\<squnion> x\\<^sup>\\<star> * z\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "have \"... \\<le> x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega> \\<squnion> x\\<^sup>\\<star> * (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * bot \\<squnion> x\\<^sup>\\<star> * z\n    \\<le> x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega> \\<squnion>\n          x\\<^sup>\\<star> * (z \\<squnion> x\\<^sup>\\<Omega> * w) *\n          y\\<^sup>\\<Omega>", "by (metis Omega1.circ_back_loop_fixpoint bot_least idempotent_bot_closed le_supI2 mult_isotone mult_left_sub_dist_sup_left semiring.add_mono zero_right_mult_decreasing mult_assoc)"], ["proof (state)\nthis:\n  x\\<^sup>\\<Omega> * bot \\<squnion> x\\<^sup>\\<star> * z\n  \\<le> x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega> \\<squnion>\n        x\\<^sup>\\<star> * (z \\<squnion> x\\<^sup>\\<Omega> * w) *\n        y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "also"], ["proof (state)\nthis:\n  x\\<^sup>\\<Omega> * bot \\<squnion> x\\<^sup>\\<star> * z\n  \\<le> x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega> \\<squnion>\n        x\\<^sup>\\<star> * (z \\<squnion> x\\<^sup>\\<Omega> * w) *\n        y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "have \"... \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega> \\<squnion>\n    x\\<^sup>\\<star> * (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "using 1"], ["proof (prove)\nusing this:\n  x * ((z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>)\n  \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega> \\<squnion>\n    x\\<^sup>\\<star> * (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "by (metis le_supI mult_right_sub_dist_sup_right star_left_induct_mult mult_assoc)"], ["proof (state)\nthis:\n  x\\<^sup>\\<Omega> * w * y\\<^sup>\\<Omega> \\<squnion>\n  x\\<^sup>\\<star> * (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\n  \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>\\<Omega> * z\n  \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "show ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>\\<Omega> * z\n  \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<Omega> * z\n    \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "."], ["proof (state)\nthis:\n  x\\<^sup>\\<Omega> * z\n  \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Omega_circ_simulate_right:\n  assumes \"z * x \\<le> y * z \\<squnion> w\"\n    shows \"z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "have \"y * z \\<squnion> w \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * z \\<squnion> w \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w", "using Omega.circ_mult_increasing mult_left_isotone sup_left_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x * ?x\\<^sup>\\<Omega>\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> ?z \\<le> ?y \\<squnion> ?z\n\ngoal (1 subgoal):\n 1. y * z \\<squnion> w \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w", "by auto"], ["proof (state)\nthis:\n  y * z \\<squnion> w \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y * z \\<squnion> w \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "using Omega_circ_simulate_right_plus assms order.trans"], ["proof (prove)\nusing this:\n  y * z \\<squnion> w \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w\n  ?z * ?x \\<le> ?y * ?y\\<^sup>\\<Omega> * ?z \\<squnion> ?w \\<Longrightarrow>\n  ?z * ?x\\<^sup>\\<Omega>\n  \\<le> ?y\\<^sup>\\<Omega> * (?z \\<squnion> ?w * ?x\\<^sup>\\<Omega>)\n  z * x \\<le> y * z \\<squnion> w\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. z * x\\<^sup>\\<Omega>\n    \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)", "by blast"], ["proof (state)\nthis:\n  z * x\\<^sup>\\<Omega>\n  \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale demonic_refinement_algebra < Omega: itering where circ = Omega"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.itering Omega (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       (x \\<squnion> y)\\<^sup>\\<Omega> =\n       (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\n 2. \\<And>x y. (x * y)\\<^sup>\\<Omega> = Rf (x * (y * x)\\<^sup>\\<Omega>) y\n 3. \\<And>z x y w.\n       z * x \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<Omega>\n       \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\n 4. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<Omega> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "apply (simp add: Omega_sup)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. (x * y)\\<^sup>\\<Omega> = Rf (x * (y * x)\\<^sup>\\<Omega>) y\n 2. \\<And>z x y w.\n       z * x \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<Omega>\n       \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\n 3. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<Omega> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "using Omega_mult"], ["proof (prove)\nusing this:\n  (?x * ?y)\\<^sup>\\<Omega> = Rf (?x * (?y * ?x)\\<^sup>\\<Omega>) ?y\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x * y)\\<^sup>\\<Omega> = Rf (x * (y * x)\\<^sup>\\<Omega>) y\n 2. \\<And>z x y w.\n       z * x \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<Omega>\n       \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\n 3. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<Omega> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z x y w.\n       z * x \\<le> y * y\\<^sup>\\<Omega> * z \\<squnion> w \\<longrightarrow>\n       z * x\\<^sup>\\<Omega>\n       \\<le> y\\<^sup>\\<Omega> * (z \\<squnion> w * x\\<^sup>\\<Omega>)\n 2. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<Omega> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "apply (simp add: Omega_circ_simulate_right_plus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<Omega> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "using Omega_circ_simulate_left_plus"], ["proof (prove)\nusing this:\n  ?x * ?z \\<le> ?z * ?y\\<^sup>\\<Omega> \\<squnion> ?w \\<Longrightarrow>\n  ?x\\<^sup>\\<Omega> * ?z\n  \\<le> (?z \\<squnion> ?x\\<^sup>\\<Omega> * ?w) * ?y\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>x z y w.\n       x * z \\<le> z * y\\<^sup>\\<Omega> \\<squnion> w \\<longrightarrow>\n       x\\<^sup>\\<Omega> * z\n       \\<le> (z \\<squnion> x\\<^sup>\\<Omega> * w) * y\\<^sup>\\<Omega>", "by auto"], ["", "class bounded_demonic_refinement_algebra = demonic_refinement_algebra + bounded_left_zero_kleene_algebra\nbegin"], ["", "lemma Omega_one:\n  \"1\\<^sup>\\<Omega> = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a)\\<^sup>\\<Omega> = top", "by (simp add: Omega_one_greatest order.antisym)"], ["", "lemma top_left_zero:\n  \"top * x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective x", "using Omega_one greatest_left_zero"], ["proof (prove)\nusing this:\n  (1::'a)\\<^sup>\\<Omega> = top\n  (1::'a)\\<^sup>\\<Omega> * ?x = (1::'a)\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. surjective x", "by auto"], ["", "end"], ["", "sublocale bounded_demonic_refinement_algebra < Omega: bounded_itering where circ = Omega"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_itering Omega (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot top", ".."], ["", "class general_refinement_algebra_omega = left_omega_algebra + Omega +\n  assumes omega_left_zero: \"x\\<^sup>\\<omega> \\<le> x\\<^sup>\\<omega> * y\"\n  assumes Omega_def: \"x\\<^sup>\\<Omega> = x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star>\"\nbegin"], ["", "lemma omega_left_zero_equal:\n  \"x\\<^sup>\\<omega> * y = x\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<omega> * y = x\\<^sup>\\<omega>", "by (simp add: order.antisym omega_left_zero omega_sub_vector)"], ["", "subclass left_demonic_refinement_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.left_demonic_refinement_algebra star (1::'a) (*) (\\<squnion>)\n     (\\<le>) (<) bot Omega", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y. y\\<^sup>\\<Omega> \\<le> Rf y (y\\<^sup>\\<Omega>)\n 2. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<Omega> * z\n 3. \\<And>y.\n       y\\<^sup>\\<Omega>\n       \\<le> y\\<^sup>\\<Omega> * bot \\<squnion> y\\<^sup>\\<star>", "apply (metis Omega_def sup_commute eq_refl mult_1_right omega_loop_fixpoint)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x z y.\n       x \\<le> z \\<squnion> y * x \\<longrightarrow>\n       x \\<le> y\\<^sup>\\<Omega> * z\n 2. \\<And>y.\n       y\\<^sup>\\<Omega>\n       \\<le> y\\<^sup>\\<Omega> * bot \\<squnion> y\\<^sup>\\<star>", "apply (metis Omega_def mult_right_dist_sup omega_induct omega_left_zero_equal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y\\<^sup>\\<Omega>\n       \\<le> y\\<^sup>\\<Omega> * bot \\<squnion> y\\<^sup>\\<star>", "by (metis Omega_def mult_right_sub_dist_sup_right sup_commute sup_right_isotone omega_left_zero_equal)"], ["", "end"], ["", "class left_demonic_refinement_algebra_omega = bounded_left_omega_algebra + Omega +\n  assumes top_left_zero: \"top * x = top\"\n  assumes Omega_def: \"x\\<^sup>\\<Omega> = x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star>\"\nbegin"], ["", "subclass general_refinement_algebra_omega"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.general_refinement_algebra_omega Omega star (1::'a) (*)\n     (\\<squnion>) (\\<le>) (<) bot omega", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x\\<^sup>\\<omega> \\<le> x\\<^sup>\\<omega> * y\n 2. \\<And>x. x\\<^sup>\\<Omega> = x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star>", "apply (metis mult_assoc omega_vector order_refl top_left_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>\\<Omega> = x\\<^sup>\\<omega> \\<squnion> x\\<^sup>\\<star>", "by (rule Omega_def)"], ["", "end"], ["", "class demonic_refinement_algebra_omega = left_demonic_refinement_algebra_omega + bounded_left_zero_omega_algebra\nbegin"], ["", "lemma Omega_mult:\n  \"(x * y)\\<^sup>\\<Omega> = 1 \\<squnion> x * (y * x)\\<^sup>\\<Omega> * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>\\<Omega> = Rf (x * (y * x)\\<^sup>\\<Omega>) y", "by (metis Omega_def comb1.circ_mult_1 omega_left_zero_equal omega_translate)"], ["", "lemma Omega_sup:\n  \"(x \\<squnion> y)\\<^sup>\\<Omega> = (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega> =\n    (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega> =\n    (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>", "have \"(x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega> = (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<omega> \\<squnion> (x\\<^sup>\\<star> * y)\\<^sup>\\<omega> \\<squnion> (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<omega>\\<^sup>\\<star> * x\\<^sup>\\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega> =\n    (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<omega> \\<squnion>\n    (x\\<^sup>\\<star> * y)\\<^sup>\\<omega> \\<squnion>\n    (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<omega>\\<^sup>\\<star> *\n    x\\<^sup>\\<Omega>", "by (smt sup_commute Omega_def mult_assoc mult_right_dist_sup mult_bot_add_omega omega_left_zero_equal star.circ_sup_1)"], ["proof (state)\nthis:\n  (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega> =\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<omega> \\<squnion>\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<omega> \\<squnion>\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<omega>\\<^sup>\\<star> *\n  x\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega> =\n    (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega> =\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<omega> \\<squnion>\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<omega> \\<squnion>\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<omega>\\<^sup>\\<star> *\n  x\\<^sup>\\<Omega>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega> =\n    (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>", "using Omega_def Omega_sup_1 comb2.circ_slide_1 omega_left_zero_equal"], ["proof (prove)\nusing this:\n  (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega> =\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<omega> \\<squnion>\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<omega> \\<squnion>\n  (x\\<^sup>\\<star> * y)\\<^sup>\\<star> * x\\<^sup>\\<omega>\\<^sup>\\<star> *\n  x\\<^sup>\\<Omega>\n  ?x\\<^sup>\\<Omega> = ?x\\<^sup>\\<omega> \\<squnion> ?x\\<^sup>\\<star>\n  (?x \\<squnion> ?y)\\<^sup>\\<Omega> =\n  ?x\\<^sup>\\<Omega> * (?y * ?x\\<^sup>\\<Omega>)\\<^sup>\\<Omega>\n  ?x * ((?y * ?x)\\<^sup>\\<omega> * bot \\<squnion> (?y * ?x)\\<^sup>\\<star>) =\n  ((?x * ?y)\\<^sup>\\<omega> * bot \\<squnion> (?x * ?y)\\<^sup>\\<star>) * ?x\n  ?x\\<^sup>\\<omega> * ?y = ?x\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>\\<Omega> =\n    (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>", "by auto"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>\\<Omega> =\n  (x\\<^sup>\\<Omega> * y)\\<^sup>\\<Omega> * x\\<^sup>\\<Omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Omega_simulate:\n  \"z * x \\<le> y * z \\<Longrightarrow> z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * x \\<le> y * z \\<Longrightarrow>\n    z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z", "using Omega_def comb2.circ_simulate omega_left_zero_equal"], ["proof (prove)\nusing this:\n  ?x\\<^sup>\\<Omega> = ?x\\<^sup>\\<omega> \\<squnion> ?x\\<^sup>\\<star>\n  ?z * ?x \\<le> ?y * ?z \\<longrightarrow>\n  ?z * (?x\\<^sup>\\<omega> * bot \\<squnion> ?x\\<^sup>\\<star>)\n  \\<le> (?y\\<^sup>\\<omega> * bot \\<squnion> ?y\\<^sup>\\<star>) * ?z\n  ?x\\<^sup>\\<omega> * ?y = ?x\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. z * x \\<le> y * z \\<Longrightarrow>\n    z * x\\<^sup>\\<Omega> \\<le> y\\<^sup>\\<Omega> * z", "by auto"], ["", "subclass demonic_refinement_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.demonic_refinement_algebra star (1::'a) (*) (\\<squnion>) (\\<le>)\n     (<) bot Omega", ".."], ["", "end"], ["", "(*\ntext hold in GRA and LKA\nlemma circ_circ_mult: \"1\\<^sup>\\<Omega> * x\\<^sup>\\<Omega> = x\\<^sup>\\<Omega>\\<^sup>\\<Omega>\" oops\nlemma sub_mult_one_circ: \"x * 1\\<^sup>\\<Omega> \\<le> 1\\<^sup>\\<Omega> * x\" oops\nlemma circ_circ_mult_1: \"x\\<^sup>\\<Omega> * 1\\<^sup>\\<Omega> = x\\<^sup>\\<Omega>\\<^sup>\\<Omega>\" oops\nlemma \"y * x \\<le> x \\<Longrightarrow> y\\<^sup>\\<circ> * x \\<le> 1\\<^sup>\\<circ> * x\" oops\n\ntext unknown\nlemma circ_simulate_2: \"y * x\\<^sup>\\<Omega> \\<le> x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega> \\<longleftrightarrow> y\\<^sup>\\<Omega> * x\\<^sup>\\<Omega> \\<le> x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega>\" oops (* holds in LKA *)\nlemma circ_simulate_3: \"y * x\\<^sup>\\<Omega> \\<le> x\\<^sup>\\<Omega> \\<Longrightarrow> y\\<^sup>\\<Omega> * x\\<^sup>\\<Omega> \\<le> x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega>\" oops (* holds in LKA *)\nlemma circ_separate_mult_1: \"y * x \\<le> x * y \\<Longrightarrow> (x * y)\\<^sup>\\<Omega> \\<le> x\\<^sup>\\<Omega> * y\\<^sup>\\<Omega>\" oops\nlemma \"x\\<^sup>\\<circ> = (x * x)\\<^sup>\\<circ> * (x \\<squnion> 1)\" oops\nlemma \"y\\<^sup>\\<circ> * x\\<^sup>\\<circ> \\<le> x\\<^sup>\\<circ> * y\\<^sup>\\<circ> \\<Longrightarrow> (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\" oops\nlemma \"y * x \\<le> (1 \\<squnion> x) * y\\<^sup>\\<circ> \\<Longrightarrow> (x \\<squnion> y)\\<^sup>\\<circ> = x\\<^sup>\\<circ> * y\\<^sup>\\<circ>\" oops\n*)"], ["", "end"]]}