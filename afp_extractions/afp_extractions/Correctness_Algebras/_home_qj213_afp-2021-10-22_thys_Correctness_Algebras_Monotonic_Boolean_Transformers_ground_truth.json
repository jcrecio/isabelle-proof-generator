{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Monotonic_Boolean_Transformers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma directed_left_mult:\n  \"directed Y \\<Longrightarrow> directed ((*) x ` Y)\"", "lemma neg_assertion:\n  \"neg_assert x \\<in> assertion\"", "lemma assertion_neg_assert:\n  \"x \\<in> assertion \\<longleftrightarrow> x = neg_assert (neg_assert x)\"", "lemma neg_assume_assert:\n  \"neg_assume x = (neg_assert (x ^ o)) ^ o\"", "lemma assert_iff_assume:\n  \"x \\<in> assertion \\<longleftrightarrow> x ^ o \\<in> assumption\"", "lemma assertion_iff_assumption_subseteq:\n  \"X \\<subseteq> assertion \\<longleftrightarrow> dual ` X \\<subseteq> assumption\"", "lemma assumption_iff_assertion_subseteq:\n  \"X \\<subseteq> assumption \\<longleftrightarrow> dual ` X \\<subseteq> assertion\"", "lemma assumption_prop:\n  \"x \\<in> assumption \\<Longrightarrow> (x * bot) \\<squnion> 1 = x\"", "lemma neg_assumption:\n  \"neg_assume x \\<in> assumption\"", "lemma assumption_neg_assume:\n  \"x \\<in> assumption \\<longleftrightarrow> x = neg_assume (neg_assume x)\"", "lemma assumption_sup_comp_eq:\n  \"x \\<in> assumption \\<Longrightarrow> y \\<in> assumption \\<Longrightarrow> x \\<squnion> y = x * y\"", "lemma sup_uminus_assume[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> x \\<sqinter> neg_assume x = 1\"", "lemma inf_uminus_assume[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> x \\<squnion> neg_assume x = top\"", "lemma uminus_assumption[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> neg_assume x \\<in> assumption\"", "lemma uminus_uminus_assume[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> neg_assume (neg_assume x) = x\"", "lemma sup_assumption[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> y \\<in> assumption \\<Longrightarrow> x \\<squnion> y \\<in> assumption\"", "lemma comp_assumption[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> y \\<in> assumption \\<Longrightarrow> x * y \\<in> assumption\"", "lemma inf_assumption[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> y \\<in> assumption \\<Longrightarrow> x \\<sqinter> y \\<in> assumption\"", "lemma assumption_comp_idempotent[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> x * x = x\"", "lemma assumption_comp_idempotent_dual[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> (x ^ o) * (x ^ o) = x ^ o\"", "lemma top_assumption[simp]:\n  \"top \\<in> assumption\"", "lemma one_assumption[simp]:\n  \"1 \\<in> assumption\"", "lemma assert_top:\n  \"neg_assert (neg_assert p) ^ o * bot = neg_assert p * top\"", "lemma assume_bot:\n  \"neg_assume (neg_assume p) ^ o * top = neg_assume p * bot\"", "lemma wpt_iff_wpb:\n  \"wpb x = wpt (x ^ o) ^ o\"", "lemma wpb_is_assumption[simp]:\n  \"wpb x \\<in> assumption\"", "lemma wpb_comp:\n  \"(wpb x) * x = x\"", "lemma wpb_comp_2:\n  \"wpb (x * y) = wpb (x * (wpb y))\"", "lemma wpb_assumption[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> wpb x = x\"", "lemma wpb_choice:\n  \"wpb (x \\<squnion> y) = wpb x \\<squnion> wpb y\"", "lemma wpb_dual_assumption:\n  \"x \\<in> assumption \\<Longrightarrow> wpb (x ^ o) = 1\"", "lemma wpb_mono:\n  \"x \\<le> y \\<Longrightarrow> wpb x \\<le> wpb y\"", "lemma assumption_disjunctive:\n  \"x \\<in> assumption \\<Longrightarrow> x \\<in> disjunctive\"", "lemma assumption_conjunctive:\n  \"x \\<in> assumption \\<Longrightarrow> x \\<in> conjunctive\"", "lemma wpb_le_assumption:\n  \"x \\<in> assumption \\<Longrightarrow> x * y = y \\<Longrightarrow> x \\<le> wpb y\"", "lemma dual_omega_fix:\n  \"x^\\<mho> = (x * (x^\\<mho>)) \\<squnion> 1\"", "lemma dual_omega_comp_fix:\n  \"x^\\<mho> * y = (x * (x^\\<mho>) * y) \\<squnion> y\"", "lemma dual_omega_greatest:\n  \"z \\<le> (x * z) \\<squnion> y \\<Longrightarrow> z \\<le> (x^\\<mho>) * y\"", "lemma post_antitone:\n  assumes \"x \\<le> y\"\n    shows \"post y \\<le> post x\"", "lemma post_assumption_below_one:\n  \"q \\<in> assumption \\<Longrightarrow> post q \\<le> post 1\"", "lemma post_assumption_above_one:\n  \"q \\<in> assumption \\<Longrightarrow> post 1 \\<le> post (q ^ o)\"", "lemma post_assumption_below_dual:\n  \"q \\<in> assumption \\<Longrightarrow> post q \\<le> post (q ^ o)\"", "lemma assumption_assertion_absorb:\n  \"q \\<in> assumption \\<Longrightarrow> q * (q ^ o) = q\"", "lemma post_dual_below_post_one:\n  assumes \"q \\<in> assumption\"\n  shows \"post (q ^ o) \\<le> post 1 * q\"", "lemma post_below_post_one:\n  \"q \\<in> assumption \\<Longrightarrow> post q \\<le> post 1 * q\"", "lemma Inf_assumption[simp]:\n  \"X \\<subseteq> assumption \\<Longrightarrow> Inf X \\<in> assumption\"", "lemma continuous_Continuous:\n  \"continuous x \\<longleftrightarrow> x \\<in> Continuous\"", "lemma one_continuous:\n  \"1 \\<in> Continuous\"", "lemma continuous_dist_ascending_chain:\n  assumes \"x \\<in> Continuous\"\n      and \"ascending_chain f\"\n    shows \"x * (SUP n::nat . f n) = (SUP n::nat . x * f n)\"", "lemma assertion_continuous:\n  assumes \"x \\<in> assertion\"\n    shows \"x \\<in> Continuous\"", "lemma assumption_continuous:\n  assumes \"x \\<in> assumption\"\n    shows \"x \\<in> Continuous\"", "lemma mult_continuous:\n  assumes \"x \\<in> Continuous\"\n      and \"y \\<in> Continuous\"\n    shows \"x * y \\<in> Continuous\"", "lemma sup_continuous:\n  \"x \\<in> Continuous \\<Longrightarrow> y \\<in> Continuous \\<Longrightarrow> x \\<squnion> y \\<in> Continuous\"", "lemma inf_continuous:\n  assumes \"x \\<in> Continuous\"\n      and \"y \\<in> Continuous\"\n    shows \"x \\<sqinter> y \\<in> Continuous\"", "lemma dual_star_continuous:\n  assumes \"x \\<in> Continuous\"\n    shows \"x ^ \\<otimes> \\<in> Continuous\"", "lemma omega_continuous:\n  assumes \"x \\<in> Continuous\"\n    shows \"x ^ \\<omega> \\<in> Continuous\"", "lemma directed_dual:\n  \"directed X \\<longleftrightarrow> co_directed (dual ` X)\"", "lemma dual_dual_image:\n  \"dual ` dual ` X = X\"", "lemma continuous_dual:\n  \"continuous x \\<longleftrightarrow> co_continuous (x ^ o)\"", "lemma co_continuous_Co_continuous:\n  \"co_continuous x \\<longleftrightarrow> x \\<in> Co_continuous\"", "lemma Continuous_dual:\n  \"x \\<in> Continuous \\<longleftrightarrow> x ^ o \\<in> Co_continuous\"", "lemma one_co_continuous:\n  \"1 \\<in> Co_continuous\"", "lemma ascending_chain_dual:\n  \"ascending_chain f \\<longleftrightarrow> descending_chain (dual o f)\"", "lemma co_continuous_dist_descending_chain:\n  assumes \"x \\<in> Co_continuous\"\n      and \"descending_chain f\"\n    shows \"x * (INF n::nat . f n) = (INF n::nat . x * f n)\"", "lemma assertion_co_continuous:\n  \"x \\<in> assertion \\<Longrightarrow> x \\<in> Co_continuous\"", "lemma assumption_co_continuous:\n  \"x \\<in> assumption \\<Longrightarrow> x \\<in> Co_continuous\"", "lemma mult_co_continuous:\n  \"x \\<in> Co_continuous \\<Longrightarrow> y \\<in> Co_continuous \\<Longrightarrow> x * y \\<in> Co_continuous\"", "lemma sup_co_continuous:\n  \"x \\<in> Co_continuous \\<Longrightarrow> y \\<in> Co_continuous \\<Longrightarrow> x \\<squnion> y \\<in> Co_continuous\"", "lemma inf_co_continuous:\n  \"x \\<in> Co_continuous \\<Longrightarrow> y \\<in> Co_continuous \\<Longrightarrow> x \\<sqinter> y \\<in> Co_continuous\"", "lemma dual_omega_co_continuous:\n  \"x \\<in> Co_continuous \\<Longrightarrow> x ^ \\<mho> \\<in> Co_continuous\"", "lemma star_co_continuous:\n  \"x \\<in> Co_continuous \\<Longrightarrow> x ^ * \\<in> Co_continuous\"", "lemma dual_omega_iterate:\n  assumes \"y \\<in> Co_continuous\"\n    shows \"y ^ \\<mho> * z = (INF n::nat . ((\\<lambda>x . y * x \\<squnion> z) ^ n) top)\"", "lemma dual_omega_iterate_one:\n  \"y \\<in> Co_continuous \\<Longrightarrow> y ^ \\<mho> = (INF n::nat . ((\\<lambda>x . y * x \\<squnion> 1) ^ n) top)\"", "lemma post_fusion:\n  \"post (neg_assume q ^ o) = post 1 * neg_assume q\"", "lemma post_dual_post_one:\n  \"q \\<in> assumption \\<Longrightarrow> post 1 * q \\<le> post (q ^ o)\""], "translations": [["", "lemma directed_left_mult:\n  \"directed Y \\<Longrightarrow> directed ((*) x ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed Y \\<Longrightarrow> directed ((*) x ` Y)", "apply (unfold directed_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>Y.\n        \\<forall>y\\<in>Y.\n           \\<exists>z\\<in>Y. x \\<le> z \\<and> y \\<le> z) \\<Longrightarrow>\n    (*) x ` Y \\<noteq> {} \\<and>\n    (\\<forall>xa\\<in>(*) x ` Y.\n        \\<forall>y\\<in>(*) x ` Y.\n           \\<exists>z\\<in>(*) x ` Y. xa \\<le> z \\<and> y \\<le> z)", "using le_comp"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (1 subgoal):\n 1. Y \\<noteq> {} \\<and>\n    (\\<forall>x\\<in>Y.\n        \\<forall>y\\<in>Y.\n           \\<exists>z\\<in>Y. x \\<le> z \\<and> y \\<le> z) \\<Longrightarrow>\n    (*) x ` Y \\<noteq> {} \\<and>\n    (\\<forall>xa\\<in>(*) x ` Y.\n        \\<forall>y\\<in>(*) x ` Y.\n           \\<exists>z\\<in>(*) x ` Y. xa \\<le> z \\<and> y \\<le> z)", "by blast"], ["", "lemma neg_assertion:\n  \"neg_assert x \\<in> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg_assert x \\<in> assertion", "by (metis bot_comp neg_assert_def wpt_def wpt_is_assertion mult_assoc)"], ["", "lemma assertion_neg_assert:\n  \"x \\<in> assertion \\<longleftrightarrow> x = neg_assert (neg_assert x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> assertion) = (x = neg_assert (neg_assert x))", "by (metis neg_assertion uminus_uminus)"], ["", "text \\<open>extend and dualise part of Viorel Preoteasa's theory\\<close>"], ["", "definition \"assumption \\<equiv> {x . 1 \\<le> x \\<and> (x * bot) \\<squnion> (x ^ o) = x}\""], ["", "definition \"neg_assume (x::'a) \\<equiv> (x ^ o * top) \\<squnion> 1\""], ["", "lemma neg_assume_assert:\n  \"neg_assume x = (neg_assert (x ^ o)) ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg_assume x = neg_assert (x ^ o) ^ o", "using dual_bot dual_comp dual_dual dual_inf dual_one neg_assert_def neg_assume_def"], ["proof (prove)\nusing this:\n  \\<bottom> ^ o = \\<top>\n  (?x * ?y) ^ o = ?x ^ o * ?y ^ o\n  (?x ^ o) ^ o = ?x\n  (?x \\<sqinter> ?y) ^ o = ?x ^ o \\<squnion> ?y ^ o\n  (1::'a) ^ o = (1::'a)\n  neg_assert ?x = ?x ^ o * \\<bottom> \\<sqinter> (1::'a)\n  neg_assume ?x \\<equiv> ?x ^ o * \\<top> \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. neg_assume x = neg_assert (x ^ o) ^ o", "by auto"], ["", "lemma assert_iff_assume:\n  \"x \\<in> assertion \\<longleftrightarrow> x ^ o \\<in> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> assertion) = (x ^ o \\<in> assumption)", "by (smt assertion_def assumption_def dual_bot dual_comp dual_dual dual_inf dual_le dual_one mem_Collect_eq)"], ["", "lemma assertion_iff_assumption_subseteq:\n  \"X \\<subseteq> assertion \\<longleftrightarrow> dual ` X \\<subseteq> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<subseteq> assertion) = (dual ` X \\<subseteq> assumption)", "using assert_iff_assume"], ["proof (prove)\nusing this:\n  (?x \\<in> assertion) = (?x ^ o \\<in> assumption)\n\ngoal (1 subgoal):\n 1. (X \\<subseteq> assertion) = (dual ` X \\<subseteq> assumption)", "by blast"], ["", "lemma assumption_iff_assertion_subseteq:\n  \"X \\<subseteq> assumption \\<longleftrightarrow> dual ` X \\<subseteq> assertion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<subseteq> assumption) = (dual ` X \\<subseteq> assertion)", "using assert_iff_assume"], ["proof (prove)\nusing this:\n  (?x \\<in> assertion) = (?x ^ o \\<in> assumption)\n\ngoal (1 subgoal):\n 1. (X \\<subseteq> assumption) = (dual ` X \\<subseteq> assertion)", "by auto"], ["", "lemma assumption_prop:\n  \"x \\<in> assumption \\<Longrightarrow> (x * bot) \\<squnion> 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow>\n    x * \\<bottom> \\<squnion> (1::'a) = x", "by (smt assert_iff_assume assertion_prop dual_comp dual_dual dual_neg_top dual_one dual_sup dual_top)"], ["", "lemma neg_assumption:\n  \"neg_assume x \\<in> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg_assume x \\<in> assumption", "using assert_iff_assume neg_assertion neg_assume_assert"], ["proof (prove)\nusing this:\n  (?x \\<in> assertion) = (?x ^ o \\<in> assumption)\n  neg_assert ?x \\<in> assertion\n  neg_assume ?x = neg_assert (?x ^ o) ^ o\n\ngoal (1 subgoal):\n 1. neg_assume x \\<in> assumption", "by auto"], ["", "lemma assumption_neg_assume:\n  \"x \\<in> assumption \\<longleftrightarrow> x = neg_assume (neg_assume x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> assumption) = (x = neg_assume (neg_assume x))", "by (smt assert_iff_assume assertion_neg_assert dual_dual neg_assume_assert)"], ["", "lemma assumption_sup_comp_eq:\n  \"x \\<in> assumption \\<Longrightarrow> y \\<in> assumption \\<Longrightarrow> x \\<squnion> y = x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assumption; y \\<in> assumption\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y = x * y", "by (smt assert_iff_assume assertion_inf_comp_eq dual_comp dual_dual dual_sup)"], ["", "lemma sup_uminus_assume[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> x \\<sqinter> neg_assume x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow> x \\<sqinter> neg_assume x = (1::'a)", "by (smt assert_iff_assume dual_dual dual_one dual_sup neg_assume_assert sup_uminus)"], ["", "lemma inf_uminus_assume[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> x \\<squnion> neg_assume x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow> x \\<squnion> neg_assume x = \\<top>", "by (smt assert_iff_assume dual_dual dual_sup dual_top inf_uminus neg_assume_assert sup_bot_right)"], ["", "lemma uminus_assumption[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> neg_assume x \\<in> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow> neg_assume x \\<in> assumption", "by (simp add: neg_assumption)"], ["", "lemma uminus_uminus_assume[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> neg_assume (neg_assume x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow> neg_assume (neg_assume x) = x", "by (simp add: assumption_neg_assume)"], ["", "lemma sup_assumption[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> y \\<in> assumption \\<Longrightarrow> x \\<squnion> y \\<in> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assumption; y \\<in> assumption\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y \\<in> assumption", "by (smt assert_iff_assume dual_dual dual_sup inf_assertion)"], ["", "lemma comp_assumption[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> y \\<in> assumption \\<Longrightarrow> x * y \\<in> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assumption; y \\<in> assumption\\<rbrakk>\n    \\<Longrightarrow> x * y \\<in> assumption", "using assumption_sup_comp_eq sup_assumption"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> assumption; ?y \\<in> assumption\\<rbrakk>\n  \\<Longrightarrow> ?x \\<squnion> ?y = ?x * ?y\n  \\<lbrakk>?x \\<in> assumption; ?y \\<in> assumption\\<rbrakk>\n  \\<Longrightarrow> ?x \\<squnion> ?y \\<in> assumption\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assumption; y \\<in> assumption\\<rbrakk>\n    \\<Longrightarrow> x * y \\<in> assumption", "by auto"], ["", "lemma inf_assumption[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> y \\<in> assumption \\<Longrightarrow> x \\<sqinter> y \\<in> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assumption; y \\<in> assumption\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<in> assumption", "by (smt assert_iff_assume dual_dual dual_inf sup_assertion)"], ["", "lemma assumption_comp_idempotent[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> x * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow> x * x = x", "using assumption_sup_comp_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> assumption; ?y \\<in> assumption\\<rbrakk>\n  \\<Longrightarrow> ?x \\<squnion> ?y = ?x * ?y\n\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow> x * x = x", "by fastforce"], ["", "lemma assumption_comp_idempotent_dual[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> (x ^ o) * (x ^ o) = x ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow> x ^ o * x ^ o = x ^ o", "by (metis assumption_comp_idempotent dual_comp)"], ["", "lemma top_assumption[simp]:\n  \"top \\<in> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<in> assumption", "by (simp add: assumption_def)"], ["", "lemma one_assumption[simp]:\n  \"1 \\<in> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<in> assumption", "by (simp add: assumption_def)"], ["", "lemma assert_top:\n  \"neg_assert (neg_assert p) ^ o * bot = neg_assert p * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg_assert (neg_assert p) ^ o * \\<bottom> = neg_assert p * \\<top>", "by (smt bot_comp dual_comp dual_dual dual_top inf_comp inf_top_right mult.assoc mult.left_neutral neg_assert_def)"], ["", "lemma assume_bot:\n  \"neg_assume (neg_assume p) ^ o * top = neg_assume p * bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neg_assume (neg_assume p) ^ o * \\<top> = neg_assume p * \\<bottom>", "by (smt assert_top dual_bot dual_comp dual_dual neg_assume_assert)"], ["", "definition \"wpb x \\<equiv> (x * bot) \\<squnion> 1\""], ["", "lemma wpt_iff_wpb:\n  \"wpb x = wpt (x ^ o) ^ o\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wpb x = wpt (x ^ o) ^ o", "using dual_comp dual_dual dual_inf dual_one dual_top wpt_def wpb_def"], ["proof (prove)\nusing this:\n  (?x * ?y) ^ o = ?x ^ o * ?y ^ o\n  (?x ^ o) ^ o = ?x\n  (?x \\<sqinter> ?y) ^ o = ?x ^ o \\<squnion> ?y ^ o\n  (1::'a) ^ o = (1::'a)\n  \\<top> ^ o = \\<bottom>\n  wpt ?x = ?x * \\<top> \\<sqinter> (1::'a)\n  wpb ?x \\<equiv> ?x * \\<bottom> \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. wpb x = wpt (x ^ o) ^ o", "by auto"], ["", "lemma wpb_is_assumption[simp]:\n  \"wpb x \\<in> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wpb x \\<in> assumption", "using assert_iff_assume wpt_is_assertion wpt_iff_wpb"], ["proof (prove)\nusing this:\n  (?x \\<in> assertion) = (?x ^ o \\<in> assumption)\n  wpt ?x \\<in> assertion\n  wpb ?x = wpt (?x ^ o) ^ o\n\ngoal (1 subgoal):\n 1. wpb x \\<in> assumption", "by auto"], ["", "lemma wpb_comp:\n  \"(wpb x) * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wpb x * x = x", "by (smt dual_comp dual_dual dual_neg_top dual_sup wpt_comp wpt_iff_wpb)"], ["", "lemma wpb_comp_2:\n  \"wpb (x * y) = wpb (x * (wpb y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wpb (x * y) = wpb (x * wpb y)", "by (simp add: sup_comp mult_assoc wpb_def)"], ["", "lemma wpb_assumption[simp]:\n  \"x \\<in> assumption \\<Longrightarrow> wpb x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow> wpb x = x", "by (simp add: assumption_prop wpb_def)"], ["", "lemma wpb_choice:\n  \"wpb (x \\<squnion> y) = wpb x \\<squnion> wpb y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wpb (x \\<squnion> y) = wpb x \\<squnion> wpb y", "using sup_assoc sup_commute sup_comp wpb_def"], ["proof (prove)\nusing this:\n  ?x \\<squnion> ?y \\<squnion> ?z = ?x \\<squnion> (?y \\<squnion> ?z)\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n  wpb ?x \\<equiv> ?x * \\<bottom> \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. wpb (x \\<squnion> y) = wpb x \\<squnion> wpb y", "by auto"], ["", "lemma wpb_dual_assumption:\n  \"x \\<in> assumption \\<Longrightarrow> wpb (x ^ o) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow> wpb (x ^ o) = (1::'a)", "by (smt assert_iff_assume dual_dual dual_one wpt_dual_assertion wpt_iff_wpb)"], ["", "lemma wpb_mono:\n  \"x \\<le> y \\<Longrightarrow> wpb x \\<le> wpb y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> wpb x \\<le> wpb y", "by (metis le_iff_sup wpb_choice)"], ["", "lemma assumption_disjunctive:\n  \"x \\<in> assumption \\<Longrightarrow> x \\<in> disjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow>\n    x \\<in> disjunctive.disjunctive (\\<squnion>) (\\<squnion>) (*)", "by (smt assert_iff_assume assertion_conjunctive dual_comp dual_conjunctive dual_dual)"], ["", "lemma assumption_conjunctive:\n  \"x \\<in> assumption \\<Longrightarrow> x \\<in> conjunctive\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow>\n    x \\<in> conjunctive.conjunctive (\\<sqinter>) (\\<sqinter>) (*)", "by (smt assert_iff_assume assertion_disjunctive dual_comp dual_disjunctive dual_dual)"], ["", "lemma wpb_le_assumption:\n  \"x \\<in> assumption \\<Longrightarrow> x * y = y \\<Longrightarrow> x \\<le> wpb y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> assumption; x * y = y\\<rbrakk>\n    \\<Longrightarrow> x \\<le> wpb y", "by (metis assumption_prop bot_least le_comp sup_commute sup_right_isotone mult_assoc wpb_def)"], ["", "definition dual_omega :: \"'a \\<Rightarrow> 'a\" (\"(_ ^ \\<mho>)\" [81] 80)\n  where \"(x ^ \\<mho>) \\<equiv> (((x ^ o) ^ \\<omega>) ^ o)\""], ["", "lemma dual_omega_fix:\n  \"x^\\<mho> = (x * (x^\\<mho>)) \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ \\<mho> = x * x ^ \\<mho> \\<squnion> (1::'a)", "by (smt dual_comp dual_dual dual_omega_def dual_one dual_sup omega_fix)"], ["", "lemma dual_omega_comp_fix:\n  \"x^\\<mho> * y = (x * (x^\\<mho>) * y) \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ \\<mho> * y = x * x ^ \\<mho> * y \\<squnion> y", "by (metis dual_omega_fix mult_1_left sup_comp)"], ["", "lemma dual_omega_greatest:\n  \"z \\<le> (x * z) \\<squnion> y \\<Longrightarrow> z \\<le> (x^\\<mho>) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> x * z \\<squnion> y \\<Longrightarrow> z \\<le> x ^ \\<mho> * y", "by (smt dual_comp dual_dual dual_le dual_neg_top dual_omega_def dual_sup omega_least)"], ["", "end"], ["", "context post_mbt_algebra\nbegin"], ["", "lemma post_antitone:\n  assumes \"x \\<le> y\"\n    shows \"post y \\<le> post x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post y \\<le> post x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. post y \\<le> post x", "have \"post y \\<le> post x * y * top \\<sqinter> post y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post y \\<le> post x * y * \\<top> \\<sqinter> post y", "by (metis assms inf_top_left post_1 inf_mono le_comp_left_right order_refl)"], ["proof (state)\nthis:\n  post y \\<le> post x * y * \\<top> \\<sqinter> post y\n\ngoal (1 subgoal):\n 1. post y \\<le> post x", "thus ?thesis"], ["proof (prove)\nusing this:\n  post y \\<le> post x * y * \\<top> \\<sqinter> post y\n\ngoal (1 subgoal):\n 1. post y \\<le> post x", "using order_lesseq_imp post_2"], ["proof (prove)\nusing this:\n  post y \\<le> post x * y * \\<top> \\<sqinter> post y\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  ?y * ?x * \\<top> \\<sqinter> post ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. post y \\<le> post x", "by blast"], ["proof (state)\nthis:\n  post y \\<le> post x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma post_assumption_below_one:\n  \"q \\<in> assumption \\<Longrightarrow> post q \\<le> post 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> assumption \\<Longrightarrow> post q \\<le> post (1::'a)", "by (simp add: assumption_def post_antitone)"], ["", "lemma post_assumption_above_one:\n  \"q \\<in> assumption \\<Longrightarrow> post 1 \\<le> post (q ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> assumption \\<Longrightarrow> post (1::'a) \\<le> post (q ^ o)", "by (metis dual_le dual_one post_antitone sup.commute sup_ge1 wpb_assumption wpb_def)"], ["", "lemma post_assumption_below_dual:\n  \"q \\<in> assumption \\<Longrightarrow> post q \\<le> post (q ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> assumption \\<Longrightarrow> post q \\<le> post (q ^ o)", "using order_trans post_assumption_above_one post_assumption_below_one"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?q \\<in> assumption \\<Longrightarrow> post (1::'a) \\<le> post (?q ^ o)\n  ?q \\<in> assumption \\<Longrightarrow> post ?q \\<le> post (1::'a)\n\ngoal (1 subgoal):\n 1. q \\<in> assumption \\<Longrightarrow> post q \\<le> post (q ^ o)", "by blast"], ["", "lemma assumption_assertion_absorb:\n  \"q \\<in> assumption \\<Longrightarrow> q * (q ^ o) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> assumption \\<Longrightarrow> q * q ^ o = q", "by (smt CollectE assumption_def assumption_prop bot_comp mult.left_neutral mult_assoc sup_comp)"], ["", "lemma post_dual_below_post_one:\n  assumes \"q \\<in> assumption\"\n  shows \"post (q ^ o) \\<le> post 1 * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post (q ^ o) \\<le> post (1::'a) * q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. post (q ^ o) \\<le> post (1::'a) * q", "have \"post (q ^ o) \\<le> post 1 * q * (q ^ o) * top \\<sqinter> post (q ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post (q ^ o)\n    \\<le> post (1::'a) * q * q ^ o * \\<top> \\<sqinter> post (q ^ o)", "by (metis assms assumption_assertion_absorb gt_one_comp inf_le1 inf_top_left mult_assoc order_refl post_1 sup_uminus_assume top_unique)"], ["proof (state)\nthis:\n  post (q ^ o)\n  \\<le> post (1::'a) * q * q ^ o * \\<top> \\<sqinter> post (q ^ o)\n\ngoal (1 subgoal):\n 1. post (q ^ o) \\<le> post (1::'a) * q", "thus ?thesis"], ["proof (prove)\nusing this:\n  post (q ^ o)\n  \\<le> post (1::'a) * q * q ^ o * \\<top> \\<sqinter> post (q ^ o)\n\ngoal (1 subgoal):\n 1. post (q ^ o) \\<le> post (1::'a) * q", "using order_lesseq_imp post_2"], ["proof (prove)\nusing this:\n  post (q ^ o)\n  \\<le> post (1::'a) * q * q ^ o * \\<top> \\<sqinter> post (q ^ o)\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  ?y * ?x * \\<top> \\<sqinter> post ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. post (q ^ o) \\<le> post (1::'a) * q", "by blast"], ["proof (state)\nthis:\n  post (q ^ o) \\<le> post (1::'a) * q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma post_below_post_one:\n  \"q \\<in> assumption \\<Longrightarrow> post q \\<le> post 1 * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> assumption \\<Longrightarrow> post q \\<le> post (1::'a) * q", "using order.trans post_assumption_below_dual post_dual_below_post_one"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n  ?q \\<in> assumption \\<Longrightarrow> post ?q \\<le> post (?q ^ o)\n  ?q \\<in> assumption \\<Longrightarrow>\n  post (?q ^ o) \\<le> post (1::'a) * ?q\n\ngoal (1 subgoal):\n 1. q \\<in> assumption \\<Longrightarrow> post q \\<le> post (1::'a) * q", "by blast"], ["", "end"], ["", "context complete_mbt_algebra\nbegin"], ["", "lemma Inf_assumption[simp]:\n  \"X \\<subseteq> assumption \\<Longrightarrow> Inf X \\<in> assumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> assumption \\<Longrightarrow> \\<Sqinter>X \\<in> assumption", "by (metis Sup_assertion assert_iff_assume assumption_iff_assertion_subseteq dual_Inf dual_dual)"], ["", "definition \"continuous x \\<equiv> (\\<forall>Y . directed Y \\<longrightarrow> x * (SUP y\\<in>Y . y) = (SUP y\\<in>Y . x * y))\""], ["", "definition \"Continuous \\<equiv> { x . continuous x }\""], ["", "lemma continuous_Continuous:\n  \"continuous x \\<longleftrightarrow> x \\<in> Continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous x = (x \\<in> Continuous)", "by (simp add: Continuous_def)"], ["", "text \\<open>Theorem 53.1\\<close>"], ["", "lemma one_continuous:\n  \"1 \\<in> Continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<in> Continuous", "by (simp add: Continuous_def continuous_def image_def)"], ["", "lemma continuous_dist_ascending_chain:\n  assumes \"x \\<in> Continuous\"\n      and \"ascending_chain f\"\n    shows \"x * (SUP n::nat . f n) = (SUP n::nat . x * f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<Squnion>range f = (\\<Squnion>n. x * f n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * \\<Squnion>range f = (\\<Squnion>n. x * f n)", "have \"directed (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed (range f)", "by (simp add: assms(2) ascending_chain_directed)"], ["proof (state)\nthis:\n  directed (range f)\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>range f = (\\<Squnion>n. x * f n)", "hence \"x * (SUP n::nat . f n) = (SUP y\\<in>range f . x * y)\""], ["proof (prove)\nusing this:\n  directed (range f)\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>range f = \\<Squnion>((*) x ` range f)", "using assms(1) continuous_Continuous continuous_def"], ["proof (prove)\nusing this:\n  directed (range f)\n  x \\<in> Continuous\n  continuous ?x = (?x \\<in> Continuous)\n  continuous ?x \\<equiv>\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     ?x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) ?x ` Y)\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>range f = \\<Squnion>((*) x ` range f)", "by auto"], ["proof (state)\nthis:\n  x * \\<Squnion>range f = \\<Squnion>((*) x ` range f)\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>range f = (\\<Squnion>n. x * f n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x * \\<Squnion>range f = \\<Squnion>((*) x ` range f)\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>range f = (\\<Squnion>n. x * f n)", "by (simp add: range_composition)"], ["proof (state)\nthis:\n  x * \\<Squnion>range f = (\\<Squnion>n. x * f n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 53.1\\<close>"], ["", "lemma assertion_continuous:\n  assumes \"x \\<in> assertion\"\n    shows \"x \\<in> Continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Continuous", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Continuous", "have 1: \"x = (x * top) \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x * \\<top> \\<sqinter> (1::'a)", "using assms assertion_prop"], ["proof (prove)\nusing this:\n  x \\<in> assertion\n  ?x \\<in> assertion \\<Longrightarrow> ?x * \\<top> \\<sqinter> (1::'a) = ?x\n\ngoal (1 subgoal):\n 1. x = x * \\<top> \\<sqinter> (1::'a)", "by auto"], ["proof (state)\nthis:\n  x = x * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> Continuous", "have \"\\<forall>Y . directed Y \\<longrightarrow> x * (SUP y\\<in>Y . y) = (SUP y\\<in>Y . x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "assume \"directed Y\""], ["proof (state)\nthis:\n  directed Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "(* assumption not used *)"], ["proof (state)\nthis:\n  directed Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "have \"x * (SUP y\\<in>Y . y) = (x * top) \\<sqinter> (SUP y\\<in>Y . y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) =\n    x * \\<top> \\<sqinter> (\\<Squnion>y\\<in>Y. y)", "using 1"], ["proof (prove)\nusing this:\n  x = x * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) =\n    x * \\<top> \\<sqinter> (\\<Squnion>y\\<in>Y. y)", "by (smt inf_comp mult.assoc mult.left_neutral top_comp)"], ["proof (state)\nthis:\n  x * (\\<Squnion>y\\<in>Y. y) = x * \\<top> \\<sqinter> (\\<Squnion>y\\<in>Y. y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "also"], ["proof (state)\nthis:\n  x * (\\<Squnion>y\\<in>Y. y) = x * \\<top> \\<sqinter> (\\<Squnion>y\\<in>Y. y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "have \"... = (SUP y\\<in>Y . (x * top) \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<top> \\<sqinter> (\\<Squnion>y\\<in>Y. y) =\n    \\<Squnion>((\\<sqinter>) (x * \\<top>) ` Y)", "by (simp add: inf_Sup)"], ["proof (state)\nthis:\n  x * \\<top> \\<sqinter> (\\<Squnion>y\\<in>Y. y) =\n  \\<Squnion>((\\<sqinter>) (x * \\<top>) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "finally"], ["proof (chain)\npicking this:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((\\<sqinter>) (x * \\<top>) ` Y)", "show \"x * (SUP y\\<in>Y . y) = (SUP y\\<in>Y . x * y)\""], ["proof (prove)\nusing this:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((\\<sqinter>) (x * \\<top>) ` Y)\n\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "using 1"], ["proof (prove)\nusing this:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((\\<sqinter>) (x * \\<top>) ` Y)\n  x = x * \\<top> \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "by (smt inf_comp mult.left_neutral mult.assoc top_comp SUP_cong)"], ["proof (state)\nthis:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal (1 subgoal):\n 1. x \\<in> Continuous", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal (1 subgoal):\n 1. x \\<in> Continuous", "by (simp add: continuous_def Continuous_def)"], ["proof (state)\nthis:\n  x \\<in> Continuous\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 53.1\\<close>"], ["", "lemma assumption_continuous:\n  assumes \"x \\<in> assumption\"\n    shows \"x \\<in> Continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Continuous", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Continuous", "have 1: \"x = (x * bot) \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x * \\<bottom> \\<squnion> (1::'a)", "by (simp add: assms assumption_prop)"], ["proof (state)\nthis:\n  x = x * \\<bottom> \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> Continuous", "have \"\\<forall>Y . directed Y \\<longrightarrow> x * (SUP y\\<in>Y . y) = (SUP y\\<in>Y . x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "assume 2: \"directed Y\""], ["proof (state)\nthis:\n  directed Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "have \"x * (SUP y\\<in>Y . y) = (x * bot) \\<squnion> (SUP y\\<in>Y . y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) =\n    x * \\<bottom> \\<squnion> (\\<Squnion>y\\<in>Y. y)", "using 1"], ["proof (prove)\nusing this:\n  x = x * \\<bottom> \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) =\n    x * \\<bottom> \\<squnion> (\\<Squnion>y\\<in>Y. y)", "by (smt sup_comp mult.assoc mult.left_neutral bot_comp)"], ["proof (state)\nthis:\n  x * (\\<Squnion>y\\<in>Y. y) =\n  x * \\<bottom> \\<squnion> (\\<Squnion>y\\<in>Y. y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "also"], ["proof (state)\nthis:\n  x * (\\<Squnion>y\\<in>Y. y) =\n  x * \\<bottom> \\<squnion> (\\<Squnion>y\\<in>Y. y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "have \"... = (SUP y\\<in>Y . (x * bot) \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<bottom> \\<squnion> (\\<Squnion>y\\<in>Y. y) =\n    \\<Squnion>((\\<squnion>) (x * \\<bottom>) ` Y)", "using 2"], ["proof (prove)\nusing this:\n  directed Y\n\ngoal (1 subgoal):\n 1. x * \\<bottom> \\<squnion> (\\<Squnion>y\\<in>Y. y) =\n    \\<Squnion>((\\<squnion>) (x * \\<bottom>) ` Y)", "by (smt (verit, ccfv_threshold) sup_SUP SUP_cong directed_def)"], ["proof (state)\nthis:\n  x * \\<bottom> \\<squnion> (\\<Squnion>y\\<in>Y. y) =\n  \\<Squnion>((\\<squnion>) (x * \\<bottom>) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "finally"], ["proof (chain)\npicking this:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((\\<squnion>) (x * \\<bottom>) ` Y)", "show \"x * (SUP y\\<in>Y . y) = (SUP y\\<in>Y . x * y)\""], ["proof (prove)\nusing this:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((\\<squnion>) (x * \\<bottom>) ` Y)\n\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "using 1"], ["proof (prove)\nusing this:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((\\<squnion>) (x * \\<bottom>) ` Y)\n  x = x * \\<bottom> \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "by (metis sup_comp mult.left_neutral mult.assoc bot_comp SUP_cong)"], ["proof (state)\nthis:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal (1 subgoal):\n 1. x \\<in> Continuous", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal (1 subgoal):\n 1. x \\<in> Continuous", "by (simp add: continuous_def Continuous_def)"], ["proof (state)\nthis:\n  x \\<in> Continuous\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 53.1\\<close>"], ["", "lemma mult_continuous:\n  assumes \"x \\<in> Continuous\"\n      and \"y \\<in> Continuous\"\n    shows \"x * y \\<in> Continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<in> Continuous", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<in> Continuous", "have \"\\<forall>Y. directed Y \\<longrightarrow> x * y * (SUP y\\<in>Y . y) = (SUP z\\<in>Y . x * y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)", "assume \"directed Y\""], ["proof (state)\nthis:\n  directed Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)", "hence \"x * y * (SUP w\\<in>Y . w) = (SUP z\\<in>Y . x * (y * z))\""], ["proof (prove)\nusing this:\n  directed Y\n\ngoal (1 subgoal):\n 1. x * y * (\\<Squnion>w\\<in>Y. w) = (\\<Squnion>z\\<in>Y. x * (y * z))", "by (metis assms continuous_Continuous continuous_def directed_left_mult image_ident image_image mult_assoc)"], ["proof (state)\nthis:\n  x * y * (\\<Squnion>w\\<in>Y. w) = (\\<Squnion>z\\<in>Y. x * (y * z))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)", "thus \"x * y * (SUP y\\<in>Y . y) = (SUP z\\<in>Y . x * y * z)\""], ["proof (prove)\nusing this:\n  x * y * (\\<Squnion>w\\<in>Y. w) = (\\<Squnion>z\\<in>Y. x * (y * z))\n\ngoal (1 subgoal):\n 1. x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)", "using mult_assoc"], ["proof (prove)\nusing this:\n  x * y * (\\<Squnion>w\\<in>Y. w) = (\\<Squnion>z\\<in>Y. x * (y * z))\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)", "by auto"], ["proof (state)\nthis:\n  x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)\n\ngoal (1 subgoal):\n 1. x * y \\<in> Continuous", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)\n\ngoal (1 subgoal):\n 1. x * y \\<in> Continuous", "using Continuous_def continuous_def"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x * y * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x * y) ` Y)\n  Continuous \\<equiv> {x. continuous x}\n  continuous ?x \\<equiv>\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     ?x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) ?x ` Y)\n\ngoal (1 subgoal):\n 1. x * y \\<in> Continuous", "by blast"], ["proof (state)\nthis:\n  x * y \\<in> Continuous\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 53.1\\<close>"], ["", "lemma sup_continuous:\n  \"x \\<in> Continuous \\<Longrightarrow> y \\<in> Continuous \\<Longrightarrow> x \\<squnion> y \\<in> Continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> Continuous; y \\<in> Continuous\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y \\<in> Continuous", "by (smt SUP_cong SUP_sup_distrib continuous_Continuous continuous_def sup_comp)"], ["", "text \\<open>Theorem 53.1\\<close>"], ["", "lemma inf_continuous:\n  assumes \"x \\<in> Continuous\"\n      and \"y \\<in> Continuous\"\n    shows \"x \\<sqinter> y \\<in> Continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<in> Continuous", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<in> Continuous", "have \"\\<forall>Y. directed Y \\<longrightarrow> (x \\<sqinter> y) * (SUP y\\<in>Y . y) = (SUP z\\<in>Y . (x \\<sqinter> y) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       directed Y \\<longrightarrow>\n       (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "assume 1: \"directed Y\""], ["proof (state)\nthis:\n  directed Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "have 2: \"(SUP w\\<in>Y . SUP z\\<in>Y . (x * w) \\<sqinter> (y * z)) \\<le> (SUP z\\<in>Y . (x * z) \\<sqinter> (y * z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z)\n    \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)", "proof (intro SUP_least)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w z.\n       \\<lbrakk>w \\<in> Y; z \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> x * w \\<sqinter> y * z\n                         \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)", "fix w z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w z.\n       \\<lbrakk>w \\<in> Y; z \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> x * w \\<sqinter> y * z\n                         \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)", "assume \"w \\<in> Y\" and \"z \\<in> Y\""], ["proof (state)\nthis:\n  w \\<in> Y\n  z \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>w z.\n       \\<lbrakk>w \\<in> Y; z \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> x * w \\<sqinter> y * z\n                         \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)", "from this"], ["proof (chain)\npicking this:\n  w \\<in> Y\n  z \\<in> Y", "obtain v where 3: \"v\\<in>Y \\<and> w \\<le> v \\<and> z \\<le> v\""], ["proof (prove)\nusing this:\n  w \\<in> Y\n  z \\<in> Y\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 1"], ["proof (prove)\nusing this:\n  w \\<in> Y\n  z \\<in> Y\n  directed Y\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson directed_def)"], ["proof (state)\nthis:\n  v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v\n\ngoal (1 subgoal):\n 1. \\<And>w z.\n       \\<lbrakk>w \\<in> Y; z \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> x * w \\<sqinter> y * z\n                         \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)", "hence \"x * w \\<sqinter> (y * z) \\<le> (x * v) \\<sqinter> (y * v)\""], ["proof (prove)\nusing this:\n  v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v\n\ngoal (1 subgoal):\n 1. x * w \\<sqinter> y * z \\<le> x * v \\<sqinter> y * v", "by (meson inf.sup_mono le_comp)"], ["proof (state)\nthis:\n  x * w \\<sqinter> y * z \\<le> x * v \\<sqinter> y * v\n\ngoal (1 subgoal):\n 1. \\<And>w z.\n       \\<lbrakk>w \\<in> Y; z \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> x * w \\<sqinter> y * z\n                         \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)", "thus \"x * w \\<sqinter> (y * z) \\<le> (SUP z\\<in>Y . (x * z) \\<sqinter> (y * z))\""], ["proof (prove)\nusing this:\n  x * w \\<sqinter> y * z \\<le> x * v \\<sqinter> y * v\n\ngoal (1 subgoal):\n 1. x * w \\<sqinter> y * z \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)", "using 3"], ["proof (prove)\nusing this:\n  x * w \\<sqinter> y * z \\<le> x * v \\<sqinter> y * v\n  v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v\n\ngoal (1 subgoal):\n 1. x * w \\<sqinter> y * z \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)", "by (meson SUP_upper2)"], ["proof (state)\nthis:\n  x * w \\<sqinter> y * z \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z)\n  \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "have \"(SUP z\\<in>Y . (x * z) \\<sqinter> (y * z)) \\<le> (SUP w\\<in>Y . SUP z\\<in>Y . (x * w) \\<sqinter> (y * z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)\n    \\<le> (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z)", "apply (rule SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> Y \\<Longrightarrow>\n       x * z \\<sqinter> y * z\n       \\<le> (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z)", "by (meson SUP_upper SUP_upper2)"], ["proof (state)\nthis:\n  (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)\n  \\<le> (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "hence \"(SUP w\\<in>Y . SUP z\\<in>Y . (x * w) \\<sqinter> (y * z)) = (SUP z\\<in>Y . (x \\<sqinter> y) * z)\""], ["proof (prove)\nusing this:\n  (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)\n  \\<le> (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z) =\n    \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "using 2 order.antisym inf_comp"], ["proof (prove)\nusing this:\n  (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)\n  \\<le> (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z)\n  (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z)\n  \\<le> (\\<Squnion>z\\<in>Y. x * z \\<sqinter> y * z)\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  (?x \\<sqinter> ?y) * ?z = ?x * ?z \\<sqinter> ?y * ?z\n\ngoal (1 subgoal):\n 1. (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z) =\n    \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "by auto"], ["proof (state)\nthis:\n  (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z) =\n  \\<Squnion>((*) (x \\<sqinter> y) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "thus \"(x \\<sqinter> y) * (SUP y\\<in>Y . y) = (SUP z\\<in>Y . (x \\<sqinter> y) * z)\""], ["proof (prove)\nusing this:\n  (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z) =\n  \\<Squnion>((*) (x \\<sqinter> y) ` Y)\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n    \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "using 1"], ["proof (prove)\nusing this:\n  (\\<Squnion>w\\<in>Y. \\<Squnion>z\\<in>Y. x * w \\<sqinter> y * z) =\n  \\<Squnion>((*) (x \\<sqinter> y) ` Y)\n  directed Y\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n    \\<Squnion>((*) (x \\<sqinter> y) ` Y)", "by (metis assms inf_comp continuous_Continuous continuous_def SUP_inf_distrib2)"], ["proof (state)\nthis:\n  (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n  \\<Squnion>((*) (x \\<sqinter> y) ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n     \\<Squnion>((*) (x \\<sqinter> y) ` Y)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<in> Continuous", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n     \\<Squnion>((*) (x \\<sqinter> y) ` Y)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<in> Continuous", "using Continuous_def continuous_def"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     (x \\<sqinter> y) * (\\<Squnion>y\\<in>Y. y) =\n     \\<Squnion>((*) (x \\<sqinter> y) ` Y)\n  Continuous \\<equiv> {x. continuous x}\n  continuous ?x \\<equiv>\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     ?x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) ?x ` Y)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<in> Continuous", "by blast"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<in> Continuous\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 53.1\\<close>"], ["", "lemma dual_star_continuous:\n  assumes \"x \\<in> Continuous\"\n    shows \"x ^ \\<otimes> \\<in> Continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ \\<otimes> \\<in> Continuous", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x ^ \\<otimes> \\<in> Continuous", "have \"\\<forall>Y. directed Y \\<longrightarrow> (x ^ \\<otimes>) * (SUP y\\<in>Y . y) = (SUP z\\<in>Y . (x ^ \\<otimes>) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "assume \"directed Y\""], ["proof (state)\nthis:\n  directed Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "hence \"directed ((*) (x ^ \\<otimes>) ` Y)\""], ["proof (prove)\nusing this:\n  directed Y\n\ngoal (1 subgoal):\n 1. directed ((*) (x ^ \\<otimes>) ` Y)", "by (simp add: directed_left_mult)"], ["proof (state)\nthis:\n  directed ((*) (x ^ \\<otimes>) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "hence \"x * (SUP y\\<in>Y . (x ^ \\<otimes>) * y) = (SUP y\\<in>Y . x * ((x ^ \\<otimes>) * y))\""], ["proof (prove)\nusing this:\n  directed ((*) (x ^ \\<otimes>) ` Y)\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>((*) (x ^ \\<otimes>) ` Y) =\n    (\\<Squnion>y\\<in>Y. x * (x ^ \\<otimes> * y))", "by (metis assms continuous_Continuous continuous_def image_ident image_image)"], ["proof (state)\nthis:\n  x * \\<Squnion>((*) (x ^ \\<otimes>) ` Y) =\n  (\\<Squnion>y\\<in>Y. x * (x ^ \\<otimes> * y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "also"], ["proof (state)\nthis:\n  x * \\<Squnion>((*) (x ^ \\<otimes>) ` Y) =\n  (\\<Squnion>y\\<in>Y. x * (x ^ \\<otimes> * y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "have \"... = (SUP y\\<in>Y . x * (x ^ \\<otimes>) * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>Y. x * (x ^ \\<otimes> * y)) =\n    \\<Squnion>((*) (x * x ^ \\<otimes>) ` Y)", "using mult_assoc"], ["proof (prove)\nusing this:\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>Y. x * (x ^ \\<otimes> * y)) =\n    \\<Squnion>((*) (x * x ^ \\<otimes>) ` Y)", "by auto"], ["proof (state)\nthis:\n  (\\<Squnion>y\\<in>Y. x * (x ^ \\<otimes> * y)) =\n  \\<Squnion>((*) (x * x ^ \\<otimes>) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>y\\<in>Y. x * (x ^ \\<otimes> * y)) =\n  \\<Squnion>((*) (x * x ^ \\<otimes>) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "have \"... \\<le> (SUP y\\<in>Y . (x ^ \\<otimes>) * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>((*) (x * x ^ \\<otimes>) ` Y)\n    \\<le> \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "apply (rule SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Y \\<Longrightarrow>\n       x * x ^ \\<otimes> * y \\<le> \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "by (simp add: SUP_upper2 dual_star_comp_fix)"], ["proof (state)\nthis:\n  \\<Squnion>((*) (x * x ^ \\<otimes>) ` Y)\n  \\<le> \\<Squnion>((*) (x ^ \\<otimes>) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "finally"], ["proof (chain)\npicking this:\n  x * \\<Squnion>((*) (x ^ \\<otimes>) ` Y)\n  \\<le> \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "have \"x * (SUP y\\<in>Y . (x ^ \\<otimes>) * y) \\<squnion> (SUP y\\<in>Y . y) \\<le> (SUP y\\<in>Y . (x ^ \\<otimes>) * y)\""], ["proof (prove)\nusing this:\n  x * \\<Squnion>((*) (x ^ \\<otimes>) ` Y)\n  \\<le> \\<Squnion>((*) (x ^ \\<otimes>) ` Y)\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>((*) (x ^ \\<otimes>) ` Y) \\<squnion>\n    (\\<Squnion>y\\<in>Y. y)\n    \\<le> \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "apply (rule sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>Y. y) \\<le> \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "by (metis SUP_mono' dual_star_comp_fix sup.cobounded1 sup_commute)"], ["proof (state)\nthis:\n  x * \\<Squnion>((*) (x ^ \\<otimes>) ` Y) \\<squnion> (\\<Squnion>y\\<in>Y. y)\n  \\<le> \\<Squnion>((*) (x ^ \\<otimes>) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "thus \"(x ^ \\<otimes>) * (SUP y\\<in>Y . y) = (SUP z\\<in>Y . (x ^ \\<otimes>) * z)\""], ["proof (prove)\nusing this:\n  x * \\<Squnion>((*) (x ^ \\<otimes>) ` Y) \\<squnion> (\\<Squnion>y\\<in>Y. y)\n  \\<le> \\<Squnion>((*) (x ^ \\<otimes>) ` Y)\n\ngoal (1 subgoal):\n 1. x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n    \\<Squnion>((*) (x ^ \\<otimes>) ` Y)", "by (meson SUP_least SUP_upper order.antisym dual_star_least le_comp)"], ["proof (state)\nthis:\n  x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n  \\<Squnion>((*) (x ^ \\<otimes>) ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n     \\<Squnion>((*) (x ^ \\<otimes>) ` Y)\n\ngoal (1 subgoal):\n 1. x ^ \\<otimes> \\<in> Continuous", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n     \\<Squnion>((*) (x ^ \\<otimes>) ` Y)\n\ngoal (1 subgoal):\n 1. x ^ \\<otimes> \\<in> Continuous", "using Continuous_def continuous_def"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x ^ \\<otimes> * (\\<Squnion>y\\<in>Y. y) =\n     \\<Squnion>((*) (x ^ \\<otimes>) ` Y)\n  Continuous \\<equiv> {x. continuous x}\n  continuous ?x \\<equiv>\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     ?x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) ?x ` Y)\n\ngoal (1 subgoal):\n 1. x ^ \\<otimes> \\<in> Continuous", "by blast"], ["proof (state)\nthis:\n  x ^ \\<otimes> \\<in> Continuous\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 53.1\\<close>"], ["", "lemma omega_continuous:\n  assumes \"x \\<in> Continuous\"\n    shows \"x ^ \\<omega> \\<in> Continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ \\<omega> \\<in> Continuous", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x ^ \\<omega> \\<in> Continuous", "have \"\\<forall>Y. directed Y \\<longrightarrow> (x ^ \\<omega>) * (SUP y\\<in>Y . y) = (SUP z\\<in>Y . (x ^ \\<omega>) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "assume 1: \"directed Y\""], ["proof (state)\nthis:\n  directed Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "hence \"directed ((*) (x ^ \\<omega>) ` Y)\""], ["proof (prove)\nusing this:\n  directed Y\n\ngoal (1 subgoal):\n 1. directed ((*) (x ^ \\<omega>) ` Y)", "using directed_left_mult"], ["proof (prove)\nusing this:\n  directed Y\n  directed ?Y \\<Longrightarrow> directed ((*) ?x ` ?Y)\n\ngoal (1 subgoal):\n 1. directed ((*) (x ^ \\<omega>) ` Y)", "by auto"], ["proof (state)\nthis:\n  directed ((*) (x ^ \\<omega>) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "hence \"x * (SUP y\\<in>Y . (x ^ \\<omega>) * y) = (SUP y\\<in>Y . x * ((x ^ \\<omega>) * y))\""], ["proof (prove)\nusing this:\n  directed ((*) (x ^ \\<omega>) ` Y)\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) =\n    (\\<Squnion>y\\<in>Y. x * (x ^ \\<omega> * y))", "by (metis assms continuous_Continuous continuous_def image_ident image_image)"], ["proof (state)\nthis:\n  x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) =\n  (\\<Squnion>y\\<in>Y. x * (x ^ \\<omega> * y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "hence 2: \"x * (SUP y\\<in>Y . (x ^ \\<omega>) * y) = (SUP y\\<in>Y . x * (x ^ \\<omega>) * y)\""], ["proof (prove)\nusing this:\n  x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) =\n  (\\<Squnion>y\\<in>Y. x * (x ^ \\<omega> * y))\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) =\n    \\<Squnion>((*) (x * x ^ \\<omega>) ` Y)", "by (simp add: mult_assoc)"], ["proof (state)\nthis:\n  x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) =\n  \\<Squnion>((*) (x * x ^ \\<omega>) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "have \"(SUP y\\<in>Y . x * (x ^ \\<omega>) * y) \\<sqinter> (SUP y\\<in>Y . y) = (SUP w\\<in>Y . SUP z\\<in>Y . (x * (x ^ \\<omega>) * w) \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>((*) (x * x ^ \\<omega>) ` Y) \\<sqinter>\n    (\\<Squnion>y\\<in>Y. y) =\n    (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))", "using SUP_inf_distrib2"], ["proof (prove)\nusing this:\n  \\<Squnion>(?f ` ?A) \\<sqinter> \\<Squnion>(?g ` ?B) =\n  (\\<Squnion>a\\<in>?A. \\<Squnion>b\\<in>?B. ?f a \\<sqinter> ?g b)\n\ngoal (1 subgoal):\n 1. \\<Squnion>((*) (x * x ^ \\<omega>) ` Y) \\<sqinter>\n    (\\<Squnion>y\\<in>Y. y) =\n    (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))", "by blast"], ["proof (state)\nthis:\n  \\<Squnion>((*) (x * x ^ \\<omega>) ` Y) \\<sqinter> (\\<Squnion>y\\<in>Y. y) =\n  (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "hence \"x * (SUP y\\<in>Y . (x ^ \\<omega>) * y) \\<sqinter> (SUP y\\<in>Y . y) = (SUP w\\<in>Y . SUP z\\<in>Y . (x * (x ^ \\<omega>) * w) \\<sqinter> z)\""], ["proof (prove)\nusing this:\n  \\<Squnion>((*) (x * x ^ \\<omega>) ` Y) \\<sqinter> (\\<Squnion>y\\<in>Y. y) =\n  (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) \\<sqinter>\n    (\\<Squnion>y\\<in>Y. y) =\n    (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))", "using 2"], ["proof (prove)\nusing this:\n  \\<Squnion>((*) (x * x ^ \\<omega>) ` Y) \\<sqinter> (\\<Squnion>y\\<in>Y. y) =\n  (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))\n  x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) =\n  \\<Squnion>((*) (x * x ^ \\<omega>) ` Y)\n\ngoal (1 subgoal):\n 1. x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) \\<sqinter>\n    (\\<Squnion>y\\<in>Y. y) =\n    (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))", "by auto"], ["proof (state)\nthis:\n  x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) \\<sqinter> (\\<Squnion>y\\<in>Y. y) =\n  (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "also"], ["proof (state)\nthis:\n  x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) \\<sqinter> (\\<Squnion>y\\<in>Y. y) =\n  (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "have \"... \\<le> (SUP y\\<in>Y . (x ^ \\<omega>) * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))\n    \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "proof (intro SUP_least)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w z.\n       \\<lbrakk>w \\<in> Y; z \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> x * x ^ \\<omega> * w \\<sqinter> z\n                         \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "fix w z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w z.\n       \\<lbrakk>w \\<in> Y; z \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> x * x ^ \\<omega> * w \\<sqinter> z\n                         \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "assume \"w \\<in> Y\" and \"z \\<in> Y\""], ["proof (state)\nthis:\n  w \\<in> Y\n  z \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>w z.\n       \\<lbrakk>w \\<in> Y; z \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> x * x ^ \\<omega> * w \\<sqinter> z\n                         \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "from this"], ["proof (chain)\npicking this:\n  w \\<in> Y\n  z \\<in> Y", "obtain v where 3: \"v\\<in>Y \\<and> w \\<le> v \\<and> z \\<le> v\""], ["proof (prove)\nusing this:\n  w \\<in> Y\n  z \\<in> Y\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 1"], ["proof (prove)\nusing this:\n  w \\<in> Y\n  z \\<in> Y\n  directed Y\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson directed_def)"], ["proof (state)\nthis:\n  v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v\n\ngoal (1 subgoal):\n 1. \\<And>w z.\n       \\<lbrakk>w \\<in> Y; z \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> x * x ^ \\<omega> * w \\<sqinter> z\n                         \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "hence \"x * x ^ \\<omega> * w \\<sqinter> z \\<le> x ^ \\<omega> * v\""], ["proof (prove)\nusing this:\n  v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v\n\ngoal (1 subgoal):\n 1. x * x ^ \\<omega> * w \\<sqinter> z \\<le> x ^ \\<omega> * v", "using inf.sup_mono le_comp omega_comp_fix"], ["proof (prove)\nusing this:\n  v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v\n  \\<lbrakk>?c \\<le> ?a; ?d \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?c \\<sqinter> ?d \\<le> ?a \\<sqinter> ?b\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  ?x ^ \\<omega> * ?y = ?x * ?x ^ \\<omega> * ?y \\<sqinter> ?y\n\ngoal (1 subgoal):\n 1. x * x ^ \\<omega> * w \\<sqinter> z \\<le> x ^ \\<omega> * v", "by auto"], ["proof (state)\nthis:\n  x * x ^ \\<omega> * w \\<sqinter> z \\<le> x ^ \\<omega> * v\n\ngoal (1 subgoal):\n 1. \\<And>w z.\n       \\<lbrakk>w \\<in> Y; z \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> x * x ^ \\<omega> * w \\<sqinter> z\n                         \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "thus \"x * x ^ \\<omega> * w \\<sqinter> z \\<le> (SUP y\\<in>Y . (x ^ \\<omega>) * y)\""], ["proof (prove)\nusing this:\n  x * x ^ \\<omega> * w \\<sqinter> z \\<le> x ^ \\<omega> * v\n\ngoal (1 subgoal):\n 1. x * x ^ \\<omega> * w \\<sqinter> z\n    \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "using 3"], ["proof (prove)\nusing this:\n  x * x ^ \\<omega> * w \\<sqinter> z \\<le> x ^ \\<omega> * v\n  v \\<in> Y \\<and> w \\<le> v \\<and> z \\<le> v\n\ngoal (1 subgoal):\n 1. x * x ^ \\<omega> * w \\<sqinter> z\n    \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "by (meson SUP_upper2)"], ["proof (state)\nthis:\n  x * x ^ \\<omega> * w \\<sqinter> z \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Squnion>w\\<in>Y. \\<Squnion>((\\<sqinter>) (x * x ^ \\<omega> * w) ` Y))\n  \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n       \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "finally"], ["proof (chain)\npicking this:\n  x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) \\<sqinter> (\\<Squnion>y\\<in>Y. y)\n  \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "show \"(x ^ \\<omega>) * (SUP y\\<in>Y . y) = (SUP z\\<in>Y . (x ^ \\<omega>) * z)\""], ["proof (prove)\nusing this:\n  x * \\<Squnion>((*) (x ^ \\<omega>) ` Y) \\<sqinter> (\\<Squnion>y\\<in>Y. y)\n  \\<le> \\<Squnion>((*) (x ^ \\<omega>) ` Y)\n\ngoal (1 subgoal):\n 1. x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n    \\<Squnion>((*) (x ^ \\<omega>) ` Y)", "by (meson SUP_least SUP_upper order.antisym omega_least le_comp)"], ["proof (state)\nthis:\n  x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) (x ^ \\<omega>) ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n     \\<Squnion>((*) (x ^ \\<omega>) ` Y)\n\ngoal (1 subgoal):\n 1. x ^ \\<omega> \\<in> Continuous", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n     \\<Squnion>((*) (x ^ \\<omega>) ` Y)\n\ngoal (1 subgoal):\n 1. x ^ \\<omega> \\<in> Continuous", "using Continuous_def continuous_def"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x ^ \\<omega> * (\\<Squnion>y\\<in>Y. y) =\n     \\<Squnion>((*) (x ^ \\<omega>) ` Y)\n  Continuous \\<equiv> {x. continuous x}\n  continuous ?x \\<equiv>\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     ?x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) ?x ` Y)\n\ngoal (1 subgoal):\n 1. x ^ \\<omega> \\<in> Continuous", "by blast"], ["proof (state)\nthis:\n  x ^ \\<omega> \\<in> Continuous\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"co_continuous x \\<equiv> (\\<forall>Y . co_directed Y \\<longrightarrow> x * (INF y\\<in>Y . y) = (INF y\\<in>Y . x * y))\""], ["", "definition \"Co_continuous \\<equiv> { x . co_continuous x }\""], ["", "lemma directed_dual:\n  \"directed X \\<longleftrightarrow> co_directed (dual ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed X = co_directed (dual ` X)", "by (simp add: directed_def co_directed_def dual_le[THEN sym])"], ["", "lemma dual_dual_image:\n  \"dual ` dual ` X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual ` dual ` X = X", "by (simp add: image_comp)"], ["", "lemma continuous_dual:\n  \"continuous x \\<longleftrightarrow> co_continuous (x ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous x = co_continuous (x ^ o)", "proof (unfold continuous_def co_continuous_def, rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y) \\<Longrightarrow>\n    \\<forall>Y.\n       co_directed Y \\<longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)\n 2. \\<forall>Y.\n       co_directed Y \\<longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) =\n       \\<Sqinter>((*) (x ^ o) ` Y) \\<Longrightarrow>\n    \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "assume 1: \"\\<forall>Y. directed Y \\<longrightarrow> x * (SUP y\\<in>Y . y) = (SUP y\\<in>Y . x * y)\""], ["proof (state)\nthis:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal (2 subgoals):\n 1. \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y) \\<Longrightarrow>\n    \\<forall>Y.\n       co_directed Y \\<longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)\n 2. \\<forall>Y.\n       co_directed Y \\<longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) =\n       \\<Sqinter>((*) (x ^ o) ` Y) \\<Longrightarrow>\n    \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "show \"\\<forall>Y. co_directed Y \\<longrightarrow> x ^ o * (INF y\\<in>Y . y) = (INF y\\<in>Y . x ^ o * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       co_directed Y \\<longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       co_directed Y \\<Longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       co_directed Y \\<Longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "assume \"co_directed Y\""], ["proof (state)\nthis:\n  co_directed Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       co_directed Y \\<Longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "hence \"x ^ o * (INF y\\<in>Y . y) = (INF y\\<in>(dual ` Y) . (x * y) ^ o)\""], ["proof (prove)\nusing this:\n  co_directed Y\n\ngoal (1 subgoal):\n 1. x ^ o * (\\<Sqinter>y\\<in>Y. y) = (\\<Sqinter>y\\<in>dual ` Y. (x * y) ^ o)", "using 1"], ["proof (prove)\nusing this:\n  co_directed Y\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal (1 subgoal):\n 1. x ^ o * (\\<Sqinter>y\\<in>Y. y) = (\\<Sqinter>y\\<in>dual ` Y. (x * y) ^ o)", "by (metis dual_dual_image dual_SUP image_ident image_image dual_comp directed_dual)"], ["proof (state)\nthis:\n  x ^ o * (\\<Sqinter>y\\<in>Y. y) = (\\<Sqinter>y\\<in>dual ` Y. (x * y) ^ o)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       co_directed Y \\<Longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "also"], ["proof (state)\nthis:\n  x ^ o * (\\<Sqinter>y\\<in>Y. y) = (\\<Sqinter>y\\<in>dual ` Y. (x * y) ^ o)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       co_directed Y \\<Longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "have \"... = (INF y\\<in>(dual ` Y) . x ^ o * y ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>y\\<in>dual ` Y. (x * y) ^ o) =\n    (\\<Sqinter>y\\<in>dual ` Y. x ^ o * y ^ o)", "by (meson dual_comp)"], ["proof (state)\nthis:\n  (\\<Sqinter>y\\<in>dual ` Y. (x * y) ^ o) =\n  (\\<Sqinter>y\\<in>dual ` Y. x ^ o * y ^ o)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       co_directed Y \\<Longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>y\\<in>dual ` Y. (x * y) ^ o) =\n  (\\<Sqinter>y\\<in>dual ` Y. x ^ o * y ^ o)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       co_directed Y \\<Longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "have \"... = (INF y\\<in>Y . x ^ o * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>y\\<in>dual ` Y. x ^ o * y ^ o) = \\<Sqinter>((*) (x ^ o) ` Y)", "by (simp add: image_image)"], ["proof (state)\nthis:\n  (\\<Sqinter>y\\<in>dual ` Y. x ^ o * y ^ o) = \\<Sqinter>((*) (x ^ o) ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       co_directed Y \\<Longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "finally"], ["proof (chain)\npicking this:\n  x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "show \"x ^ o * (INF y\\<in>Y . y) = (INF y\\<in>Y . x ^ o * y)\""], ["proof (prove)\nusing this:\n  x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)\n\ngoal (1 subgoal):\n 1. x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)", "."], ["proof (state)\nthis:\n  x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Y.\n     co_directed Y \\<longrightarrow>\n     x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)\n\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       co_directed Y \\<longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) =\n       \\<Sqinter>((*) (x ^ o) ` Y) \\<Longrightarrow>\n    \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       co_directed Y \\<longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) =\n       \\<Sqinter>((*) (x ^ o) ` Y) \\<Longrightarrow>\n    \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "assume 2: \"\\<forall>Y. co_directed Y \\<longrightarrow> x ^ o * (INF y\\<in>Y . y) = (INF y\\<in>Y . x ^ o * y)\""], ["proof (state)\nthis:\n  \\<forall>Y.\n     co_directed Y \\<longrightarrow>\n     x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)\n\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       co_directed Y \\<longrightarrow>\n       x ^ o * (\\<Sqinter>y\\<in>Y. y) =\n       \\<Sqinter>((*) (x ^ o) ` Y) \\<Longrightarrow>\n    \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "show \"\\<forall>Y. directed Y \\<longrightarrow> x * (SUP y\\<in>Y . y) = (SUP y\\<in>Y . x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       directed Y \\<longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "assume \"directed Y\""], ["proof (state)\nthis:\n  directed Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "hence \"x * (SUP y\\<in>Y . y) = (SUP y\\<in>(dual ` Y) . (x ^ o * y) ^ o)\""], ["proof (prove)\nusing this:\n  directed Y\n\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) = (\\<Squnion>y\\<in>dual ` Y. (x ^ o * y) ^ o)", "using 2"], ["proof (prove)\nusing this:\n  directed Y\n  \\<forall>Y.\n     co_directed Y \\<longrightarrow>\n     x ^ o * (\\<Sqinter>y\\<in>Y. y) = \\<Sqinter>((*) (x ^ o) ` Y)\n\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) = (\\<Squnion>y\\<in>dual ` Y. (x ^ o * y) ^ o)", "by (metis directed_dual dual_dual_image image_ident image_image dual_SUP dual_comp dual_dual)"], ["proof (state)\nthis:\n  x * (\\<Squnion>y\\<in>Y. y) = (\\<Squnion>y\\<in>dual ` Y. (x ^ o * y) ^ o)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "also"], ["proof (state)\nthis:\n  x * (\\<Squnion>y\\<in>Y. y) = (\\<Squnion>y\\<in>dual ` Y. (x ^ o * y) ^ o)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "have \"... = (SUP y\\<in>(dual ` Y) . x * y ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>dual ` Y. (x ^ o * y) ^ o) =\n    (\\<Squnion>y\\<in>dual ` Y. x * y ^ o)", "using dual_comp dual_dual"], ["proof (prove)\nusing this:\n  (?x * ?y) ^ o = ?x ^ o * ?y ^ o\n  (?x ^ o) ^ o = ?x\n\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>dual ` Y. (x ^ o * y) ^ o) =\n    (\\<Squnion>y\\<in>dual ` Y. x * y ^ o)", "by auto"], ["proof (state)\nthis:\n  (\\<Squnion>y\\<in>dual ` Y. (x ^ o * y) ^ o) =\n  (\\<Squnion>y\\<in>dual ` Y. x * y ^ o)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>y\\<in>dual ` Y. (x ^ o * y) ^ o) =\n  (\\<Squnion>y\\<in>dual ` Y. x * y ^ o)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "have \"... = (SUP y\\<in>Y . x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>y\\<in>dual ` Y. x * y ^ o) = \\<Squnion>((*) x ` Y)", "by (simp add: image_image)"], ["proof (state)\nthis:\n  (\\<Squnion>y\\<in>dual ` Y. x * y ^ o) = \\<Squnion>((*) x ` Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       directed Y \\<Longrightarrow>\n       x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "finally"], ["proof (chain)\npicking this:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "show \"x * (SUP y\\<in>Y . y) = (SUP y\\<in>Y . x * y)\""], ["proof (prove)\nusing this:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal (1 subgoal):\n 1. x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)", "."], ["proof (state)\nthis:\n  x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>Y.\n     directed Y \\<longrightarrow>\n     x * (\\<Squnion>y\\<in>Y. y) = \\<Squnion>((*) x ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma co_continuous_Co_continuous:\n  \"co_continuous x \\<longleftrightarrow> x \\<in> Co_continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. co_continuous x = (x \\<in> Co_continuous)", "by (simp add: Co_continuous_def)"], ["", "text \\<open>Theorem 53.1 and Theorem 53.2\\<close>"], ["", "lemma Continuous_dual:\n  \"x \\<in> Continuous \\<longleftrightarrow> x ^ o \\<in> Co_continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> Continuous) = (x ^ o \\<in> Co_continuous)", "by (simp add: Co_continuous_def Continuous_def continuous_dual)"], ["", "text \\<open>Theorem 53.2\\<close>"], ["", "lemma one_co_continuous:\n  \"1 \\<in> Co_continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<in> Co_continuous", "using Continuous_dual one_continuous"], ["proof (prove)\nusing this:\n  (?x \\<in> Continuous) = (?x ^ o \\<in> Co_continuous)\n  (1::'a) \\<in> Continuous\n\ngoal (1 subgoal):\n 1. (1::'a) \\<in> Co_continuous", "by auto"], ["", "lemma ascending_chain_dual:\n  \"ascending_chain f \\<longleftrightarrow> descending_chain (dual o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ascending_chain f = descending_chain (dual \\<circ> f)", "using ascending_chain_def descending_chain_def dual_le"], ["proof (prove)\nusing this:\n  ascending_chain ?f \\<equiv> \\<forall>n. ?f n \\<le> ?f (Suc n)\n  descending_chain ?f \\<equiv> \\<forall>n. ?f (Suc n) \\<le> ?f n\n  (?x \\<le> ?y) = (?y ^ o \\<le> ?x ^ o)\n\ngoal (1 subgoal):\n 1. ascending_chain f = descending_chain (dual \\<circ> f)", "by auto"], ["", "lemma co_continuous_dist_descending_chain:\n  assumes \"x \\<in> Co_continuous\"\n      and \"descending_chain f\"\n    shows \"x * (INF n::nat . f n) = (INF n::nat . x * f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<Sqinter>range f = (\\<Sqinter>n. x * f n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * \\<Sqinter>range f = (\\<Sqinter>n. x * f n)", "have \"x ^ o * (SUP n::nat . (dual o f) n) = (SUP n::nat . x ^ o * (dual o f) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ o * \\<Squnion>range (dual \\<circ> f) =\n    (\\<Squnion>n. x ^ o * (dual \\<circ> f) n)", "by (smt assms Continuous_dual SUP_cong ascending_chain_dual continuous_dist_ascending_chain descending_chain_def dual_dual o_def)"], ["proof (state)\nthis:\n  x ^ o * \\<Squnion>range (dual \\<circ> f) =\n  (\\<Squnion>n. x ^ o * (dual \\<circ> f) n)\n\ngoal (1 subgoal):\n 1. x * \\<Sqinter>range f = (\\<Sqinter>n. x * f n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x ^ o * \\<Squnion>range (dual \\<circ> f) =\n  (\\<Squnion>n. x ^ o * (dual \\<circ> f) n)\n\ngoal (1 subgoal):\n 1. x * \\<Sqinter>range f = (\\<Sqinter>n. x * f n)", "by (smt INF_cong dual_SUP dual_comp dual_dual o_def)"], ["proof (state)\nthis:\n  x * \\<Sqinter>range f = (\\<Sqinter>n. x * f n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 53.2\\<close>"], ["", "lemma assertion_co_continuous:\n  \"x \\<in> assertion \\<Longrightarrow> x \\<in> Co_continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assertion \\<Longrightarrow> x \\<in> Co_continuous", "by (smt Continuous_dual assert_iff_assume assumption_continuous dual_dual)"], ["", "text \\<open>Theorem 53.2\\<close>"], ["", "lemma assumption_co_continuous:\n  \"x \\<in> assumption \\<Longrightarrow> x \\<in> Co_continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> assumption \\<Longrightarrow> x \\<in> Co_continuous", "by (smt Continuous_dual assert_iff_assume assertion_continuous dual_dual)"], ["", "text \\<open>Theorem 53.2\\<close>"], ["", "lemma mult_co_continuous:\n  \"x \\<in> Co_continuous \\<Longrightarrow> y \\<in> Co_continuous \\<Longrightarrow> x * y \\<in> Co_continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> Co_continuous; y \\<in> Co_continuous\\<rbrakk>\n    \\<Longrightarrow> x * y \\<in> Co_continuous", "by (smt Continuous_dual dual_comp dual_dual mult_continuous)"], ["", "text \\<open>Theorem 53.2\\<close>"], ["", "lemma sup_co_continuous:\n  \"x \\<in> Co_continuous \\<Longrightarrow> y \\<in> Co_continuous \\<Longrightarrow> x \\<squnion> y \\<in> Co_continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> Co_continuous; y \\<in> Co_continuous\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y \\<in> Co_continuous", "by (smt Continuous_dual dual_sup dual_dual inf_continuous)"], ["", "text \\<open>Theorem 53.2\\<close>"], ["", "lemma inf_co_continuous:\n  \"x \\<in> Co_continuous \\<Longrightarrow> y \\<in> Co_continuous \\<Longrightarrow> x \\<sqinter> y \\<in> Co_continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> Co_continuous; y \\<in> Co_continuous\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<in> Co_continuous", "by (smt Continuous_dual dual_inf dual_dual sup_continuous)"], ["", "text \\<open>Theorem 53.2\\<close>"], ["", "lemma dual_omega_co_continuous:\n  \"x \\<in> Co_continuous \\<Longrightarrow> x ^ \\<mho> \\<in> Co_continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Co_continuous \\<Longrightarrow> x ^ \\<mho> \\<in> Co_continuous", "by (smt Continuous_dual dual_omega_def dual_dual omega_continuous)"], ["", "text \\<open>Theorem 53.2\\<close>"], ["", "lemma star_co_continuous:\n  \"x \\<in> Co_continuous \\<Longrightarrow> x ^ * \\<in> Co_continuous\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Co_continuous \\<Longrightarrow> x ^ * \\<in> Co_continuous", "by (smt Continuous_dual dual_star_def dual_dual dual_star_continuous)"], ["", "lemma dual_omega_iterate:\n  assumes \"y \\<in> Co_continuous\"\n    shows \"y ^ \\<mho> * z = (INF n::nat . ((\\<lambda>x . y * x \\<squnion> z) ^ n) top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ^ \\<mho> * z =\n    (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)", "proof (rule order.antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. y ^ \\<mho> * z\n    \\<le> (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n 2. (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n    \\<le> y ^ \\<mho> * z", "show \"y ^ \\<mho> * z \\<le> (INF n::nat . ((\\<lambda>x . y * x \\<squnion> z) ^ n) top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ^ \\<mho> * z\n    \\<le> (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)", "proof (rule INF_greatest)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       y ^ \\<mho> * z \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       y ^ \\<mho> * z \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>", "show \"y ^ \\<mho> * z \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ^ \\<mho> * z \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y ^ \\<mho> * z \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ 0) \\<top>\n 2. \\<And>n.\n       y ^ \\<mho> * z\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top> \\<Longrightarrow>\n       y ^ \\<mho> * z\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>", "apply (metis power_zero_id id_def top_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       y ^ \\<mho> * z\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top> \\<Longrightarrow>\n       y ^ \\<mho> * z\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>", "by (smt dual_omega_comp_fix le_comp mult_assoc order_refl sup_mono power_succ_unfold_ext)"], ["proof (state)\nthis:\n  y ^ \\<mho> * z \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y ^ \\<mho> * z\n  \\<le> (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n    \\<le> y ^ \\<mho> * z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n    \\<le> y ^ \\<mho> * z", "have 1: \"descending_chain (\\<lambda>n . ((\\<lambda>x. y * x \\<squnion> z) ^ n) top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. descending_chain\n     (\\<lambda>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)", "proof (unfold descending_chain_def, rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>", "show \"((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) top \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>\n    \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. y * x \\<squnion> z) ^ Suc 0) \\<top>\n    \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ 0) \\<top>\n 2. \\<And>n.\n       ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top> \\<Longrightarrow>\n       ((\\<lambda>x. y * x \\<squnion> z) ^ Suc (Suc n)) \\<top>\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>", "apply (metis power_zero_id id_def top_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top> \\<Longrightarrow>\n       ((\\<lambda>x. y * x \\<squnion> z) ^ Suc (Suc n)) \\<top>\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>", "by (smt power_succ_unfold_ext sup_mono order_refl le_comp)"], ["proof (state)\nthis:\n  ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>\n  \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  descending_chain\n   (\\<lambda>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n    \\<le> y ^ \\<mho> * z", "have \"(INF n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) top) \\<le> (INF n. ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n    \\<le> (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>)", "apply (rule INF_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n       \\<le> ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>", "apply (unfold power_succ_unfold_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n       \\<le> y * ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top> \\<squnion> z", "by (smt power_succ_unfold_ext INF_lower UNIV_I)"], ["proof (state)\nthis:\n  (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n  \\<le> (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n    \\<le> y ^ \\<mho> * z", "thus \"(INF n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) top) \\<le> y ^ \\<mho> * z\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n  \\<le> (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n    \\<le> y ^ \\<mho> * z", "using 1"], ["proof (prove)\nusing this:\n  (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n  \\<le> (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ Suc n) \\<top>)\n  descending_chain\n   (\\<lambda>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n    \\<le> y ^ \\<mho> * z", "by (smt assms INF_cong co_continuous_dist_descending_chain power_succ_unfold_ext sup_INF sup_commute dual_omega_greatest)"], ["proof (state)\nthis:\n  (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> z) ^ n) \\<top>)\n  \\<le> y ^ \\<mho> * z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dual_omega_iterate_one:\n  \"y \\<in> Co_continuous \\<Longrightarrow> y ^ \\<mho> = (INF n::nat . ((\\<lambda>x . y * x \\<squnion> 1) ^ n) top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> Co_continuous \\<Longrightarrow>\n    y ^ \\<mho> =\n    (\\<Sqinter>n. ((\\<lambda>x. y * x \\<squnion> (1::'a)) ^ n) \\<top>)", "by (metis dual_omega_iterate mult.right_neutral)"], ["", "subclass ccpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ccpo Sup (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A x.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion>A\n 2. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>A \\<le> z", "apply (simp add: Sup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>A \\<le> z", "using Sup_least"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> ?z) \\<Longrightarrow>\n  \\<Squnion>?A \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Complete_Partial_Order.chain (\\<le>) A;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion>A \\<le> z", "by auto"], ["", "end"], ["", "class post_mbt_algebra_ext = post_mbt_algebra +\n  assumes post_sub_fusion: \"post 1 * neg_assume q \\<le> post (neg_assume q ^ o)\"\nbegin"], ["", "lemma post_fusion:\n  \"post (neg_assume q ^ o) = post 1 * neg_assume q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post (neg_assume q ^ o) = post (1::'a) * neg_assume q", "using order.antisym neg_assumption post_dual_below_post_one post_sub_fusion"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n  neg_assume ?x \\<in> assumption\n  ?q \\<in> assumption \\<Longrightarrow>\n  post (?q ^ o) \\<le> post (1::'a) * ?q\n  post (1::'a) * neg_assume ?q \\<le> post (neg_assume ?q ^ o)\n\ngoal (1 subgoal):\n 1. post (neg_assume q ^ o) = post (1::'a) * neg_assume q", "by auto"], ["", "lemma post_dual_post_one:\n  \"q \\<in> assumption \\<Longrightarrow> post 1 * q \\<le> post (q ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> assumption \\<Longrightarrow> post (1::'a) * q \\<le> post (q ^ o)", "by (metis assumption_neg_assume post_sub_fusion)"], ["", "end"], ["", "instance MonoTran :: (complete_boolean_algebra) post_mbt_algebra_ext"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, post_mbt_algebra_ext_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q. post 1 * neg_assume q \\<le> post (neg_assume q ^ o)", "fix q :: \"'a MonoTran\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q. post 1 * neg_assume q \\<le> post (neg_assume q ^ o)", "show \"post 1 * neg_assume q \\<le> post (neg_assume q ^ o)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post 1 * neg_assume q \\<le> post (neg_assume q ^ o)", "proof (unfold neg_assume_def, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       mono q \\<Longrightarrow>\n       post_fun (id \\<top>) \\<circ>\n       (dual_fun q \\<circ> \\<top>) \\<squnion> id\n       \\<le> post_fun\n              (dual_fun ((dual_fun q \\<circ> \\<top>) \\<squnion> id) \\<top>)", "fix f :: \"'a \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       mono q \\<Longrightarrow>\n       post_fun (id \\<top>) \\<circ>\n       (dual_fun q \\<circ> \\<top>) \\<squnion> id\n       \\<le> post_fun\n              (dual_fun ((dual_fun q \\<circ> \\<top>) \\<squnion> id) \\<top>)", "assume \"mono f\""], ["proof (state)\nthis:\n  mono f\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       mono q \\<Longrightarrow>\n       post_fun (id \\<top>) \\<circ>\n       (dual_fun q \\<circ> \\<top>) \\<squnion> id\n       \\<le> post_fun\n              (dual_fun ((dual_fun q \\<circ> \\<top>) \\<squnion> id) \\<top>)", "have \"\\<forall>x. top \\<le> -f bot \\<squnion> x \\<longrightarrow> \\<not> f bot \\<le> x \\<longrightarrow> top \\<le> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<top> \\<le> - f \\<bottom> \\<squnion> x \\<longrightarrow>\n       \\<not> f \\<bottom> \\<le> x \\<longrightarrow> \\<top> \\<le> \\<bottom>", "by (metis (no_types, lifting) double_compl inf.sup_bot_left inf_compl_bot sup.order_iff sup_bot_left sup_commute sup_inf_distrib1 top.extremum_uniqueI)"], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<top> \\<le> - f \\<bottom> \\<squnion> x \\<longrightarrow>\n     \\<not> f \\<bottom> \\<le> x \\<longrightarrow> \\<top> \\<le> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       mono q \\<Longrightarrow>\n       post_fun (id \\<top>) \\<circ>\n       (dual_fun q \\<circ> \\<top>) \\<squnion> id\n       \\<le> post_fun\n              (dual_fun ((dual_fun q \\<circ> \\<top>) \\<squnion> id) \\<top>)", "hence \"post_fun top \\<circ> (dual_fun f \\<circ> top) \\<squnion> id \\<le> post_fun (f bot)\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     \\<top> \\<le> - f \\<bottom> \\<squnion> x \\<longrightarrow>\n     \\<not> f \\<bottom> \\<le> x \\<longrightarrow> \\<top> \\<le> \\<bottom>\n\ngoal (1 subgoal):\n 1. post_fun \\<top> \\<circ> (dual_fun f \\<circ> \\<top>) \\<squnion> id\n    \\<le> post_fun (f \\<bottom>)", "by (simp add: dual_fun_def le_fun_def post_fun_def)"], ["proof (state)\nthis:\n  post_fun \\<top> \\<circ> (dual_fun f \\<circ> \\<top>) \\<squnion> id\n  \\<le> post_fun (f \\<bottom>)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       mono q \\<Longrightarrow>\n       post_fun (id \\<top>) \\<circ>\n       (dual_fun q \\<circ> \\<top>) \\<squnion> id\n       \\<le> post_fun\n              (dual_fun ((dual_fun q \\<circ> \\<top>) \\<squnion> id) \\<top>)", "thus \"post_fun (id top) \\<circ> (dual_fun f \\<circ> top) \\<squnion> id \\<le> post_fun (dual_fun ((dual_fun f \\<circ> top) \\<squnion> id) top)\""], ["proof (prove)\nusing this:\n  post_fun \\<top> \\<circ> (dual_fun f \\<circ> \\<top>) \\<squnion> id\n  \\<le> post_fun (f \\<bottom>)\n\ngoal (1 subgoal):\n 1. post_fun (id \\<top>) \\<circ> (dual_fun f \\<circ> \\<top>) \\<squnion> id\n    \\<le> post_fun\n           (dual_fun ((dual_fun f \\<circ> \\<top>) \\<squnion> id) \\<top>)", "by simp"], ["proof (state)\nthis:\n  post_fun (id \\<top>) \\<circ> (dual_fun f \\<circ> \\<top>) \\<squnion> id\n  \\<le> post_fun\n         (dual_fun ((dual_fun f \\<circ> \\<top>) \\<squnion> id) \\<top>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  post 1 * neg_assume q \\<le> post (neg_assume q ^ o)\n\ngoal:\nNo subgoals!", "qed"], ["", "class complete_mbt_algebra_ext = complete_mbt_algebra + post_mbt_algebra_ext"], ["", "instance MonoTran :: (complete_boolean_algebra) complete_mbt_algebra_ext"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a MonoTran, complete_mbt_algebra_ext_class)", ".."], ["", "end"]]}