{"file_name": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras/Domain.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Correctness_Algebras", "problem_names": ["lemma d_restrict_equals:\n  \"x = d(x) * x\"", "lemma d_involutive:\n  \"d(d(x)) = d(x)\"", "lemma d_fixpoint:\n  \"(\\<exists>y . x = d(y)) \\<longleftrightarrow> x = d(x)\"", "lemma d_type:\n  \"\\<forall>P . (\\<forall>x . x = d(x) \\<longrightarrow> P(x)) \\<longleftrightarrow> (\\<forall>x . P(d(x)))\"", "lemma d_mult_sub:\n  \"d(x * y) \\<le> d(x)\"", "lemma d_sub_one:\n  \"x \\<le> 1 \\<Longrightarrow> x \\<le> d(x)\"", "lemma d_strict:\n  \"d(x) = bot \\<longleftrightarrow> x = bot\"", "lemma d_one:\n  \"d(1) = 1\"", "lemma d_below_one:\n  \"d(x) \\<le> 1\"", "lemma d_isotone:\n  \"x \\<le> y \\<Longrightarrow> d(x) \\<le> d(y)\"", "lemma d_plus_left_upper_bound:\n  \"d(x) \\<le> d(x \\<squnion> y)\"", "lemma d_export:\n  \"d(d(x) * y) = d(x) * d(y)\"", "lemma d_idempotent:\n  \"d(x) * d(x) = d(x)\"", "lemma d_commutative:\n  \"d(x) * d(y) = d(y) * d(x)\"", "lemma d_least_left_preserver:\n  \"x \\<le> d(y) * x \\<longleftrightarrow> d(x) \\<le> d(y)\"", "lemma d_weak_locality:\n  \"x * y = bot \\<longleftrightarrow> x * d(y) = bot\"", "lemma d_sup_closed:\n  \"d(d(x) \\<squnion> d(y)) = d(x) \\<squnion> d(y)\"", "lemma d_mult_closed:\n  \"d(d(x) * d(y)) = d(x) * d(y)\"", "lemma d_mult_left_lower_bound:\n  \"d(x) * d(y) \\<le> d(x)\"", "lemma d_mult_greatest_lower_bound:\n  \"d(x) \\<le> d(y) * d(z) \\<longleftrightarrow> d(x) \\<le> d(y) \\<and> d(x) \\<le> d(z)\"", "lemma d_mult_left_absorb_sup:\n  \"d(x) * (d(x) \\<squnion> d(y)) = d(x)\"", "lemma d_sup_left_absorb_mult:\n  \"d(x) \\<squnion> d(x) * d(y) = d(x)\"", "lemma d_sup_left_dist_mult:\n  \"d(x) \\<squnion> d(y) * d(z) = (d(x) \\<squnion> d(y)) * (d(x) \\<squnion> d(z))\"", "lemma d_order:\n  \"d(x) \\<le> d(y) \\<longleftrightarrow> d(x) = d(x) * d(y)\"", "lemma d_mult_below:\n  \"d(x) * y \\<le> y\"", "lemma d_preserves_equation:\n  \"d(y) * x \\<le> x * d(y) \\<longleftrightarrow> d(y) * x = d(y) * x * d(y)\"", "lemma a_greatest_left_absorber:\n  \"a(x) * y = bot \\<longleftrightarrow> a(x) \\<le> a(y)\"", "lemma a_mult_d:\n  \"a(x * y) = a(x * d(y))\"", "lemma a_d_closed:\n  \"d(a(x)) = a(x)\"", "lemma a_plus_left_lower_bound:\n  \"a(x \\<squnion> y) \\<le> a(x)\"", "lemma a_mult_sup:\n  \"a(x) * (y \\<squnion> x) = a(x) * y\"", "lemma a_3:\n  \"a(x) * a(y) * d(x \\<squnion> y) = bot\"", "lemma a_export:\n  \"a(a(x) * y) = d(x) \\<squnion> a(y)\"", "lemma a_fixpoint:\n  \"\\<forall>x . (a(x) = x \\<longrightarrow> (\\<forall>y . y = bot))\"", "lemma a_strict:\n  \"a(x) = 1 \\<longleftrightarrow> x = bot\"", "lemma d_complement_zero:\n  \"d(x) * a(x) = bot\"", "lemma a_complement_zero:\n  \"a(x) * d(x) = bot\"", "lemma a_shunting_zero:\n  \"a(x) * d(y) = bot \\<longleftrightarrow> a(x) \\<le> a(y)\"", "lemma a_antitone:\n  \"x \\<le> y \\<Longrightarrow> a(y) \\<le> a(x)\"", "lemma a_mult_deMorgan:\n  \"a(a(x) * a(y)) = d(x \\<squnion> y)\"", "lemma a_mult_deMorgan_1:\n  \"a(a(x) * a(y)) = d(x) \\<squnion> d(y)\"", "lemma a_mult_deMorgan_2:\n  \"a(d(x) * d(y)) = a(x) \\<squnion> a(y)\"", "lemma a_plus_deMorgan:\n  \"a(a(x) \\<squnion> a(y)) = d(x) * d(y)\"", "lemma a_plus_deMorgan_1:\n  \"a(d(x) \\<squnion> d(y)) = a(x) * a(y)\"", "lemma a_mult_left_upper_bound:\n  \"a(x) \\<le> a(x * y)\"", "lemma d_a_closed:\n  \"a(d(x)) = a(x)\"", "lemma a_export_d:\n  \"a(d(x) * y) = a(x) \\<squnion> a(y)\"", "lemma a_7:\n  \"d(x) * a(d(y) \\<squnion> d(z)) = d(x) * a(y) * a(z)\"", "lemma d_a_shunting:\n  \"d(x) * a(y) \\<le> d(z) \\<longleftrightarrow> d(x) \\<le> d(z) \\<squnion> d(y)\"", "lemma d_d_shunting:\n  \"d(x) * d(y) \\<le> d(z) \\<longleftrightarrow> d(x) \\<le> d(z) \\<squnion> a(y)\"", "lemma d_cancellation_1:\n  \"d(x) \\<le> d(y) \\<squnion> (d(x) * a(y))\"", "lemma d_cancellation_2:\n  \"(d(z) \\<squnion> d(y)) * a(y) \\<le> d(z)\"", "lemma a_sup_closed:\n  \"d(a(x) \\<squnion> a(y)) = a(x) \\<squnion> a(y)\"", "lemma a_mult_closed:\n  \"d(a(x) * a(y)) = a(x) * a(y)\"", "lemma d_a_shunting_zero:\n  \"d(x) * a(y) = bot \\<longleftrightarrow> d(x) \\<le> d(y)\"", "lemma d_d_shunting_zero:\n  \"d(x) * d(y) = bot \\<longleftrightarrow> d(x) \\<le> a(y)\"", "lemma d_compl_intro:\n  \"d(x) \\<squnion> d(y) = d(x) \\<squnion> a(x) * d(y)\"", "lemma a_compl_intro:\n  \"a(x) \\<squnion> a(y) = a(x) \\<squnion> d(x) * a(y)\"", "lemma kat_2:\n  \"y * a(z) \\<le> a(x) * y \\<Longrightarrow> d(x) * y * a(z) = bot\"", "lemma kat_3:\n  \"d(x) * y * a(z) = bot \\<Longrightarrow> d(x) * y = d(x) * y * d(z)\"", "lemma kat_4:\n  \"d(x) * y = d(x) * y * d(z) \\<Longrightarrow> d(x) * y \\<le> y * d(z)\"", "lemma kat_2_equiv:\n  \"y * a(z) \\<le> a(x) * y \\<longleftrightarrow> d(x) * y * a(z) = bot\"", "lemma kat_4_equiv:\n  \"d(x) * y = d(x) * y * d(z) \\<longleftrightarrow> d(x) * y \\<le> y * d(z)\"", "lemma kat_3_equiv_opp:\n  \"a(z) * y * d(x) = bot \\<longleftrightarrow> y * d(x) = d(z) * y * d(x)\"", "lemma kat_4_equiv_opp:\n  \"y * d(x) = d(z) * y * d(x) \\<longleftrightarrow> y * d(x) \\<le> d(z) * y\"", "lemma d_restrict_iff:\n  \"(x \\<le> y) \\<longleftrightarrow> (x \\<le> d(x) * y)\"", "lemma d_restrict_iff_1:\n  \"(d(x) * y \\<le> z) \\<longleftrightarrow> (d(x) * y \\<le> d(x) * z)\""], "translations": [["", "lemma d_restrict_equals:\n  \"x = d(x) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = d x * x", "by (metis sup_commute d_plus_one d_restrict mult_left_one mult_right_dist_sup)"], ["", "lemma d_involutive:\n  \"d(d(x)) = d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d x) = d x", "by (metis d_mult_d mult_left_one)"], ["", "lemma d_fixpoint:\n  \"(\\<exists>y . x = d(y)) \\<longleftrightarrow> x = d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y. x = d y) = (x = d x)", "using d_involutive"], ["proof (prove)\nusing this:\n  d (d ?x) = d ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>y. x = d y) = (x = d x)", "by auto"], ["", "lemma d_type:\n  \"\\<forall>P . (\\<forall>x . x = d(x) \\<longrightarrow> P(x)) \\<longleftrightarrow> (\\<forall>x . P(d(x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P.\n       (\\<forall>x. x = d x \\<longrightarrow> P x) = (\\<forall>x. P (d x))", "by (metis d_involutive)"], ["", "lemma d_mult_sub:\n  \"d(x * y) \\<le> d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (x * y) \\<le> d x", "by (metis d_dist_sup d_mult_d d_plus_one le_iff_sup mult_left_sub_dist_sup_left mult_1_right)"], ["", "lemma d_sub_one:\n  \"x \\<le> 1 \\<Longrightarrow> x \\<le> d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> x \\<le> d x", "by (metis d_restrict_equals mult_right_isotone mult_1_right)"], ["", "lemma d_strict:\n  \"d(x) = bot \\<longleftrightarrow> x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x = bot) = (x = bot)", "by (metis d_restrict_equals d_zero mult_left_zero)"], ["", "lemma d_one:\n  \"d(1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (1::'a) = (1::'a)", "by (metis d_restrict_equals mult_1_right)"], ["", "lemma d_below_one:\n  \"d(x) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (d x)", "by (simp add: d_plus_one le_iff_sup)"], ["", "lemma d_isotone:\n  \"x \\<le> y \\<Longrightarrow> d(x) \\<le> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> d x \\<le> d y", "by (metis d_dist_sup le_iff_sup)"], ["", "lemma d_plus_left_upper_bound:\n  \"d(x) \\<le> d(x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<le> d (x \\<squnion> y)", "by (simp add: d_isotone)"], ["", "lemma d_export:\n  \"d(d(x) * y) = d(x) * d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d x * y) = d x * d y", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d (d x * y) \\<le> d x * d y\n 2. d x * d y \\<le> d (d x * y)", "apply (metis d_below_one d_involutive d_mult_sub d_restrict_equals d_isotone d_mult_d mult_isotone mult_left_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * d y \\<le> d (d x * y)", "by (metis d_below_one d_sub_one coreflexive_mult_closed d_mult_d)"], ["", "lemma d_idempotent:\n  \"d(x) * d(x) = d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent (d x)", "by (metis d_export d_restrict_equals)"], ["", "lemma d_commutative:\n  \"d(x) * d(y) = d(y) * d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * d y = d y * d x", "by (metis ils.il_inf_associative order.antisym d_export d_mult_d d_mult_sub d_one d_restrict_equals mult_isotone mult_left_one)"], ["", "lemma d_least_left_preserver:\n  \"x \\<le> d(y) * x \\<longleftrightarrow> d(x) \\<le> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> d y * x) = (d x \\<le> d y)", "by (metis d_below_one d_involutive d_mult_sub d_restrict_equals order.eq_iff mult_left_isotone mult_left_one)"], ["", "lemma d_weak_locality:\n  \"x * y = bot \\<longleftrightarrow> x * d(y) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y = bot) = (x * d y = bot)", "by (metis d_mult_d d_strict)"], ["", "lemma d_sup_closed:\n  \"d(d(x) \\<squnion> d(y)) = d(x) \\<squnion> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d x \\<squnion> d y) = d x \\<squnion> d y", "by (simp add: d_involutive d_dist_sup)"], ["", "lemma d_mult_closed:\n  \"d(d(x) * d(y)) = d(x) * d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (d x * d y) = d x * d y", "using d_export d_mult_d"], ["proof (prove)\nusing this:\n  d (d ?x * ?y) = d ?x * d ?y\n  d (?x * ?y) = d (?x * d ?y)\n\ngoal (1 subgoal):\n 1. d (d x * d y) = d x * d y", "by auto"], ["", "lemma d_mult_left_lower_bound:\n  \"d(x) * d(y) \\<le> d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * d y \\<le> d x", "by (metis d_export d_involutive d_mult_sub)"], ["", "lemma d_mult_greatest_lower_bound:\n  \"d(x) \\<le> d(y) * d(z) \\<longleftrightarrow> d(x) \\<le> d(y) \\<and> d(x) \\<le> d(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x \\<le> d y * d z) = (d x \\<le> d y \\<and> d x \\<le> d z)", "by (metis d_commutative d_idempotent d_mult_left_lower_bound mult_isotone order_trans)"], ["", "lemma d_mult_left_absorb_sup:\n  \"d(x) * (d(x) \\<squnion> d(y)) = d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * (d x \\<squnion> d y) = d x", "by (metis sup_commute d_idempotent d_plus_one mult_left_dist_sup mult_1_right)"], ["", "lemma d_sup_left_absorb_mult:\n  \"d(x) \\<squnion> d(x) * d(y) = d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<squnion> d x * d y = d x", "using d_mult_left_lower_bound sup.absorb_iff1"], ["proof (prove)\nusing this:\n  d ?x * d ?y \\<le> d ?x\n  (?b \\<le> ?a) = (?a \\<squnion> ?b = ?a)\n\ngoal (1 subgoal):\n 1. d x \\<squnion> d x * d y = d x", "by auto"], ["", "lemma d_sup_left_dist_mult:\n  \"d(x) \\<squnion> d(y) * d(z) = (d(x) \\<squnion> d(y)) * (d(x) \\<squnion> d(z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<squnion> d y * d z = (d x \\<squnion> d y) * (d x \\<squnion> d z)", "by (smt sup_assoc d_commutative d_idempotent d_mult_left_absorb_sup mult_left_dist_sup mult_right_dist_sup)"], ["", "lemma d_order:\n  \"d(x) \\<le> d(y) \\<longleftrightarrow> d(x) = d(x) * d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x \\<le> d y) = (d x = d x * d y)", "by (metis d_mult_greatest_lower_bound d_mult_left_absorb_sup le_iff_sup order_refl)"], ["", "lemma d_mult_below:\n  \"d(x) * y \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y \\<le> y", "by (metis sup_left_divisibility d_plus_one mult_left_one mult_right_dist_sup)"], ["", "lemma d_preserves_equation:\n  \"d(y) * x \\<le> x * d(y) \\<longleftrightarrow> d(y) * x = d(y) * x * d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d y * x \\<le> x * d y) = (d y * x = d y * x * d y)", "by (simp add: d_below_one d_idempotent test_preserves_equation)"], ["", "end"], ["", "class left_zero_antidomain_semiring = idempotent_left_zero_semiring + dom + uminus +\n  assumes a_restrict   : \"-x * x = bot\"\n  assumes a_plus_mult_d: \"-(x * y) \\<squnion> -(x * --y) = -(x * --y)\"\n  assumes a_complement : \"--x \\<squnion> -x = 1\"\n  assumes d_def        : \"d(x) = --x\"\nbegin"], ["", "sublocale aa: a_algebra where minus = \"\\<lambda>x y . -(-x \\<squnion> y)\" and uminus = uminus and inf = times and sup = sup and bot = bot and less_eq = less_eq and less = less and top = 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.a_algebra (\\<lambda>x y. - (- x \\<squnion> y)) uminus (*)\n     (\\<squnion>) bot (\\<le>) (<) (1::'a)", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. - x * x = bot\n 2. \\<And>x. - x \\<squnion> - - x = (1::'a)\n 3. \\<And>x y. - (x * y) \\<le> - (x * - - y)\n 4. \\<And>x y. - (- - x \\<squnion> - y) = - (- - x \\<squnion> - y)", "apply (simp add: a_restrict)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. - x \\<squnion> - - x = (1::'a)\n 2. \\<And>x y. - (x * y) \\<le> - (x * - - y)\n 3. \\<And>x y. - (- - x \\<squnion> - y) = - (- - x \\<squnion> - y)", "using a_complement sup_commute"], ["proof (prove)\nusing this:\n  - - ?x \\<squnion> - ?x = (1::'a)\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (3 subgoals):\n 1. \\<And>x. - x \\<squnion> - - x = (1::'a)\n 2. \\<And>x y. - (x * y) \\<le> - (x * - - y)\n 3. \\<And>x y. - (- - x \\<squnion> - y) = - (- - x \\<squnion> - y)", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. - (x * y) \\<le> - (x * - - y)\n 2. \\<And>x y. - (- - x \\<squnion> - y) = - (- - x \\<squnion> - y)", "apply (simp add: a_plus_mult_d le_iff_sup)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. - (- - x \\<squnion> - y) = - (- - x \\<squnion> - y)", "by simp"], ["", "subclass left_zero_domain_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.left_zero_domain_semiring (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot\n     d", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. x \\<squnion> d x * x = d x * x\n 2. \\<And>x y. d (x * y) = d (x * d y)\n 3. \\<And>x. d x \\<squnion> (1::'a) = (1::'a)\n 4. d bot = bot\n 5. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y", "apply (simp add: d_def aa.double_complement_above)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y. d (x * y) = d (x * d y)\n 2. \\<And>x. d x \\<squnion> (1::'a) = (1::'a)\n 3. d bot = bot\n 4. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y", "apply (simp add: aa.a_d.d3_eq d_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. d x \\<squnion> (1::'a) = (1::'a)\n 2. d bot = bot\n 3. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y", "apply (simp add: d_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d bot = bot\n 2. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y", "apply (simp add: d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. d (x \\<squnion> y) = d x \\<squnion> d y", "by (simp add: d_def aa.l15)"], ["", "subclass tests"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.tests (1::'a) (*) uminus (\\<squnion>) bot (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y z. - x * (- y * - z) = - x * - y * - z\n 2. \\<And>x y. - x * - y = - y * - x\n 3. \\<And>x y. - x = - (- - x * - y) * - (- - x * - - y)\n 4. \\<And>x y. - x * - y = - - (- x * - y)\n 5. bot = (THE x. \\<forall>y. x = - y * - - y)\n 6. (1::'a) = - bot\n 7. \\<And>x y. - x \\<squnion> - y = - (- - x * - - y)\n 8. \\<And>x y. (- x \\<le> - y) = (- x * - y = - x)\n 9. \\<And>x y. (- x < - y) = (- x \\<le> - y \\<and> \\<not> - y \\<le> - x)", "apply (simp add: mult_assoc)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y. - x * - y = - y * - x\n 2. \\<And>x y. - x = - (- - x * - y) * - (- - x * - - y)\n 3. \\<And>x y. - x * - y = - - (- x * - y)\n 4. bot = (THE x. \\<forall>y. x = - y * - - y)\n 5. (1::'a) = - bot\n 6. \\<And>x y. - x \\<squnion> - y = - (- - x * - - y)\n 7. \\<And>x y. (- x \\<le> - y) = (- x * - y = - x)\n 8. \\<And>x y. (- x < - y) = (- x \\<le> - y \\<and> \\<not> - y \\<le> - x)", "apply (simp add: aa.sba_dual.sub_commutative)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y. - x = - (- - x * - y) * - (- - x * - - y)\n 2. \\<And>x y. - x * - y = - - (- x * - y)\n 3. bot = (THE x. \\<forall>y. x = - y * - - y)\n 4. (1::'a) = - bot\n 5. \\<And>x y. - x \\<squnion> - y = - (- - x * - - y)\n 6. \\<And>x y. (- x \\<le> - y) = (- x * - y = - x)\n 7. \\<And>x y. (- x < - y) = (- x \\<le> - y \\<and> \\<not> - y \\<le> - x)", "apply (simp add: aa.sba_dual.sub_complement)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y. - x * - y = - - (- x * - y)\n 2. bot = (THE x. \\<forall>y. x = - y * - - y)\n 3. (1::'a) = - bot\n 4. \\<And>x y. - x \\<squnion> - y = - (- - x * - - y)\n 5. \\<And>x y. (- x \\<le> - y) = (- x * - y = - x)\n 6. \\<And>x y. (- x < - y) = (- x \\<le> - y \\<and> \\<not> - y \\<le> - x)", "using aa.sba_dual.sub_sup_closed"], ["proof (prove)\nusing this:\n  - ?x * - ?y = - - (- ?x * - ?y)\n\ngoal (6 subgoals):\n 1. \\<And>x y. - x * - y = - - (- x * - y)\n 2. bot = (THE x. \\<forall>y. x = - y * - - y)\n 3. (1::'a) = - bot\n 4. \\<And>x y. - x \\<squnion> - y = - (- - x * - - y)\n 5. \\<And>x y. (- x \\<le> - y) = (- x * - y = - x)\n 6. \\<And>x y. (- x < - y) = (- x \\<le> - y \\<and> \\<not> - y \\<le> - x)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. bot = (THE x. \\<forall>y. x = - y * - - y)\n 2. (1::'a) = - bot\n 3. \\<And>x y. - x \\<squnion> - y = - (- - x * - - y)\n 4. \\<And>x y. (- x \\<le> - y) = (- x * - y = - x)\n 5. \\<And>x y. (- x < - y) = (- x \\<le> - y \\<and> \\<not> - y \\<le> - x)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. (1::'a) = - bot\n 2. \\<And>x y. - x \\<squnion> - y = - (- - x * - - y)\n 3. \\<And>x y. (- x \\<le> - y) = (- x * - y = - x)\n 4. \\<And>x y. (- x < - y) = (- x \\<le> - y \\<and> \\<not> - y \\<le> - x)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. - x \\<squnion> - y = - (- - x * - - y)\n 2. \\<And>x y. (- x \\<le> - y) = (- x * - y = - x)\n 3. \\<And>x y. (- x < - y) = (- x \\<le> - y \\<and> \\<not> - y \\<le> - x)", "apply (simp add: aa.sba_dual.sub_inf_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (- x \\<le> - y) = (- x * - y = - x)\n 2. \\<And>x y. (- x < - y) = (- x \\<le> - y \\<and> \\<not> - y \\<le> - x)", "apply (simp add: aa.less_eq_inf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (- x < - y) = (- x \\<le> - y \\<and> \\<not> - y \\<le> - x)", "by (simp add: less_le_not_le)"], ["", "text \\<open>Many lemmas in this class are taken from Georg Struth's theories.\\<close>"], ["", "notation\n  uminus (\"a\")"], ["", "lemma a_greatest_left_absorber:\n  \"a(x) * y = bot \\<longleftrightarrow> a(x) \\<le> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a x * y = bot) = (a x \\<le> a y)", "by (simp add: aa.l10_iff)"], ["", "lemma a_mult_d:\n  \"a(x * y) = a(x * d(y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (x * y) = a (x * d y)", "by (simp add: d_def aa.sba3_complement_inf_double_complement)"], ["", "lemma a_d_closed:\n  \"d(a(x)) = a(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (a x) = a x", "by (simp add: d_def)"], ["", "lemma a_plus_left_lower_bound:\n  \"a(x \\<squnion> y) \\<le> a(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (x \\<squnion> y) \\<le> a x", "by (simp add: aa.l9)"], ["", "lemma a_mult_sup:\n  \"a(x) * (y \\<squnion> x) = a(x) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x * (y \\<squnion> x) = a x * y", "by (simp add: aa.sba3_inf_complement_bot semiring.distrib_left)"], ["", "lemma a_3:\n  \"a(x) * a(y) * d(x \\<squnion> y) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x * a y * d (x \\<squnion> y) = bot", "using d_weak_locality aa.l12 aa.sba3_inf_complement_bot"], ["proof (prove)\nusing this:\n  (?x * ?y = bot) = (?x * d ?y = bot)\n  a ?x * a ?y = a (?x \\<squnion> ?y)\n  a ?x * ?x = bot\n\ngoal (1 subgoal):\n 1. a x * a y * d (x \\<squnion> y) = bot", "by force"], ["", "lemma a_export:\n  \"a(a(x) * y) = d(x) \\<squnion> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x * y) = d x \\<squnion> a y", "using a_mult_d d_def aa.sba_dual.sub_inf_def"], ["proof (prove)\nusing this:\n  a (?x * ?y) = a (?x * d ?y)\n  d ?x = a (a ?x)\n  a ?x \\<squnion> a ?y = a (a (a ?x) * a (a ?y))\n\ngoal (1 subgoal):\n 1. a (a x * y) = d x \\<squnion> a y", "by auto"], ["", "lemma a_fixpoint:\n  \"\\<forall>x . (a(x) = x \\<longrightarrow> (\\<forall>y . y = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. a x = x \\<longrightarrow> (\\<forall>y. y = bot)", "by (metis aa.a_d.d_fully_strict aa.sba2_bot_unit aa.sup_idempotent aa.sup_right_zero_var)"], ["", "lemma a_strict:\n  \"a(x) = 1 \\<longleftrightarrow> x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a x = (1::'a)) = (x = bot)", "using aa.a_d.d_fully_strict one_def"], ["proof (prove)\nusing this:\n  (a (a ?x) = bot) = (?x = bot)\n  (1::'a) = a bot\n\ngoal (1 subgoal):\n 1. (a x = (1::'a)) = (x = bot)", "by fastforce"], ["", "lemma d_complement_zero:\n  \"d(x) * a(x) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * a x = bot", "by (simp add: aa.sba3_inf_complement_bot d_def)"], ["", "lemma a_complement_zero:\n  \"a(x) * d(x) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x * d x = bot", "by (simp add: d_def)"], ["", "lemma a_shunting_zero:\n  \"a(x) * d(y) = bot \\<longleftrightarrow> a(x) \\<le> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a x * d y = bot) = (a x \\<le> a y)", "by (simp add: aa.less_eq_inf_bot d_def)"], ["", "lemma a_antitone:\n  \"x \\<le> y \\<Longrightarrow> a(y) \\<le> a(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> a y \\<le> a x", "by (simp add: aa.l9)"], ["", "lemma a_mult_deMorgan:\n  \"a(a(x) * a(y)) = d(x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x * a y) = d (x \\<squnion> y)", "by (simp add: aa.sup_demorgan d_def)"], ["", "lemma a_mult_deMorgan_1:\n  \"a(a(x) * a(y)) = d(x) \\<squnion> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x * a y) = d x \\<squnion> d y", "by (simp add: a_export d_def)"], ["", "lemma a_mult_deMorgan_2:\n  \"a(d(x) * d(y)) = a(x) \\<squnion> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (d x * d y) = a x \\<squnion> a y", "by (simp add: d_def sup_def)"], ["", "lemma a_plus_deMorgan:\n  \"a(a(x) \\<squnion> a(y)) = d(x) * d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (a x \\<squnion> a y) = d x * d y", "by (simp add: aa.sub_sup_demorgan d_def)"], ["", "lemma a_plus_deMorgan_1:\n  \"a(d(x) \\<squnion> d(y)) = a(x) * a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (d x \\<squnion> d y) = a x * a y", "by (simp add: aa.sup_demorgan d_def)"], ["", "lemma a_mult_left_upper_bound:\n  \"a(x) \\<le> a(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<le> a (x * y)", "using aa.l5 d_def d_mult_sub"], ["proof (prove)\nusing this:\n  a (a ?x) \\<le> a (a ?y) \\<Longrightarrow> a ?y \\<le> a ?x\n  d ?x = a (a ?x)\n  d (?x * ?y) \\<le> d ?x\n\ngoal (1 subgoal):\n 1. a x \\<le> a (x * y)", "by auto"], ["", "lemma d_a_closed:\n  \"a(d(x)) = a(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (d x) = a x", "by (simp add: d_def)"], ["", "lemma a_export_d:\n  \"a(d(x) * y) = a(x) \\<squnion> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a (d x * y) = a x \\<squnion> a y", "using a_mult_d a_mult_deMorgan_2"], ["proof (prove)\nusing this:\n  a (?x * ?y) = a (?x * d ?y)\n  a (d ?x * d ?y) = a ?x \\<squnion> a ?y\n\ngoal (1 subgoal):\n 1. a (d x * y) = a x \\<squnion> a y", "by auto"], ["", "lemma a_7:\n  \"d(x) * a(d(y) \\<squnion> d(z)) = d(x) * a(y) * a(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * a (d y \\<squnion> d z) = d x * a y * a z", "by (simp add: a_plus_deMorgan_1 mult_assoc)"], ["", "lemma d_a_shunting:\n  \"d(x) * a(y) \\<le> d(z) \\<longleftrightarrow> d(x) \\<le> d(z) \\<squnion> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * a y \\<le> d z) = (d x \\<le> d z \\<squnion> d y)", "using aa.sba_dual.shunting_right d_def"], ["proof (prove)\nusing this:\n  (a ?z \\<le> a ?x \\<squnion> a ?y) = (a ?z * a (a ?y) \\<le> a ?x)\n  d ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. (d x * a y \\<le> d z) = (d x \\<le> d z \\<squnion> d y)", "by auto"], ["", "lemma d_d_shunting:\n  \"d(x) * d(y) \\<le> d(z) \\<longleftrightarrow> d(x) \\<le> d(z) \\<squnion> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * d y \\<le> d z) = (d x \\<le> d z \\<squnion> a y)", "using d_a_shunting d_def"], ["proof (prove)\nusing this:\n  (d ?x * a ?y \\<le> d ?z) = (d ?x \\<le> d ?z \\<squnion> d ?y)\n  d ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. (d x * d y \\<le> d z) = (d x \\<le> d z \\<squnion> a y)", "by auto"], ["", "lemma d_cancellation_1:\n  \"d(x) \\<le> d(y) \\<squnion> (d(x) * a(y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<le> d y \\<squnion> d x * a y", "by (metis a_d_closed aa.sba2_export aa.sup_demorgan d_def eq_refl le_supE sup_commute)"], ["", "lemma d_cancellation_2:\n  \"(d(z) \\<squnion> d(y)) * a(y) \\<le> d(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d z \\<squnion> d y) * a y \\<le> d z", "by (metis d_a_shunting d_dist_sup eq_refl)"], ["", "lemma a_sup_closed:\n  \"d(a(x) \\<squnion> a(y)) = a(x) \\<squnion> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (a x \\<squnion> a y) = a x \\<squnion> a y", "using aa.sub_sup_closed d_def"], ["proof (prove)\nusing this:\n  a ?x \\<squnion> a ?y = a (a (a ?x \\<squnion> a ?y))\n  d ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. d (a x \\<squnion> a y) = a x \\<squnion> a y", "by auto"], ["", "lemma a_mult_closed:\n  \"d(a(x) * a(y)) = a(x) * a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d (a x * a y) = a x * a y", "using a_d_closed aa.l12"], ["proof (prove)\nusing this:\n  d (a ?x) = a ?x\n  a ?x * a ?y = a (?x \\<squnion> ?y)\n\ngoal (1 subgoal):\n 1. d (a x * a y) = a x * a y", "by auto"], ["", "lemma d_a_shunting_zero:\n  \"d(x) * a(y) = bot \\<longleftrightarrow> d(x) \\<le> d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * a y = bot) = (d x \\<le> d y)", "by (simp add: aa.l10_iff d_def)"], ["", "lemma d_d_shunting_zero:\n  \"d(x) * d(y) = bot \\<longleftrightarrow> d(x) \\<le> a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * d y = bot) = (d x \\<le> a y)", "by (simp add: aa.l10_iff d_def)"], ["", "lemma d_compl_intro:\n  \"d(x) \\<squnion> d(y) = d(x) \\<squnion> a(x) * d(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x \\<squnion> d y = d x \\<squnion> a x * d y", "by (simp add: aa.sup_complement_intro d_def)"], ["", "lemma a_compl_intro:\n  \"a(x) \\<squnion> a(y) = a(x) \\<squnion> d(x) * a(y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a x \\<squnion> a y = a x \\<squnion> d x * a y", "by (simp add: aa.sup_complement_intro d_def)"], ["", "lemma kat_2:\n  \"y * a(z) \\<le> a(x) * y \\<Longrightarrow> d(x) * y * a(z) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * a z \\<le> a x * y \\<Longrightarrow> d x * y * a z = bot", "by (smt a_export a_plus_left_lower_bound le_sup_iff d_d_shunting_zero d_export d_strict le_iff_sup mult_assoc)"], ["", "lemma kat_3:\n  \"d(x) * y * a(z) = bot \\<Longrightarrow> d(x) * y = d(x) * y * d(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y * a z = bot \\<Longrightarrow> d x * y = d x * y * d z", "by (metis a_export_d aa.complement_bot d_complement_zero d_def mult_1_right mult_left_dist_sup sup_bot_left)"], ["", "lemma kat_4:\n  \"d(x) * y = d(x) * y * d(z) \\<Longrightarrow> d(x) * y \\<le> y * d(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y = d x * y * d z \\<Longrightarrow> d x * y \\<le> y * d z", "using d_mult_below mult_assoc"], ["proof (prove)\nusing this:\n  d ?x * ?y \\<le> ?y\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. d x * y = d x * y * d z \\<Longrightarrow> d x * y \\<le> y * d z", "by auto"], ["", "lemma kat_2_equiv:\n  \"y * a(z) \\<le> a(x) * y \\<longleftrightarrow> d(x) * y * a(z) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * a z \\<le> a x * y) = (d x * y * a z = bot)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y * a z \\<le> a x * y \\<Longrightarrow> d x * y * a z = bot\n 2. d x * y * a z = bot \\<Longrightarrow> y * a z \\<le> a x * y", "apply (simp add: kat_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y * a z = bot \\<Longrightarrow> y * a z \\<le> a x * y", "by (metis aa.top_greatest a_complement sup_bot_left d_def mult_left_one mult_right_dist_sup mult_right_isotone mult_1_right)"], ["", "lemma kat_4_equiv:\n  \"d(x) * y = d(x) * y * d(z) \\<longleftrightarrow> d(x) * y \\<le> y * d(z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * y = d x * y * d z) = (d x * y \\<le> y * d z)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d x * y = d x * y * d z \\<Longrightarrow> d x * y \\<le> y * d z\n 2. d x * y \\<le> y * d z \\<Longrightarrow> d x * y = d x * y * d z", "apply (simp add: kat_4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y \\<le> y * d z \\<Longrightarrow> d x * y = d x * y * d z", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d x * y \\<le> y * d z \\<Longrightarrow> d x * y \\<le> d x * y * d z\n 2. d x * y \\<le> y * d z \\<Longrightarrow> d x * y * d z \\<le> d x * y", "apply (metis d_idempotent le_iff_sup mult_assoc mult_left_dist_sup)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d x * y \\<le> y * d z \\<Longrightarrow> d x * y * d z \\<le> d x * y", "by (metis d_plus_one le_iff_sup mult_left_dist_sup mult_1_right)"], ["", "lemma kat_3_equiv_opp:\n  \"a(z) * y * d(x) = bot \\<longleftrightarrow> y * d(x) = d(z) * y * d(x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a z * y * d x = bot) = (y * d x = d z * y * d x)", "by (metis a_complement a_restrict sup_bot_left d_a_closed d_def mult_assoc mult_left_one mult_left_zero mult_right_dist_sup)"], ["", "lemma kat_4_equiv_opp:\n  \"y * d(x) = d(z) * y * d(x) \\<longleftrightarrow> y * d(x) \\<le> d(z) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y * d x = d z * y * d x) = (y * d x \\<le> d z * y)", "using kat_2_equiv kat_3_equiv_opp d_def"], ["proof (prove)\nusing this:\n  (?y * a ?z \\<le> a ?x * ?y) = (d ?x * ?y * a ?z = bot)\n  (a ?z * ?y * d ?x = bot) = (?y * d ?x = d ?z * ?y * d ?x)\n  d ?x = a (a ?x)\n\ngoal (1 subgoal):\n 1. (y * d x = d z * y * d x) = (y * d x \\<le> d z * y)", "by auto"], ["", "lemma d_restrict_iff:\n  \"(x \\<le> y) \\<longleftrightarrow> (x \\<le> d(x) * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x \\<le> d x * y)", "by (metis d_mult_below d_restrict_equals mult_isotone order_lesseq_imp)"], ["", "lemma d_restrict_iff_1:\n  \"(d(x) * y \\<le> z) \\<longleftrightarrow> (d(x) * y \\<le> d(x) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d x * y \\<le> z) = (d x * y \\<le> d x * z)", "by (metis sup_commute d_export d_mult_left_lower_bound d_plus_one d_restrict_iff mult_left_isotone mult_left_one mult_right_sub_dist_sup_right order_trans)"], ["", "end"], ["", "end"]]}