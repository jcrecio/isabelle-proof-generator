{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Gauss_Jordan_IArray_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma [code]: \"mat_swaprows k l (mat_impl A) = (let nr = dim_row_impl A in\n  if l < nr \\<and> k < nr then \n  mat_impl (mat_swaprows_impl k l A) else Code.abort (STR ''index out of bounds in mat_swaprows'') \n  (\\<lambda> _. mat_swaprows k l (mat_impl A)))\" (is \"?l = ?r\")", "lemma [code]: \"mat_multrow_gen mul k a (mat_impl A) = mat_impl (mat_multrow_gen_impl mul k a A)\"", "lemma mat_addrow_gen_impl[code]: \"mat_addrow_gen ad mul a k l (mat_impl A) = (if l < dim_row_impl A then\n  mat_impl (mat_addrow_gen_impl ad mul a k l A) else Code.abort (STR ''index out of bounds in mat_addrow'') \n  (\\<lambda> _. mat_addrow_gen ad mul a k l (mat_impl A)))\" (is \"?l = ?r\")", "lemma gauss_jordan_main_code[code]:\n  \"gauss_jordan_main A B i j = (let nr = dim_row A; nc = dim_col A in\n    if i < nr \\<and> j < nc then let aij = A $$ (i,j) in if aij = 0 then\n      (case [ i' . i' <- [Suc i ..< nr],  A $$ (i',j) \\<noteq> 0] \n        of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | (i' # _) \\<Rightarrow> gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n      else if aij = 1 then let v = (\\<lambda> i. A $$ (i,j)) in\n        gauss_jordan_main \n        (eliminate_entries v A i j) (eliminate_entries v B i j) (Suc i) (Suc j)\n      else let iaij = inverse aij; A' = multrow i iaij A; B' = multrow i iaij B;\n        v = (\\<lambda> i. A' $$ (i,j)) in gauss_jordan_main \n        (eliminate_entries v A' i j) (eliminate_entries v B' i j) (Suc i) (Suc j)\n    else (A,B))\" (is \"?l = ?r\")"], "translations": [["", "lemma [code]: \"mat_swaprows k l (mat_impl A) = (let nr = dim_row_impl A in\n  if l < nr \\<and> k < nr then \n  mat_impl (mat_swaprows_impl k l A) else Code.abort (STR ''index out of bounds in mat_swaprows'') \n  (\\<lambda> _. mat_swaprows k l (mat_impl A)))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows k l (mat_impl A) =\n    (let nr = dim_row_impl A\n     in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n        else Code.abort STR ''index out of bounds in mat_swaprows''\n              (\\<lambda>_. swaprows k l (mat_impl A)))", "proof (cases \"l < dim_row_impl A \\<and> k < dim_row_impl A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l < dim_row_impl A \\<and> k < dim_row_impl A \\<Longrightarrow>\n    swaprows k l (mat_impl A) =\n    (let nr = dim_row_impl A\n     in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n        else Code.abort STR ''index out of bounds in mat_swaprows''\n              (\\<lambda>_. swaprows k l (mat_impl A)))\n 2. \\<not> (l < dim_row_impl A \\<and> k < dim_row_impl A) \\<Longrightarrow>\n    swaprows k l (mat_impl A) =\n    (let nr = dim_row_impl A\n     in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n        else Code.abort STR ''index out of bounds in mat_swaprows''\n              (\\<lambda>_. swaprows k l (mat_impl A)))", "case True"], ["proof (state)\nthis:\n  l < dim_row_impl A \\<and> k < dim_row_impl A\n\ngoal (2 subgoals):\n 1. l < dim_row_impl A \\<and> k < dim_row_impl A \\<Longrightarrow>\n    swaprows k l (mat_impl A) =\n    (let nr = dim_row_impl A\n     in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n        else Code.abort STR ''index out of bounds in mat_swaprows''\n              (\\<lambda>_. swaprows k l (mat_impl A)))\n 2. \\<not> (l < dim_row_impl A \\<and> k < dim_row_impl A) \\<Longrightarrow>\n    swaprows k l (mat_impl A) =\n    (let nr = dim_row_impl A\n     in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n        else Code.abort STR ''index out of bounds in mat_swaprows''\n              (\\<lambda>_. swaprows k l (mat_impl A)))", "hence id: \"?r = mat_impl (mat_swaprows_impl k l A)\""], ["proof (prove)\nusing this:\n  l < dim_row_impl A \\<and> k < dim_row_impl A\n\ngoal (1 subgoal):\n 1. (let nr = dim_row_impl A\n     in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n        else Code.abort STR ''index out of bounds in mat_swaprows''\n              (\\<lambda>_. swaprows k l (mat_impl A))) =\n    mat_impl (mat_swaprows_impl k l A)", "by simp"], ["proof (state)\nthis:\n  (let nr = dim_row_impl A\n   in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n      else Code.abort STR ''index out of bounds in mat_swaprows''\n            (\\<lambda>_. swaprows k l (mat_impl A))) =\n  mat_impl (mat_swaprows_impl k l A)\n\ngoal (2 subgoals):\n 1. l < dim_row_impl A \\<and> k < dim_row_impl A \\<Longrightarrow>\n    swaprows k l (mat_impl A) =\n    (let nr = dim_row_impl A\n     in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n        else Code.abort STR ''index out of bounds in mat_swaprows''\n              (\\<lambda>_. swaprows k l (mat_impl A)))\n 2. \\<not> (l < dim_row_impl A \\<and> k < dim_row_impl A) \\<Longrightarrow>\n    swaprows k l (mat_impl A) =\n    (let nr = dim_row_impl A\n     in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n        else Code.abort STR ''index out of bounds in mat_swaprows''\n              (\\<lambda>_. swaprows k l (mat_impl A)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows k l (mat_impl A) =\n    (let nr = dim_row_impl A\n     in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n        else Code.abort STR ''index out of bounds in mat_swaprows''\n              (\\<lambda>_. swaprows k l (mat_impl A)))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows k l (mat_impl A) = mat_impl (mat_swaprows_impl k l A)", "unfolding mat_swaprows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if k = i then mat_impl A $$ (l, j)\n         else if l = i then mat_impl A $$ (k, j)\n              else mat_impl A $$ (i, j)) =\n    mat_impl (mat_swaprows_impl k l A)", "proof (rule eq_matI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat_impl (mat_swaprows_impl k l A));\n        j < dim_col (mat_impl (mat_swaprows_impl k l A))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n                          (\\<lambda>(i, j).\n                              if k = i then mat_impl A $$ (l, j)\n                              else if l = i then mat_impl A $$ (k, j)\n                                   else mat_impl A $$ (i, j)) $$\n                         (i, j) =\n                         mat_impl (mat_swaprows_impl k l A) $$ (i, j)\n 2. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mat_impl A $$ (l, j)\n           else if l = i then mat_impl A $$ (k, j)\n                else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (mat_swaprows_impl k l A))\n 3. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mat_impl A $$ (l, j)\n           else if l = i then mat_impl A $$ (k, j)\n                else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (mat_swaprows_impl k l A))", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row (mat_impl (mat_swaprows_impl k l A))\n  j < dim_col (mat_impl (mat_swaprows_impl k l A))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat_impl (mat_swaprows_impl k l A));\n        j < dim_col (mat_impl (mat_swaprows_impl k l A))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n                          (\\<lambda>(i, j).\n                              if k = i then mat_impl A $$ (l, j)\n                              else if l = i then mat_impl A $$ (k, j)\n                                   else mat_impl A $$ (i, j)) $$\n                         (i, j) =\n                         mat_impl (mat_swaprows_impl k l A) $$ (i, j)\n 2. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mat_impl A $$ (l, j)\n           else if l = i then mat_impl A $$ (k, j)\n                else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (mat_swaprows_impl k l A))\n 3. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mat_impl A $$ (l, j)\n           else if l = i then mat_impl A $$ (k, j)\n                else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (mat_swaprows_impl k l A))", "thus ?case"], ["proof (prove)\nusing this:\n  i < dim_row (mat_impl (mat_swaprows_impl k l A))\n  j < dim_col (mat_impl (mat_swaprows_impl k l A))\n\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if k = i then mat_impl A $$ (l, j)\n         else if l = i then mat_impl A $$ (k, j)\n              else mat_impl A $$ (i, j)) $$\n    (i, j) =\n    mat_impl (mat_swaprows_impl k l A) $$ (i, j)", "using True"], ["proof (prove)\nusing this:\n  i < dim_row (mat_impl (mat_swaprows_impl k l A))\n  j < dim_col (mat_impl (mat_swaprows_impl k l A))\n  l < dim_row_impl A \\<and> k < dim_row_impl A\n\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if k = i then mat_impl A $$ (l, j)\n         else if l = i then mat_impl A $$ (k, j)\n              else mat_impl A $$ (i, j)) $$\n    (i, j) =\n    mat_impl (mat_swaprows_impl k l A) $$ (i, j)", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i k l A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        if k < nr \\<and> l < nr\n                        then let Ai = A !! k; Aj = A !! l;\n                                 Arows = IArray.list_of A;\n                                 A' = IArray (Arows[k := Aj, l := Ai])\n                             in (nr, nc, A')\n                        else (nr, nc, A) of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     if k < nr \\<and> l < nr\n                     then let Ai = A !! k; Aj = A !! l;\n                              Arows = IArray.list_of A;\n                              A' = IArray (Arows[k := Aj, l := Ai])\n                          in (nr, nc, A')\n                     else (nr, nc, A) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        l < fst A \\<and> k < fst A\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(l, j)\n                                else if l = i\n                                     then (snd \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (k, j)\n                                     else (snd \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  if k < nr \\<and> l < nr\n                                  then let Ai = A !! k; Aj = A !! l;\n     Arows = IArray.list_of A; A' = IArray (Arows[k := Aj, l := Ai])\n in (nr, nc, A')\n                                  else (nr, nc, A) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "case (1 i k l A j)"], ["proof (state)\nthis:\n  A \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}\n  i < fst (case case A of\n                (nr, nc, A) \\<Rightarrow>\n                  if k < nr \\<and> l < nr\n                  then let Ai = A !! k; Aj = A !! l;\n                           Arows = IArray.list_of A;\n                           A' = IArray (Arows[k := Aj, l := Ai])\n                       in (nr, nc, A')\n                  else (nr, nc, A) of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  j < (fst \\<circ> snd)\n       (case case A of\n             (nr, nc, A) \\<Rightarrow>\n               if k < nr \\<and> l < nr\n               then let Ai = A !! k; Aj = A !! l; Arows = IArray.list_of A;\n                        A' = IArray (Arows[k := Aj, l := Ai])\n                    in (nr, nc, A')\n               else (nr, nc, A) of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  l < fst A \\<and> k < fst A\n\ngoal (1 subgoal):\n 1. \\<And>i k l A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        if k < nr \\<and> l < nr\n                        then let Ai = A !! k; Aj = A !! l;\n                                 Arows = IArray.list_of A;\n                                 A' = IArray (Arows[k := Aj, l := Ai])\n                             in (nr, nc, A')\n                        else (nr, nc, A) of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     if k < nr \\<and> l < nr\n                     then let Ai = A !! k; Aj = A !! l;\n                              Arows = IArray.list_of A;\n                              A' = IArray (Arows[k := Aj, l := Ai])\n                          in (nr, nc, A')\n                     else (nr, nc, A) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        l < fst A \\<and> k < fst A\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(l, j)\n                                else if l = i\n                                     then (snd \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (k, j)\n                                     else (snd \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  if k < nr \\<and> l < nr\n                                  then let Ai = A !! k; Aj = A !! l;\n     Arows = IArray.list_of A; A' = IArray (Arows[k := Aj, l := Ai])\n in (nr, nc, A')\n                                  else (nr, nc, A) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "obtain nr nc rows where A: \"A = (nr,nc,rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nr nc rows.\n        A = (nr, nc, rows) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases A, auto)"], ["proof (state)\nthis:\n  A = (nr, nc, rows)\n\ngoal (1 subgoal):\n 1. \\<And>i k l A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        if k < nr \\<and> l < nr\n                        then let Ai = A !! k; Aj = A !! l;\n                                 Arows = IArray.list_of A;\n                                 A' = IArray (Arows[k := Aj, l := Ai])\n                             in (nr, nc, A')\n                        else (nr, nc, A) of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     if k < nr \\<and> l < nr\n                     then let Ai = A !! k; Aj = A !! l;\n                              Arows = IArray.list_of A;\n                              A' = IArray (Arows[k := Aj, l := Ai])\n                          in (nr, nc, A')\n                     else (nr, nc, A) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        l < fst A \\<and> k < fst A\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(l, j)\n                                else if l = i\n                                     then (snd \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (k, j)\n                                     else (snd \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  if k < nr \\<and> l < nr\n                                  then let Ai = A !! k; Aj = A !! l;\n     Arows = IArray.list_of A; A' = IArray (Arows[k := Aj, l := Ai])\n in (nr, nc, A')\n                                  else (nr, nc, A) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "from 1[unfolded A]"], ["proof (chain)\npicking this:\n  (nr, nc, rows)\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n  i < fst (case case (nr, nc, rows) of\n                (nr, nc, A) \\<Rightarrow>\n                  if k < nr \\<and> l < nr\n                  then let Ai = A !! k; Aj = A !! l;\n                           Arows = IArray.list_of A;\n                           A' = IArray (Arows[k := Aj, l := Ai])\n                       in (nr, nc, A')\n                  else (nr, nc, A) of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  j < (fst \\<circ> snd)\n       (case case (nr, nc, rows) of\n             (nr, nc, A) \\<Rightarrow>\n               if k < nr \\<and> l < nr\n               then let Ai = A !! k; Aj = A !! l; Arows = IArray.list_of A;\n                        A' = IArray (Arows[k := Aj, l := Ai])\n                    in (nr, nc, A')\n               else (nr, nc, A) of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  l < fst (nr, nc, rows) \\<and> k < fst (nr, nc, rows)", "have nr: \"length (IArray.list_of rows) = nr\"\n        and nc: \"IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\"\n        and ij: \"i < nr\" \"j < nc\" and ij': \"(i < nr \\<and> j < nc) = True\" \n        and l: \"l < nr\" \"k < nr\""], ["proof (prove)\nusing this:\n  (nr, nc, rows)\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n  i < fst (case case (nr, nc, rows) of\n                (nr, nc, A) \\<Rightarrow>\n                  if k < nr \\<and> l < nr\n                  then let Ai = A !! k; Aj = A !! l;\n                           Arows = IArray.list_of A;\n                           A' = IArray (Arows[k := Aj, l := Ai])\n                       in (nr, nc, A')\n                  else (nr, nc, A) of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  j < (fst \\<circ> snd)\n       (case case (nr, nc, rows) of\n             (nr, nc, A) \\<Rightarrow>\n               if k < nr \\<and> l < nr\n               then let Ai = A !! k; Aj = A !! l; Arows = IArray.list_of A;\n                        A' = IArray (Arows[k := Aj, l := Ai])\n                    in (nr, nc, A')\n               else (nr, nc, A) of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  l < fst (nr, nc, rows) \\<and> k < fst (nr, nc, rows)\n\ngoal (1 subgoal):\n 1. (length (IArray.list_of rows) = nr &&&\n     IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows) &&&\n    (i < nr &&& j < nc) &&&\n    (i < nr \\<and> j < nc) = True &&& l < nr &&& k < nr", "by auto"], ["proof (state)\nthis:\n  length (IArray.list_of rows) = nr\n  IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\n  i < nr\n  j < nc\n  (i < nr \\<and> j < nc) = True\n  l < nr\n  k < nr\n\ngoal (1 subgoal):\n 1. \\<And>i k l A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        if k < nr \\<and> l < nr\n                        then let Ai = A !! k; Aj = A !! l;\n                                 Arows = IArray.list_of A;\n                                 A' = IArray (Arows[k := Aj, l := Ai])\n                             in (nr, nc, A')\n                        else (nr, nc, A) of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     if k < nr \\<and> l < nr\n                     then let Ai = A !! k; Aj = A !! l;\n                              Arows = IArray.list_of A;\n                              A' = IArray (Arows[k := Aj, l := Ai])\n                          in (nr, nc, A')\n                     else (nr, nc, A) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        l < fst A \\<and> k < fst A\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(l, j)\n                                else if l = i\n                                     then (snd \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (k, j)\n                                     else (snd \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  if k < nr \\<and> l < nr\n                                  then let Ai = A !! k; Aj = A !! l;\n     Arows = IArray.list_of A; A' = IArray (Arows[k := Aj, l := Ai])\n in (nr, nc, A')\n                                  else (nr, nc, A) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd \\<circ> snd)\n     (fst (case A of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n      (fst \\<circ> snd)\n       (case A of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n      mk_mat\n       (fst (case A of\n             (nr, nc, m) \\<Rightarrow>\n               (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n       ((fst \\<circ> snd)\n         (case A of\n          (nr, nc, m) \\<Rightarrow>\n            (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n       (\\<lambda>(i, j).\n           if k = i\n           then (snd \\<circ> snd)\n                 (case A of\n                  (nr, nc, m) \\<Rightarrow>\n                    (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                 (l, j)\n           else if l = i\n                then (snd \\<circ> snd)\n                      (case A of\n                       (nr, nc, m) \\<Rightarrow>\n                         (nr, nc,\n                          mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                      (k, j)\n                else (snd \\<circ> snd)\n                      (case A of\n                       (nr, nc, m) \\<Rightarrow>\n                         (nr, nc,\n                          mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                      (i, j)))\n     (i, j) =\n    (snd \\<circ> snd)\n     (case case A of\n           (nr, nc, A) \\<Rightarrow>\n             if k < nr \\<and> l < nr\n             then let Ai = A !! k; Aj = A !! l; Arows = IArray.list_of A;\n                      A' = IArray (Arows[k := Aj, l := Ai])\n                  in (nr, nc, A')\n             else (nr, nc, A) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "unfolding A prod.simps fst_conv o_def snd_conv Let_def mk_mat_def ij' if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k = i\n     then if l < nr \\<and> j < nc then rows !! l !! j\n          else undef_mat nr nc (\\<lambda>(i, y). rows !! i !! y) (l, j)\n     else if l = i\n          then if k < nr \\<and> j < nc then rows !! k !! j\n               else undef_mat nr nc (\\<lambda>(i, y). rows !! i !! y) (k, j)\n          else rows !! i !! j) =\n    snd (snd (case if k < nr \\<and> l < nr\n                   then (nr, nc,\n                         IArray\n                          ((IArray.list_of rows)\n                           [k := rows !! l, l := rows !! k]))\n                   else (nr, nc, rows) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc,\n                 \\<lambda>(i, j).\n                    if i < nr \\<and> j < nc then m !! i !! j\n                    else undef_mat nr nc (\\<lambda>(i, y). m !! i !! y)\n                          (i, j))))\n     (i, j)", "using ij nr nc l"], ["proof (prove)\nusing this:\n  i < nr\n  j < nc\n  length (IArray.list_of rows) = nr\n  IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\n  l < nr\n  k < nr\n\ngoal (1 subgoal):\n 1. (if k = i\n     then if l < nr \\<and> j < nc then rows !! l !! j\n          else undef_mat nr nc (\\<lambda>(i, y). rows !! i !! y) (l, j)\n     else if l = i\n          then if k < nr \\<and> j < nc then rows !! k !! j\n               else undef_mat nr nc (\\<lambda>(i, y). rows !! i !! y) (k, j)\n          else rows !! i !! j) =\n    snd (snd (case if k < nr \\<and> l < nr\n                   then (nr, nc,\n                         IArray\n                          ((IArray.list_of rows)\n                           [k := rows !! l, l := rows !! k]))\n                   else (nr, nc, rows) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc,\n                 \\<lambda>(i, j).\n                    if i < nr \\<and> j < nc then m !! i !! j\n                    else undef_mat nr nc (\\<lambda>(i, y). m !! i !! y)\n                          (i, j))))\n     (i, j)", "by (cases \"k = i\"; cases \"l = i\", auto)"], ["proof (state)\nthis:\n  (snd \\<circ> snd)\n   (fst (case A of\n         (nr, nc, m) \\<Rightarrow>\n           (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n    (fst \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n    mk_mat\n     (fst (case A of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n     ((fst \\<circ> snd)\n       (case A of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n     (\\<lambda>(i, j).\n         if k = i\n         then (snd \\<circ> snd)\n               (case A of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (l, j)\n         else if l = i\n              then (snd \\<circ> snd)\n                    (case A of\n                     (nr, nc, m) \\<Rightarrow>\n                       (nr, nc,\n                        mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                    (k, j)\n              else (snd \\<circ> snd)\n                    (case A of\n                     (nr, nc, m) \\<Rightarrow>\n                       (nr, nc,\n                        mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                    (i, j)))\n   (i, j) =\n  (snd \\<circ> snd)\n   (case case A of\n         (nr, nc, A) \\<Rightarrow>\n           if k < nr \\<and> l < nr\n           then let Ai = A !! k; Aj = A !! l; Arows = IArray.list_of A;\n                    A' = IArray (Arows[k := Aj, l := Ai])\n                in (nr, nc, A')\n           else (nr, nc, A) of\n    (nr, nc, m) \\<Rightarrow>\n      (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n   (\\<lambda>(i, j).\n       if k = i then mat_impl A $$ (l, j)\n       else if l = i then mat_impl A $$ (k, j) else mat_impl A $$ (i, j)) $$\n  (i, j) =\n  mat_impl (mat_swaprows_impl k l A) $$ (i, j)\n\ngoal (2 subgoals):\n 1. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mat_impl A $$ (l, j)\n           else if l = i then mat_impl A $$ (k, j)\n                else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (mat_swaprows_impl k l A))\n 2. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mat_impl A $$ (l, j)\n           else if l = i then mat_impl A $$ (k, j)\n                else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (mat_swaprows_impl k l A))", "qed ((transfer, auto)+)"], ["proof (state)\nthis:\n  swaprows k l (mat_impl A) =\n  (let nr = dim_row_impl A\n   in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n      else Code.abort STR ''index out of bounds in mat_swaprows''\n            (\\<lambda>_. swaprows k l (mat_impl A)))\n\ngoal (1 subgoal):\n 1. \\<not> (l < dim_row_impl A \\<and> k < dim_row_impl A) \\<Longrightarrow>\n    swaprows k l (mat_impl A) =\n    (let nr = dim_row_impl A\n     in if l < nr \\<and> k < nr then mat_impl (mat_swaprows_impl k l A)\n        else Code.abort STR ''index out of bounds in mat_swaprows''\n              (\\<lambda>_. swaprows k l (mat_impl A)))", "qed auto"], ["", "lift_definition mat_multrow_gen_impl :: \"('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a mat_impl \\<Rightarrow> 'a mat_impl\" is\n  \"\\<lambda> mul k a (nr,nc,A). let Ak = IArray.sub A k; Arows = IArray.list_of A;\n     Ak' = IArray.IArray (map (mul a) (IArray.list_of Ak));\n     A' = IArray.IArray (Arows [k := Ak'])\n     in (nr,nc,A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun nat a prod.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, A) \\<Rightarrow>\n          let Ak = A !! nat; Arows = IArray.list_of A;\n              Ak' = IArray (map (fun a) (IArray.list_of Ak));\n              A' = IArray (Arows[nat := Ak'])\n          in (nr, nc, A'))\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "proof (auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun nat a ab b ac.\n       \\<lbrakk>\\<forall>a\\<in>set (IArray.list_of b).\n                   length (IArray.list_of a) = ab;\n        ac \\<in> set ((IArray.list_of b)\n                      [nat :=\n                         IArray\n                          (map (fun a)\n                            (IArray.list_of\n                              (IArray.list_of b ! nat)))])\\<rbrakk>\n       \\<Longrightarrow> length (IArray.list_of ac) = ab", "case (1 mul k a nc b row)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (IArray.list_of b). length (IArray.list_of a) = nc\n  row\n  \\<in> set ((IArray.list_of b)\n             [k := IArray\n                    (map (mul a) (IArray.list_of (IArray.list_of b ! k)))])\n\ngoal (1 subgoal):\n 1. \\<And>fun nat a ab b ac.\n       \\<lbrakk>\\<forall>a\\<in>set (IArray.list_of b).\n                   length (IArray.list_of a) = ab;\n        ac \\<in> set ((IArray.list_of b)\n                      [nat :=\n                         IArray\n                          (map (fun a)\n                            (IArray.list_of\n                              (IArray.list_of b ! nat)))])\\<rbrakk>\n       \\<Longrightarrow> length (IArray.list_of ac) = ab", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (IArray.list_of row) = nc", "proof (cases b)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. b = IArray x \\<Longrightarrow> length (IArray.list_of row) = nc", "case (IArray rows)"], ["proof (state)\nthis:\n  b = IArray rows\n\ngoal (1 subgoal):\n 1. \\<And>x. b = IArray x \\<Longrightarrow> length (IArray.list_of row) = nc", "with 1"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (IArray.list_of b). length (IArray.list_of a) = nc\n  row\n  \\<in> set ((IArray.list_of b)\n             [k := IArray\n                    (map (mul a) (IArray.list_of (IArray.list_of b ! k)))])\n  b = IArray rows", "have \"row \\<in> set rows \\<or> k < length rows \\<and> row = IArray (map (mul a) (IArray.list_of (rows ! k)))\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (IArray.list_of b). length (IArray.list_of a) = nc\n  row\n  \\<in> set ((IArray.list_of b)\n             [k := IArray\n                    (map (mul a) (IArray.list_of (IArray.list_of b ! k)))])\n  b = IArray rows\n\ngoal (1 subgoal):\n 1. row \\<in> set rows \\<or>\n    k < length rows \\<and>\n    row = IArray (map (mul a) (IArray.list_of (rows ! k)))", "by (cases \"k < length rows\", auto simp: set_list_update dest: in_set_takeD in_set_dropD)"], ["proof (state)\nthis:\n  row \\<in> set rows \\<or>\n  k < length rows \\<and>\n  row = IArray (map (mul a) (IArray.list_of (rows ! k)))\n\ngoal (1 subgoal):\n 1. \\<And>x. b = IArray x \\<Longrightarrow> length (IArray.list_of row) = nc", "with 1 IArray"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (IArray.list_of b). length (IArray.list_of a) = nc\n  row\n  \\<in> set ((IArray.list_of b)\n             [k := IArray\n                    (map (mul a) (IArray.list_of (IArray.list_of b ! k)))])\n  b = IArray rows\n  row \\<in> set rows \\<or>\n  k < length rows \\<and>\n  row = IArray (map (mul a) (IArray.list_of (rows ! k)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (IArray.list_of b). length (IArray.list_of a) = nc\n  row\n  \\<in> set ((IArray.list_of b)\n             [k := IArray\n                    (map (mul a) (IArray.list_of (IArray.list_of b ! k)))])\n  b = IArray rows\n  row \\<in> set rows \\<or>\n  k < length rows \\<and>\n  row = IArray (map (mul a) (IArray.list_of (rows ! k)))\n\ngoal (1 subgoal):\n 1. length (IArray.list_of row) = nc", "by (cases, auto)"], ["proof (state)\nthis:\n  length (IArray.list_of row) = nc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (IArray.list_of row) = nc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [code]: \"mat_multrow_gen mul k a (mat_impl A) = mat_impl (mat_multrow_gen_impl mul k a A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_multrow_gen mul k a (mat_impl A) =\n    mat_impl (mat_multrow_gen_impl mul k a A)", "unfolding mat_multrow_gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if k = i then mul a (mat_impl A $$ (i, j))\n         else mat_impl A $$ (i, j)) =\n    mat_impl (mat_multrow_gen_impl mul k a A)", "proof (rule eq_matI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat_impl (mat_multrow_gen_impl mul k a A));\n        j < dim_col (mat_impl (mat_multrow_gen_impl mul k a A))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n                          (\\<lambda>(i, j).\n                              if k = i then mul a (mat_impl A $$ (i, j))\n                              else mat_impl A $$ (i, j)) $$\n                         (i, j) =\n                         mat_impl (mat_multrow_gen_impl mul k a A) $$ (i, j)\n 2. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mul a (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (mat_multrow_gen_impl mul k a A))\n 3. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mul a (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (mat_multrow_gen_impl mul k a A))", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row (mat_impl (mat_multrow_gen_impl mul k a A))\n  j < dim_col (mat_impl (mat_multrow_gen_impl mul k a A))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat_impl (mat_multrow_gen_impl mul k a A));\n        j < dim_col (mat_impl (mat_multrow_gen_impl mul k a A))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n                          (\\<lambda>(i, j).\n                              if k = i then mul a (mat_impl A $$ (i, j))\n                              else mat_impl A $$ (i, j)) $$\n                         (i, j) =\n                         mat_impl (mat_multrow_gen_impl mul k a A) $$ (i, j)\n 2. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mul a (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (mat_multrow_gen_impl mul k a A))\n 3. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mul a (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (mat_multrow_gen_impl mul k a A))", "thus ?case"], ["proof (prove)\nusing this:\n  i < dim_row (mat_impl (mat_multrow_gen_impl mul k a A))\n  j < dim_col (mat_impl (mat_multrow_gen_impl mul k a A))\n\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if k = i then mul a (mat_impl A $$ (i, j))\n         else mat_impl A $$ (i, j)) $$\n    (i, j) =\n    mat_impl (mat_multrow_gen_impl mul k a A) $$ (i, j)", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i mul k a A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        let Ak = A !! k; Arows = IArray.list_of A;\n                            Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                            A' = IArray (Arows[k := Ak'])\n                        in (nr, nc, A') of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     let Ak = A !! k; Arows = IArray.list_of A;\n                         Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                         A' = IArray (Arows[k := Ak'])\n                     in (nr, nc, A') of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc,\n                 mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then mul a\n((snd \\<circ> snd)\n  (case A of\n   (nr, nc, m) \\<Rightarrow>\n     (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  (i, j))\n                                else (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  let Ak = A !! k; Arows = IArray.list_of A;\nAk' = IArray (map (mul a) (IArray.list_of Ak));\nA' = IArray (Arows[k := Ak'])\n                                  in (nr, nc, A') of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "case (1 i mul k a A j)"], ["proof (state)\nthis:\n  A \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}\n  i < fst (case case A of\n                (nr, nc, A) \\<Rightarrow>\n                  let Ak = A !! k; Arows = IArray.list_of A;\n                      Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                      A' = IArray (Arows[k := Ak'])\n                  in (nr, nc, A') of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  j < (fst \\<circ> snd)\n       (case case A of\n             (nr, nc, A) \\<Rightarrow>\n               let Ak = A !! k; Arows = IArray.list_of A;\n                   Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                   A' = IArray (Arows[k := Ak'])\n               in (nr, nc, A') of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n\ngoal (1 subgoal):\n 1. \\<And>i mul k a A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        let Ak = A !! k; Arows = IArray.list_of A;\n                            Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                            A' = IArray (Arows[k := Ak'])\n                        in (nr, nc, A') of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     let Ak = A !! k; Arows = IArray.list_of A;\n                         Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                         A' = IArray (Arows[k := Ak'])\n                     in (nr, nc, A') of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc,\n                 mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then mul a\n((snd \\<circ> snd)\n  (case A of\n   (nr, nc, m) \\<Rightarrow>\n     (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  (i, j))\n                                else (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  let Ak = A !! k; Arows = IArray.list_of A;\nAk' = IArray (map (mul a) (IArray.list_of Ak));\nA' = IArray (Arows[k := Ak'])\n                                  in (nr, nc, A') of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "obtain nr nc rows where A: \"A = (nr,nc,rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nr nc rows.\n        A = (nr, nc, rows) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases A, auto)"], ["proof (state)\nthis:\n  A = (nr, nc, rows)\n\ngoal (1 subgoal):\n 1. \\<And>i mul k a A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        let Ak = A !! k; Arows = IArray.list_of A;\n                            Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                            A' = IArray (Arows[k := Ak'])\n                        in (nr, nc, A') of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     let Ak = A !! k; Arows = IArray.list_of A;\n                         Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                         A' = IArray (Arows[k := Ak'])\n                     in (nr, nc, A') of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc,\n                 mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then mul a\n((snd \\<circ> snd)\n  (case A of\n   (nr, nc, m) \\<Rightarrow>\n     (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  (i, j))\n                                else (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  let Ak = A !! k; Arows = IArray.list_of A;\nAk' = IArray (map (mul a) (IArray.list_of Ak));\nA' = IArray (Arows[k := Ak'])\n                                  in (nr, nc, A') of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "from 1[unfolded A]"], ["proof (chain)\npicking this:\n  (nr, nc, rows)\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n  i < fst (case case (nr, nc, rows) of\n                (nr, nc, A) \\<Rightarrow>\n                  let Ak = A !! k; Arows = IArray.list_of A;\n                      Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                      A' = IArray (Arows[k := Ak'])\n                  in (nr, nc, A') of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  j < (fst \\<circ> snd)\n       (case case (nr, nc, rows) of\n             (nr, nc, A) \\<Rightarrow>\n               let Ak = A !! k; Arows = IArray.list_of A;\n                   Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                   A' = IArray (Arows[k := Ak'])\n               in (nr, nc, A') of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))", "have nr: \"length (IArray.list_of rows) = nr\"\n      and nc: \"IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\"\n      and ij: \"i < nr\" \"j < nc\" and ij': \"(i < nr \\<and> j < nc) = True\""], ["proof (prove)\nusing this:\n  (nr, nc, rows)\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n  i < fst (case case (nr, nc, rows) of\n                (nr, nc, A) \\<Rightarrow>\n                  let Ak = A !! k; Arows = IArray.list_of A;\n                      Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                      A' = IArray (Arows[k := Ak'])\n                  in (nr, nc, A') of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  j < (fst \\<circ> snd)\n       (case case (nr, nc, rows) of\n             (nr, nc, A) \\<Rightarrow>\n               let Ak = A !! k; Arows = IArray.list_of A;\n                   Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                   A' = IArray (Arows[k := Ak'])\n               in (nr, nc, A') of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n\ngoal (1 subgoal):\n 1. (length (IArray.list_of rows) = nr &&&\n     IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows) &&&\n    (i < nr &&& j < nc) &&& (i < nr \\<and> j < nc) = True", "by auto"], ["proof (state)\nthis:\n  length (IArray.list_of rows) = nr\n  IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\n  i < nr\n  j < nc\n  (i < nr \\<and> j < nc) = True\n\ngoal (1 subgoal):\n 1. \\<And>i mul k a A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        let Ak = A !! k; Arows = IArray.list_of A;\n                            Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                            A' = IArray (Arows[k := Ak'])\n                        in (nr, nc, A') of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     let Ak = A !! k; Arows = IArray.list_of A;\n                         Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                         A' = IArray (Arows[k := Ak'])\n                     in (nr, nc, A') of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc,\n                 mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then mul a\n((snd \\<circ> snd)\n  (case A of\n   (nr, nc, m) \\<Rightarrow>\n     (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  (i, j))\n                                else (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  let Ak = A !! k; Arows = IArray.list_of A;\nAk' = IArray (map (mul a) (IArray.list_of Ak));\nA' = IArray (Arows[k := Ak'])\n                                  in (nr, nc, A') of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "have len: \"j < length (IArray.list_of (IArray.list_of rows ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length (IArray.list_of (IArray.list_of rows ! i))", "using ij nc nr"], ["proof (prove)\nusing this:\n  i < nr\n  j < nc\n  IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\n  length (IArray.list_of rows) = nr\n\ngoal (1 subgoal):\n 1. j < length (IArray.list_of (IArray.list_of rows ! i))", "by (cases rows, auto)"], ["proof (state)\nthis:\n  j < length (IArray.list_of (IArray.list_of rows ! i))\n\ngoal (1 subgoal):\n 1. \\<And>i mul k a A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        let Ak = A !! k; Arows = IArray.list_of A;\n                            Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                            A' = IArray (Arows[k := Ak'])\n                        in (nr, nc, A') of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     let Ak = A !! k; Arows = IArray.list_of A;\n                         Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                         A' = IArray (Arows[k := Ak'])\n                     in (nr, nc, A') of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc,\n                 mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then mul a\n((snd \\<circ> snd)\n  (case A of\n   (nr, nc, m) \\<Rightarrow>\n     (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  (i, j))\n                                else (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  let Ak = A !! k; Arows = IArray.list_of A;\nAk' = IArray (map (mul a) (IArray.list_of Ak));\nA' = IArray (Arows[k := Ak'])\n                                  in (nr, nc, A') of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd \\<circ> snd)\n     (fst (case A of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n      (fst \\<circ> snd)\n       (case A of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n      mk_mat\n       (fst (case A of\n             (nr, nc, m) \\<Rightarrow>\n               (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n       ((fst \\<circ> snd)\n         (case A of\n          (nr, nc, m) \\<Rightarrow>\n            (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n       (\\<lambda>(i, j).\n           if k = i\n           then mul a\n                 ((snd \\<circ> snd)\n                   (case A of\n                    (nr, nc, m) \\<Rightarrow>\n                      (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                   (i, j))\n           else (snd \\<circ> snd)\n                 (case A of\n                  (nr, nc, m) \\<Rightarrow>\n                    (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                 (i, j)))\n     (i, j) =\n    (snd \\<circ> snd)\n     (case case A of\n           (nr, nc, A) \\<Rightarrow>\n             let Ak = A !! k; Arows = IArray.list_of A;\n                 Ak' = IArray (map (mul a) (IArray.list_of Ak));\n                 A' = IArray (Arows[k := Ak'])\n             in (nr, nc, A') of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "unfolding A prod.simps fst_conv o_def snd_conv Let_def mk_mat_def ij' if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k = i then mul a (rows !! i !! j) else rows !! i !! j) =\n    IArray\n     ((IArray.list_of rows)\n      [k := IArray (map (mul a) (IArray.list_of (rows !! k)))]) !!\n    i !!\n    j", "using ij nr nc"], ["proof (prove)\nusing this:\n  i < nr\n  j < nc\n  length (IArray.list_of rows) = nr\n  IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\n\ngoal (1 subgoal):\n 1. (if k = i then mul a (rows !! i !! j) else rows !! i !! j) =\n    IArray\n     ((IArray.list_of rows)\n      [k := IArray (map (mul a) (IArray.list_of (rows !! k)))]) !!\n    i !!\n    j", "by (cases \"k = i\", auto simp: len)"], ["proof (state)\nthis:\n  (snd \\<circ> snd)\n   (fst (case A of\n         (nr, nc, m) \\<Rightarrow>\n           (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n    (fst \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n    mk_mat\n     (fst (case A of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n     ((fst \\<circ> snd)\n       (case A of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n     (\\<lambda>(i, j).\n         if k = i\n         then mul a\n               ((snd \\<circ> snd)\n                 (case A of\n                  (nr, nc, m) \\<Rightarrow>\n                    (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                 (i, j))\n         else (snd \\<circ> snd)\n               (case A of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j)))\n   (i, j) =\n  (snd \\<circ> snd)\n   (case case A of\n         (nr, nc, A) \\<Rightarrow>\n           let Ak = A !! k; Arows = IArray.list_of A;\n               Ak' = IArray (map (mul a) (IArray.list_of Ak));\n               A' = IArray (Arows[k := Ak'])\n           in (nr, nc, A') of\n    (nr, nc, m) \\<Rightarrow>\n      (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n   (\\<lambda>(i, j).\n       if k = i then mul a (mat_impl A $$ (i, j))\n       else mat_impl A $$ (i, j)) $$\n  (i, j) =\n  mat_impl (mat_multrow_gen_impl mul k a A) $$ (i, j)\n\ngoal (2 subgoals):\n 1. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mul a (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (mat_multrow_gen_impl mul k a A))\n 2. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i then mul a (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (mat_multrow_gen_impl mul k a A))", "qed ((transfer, auto)+)"], ["", "lift_definition mat_addrow_gen_impl \n  :: \"('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a mat_impl \\<Rightarrow> 'a mat_impl\" is\n  \"\\<lambda> ad mul a k l (nr,nc,A). if l < nr then let Ak = IArray.sub A k; Al = IArray.sub A l;\n     Ak' = IArray.of_fun (\\<lambda> i. ad (mul a (Al !! i)) (Ak !! i)) (min (IArray.length Ak) (IArray.length Al));\n     A' = IArray.of_fun (\\<lambda> i. if i = k then Ak' else A !! i) (IArray.length A)\n     in (nr,nc,A') else (nr,nc,A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 a nat1 nat2 prod.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, A) \\<Rightarrow>\n          if nat2 < nr\n          then let Ak = A !! nat1; Al = A !! nat2;\n                   Ak' =\n                     IArray.of_fun\n                      (\\<lambda>i. fun1 (fun2 a (Al !! i)) (Ak !! i))\n                      (min (IArray.length Ak) (IArray.length Al));\n                   A' = IArray.of_fun\n                         (\\<lambda>i. if i = nat1 then Ak' else A !! i)\n                         (IArray.length A)\n               in (nr, nc, A')\n          else (nr, nc, A))\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 a nat1 nat2 prod.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, A) \\<Rightarrow>\n          if nat2 < nr\n          then let Ak = A !! nat1; Al = A !! nat2;\n                   Ak' =\n                     IArray.of_fun\n                      (\\<lambda>i. fun1 (fun2 a (Al !! i)) (Ak !! i))\n                      (min (IArray.length Ak) (IArray.length Al));\n                   A' = IArray.of_fun\n                         (\\<lambda>i. if i = nat1 then Ak' else A !! i)\n                         (IArray.length A)\n               in (nr, nc, A')\n          else (nr, nc, A))\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "case (1 ad mul a k l pp)"], ["proof (state)\nthis:\n  pp \\<in> {(nr, nc, m).\n            IArray.length m = nr \\<and>\n            IArray.all (\\<lambda>r. IArray.length r = nc) m}\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 a nat1 nat2 prod.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, A) \\<Rightarrow>\n          if nat2 < nr\n          then let Ak = A !! nat1; Al = A !! nat2;\n                   Ak' =\n                     IArray.of_fun\n                      (\\<lambda>i. fun1 (fun2 a (Al !! i)) (Ak !! i))\n                      (min (IArray.length Ak) (IArray.length Al));\n                   A' = IArray.of_fun\n                         (\\<lambda>i. if i = nat1 then Ak' else A !! i)\n                         (IArray.length A)\n               in (nr, nc, A')\n          else (nr, nc, A))\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "obtain nr nc A where pp: \"pp = (nr,nc,A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nr nc A.\n        pp = (nr, nc, A) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases pp)"], ["proof (state)\nthis:\n  pp = (nr, nc, A)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 a nat1 nat2 prod.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, A) \\<Rightarrow>\n          if nat2 < nr\n          then let Ak = A !! nat1; Al = A !! nat2;\n                   Ak' =\n                     IArray.of_fun\n                      (\\<lambda>i. fun1 (fun2 a (Al !! i)) (Ak !! i))\n                      (min (IArray.length Ak) (IArray.length Al));\n                   A' = IArray.of_fun\n                         (\\<lambda>i. if i = nat1 then Ak' else A !! i)\n                         (IArray.length A)\n               in (nr, nc, A')\n          else (nr, nc, A))\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "obtain rows where A: \"A = IArray rows\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rows. A = IArray rows \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases A)"], ["proof (state)\nthis:\n  A = IArray rows\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 a nat1 nat2 prod.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, A) \\<Rightarrow>\n          if nat2 < nr\n          then let Ak = A !! nat1; Al = A !! nat2;\n                   Ak' =\n                     IArray.of_fun\n                      (\\<lambda>i. fun1 (fun2 a (Al !! i)) (Ak !! i))\n                      (min (IArray.length Ak) (IArray.length Al));\n                   A' = IArray.of_fun\n                         (\\<lambda>i. if i = nat1 then Ak' else A !! i)\n                         (IArray.length A)\n               in (nr, nc, A')\n          else (nr, nc, A))\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "from 1[unfolded pp A, simplified]"], ["proof (chain)\npicking this:\n  length rows = nr \\<and>\n  (\\<forall>a\\<in>set rows. length (IArray.list_of a) = nc)", "have nr: \"length rows = nr\" and nc: \"\\<And> r. r\\<in>set rows \\<Longrightarrow> length (IArray.list_of r) = nc\""], ["proof (prove)\nusing this:\n  length rows = nr \\<and>\n  (\\<forall>a\\<in>set rows. length (IArray.list_of a) = nc)\n\ngoal (1 subgoal):\n 1. length rows = nr &&&\n    (\\<And>r.\n        r \\<in> set rows \\<Longrightarrow> length (IArray.list_of r) = nc)", "by auto"], ["proof (state)\nthis:\n  length rows = nr\n  ?r \\<in> set rows \\<Longrightarrow> length (IArray.list_of ?r) = nc\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 a nat1 nat2 prod.\n       prod\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc)\n               m} \\<Longrightarrow>\n       (case prod of\n        (nr, nc, A) \\<Rightarrow>\n          if nat2 < nr\n          then let Ak = A !! nat1; Al = A !! nat2;\n                   Ak' =\n                     IArray.of_fun\n                      (\\<lambda>i. fun1 (fun2 a (Al !! i)) (Ak !! i))\n                      (min (IArray.length Ak) (IArray.length Al));\n                   A' = IArray.of_fun\n                         (\\<lambda>i. if i = nat1 then Ak' else A !! i)\n                         (IArray.length A)\n               in (nr, nc, A')\n          else (nr, nc, A))\n       \\<in> {(nr, nc, m).\n              IArray.length m = nr \\<and>\n              IArray.all (\\<lambda>r. IArray.length r = nc) m}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case pp of\n     (nr, nc, A) \\<Rightarrow>\n       if l < nr\n       then let Ak = A !! k; Al = A !! l;\n                Ak' =\n                  IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                   (min (IArray.length Ak) (IArray.length Al));\n                A' = IArray.of_fun\n                      (\\<lambda>i. if i = k then Ak' else A !! i)\n                      (IArray.length A)\n            in (nr, nc, A')\n       else (nr, nc, A))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "proof (cases \"l < nr\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l < nr \\<Longrightarrow>\n    (case pp of\n     (nr, nc, A) \\<Rightarrow>\n       if l < nr\n       then let Ak = A !! k; Al = A !! l;\n                Ak' =\n                  IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                   (min (IArray.length Ak) (IArray.length Al));\n                A' = IArray.of_fun\n                      (\\<lambda>i. if i = k then Ak' else A !! i)\n                      (IArray.length A)\n            in (nr, nc, A')\n       else (nr, nc, A))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}\n 2. \\<not> l < nr \\<Longrightarrow>\n    (case pp of\n     (nr, nc, A) \\<Rightarrow>\n       if l < nr\n       then let Ak = A !! k; Al = A !! l;\n                Ak' =\n                  IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                   (min (IArray.length Ak) (IArray.length Al));\n                A' = IArray.of_fun\n                      (\\<lambda>i. if i = k then Ak' else A !! i)\n                      (IArray.length A)\n            in (nr, nc, A')\n       else (nr, nc, A))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "case False"], ["proof (state)\nthis:\n  \\<not> l < nr\n\ngoal (2 subgoals):\n 1. l < nr \\<Longrightarrow>\n    (case pp of\n     (nr, nc, A) \\<Rightarrow>\n       if l < nr\n       then let Ak = A !! k; Al = A !! l;\n                Ak' =\n                  IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                   (min (IArray.length Ak) (IArray.length Al));\n                A' = IArray.of_fun\n                      (\\<lambda>i. if i = k then Ak' else A !! i)\n                      (IArray.length A)\n            in (nr, nc, A')\n       else (nr, nc, A))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}\n 2. \\<not> l < nr \\<Longrightarrow>\n    (case pp of\n     (nr, nc, A) \\<Rightarrow>\n       if l < nr\n       then let Ak = A !! k; Al = A !! l;\n                Ak' =\n                  IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                   (min (IArray.length Ak) (IArray.length Al));\n                A' = IArray.of_fun\n                      (\\<lambda>i. if i = k then Ak' else A !! i)\n                      (IArray.length A)\n            in (nr, nc, A')\n       else (nr, nc, A))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> l < nr\n\ngoal (1 subgoal):\n 1. (case pp of\n     (nr, nc, A) \\<Rightarrow>\n       if l < nr\n       then let Ak = A !! k; Al = A !! l;\n                Ak' =\n                  IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                   (min (IArray.length Ak) (IArray.length Al));\n                A' = IArray.of_fun\n                      (\\<lambda>i. if i = k then Ak' else A !! i)\n                      (IArray.length A)\n            in (nr, nc, A')\n       else (nr, nc, A))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "unfolding pp A prod.simps"], ["proof (prove)\nusing this:\n  \\<not> l < nr\n\ngoal (1 subgoal):\n 1. (if l < nr\n     then let Ak = IArray rows !! k; Al = IArray rows !! l;\n              Ak' =\n                IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                 (min (IArray.length Ak) (IArray.length Al));\n              A' = IArray.of_fun\n                    (\\<lambda>i. if i = k then Ak' else IArray rows !! i)\n                    (IArray.length (IArray rows))\n          in (nr, nc, A')\n     else (nr, nc, IArray rows))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "using nr nc"], ["proof (prove)\nusing this:\n  \\<not> l < nr\n  length rows = nr\n  ?r \\<in> set rows \\<Longrightarrow> length (IArray.list_of ?r) = nc\n\ngoal (1 subgoal):\n 1. (if l < nr\n     then let Ak = IArray rows !! k; Al = IArray rows !! l;\n              Ak' =\n                IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                 (min (IArray.length Ak) (IArray.length Al));\n              A' = IArray.of_fun\n                    (\\<lambda>i. if i = k then Ak' else IArray rows !! i)\n                    (IArray.length (IArray rows))\n          in (nr, nc, A')\n     else (nr, nc, IArray rows))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "by auto"], ["proof (state)\nthis:\n  (case pp of\n   (nr, nc, A) \\<Rightarrow>\n     if l < nr\n     then let Ak = A !! k; Al = A !! l;\n              Ak' =\n                IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                 (min (IArray.length Ak) (IArray.length Al));\n              A' = IArray.of_fun (\\<lambda>i. if i = k then Ak' else A !! i)\n                    (IArray.length A)\n          in (nr, nc, A')\n     else (nr, nc, A))\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n\ngoal (1 subgoal):\n 1. l < nr \\<Longrightarrow>\n    (case pp of\n     (nr, nc, A) \\<Rightarrow>\n       if l < nr\n       then let Ak = A !! k; Al = A !! l;\n                Ak' =\n                  IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                   (min (IArray.length Ak) (IArray.length Al));\n                A' = IArray.of_fun\n                      (\\<lambda>i. if i = k then Ak' else A !! i)\n                      (IArray.length A)\n            in (nr, nc, A')\n       else (nr, nc, A))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l < nr \\<Longrightarrow>\n    (case pp of\n     (nr, nc, A) \\<Rightarrow>\n       if l < nr\n       then let Ak = A !! k; Al = A !! l;\n                Ak' =\n                  IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                   (min (IArray.length Ak) (IArray.length Al));\n                A' = IArray.of_fun\n                      (\\<lambda>i. if i = k then Ak' else A !! i)\n                      (IArray.length A)\n            in (nr, nc, A')\n       else (nr, nc, A))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "case True"], ["proof (state)\nthis:\n  l < nr\n\ngoal (1 subgoal):\n 1. l < nr \\<Longrightarrow>\n    (case pp of\n     (nr, nc, A) \\<Rightarrow>\n       if l < nr\n       then let Ak = A !! k; Al = A !! l;\n                Ak' =\n                  IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                   (min (IArray.length Ak) (IArray.length Al));\n                A' = IArray.of_fun\n                      (\\<lambda>i. if i = k then Ak' else A !! i)\n                      (IArray.length A)\n            in (nr, nc, A')\n       else (nr, nc, A))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "thus ?thesis"], ["proof (prove)\nusing this:\n  l < nr\n\ngoal (1 subgoal):\n 1. (case pp of\n     (nr, nc, A) \\<Rightarrow>\n       if l < nr\n       then let Ak = A !! k; Al = A !! l;\n                Ak' =\n                  IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                   (min (IArray.length Ak) (IArray.length Al));\n                A' = IArray.of_fun\n                      (\\<lambda>i. if i = k then Ak' else A !! i)\n                      (IArray.length A)\n            in (nr, nc, A')\n       else (nr, nc, A))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "unfolding pp A prod.simps Let_def"], ["proof (prove)\nusing this:\n  l < nr\n\ngoal (1 subgoal):\n 1. (if l < nr\n     then (nr, nc,\n           IArray.of_fun\n            (\\<lambda>i.\n                if i = k\n                then IArray.of_fun\n                      (\\<lambda>i.\n                          ad (mul a (IArray rows !! l !! i))\n                           (IArray rows !! k !! i))\n                      (min (IArray.length (IArray rows !! k))\n                        (IArray.length (IArray rows !! l)))\n                else IArray rows !! i)\n            (IArray.length (IArray rows)))\n     else (nr, nc, IArray rows))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "using nr nc"], ["proof (prove)\nusing this:\n  l < nr\n  length rows = nr\n  ?r \\<in> set rows \\<Longrightarrow> length (IArray.list_of ?r) = nc\n\ngoal (1 subgoal):\n 1. (if l < nr\n     then (nr, nc,\n           IArray.of_fun\n            (\\<lambda>i.\n                if i = k\n                then IArray.of_fun\n                      (\\<lambda>i.\n                          ad (mul a (IArray rows !! l !! i))\n                           (IArray rows !! k !! i))\n                      (min (IArray.length (IArray rows !! k))\n                        (IArray.length (IArray rows !! l)))\n                else IArray rows !! i)\n            (IArray.length (IArray rows)))\n     else (nr, nc, IArray rows))\n    \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}", "by (auto simp: set_list_update dest: in_set_takeD in_set_dropD)"], ["proof (state)\nthis:\n  (case pp of\n   (nr, nc, A) \\<Rightarrow>\n     if l < nr\n     then let Ak = A !! k; Al = A !! l;\n              Ak' =\n                IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                 (min (IArray.length Ak) (IArray.length Al));\n              A' = IArray.of_fun (\\<lambda>i. if i = k then Ak' else A !! i)\n                    (IArray.length A)\n          in (nr, nc, A')\n     else (nr, nc, A))\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case pp of\n   (nr, nc, A) \\<Rightarrow>\n     if l < nr\n     then let Ak = A !! k; Al = A !! l;\n              Ak' =\n                IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                 (min (IArray.length Ak) (IArray.length Al));\n              A' = IArray.of_fun (\\<lambda>i. if i = k then Ak' else A !! i)\n                    (IArray.length A)\n          in (nr, nc, A')\n     else (nr, nc, A))\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_addrow_gen_impl[code]: \"mat_addrow_gen ad mul a k l (mat_impl A) = (if l < dim_row_impl A then\n  mat_impl (mat_addrow_gen_impl ad mul a k l A) else Code.abort (STR ''index out of bounds in mat_addrow'') \n  (\\<lambda> _. mat_addrow_gen ad mul a k l (mat_impl A)))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_addrow_gen ad mul a k l (mat_impl A) =\n    (if l < dim_row_impl A\n     then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n     else Code.abort STR ''index out of bounds in mat_addrow''\n           (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A)))", "proof (cases \"l < dim_row_impl A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l < dim_row_impl A \\<Longrightarrow>\n    mat_addrow_gen ad mul a k l (mat_impl A) =\n    (if l < dim_row_impl A\n     then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n     else Code.abort STR ''index out of bounds in mat_addrow''\n           (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A)))\n 2. \\<not> l < dim_row_impl A \\<Longrightarrow>\n    mat_addrow_gen ad mul a k l (mat_impl A) =\n    (if l < dim_row_impl A\n     then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n     else Code.abort STR ''index out of bounds in mat_addrow''\n           (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A)))", "case True"], ["proof (state)\nthis:\n  l < dim_row_impl A\n\ngoal (2 subgoals):\n 1. l < dim_row_impl A \\<Longrightarrow>\n    mat_addrow_gen ad mul a k l (mat_impl A) =\n    (if l < dim_row_impl A\n     then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n     else Code.abort STR ''index out of bounds in mat_addrow''\n           (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A)))\n 2. \\<not> l < dim_row_impl A \\<Longrightarrow>\n    mat_addrow_gen ad mul a k l (mat_impl A) =\n    (if l < dim_row_impl A\n     then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n     else Code.abort STR ''index out of bounds in mat_addrow''\n           (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A)))", "hence id: \"?r = mat_impl (mat_addrow_gen_impl ad mul a k l A)\""], ["proof (prove)\nusing this:\n  l < dim_row_impl A\n\ngoal (1 subgoal):\n 1. (if l < dim_row_impl A\n     then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n     else Code.abort STR ''index out of bounds in mat_addrow''\n           (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A))) =\n    mat_impl (mat_addrow_gen_impl ad mul a k l A)", "by simp"], ["proof (state)\nthis:\n  (if l < dim_row_impl A then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n   else Code.abort STR ''index out of bounds in mat_addrow''\n         (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A))) =\n  mat_impl (mat_addrow_gen_impl ad mul a k l A)\n\ngoal (2 subgoals):\n 1. l < dim_row_impl A \\<Longrightarrow>\n    mat_addrow_gen ad mul a k l (mat_impl A) =\n    (if l < dim_row_impl A\n     then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n     else Code.abort STR ''index out of bounds in mat_addrow''\n           (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A)))\n 2. \\<not> l < dim_row_impl A \\<Longrightarrow>\n    mat_addrow_gen ad mul a k l (mat_impl A) =\n    (if l < dim_row_impl A\n     then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n     else Code.abort STR ''index out of bounds in mat_addrow''\n           (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_addrow_gen ad mul a k l (mat_impl A) =\n    (if l < dim_row_impl A\n     then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n     else Code.abort STR ''index out of bounds in mat_addrow''\n           (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A)))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_addrow_gen ad mul a k l (mat_impl A) =\n    mat_impl (mat_addrow_gen_impl ad mul a k l A)", "unfolding mat_addrow_gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if k = i\n         then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n         else mat_impl A $$ (i, j)) =\n    mat_impl (mat_addrow_gen_impl ad mul a k l A)", "proof (rule eq_matI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat_impl (mat_addrow_gen_impl ad mul a k l A));\n        j < dim_col (mat_impl (mat_addrow_gen_impl ad mul a k l A))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n                          (\\<lambda>(i, j).\n                              if k = i\n                              then ad (mul a (mat_impl A $$ (l, j)))\n                                    (mat_impl A $$ (i, j))\n                              else mat_impl A $$ (i, j)) $$\n                         (i, j) =\n                         mat_impl (mat_addrow_gen_impl ad mul a k l A) $$\n                         (i, j)\n 2. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i\n           then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (mat_addrow_gen_impl ad mul a k l A))\n 3. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i\n           then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (mat_addrow_gen_impl ad mul a k l A))", "case (1 i j)"], ["proof (state)\nthis:\n  i < dim_row (mat_impl (mat_addrow_gen_impl ad mul a k l A))\n  j < dim_col (mat_impl (mat_addrow_gen_impl ad mul a k l A))\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (mat_impl (mat_addrow_gen_impl ad mul a k l A));\n        j < dim_col (mat_impl (mat_addrow_gen_impl ad mul a k l A))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n                          (\\<lambda>(i, j).\n                              if k = i\n                              then ad (mul a (mat_impl A $$ (l, j)))\n                                    (mat_impl A $$ (i, j))\n                              else mat_impl A $$ (i, j)) $$\n                         (i, j) =\n                         mat_impl (mat_addrow_gen_impl ad mul a k l A) $$\n                         (i, j)\n 2. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i\n           then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (mat_addrow_gen_impl ad mul a k l A))\n 3. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i\n           then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (mat_addrow_gen_impl ad mul a k l A))", "thus ?case"], ["proof (prove)\nusing this:\n  i < dim_row (mat_impl (mat_addrow_gen_impl ad mul a k l A))\n  j < dim_col (mat_impl (mat_addrow_gen_impl ad mul a k l A))\n\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if k = i\n         then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n         else mat_impl A $$ (i, j)) $$\n    (i, j) =\n    mat_impl (mat_addrow_gen_impl ad mul a k l A) $$ (i, j)", "using True"], ["proof (prove)\nusing this:\n  i < dim_row (mat_impl (mat_addrow_gen_impl ad mul a k l A))\n  j < dim_col (mat_impl (mat_addrow_gen_impl ad mul a k l A))\n  l < dim_row_impl A\n\ngoal (1 subgoal):\n 1. mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n     (\\<lambda>(i, j).\n         if k = i\n         then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n         else mat_impl A $$ (i, j)) $$\n    (i, j) =\n    mat_impl (mat_addrow_gen_impl ad mul a k l A) $$ (i, j)", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ad mul a k l A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        if l < nr\n                        then let Ak = A !! k; Al = A !! l;\n                                 Ak' =\n                                   IArray.of_fun\n                                    (\\<lambda>i.\n  ad (mul a (Al !! i)) (Ak !! i))\n                                    (min (IArray.length Ak)\n(IArray.length Al));\n                                 A' = IArray.of_fun\n (\\<lambda>i. if i = k then Ak' else A !! i) (IArray.length A)\n                             in (nr, nc, A')\n                        else (nr, nc, A) of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     if l < nr\n                     then let Ak = A !! k; Al = A !! l;\n                              Ak' =\n                                IArray.of_fun\n                                 (\\<lambda>i.\n                                     ad (mul a (Al !! i)) (Ak !! i))\n                                 (min (IArray.length Ak)\n                                   (IArray.length Al));\n                              A' = IArray.of_fun\n                                    (\\<lambda>i.\n  if i = k then Ak' else A !! i)\n                                    (IArray.length A)\n                          in (nr, nc, A')\n                     else (nr, nc, A) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        l < fst A\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then ad\n(mul a\n  ((snd \\<circ> snd)\n    (case A of\n     (nr, nc, m) \\<Rightarrow>\n       (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n    (l, j)))\n((snd \\<circ> snd)\n  (case A of\n   (nr, nc, m) \\<Rightarrow>\n     (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  (i, j))\n                                else (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  if l < nr\n                                  then let Ak = A !! k; Al = A !! l;\n     Ak' =\n       IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n        (min (IArray.length Ak) (IArray.length Al));\n     A' = IArray.of_fun (\\<lambda>i. if i = k then Ak' else A !! i)\n           (IArray.length A)\n in (nr, nc, A')\n                                  else (nr, nc, A) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "case (1 i ad mul a k l A j)"], ["proof (state)\nthis:\n  A \\<in> {(nr, nc, m).\n           IArray.length m = nr \\<and>\n           IArray.all (\\<lambda>r. IArray.length r = nc) m}\n  i < fst (case case A of\n                (nr, nc, A) \\<Rightarrow>\n                  if l < nr\n                  then let Ak = A !! k; Al = A !! l;\n                           Ak' =\n                             IArray.of_fun\n                              (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                              (min (IArray.length Ak) (IArray.length Al));\n                           A' = IArray.of_fun\n                                 (\\<lambda>i. if i = k then Ak' else A !! i)\n                                 (IArray.length A)\n                       in (nr, nc, A')\n                  else (nr, nc, A) of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  j < (fst \\<circ> snd)\n       (case case A of\n             (nr, nc, A) \\<Rightarrow>\n               if l < nr\n               then let Ak = A !! k; Al = A !! l;\n                        Ak' =\n                          IArray.of_fun\n                           (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                           (min (IArray.length Ak) (IArray.length Al));\n                        A' = IArray.of_fun\n                              (\\<lambda>i. if i = k then Ak' else A !! i)\n                              (IArray.length A)\n                    in (nr, nc, A')\n               else (nr, nc, A) of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  l < fst A\n\ngoal (1 subgoal):\n 1. \\<And>i ad mul a k l A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        if l < nr\n                        then let Ak = A !! k; Al = A !! l;\n                                 Ak' =\n                                   IArray.of_fun\n                                    (\\<lambda>i.\n  ad (mul a (Al !! i)) (Ak !! i))\n                                    (min (IArray.length Ak)\n(IArray.length Al));\n                                 A' = IArray.of_fun\n (\\<lambda>i. if i = k then Ak' else A !! i) (IArray.length A)\n                             in (nr, nc, A')\n                        else (nr, nc, A) of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     if l < nr\n                     then let Ak = A !! k; Al = A !! l;\n                              Ak' =\n                                IArray.of_fun\n                                 (\\<lambda>i.\n                                     ad (mul a (Al !! i)) (Ak !! i))\n                                 (min (IArray.length Ak)\n                                   (IArray.length Al));\n                              A' = IArray.of_fun\n                                    (\\<lambda>i.\n  if i = k then Ak' else A !! i)\n                                    (IArray.length A)\n                          in (nr, nc, A')\n                     else (nr, nc, A) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        l < fst A\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then ad\n(mul a\n  ((snd \\<circ> snd)\n    (case A of\n     (nr, nc, m) \\<Rightarrow>\n       (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n    (l, j)))\n((snd \\<circ> snd)\n  (case A of\n   (nr, nc, m) \\<Rightarrow>\n     (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  (i, j))\n                                else (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  if l < nr\n                                  then let Ak = A !! k; Al = A !! l;\n     Ak' =\n       IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n        (min (IArray.length Ak) (IArray.length Al));\n     A' = IArray.of_fun (\\<lambda>i. if i = k then Ak' else A !! i)\n           (IArray.length A)\n in (nr, nc, A')\n                                  else (nr, nc, A) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "obtain nr nc rows where A: \"A = (nr,nc,rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nr nc rows.\n        A = (nr, nc, rows) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases A, auto)"], ["proof (state)\nthis:\n  A = (nr, nc, rows)\n\ngoal (1 subgoal):\n 1. \\<And>i ad mul a k l A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        if l < nr\n                        then let Ak = A !! k; Al = A !! l;\n                                 Ak' =\n                                   IArray.of_fun\n                                    (\\<lambda>i.\n  ad (mul a (Al !! i)) (Ak !! i))\n                                    (min (IArray.length Ak)\n(IArray.length Al));\n                                 A' = IArray.of_fun\n (\\<lambda>i. if i = k then Ak' else A !! i) (IArray.length A)\n                             in (nr, nc, A')\n                        else (nr, nc, A) of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     if l < nr\n                     then let Ak = A !! k; Al = A !! l;\n                              Ak' =\n                                IArray.of_fun\n                                 (\\<lambda>i.\n                                     ad (mul a (Al !! i)) (Ak !! i))\n                                 (min (IArray.length Ak)\n                                   (IArray.length Al));\n                              A' = IArray.of_fun\n                                    (\\<lambda>i.\n  if i = k then Ak' else A !! i)\n                                    (IArray.length A)\n                          in (nr, nc, A')\n                     else (nr, nc, A) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        l < fst A\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then ad\n(mul a\n  ((snd \\<circ> snd)\n    (case A of\n     (nr, nc, m) \\<Rightarrow>\n       (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n    (l, j)))\n((snd \\<circ> snd)\n  (case A of\n   (nr, nc, m) \\<Rightarrow>\n     (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  (i, j))\n                                else (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  if l < nr\n                                  then let Ak = A !! k; Al = A !! l;\n     Ak' =\n       IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n        (min (IArray.length Ak) (IArray.length Al));\n     A' = IArray.of_fun (\\<lambda>i. if i = k then Ak' else A !! i)\n           (IArray.length A)\n in (nr, nc, A')\n                                  else (nr, nc, A) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "from 1[unfolded A Let_def]"], ["proof (chain)\npicking this:\n  (nr, nc, rows)\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n  i < fst (case case (nr, nc, rows) of\n                (nr, nc, A) \\<Rightarrow>\n                  if l < nr\n                  then (nr, nc,\n                        IArray.of_fun\n                         (\\<lambda>i.\n                             if i = k\n                             then IArray.of_fun\n                                   (\\<lambda>i.\n ad (mul a (A !! l !! i)) (A !! k !! i))\n                                   (min (IArray.length (A !! k))\n                                     (IArray.length (A !! l)))\n                             else A !! i)\n                         (IArray.length A))\n                  else (nr, nc, A) of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  j < (fst \\<circ> snd)\n       (case case (nr, nc, rows) of\n             (nr, nc, A) \\<Rightarrow>\n               if l < nr\n               then (nr, nc,\n                     IArray.of_fun\n                      (\\<lambda>i.\n                          if i = k\n                          then IArray.of_fun\n                                (\\<lambda>i.\n                                    ad (mul a (A !! l !! i)) (A !! k !! i))\n                                (min (IArray.length (A !! k))\n                                  (IArray.length (A !! l)))\n                          else A !! i)\n                      (IArray.length A))\n               else (nr, nc, A) of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  l < fst (nr, nc, rows)", "have nr: \"length (IArray.list_of rows) = nr\"\n        and nc: \"IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\"\n        and ij: \"i < nr\" \"j < nc\" and ij': \"(i < nr \\<and> j < nc) = True\" \n        and l: \"l < nr\""], ["proof (prove)\nusing this:\n  (nr, nc, rows)\n  \\<in> {(nr, nc, m).\n         IArray.length m = nr \\<and>\n         IArray.all (\\<lambda>r. IArray.length r = nc) m}\n  i < fst (case case (nr, nc, rows) of\n                (nr, nc, A) \\<Rightarrow>\n                  if l < nr\n                  then (nr, nc,\n                        IArray.of_fun\n                         (\\<lambda>i.\n                             if i = k\n                             then IArray.of_fun\n                                   (\\<lambda>i.\n ad (mul a (A !! l !! i)) (A !! k !! i))\n                                   (min (IArray.length (A !! k))\n                                     (IArray.length (A !! l)))\n                             else A !! i)\n                         (IArray.length A))\n                  else (nr, nc, A) of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  j < (fst \\<circ> snd)\n       (case case (nr, nc, rows) of\n             (nr, nc, A) \\<Rightarrow>\n               if l < nr\n               then (nr, nc,\n                     IArray.of_fun\n                      (\\<lambda>i.\n                          if i = k\n                          then IArray.of_fun\n                                (\\<lambda>i.\n                                    ad (mul a (A !! l !! i)) (A !! k !! i))\n                                (min (IArray.length (A !! k))\n                                  (IArray.length (A !! l)))\n                          else A !! i)\n                      (IArray.length A))\n               else (nr, nc, A) of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  l < fst (nr, nc, rows)\n\ngoal (1 subgoal):\n 1. (length (IArray.list_of rows) = nr &&&\n     IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows) &&&\n    (i < nr &&& j < nc) &&& (i < nr \\<and> j < nc) = True &&& l < nr", "by auto"], ["proof (state)\nthis:\n  length (IArray.list_of rows) = nr\n  IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\n  i < nr\n  j < nc\n  (i < nr \\<and> j < nc) = True\n  l < nr\n\ngoal (1 subgoal):\n 1. \\<And>i ad mul a k l A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        if l < nr\n                        then let Ak = A !! k; Al = A !! l;\n                                 Ak' =\n                                   IArray.of_fun\n                                    (\\<lambda>i.\n  ad (mul a (Al !! i)) (Ak !! i))\n                                    (min (IArray.length Ak)\n(IArray.length Al));\n                                 A' = IArray.of_fun\n (\\<lambda>i. if i = k then Ak' else A !! i) (IArray.length A)\n                             in (nr, nc, A')\n                        else (nr, nc, A) of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     if l < nr\n                     then let Ak = A !! k; Al = A !! l;\n                              Ak' =\n                                IArray.of_fun\n                                 (\\<lambda>i.\n                                     ad (mul a (Al !! i)) (Ak !! i))\n                                 (min (IArray.length Ak)\n                                   (IArray.length Al));\n                              A' = IArray.of_fun\n                                    (\\<lambda>i.\n  if i = k then Ak' else A !! i)\n                                    (IArray.length A)\n                          in (nr, nc, A')\n                     else (nr, nc, A) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        l < fst A\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then ad\n(mul a\n  ((snd \\<circ> snd)\n    (case A of\n     (nr, nc, m) \\<Rightarrow>\n       (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n    (l, j)))\n((snd \\<circ> snd)\n  (case A of\n   (nr, nc, m) \\<Rightarrow>\n     (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  (i, j))\n                                else (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  if l < nr\n                                  then let Ak = A !! k; Al = A !! l;\n     Ak' =\n       IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n        (min (IArray.length Ak) (IArray.length Al));\n     A' = IArray.of_fun (\\<lambda>i. if i = k then Ak' else A !! i)\n           (IArray.length A)\n in (nr, nc, A')\n                                  else (nr, nc, A) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "have len: \"j < length (IArray.list_of (IArray.list_of rows ! i))\"\n        \"j < length (IArray.list_of (IArray.list_of rows ! l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length (IArray.list_of (IArray.list_of rows ! i)) &&&\n    j < length (IArray.list_of (IArray.list_of rows ! l))", "using ij nc nr l"], ["proof (prove)\nusing this:\n  i < nr\n  j < nc\n  IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\n  length (IArray.list_of rows) = nr\n  l < nr\n\ngoal (1 subgoal):\n 1. j < length (IArray.list_of (IArray.list_of rows ! i)) &&&\n    j < length (IArray.list_of (IArray.list_of rows ! l))", "by (cases rows, auto)+"], ["proof (state)\nthis:\n  j < length (IArray.list_of (IArray.list_of rows ! i))\n  j < length (IArray.list_of (IArray.list_of rows ! l))\n\ngoal (1 subgoal):\n 1. \\<And>i ad mul a k l A j.\n       \\<lbrakk>A \\<in> {(nr, nc, m).\n                         IArray.length m = nr \\<and>\n                         IArray.all (\\<lambda>r. IArray.length r = nc) m};\n        i < fst (case case A of\n                      (nr, nc, A) \\<Rightarrow>\n                        if l < nr\n                        then let Ak = A !! k; Al = A !! l;\n                                 Ak' =\n                                   IArray.of_fun\n                                    (\\<lambda>i.\n  ad (mul a (Al !! i)) (Ak !! i))\n                                    (min (IArray.length Ak)\n(IArray.length Al));\n                                 A' = IArray.of_fun\n (\\<lambda>i. if i = k then Ak' else A !! i) (IArray.length A)\n                             in (nr, nc, A')\n                        else (nr, nc, A) of\n                 (nr, nc, m) \\<Rightarrow>\n                   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        j < (fst \\<circ> snd)\n             (case case A of\n                   (nr, nc, A) \\<Rightarrow>\n                     if l < nr\n                     then let Ak = A !! k; Al = A !! l;\n                              Ak' =\n                                IArray.of_fun\n                                 (\\<lambda>i.\n                                     ad (mul a (Al !! i)) (Ak !! i))\n                                 (min (IArray.length Ak)\n                                   (IArray.length Al));\n                              A' = IArray.of_fun\n                                    (\\<lambda>i.\n  if i = k then Ak' else A !! i)\n                                    (IArray.length A)\n                          in (nr, nc, A')\n                     else (nr, nc, A) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)));\n        l < fst A\\<rbrakk>\n       \\<Longrightarrow> (snd \\<circ> snd)\n                          (fst (case A of\n                                (nr, nc, m) \\<Rightarrow>\n                                  (nr, nc,\n                                   mk_mat nr nc\n                                    (\\<lambda>(i, y). m !! i !! y))),\n                           (fst \\<circ> snd)\n                            (case A of\n                             (nr, nc, m) \\<Rightarrow>\n                               (nr, nc,\n                                mk_mat nr nc\n                                 (\\<lambda>(i, y). m !! i !! y))),\n                           mk_mat\n                            (fst (case A of\n                                  (nr, nc, m) \\<Rightarrow>\n                                    (nr, nc,\n                                     mk_mat nr nc\n(\\<lambda>(i, y). m !! i !! y))))\n                            ((fst \\<circ> snd)\n                              (case A of\n                               (nr, nc, m) \\<Rightarrow>\n                                 (nr, nc,\n                                  mk_mat nr nc\n                                   (\\<lambda>(i, y). m !! i !! y))))\n                            (\\<lambda>(i, j).\n                                if k = i\n                                then ad\n(mul a\n  ((snd \\<circ> snd)\n    (case A of\n     (nr, nc, m) \\<Rightarrow>\n       (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n    (l, j)))\n((snd \\<circ> snd)\n  (case A of\n   (nr, nc, m) \\<Rightarrow>\n     (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n  (i, j))\n                                else (snd \\<circ> snd)\n(case A of\n (nr, nc, m) \\<Rightarrow>\n   (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n(i, j)))\n                          (i, j) =\n                         (snd \\<circ> snd)\n                          (case case A of\n                                (nr, nc, A) \\<Rightarrow>\n                                  if l < nr\n                                  then let Ak = A !! k; Al = A !! l;\n     Ak' =\n       IArray.of_fun (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n        (min (IArray.length Ak) (IArray.length Al));\n     A' = IArray.of_fun (\\<lambda>i. if i = k then Ak' else A !! i)\n           (IArray.length A)\n in (nr, nc, A')\n                                  else (nr, nc, A) of\n                           (nr, nc, m) \\<Rightarrow>\n                             (nr, nc,\n                              mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                          (i, j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd \\<circ> snd)\n     (fst (case A of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n      (fst \\<circ> snd)\n       (case A of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n      mk_mat\n       (fst (case A of\n             (nr, nc, m) \\<Rightarrow>\n               (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n       ((fst \\<circ> snd)\n         (case A of\n          (nr, nc, m) \\<Rightarrow>\n            (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n       (\\<lambda>(i, j).\n           if k = i\n           then ad (mul a\n                     ((snd \\<circ> snd)\n                       (case A of\n                        (nr, nc, m) \\<Rightarrow>\n                          (nr, nc,\n                           mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                       (l, j)))\n                 ((snd \\<circ> snd)\n                   (case A of\n                    (nr, nc, m) \\<Rightarrow>\n                      (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                   (i, j))\n           else (snd \\<circ> snd)\n                 (case A of\n                  (nr, nc, m) \\<Rightarrow>\n                    (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                 (i, j)))\n     (i, j) =\n    (snd \\<circ> snd)\n     (case case A of\n           (nr, nc, A) \\<Rightarrow>\n             if l < nr\n             then let Ak = A !! k; Al = A !! l;\n                      Ak' =\n                        IArray.of_fun\n                         (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                         (min (IArray.length Ak) (IArray.length Al));\n                      A' = IArray.of_fun\n                            (\\<lambda>i. if i = k then Ak' else A !! i)\n                            (IArray.length A)\n                  in (nr, nc, A')\n             else (nr, nc, A) of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j)", "unfolding A prod.simps fst_conv o_def snd_conv Let_def mk_mat_def ij' if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k = i\n     then ad (mul a\n               (if l < nr \\<and> j < nc then rows !! l !! j\n                else undef_mat nr nc (\\<lambda>(i, y). rows !! i !! y)\n                      (l, j)))\n           (rows !! i !! j)\n     else rows !! i !! j) =\n    snd (snd (case if l < nr\n                   then (nr, nc,\n                         IArray.of_fun\n                          (\\<lambda>i.\n                              if i = k\n                              then IArray.of_fun\n                                    (\\<lambda>i.\n  ad (mul a (rows !! l !! i)) (rows !! k !! i))\n                                    (min (IArray.length (rows !! k))\n(IArray.length (rows !! l)))\n                              else rows !! i)\n                          (IArray.length rows))\n                   else (nr, nc, rows) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc,\n                 \\<lambda>(i, j).\n                    if i < nr \\<and> j < nc then m !! i !! j\n                    else undef_mat nr nc (\\<lambda>(i, y). m !! i !! y)\n                          (i, j))))\n     (i, j)", "using ij nr nc l"], ["proof (prove)\nusing this:\n  i < nr\n  j < nc\n  length (IArray.list_of rows) = nr\n  IArray.all (\\<lambda>r. length (IArray.list_of r) = nc) rows\n  l < nr\n\ngoal (1 subgoal):\n 1. (if k = i\n     then ad (mul a\n               (if l < nr \\<and> j < nc then rows !! l !! j\n                else undef_mat nr nc (\\<lambda>(i, y). rows !! i !! y)\n                      (l, j)))\n           (rows !! i !! j)\n     else rows !! i !! j) =\n    snd (snd (case if l < nr\n                   then (nr, nc,\n                         IArray.of_fun\n                          (\\<lambda>i.\n                              if i = k\n                              then IArray.of_fun\n                                    (\\<lambda>i.\n  ad (mul a (rows !! l !! i)) (rows !! k !! i))\n                                    (min (IArray.length (rows !! k))\n(IArray.length (rows !! l)))\n                              else rows !! i)\n                          (IArray.length rows))\n                   else (nr, nc, rows) of\n              (nr, nc, m) \\<Rightarrow>\n                (nr, nc,\n                 \\<lambda>(i, j).\n                    if i < nr \\<and> j < nc then m !! i !! j\n                    else undef_mat nr nc (\\<lambda>(i, y). m !! i !! y)\n                          (i, j))))\n     (i, j)", "by (cases \"k = i\", auto simp: len)"], ["proof (state)\nthis:\n  (snd \\<circ> snd)\n   (fst (case A of\n         (nr, nc, m) \\<Rightarrow>\n           (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n    (fst \\<circ> snd)\n     (case A of\n      (nr, nc, m) \\<Rightarrow>\n        (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))),\n    mk_mat\n     (fst (case A of\n           (nr, nc, m) \\<Rightarrow>\n             (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n     ((fst \\<circ> snd)\n       (case A of\n        (nr, nc, m) \\<Rightarrow>\n          (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y))))\n     (\\<lambda>(i, j).\n         if k = i\n         then ad (mul a\n                   ((snd \\<circ> snd)\n                     (case A of\n                      (nr, nc, m) \\<Rightarrow>\n                        (nr, nc,\n                         mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                     (l, j)))\n               ((snd \\<circ> snd)\n                 (case A of\n                  (nr, nc, m) \\<Rightarrow>\n                    (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n                 (i, j))\n         else (snd \\<circ> snd)\n               (case A of\n                (nr, nc, m) \\<Rightarrow>\n                  (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n               (i, j)))\n   (i, j) =\n  (snd \\<circ> snd)\n   (case case A of\n         (nr, nc, A) \\<Rightarrow>\n           if l < nr\n           then let Ak = A !! k; Al = A !! l;\n                    Ak' =\n                      IArray.of_fun\n                       (\\<lambda>i. ad (mul a (Al !! i)) (Ak !! i))\n                       (min (IArray.length Ak) (IArray.length Al));\n                    A' = IArray.of_fun\n                          (\\<lambda>i. if i = k then Ak' else A !! i)\n                          (IArray.length A)\n                in (nr, nc, A')\n           else (nr, nc, A) of\n    (nr, nc, m) \\<Rightarrow>\n      (nr, nc, mk_mat nr nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n   (\\<lambda>(i, j).\n       if k = i\n       then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n       else mat_impl A $$ (i, j)) $$\n  (i, j) =\n  mat_impl (mat_addrow_gen_impl ad mul a k l A) $$ (i, j)\n\ngoal (2 subgoals):\n 1. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i\n           then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (mat_addrow_gen_impl ad mul a k l A))\n 2. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i\n           then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (mat_addrow_gen_impl ad mul a k l A))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_row\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i\n           then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_row (mat_impl (mat_addrow_gen_impl ad mul a k l A))\n 2. dim_col\n     (mat (dim_row (mat_impl A)) (dim_col (mat_impl A))\n       (\\<lambda>(i, j).\n           if k = i\n           then ad (mul a (mat_impl A $$ (l, j))) (mat_impl A $$ (i, j))\n           else mat_impl A $$ (i, j))) =\n    dim_col (mat_impl (mat_addrow_gen_impl ad mul a k l A))", "qed ((transfer, auto simp:Let_def)+)"], ["proof (state)\nthis:\n  mat_addrow_gen ad mul a k l (mat_impl A) =\n  (if l < dim_row_impl A then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n   else Code.abort STR ''index out of bounds in mat_addrow''\n         (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A)))\n\ngoal (1 subgoal):\n 1. \\<not> l < dim_row_impl A \\<Longrightarrow>\n    mat_addrow_gen ad mul a k l (mat_impl A) =\n    (if l < dim_row_impl A\n     then mat_impl (mat_addrow_gen_impl ad mul a k l A)\n     else Code.abort STR ''index out of bounds in mat_addrow''\n           (\\<lambda>_. mat_addrow_gen ad mul a k l (mat_impl A)))", "qed simp"], ["", "lemma gauss_jordan_main_code[code]:\n  \"gauss_jordan_main A B i j = (let nr = dim_row A; nc = dim_col A in\n    if i < nr \\<and> j < nc then let aij = A $$ (i,j) in if aij = 0 then\n      (case [ i' . i' <- [Suc i ..< nr],  A $$ (i',j) \\<noteq> 0] \n        of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | (i' # _) \\<Rightarrow> gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n      else if aij = 1 then let v = (\\<lambda> i. A $$ (i,j)) in\n        gauss_jordan_main \n        (eliminate_entries v A i j) (eliminate_entries v B i j) (Suc i) (Suc j)\n      else let iaij = inverse aij; A' = multrow i iaij A; B' = multrow i iaij B;\n        v = (\\<lambda> i. A' $$ (i,j)) in gauss_jordan_main \n        (eliminate_entries v A' i j) (eliminate_entries v B' i j) (Suc i) (Suc j)\n    else (A,B))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "note simps = gauss_jordan_main.simps[of A B i j] Let_def"], ["proof (state)\nthis:\n  gauss_jordan_main A B i j =\n  (let nr = dim_row A; nc = dim_col A\n   in if i < nr \\<and> j < nc\n      then let aij = A $$ (i, j)\n           in if aij = (0::'a)\n              then case concat\n                         (map (\\<lambda>i'.\n                                  if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                                  else [])\n                           [Suc i..<nr]) of\n                   [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                   | i' # x \\<Rightarrow>\n                       gauss_jordan_main (swaprows i i' A) (swaprows i i' B)\n                        i j\n              else if aij = (1::'a)\n                   then let v = \\<lambda>i. A $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A i j)\n                            (eliminate_entries v B i j) (Suc i) (Suc j)\n                   else let iaij = inverse aij\n                        in gauss_jordan_main (multrow i iaij A)\n                            (multrow i iaij B) i j\n      else (A, B))\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "let ?nr = \"dim_row A\""], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "let ?nc = \"dim_col A\""], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "let ?A' = \"multrow i (inverse (A $$ (i,j))) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "let ?B' = \"multrow i (inverse (A $$ (i,j))) B\""], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "proof (cases \"i < ?nr \\<and> j < ?nc \\<and> A $$ (i,j) \\<noteq> 0 \\<and> A $$ (i,j) \\<noteq> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < dim_row A \\<and>\n    j < dim_col A \\<and>\n    A $$ (i, j) \\<noteq> (0::'a) \\<and>\n    A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))\n 2. \\<not> (i < dim_row A \\<and>\n            j < dim_col A \\<and>\n            A $$ (i, j) \\<noteq> (0::'a) \\<and>\n            A $$ (i, j) \\<noteq> (1::'a)) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "case False"], ["proof (state)\nthis:\n  \\<not> (i < dim_row A \\<and>\n          j < dim_col A \\<and>\n          A $$ (i, j) \\<noteq> (0::'a) \\<and> A $$ (i, j) \\<noteq> (1::'a))\n\ngoal (2 subgoals):\n 1. i < dim_row A \\<and>\n    j < dim_col A \\<and>\n    A $$ (i, j) \\<noteq> (0::'a) \\<and>\n    A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))\n 2. \\<not> (i < dim_row A \\<and>\n            j < dim_col A \\<and>\n            A $$ (i, j) \\<noteq> (0::'a) \\<and>\n            A $$ (i, j) \\<noteq> (1::'a)) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (i < dim_row A \\<and>\n          j < dim_col A \\<and>\n          A $$ (i, j) \\<noteq> (0::'a) \\<and> A $$ (i, j) \\<noteq> (1::'a))\n\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "unfolding simps"], ["proof (prove)\nusing this:\n  \\<not> (i < dim_row A \\<and>\n          j < dim_col A \\<and>\n          A $$ (i, j) \\<noteq> (0::'a) \\<and> A $$ (i, j) \\<noteq> (1::'a))\n\ngoal (1 subgoal):\n 1. (if i < dim_row A \\<and> j < dim_col A\n     then if A $$ (i, j) = (0::'a)\n          then case concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<dim_row A]) of\n               [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n               | i' # x \\<Rightarrow>\n                   gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n          else if A $$ (i, j) = (1::'a)\n               then gauss_jordan_main\n                     (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                     (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                     (Suc i) (Suc j)\n               else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                     (multrow i (inverse (A $$ (i, j))) B) i j\n     else (A, B)) =\n    (if i < dim_row A \\<and> j < dim_col A\n     then if A $$ (i, j) = (0::'a)\n          then case concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<dim_row A]) of\n               [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n               | i' # x \\<Rightarrow>\n                   gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n          else if A $$ (i, j) = (1::'a)\n               then gauss_jordan_main\n                     (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                     (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                     (Suc i) (Suc j)\n               else gauss_jordan_main\n                     (eliminate_entries\n                       (\\<lambda>ia.\n                           multrow i (inverse (A $$ (i, j))) A $$ (ia, j))\n                       (multrow i (inverse (A $$ (i, j))) A) i j)\n                     (eliminate_entries\n                       (\\<lambda>ia.\n                           multrow i (inverse (A $$ (i, j))) A $$ (ia, j))\n                       (multrow i (inverse (A $$ (i, j))) B) i j)\n                     (Suc i) (Suc j)\n     else (A, B))", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  gauss_jordan_main A B i j =\n  (let nr = dim_row A; nc = dim_col A\n   in if i < nr \\<and> j < nc\n      then let aij = A $$ (i, j)\n           in if aij = (0::'a)\n              then case concat\n                         (map (\\<lambda>i'.\n                                  if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                                  else [])\n                           [Suc i..<nr]) of\n                   [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                   | i' # x \\<Rightarrow>\n                       gauss_jordan_main (swaprows i i' A) (swaprows i i' B)\n                        i j\n              else if aij = (1::'a)\n                   then let v = \\<lambda>i. A $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A i j)\n                            (eliminate_entries v B i j) (Suc i) (Suc j)\n                   else let iaij = inverse aij; A' = multrow i iaij A;\n                            B' = multrow i iaij B;\n                            v = \\<lambda>i. A' $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A' i j)\n                            (eliminate_entries v B' i j) (Suc i) (Suc j)\n      else (A, B))\n\ngoal (1 subgoal):\n 1. i < dim_row A \\<and>\n    j < dim_col A \\<and>\n    A $$ (i, j) \\<noteq> (0::'a) \\<and>\n    A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < dim_row A \\<and>\n    j < dim_col A \\<and>\n    A $$ (i, j) \\<noteq> (0::'a) \\<and>\n    A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "case True"], ["proof (state)\nthis:\n  i < dim_row A \\<and>\n  j < dim_col A \\<and>\n  A $$ (i, j) \\<noteq> (0::'a) \\<and> A $$ (i, j) \\<noteq> (1::'a)\n\ngoal (1 subgoal):\n 1. i < dim_row A \\<and>\n    j < dim_col A \\<and>\n    A $$ (i, j) \\<noteq> (0::'a) \\<and>\n    A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "from True"], ["proof (chain)\npicking this:\n  i < dim_row A \\<and>\n  j < dim_col A \\<and>\n  A $$ (i, j) \\<noteq> (0::'a) \\<and> A $$ (i, j) \\<noteq> (1::'a)", "have id: \"?A' $$ (i,j) = 1\""], ["proof (prove)\nusing this:\n  i < dim_row A \\<and>\n  j < dim_col A \\<and>\n  A $$ (i, j) \\<noteq> (0::'a) \\<and> A $$ (i, j) \\<noteq> (1::'a)\n\ngoal (1 subgoal):\n 1. multrow i (inverse (A $$ (i, j))) A $$ (i, j) = (1::'a)", "by auto"], ["proof (state)\nthis:\n  multrow i (inverse (A $$ (i, j))) A $$ (i, j) = (1::'a)\n\ngoal (1 subgoal):\n 1. i < dim_row A \\<and>\n    j < dim_col A \\<and>\n    A $$ (i, j) \\<noteq> (0::'a) \\<and>\n    A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "from True"], ["proof (chain)\npicking this:\n  i < dim_row A \\<and>\n  j < dim_col A \\<and>\n  A $$ (i, j) \\<noteq> (0::'a) \\<and> A $$ (i, j) \\<noteq> (1::'a)", "have \"?l = gauss_jordan_main ?A' ?B' i j\""], ["proof (prove)\nusing this:\n  i < dim_row A \\<and>\n  j < dim_col A \\<and>\n  A $$ (i, j) \\<noteq> (0::'a) \\<and> A $$ (i, j) \\<noteq> (1::'a)\n\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n     (multrow i (inverse (A $$ (i, j))) B) i j", "unfolding simps"], ["proof (prove)\nusing this:\n  i < dim_row A \\<and>\n  j < dim_col A \\<and>\n  A $$ (i, j) \\<noteq> (0::'a) \\<and> A $$ (i, j) \\<noteq> (1::'a)\n\ngoal (1 subgoal):\n 1. (if i < dim_row A \\<and> j < dim_col A\n     then if A $$ (i, j) = (0::'a)\n          then case concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<dim_row A]) of\n               [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n               | i' # x \\<Rightarrow>\n                   gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n          else if A $$ (i, j) = (1::'a)\n               then gauss_jordan_main\n                     (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                     (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                     (Suc i) (Suc j)\n               else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                     (multrow i (inverse (A $$ (i, j))) B) i j\n     else (A, B)) =\n    gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n     (multrow i (inverse (A $$ (i, j))) B) i j", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  gauss_jordan_main A B i j =\n  gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n   (multrow i (inverse (A $$ (i, j))) B) i j\n\ngoal (1 subgoal):\n 1. i < dim_row A \\<and>\n    j < dim_col A \\<and>\n    A $$ (i, j) \\<noteq> (0::'a) \\<and>\n    A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "also"], ["proof (state)\nthis:\n  gauss_jordan_main A B i j =\n  gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n   (multrow i (inverse (A $$ (i, j))) B) i j\n\ngoal (1 subgoal):\n 1. i < dim_row A \\<and>\n    j < dim_col A \\<and>\n    A $$ (i, j) \\<noteq> (0::'a) \\<and>\n    A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n     (multrow i (inverse (A $$ (i, j))) B) i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "unfolding Let_def gauss_jordan_main.simps[of ?A' ?B' i j] id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < dim_row (multrow i (inverse (A $$ (i, j))) A) \\<and>\n        j < dim_col (multrow i (inverse (A $$ (i, j))) A)\n     then if (1::'a) = (0::'a)\n          then case concat\n                     (map (\\<lambda>i'.\n                              if multrow i (inverse (A $$ (i, j))) A $$\n                                 (i', j) \\<noteq>\n                                 (0::'a)\n                              then [i'] else [])\n                       [Suc i..<\n                        dim_row (multrow i (inverse (A $$ (i, j))) A)]) of\n               [] \\<Rightarrow>\n                 gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i (Suc j)\n               | i' # x \\<Rightarrow>\n                   gauss_jordan_main\n                    (swaprows i i' (multrow i (inverse (A $$ (i, j))) A))\n                    (swaprows i i' (multrow i (inverse (A $$ (i, j))) B)) i\n                    j\n          else if (1::'a) = (1::'a)\n               then gauss_jordan_main\n                     (eliminate_entries\n                       (\\<lambda>ia.\n                           multrow i (inverse (A $$ (i, j))) A $$ (ia, j))\n                       (multrow i (inverse (A $$ (i, j))) A) i j)\n                     (eliminate_entries\n                       (\\<lambda>ia.\n                           multrow i (inverse (A $$ (i, j))) A $$ (ia, j))\n                       (multrow i (inverse (A $$ (i, j))) B) i j)\n                     (Suc i) (Suc j)\n               else gauss_jordan_main\n                     (multrow i (inverse (1::'a))\n                       (multrow i (inverse (A $$ (i, j))) A))\n                     (multrow i (inverse (1::'a))\n                       (multrow i (inverse (A $$ (i, j))) B))\n                     i j\n     else (multrow i (inverse (A $$ (i, j))) A,\n           multrow i (inverse (A $$ (i, j))) B)) =\n    (if i < dim_row A \\<and> j < dim_col A\n     then if A $$ (i, j) = (0::'a)\n          then case concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<dim_row A]) of\n               [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n               | i' # x \\<Rightarrow>\n                   gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n          else if A $$ (i, j) = (1::'a)\n               then gauss_jordan_main\n                     (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                     (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                     (Suc i) (Suc j)\n               else gauss_jordan_main\n                     (eliminate_entries\n                       (\\<lambda>ia.\n                           multrow i (inverse (A $$ (i, j))) A $$ (ia, j))\n                       (multrow i (inverse (A $$ (i, j))) A) i j)\n                     (eliminate_entries\n                       (\\<lambda>ia.\n                           multrow i (inverse (A $$ (i, j))) A $$ (ia, j))\n                       (multrow i (inverse (A $$ (i, j))) B) i j)\n                     (Suc i) (Suc j)\n     else (A, B))", "using True"], ["proof (prove)\nusing this:\n  i < dim_row A \\<and>\n  j < dim_col A \\<and>\n  A $$ (i, j) \\<noteq> (0::'a) \\<and> A $$ (i, j) \\<noteq> (1::'a)\n\ngoal (1 subgoal):\n 1. (if i < dim_row (multrow i (inverse (A $$ (i, j))) A) \\<and>\n        j < dim_col (multrow i (inverse (A $$ (i, j))) A)\n     then if (1::'a) = (0::'a)\n          then case concat\n                     (map (\\<lambda>i'.\n                              if multrow i (inverse (A $$ (i, j))) A $$\n                                 (i', j) \\<noteq>\n                                 (0::'a)\n                              then [i'] else [])\n                       [Suc i..<\n                        dim_row (multrow i (inverse (A $$ (i, j))) A)]) of\n               [] \\<Rightarrow>\n                 gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                  (multrow i (inverse (A $$ (i, j))) B) i (Suc j)\n               | i' # x \\<Rightarrow>\n                   gauss_jordan_main\n                    (swaprows i i' (multrow i (inverse (A $$ (i, j))) A))\n                    (swaprows i i' (multrow i (inverse (A $$ (i, j))) B)) i\n                    j\n          else if (1::'a) = (1::'a)\n               then gauss_jordan_main\n                     (eliminate_entries\n                       (\\<lambda>ia.\n                           multrow i (inverse (A $$ (i, j))) A $$ (ia, j))\n                       (multrow i (inverse (A $$ (i, j))) A) i j)\n                     (eliminate_entries\n                       (\\<lambda>ia.\n                           multrow i (inverse (A $$ (i, j))) A $$ (ia, j))\n                       (multrow i (inverse (A $$ (i, j))) B) i j)\n                     (Suc i) (Suc j)\n               else gauss_jordan_main\n                     (multrow i (inverse (1::'a))\n                       (multrow i (inverse (A $$ (i, j))) A))\n                     (multrow i (inverse (1::'a))\n                       (multrow i (inverse (A $$ (i, j))) B))\n                     i j\n     else (multrow i (inverse (A $$ (i, j))) A,\n           multrow i (inverse (A $$ (i, j))) B)) =\n    (if i < dim_row A \\<and> j < dim_col A\n     then if A $$ (i, j) = (0::'a)\n          then case concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<dim_row A]) of\n               [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n               | i' # x \\<Rightarrow>\n                   gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n          else if A $$ (i, j) = (1::'a)\n               then gauss_jordan_main\n                     (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                     (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                     (Suc i) (Suc j)\n               else gauss_jordan_main\n                     (eliminate_entries\n                       (\\<lambda>ia.\n                           multrow i (inverse (A $$ (i, j))) A $$ (ia, j))\n                       (multrow i (inverse (A $$ (i, j))) A) i j)\n                     (eliminate_entries\n                       (\\<lambda>ia.\n                           multrow i (inverse (A $$ (i, j))) A $$ (ia, j))\n                       (multrow i (inverse (A $$ (i, j))) B) i j)\n                     (Suc i) (Suc j)\n     else (A, B))", "by simp"], ["proof (state)\nthis:\n  gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n   (multrow i (inverse (A $$ (i, j))) B) i j =\n  (let nr = dim_row A; nc = dim_col A\n   in if i < nr \\<and> j < nc\n      then let aij = A $$ (i, j)\n           in if aij = (0::'a)\n              then case concat\n                         (map (\\<lambda>i'.\n                                  if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                                  else [])\n                           [Suc i..<nr]) of\n                   [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                   | i' # x \\<Rightarrow>\n                       gauss_jordan_main (swaprows i i' A) (swaprows i i' B)\n                        i j\n              else if aij = (1::'a)\n                   then let v = \\<lambda>i. A $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A i j)\n                            (eliminate_entries v B i j) (Suc i) (Suc j)\n                   else let iaij = inverse aij; A' = multrow i iaij A;\n                            B' = multrow i iaij B;\n                            v = \\<lambda>i. A' $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A' i j)\n                            (eliminate_entries v B' i j) (Suc i) (Suc j)\n      else (A, B))\n\ngoal (1 subgoal):\n 1. i < dim_row A \\<and>\n    j < dim_col A \\<and>\n    A $$ (i, j) \\<noteq> (0::'a) \\<and>\n    A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "finally"], ["proof (chain)\npicking this:\n  gauss_jordan_main A B i j =\n  (let nr = dim_row A; nc = dim_col A\n   in if i < nr \\<and> j < nc\n      then let aij = A $$ (i, j)\n           in if aij = (0::'a)\n              then case concat\n                         (map (\\<lambda>i'.\n                                  if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                                  else [])\n                           [Suc i..<nr]) of\n                   [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                   | i' # x \\<Rightarrow>\n                       gauss_jordan_main (swaprows i i' A) (swaprows i i' B)\n                        i j\n              else if aij = (1::'a)\n                   then let v = \\<lambda>i. A $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A i j)\n                            (eliminate_entries v B i j) (Suc i) (Suc j)\n                   else let iaij = inverse aij; A' = multrow i iaij A;\n                            B' = multrow i iaij B;\n                            v = \\<lambda>i. A' $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A' i j)\n                            (eliminate_entries v B' i j) (Suc i) (Suc j)\n      else (A, B))", "show ?thesis"], ["proof (prove)\nusing this:\n  gauss_jordan_main A B i j =\n  (let nr = dim_row A; nc = dim_col A\n   in if i < nr \\<and> j < nc\n      then let aij = A $$ (i, j)\n           in if aij = (0::'a)\n              then case concat\n                         (map (\\<lambda>i'.\n                                  if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                                  else [])\n                           [Suc i..<nr]) of\n                   [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                   | i' # x \\<Rightarrow>\n                       gauss_jordan_main (swaprows i i' A) (swaprows i i' B)\n                        i j\n              else if aij = (1::'a)\n                   then let v = \\<lambda>i. A $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A i j)\n                            (eliminate_entries v B i j) (Suc i) (Suc j)\n                   else let iaij = inverse aij; A' = multrow i iaij A;\n                            B' = multrow i iaij B;\n                            v = \\<lambda>i. A' $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A' i j)\n                            (eliminate_entries v B' i j) (Suc i) (Suc j)\n      else (A, B))\n\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i j =\n    (let nr = dim_row A; nc = dim_col A\n     in if i < nr \\<and> j < nc\n        then let aij = A $$ (i, j)\n             in if aij = (0::'a)\n                then case concat\n                           (map (\\<lambda>i'.\n                                    if A $$ (i', j) \\<noteq> (0::'a)\n                                    then [i'] else [])\n                             [Suc i..<nr]) of\n                     [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                     | i' # x \\<Rightarrow>\n                         gauss_jordan_main (swaprows i i' A)\n                          (swaprows i i' B) i j\n                else if aij = (1::'a)\n                     then let v = \\<lambda>i. A $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A i j)\n                              (eliminate_entries v B i j) (Suc i) (Suc j)\n                     else let iaij = inverse aij; A' = multrow i iaij A;\n                              B' = multrow i iaij B;\n                              v = \\<lambda>i. A' $$ (i, j)\n                          in gauss_jordan_main (eliminate_entries v A' i j)\n                              (eliminate_entries v B' i j) (Suc i) (Suc j)\n        else (A, B))", "."], ["proof (state)\nthis:\n  gauss_jordan_main A B i j =\n  (let nr = dim_row A; nc = dim_col A\n   in if i < nr \\<and> j < nc\n      then let aij = A $$ (i, j)\n           in if aij = (0::'a)\n              then case concat\n                         (map (\\<lambda>i'.\n                                  if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                                  else [])\n                           [Suc i..<nr]) of\n                   [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                   | i' # x \\<Rightarrow>\n                       gauss_jordan_main (swaprows i i' A) (swaprows i i' B)\n                        i j\n              else if aij = (1::'a)\n                   then let v = \\<lambda>i. A $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A i j)\n                            (eliminate_entries v B i j) (Suc i) (Suc j)\n                   else let iaij = inverse aij; A' = multrow i iaij A;\n                            B' = multrow i iaij B;\n                            v = \\<lambda>i. A' $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A' i j)\n                            (eliminate_entries v B' i j) (Suc i) (Suc j)\n      else (A, B))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gauss_jordan_main A B i j =\n  (let nr = dim_row A; nc = dim_col A\n   in if i < nr \\<and> j < nc\n      then let aij = A $$ (i, j)\n           in if aij = (0::'a)\n              then case concat\n                         (map (\\<lambda>i'.\n                                  if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                                  else [])\n                           [Suc i..<nr]) of\n                   [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                   | i' # x \\<Rightarrow>\n                       gauss_jordan_main (swaprows i i' A) (swaprows i i' B)\n                        i j\n              else if aij = (1::'a)\n                   then let v = \\<lambda>i. A $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A i j)\n                            (eliminate_entries v B i j) (Suc i) (Suc j)\n                   else let iaij = inverse aij; A' = multrow i iaij A;\n                            B' = multrow i iaij B;\n                            v = \\<lambda>i. A' $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A' i j)\n                            (eliminate_entries v B' i j) (Suc i) (Suc j)\n      else (A, B))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}