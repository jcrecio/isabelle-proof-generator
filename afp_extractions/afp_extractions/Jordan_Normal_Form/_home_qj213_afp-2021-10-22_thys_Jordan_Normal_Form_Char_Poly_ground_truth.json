{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Char_Poly.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma eigenvector_pow: assumes A: \"A \\<in> carrier_mat n n\"\n  and ev: \"eigenvector A v (k :: 'a :: comm_ring_1)\"\n  shows \"A ^\\<^sub>m i *\\<^sub>v v = k^i \\<cdot>\\<^sub>v v\"", "lemma char_matrix_closed[simp]: \"A \\<in> carrier_mat n n \\<Longrightarrow> char_matrix A e \\<in> carrier_mat n n\"", "lemma eigenvector_char_matrix: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\" \n  shows \"eigenvector A v e = (v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\"", "lemma eigenvalue_char_matrix: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\" \n  shows \"eigenvalue A e = (\\<exists> v. v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\"", "lemma find_eigenvector: assumes A: \"A \\<in> carrier_mat n n\"\n  and ev: \"eigenvalue A e\"\n  shows \"eigenvector A (find_eigenvector A e) e\"", "lemma eigenvalue_imp_nonzero_dim: assumes \"A \\<in> carrier_mat n n\"\n  and \"eigenvalue A ev\"\n  shows \"n > 0\"", "lemma eigenvalue_det: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\" shows\n  \"eigenvalue A e = (det (char_matrix A e) = 0)\"", "lemma char_poly_matrix_closed[simp]: \"A \\<in> carrier_mat n n \\<Longrightarrow> char_poly_matrix A \\<in> carrier_mat n n\"", "lemmas char_poly_defs = char_poly_def char_poly_matrix_def", "lemma (in comm_ring_hom) char_poly_matrix_hom: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"char_poly_matrix (mat\\<^sub>h A) = map_mat (map_poly hom) (char_poly_matrix A)\"", "lemma (in comm_ring_hom) char_poly_hom: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"char_poly (map_mat hom A) = map_poly hom (char_poly A)\"", "lemma eigenvector_hom: assumes A: \"A \\<in> carrier_mat n n\"\n  and ev: \"eigenvector A v ev\"\n  shows \"eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)\"", "lemma eigenvalue_hom: assumes A: \"A \\<in> carrier_mat n n\"\n  and ev: \"eigenvalue A ev\"\n  shows \"eigenvalue (mat\\<^sub>h A) (hom ev)\"", "lemma eigenvector_hom_rev: assumes A: \"A \\<in> carrier_mat n n\"\n  and ev: \"eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)\"\n  shows \"eigenvector A v ev\"", "lemma poly_det_cong: assumes A: \"A \\<in> carrier_mat n n\"\n  and B: \"B \\<in> carrier_mat n n\"\n  and poly: \"\\<And> i j. i < n \\<Longrightarrow> j < n \\<Longrightarrow> poly (B $$ (i,j)) k = A $$ (i,j)\"\n  shows \"poly (det B) k = det A\"", "lemma char_poly_matrix: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\"\n  shows \"poly (char_poly A) k = det (- (char_matrix A k))\"", "lemma eigenvalue_root_char_poly: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\"\n  shows \"eigenvalue A k \\<longleftrightarrow> poly (char_poly A) k = 0\"", "lemma char_poly_matrix_upper_triangular: \"upper_triangular (char_poly_matrix A)\"", "lemma char_poly_upper_triangular: \n  \"char_poly A = (\\<Prod> a \\<leftarrow> diag_mat A. [:- a, 1:])\"", "lemma map_poly_mult: assumes A: \"A \\<in> carrier_mat nr n\"\n  and B: \"B \\<in> carrier_mat n nc\"\n  shows \n    \"map_mat (\\<lambda> a. [: a :]) (A * B) = map_mat (\\<lambda> a. [: a :]) A * map_mat (\\<lambda> a. [: a :]) B\" (is \"?id\")\n    \"map_mat (\\<lambda> a. [: a :] * p) (A * B) = map_mat (\\<lambda> a. [: a :] * p) A * map_mat (\\<lambda> a. [: a :]) B\" (is \"?left\")\n    \"map_mat (\\<lambda> a. [: a :] * p) (A * B) = map_mat (\\<lambda> a. [: a :]) A * map_mat (\\<lambda> a. [: a :] * p) B\" (is \"?right\")", "lemma char_poly_similar: assumes \"similar_mat A (B :: 'a :: comm_ring_1 mat)\"\n  shows \"char_poly A = char_poly B\"", "lemma degree_signof_mult[simp]: \"degree (signof p * q) = degree q\"", "lemma degree_monic_char_poly: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1\"", "lemma char_poly_factorized: fixes A :: \"complex mat\"\n  assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"\\<exists> as. char_poly A = (\\<Prod> a \\<leftarrow> as. [:- a, 1:]) \\<and> length as = n\"", "lemma char_poly_four_block_zeros_col: assumes A1: \"A1 \\<in> carrier_mat 1 1\"\n  and A2: \"A2 \\<in> carrier_mat 1 n\" and A3: \"A3 \\<in> carrier_mat n n\"\n  shows \"char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) = char_poly A1 * char_poly A3\" \n    (is \"char_poly ?A = ?cp1 * ?cp3\")", "lemma char_poly_transpose_mat[simp]: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"char_poly (transpose_mat A) = char_poly A\"", "lemma pderiv_char_poly: fixes A :: \"'a :: idom mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" \n  shows \"pderiv (char_poly A) = (\\<Sum>i < n. char_poly (mat_delete A i i))\"", "lemma char_poly_0_column: fixes A :: \"'a :: idom mat\" \n  assumes 0: \"\\<And> j. j < n \\<Longrightarrow> A $$ (j,i) = 0\" \n  and A: \"A \\<in> carrier_mat n n\" \n  and i: \"i < n\"\nshows \"char_poly A = monom 1 1 * char_poly (mat_delete A i i)\"", "lemma mat_erase_carrier[simp]: \"(mat_erase A i j) \\<in> carrier_mat nr nc \\<longleftrightarrow> A \\<in> carrier_mat nr nc\"", "lemma pderiv_char_poly_mat_erase: fixes A :: \"'a :: idom mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" \n  shows \"monom 1 1 * pderiv (char_poly A) = (\\<Sum>i < n. char_poly (mat_erase A i i))\""], "translations": [["", "lemma eigenvector_pow: assumes A: \"A \\<in> carrier_mat n n\"\n  and ev: \"eigenvector A v (k :: 'a :: comm_ring_1)\"\n  shows \"A ^\\<^sub>m i *\\<^sub>v v = k^i \\<cdot>\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v", "let ?G = \"monoid_vec TYPE ('a) n\""], ["proof (state)\ngoal (1 subgoal):\n 1. A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have dim: \"dim_row A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v", "from ev[unfolded eigenvector_def dim]"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n \\<and>\n  v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = k \\<cdot>\\<^sub>v v", "have v: \"v \\<in> carrier_vec n\" and Av: \"A *\\<^sub>v v = k \\<cdot>\\<^sub>v v\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n \\<and>\n  v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = k \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&& A *\\<^sub>v v = k \\<cdot>\\<^sub>v v", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  A *\\<^sub>v v = k \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v", "interpret v: comm_group ?G"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group (monoid_vec TYPE('a) n)", "by (rule comm_group_vec)"], ["proof (state)\ngoal (1 subgoal):\n 1. A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. A ^\\<^sub>m 0 *\\<^sub>v v = k ^ 0 \\<cdot>\\<^sub>v v\n 2. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. A ^\\<^sub>m 0 *\\<^sub>v v = k ^ 0 \\<cdot>\\<^sub>v v\n 2. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^\\<^sub>m 0 *\\<^sub>v v = k ^ 0 \\<cdot>\\<^sub>v v", "using v dim"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. A ^\\<^sub>m 0 *\\<^sub>v v = k ^ 0 \\<cdot>\\<^sub>v v", "by simp"], ["proof (state)\nthis:\n  A ^\\<^sub>m 0 *\\<^sub>v v = k ^ 0 \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "case (Suc i)"], ["proof (state)\nthis:\n  A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "define P where \"P = A ^\\<^sub>m i\""], ["proof (state)\nthis:\n  P = A ^\\<^sub>m i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "have P: \"P \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "unfolding P_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A ^\\<^sub>m i \\<in> carrier_mat n n", "by simp"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "have \"A ^\\<^sub>m Suc i = P * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^\\<^sub>m Suc i = P * A", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^\\<^sub>m Suc i = A ^\\<^sub>m i * A", "by simp"], ["proof (state)\nthis:\n  A ^\\<^sub>m Suc i = P * A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "also"], ["proof (state)\nthis:\n  A ^\\<^sub>m Suc i = P * A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "have \"\\<dots> *\\<^sub>v v = P *\\<^sub>v (A *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * A *\\<^sub>v v = P *\\<^sub>v (A *\\<^sub>v v)", "using P A v"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. P * A *\\<^sub>v v = P *\\<^sub>v (A *\\<^sub>v v)", "by simp"], ["proof (state)\nthis:\n  P * A *\\<^sub>v v = P *\\<^sub>v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "also"], ["proof (state)\nthis:\n  P * A *\\<^sub>v v = P *\\<^sub>v (A *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "have \"A *\\<^sub>v v = k \\<cdot>\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = k \\<cdot>\\<^sub>v v", "by (rule Av)"], ["proof (state)\nthis:\n  A *\\<^sub>v v = k \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "also"], ["proof (state)\nthis:\n  A *\\<^sub>v v = k \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "have \"P *\\<^sub>v (k \\<cdot>\\<^sub>v v) = k \\<cdot>\\<^sub>v (P *\\<^sub>v v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P *\\<^sub>v (k \\<cdot>\\<^sub>v v) = k \\<cdot>\\<^sub>v (P *\\<^sub>v v)", "by (rule eq_vecI, insert v P, auto)"], ["proof (state)\nthis:\n  P *\\<^sub>v (k \\<cdot>\\<^sub>v v) = k \\<cdot>\\<^sub>v (P *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "also"], ["proof (state)\nthis:\n  P *\\<^sub>v (k \\<cdot>\\<^sub>v v) = k \\<cdot>\\<^sub>v (P *\\<^sub>v v)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "have \"(P *\\<^sub>v v) = (k ^ i) \\<cdot>\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v", "by (rule Suc)"], ["proof (state)\nthis:\n  P *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "also"], ["proof (state)\nthis:\n  P *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "have \"k \\<cdot>\\<^sub>v ((k ^ i) \\<cdot>\\<^sub>v v) = (k * k ^ i) \\<cdot>\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<cdot>\\<^sub>v (k ^ i \\<cdot>\\<^sub>v v) =\n    k * k ^ i \\<cdot>\\<^sub>v v", "by (rule eq_vecI, insert v, auto)"], ["proof (state)\nthis:\n  k \\<cdot>\\<^sub>v (k ^ i \\<cdot>\\<^sub>v v) = k * k ^ i \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "also"], ["proof (state)\nthis:\n  k \\<cdot>\\<^sub>v (k ^ i \\<cdot>\\<^sub>v v) = k * k ^ i \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "have \"k * k ^ i = k ^ (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * k ^ i = k ^ Suc i", "by auto"], ["proof (state)\nthis:\n  k * k ^ i = k ^ Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v \\<Longrightarrow>\n       A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "finally"], ["proof (chain)\npicking this:\n  A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "show ?case"], ["proof (prove)\nusing this:\n  A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v", "."], ["proof (state)\nthis:\n  A ^\\<^sub>m Suc i *\\<^sub>v v = k ^ Suc i \\<cdot>\\<^sub>v v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A ^\\<^sub>m i *\\<^sub>v v = k ^ i \\<cdot>\\<^sub>v v\n\ngoal:\nNo subgoals!", "qed"], ["", "definition eigenvalue :: \"'a :: comm_ring_1 mat \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"eigenvalue A k = (\\<exists> v. eigenvector A v k)\""], ["", "definition char_matrix :: \"'a :: field mat \\<Rightarrow> 'a \\<Rightarrow> 'a mat\" where\n  \"char_matrix A e = A + ((-e) \\<cdot>\\<^sub>m (1\\<^sub>m (dim_row A)))\""], ["", "lemma char_matrix_closed[simp]: \"A \\<in> carrier_mat n n \\<Longrightarrow> char_matrix A e \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n \\<Longrightarrow>\n    char_matrix A e \\<in> carrier_mat n n", "unfolding char_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n \\<Longrightarrow>\n    A + - e \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) \\<in> carrier_mat n n", "by auto"], ["", "lemma eigenvector_char_matrix: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\" \n  shows \"eigenvector A v e = (v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have dim: \"dim_row A = n\" \"dim_col A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n &&& dim_col A = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "{"], ["proof (state)\nthis:\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "assume v: \"v \\<in> carrier_vec n\""], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "hence dimv: \"dim_vec v = n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. dim_vec v = n", "by auto"], ["proof (state)\nthis:\n  dim_vec v = n\n\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "have \"(A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) = (A *\\<^sub>v v + (-e) \\<cdot>\\<^sub>v v = 0\\<^sub>v n)\" (is \"?id1 = ?id2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n    (A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v \\<Longrightarrow>\n    A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n\n 2. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "assume ?id1"], ["proof (state)\nthis:\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n\ngoal (2 subgoals):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v \\<Longrightarrow>\n    A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n\n 2. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "from arg_cong[OF this, of \"\\<lambda> w. w + (-e) \\<cdot>\\<^sub>v v\"]"], ["proof (chain)\npicking this:\n  A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v =\n  e \\<cdot>\\<^sub>v v + - e \\<cdot>\\<^sub>v v", "show ?id2"], ["proof (prove)\nusing this:\n  A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v =\n  e \\<cdot>\\<^sub>v v + - e \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n", "using A v"], ["proof (prove)\nusing this:\n  A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v =\n  e \\<cdot>\\<^sub>v v + - e \\<cdot>\\<^sub>v v\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "assume ?id2"], ["proof (state)\nthis:\n  A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "have \"A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v + e \\<cdot>\\<^sub>v v = A *\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v + e \\<cdot>\\<^sub>v v =\n    A *\\<^sub>v v", "using A v"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v + e \\<cdot>\\<^sub>v v =\n    A *\\<^sub>v v", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v + e \\<cdot>\\<^sub>v v =\n  A *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n \\<Longrightarrow>\n    A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "from arg_cong[OF \\<open>?id2\\<close>, of \"\\<lambda> w. w + e \\<cdot>\\<^sub>v v\", unfolded this]"], ["proof (chain)\npicking this:\n  A *\\<^sub>v v = 0\\<^sub>v n + e \\<cdot>\\<^sub>v v", "show ?id1"], ["proof (prove)\nusing this:\n  A *\\<^sub>v v = 0\\<^sub>v n + e \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "using A v"], ["proof (prove)\nusing this:\n  A *\\<^sub>v v = 0\\<^sub>v n + e \\<cdot>\\<^sub>v v\n  A \\<in> carrier_mat n n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = e \\<cdot>\\<^sub>v v", "by simp"], ["proof (state)\nthis:\n  A *\\<^sub>v v = e \\<cdot>\\<^sub>v v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n  (A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "also"], ["proof (state)\nthis:\n  (A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n  (A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "have \"(A *\\<^sub>v v + (-e) \\<cdot>\\<^sub>v v) = char_matrix A e *\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = char_matrix A e *\\<^sub>v v", "unfolding char_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v =\n    (A + - e \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A)) *\\<^sub>v v", "by (rule eq_vecI, insert v A dim, auto simp: add_scalar_prod_distrib[of _ n])"], ["proof (state)\nthis:\n  A *\\<^sub>v v + - e \\<cdot>\\<^sub>v v = char_matrix A e *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "finally"], ["proof (chain)\npicking this:\n  (A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n  (char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "have \"(A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) = (char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\""], ["proof (prove)\nusing this:\n  (A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n  (char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n    (char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "."], ["proof (state)\nthis:\n  (A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n  (char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "}"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n \\<Longrightarrow>\n  (A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n  (char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n \\<Longrightarrow>\n  (A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n  (char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. eigenvector A v e =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "unfolding eigenvector_def dim"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n \\<Longrightarrow>\n  (A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n  (char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal (1 subgoal):\n 1. (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> A *\\<^sub>v v = e \\<cdot>\\<^sub>v v) =\n    (v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and>\n     char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "by blast"], ["proof (state)\nthis:\n  eigenvector A v e =\n  (v \\<in> carrier_vec n \\<and>\n   v \\<noteq> 0\\<^sub>v n \\<and> char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eigenvalue_char_matrix: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\" \n  shows \"eigenvalue A e = (\\<exists> v. v \\<in> carrier_vec n \\<and> v \\<noteq> 0\\<^sub>v n \\<and> char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvalue A e =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and>\n        char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "unfolding eigenvalue_def eigenvector_char_matrix[OF A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and>\n        char_matrix A e *\\<^sub>v v = 0\\<^sub>v n) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and>\n        char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", ".."], ["", "definition find_eigenvector :: \"'a::field mat \\<Rightarrow> 'a \\<Rightarrow> 'a vec\" where\n  \"find_eigenvector A e = \n    find_base_vector (fst (gauss_jordan (char_matrix A e) (0\\<^sub>m (dim_row A) 0)))\""], ["", "lemma find_eigenvector: assumes A: \"A \\<in> carrier_mat n n\"\n  and ev: \"eigenvalue A e\"\n  shows \"eigenvector A (find_eigenvector A e) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "define B where \"B = char_matrix A e\""], ["proof (state)\nthis:\n  B = char_matrix A e\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "from ev[unfolded eigenvalue_char_matrix[OF A]]"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> char_matrix A e *\\<^sub>v v = 0\\<^sub>v n", "obtain v where\n    v: \"v \\<in> carrier_vec n\" \"v \\<noteq> 0\\<^sub>v n\" and Bv: \"B *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> char_matrix A e *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> carrier_vec n; v \\<noteq> 0\\<^sub>v n;\n         B *\\<^sub>v v = 0\\<^sub>v n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding B_def"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<in> carrier_vec n \\<and>\n     v \\<noteq> 0\\<^sub>v n \\<and> char_matrix A e *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> carrier_vec n; v \\<noteq> 0\\<^sub>v n;\n         char_matrix A e *\\<^sub>v v = 0\\<^sub>v n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  B *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "have B: \"B \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B \\<in> carrier_mat n n", "unfolding B_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. char_matrix A e \\<in> carrier_mat n n", "by simp"], ["proof (state)\nthis:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "let ?z = \"0\\<^sub>m (dim_row A) 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "obtain C D where gauss: \"gauss_jordan B ?z = (C,D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C D.\n        gauss_jordan B (0\\<^sub>m (dim_row A) 0) = (C, D) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  gauss_jordan B (0\\<^sub>m (dim_row A) 0) = (C, D)\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "define w where \"w = find_base_vector C\""], ["proof (state)\nthis:\n  w = find_base_vector C\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "have res: \"find_eigenvector A e = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_eigenvector A e = w", "unfolding w_def find_eigenvector_def Let_def gauss B_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_base_vector (fst (C, D)) = find_base_vector C", "by simp"], ["proof (state)\nthis:\n  find_eigenvector A e = w\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "have \"?z \\<in> carrier_mat n 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m (dim_row A) 0 \\<in> carrier_mat n 0", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. 0\\<^sub>m (dim_row A) 0 \\<in> carrier_mat n 0", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>m (dim_row A) 0 \\<in> carrier_mat n 0\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "note gauss_0 = gauss_jordan[OF B this gauss]"], ["proof (state)\nthis:\n  ?x \\<in> carrier_vec n \\<Longrightarrow>\n  (B *\\<^sub>v ?x = 0\\<^sub>v n) = (C *\\<^sub>v ?x = 0\\<^sub>v n)\n  ?X \\<in> carrier_mat n 0 \\<Longrightarrow>\n  (B * ?X = 0\\<^sub>m (dim_row A) 0) = (C * ?X = D)\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n 0\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "hence C: \"C \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  ?x \\<in> carrier_vec n \\<Longrightarrow>\n  (B *\\<^sub>v ?x = 0\\<^sub>v n) = (C *\\<^sub>v ?x = 0\\<^sub>v n)\n  ?X \\<in> carrier_mat n 0 \\<Longrightarrow>\n  (B * ?X = 0\\<^sub>m (dim_row A) 0) = (C * ?X = D)\n  C \\<in> carrier_mat n n\n  D \\<in> carrier_mat n 0\n\ngoal (1 subgoal):\n 1. C \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  C \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "from gauss_0(1)[OF v(1)] Bv"], ["proof (chain)\npicking this:\n  (B *\\<^sub>v v = 0\\<^sub>v n) = (C *\\<^sub>v v = 0\\<^sub>v n)\n  B *\\<^sub>v v = 0\\<^sub>v n", "have Cv: \"C *\\<^sub>v v = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  (B *\\<^sub>v v = 0\\<^sub>v n) = (C *\\<^sub>v v = 0\\<^sub>v n)\n  B *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. C *\\<^sub>v v = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  C *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "{"], ["proof (state)\nthis:\n  C *\\<^sub>v v = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "assume C: \"C = 1\\<^sub>m n\""], ["proof (state)\nthis:\n  C = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "have False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using id Cv v"], ["proof (prove)\nusing this:\n  swapidseq 0 id\n  C *\\<^sub>v v = 0\\<^sub>v n\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. False", "unfolding C"], ["proof (prove)\nusing this:\n  swapidseq 0 id\n  1\\<^sub>m n *\\<^sub>v v = 0\\<^sub>v n\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "}"], ["proof (state)\nthis:\n  C = 1\\<^sub>m n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "hence C1: \"C \\<noteq> 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  C = 1\\<^sub>m n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. C \\<noteq> 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  C \\<noteq> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "from find_base_vector_not_1[OF gauss_jordan_row_echelon[OF B gauss] C C1]"], ["proof (chain)\npicking this:\n  find_base_vector C \\<in> carrier_vec n\n  find_base_vector C \\<noteq> 0\\<^sub>v n\n  C *\\<^sub>v find_base_vector C = 0\\<^sub>v n", "have w: \"w \\<in> carrier_vec n\" \"w \\<noteq> 0\\<^sub>v n\" and id: \"C *\\<^sub>v w = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  find_base_vector C \\<in> carrier_vec n\n  find_base_vector C \\<noteq> 0\\<^sub>v n\n  C *\\<^sub>v find_base_vector C = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (w \\<in> carrier_vec n &&& w \\<noteq> 0\\<^sub>v n) &&&\n    C *\\<^sub>v w = 0\\<^sub>v n", "unfolding w_def"], ["proof (prove)\nusing this:\n  find_base_vector C \\<in> carrier_vec n\n  find_base_vector C \\<noteq> 0\\<^sub>v n\n  C *\\<^sub>v find_base_vector C = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (find_base_vector C \\<in> carrier_vec n &&&\n     find_base_vector C \\<noteq> 0\\<^sub>v n) &&&\n    C *\\<^sub>v find_base_vector C = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  w \\<in> carrier_vec n\n  w \\<noteq> 0\\<^sub>v n\n  C *\\<^sub>v w = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "from gauss_0(1)[OF w(1)] id"], ["proof (chain)\npicking this:\n  (B *\\<^sub>v w = 0\\<^sub>v n) = (C *\\<^sub>v w = 0\\<^sub>v n)\n  C *\\<^sub>v w = 0\\<^sub>v n", "have Bw: \"B *\\<^sub>v w = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  (B *\\<^sub>v w = 0\\<^sub>v n) = (C *\\<^sub>v w = 0\\<^sub>v n)\n  C *\\<^sub>v w = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. B *\\<^sub>v w = 0\\<^sub>v n", "by simp"], ["proof (state)\nthis:\n  B *\\<^sub>v w = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "from w Bw"], ["proof (chain)\npicking this:\n  w \\<in> carrier_vec n\n  w \\<noteq> 0\\<^sub>v n\n  B *\\<^sub>v w = 0\\<^sub>v n", "have \"eigenvector A w e\""], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n\n  w \\<noteq> 0\\<^sub>v n\n  B *\\<^sub>v w = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. eigenvector A w e", "unfolding eigenvector_char_matrix[OF A] B_def"], ["proof (prove)\nusing this:\n  w \\<in> carrier_vec n\n  w \\<noteq> 0\\<^sub>v n\n  char_matrix A e *\\<^sub>v w = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. w \\<in> carrier_vec n \\<and>\n    w \\<noteq> 0\\<^sub>v n \\<and> char_matrix A e *\\<^sub>v w = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  eigenvector A w e\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "thus ?thesis"], ["proof (prove)\nusing this:\n  eigenvector A w e\n\ngoal (1 subgoal):\n 1. eigenvector A (find_eigenvector A e) e", "unfolding res"], ["proof (prove)\nusing this:\n  eigenvector A w e\n\ngoal (1 subgoal):\n 1. eigenvector A w e", "."], ["proof (state)\nthis:\n  eigenvector A (find_eigenvector A e) e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eigenvalue_imp_nonzero_dim: assumes \"A \\<in> carrier_mat n n\"\n  and \"eigenvalue A ev\"\n  shows \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> 0 < n\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> 0 < n", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> 0 < n\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> 0 < n", "from assms"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n\n  eigenvalue A ev", "obtain v where \"eigenvector A v ev\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  eigenvalue A ev\n\ngoal (1 subgoal):\n 1. (\\<And>v. eigenvector A v ev \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eigenvalue_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  \\<exists>v. eigenvector A v ev\n\ngoal (1 subgoal):\n 1. (\\<And>v. eigenvector A v ev \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eigenvector A v ev\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> 0 < n\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> 0 < n", "from this[unfolded eigenvector_def] assms 0"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\n  A \\<in> carrier_mat n n\n  eigenvalue A ev\n  n = 0", "have \"v \\<in> carrier_vec 0\" \"v \\<noteq> 0\\<^sub>v 0\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\n  A \\<in> carrier_mat n n\n  eigenvalue A ev\n  n = 0\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec 0 &&& v \\<noteq> 0\\<^sub>v 0", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec 0\n  v \\<noteq> 0\\<^sub>v 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> 0 < n\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> 0 < n", "hence False"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec 0\n  v \\<noteq> 0\\<^sub>v 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> 0 < n\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> 0 < n", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> 0 < n", "qed simp"], ["", "lemma eigenvalue_det: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\" shows\n  \"eigenvalue A e = (det (char_matrix A e) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvalue A e = (det (char_matrix A e) = (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvalue A e = (det (char_matrix A e) = (0::'a))", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have cA: \"char_matrix A e \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. char_matrix A e \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  char_matrix A e \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. eigenvalue A e = (det (char_matrix A e) = (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvalue A e = (det (char_matrix A e) = (0::'a))", "unfolding eigenvalue_char_matrix[OF A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and>\n        char_matrix A e *\\<^sub>v v = 0\\<^sub>v n) =\n    (det (char_matrix A e) = (0::'a))", "unfolding id det_0_negate[OF cA] det_0_iff_vec_prod_zero[OF cA]\n      eigenvalue_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and>\n        char_matrix A e *\\<^sub>v v = 0\\<^sub>v n) =\n    (\\<exists>v.\n        v \\<in> carrier_vec n \\<and>\n        v \\<noteq> 0\\<^sub>v n \\<and>\n        char_matrix A e *\\<^sub>v v = 0\\<^sub>v n)", "by auto"], ["proof (state)\nthis:\n  eigenvalue A e = (det (char_matrix A e) = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition char_poly_matrix :: \"'a :: comm_ring_1 mat \\<Rightarrow> 'a poly mat\" where\n  \"char_poly_matrix A = (([:0,1:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A)) + map_mat (\\<lambda> a. [: - a :]) A)\""], ["", "lemma char_poly_matrix_closed[simp]: \"A \\<in> carrier_mat n n \\<Longrightarrow> char_poly_matrix A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n \\<Longrightarrow>\n    char_poly_matrix A \\<in> carrier_mat n n", "unfolding char_poly_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n \\<Longrightarrow>\n    [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n    map_mat (\\<lambda>a. [:- a:]) A\n    \\<in> carrier_mat n n", "by auto"], ["", "definition char_poly :: \"'a :: comm_ring_1 mat \\<Rightarrow> 'a poly\" where\n  \"char_poly A = (det (char_poly_matrix A))\""], ["", "lemmas char_poly_defs = char_poly_def char_poly_matrix_def"], ["", "lemma (in comm_ring_hom) char_poly_matrix_hom: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"char_poly_matrix (mat\\<^sub>h A) = map_mat (map_poly hom) (char_poly_matrix A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly_matrix (mat\\<^sub>h A) =\n    map_mat (map_poly hom) (char_poly_matrix A)", "unfolding char_poly_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'b, 1::'b:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row (mat\\<^sub>h A)) +\n    map_mat (\\<lambda>a. [:- a:]) (mat\\<^sub>h A) =\n    map_mat (map_poly hom)\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n      map_mat (\\<lambda>a. [:- a:]) A)", "by (rule eq_matI, insert A, auto simp: smult_mat_def hom_distribs)"], ["", "lemma (in comm_ring_hom) char_poly_hom: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"char_poly (map_mat hom A) = map_poly hom (char_poly A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly (mat\\<^sub>h A) = map_poly hom (char_poly A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly (mat\\<^sub>h A) = map_poly hom (char_poly A)", "interpret map_poly_hom: map_poly_comm_ring_hom hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_ring_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly (mat\\<^sub>h A) = map_poly hom (char_poly A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly (mat\\<^sub>h A) = map_poly hom (char_poly A)", "unfolding char_poly_def map_poly_hom.hom_det[symmetric] char_poly_matrix_hom[OF A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (map_poly_hom.mat_hom (char_poly_matrix A)) =\n    det (map_poly_hom.mat_hom (char_poly_matrix A))", ".."], ["proof (state)\nthis:\n  char_poly (mat\\<^sub>h A) = map_poly hom (char_poly A)\n\ngoal:\nNo subgoals!", "qed"], ["", "context inj_comm_ring_hom\nbegin"], ["", "lemma eigenvector_hom: assumes A: \"A \\<in> carrier_mat n n\"\n  and ev: \"eigenvector A v ev\"\n  shows \"eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "let ?A = \"mat\\<^sub>h A\""], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "let ?v = \"vec\\<^sub>h v\""], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "let ?ev = \"hom ev\""], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "from ev[unfolded eigenvector_def] A"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\n  A \\<in> carrier_mat n n", "have v: \"v \\<in> carrier_vec n\" \"v \\<noteq> 0\\<^sub>v n\" \"A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (dim_row A) \\<and>\n  v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&&\n    v \\<noteq> 0\\<^sub>v n &&& A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "from v(1)"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n", "have v1: \"?v \\<in> carrier_vec n\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. vec\\<^sub>h v \\<in> carrier_vec n", "by simp"], ["proof (state)\nthis:\n  vec\\<^sub>h v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "from v(1-2)"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n", "obtain i where \"i < n\" and \"v $ i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; v $ i \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  i < n\n  v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "with v(1)"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  i < n\n  v $ i \\<noteq> (0::'a)", "have \"?v $ i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  i < n\n  v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. vec\\<^sub>h v $ i \\<noteq> (0::'b)", "by auto"], ["proof (state)\nthis:\n  vec\\<^sub>h v $ i \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "hence v2: \"?v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  vec\\<^sub>h v $ i \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. vec\\<^sub>h v \\<noteq> 0\\<^sub>v n", "using \\<open>i < n\\<close> v(1)"], ["proof (prove)\nusing this:\n  vec\\<^sub>h v $ i \\<noteq> (0::'b)\n  i < n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. vec\\<^sub>h v \\<noteq> 0\\<^sub>v n", "by force"], ["proof (state)\nthis:\n  vec\\<^sub>h v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "from arg_cong[OF v(3), of \"vec\\<^sub>h\", unfolded mult_mat_vec_hom[OF A v(1)] vec_hom_smult]"], ["proof (chain)\npicking this:\n  mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n  hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v", "have v3: \"?A *\\<^sub>v ?v = ?ev \\<cdot>\\<^sub>v ?v\""], ["proof (prove)\nusing this:\n  mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n  hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v\n\ngoal (1 subgoal):\n 1. mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n    hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v", "."], ["proof (state)\nthis:\n  mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n  hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v\n\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "from v1 v2 v3"], ["proof (chain)\npicking this:\n  vec\\<^sub>h v \\<in> carrier_vec n\n  vec\\<^sub>h v \\<noteq> 0\\<^sub>v n\n  mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n  hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v", "show ?thesis"], ["proof (prove)\nusing this:\n  vec\\<^sub>h v \\<in> carrier_vec n\n  vec\\<^sub>h v \\<noteq> 0\\<^sub>v n\n  mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n  hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v\n\ngoal (1 subgoal):\n 1. eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)", "unfolding eigenvector_def"], ["proof (prove)\nusing this:\n  vec\\<^sub>h v \\<in> carrier_vec n\n  vec\\<^sub>h v \\<noteq> 0\\<^sub>v n\n  mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n  hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v\n\ngoal (1 subgoal):\n 1. vec\\<^sub>h v \\<in> carrier_vec (dim_row (mat\\<^sub>h A)) \\<and>\n    vec\\<^sub>h v \\<noteq> 0\\<^sub>v (dim_row (mat\\<^sub>h A)) \\<and>\n    mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n    hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v", "using A"], ["proof (prove)\nusing this:\n  vec\\<^sub>h v \\<in> carrier_vec n\n  vec\\<^sub>h v \\<noteq> 0\\<^sub>v n\n  mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n  hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. vec\\<^sub>h v \\<in> carrier_vec (dim_row (mat\\<^sub>h A)) \\<and>\n    vec\\<^sub>h v \\<noteq> 0\\<^sub>v (dim_row (mat\\<^sub>h A)) \\<and>\n    mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n    hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v", "by auto"], ["proof (state)\nthis:\n  eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eigenvalue_hom: assumes A: \"A \\<in> carrier_mat n n\"\n  and ev: \"eigenvalue A ev\"\n  shows \"eigenvalue (mat\\<^sub>h A) (hom ev)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvalue (mat\\<^sub>h A) (hom ev)", "using eigenvector_hom[OF A, of _ ev] ev"], ["proof (prove)\nusing this:\n  eigenvector A ?v ev \\<Longrightarrow>\n  eigenvector (mat\\<^sub>h A) (vec\\<^sub>h ?v) (hom ev)\n  eigenvalue A ev\n\ngoal (1 subgoal):\n 1. eigenvalue (mat\\<^sub>h A) (hom ev)", "unfolding eigenvalue_def"], ["proof (prove)\nusing this:\n  eigenvector A ?v ev \\<Longrightarrow>\n  eigenvector (mat\\<^sub>h A) (vec\\<^sub>h ?v) (hom ev)\n  \\<exists>v. eigenvector A v ev\n\ngoal (1 subgoal):\n 1. \\<exists>v. eigenvector (mat\\<^sub>h A) v (hom ev)", "by auto"], ["", "lemma eigenvector_hom_rev: assumes A: \"A \\<in> carrier_mat n n\"\n  and ev: \"eigenvector (mat\\<^sub>h A) (vec\\<^sub>h v) (hom ev)\"\n  shows \"eigenvector A v ev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvector A v ev", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector A v ev", "let ?A = \"mat\\<^sub>h A\""], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector A v ev", "let ?v = \"vec\\<^sub>h v\""], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector A v ev", "let ?ev = \"hom ev\""], ["proof (state)\ngoal (1 subgoal):\n 1. eigenvector A v ev", "from ev[unfolded eigenvector_def] A"], ["proof (chain)\npicking this:\n  vec\\<^sub>h v \\<in> carrier_vec (dim_row (mat\\<^sub>h A)) \\<and>\n  vec\\<^sub>h v \\<noteq> 0\\<^sub>v (dim_row (mat\\<^sub>h A)) \\<and>\n  mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n  hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v\n  A \\<in> carrier_mat n n", "have v: \"v \\<in> carrier_vec n\" \"?v \\<noteq> 0\\<^sub>v n\" \"?A *\\<^sub>v ?v = ?ev \\<cdot>\\<^sub>v ?v\""], ["proof (prove)\nusing this:\n  vec\\<^sub>h v \\<in> carrier_vec (dim_row (mat\\<^sub>h A)) \\<and>\n  vec\\<^sub>h v \\<noteq> 0\\<^sub>v (dim_row (mat\\<^sub>h A)) \\<and>\n  mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n  hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec n &&&\n    vec\\<^sub>h v \\<noteq> 0\\<^sub>v n &&&\n    mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n    hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec n\n  vec\\<^sub>h v \\<noteq> 0\\<^sub>v n\n  mat\\<^sub>h A *\\<^sub>v vec\\<^sub>h v =\n  hom ev \\<cdot>\\<^sub>v vec\\<^sub>h v\n\ngoal (1 subgoal):\n 1. eigenvector A v ev", "from v(1-2)"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  vec\\<^sub>h v \\<noteq> 0\\<^sub>v n", "obtain i where \"i < n\" and \"v $ i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  vec\\<^sub>h v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; v $ i \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  i < n\n  v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. eigenvector A v ev", "with v(1)"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  i < n\n  v $ i \\<noteq> (0::'a)", "have \"v $ i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  i < n\n  v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. v $ i \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. eigenvector A v ev", "hence v2: \"v \\<noteq> 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n", "using \\<open>i < n\\<close> v(1)"], ["proof (prove)\nusing this:\n  v $ i \\<noteq> (0::'a)\n  i < n\n  v \\<in> carrier_vec n\n\ngoal (1 subgoal):\n 1. v \\<noteq> 0\\<^sub>v n", "by force"], ["proof (state)\nthis:\n  v \\<noteq> 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. eigenvector A v ev", "from vec_hom_inj[OF v(3)[folded mult_mat_vec_hom[OF A v(1)] vec_hom_smult]]"], ["proof (chain)\npicking this:\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v", "have v3: \"A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\""], ["proof (prove)\nusing this:\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v", "."], ["proof (state)\nthis:\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. eigenvector A v ev", "from v(1) v2 v3"], ["proof (chain)\npicking this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. eigenvector A v ev", "unfolding eigenvector_def"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec (dim_row A) \\<and>\n    v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v", "using A"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec n\n  v \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec (dim_row A) \\<and>\n    v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n    A *\\<^sub>v v = ev \\<cdot>\\<^sub>v v", "by auto"], ["proof (state)\nthis:\n  eigenvector A v ev\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma poly_det_cong: assumes A: \"A \\<in> carrier_mat n n\"\n  and B: \"B \\<in> carrier_mat n n\"\n  and poly: \"\\<And> i j. i < n \\<Longrightarrow> j < n \\<Longrightarrow> poly (B $$ (i,j)) k = A $$ (i,j)\"\n  shows \"poly (det B) k = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (det B) k = det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (det B) k = det A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (det B) k = det A", "unfolding det_def'[OF A] det_def'[OF B] poly_sum poly_mult poly_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ka\\<in>{p. p permutes {0..<n}}.\n       poly (signof ka) k *\n       (\\<Prod>kb = 0..<n. poly (B $$ (kb, ka kb)) k)) =\n    (\\<Sum>p | p permutes {0..<n}.\n       signof p * (\\<Prod>i = 0..<n. A $$ (i, p i)))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       poly (signof x) k * (\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k) =\n       signof x * (\\<Prod>i = 0..<n. A $$ (i, x i))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       poly (signof x) k * (\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k) =\n       signof x * (\\<Prod>i = 0..<n. A $$ (i, x i))", "assume x: \"x \\<in> {p. p permutes {0..<n}}\""], ["proof (state)\nthis:\n  x \\<in> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       poly (signof x) k * (\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k) =\n       signof x * (\\<Prod>i = 0..<n. A $$ (i, x i))", "let ?l = \"\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       poly (signof x) k * (\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k) =\n       signof x * (\\<Prod>i = 0..<n. A $$ (i, x i))", "let ?r = \"\\<Prod>i = 0..<n. A $$ (i, x i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       poly (signof x) k * (\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k) =\n       signof x * (\\<Prod>i = 0..<n. A $$ (i, x i))", "have id: \"?l = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k) =\n    (\\<Prod>i = 0..<n. A $$ (i, x i))", "by (rule prod.cong[OF refl poly], insert x, auto)"], ["proof (state)\nthis:\n  (\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k) =\n  (\\<Prod>i = 0..<n. A $$ (i, x i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n       poly (signof x) k * (\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k) =\n       signof x * (\\<Prod>i = 0..<n. A $$ (i, x i))", "show \"poly (signof x) k * ?l = signof x * ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (signof x) k * (\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k) =\n    signof x * (\\<Prod>i = 0..<n. A $$ (i, x i))", "unfolding id signof_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (if sign x = 1 then 1 else - 1) k *\n    (\\<Prod>i = 0..<n. A $$ (i, x i)) =\n    (if sign x = 1 then 1::'a else - (1::'a)) *\n    (\\<Prod>i = 0..<n. A $$ (i, x i))", "by auto"], ["proof (state)\nthis:\n  poly (signof x) k * (\\<Prod>ka = 0..<n. poly (B $$ (ka, x ka)) k) =\n  signof x * (\\<Prod>i = 0..<n. A $$ (i, x i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (det B) k = det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma char_poly_matrix: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\"\n  shows \"poly (char_poly A) k = det (- (char_matrix A k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (char_poly A) k = det (- char_matrix A k)", "unfolding char_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (det (char_poly_matrix A)) k = det (- char_matrix A k)", "by (rule poly_det_cong[of _ n], insert A, auto simp: char_poly_matrix_def char_matrix_def)"], ["", "lemma eigenvalue_root_char_poly: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat n n\"\n  shows \"eigenvalue A k \\<longleftrightarrow> poly (char_poly A) k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvalue A k = (poly (char_poly A) k = (0::'a))", "unfolding eigenvalue_det[OF A] char_poly_matrix[OF A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (det (char_matrix A k) = (0::'a)) = (det (- char_matrix A k) = (0::'a))", "by (subst det_0_negate[of _ n], insert A, auto)"], ["", "context\n  fixes A :: \"'a :: comm_ring_1 mat\" and n :: nat\n  assumes A: \"A \\<in> carrier_mat n n\"\n  and ut: \"upper_triangular A\"\nbegin"], ["", "lemma char_poly_matrix_upper_triangular: \"upper_triangular (char_poly_matrix A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular (char_poly_matrix A)", "using A ut"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  upper_triangular A\n\ngoal (1 subgoal):\n 1. upper_triangular (char_poly_matrix A)", "unfolding upper_triangular_def char_poly_matrix_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  \\<forall>i<dim_row A. \\<forall>j<i. A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i<dim_row\n                ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n                 map_mat (\\<lambda>a. [:- a:]) A).\n       \\<forall>j<i.\n          ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n           map_mat (\\<lambda>a. [:- a:]) A) $$\n          (i, j) =\n          0", "by auto"], ["", "lemma char_poly_upper_triangular: \n  \"char_poly A = (\\<Prod> a \\<leftarrow> diag_mat A. [:- a, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = (\\<Prod>a\\<leftarrow>diag_mat A. [:- a, 1::'a:])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = (\\<Prod>a\\<leftarrow>diag_mat A. [:- a, 1::'a:])", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have cA: \"char_poly_matrix A \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. char_poly_matrix A \\<in> carrier_mat n n", "by simp"], ["proof (state)\nthis:\n  char_poly_matrix A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. char_poly A = (\\<Prod>a\\<leftarrow>diag_mat A. [:- a, 1::'a:])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = (\\<Prod>a\\<leftarrow>diag_mat A. [:- a, 1::'a:])", "unfolding char_poly_def det_upper_triangular [OF char_poly_matrix_upper_triangular cA]"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (diag_mat (char_poly_matrix A)) =\n    (\\<Prod>a\\<leftarrow>diag_mat A. [:- a, 1::'a:])", "by (rule arg_cong[where f = prod_list], unfold list_eq_iff_nth_eq, insert cA A, auto simp: diag_mat_def\n      char_poly_matrix_def)"], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>a\\<leftarrow>diag_mat A. [:- a, 1::'a:])\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma map_poly_mult: assumes A: \"A \\<in> carrier_mat nr n\"\n  and B: \"B \\<in> carrier_mat n nc\"\n  shows \n    \"map_mat (\\<lambda> a. [: a :]) (A * B) = map_mat (\\<lambda> a. [: a :]) A * map_mat (\\<lambda> a. [: a :]) B\" (is \"?id\")\n    \"map_mat (\\<lambda> a. [: a :] * p) (A * B) = map_mat (\\<lambda> a. [: a :] * p) A * map_mat (\\<lambda> a. [: a :]) B\" (is \"?left\")\n    \"map_mat (\\<lambda> a. [: a :] * p) (A * B) = map_mat (\\<lambda> a. [: a :]) A * map_mat (\\<lambda> a. [: a :] * p) B\" (is \"?right\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B &&&\n    map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B &&&\n    map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "from A B"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr n\n  B \\<in> carrier_mat n nc", "have dim: \"dim_row A = nr\" \"dim_col A = n\" \"dim_row B = n\" \"dim_col B = nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr n\n  B \\<in> carrier_mat n nc\n\ngoal (1 subgoal):\n 1. (dim_row A = nr &&& dim_col A = n) &&& dim_row B = n &&& dim_col B = nc", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr\n  dim_col A = n\n  dim_row B = n\n  dim_col B = nc\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "{"], ["proof (state)\nthis:\n  dim_row A = nr\n  dim_col A = n\n  dim_row B = n\n  dim_col B = nc\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "have \"i < nr \\<Longrightarrow> j < nc \\<Longrightarrow> \n      row (map_mat (\\<lambda>a. [:a:]) A) i \\<bullet> col (map_mat (\\<lambda>a. [:a:]) B) j = [:(row A i \\<bullet> col B j):]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr; j < nc\\<rbrakk>\n    \\<Longrightarrow> row (map_mat (\\<lambda>a. [:a:]) A) i \\<bullet>\n                      col (map_mat (\\<lambda>a. [:a:]) B) j =\n                      [:row A i \\<bullet> col B j:]", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr; j < nc\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>ia = 0..<dim_vec\n (col (map_mat (\\<lambda>a. [:a:]) B) j).\n                          row (map_mat (\\<lambda>a. [:a:]) A) i $ ia *\n                          col (map_mat (\\<lambda>a. [:a:]) B) j $ ia) =\n                      [:\\<Sum>ia = 0..<dim_vec (col B j).\n                           row A i $ ia * col B j $ ia:]", "by (auto simp: dim ac_simps, induct n, auto)"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr; j < nc\\<rbrakk>\n  \\<Longrightarrow> row (map_mat (\\<lambda>a. [:a:]) A) i \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:]) B) j =\n                    [:row A i \\<bullet> col B j:]\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> row (map_mat (\\<lambda>a. [:a:]) A) ?i2 \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:]) B) ?j2 =\n                    [:row A ?i2 \\<bullet> col B ?j2:]\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "note id = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> row (map_mat (\\<lambda>a. [:a:]) A) ?i2 \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:]) B) ?j2 =\n                    [:row A ?i2 \\<bullet> col B ?j2:]\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> row (map_mat (\\<lambda>a. [:a:]) A) ?i2 \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:]) B) ?j2 =\n                    [:row A ?i2 \\<bullet> col B ?j2:]\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "have \"i < nr \\<Longrightarrow> j < nc \\<Longrightarrow> \n      [:(row A i \\<bullet> col B j):] * p = row (map_mat (\\<lambda> a. [: a :] * p) A) i \\<bullet> col (map_mat (\\<lambda>a. [:a:]) B) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr; j < nc\\<rbrakk>\n    \\<Longrightarrow> [:row A i \\<bullet> col B j:] * p =\n                      row (map_mat (\\<lambda>a. [:a:] * p) A) i \\<bullet>\n                      col (map_mat (\\<lambda>a. [:a:]) B) j", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr; j < nc\\<rbrakk>\n    \\<Longrightarrow> [:\\<Sum>ia = 0..<dim_vec (col B j).\n                           row A i $ ia * col B j $ ia:] *\n                      p =\n                      (\\<Sum>ia = 0..<dim_vec\n (col (map_mat (\\<lambda>a. [:a:]) B) j).\n                          row (map_mat (\\<lambda>a. [:a:] * p) A) i $ ia *\n                          col (map_mat (\\<lambda>a. [:a:]) B) j $ ia)", "by (auto simp: dim ac_simps smult_sum)"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr; j < nc\\<rbrakk>\n  \\<Longrightarrow> [:row A i \\<bullet> col B j:] * p =\n                    row (map_mat (\\<lambda>a. [:a:] * p) A) i \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:]) B) j\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> [:row A ?i2 \\<bullet> col B ?j2:] * p =\n                    row (map_mat (\\<lambda>a. [:a:] * p) A) ?i2 \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:]) B) ?j2\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "note left = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> [:row A ?i2 \\<bullet> col B ?j2:] * p =\n                    row (map_mat (\\<lambda>a. [:a:] * p) A) ?i2 \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:]) B) ?j2\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> [:row A ?i2 \\<bullet> col B ?j2:] * p =\n                    row (map_mat (\\<lambda>a. [:a:] * p) A) ?i2 \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:]) B) ?j2\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "have \"i < nr \\<Longrightarrow> j < nc \\<Longrightarrow> \n      [:(row A i \\<bullet> col B j):] * p = row (map_mat (\\<lambda> a. [: a :]) A) i \\<bullet> col (map_mat (\\<lambda>a. [:a:] * p) B) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr; j < nc\\<rbrakk>\n    \\<Longrightarrow> [:row A i \\<bullet> col B j:] * p =\n                      row (map_mat (\\<lambda>a. [:a:]) A) i \\<bullet>\n                      col (map_mat (\\<lambda>a. [:a:] * p) B) j", "unfolding scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr; j < nc\\<rbrakk>\n    \\<Longrightarrow> [:\\<Sum>ia = 0..<dim_vec (col B j).\n                           row A i $ ia * col B j $ ia:] *\n                      p =\n                      (\\<Sum>ia = 0..<dim_vec\n (col (map_mat (\\<lambda>a. [:a:] * p) B) j).\n                          row (map_mat (\\<lambda>a. [:a:]) A) i $ ia *\n                          col (map_mat (\\<lambda>a. [:a:] * p) B) j $ ia)", "by (auto simp: dim ac_simps smult_sum)"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr; j < nc\\<rbrakk>\n  \\<Longrightarrow> [:row A i \\<bullet> col B j:] * p =\n                    row (map_mat (\\<lambda>a. [:a:]) A) i \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:] * p) B) j\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> [:row A ?i2 \\<bullet> col B ?j2:] * p =\n                    row (map_mat (\\<lambda>a. [:a:]) A) ?i2 \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:] * p) B) ?j2\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "note right = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?j2 < nc\\<rbrakk>\n  \\<Longrightarrow> [:row A ?i2 \\<bullet> col B ?j2:] * p =\n                    row (map_mat (\\<lambda>a. [:a:]) A) ?i2 \\<bullet>\n                    col (map_mat (\\<lambda>a. [:a:] * p) B) ?j2\n\ngoal (3 subgoals):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 3. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "show ?id"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B", "by (rule eq_matI, insert id, auto simp: dim)"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) (A * B) =\n  map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:]) B\n\ngoal (2 subgoals):\n 1. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n 2. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "show ?left"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B", "by (rule eq_matI, insert left, auto simp: dim)"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n  map_mat (\\<lambda>a. [:a:] * p) A * map_mat (\\<lambda>a. [:a:]) B\n\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "show ?right"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n    map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B", "by (rule eq_matI, insert right, auto simp: dim)"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:] * p) (A * B) =\n  map_mat (\\<lambda>a. [:a:]) A * map_mat (\\<lambda>a. [:a:] * p) B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma char_poly_similar: assumes \"similar_mat A (B :: 'a :: comm_ring_1 mat)\"\n  shows \"char_poly A = char_poly B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "from similar_matD[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>n P Q.\n     {A, B, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and> Q * P = 1\\<^sub>m n \\<and> A = P * B * Q", "obtain n P Q where\n  carr: \"{A, B, P, Q} \\<subseteq> carrier_mat n n\" (is \"_ \\<subseteq> ?C\")\n  and PQ: \"P * Q = 1\\<^sub>m n\" \n  and AB: \"A = P * B * Q\""], ["proof (prove)\nusing this:\n  \\<exists>n P Q.\n     {A, B, P, Q} \\<subseteq> carrier_mat n n \\<and>\n     P * Q = 1\\<^sub>m n \\<and> Q * P = 1\\<^sub>m n \\<and> A = P * B * Q\n\ngoal (1 subgoal):\n 1. (\\<And>P Q n.\n        \\<lbrakk>{A, B, P, Q} \\<subseteq> carrier_mat n n;\n         P * Q = 1\\<^sub>m n; A = P * B * Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {A, B, P, Q} \\<subseteq> carrier_mat n n\n  P * Q = 1\\<^sub>m n\n  A = P * B * Q\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "hence A: \"A \\<in> ?C\" and B: \"B \\<in> ?C\" and P: \"P \\<in> ?C\" and Q: \"Q \\<in> ?C\""], ["proof (prove)\nusing this:\n  {A, B, P, Q} \\<subseteq> carrier_mat n n\n  P * Q = 1\\<^sub>m n\n  A = P * B * Q\n\ngoal (1 subgoal):\n 1. (A \\<in> carrier_mat n n &&& B \\<in> carrier_mat n n) &&&\n    P \\<in> carrier_mat n n &&& Q \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "let ?m = \"\\<lambda> a. [: -a :]\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "let ?P = \"map_mat (\\<lambda> a. [: a :]) P\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "let ?Q = \"map_mat (\\<lambda> a. [: a :]) Q\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "let ?B = \"map_mat ?m B\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "let ?I = \"map_mat (\\<lambda> a. [: a :]) (1\\<^sub>m n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "let ?XI = \"[:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m n\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "from A B"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n", "have dim: \"dim_row A = n\" \"dim_row B = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n &&& dim_row B = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n  dim_row B = n\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have cong: \"\\<And> x y z. x = y \\<Longrightarrow> x * z = y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z. x = y \\<Longrightarrow> x * z = y * z", "by auto"], ["proof (state)\nthis:\n  ?x3 = ?y3 \\<Longrightarrow> ?x3 * ?z3 = ?y3 * ?z3\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have id: \"?m = (\\<lambda> a :: 'a. [: a :] * [: -1 :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. [:- a:]) = (\\<lambda>a. [:a:] * [:- (1::'a):])", "by (intro ext, auto)"], ["proof (state)\nthis:\n  (\\<lambda>a. [:- a:]) = (\\<lambda>a. [:a:] * [:- (1::'a):])\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"char_poly A = det (?XI + map_mat (\\<lambda>a. [:- a:]) (P * B * Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) (P * B * Q))", "unfolding \n    char_poly_defs dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) A) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) (P * B * Q))", "by (simp add: AB)"], ["proof (state)\nthis:\n  char_poly A =\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) (P * B * Q))\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  char_poly A =\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) (P * B * Q))\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"?XI = ?P * ?XI * ?Q\" (is \"_ = ?left\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "have \"?P * ?XI = [:0, 1:] \\<cdot>\\<^sub>m (?P * 1\\<^sub>m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) =\n    [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n    (map_mat (\\<lambda>a. [:a:]) P * 1\\<^sub>m n)", "by (rule mult_smult_distrib[of _ n n _ n], insert P, auto)"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) =\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n  (map_mat (\\<lambda>a. [:a:]) P * 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "also"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) =\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n  (map_mat (\\<lambda>a. [:a:]) P * 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "have \"?P * 1\\<^sub>m n = ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) P * 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P", "using P"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) P * 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P", "by simp"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P * 1\\<^sub>m n =\n  map_mat (\\<lambda>a. [:a:]) P\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "also"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P * 1\\<^sub>m n =\n  map_mat (\\<lambda>a. [:a:]) P\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "have \"([: 0, 1:] \\<cdot>\\<^sub>m ?P) * ?Q = [: 0, 1:] \\<cdot>\\<^sub>m (?P * ?Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m map_mat (\\<lambda>a. [:a:]) P *\n    map_mat (\\<lambda>a. [:a:]) Q =\n    [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n    (map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q)", "by (rule mult_smult_assoc_mat, insert P Q, auto)"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m map_mat (\\<lambda>a. [:a:]) P *\n  map_mat (\\<lambda>a. [:a:]) Q =\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n  (map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q)\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "also"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m map_mat (\\<lambda>a. [:a:]) P *\n  map_mat (\\<lambda>a. [:a:]) Q =\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n  (map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q)\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "have \"?P * ?Q = ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q =\n    map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)", "unfolding PQ[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q =\n    map_mat (\\<lambda>a. [:a:]) (P * Q)", "by (rule map_poly_mult[symmetric, OF P Q])"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q =\n  map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "also"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q =\n  map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "have \"[: 0, 1:] \\<cdot>\\<^sub>m ?I = ?XI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'b, 1::'b:] \\<cdot>\\<^sub>m\n    map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n) =\n    [:0::'b, 1::'b:] \\<cdot>\\<^sub>m 1\\<^sub>m n", "by rule auto"], ["proof (state)\nthis:\n  [:0::?'b5, 1::?'b5:] \\<cdot>\\<^sub>m\n  map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n) =\n  [:0::?'b5, 1::?'b5:] \\<cdot>\\<^sub>m 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", "finally"], ["proof (chain)\npicking this:\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n  map_mat (\\<lambda>a. [:a:]) Q =\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n", "show ?thesis"], ["proof (prove)\nusing this:\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n  map_mat (\\<lambda>a. [:a:]) Q =\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q", ".."], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n  map_mat (\\<lambda>a. [:a:]) Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n  map_mat (\\<lambda>a. [:a:]) Q\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n =\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n  map_mat (\\<lambda>a. [:a:]) Q\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"map_mat ?m (P * B * Q) = ?P * ?B * ?Q\" (is \"_ = ?right\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:- a:]) (P * B * Q) =\n    map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B *\n    map_mat (\\<lambda>a. [:a:]) Q", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:] * [:- (1::'a):]) (P * B * Q) =\n    map_mat (\\<lambda>a. [:a:]) P *\n    map_mat (\\<lambda>a. [:a:] * [:- (1::'a):]) B *\n    map_mat (\\<lambda>a. [:a:]) Q", "by (subst map_poly_mult[OF mult_carrier_mat[OF P B] Q],\n      subst map_poly_mult(3)[OF P B], simp)"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:- a:]) (P * B * Q) =\n  map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B *\n  map_mat (\\<lambda>a. [:a:]) Q\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:- a:]) (P * B * Q) =\n  map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B *\n  map_mat (\\<lambda>a. [:a:]) Q\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"?left + ?right = (?P * ?XI + ?P * ?B) * ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n    map_mat (\\<lambda>a. [:a:]) Q +\n    map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B *\n    map_mat (\\<lambda>a. [:a:]) Q =\n    (map_mat (\\<lambda>a. [:a:]) P *\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) +\n     map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B) *\n    map_mat (\\<lambda>a. [:a:]) Q", "by (rule add_mult_distrib_mat[symmetric, of _ n n], insert B P Q, auto)"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n  map_mat (\\<lambda>a. [:a:]) Q +\n  map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B *\n  map_mat (\\<lambda>a. [:a:]) Q =\n  (map_mat (\\<lambda>a. [:a:]) P *\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) +\n   map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B) *\n  map_mat (\\<lambda>a. [:a:]) Q\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) *\n  map_mat (\\<lambda>a. [:a:]) Q +\n  map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B *\n  map_mat (\\<lambda>a. [:a:]) Q =\n  (map_mat (\\<lambda>a. [:a:]) P *\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) +\n   map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B) *\n  map_mat (\\<lambda>a. [:a:]) Q\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"?P * ?XI + ?P * ?B = ?P * (?XI + ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) +\n    map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B =\n    map_mat (\\<lambda>a. [:a:]) P *\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n     map_mat (\\<lambda>a. [:- a:]) B)", "by (rule mult_add_distrib_mat[symmetric, of _ n n], insert B P Q, auto)"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) +\n  map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B =\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n   map_mat (\\<lambda>a. [:- a:]) B)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n) +\n  map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:- a:]) B =\n  map_mat (\\<lambda>a. [:a:]) P *\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n   map_mat (\\<lambda>a. [:- a:]) B)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"det (?P * (?XI + ?B) * ?Q) = det ?P * det (?XI + ?B) * det ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (map_mat (\\<lambda>a. [:a:]) P *\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) B) *\n         map_mat (\\<lambda>a. [:a:]) Q) =\n    det (map_mat (\\<lambda>a. [:a:]) P) *\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) B) *\n    det (map_mat (\\<lambda>a. [:a:]) Q)", "by (rule trans[OF det_mult[of _ n] cong[OF det_mult]], insert P Q B, auto)"], ["proof (state)\nthis:\n  det (map_mat (\\<lambda>a. [:a:]) P *\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) B) *\n       map_mat (\\<lambda>a. [:a:]) Q) =\n  det (map_mat (\\<lambda>a. [:a:]) P) *\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) B) *\n  det (map_mat (\\<lambda>a. [:a:]) Q)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  det (map_mat (\\<lambda>a. [:a:]) P *\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) B) *\n       map_mat (\\<lambda>a. [:a:]) Q) =\n  det (map_mat (\\<lambda>a. [:a:]) P) *\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) B) *\n  det (map_mat (\\<lambda>a. [:a:]) Q)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"\\<dots> = (det ?P * det ?Q) * det (?XI + ?B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (map_mat (\\<lambda>a. [:a:]) P) *\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) B) *\n    det (map_mat (\\<lambda>a. [:a:]) Q) =\n    det (map_mat (\\<lambda>a. [:a:]) P) *\n    det (map_mat (\\<lambda>a. [:a:]) Q) *\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) B)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  det (map_mat (\\<lambda>a. [:a:]) P) *\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) B) *\n  det (map_mat (\\<lambda>a. [:a:]) Q) =\n  det (map_mat (\\<lambda>a. [:a:]) P) *\n  det (map_mat (\\<lambda>a. [:a:]) Q) *\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) B)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  det (map_mat (\\<lambda>a. [:a:]) P) *\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) B) *\n  det (map_mat (\\<lambda>a. [:a:]) Q) =\n  det (map_mat (\\<lambda>a. [:a:]) P) *\n  det (map_mat (\\<lambda>a. [:a:]) Q) *\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) B)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"det (?XI + ?B) = char_poly B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) B) =\n    char_poly B", "unfolding char_poly_defs dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) B) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) B)", "by simp"], ["proof (state)\nthis:\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) B) =\n  char_poly B\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) B) =\n  char_poly B\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"det ?P * det ?Q = det (?P * ?Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (map_mat (\\<lambda>a. [:a:]) P) *\n    det (map_mat (\\<lambda>a. [:a:]) Q) =\n    det (map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q)", "by (rule det_mult[symmetric], insert P Q, auto)"], ["proof (state)\nthis:\n  det (map_mat (\\<lambda>a. [:a:]) P) *\n  det (map_mat (\\<lambda>a. [:a:]) Q) =\n  det (map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  det (map_mat (\\<lambda>a. [:a:]) P) *\n  det (map_mat (\\<lambda>a. [:a:]) Q) =\n  det (map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"?P * ?Q = ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q =\n    map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)", "unfolding PQ[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q =\n    map_mat (\\<lambda>a. [:a:]) (P * Q)", "by (rule map_poly_mult[symmetric, OF P Q])"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q =\n  map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  map_mat (\\<lambda>a. [:a:]) P * map_mat (\\<lambda>a. [:a:]) Q =\n  map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"det \\<dots> = prod_list (diag_mat ?I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)) =\n    prod_list (diag_mat (map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)))", "by (rule det_upper_triangular[of _ n], auto)"], ["proof (state)\nthis:\n  det (map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)) =\n  prod_list (diag_mat (map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)))\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "also"], ["proof (state)\nthis:\n  det (map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)) =\n  prod_list (diag_mat (map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)))\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (diag_mat (map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n))) = 1", "unfolding prod_list_diag_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<dim_row (map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n)).\n        map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n) $$ (i, i)) =\n    1", "by (rule prod.neutral) simp"], ["proof (state)\nthis:\n  prod_list (diag_mat (map_mat (\\<lambda>a. [:a:]) (1\\<^sub>m n))) = 1\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "finally"], ["proof (chain)\npicking this:\n  char_poly A = 1 * char_poly B", "show ?thesis"], ["proof (prove)\nusing this:\n  char_poly A = 1 * char_poly B\n\ngoal (1 subgoal):\n 1. char_poly A = char_poly B", "by simp"], ["proof (state)\nthis:\n  char_poly A = char_poly B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_signof_mult[simp]: \"degree (signof p * q) = degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (signof p * q) = degree q", "by (cases \"sign p = 1\", auto simp: signof_def)"], ["", "lemma degree_monic_char_poly: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (char_poly A) = n \\<and> coeff (char_poly A) n = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (char_poly A) = n \\<and> coeff (char_poly A) n = (1::'a)", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have A': \"[:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) + map_mat (\\<lambda>a. [:- a:]) A \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n    map_mat (\\<lambda>a. [:- a:]) A\n    \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n  map_mat (\\<lambda>a. [:- a:]) A\n  \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. degree (char_poly A) = n \\<and> coeff (char_poly A) n = (1::'a)", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have dA: \"dim_row A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n", "by simp"], ["proof (state)\nthis:\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. degree (char_poly A) = n \\<and> coeff (char_poly A) n = (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (char_poly A) = n \\<and> coeff (char_poly A) n = (1::'a)", "unfolding char_poly_defs det_def'[OF A']"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Sum>p | p permutes {0..<n}.\n        signof p *\n        (\\<Prod>i = 0..<n.\n            ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n             map_mat (\\<lambda>a. [:- a:]) A) $$\n            (i, p i))) =\n    n \\<and>\n    coeff\n     (\\<Sum>p | p permutes {0..<n}.\n        signof p *\n        (\\<Prod>i = 0..<n.\n            ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n             map_mat (\\<lambda>a. [:- a:]) A) $$\n            (i, p i)))\n     n =\n    (1::'a)", "proof (rule degree_lcoeff_sum[of _ id], auto simp: finite_permutations permutes_id dA)"], ["proof (state)\ngoal (3 subgoals):\n 1. degree\n     (\\<Prod>i = 0..<n.\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A) $$\n         (i, i)) =\n    n\n 2. \\<And>p.\n       \\<lbrakk>p permutes {0..<n}; p \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i = 0..<n.\n                              ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n                               1\\<^sub>m n +\n                               map_mat (\\<lambda>a. [:- a:]) A) $$\n                              (i, p i))\n                         < n\n 3. coeff\n     (\\<Prod>i = 0..<n.\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A) $$\n         (i, i))\n     n =\n    (1::'a)", "have both: \"degree (\\<Prod>i = 0..<n. ([:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m n + map_mat (\\<lambda>a. [:- a:]) A) $$ (i, i)) = n \\<and>\n      coeff (\\<Prod>i = 0..<n. ([:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m n + map_mat (\\<lambda>a. [:- a:]) A) $$ (i, i)) n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i = 0..<n.\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A) $$\n         (i, i)) =\n    n \\<and>\n    coeff\n     (\\<Prod>i = 0..<n.\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A) $$\n         (i, i))\n     n =\n    (1::'a)", "by (rule degree_prod_monic, insert A, auto)"], ["proof (state)\nthis:\n  degree\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i)) =\n  n \\<and>\n  coeff\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i))\n   n =\n  (1::'a)\n\ngoal (3 subgoals):\n 1. degree\n     (\\<Prod>i = 0..<n.\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A) $$\n         (i, i)) =\n    n\n 2. \\<And>p.\n       \\<lbrakk>p permutes {0..<n}; p \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i = 0..<n.\n                              ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n                               1\\<^sub>m n +\n                               map_mat (\\<lambda>a. [:- a:]) A) $$\n                              (i, p i))\n                         < n\n 3. coeff\n     (\\<Prod>i = 0..<n.\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A) $$\n         (i, i))\n     n =\n    (1::'a)", "from both"], ["proof (chain)\npicking this:\n  degree\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i)) =\n  n \\<and>\n  coeff\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i))\n   n =\n  (1::'a)", "show \"degree (\\<Prod>i = 0..<n. ([:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m n + map_mat (\\<lambda>a. [:- a:]) A) $$ (i, i)) = n\""], ["proof (prove)\nusing this:\n  degree\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i)) =\n  n \\<and>\n  coeff\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i))\n   n =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i = 0..<n.\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A) $$\n         (i, i)) =\n    n", ".."], ["proof (state)\nthis:\n  degree\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i)) =\n  n\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>p permutes {0..<n}; p \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i = 0..<n.\n                              ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n                               1\\<^sub>m n +\n                               map_mat (\\<lambda>a. [:- a:]) A) $$\n                              (i, p i))\n                         < n\n 2. coeff\n     (\\<Prod>i = 0..<n.\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A) $$\n         (i, i))\n     n =\n    (1::'a)", "from both"], ["proof (chain)\npicking this:\n  degree\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i)) =\n  n \\<and>\n  coeff\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i))\n   n =\n  (1::'a)", "show \"coeff (\\<Prod>i = 0..<n. ([:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m n + map_mat (\\<lambda>a. [:- a:]) A) $$ (i, i)) n = 1\""], ["proof (prove)\nusing this:\n  degree\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i)) =\n  n \\<and>\n  coeff\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i))\n   n =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. coeff\n     (\\<Prod>i = 0..<n.\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A) $$\n         (i, i))\n     n =\n    (1::'a)", ".."], ["proof (state)\nthis:\n  coeff\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, i))\n   n =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p permutes {0..<n}; p \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i = 0..<n.\n                              ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n                               1\\<^sub>m n +\n                               map_mat (\\<lambda>a. [:- a:]) A) $$\n                              (i, p i))\n                         < n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p permutes {0..<n}; p \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i = 0..<n.\n                              ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n                               1\\<^sub>m n +\n                               map_mat (\\<lambda>a. [:- a:]) A) $$\n                              (i, p i))\n                         < n", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p permutes {0..<n}; p \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i = 0..<n.\n                              ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n                               1\\<^sub>m n +\n                               map_mat (\\<lambda>a. [:- a:]) A) $$\n                              (i, p i))\n                         < n", "assume p: \"p permutes {0..<n}\"\n      and \"p \\<noteq> id\""], ["proof (state)\nthis:\n  p permutes {0..<n}\n  p \\<noteq> id\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p permutes {0..<n}; p \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i = 0..<n.\n                              ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n                               1\\<^sub>m n +\n                               map_mat (\\<lambda>a. [:- a:]) A) $$\n                              (i, p i))\n                         < n", "then"], ["proof (chain)\npicking this:\n  p permutes {0..<n}\n  p \\<noteq> id", "obtain i where i: \"i < n\" and pi: \"p i \\<noteq> i\""], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  p \\<noteq> id\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; p i \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis atLeastLessThan_iff order_refl permutes_natset_le)"], ["proof (state)\nthis:\n  i < n\n  p i \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>p permutes {0..<n}; p \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i = 0..<n.\n                              ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n                               1\\<^sub>m n +\n                               map_mat (\\<lambda>a. [:- a:]) A) $$\n                              (i, p i))\n                         < n", "show \"degree (\\<Prod>i = 0..<n. ([:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m n + map_mat (\\<lambda>a. [:- a:]) A) $$ (i, p i)) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i = 0..<n.\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A) $$\n         (i, p i))\n    < n", "by (rule degree_prod_sum_lt_n[OF _ i], insert p i pi A, auto)"], ["proof (state)\nthis:\n  degree\n   (\\<Prod>i = 0..<n.\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A) $$\n       (i, p i))\n  < n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma char_poly_factorized: fixes A :: \"complex mat\"\n  assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"\\<exists> as. char_poly A = (\\<Prod> a \\<leftarrow> as. [:- a, 1:]) \\<and> length as = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "let ?p = \"char_poly A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "from fundamental_theorem_algebra_factorized[of ?p]"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     Polynomial.smult (lead_coeff (char_poly A))\n      (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n     char_poly A \\<and>\n     length as = degree (char_poly A)", "obtain as\n  where \"Polynomial.smult (coeff ?p (degree ?p)) (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = ?p\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     Polynomial.smult (lead_coeff (char_poly A))\n      (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n     char_poly A \\<and>\n     length as = degree (char_poly A)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        Polynomial.smult (lead_coeff (char_poly A))\n         (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n        char_poly A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff (char_poly A))\n   (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n  char_poly A\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "also"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff (char_poly A))\n   (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n  char_poly A\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "have \"coeff ?p (degree ?p) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (char_poly A)", "using degree_monic_char_poly[OF A]"], ["proof (prove)\nusing this:\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1\n\ngoal (1 subgoal):\n 1. monic (char_poly A)", "by simp"], ["proof (state)\nthis:\n  monic (char_poly A)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "finally"], ["proof (chain)\npicking this:\n  Polynomial.smult 1 (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = char_poly A", "have cA: \"?p = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\""], ["proof (prove)\nusing this:\n  Polynomial.smult 1 (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = char_poly A\n\ngoal (1 subgoal):\n 1. char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])", "by simp"], ["proof (state)\nthis:\n  char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "from degree_monic_char_poly[OF A]"], ["proof (chain)\npicking this:\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1", "have \"degree ?p = n\""], ["proof (prove)\nusing this:\n  degree (char_poly A) = n \\<and> coeff (char_poly A) n = 1\n\ngoal (1 subgoal):\n 1. degree (char_poly A) = n", ".."], ["proof (state)\nthis:\n  degree (char_poly A) = n\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "with degree_linear_factors[of uminus as, folded cA]"], ["proof (chain)\npicking this:\n  degree (char_poly A) = length as\n  degree (char_poly A) = n", "have \"length as = n\""], ["proof (prove)\nusing this:\n  degree (char_poly A) = length as\n  degree (char_poly A) = n\n\ngoal (1 subgoal):\n 1. length as = n", "by auto"], ["proof (state)\nthis:\n  length as = n\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "with cA"], ["proof (chain)\npicking this:\n  char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\n  length as = n", "show ?thesis"], ["proof (prove)\nusing this:\n  char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\n  length as = n\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and>\n       length as = n", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     char_poly A = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<and> length as = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma char_poly_four_block_zeros_col: assumes A1: \"A1 \\<in> carrier_mat 1 1\"\n  and A2: \"A2 \\<in> carrier_mat 1 n\" and A3: \"A3 \\<in> carrier_mat n n\"\n  shows \"char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) = char_poly A1 * char_poly A3\" \n    (is \"char_poly ?A = ?cp1 * ?cp3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "let ?cm = \"\\<lambda> A. [:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n         map_mat (\\<lambda>a. [:- a:]) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "let ?B2 = \"map_mat (\\<lambda>a. [:- a:]) A2\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "have \"char_poly ?A = det (?cm ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (dim_row (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (four_block_mat A1 A2 (0\\<^sub>m n 1) A3))", "unfolding char_poly_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (dim_row (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (dim_row (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (four_block_mat A1 A2 (0\\<^sub>m n 1) A3))", "using A1 A3"], ["proof (prove)\nusing this:\n  A1 \\<in> carrier_mat 1 1\n  A3 \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (dim_row (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (dim_row (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) +\n         map_mat (\\<lambda>a. [:- a:])\n          (four_block_mat A1 A2 (0\\<^sub>m n 1) A3))", "by simp"], ["proof (state)\nthis:\n  char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n       1\\<^sub>m (dim_row (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) +\n       map_mat (\\<lambda>a. [:- a:])\n        (four_block_mat A1 A2 (0\\<^sub>m n 1) A3))\n\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "also"], ["proof (state)\nthis:\n  char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n       1\\<^sub>m (dim_row (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) +\n       map_mat (\\<lambda>a. [:- a:])\n        (four_block_mat A1 A2 (0\\<^sub>m n 1) A3))\n\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "have \"?cm ?A = four_block_mat (?cm A1) ?B2 (0\\<^sub>m n 1) (?cm A3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n    1\\<^sub>m (dim_row (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) +\n    map_mat (\\<lambda>a. [:- a:])\n     (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    four_block_mat\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n      map_mat (\\<lambda>a. [:- a:]) A1)\n     (map_mat (\\<lambda>a. [:- a:]) A2) (0\\<^sub>m n 1)\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n      map_mat (\\<lambda>a. [:- a:]) A3)", "by (rule eq_matI, insert A1 A2 A3, auto simp: one_poly_def)"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n  1\\<^sub>m (dim_row (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) +\n  map_mat (\\<lambda>a. [:- a:]) (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n  four_block_mat\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n    map_mat (\\<lambda>a. [:- a:]) A1)\n   (map_mat (\\<lambda>a. [:- a:]) A2) (0\\<^sub>m n 1)\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n    map_mat (\\<lambda>a. [:- a:]) A3)\n\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "also"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n  1\\<^sub>m (dim_row (four_block_mat A1 A2 (0\\<^sub>m n 1) A3)) +\n  map_mat (\\<lambda>a. [:- a:]) (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n  four_block_mat\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n    map_mat (\\<lambda>a. [:- a:]) A1)\n   (map_mat (\\<lambda>a. [:- a:]) A2) (0\\<^sub>m n 1)\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n    map_mat (\\<lambda>a. [:- a:]) A3)\n\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "have \"det \\<dots> = det (?cm A1) * det (?cm A3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (four_block_mat\n          ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n           map_mat (\\<lambda>a. [:- a:]) A1)\n          (map_mat (\\<lambda>a. [:- a:]) A2) (0\\<^sub>m n 1)\n          ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n           map_mat (\\<lambda>a. [:- a:]) A3)) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n         map_mat (\\<lambda>a. [:- a:]) A1) *\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n         map_mat (\\<lambda>a. [:- a:]) A3)", "by (rule det_four_block_mat_lower_left_zero_col[OF _ _ refl], insert A1 A2 A3, auto)"], ["proof (state)\nthis:\n  det (four_block_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n         map_mat (\\<lambda>a. [:- a:]) A1)\n        (map_mat (\\<lambda>a. [:- a:]) A2) (0\\<^sub>m n 1)\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n         map_mat (\\<lambda>a. [:- a:]) A3)) =\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n       map_mat (\\<lambda>a. [:- a:]) A1) *\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n       map_mat (\\<lambda>a. [:- a:]) A3)\n\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "also"], ["proof (state)\nthis:\n  det (four_block_mat\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n         map_mat (\\<lambda>a. [:- a:]) A1)\n        (map_mat (\\<lambda>a. [:- a:]) A2) (0\\<^sub>m n 1)\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n         map_mat (\\<lambda>a. [:- a:]) A3)) =\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n       map_mat (\\<lambda>a. [:- a:]) A1) *\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n       map_mat (\\<lambda>a. [:- a:]) A3)\n\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "have \"\\<dots> = ?cp1 * ?cp3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n         map_mat (\\<lambda>a. [:- a:]) A1) *\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n         map_mat (\\<lambda>a. [:- a:]) A3) =\n    char_poly A1 * char_poly A3", "unfolding char_poly_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n         map_mat (\\<lambda>a. [:- a:]) A1) *\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n         map_mat (\\<lambda>a. [:- a:]) A3) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n         map_mat (\\<lambda>a. [:- a:]) A1) *\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n         map_mat (\\<lambda>a. [:- a:]) A3)", ".."], ["proof (state)\nthis:\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A1) +\n       map_mat (\\<lambda>a. [:- a:]) A1) *\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A3) +\n       map_mat (\\<lambda>a. [:- a:]) A3) =\n  char_poly A1 * char_poly A3\n\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "finally"], ["proof (chain)\npicking this:\n  char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n  char_poly A1 * char_poly A3", "show ?thesis"], ["proof (prove)\nusing this:\n  char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n  char_poly A1 * char_poly A3\n\ngoal (1 subgoal):\n 1. char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n    char_poly A1 * char_poly A3", "."], ["proof (state)\nthis:\n  char_poly (four_block_mat A1 A2 (0\\<^sub>m n 1) A3) =\n  char_poly A1 * char_poly A3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma char_poly_transpose_mat[simp]: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"char_poly (transpose_mat A) = char_poly A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A\\<^sup>T = char_poly A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A\\<^sup>T = char_poly A", "let ?A = \"[:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) + map_mat (\\<lambda>a. [:- a:]) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A\\<^sup>T = char_poly A", "have A': \"?A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n    map_mat (\\<lambda>a. [:- a:]) A\n    \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n    map_mat (\\<lambda>a. [:- a:]) A\n    \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n  map_mat (\\<lambda>a. [:- a:]) A\n  \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. char_poly A\\<^sup>T = char_poly A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A\\<^sup>T = char_poly A", "unfolding char_poly_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A\\<^sup>T) +\n         map_mat (\\<lambda>a. [:- a:]) A\\<^sup>T) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n         map_mat (\\<lambda>a. [:- a:]) A)", "by (subst det_transpose[symmetric, OF A'], rule arg_cong[of _ _ det],\n    insert A, auto)"], ["proof (state)\nthis:\n  char_poly A\\<^sup>T = char_poly A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pderiv_char_poly: fixes A :: \"'a :: idom mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" \n  shows \"pderiv (char_poly A) = (\\<Sum>i < n. char_poly (mat_delete A i i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "let ?det = Determinant.det"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "let ?m = \"map_mat (\\<lambda>a. [:- a:])\""], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "let ?lam = \"[:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m n :: 'a poly mat\""], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have id: \"dim_row A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "define mA where \"mA = ?m A\""], ["proof (state)\nthis:\n  mA = map_mat (\\<lambda>a. [:- a:]) A\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "define lam where \"lam = ?lam\""], ["proof (state)\nthis:\n  lam = [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "let ?sum = \"lam + mA\""], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "define Sum where \"Sum = ?sum\""], ["proof (state)\nthis:\n  Sum = lam + mA\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have mA: \"mA \\<in> carrier_mat n n\" and \n    lam: \"lam \\<in> carrier_mat n n\" and\n    Sum: \"Sum \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mA \\<in> carrier_mat n n &&&\n    lam \\<in> carrier_mat n n &&& Sum \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mA \\<in> carrier_mat n n &&&\n    lam \\<in> carrier_mat n n &&& Sum \\<in> carrier_mat n n", "unfolding mA_def Sum_def lam_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. map_mat (\\<lambda>a. [:- a:]) A \\<in> carrier_mat n n &&&\n    [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n \\<in> carrier_mat n n &&&\n    [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n    map_mat (\\<lambda>a. [:- a:]) A\n    \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  mA \\<in> carrier_mat n n\n  lam \\<in> carrier_mat n n\n  Sum \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "let ?P = \"{p. p permutes {0..<n}}\""], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "let ?e = \"\\<lambda> p. (\\<Prod>i = 0..<n. Sum $$ (i, p i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "let ?f = \"\\<lambda> p a. signof p * (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, p i)) * pderiv (Sum $$ (a, p a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "let ?g = \"\\<lambda> p a. signof p * (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, p i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "define f where \"f = ?f\""], ["proof (state)\nthis:\n  f =\n  (\\<lambda>p a.\n      signof p * (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, p i)) *\n      pderiv (Sum $$ (a, p a)))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "define g where \"g = ?g\""], ["proof (state)\nthis:\n  g =\n  (\\<lambda>p a. signof p * (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "{"], ["proof (state)\nthis:\n  g =\n  (\\<lambda>p a. signof p * (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "assume p: \"p permutes {0 ..< n}\""], ["proof (state)\nthis:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"pderiv (signof p :: 'a poly) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (signof p) = 0", "unfolding signof_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (if sign p = 1 then 1 else - 1) = 0", "by (simp add: pderiv_minus)"], ["proof (state)\nthis:\n  pderiv (signof p) = 0\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "hence \"pderiv (signof p * ?e p) = signof p * pderiv (\\<Prod>i = 0..<n. Sum $$ (i, p i))\""], ["proof (prove)\nusing this:\n  pderiv (signof p) = 0\n\ngoal (1 subgoal):\n 1. pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i))) =\n    signof p * pderiv (\\<Prod>i = 0..<n. Sum $$ (i, p i))", "unfolding pderiv_mult"], ["proof (prove)\nusing this:\n  pderiv (signof p) = 0\n\ngoal (1 subgoal):\n 1. signof p * pderiv (\\<Prod>i = 0..<n. Sum $$ (i, p i)) +\n    (\\<Prod>i = 0..<n. Sum $$ (i, p i)) * pderiv (signof p) =\n    signof p * pderiv (\\<Prod>i = 0..<n. Sum $$ (i, p i))", "by auto"], ["proof (state)\nthis:\n  pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i))) =\n  signof p * pderiv (\\<Prod>i = 0..<n. Sum $$ (i, p i))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i))) =\n  signof p * pderiv (\\<Prod>i = 0..<n. Sum $$ (i, p i))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"signof p * pderiv (\\<Prod>i = 0..<n. Sum $$ (i, p i)) = \n       (\\<Sum>a = 0..<n. f p a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p * pderiv (\\<Prod>i = 0..<n. Sum $$ (i, p i)) =\n    sum (f p) {0..<n}", "unfolding pderiv_prod sum_distrib_left f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>na = 0..<n.\n        signof p *\n        ((\\<Prod>i\\<in>{0..<n} - {na}. Sum $$ (i, p i)) *\n         pderiv (Sum $$ (na, p na)))) =\n    (\\<Sum>a = 0..<n.\n        signof p * (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, p i)) *\n        pderiv (Sum $$ (a, p a)))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  signof p * pderiv (\\<Prod>i = 0..<n. Sum $$ (i, p i)) = sum (f p) {0..<n}\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  signof p * pderiv (\\<Prod>i = 0..<n. Sum $$ (i, p i)) = sum (f p) {0..<n}\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "note calculation"], ["proof (state)\nthis:\n  pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i))) =\n  sum (f p) {0..<n}\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "}"], ["proof (state)\nthis:\n  ?p4 permutes {0..<n} \\<Longrightarrow>\n  pderiv (signof ?p4 * (\\<Prod>i = 0..<n. Sum $$ (i, ?p4 i))) =\n  sum (f ?p4) {0..<n}\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "note to_f = this"], ["proof (state)\nthis:\n  ?p4 permutes {0..<n} \\<Longrightarrow>\n  pderiv (signof ?p4 * (\\<Prod>i = 0..<n. Sum $$ (i, ?p4 i))) =\n  sum (f ?p4) {0..<n}\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "{"], ["proof (state)\nthis:\n  ?p4 permutes {0..<n} \\<Longrightarrow>\n  pderiv (signof ?p4 * (\\<Prod>i = 0..<n. Sum $$ (i, ?p4 i))) =\n  sum (f ?p4) {0..<n}\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "assume a: \"a < n\""], ["proof (state)\nthis:\n  a < n\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have Psplit: \"?P = {p. p permutes {0..<n} \\<and> p a = a} \\<union> (?P - {p. p a = a})\" (is \"_ = ?Pa \\<union> ?Pz\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes {0..<n}} =\n    {p. p permutes {0..<n} \\<and> p a = a} \\<union>\n    ({p. p permutes {0..<n}} - {p. p a = a})", "by auto"], ["proof (state)\nthis:\n  {p. p permutes {0..<n}} =\n  {p. p permutes {0..<n} \\<and> p a = a} \\<union>\n  ({p. p permutes {0..<n}} - {p. p a = a})\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "{"], ["proof (state)\nthis:\n  {p. p permutes {0..<n}} =\n  {p. p permutes {0..<n} \\<and> p a = a} \\<union>\n  ({p. p permutes {0..<n}} - {p. p a = a})\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "assume p: \"p permutes {0 ..< n}\" \"p a \\<noteq> a\""], ["proof (state)\nthis:\n  p permutes {0..<n}\n  p a \\<noteq> a\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "hence \"pderiv (Sum $$ (a, p a)) = 0\""], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  p a \\<noteq> a\n\ngoal (1 subgoal):\n 1. pderiv (Sum $$ (a, p a)) = 0", "unfolding Sum_def lam_def mA_def"], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  p a \\<noteq> a\n\ngoal (1 subgoal):\n 1. pderiv\n     (([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) A) $$\n      (a, p a)) =\n    0", "using a p A"], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  p a \\<noteq> a\n  a < n\n  p permutes {0..<n}\n  p a \\<noteq> a\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. pderiv\n     (([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) A) $$\n      (a, p a)) =\n    0", "by auto"], ["proof (state)\nthis:\n  pderiv (Sum $$ (a, p a)) = 0\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "hence \"f p a = 0\""], ["proof (prove)\nusing this:\n  pderiv (Sum $$ (a, p a)) = 0\n\ngoal (1 subgoal):\n 1. f p a = 0", "unfolding f_def"], ["proof (prove)\nusing this:\n  pderiv (Sum $$ (a, p a)) = 0\n\ngoal (1 subgoal):\n 1. signof p * (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, p i)) *\n    pderiv (Sum $$ (a, p a)) =\n    0", "by auto"], ["proof (state)\nthis:\n  f p a = 0\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?p4 permutes {0..<n}; ?p4 a \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> f ?p4 a = 0\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "note 0 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?p4 permutes {0..<n}; ?p4 a \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> f ?p4 a = 0\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?p4 permutes {0..<n}; ?p4 a \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> f ?p4 a = 0\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "assume p: \"p permutes {0 ..< n}\" \"p a = a\""], ["proof (state)\nthis:\n  p permutes {0..<n}\n  p a = a\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "hence \"pderiv (Sum $$ (a, p a)) = 1\""], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  p a = a\n\ngoal (1 subgoal):\n 1. pderiv (Sum $$ (a, p a)) = 1", "unfolding Sum_def lam_def mA_def"], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  p a = a\n\ngoal (1 subgoal):\n 1. pderiv\n     (([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) A) $$\n      (a, p a)) =\n    1", "using a p A"], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  p a = a\n  a < n\n  p permutes {0..<n}\n  p a = a\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. pderiv\n     (([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) A) $$\n      (a, p a)) =\n    1", "by (auto simp: pderiv_pCons)"], ["proof (state)\nthis:\n  pderiv (Sum $$ (a, p a)) = 1\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "hence \"f p a = g p a\""], ["proof (prove)\nusing this:\n  pderiv (Sum $$ (a, p a)) = 1\n\ngoal (1 subgoal):\n 1. f p a = g p a", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  pderiv (Sum $$ (a, p a)) = 1\n\ngoal (1 subgoal):\n 1. signof p * (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, p i)) *\n    pderiv (Sum $$ (a, p a)) =\n    signof p * (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, p i))", "by auto"], ["proof (state)\nthis:\n  f p a = g p a\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?p4 permutes {0..<n}; ?p4 a = a\\<rbrakk>\n  \\<Longrightarrow> f ?p4 a = g ?p4 a\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "note fg = this"], ["proof (state)\nthis:\n  \\<lbrakk>?p4 permutes {0..<n}; ?p4 a = a\\<rbrakk>\n  \\<Longrightarrow> f ?p4 a = g ?p4 a\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "let ?n = \"n - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "from a"], ["proof (chain)\npicking this:\n  a < n", "have n: \"Suc ?n = n\""], ["proof (prove)\nusing this:\n  a < n\n\ngoal (1 subgoal):\n 1. Suc (n - 1) = n", "by simp"], ["proof (state)\nthis:\n  Suc (n - 1) = n\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "let ?B = \"[:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m ?n + ?m (mat_delete A a a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have B: \"?B \\<in> carrier_mat ?n ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n    map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)\n    \\<in> carrier_mat (n - 1) (n - 1)", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n    map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)\n    \\<in> carrier_mat (n - 1) (n - 1)", "by auto"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n  map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)\n  \\<in> carrier_mat (n - 1) (n - 1)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"sum (\\<lambda> p. f p a) ?P = sum (\\<lambda> p. f p a) ?Pa + sum (\\<lambda> p. f p a) ?Pz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}. f p a) =\n    (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a) +\n    (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {p. p a = a}. f p a)", "by (subst sum.union_disjoint[symmetric], auto simp: finite_permutations Psplit[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}. f p a) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a) +\n  (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {p. p a = a}. f p a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}. f p a) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a) +\n  (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {p. p a = a}. f p a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"\\<dots> = sum (\\<lambda> p. f p a) ?Pa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a) +\n    (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {p. p a = a}. f p a) =\n    (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a)", "by (subst (2) sum.neutral, insert 0, auto)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a) +\n  (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {p. p a = a}. f p a) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a) +\n  (\\<Sum>p\\<in>{p. p permutes {0..<n}} - {p. p a = a}. f p a) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"\\<dots> = sum (\\<lambda> p. g p a) ?Pa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a) =\n    (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. g p a)", "by (rule sum.cong, auto simp: fg)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. g p a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. f p a) =\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. g p a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"\\<dots> = ?det ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. g p a) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a))", "unfolding det_def'[OF B]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. g p a) =\n    (\\<Sum>p | p permutes {0..<n - 1}.\n       signof p *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, p i)))", "unfolding permutation_fix[of a ?n a, unfolded n, OF a a]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>permutation_insert a a ` {q. q permutes {0..<n - 1}}.\n       g p a) =\n    (\\<Sum>p | p permutes {0..<n - 1}.\n       signof p *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, p i)))", "unfolding sum.reindex[OF permutation_insert_inj_on[of a ?n a, unfolded n, OF a a]] o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{q. q permutes {0..<n - 1}}.\n       g (permutation_insert a a x) a) =\n    (\\<Sum>p | p permutes {0..<n - 1}.\n       signof p *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, p i)))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {q. q permutes {0..<n - 1}} \\<Longrightarrow>\n       g (permutation_insert a a x) a =\n       signof x *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, x i))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {q. q permutes {0..<n - 1}} \\<Longrightarrow>\n       g (permutation_insert a a x) a =\n       signof x *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, x i))", "let ?Q = \"{p. p permutes {0..<?n}}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {q. q permutes {0..<n - 1}} \\<Longrightarrow>\n       g (permutation_insert a a x) a =\n       signof x *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, x i))", "assume \"p \\<in> ?Q\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<n - 1}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {q. q permutes {0..<n - 1}} \\<Longrightarrow>\n       g (permutation_insert a a x) a =\n       signof x *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, x i))", "hence p: \"p permutes {0 ..< ?n}\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes {0..<n - 1}}\n\ngoal (1 subgoal):\n 1. p permutes {0..<n - 1}", "by auto"], ["proof (state)\nthis:\n  p permutes {0..<n - 1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {q. q permutes {0..<n - 1}} \\<Longrightarrow>\n       g (permutation_insert a a x) a =\n       signof x *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, x i))", "let ?p = \"permutation_insert a a p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {q. q permutes {0..<n - 1}} \\<Longrightarrow>\n       g (permutation_insert a a x) a =\n       signof x *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, x i))", "let ?i = \"insert_index a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {q. q permutes {0..<n - 1}} \\<Longrightarrow>\n       g (permutation_insert a a x) a =\n       signof x *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, x i))", "have sign: \"signof ?p = signof p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof (permutation_insert a a p) = signof p", "unfolding signof_permutation_insert[OF p, unfolded n, OF a a]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'b)) ^ (a + a) * signof p = signof p", "by simp"], ["proof (state)\nthis:\n  signof (permutation_insert a a p) = signof p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {q. q permutes {0..<n - 1}} \\<Longrightarrow>\n       g (permutation_insert a a x) a =\n       signof x *\n       (\\<Prod>i = 0..<n - 1.\n           ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n            map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n           (i, x i))", "show \"g (permutation_insert a a p) a = signof p * (\\<Prod>i = 0..<?n. ?B $$ (i, p i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (permutation_insert a a p) a =\n    signof p *\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "unfolding g_def sign"], ["proof (prove)\ngoal (1 subgoal):\n 1. signof p *\n    (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    signof p *\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "proof (rule arg_cong[of _ _ \"(*) (signof p)\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "have \"(\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, ?p i)) = \n           prod (($$) Sum) ((\\<lambda>x. (x, ?p x)) ` ({0..<n} - {a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    prod (($$) Sum)\n     ((\\<lambda>x. (x, permutation_insert a a p x)) ` ({0..<n} - {a}))", "unfolding prod.reindex[OF inj_on_convol_ident, of _ ?p] o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>x\\<in>{0..<n} - {a}. Sum $$ (x, permutation_insert a a p x))", ".."], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n  prod (($$) Sum)\n   ((\\<lambda>x. (x, permutation_insert a a p x)) ` ({0..<n} - {a}))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "also"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n  prod (($$) Sum)\n   ((\\<lambda>x. (x, permutation_insert a a p x)) ` ({0..<n} - {a}))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "have \"\\<dots> = (\\<Prod> ii \\<in> {(i', ?p i') |i'. i' \\<in> {0..<n} - {a}}. Sum $$ ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (($$) Sum)\n     ((\\<lambda>x. (x, permutation_insert a a p x)) ` ({0..<n} - {a})) =\n    prod (($$) Sum)\n     {(i', permutation_insert a a p i') |i'. i' \\<in> {0..<n} - {a}}", "by (rule prod.cong, auto)"], ["proof (state)\nthis:\n  prod (($$) Sum)\n   ((\\<lambda>x. (x, permutation_insert a a p x)) ` ({0..<n} - {a})) =\n  prod (($$) Sum)\n   {(i', permutation_insert a a p i') |i'. i' \\<in> {0..<n} - {a}}\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "also"], ["proof (state)\nthis:\n  prod (($$) Sum)\n   ((\\<lambda>x. (x, permutation_insert a a p x)) ` ({0..<n} - {a})) =\n  prod (($$) Sum)\n   {(i', permutation_insert a a p i') |i'. i' \\<in> {0..<n} - {a}}\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "have \"\\<dots> = prod (($$) Sum) ((\\<lambda> i. (?i i, ?i (p i))) ` {0 ..< ?n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (($$) Sum)\n     {(i', permutation_insert a a p i') |i'. i' \\<in> {0..<n} - {a}} =\n    prod (($$) Sum)\n     ((\\<lambda>i. (insert_index a i, insert_index a (p i))) ` {0..<n - 1})", "unfolding Determinant.foo[of a ?n a, unfolded n, OF a a p]"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (($$) Sum)\n     {(insert_index a i'', insert_index a (p i'')) |i''. i'' < n - 1} =\n    prod (($$) Sum)\n     ((\\<lambda>i. (insert_index a i, insert_index a (p i))) ` {0..<n - 1})", "by (rule arg_cong[of _ _ \"prod _\"], auto)"], ["proof (state)\nthis:\n  prod (($$) Sum)\n   {(i', permutation_insert a a p i') |i'. i' \\<in> {0..<n} - {a}} =\n  prod (($$) Sum)\n   ((\\<lambda>i. (insert_index a i, insert_index a (p i))) ` {0..<n - 1})\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "also"], ["proof (state)\nthis:\n  prod (($$) Sum)\n   {(i', permutation_insert a a p i') |i'. i' \\<in> {0..<n} - {a}} =\n  prod (($$) Sum)\n   ((\\<lambda>i. (insert_index a i, insert_index a (p i))) ` {0..<n - 1})\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "have \"\\<dots> = prod (\\<lambda> i. Sum $$ (?i i, ?i (p i))) {0 ..< ?n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (($$) Sum)\n     ((\\<lambda>i. (insert_index a i, insert_index a (p i))) `\n      {0..<n - 1}) =\n    (\\<Prod>i = 0..<n - 1. Sum $$ (insert_index a i, insert_index a (p i)))", "proof (subst prod.reindex, unfold o_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>i. (insert_index a i, insert_index a (p i)))\n     {0..<n - 1}\n 2. (\\<Prod>x = 0..<n - 1.\n        Sum $$ (insert_index a x, insert_index a (p x))) =\n    (\\<Prod>i = 0..<n - 1. Sum $$ (insert_index a i, insert_index a (p i)))", "show \"inj_on (\\<lambda>i. (?i i, ?i (p i))) {0..<?n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. (insert_index a i, insert_index a (p i)))\n     {0..<n - 1}", "using insert_index_inj_on[of a]"], ["proof (prove)\nusing this:\n  inj_on (insert_index a) ?S\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. (insert_index a i, insert_index a (p i)))\n     {0..<n - 1}", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>i. (insert_index a i, insert_index a (p i))) {0..<n - 1}\n\ngoal (1 subgoal):\n 1. (\\<Prod>x = 0..<n - 1.\n        Sum $$ (insert_index a x, insert_index a (p x))) =\n    (\\<Prod>i = 0..<n - 1. Sum $$ (insert_index a i, insert_index a (p i)))", "qed simp"], ["proof (state)\nthis:\n  prod (($$) Sum)\n   ((\\<lambda>i. (insert_index a i, insert_index a (p i))) ` {0..<n - 1}) =\n  (\\<Prod>i = 0..<n - 1. Sum $$ (insert_index a i, insert_index a (p i)))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "also"], ["proof (state)\nthis:\n  prod (($$) Sum)\n   ((\\<lambda>i. (insert_index a i, insert_index a (p i))) ` {0..<n - 1}) =\n  (\\<Prod>i = 0..<n - 1. Sum $$ (insert_index a i, insert_index a (p i)))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "have \"\\<dots> = (\\<Prod>i = 0..<?n. ?B $$ (i, p i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n - 1.\n        Sum $$ (insert_index a i, insert_index a (p i))) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "proof (rule prod.cong[OF refl], rename_tac i)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "assume \"j \\<in> {0 ..< ?n}\""], ["proof (state)\nthis:\n  j \\<in> {0..<n - 1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "hence j: \"j < ?n\""], ["proof (prove)\nusing this:\n  j \\<in> {0..<n - 1}\n\ngoal (1 subgoal):\n 1. j < n - 1", "by auto"], ["proof (state)\nthis:\n  j < n - 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "with p"], ["proof (chain)\npicking this:\n  p permutes {0..<n - 1}\n  j < n - 1", "have pj: \"p j < ?n\""], ["proof (prove)\nusing this:\n  p permutes {0..<n - 1}\n  j < n - 1\n\ngoal (1 subgoal):\n 1. p j < n - 1", "by auto"], ["proof (state)\nthis:\n  p j < n - 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "from j pj"], ["proof (chain)\npicking this:\n  j < n - 1\n  p j < n - 1", "have jj: \"?i j < n\" \"?i (p j) < n\""], ["proof (prove)\nusing this:\n  j < n - 1\n  p j < n - 1\n\ngoal (1 subgoal):\n 1. insert_index a j < n &&& insert_index a (p j) < n", "by (auto simp: insert_index_def)"], ["proof (state)\nthis:\n  insert_index a j < n\n  insert_index a (p j) < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "let ?jj = \"(?i j, ?i (p j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "note index_adj = mat_delete_index[of _ ?n, unfolded n, OF _ a a j pj]"], ["proof (state)\nthis:\n  ?A \\<in> carrier_mat n n \\<Longrightarrow>\n  ?A $$ (insert_index a j, insert_index a (p j)) =\n  mat_delete ?A a a $$ (j, p j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "have \"Sum $$ ?jj = lam $$ ?jj + mA $$ ?jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum $$ (insert_index a j, insert_index a (p j)) =\n    lam $$ (insert_index a j, insert_index a (p j)) +\n    mA $$ (insert_index a j, insert_index a (p j))", "unfolding Sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lam + mA) $$ (insert_index a j, insert_index a (p j)) =\n    lam $$ (insert_index a j, insert_index a (p j)) +\n    mA $$ (insert_index a j, insert_index a (p j))", "using jj A lam mA"], ["proof (prove)\nusing this:\n  insert_index a j < n\n  insert_index a (p j) < n\n  A \\<in> carrier_mat n n\n  lam \\<in> carrier_mat n n\n  mA \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (lam + mA) $$ (insert_index a j, insert_index a (p j)) =\n    lam $$ (insert_index a j, insert_index a (p j)) +\n    mA $$ (insert_index a j, insert_index a (p j))", "by auto"], ["proof (state)\nthis:\n  Sum $$ (insert_index a j, insert_index a (p j)) =\n  lam $$ (insert_index a j, insert_index a (p j)) +\n  mA $$ (insert_index a j, insert_index a (p j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "also"], ["proof (state)\nthis:\n  Sum $$ (insert_index a j, insert_index a (p j)) =\n  lam $$ (insert_index a j, insert_index a (p j)) +\n  mA $$ (insert_index a j, insert_index a (p j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "have \"\\<dots> = ?B $$ (j, p j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lam $$ (insert_index a j, insert_index a (p j)) +\n    mA $$ (insert_index a j, insert_index a (p j)) =\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n     map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n    (j, p j)", "unfolding index_adj[OF mA] index_adj[OF lam]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_delete lam a a $$ (j, p j) + mat_delete mA a a $$ (j, p j) =\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n     map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n    (j, p j)", "using j pj A"], ["proof (prove)\nusing this:\n  j < n - 1\n  p j < n - 1\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat_delete lam a a $$ (j, p j) + mat_delete mA a a $$ (j, p j) =\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n     map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n    (j, p j)", "by (simp add: mA_def lam_def mat_delete_def)"], ["proof (state)\nthis:\n  lam $$ (insert_index a j, insert_index a (p j)) +\n  mA $$ (insert_index a j, insert_index a (p j)) =\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n   map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n  (j, p j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<n - 1} \\<Longrightarrow>\n       Sum $$ (insert_index a i, insert_index a (p i)) =\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n        map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n       (i, p i)", "finally"], ["proof (chain)\npicking this:\n  Sum $$ (insert_index a j, insert_index a (p j)) =\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n   map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n  (j, p j)", "show \"Sum $$ ?jj = ?B $$ (j, p j)\""], ["proof (prove)\nusing this:\n  Sum $$ (insert_index a j, insert_index a (p j)) =\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n   map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n  (j, p j)\n\ngoal (1 subgoal):\n 1. Sum $$ (insert_index a j, insert_index a (p j)) =\n    ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n     map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n    (j, p j)", "."], ["proof (state)\nthis:\n  Sum $$ (insert_index a j, insert_index a (p j)) =\n  ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n   map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n  (j, p j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n - 1. Sum $$ (insert_index a i, insert_index a (p i))) =\n  (\\<Prod>i = 0..<n - 1.\n      ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n       map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n      (i, p i))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n  (\\<Prod>i = 0..<n - 1.\n      ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n       map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n      (i, p i))", "show \"(\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, ?p i)) = (\\<Prod>i = 0..<?n. ?B $$ (i, p i))\""], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n  (\\<Prod>i = 0..<n - 1.\n      ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n       map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n      (i, p i))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n    (\\<Prod>i = 0..<n - 1.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n        (i, p i))", "."], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>{0..<n} - {a}. Sum $$ (i, permutation_insert a a p i)) =\n  (\\<Prod>i = 0..<n - 1.\n      ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n       map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n      (i, p i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g (permutation_insert a a p) a =\n  signof p *\n  (\\<Prod>i = 0..<n - 1.\n      ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n       map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) $$\n      (i, p i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. g p a) =\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n       map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n} \\<and> p a = a. g p a) =\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n       map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"\\<dots> = char_poly (mat_delete A a a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) =\n    char_poly (mat_delete A a a)", "unfolding char_poly_def char_poly_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (dim_row (mat_delete A a a)) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a))", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (dim_row (mat_delete A a a)) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a))", "by simp"], ["proof (state)\nthis:\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n       map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) =\n  char_poly (mat_delete A a a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (n - 1) +\n       map_mat (\\<lambda>a. [:- a:]) (mat_delete A a a)) =\n  char_poly (mat_delete A a a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "note calculation"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}. f p a) = char_poly (mat_delete A a a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "}"], ["proof (state)\nthis:\n  ?a4 < n \\<Longrightarrow>\n  (\\<Sum>p | p permutes {0..<n}. f p ?a4) = char_poly (mat_delete A ?a4 ?a4)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "note to_char_poly = this"], ["proof (state)\nthis:\n  ?a4 < n \\<Longrightarrow>\n  (\\<Sum>p | p permutes {0..<n}. f p ?a4) = char_poly (mat_delete A ?a4 ?a4)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"pderiv (char_poly A) = pderiv (?det Sum)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = pderiv (det Sum)", "unfolding char_poly_def char_poly_matrix_def id lam_def mA_def Sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv\n     (det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n           map_mat (\\<lambda>a. [:- a:]) A)) =\n    pderiv\n     (det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n           map_mat (\\<lambda>a. [:- a:]) A))", "by auto"], ["proof (state)\nthis:\n  pderiv (char_poly A) = pderiv (det Sum)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  pderiv (char_poly A) = pderiv (det Sum)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"\\<dots> = sum (\\<lambda> p. pderiv (signof p * ?e p)) ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (det Sum) =\n    (\\<Sum>p | p permutes {0..<n}.\n       pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i))))", "unfolding det_def'[OF Sum]\n    pderiv_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{p. p permutes {0..<n}}.\n       pderiv (signof i * (\\<Prod>ia = 0..<n. Sum $$ (ia, i ia)))) =\n    (\\<Sum>p | p permutes {0..<n}.\n       pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i))))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  pderiv (det Sum) =\n  (\\<Sum>p | p permutes {0..<n}.\n     pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i))))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  pderiv (det Sum) =\n  (\\<Sum>p | p permutes {0..<n}.\n     pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i))))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"\\<dots> = sum (\\<lambda> p. (\\<Sum>a = 0..<n. f p a)) ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}.\n       pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i)))) =\n    (\\<Sum>p | p permutes {0..<n}. sum (f p) {0..<n})", "by (rule sum.cong[OF refl], subst to_f, auto)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i)))) =\n  (\\<Sum>p | p permutes {0..<n}. sum (f p) {0..<n})\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}.\n     pderiv (signof p * (\\<Prod>i = 0..<n. Sum $$ (i, p i)))) =\n  (\\<Sum>p | p permutes {0..<n}. sum (f p) {0..<n})\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"\\<dots> = (\\<Sum>a = 0..<n. sum (\\<lambda> p. f p a) ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<n}. sum (f p) {0..<n}) =\n    (\\<Sum>a = 0..<n. \\<Sum>p | p permutes {0..<n}. f p a)", "by (rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}. sum (f p) {0..<n}) =\n  (\\<Sum>a = 0..<n. \\<Sum>p | p permutes {0..<n}. f p a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<n}. sum (f p) {0..<n}) =\n  (\\<Sum>a = 0..<n. \\<Sum>p | p permutes {0..<n}. f p a)\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "have \"\\<dots> = (\\<Sum>a <n. char_poly (mat_delete A a a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a = 0..<n. \\<Sum>p | p permutes {0..<n}. f p a) =\n    (\\<Sum>a<n. char_poly (mat_delete A a a))", "by (rule sum.cong, auto simp: to_char_poly)"], ["proof (state)\nthis:\n  (\\<Sum>a = 0..<n. \\<Sum>p | p permutes {0..<n}. f p a) =\n  (\\<Sum>a<n. char_poly (mat_delete A a a))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "finally"], ["proof (chain)\npicking this:\n  pderiv (char_poly A) = (\\<Sum>a<n. char_poly (mat_delete A a a))", "show ?thesis"], ["proof (prove)\nusing this:\n  pderiv (char_poly A) = (\\<Sum>a<n. char_poly (mat_delete A a a))\n\ngoal (1 subgoal):\n 1. pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))", "."], ["proof (state)\nthis:\n  pderiv (char_poly A) = (\\<Sum>i<n. char_poly (mat_delete A i i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma char_poly_0_column: fixes A :: \"'a :: idom mat\" \n  assumes 0: \"\\<And> j. j < n \\<Longrightarrow> A $$ (j,i) = 0\" \n  and A: \"A \\<in> carrier_mat n n\" \n  and i: \"i < n\"\nshows \"char_poly A = monom 1 1 * char_poly (mat_delete A i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "let ?n = \"n - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "let ?A = \"mat_delete A i i\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "let ?sum = \"[:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m n + map_mat (\\<lambda>a. [:- a:]) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "define Sum where \"Sum = ?sum\""], ["proof (state)\nthis:\n  Sum =\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n  map_mat (\\<lambda>a. [:- a:]) A\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "let ?f = \"\\<lambda> j. Sum $$ (j, i) * cofactor Sum j i\""], ["proof (state)\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "have Sum: \"Sum \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. Sum \\<in> carrier_mat n n", "unfolding Sum_def"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n    map_mat (\\<lambda>a. [:- a:]) A\n    \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  Sum \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have id: \"dim_row A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "have \"char_poly A = (\\<Sum>j<n. ?f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = (\\<Sum>j<n. Sum $$ (j, i) * cofactor Sum j i)", "unfolding char_poly_def[of A] char_poly_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n         map_mat (\\<lambda>a. [:- a:]) A) =\n    (\\<Sum>j<n. Sum $$ (j, i) * cofactor Sum j i)", "using laplace_expansion_column[OF Sum i]"], ["proof (prove)\nusing this:\n  det Sum = (\\<Sum>ia<n. Sum $$ (ia, i) * cofactor Sum ia i)\n\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n         map_mat (\\<lambda>a. [:- a:]) A) =\n    (\\<Sum>j<n. Sum $$ (j, i) * cofactor Sum j i)", "unfolding Sum_def"], ["proof (prove)\nusing this:\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) A) =\n  (\\<Sum>ia<n.\n      ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) A) $$\n      (ia, i) *\n      cofactor\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A)\n       ia i)\n\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n         map_mat (\\<lambda>a. [:- a:]) A) =\n    (\\<Sum>j<n.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) A) $$\n        (j, i) *\n        cofactor\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A)\n         j i)", "using A"], ["proof (prove)\nusing this:\n  det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) A) =\n  (\\<Sum>ia<n.\n      ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n       map_mat (\\<lambda>a. [:- a:]) A) $$\n      (ia, i) *\n      cofactor\n       ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n        map_mat (\\<lambda>a. [:- a:]) A)\n       ia i)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n         map_mat (\\<lambda>a. [:- a:]) A) =\n    (\\<Sum>j<n.\n        ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n         map_mat (\\<lambda>a. [:- a:]) A) $$\n        (j, i) *\n        cofactor\n         ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n          map_mat (\\<lambda>a. [:- a:]) A)\n         j i)", "by simp"], ["proof (state)\nthis:\n  char_poly A = (\\<Sum>j<n. Sum $$ (j, i) * cofactor Sum j i)\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "also"], ["proof (state)\nthis:\n  char_poly A = (\\<Sum>j<n. Sum $$ (j, i) * cofactor Sum j i)\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "have \"\\<dots> = ?f i + sum ?f ({..<n} - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<n. Sum $$ (j, i) * cofactor Sum j i) =\n    Sum $$ (i, i) * cofactor Sum i i +\n    (\\<Sum>j\\<in>{..<n} - {i}. Sum $$ (j, i) * cofactor Sum j i)", "by (rule sum.remove[of _ i], insert i, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j<n. Sum $$ (j, i) * cofactor Sum j i) =\n  Sum $$ (i, i) * cofactor Sum i i +\n  (\\<Sum>j\\<in>{..<n} - {i}. Sum $$ (j, i) * cofactor Sum j i)\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<n. Sum $$ (j, i) * cofactor Sum j i) =\n  Sum $$ (i, i) * cofactor Sum i i +\n  (\\<Sum>j\\<in>{..<n} - {i}. Sum $$ (j, i) * cofactor Sum j i)\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "have \"\\<dots> = ?f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum $$ (i, i) * cofactor Sum i i +\n    (\\<Sum>j\\<in>{..<n} - {i}. Sum $$ (j, i) * cofactor Sum j i) =\n    Sum $$ (i, i) * cofactor Sum i i", "proof (subst sum.neutral, intro ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<n} - {i} \\<Longrightarrow>\n       Sum $$ (x, i) * cofactor Sum x i = 0\n 2. Sum $$ (i, i) * cofactor Sum i i + 0 = Sum $$ (i, i) * cofactor Sum i i", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<n} - {i} \\<Longrightarrow>\n       Sum $$ (x, i) * cofactor Sum x i = 0\n 2. Sum $$ (i, i) * cofactor Sum i i + 0 = Sum $$ (i, i) * cofactor Sum i i", "assume \"j \\<in> {..<n} - {i}\""], ["proof (state)\nthis:\n  j \\<in> {..<n} - {i}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<n} - {i} \\<Longrightarrow>\n       Sum $$ (x, i) * cofactor Sum x i = 0\n 2. Sum $$ (i, i) * cofactor Sum i i + 0 = Sum $$ (i, i) * cofactor Sum i i", "hence j: \"j < n\" and ji: \"j \\<noteq> i\""], ["proof (prove)\nusing this:\n  j \\<in> {..<n} - {i}\n\ngoal (1 subgoal):\n 1. j < n &&& j \\<noteq> i", "by auto"], ["proof (state)\nthis:\n  j < n\n  j \\<noteq> i\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {..<n} - {i} \\<Longrightarrow>\n       Sum $$ (x, i) * cofactor Sum x i = 0\n 2. Sum $$ (i, i) * cofactor Sum i i + 0 = Sum $$ (i, i) * cofactor Sum i i", "show \"?f j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum $$ (j, i) * cofactor Sum j i = 0", "unfolding Sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n     map_mat (\\<lambda>a. [:- a:]) A) $$\n    (j, i) *\n    cofactor\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n      map_mat (\\<lambda>a. [:- a:]) A)\n     j i =\n    0", "using ji j i A 0[OF j]"], ["proof (prove)\nusing this:\n  j \\<noteq> i\n  j < n\n  i < n\n  A \\<in> carrier_mat n n\n  A $$ (j, i) = (0::'a)\n\ngoal (1 subgoal):\n 1. ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n     map_mat (\\<lambda>a. [:- a:]) A) $$\n    (j, i) *\n    cofactor\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n      map_mat (\\<lambda>a. [:- a:]) A)\n     j i =\n    0", "by simp"], ["proof (state)\nthis:\n  Sum $$ (j, i) * cofactor Sum j i = 0\n\ngoal (1 subgoal):\n 1. Sum $$ (i, i) * cofactor Sum i i + 0 = Sum $$ (i, i) * cofactor Sum i i", "qed simp"], ["proof (state)\nthis:\n  Sum $$ (i, i) * cofactor Sum i i +\n  (\\<Sum>j\\<in>{..<n} - {i}. Sum $$ (j, i) * cofactor Sum j i) =\n  Sum $$ (i, i) * cofactor Sum i i\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "also"], ["proof (state)\nthis:\n  Sum $$ (i, i) * cofactor Sum i i +\n  (\\<Sum>j\\<in>{..<n} - {i}. Sum $$ (j, i) * cofactor Sum j i) =\n  Sum $$ (i, i) * cofactor Sum i i\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "have \"?f i = [:0, 1:] * (cofactor Sum i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum $$ (i, i) * cofactor Sum i i = [:0::'a, 1::'a:] * cofactor Sum i i", "unfolding Sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n     map_mat (\\<lambda>a. [:- a:]) A) $$\n    (i, i) *\n    cofactor\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n      map_mat (\\<lambda>a. [:- a:]) A)\n     i i =\n    [:0::'a, 1::'a:] *\n    cofactor\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n      map_mat (\\<lambda>a. [:- a:]) A)\n     i i", "using i A 0[OF i]"], ["proof (prove)\nusing this:\n  i < n\n  A \\<in> carrier_mat n n\n  A $$ (i, i) = (0::'a)\n\ngoal (1 subgoal):\n 1. ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n     map_mat (\\<lambda>a. [:- a:]) A) $$\n    (i, i) *\n    cofactor\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n      map_mat (\\<lambda>a. [:- a:]) A)\n     i i =\n    [:0::'a, 1::'a:] *\n    cofactor\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n      map_mat (\\<lambda>a. [:- a:]) A)\n     i i", "by simp"], ["proof (state)\nthis:\n  Sum $$ (i, i) * cofactor Sum i i = [:0::'a, 1::'a:] * cofactor Sum i i\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "also"], ["proof (state)\nthis:\n  Sum $$ (i, i) * cofactor Sum i i = [:0::'a, 1::'a:] * cofactor Sum i i\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "have \"cofactor Sum i i = det (mat_delete Sum i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cofactor Sum i i = det (mat_delete Sum i i)", "unfolding cofactor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (i + i) * det (mat_delete Sum i i) = det (mat_delete Sum i i)", "by simp"], ["proof (state)\nthis:\n  cofactor Sum i i = det (mat_delete Sum i i)\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "also"], ["proof (state)\nthis:\n  cofactor Sum i i = det (mat_delete Sum i i)\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "have \"\\<dots> = char_poly ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_delete Sum i i) = char_poly (mat_delete A i i)", "unfolding char_poly_def char_poly_matrix_def Sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat_delete\n          ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n           map_mat (\\<lambda>a. [:- a:]) A)\n          i i) =\n    det ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n         1\\<^sub>m (dim_row (mat_delete A i i)) +\n         map_mat (\\<lambda>a. [:- a:]) (mat_delete A i i))", "proof (rule arg_cong[of _ _ det])"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_delete\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n      map_mat (\\<lambda>a. [:- a:]) A)\n     i i =\n    [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n    1\\<^sub>m (dim_row (mat_delete A i i)) +\n    map_mat (\\<lambda>a. [:- a:]) (mat_delete A i i)", "show \"mat_delete ?sum i i = [:0, 1:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row ?A) + map_mat (\\<lambda>a. [:- a:]) ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_delete\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n      map_mat (\\<lambda>a. [:- a:]) A)\n     i i =\n    [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n    1\\<^sub>m (dim_row (mat_delete A i i)) +\n    map_mat (\\<lambda>a. [:- a:]) (mat_delete A i i)", "using i A"], ["proof (prove)\nusing this:\n  i < n\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat_delete\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n      map_mat (\\<lambda>a. [:- a:]) A)\n     i i =\n    [:0::'a, 1::'a:] \\<cdot>\\<^sub>m\n    1\\<^sub>m (dim_row (mat_delete A i i)) +\n    map_mat (\\<lambda>a. [:- a:]) (mat_delete A i i)", "by (auto simp: mat_delete_def)"], ["proof (state)\nthis:\n  mat_delete\n   ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m n +\n    map_mat (\\<lambda>a. [:- a:]) A)\n   i i =\n  [:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row (mat_delete A i i)) +\n  map_mat (\\<lambda>a. [:- a:]) (mat_delete A i i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (mat_delete Sum i i) = char_poly (mat_delete A i i)\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "also"], ["proof (state)\nthis:\n  det (mat_delete Sum i i) = char_poly (mat_delete A i i)\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "have \"[:0, 1:] = (monom 1 1 :: 'a poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] = monom (1::'a) 1", "by (rule x_as_monom)"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] = monom (1::'a) 1\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "finally"], ["proof (chain)\npicking this:\n  char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "show ?thesis"], ["proof (prove)\nusing this:\n  char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)\n\ngoal (1 subgoal):\n 1. char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)", "."], ["proof (state)\nthis:\n  char_poly A = monom (1::'a) 1 * char_poly (mat_delete A i i)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mat_erase :: \"'a :: zero mat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a mat\" where\n  \"mat_erase A i j = Matrix.mat (dim_row A) (dim_col A) \n     (\\<lambda> (i',j'). if i' = i \\<or> j' = j then 0 else A $$ (i',j'))\""], ["", "lemma mat_erase_carrier[simp]: \"(mat_erase A i j) \\<in> carrier_mat nr nc \\<longleftrightarrow> A \\<in> carrier_mat nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_erase A i j \\<in> carrier_mat nr nc) = (A \\<in> carrier_mat nr nc)", "unfolding mat_erase_def carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (dim_row A) (dim_col A)\n      (\\<lambda>(i', j').\n          if i' = i \\<or> j' = j then 0::'a else A $$ (i', j'))\n     \\<in> {m. dim_row m = nr \\<and> dim_col m = nc}) =\n    (A \\<in> {m. dim_row m = nr \\<and> dim_col m = nc})", "by simp"], ["", "lemma pderiv_char_poly_mat_erase: fixes A :: \"'a :: idom mat\" \n  assumes A: \"A \\<in> carrier_mat n n\" \n  shows \"monom 1 1 * pderiv (char_poly A) = (\\<Sum>i < n. char_poly (mat_erase A i i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (char_poly A) =\n    (\\<Sum>i<n. char_poly (mat_erase A i i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (char_poly A) =\n    (\\<Sum>i<n. char_poly (mat_erase A i i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (char_poly A) =\n    (\\<Sum>i<n. char_poly (mat_erase A i i))", "unfolding pderiv_char_poly[OF A] sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n<n. monom (1::'a) 1 * char_poly (mat_delete A n n)) =\n    (\\<Sum>i<n. char_poly (mat_erase A i i))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       monom (1::'a) 1 * char_poly (mat_delete A x x) =\n       char_poly (mat_erase A x x)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       monom (1::'a) 1 * char_poly (mat_delete A x x) =\n       char_poly (mat_erase A x x)", "assume \"i \\<in> {..<n}\""], ["proof (state)\nthis:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       monom (1::'a) 1 * char_poly (mat_delete A x x) =\n       char_poly (mat_erase A x x)", "hence i: \"i < n\""], ["proof (prove)\nusing this:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. i < n", "by simp"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       monom (1::'a) 1 * char_poly (mat_delete A x x) =\n       char_poly (mat_erase A x x)", "have mA: \"mat_erase A i i \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_erase A i i \\<in> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mat_erase A i i \\<in> carrier_mat n n", "by simp"], ["proof (state)\nthis:\n  mat_erase A i i \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       monom (1::'a) 1 * char_poly (mat_delete A x x) =\n       char_poly (mat_erase A x x)", "show \"monom 1 1 * char_poly (mat_delete A i i) = char_poly (mat_erase A i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * char_poly (mat_delete A i i) =\n    char_poly (mat_erase A i i)", "by (subst char_poly_0_column[OF _ mA i], (insert i A, force simp: mat_erase_def),\n      rule arg_cong[of _ _ \"\\<lambda> x. f * char_poly x\" for f],\n      auto simp: mat_delete_def mat_erase_def)"], ["proof (state)\nthis:\n  monom (1::'a) 1 * char_poly (mat_delete A i i) =\n  char_poly (mat_erase A i i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom (1::'a) 1 * pderiv (char_poly A) =\n  (\\<Sum>i<n. char_poly (mat_erase A i i))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}