{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Matrix_IArray_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma vec_code[code]: \"vec n f = vec_impl (vec_of_fun n f)\"", "lemma mat_code[code]: \"mat nr nc f = mat_impl (mat_of_fun nr nc f)\"", "lemma vec_of_list[code]: \"vec_of_list v = vec_impl (vec_of_list_impl v)\"", "lemma list_of_vec_code[code]: \"list_of_vec (vec_impl v) = list_of_vec_impl v\"", "lemma empty_nth: \"\\<not> i < length x \\<Longrightarrow> x ! i = [] ! (i - length x)\"", "lemma undef_vec: \"\\<not> i < length x \\<Longrightarrow> undef_vec (i - length x) = x ! i\"", "lemma vec_index_code[code]: \"(vec_impl v) $ i = vec_index_impl v i\"", "lemma index_mat_code[code]: \"(mat_impl m) $$ ij = (index_mat_impl m ij :: 'a)\"", "lemma mat_of_rows_list_impl: \"mat_of_rows_list_impl n rs = Some A \\<Longrightarrow> mat_impl A = mat_of_rows_list n rs\"", "lemma mat_of_rows_list_code[code]: \"mat_of_rows_list nc vs = \n  (case mat_of_rows_list_impl nc vs of Some A \\<Rightarrow> mat_impl A \n  | None \\<Rightarrow> mat_of_rows nc (map (\\<lambda> v. vec nc (nth v)) vs))\"", "lemma dim_vec_code[code]: \"dim_vec (vec_impl v) = dim_vec_impl v\"", "lemma dim_row_code[code]: \"dim_row (mat_impl m) = dim_row_impl m\"", "lemma dim_col_code[code]: \"dim_col (mat_impl m) = dim_col_impl m\"", "lemma veq_equal_code[code]: \"HOL.equal (vec_impl (v1 :: 'a vec_impl)) (vec_impl v2) = vec_equal_impl v1 v2\"", "lemma mat_equal_code[code]: \"HOL.equal (mat_impl (m1 :: 'a mat_impl)) (mat_impl m2) = mat_equal_impl m1 m2\"", "lemma carrier_mat_code[code]: \"carrier_mat nr nc = Collect_set (\\<lambda> A. dim_row A = nr \\<and> dim_col A = nc)\"", "lemma carrier_vec_code[code]: \"carrier_vec n = Collect_set (\\<lambda> v. dim_vec v = n)\""], "translations": [["", "lemma vec_code[code]: \"vec n f = vec_impl (vec_of_fun n f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n f = vec_impl (vec_of_fun n f)", "by (transfer, auto simp: mk_vec_def)"], ["", "lemma mat_code[code]: \"mat nr nc f = mat_impl (mat_of_fun nr nc f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat nr nc f = mat_impl (mat_of_fun nr nc f)", "by (transfer, auto simp: mk_mat_def, intro ext, clarsimp, \n  auto intro: undef_cong_mat)"], ["", "lemma vec_of_list[code]: \"vec_of_list v = vec_impl (vec_of_list_impl v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_list v = vec_impl (vec_of_list_impl v)", "by (transfer, auto simp: mk_vec_def)"], ["", "lemma list_of_vec_code[code]: \"list_of_vec (vec_impl v) = list_of_vec_impl v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec (vec_impl v) = list_of_vec_impl v", "by (transfer, auto simp: mk_vec_def, case_tac b, auto intro: nth_equalityI)"], ["", "lemma empty_nth: \"\\<not> i < length x \\<Longrightarrow> x ! i = [] ! (i - length x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow> x ! i = [] ! (i - length x)", "by (metis append_Nil2 nth_append)"], ["", "lemma undef_vec: \"\\<not> i < length x \\<Longrightarrow> undef_vec (i - length x) = x ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow> undef_vec (i - length x) = x ! i", "unfolding undef_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> i < length x \\<Longrightarrow> [] ! (i - length x) = x ! i", "by (rule empty_nth[symmetric])"], ["", "lemma vec_index_code[code]: \"(vec_impl v) $ i = vec_index_impl v i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_impl v $ i = vec_index_impl v i", "by (transfer, auto simp: mk_vec_def, case_tac b, auto simp: undef_vec)"], ["", "lemma index_mat_code[code]: \"(mat_impl m) $$ ij = (index_mat_impl m ij :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_impl m $$ ij = index_mat_impl m ij", "proof (transfer, unfold o_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba.\n       IArray.all (\\<lambda>r. IArray.length r = aa) b \\<Longrightarrow>\n       snd (snd (IArray.length b, aa,\n                 mk_mat (IArray.length b) aa\n                  (\\<lambda>(i, y). b !! i !! y)))\n        (ab, ba) =\n       (if ab < IArray.length b then b !! ab !! ba\n        else IArray ([] ! (ab - IArray.length b)) !! ba)", "fix m :: \"'a iarray iarray\" and i j nc"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba.\n       IArray.all (\\<lambda>r. IArray.length r = aa) b \\<Longrightarrow>\n       snd (snd (IArray.length b, aa,\n                 mk_mat (IArray.length b) aa\n                  (\\<lambda>(i, y). b !! i !! y)))\n        (ab, ba) =\n       (if ab < IArray.length b then b !! ab !! ba\n        else IArray ([] ! (ab - IArray.length b)) !! ba)", "assume all: \"IArray.all (\\<lambda>r. IArray.length r = nc) m\""], ["proof (state)\nthis:\n  IArray.all (\\<lambda>r. IArray.length r = nc) m\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba.\n       IArray.all (\\<lambda>r. IArray.length r = aa) b \\<Longrightarrow>\n       snd (snd (IArray.length b, aa,\n                 mk_mat (IArray.length b) aa\n                  (\\<lambda>(i, y). b !! i !! y)))\n        (ab, ba) =\n       (if ab < IArray.length b then b !! ab !! ba\n        else IArray ([] ! (ab - IArray.length b)) !! ba)", "obtain mm where m: \"m = IArray mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mm. m = IArray mm \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m)"], ["proof (state)\nthis:\n  m = IArray mm\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba.\n       IArray.all (\\<lambda>r. IArray.length r = aa) b \\<Longrightarrow>\n       snd (snd (IArray.length b, aa,\n                 mk_mat (IArray.length b) aa\n                  (\\<lambda>(i, y). b !! i !! y)))\n        (ab, ba) =\n       (if ab < IArray.length b then b !! ab !! ba\n        else IArray ([] ! (ab - IArray.length b)) !! ba)", "with all"], ["proof (chain)\npicking this:\n  IArray.all (\\<lambda>r. IArray.length r = nc) m\n  m = IArray mm", "have all: \"\\<And> v. v \\<in> set mm \\<Longrightarrow> IArray.length v = nc\""], ["proof (prove)\nusing this:\n  IArray.all (\\<lambda>r. IArray.length r = nc) m\n  m = IArray mm\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> set mm \\<Longrightarrow> IArray.length v = nc", "by auto"], ["proof (state)\nthis:\n  ?v \\<in> set mm \\<Longrightarrow> IArray.length ?v = nc\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba.\n       IArray.all (\\<lambda>r. IArray.length r = aa) b \\<Longrightarrow>\n       snd (snd (IArray.length b, aa,\n                 mk_mat (IArray.length b) aa\n                  (\\<lambda>(i, y). b !! i !! y)))\n        (ab, ba) =\n       (if ab < IArray.length b then b !! ab !! ba\n        else IArray ([] ! (ab - IArray.length b)) !! ba)", "show \"snd (snd (IArray.length m, nc, mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y))) (i, j) =\n     (if i < IArray.length m then m !! i !! j\n        else IArray ([] ! (i - IArray.length m)) !! j)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "proof (cases \"i < length mm\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)\n 2. \\<not> i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "case False"], ["proof (state)\nthis:\n  \\<not> i < length mm\n\ngoal (2 subgoals):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)\n 2. \\<not> i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "hence \"\\<And> f. \\<not> i < length (map f [0..<length mm])\""], ["proof (prove)\nusing this:\n  \\<not> i < length mm\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<not> i < length (map f [0..<length mm])", "by simp"], ["proof (state)\nthis:\n  \\<not> i < length (map ?f [0..<length mm])\n\ngoal (2 subgoals):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)\n 2. \\<not> i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "note [simp] = empty_nth[OF this]"], ["proof (state)\nthis:\n  map ?f1 [0..<length mm] ! i = [] ! (i - length (map ?f1 [0..<length mm]))\n\ngoal (2 subgoals):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)\n 2. \\<not> i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "have \"?l = [] ! (i - length mm) ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    [] ! (i - length mm) ! j", "using False"], ["proof (prove)\nusing this:\n  \\<not> i < length mm\n\ngoal (1 subgoal):\n 1. snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    [] ! (i - length mm) ! j", "unfolding m mk_mat_def undef_mat_def"], ["proof (prove)\nusing this:\n  \\<not> i < length mm\n\ngoal (1 subgoal):\n 1. snd (snd (IArray.length (IArray mm), nc,\n              \\<lambda>(i, j).\n                 if i < IArray.length (IArray mm) \\<and> j < nc\n                 then case (i, j) of\n                      (i, x) \\<Rightarrow> IArray mm !! i !! x\n                 else case (i, j) of\n                      (i, j) \\<Rightarrow>\n                        map (\\<lambda>i.\n                                map (\\<lambda>j.\n  case (i, j) of (i, x) \\<Rightarrow> IArray mm !! i !! x)\n                                 [0..<nc])\n                         [0..<IArray.length (IArray mm)] !\n                        i !\n                        j))\n     (i, j) =\n    [] ! (i - length mm) ! j", "by simp"], ["proof (state)\nthis:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  [] ! (i - length mm) ! j\n\ngoal (2 subgoals):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)\n 2. \\<not> i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "also"], ["proof (state)\nthis:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  [] ! (i - length mm) ! j\n\ngoal (2 subgoals):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)\n 2. \\<not> i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] ! (i - length mm) ! j =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] ! (i - length mm) ! j =\n    (if i < IArray.length (IArray mm) then IArray mm !! i !! j\n     else IArray ([] ! (i - IArray.length (IArray mm))) !! j)", "by (simp add: False empty_nth[OF False])"], ["proof (state)\nthis:\n  [] ! (i - length mm) ! j =\n  (if i < IArray.length m then m !! i !! j\n   else IArray ([] ! (i - IArray.length m)) !! j)\n\ngoal (2 subgoals):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)\n 2. \\<not> i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "finally"], ["proof (chain)\npicking this:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  (if i < IArray.length m then m !! i !! j\n   else IArray ([] ! (i - IArray.length m)) !! j)", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  (if i < IArray.length m then m !! i !! j\n   else IArray ([] ! (i - IArray.length m)) !! j)\n\ngoal (1 subgoal):\n 1. snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "."], ["proof (state)\nthis:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  (if i < IArray.length m then m !! i !! j\n   else IArray ([] ! (i - IArray.length m)) !! j)\n\ngoal (1 subgoal):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "case True"], ["proof (state)\nthis:\n  i < length mm\n\ngoal (1 subgoal):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "obtain v where mm: \"mm ! i = IArray v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. mm ! i = IArray v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"mm ! i\")"], ["proof (state)\nthis:\n  mm ! i = IArray v\n\ngoal (1 subgoal):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "with True all[of \"mm ! i\"]"], ["proof (chain)\npicking this:\n  i < length mm\n  mm ! i \\<in> set mm \\<Longrightarrow> IArray.length (mm ! i) = nc\n  mm ! i = IArray v", "have len: \"length v = nc\""], ["proof (prove)\nusing this:\n  i < length mm\n  mm ! i \\<in> set mm \\<Longrightarrow> IArray.length (mm ! i) = nc\n  mm ! i = IArray v\n\ngoal (1 subgoal):\n 1. length v = nc", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  i < length mm\n  mm ! i \\<in> {mm ! i |i. i < length mm} \\<Longrightarrow>\n  IArray.length (mm ! i) = nc\n  mm ! i = IArray v\n\ngoal (1 subgoal):\n 1. length v = nc", "by force"], ["proof (state)\nthis:\n  length v = nc\n\ngoal (1 subgoal):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "from mm True"], ["proof (chain)\npicking this:\n  mm ! i = IArray v\n  i < length mm", "have \"?l = map ((!) v) [0..<nc] ! j\" (is \"_ = ?m\")"], ["proof (prove)\nusing this:\n  mm ! i = IArray v\n  i < length mm\n\ngoal (1 subgoal):\n 1. snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    map ((!) v) [0..<nc] ! j", "unfolding m mk_mat_def undef_mat_def"], ["proof (prove)\nusing this:\n  mm ! i = IArray v\n  i < length mm\n\ngoal (1 subgoal):\n 1. snd (snd (IArray.length (IArray mm), nc,\n              \\<lambda>(i, j).\n                 if i < IArray.length (IArray mm) \\<and> j < nc\n                 then case (i, j) of\n                      (i, x) \\<Rightarrow> IArray mm !! i !! x\n                 else case (i, j) of\n                      (i, j) \\<Rightarrow>\n                        map (\\<lambda>i.\n                                map (\\<lambda>j.\n  case (i, j) of (i, x) \\<Rightarrow> IArray mm !! i !! x)\n                                 [0..<nc])\n                         [0..<IArray.length (IArray mm)] !\n                        i !\n                        j))\n     (i, j) =\n    map ((!) v) [0..<nc] ! j", "by simp"], ["proof (state)\nthis:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  map ((!) v) [0..<nc] ! j\n\ngoal (1 subgoal):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "also"], ["proof (state)\nthis:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  map ((!) v) [0..<nc] ! j\n\ngoal (1 subgoal):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "have \"?m = m !! i !! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) v) [0..<nc] ! j = m !! i !! j", "proof (cases \"j < length v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < length v \\<Longrightarrow> map ((!) v) [0..<nc] ! j = m !! i !! j\n 2. \\<not> j < length v \\<Longrightarrow>\n    map ((!) v) [0..<nc] ! j = m !! i !! j", "case True"], ["proof (state)\nthis:\n  j < length v\n\ngoal (2 subgoals):\n 1. j < length v \\<Longrightarrow> map ((!) v) [0..<nc] ! j = m !! i !! j\n 2. \\<not> j < length v \\<Longrightarrow>\n    map ((!) v) [0..<nc] ! j = m !! i !! j", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < length v\n\ngoal (1 subgoal):\n 1. map ((!) v) [0..<nc] ! j = m !! i !! j", "unfolding m"], ["proof (prove)\nusing this:\n  j < length v\n\ngoal (1 subgoal):\n 1. map ((!) v) [0..<nc] ! j = IArray mm !! i !! j", "using mm len"], ["proof (prove)\nusing this:\n  j < length v\n  mm ! i = IArray v\n  length v = nc\n\ngoal (1 subgoal):\n 1. map ((!) v) [0..<nc] ! j = IArray mm !! i !! j", "by auto"], ["proof (state)\nthis:\n  map ((!) v) [0..<nc] ! j = m !! i !! j\n\ngoal (1 subgoal):\n 1. \\<not> j < length v \\<Longrightarrow>\n    map ((!) v) [0..<nc] ! j = m !! i !! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < length v \\<Longrightarrow>\n    map ((!) v) [0..<nc] ! j = m !! i !! j", "case False"], ["proof (state)\nthis:\n  \\<not> j < length v\n\ngoal (1 subgoal):\n 1. \\<not> j < length v \\<Longrightarrow>\n    map ((!) v) [0..<nc] ! j = m !! i !! j", "hence j: \"\\<not> j < length (map ((!) v) [0..<length v])\""], ["proof (prove)\nusing this:\n  \\<not> j < length v\n\ngoal (1 subgoal):\n 1. \\<not> j < length (map ((!) v) [0..<length v])", "by simp"], ["proof (state)\nthis:\n  \\<not> j < length (map ((!) v) [0..<length v])\n\ngoal (1 subgoal):\n 1. \\<not> j < length v \\<Longrightarrow>\n    map ((!) v) [0..<nc] ! j = m !! i !! j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) v) [0..<nc] ! j = m !! i !! j", "unfolding m"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) v) [0..<nc] ! j = IArray mm !! i !! j", "using mm len"], ["proof (prove)\nusing this:\n  mm ! i = IArray v\n  length v = nc\n\ngoal (1 subgoal):\n 1. map ((!) v) [0..<nc] ! j = IArray mm !! i !! j", "by (auto simp: empty_nth[OF j] empty_nth[OF False])"], ["proof (state)\nthis:\n  map ((!) v) [0..<nc] ! j = m !! i !! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map ((!) v) [0..<nc] ! j = m !! i !! j\n\ngoal (1 subgoal):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "also"], ["proof (state)\nthis:\n  map ((!) v) [0..<nc] ! j = m !! i !! j\n\ngoal (1 subgoal):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m !! i !! j =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "using True m"], ["proof (prove)\nusing this:\n  i < length mm\n  m = IArray mm\n\ngoal (1 subgoal):\n 1. m !! i !! j =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "by simp"], ["proof (state)\nthis:\n  m !! i !! j =\n  (if i < IArray.length m then m !! i !! j\n   else IArray ([] ! (i - IArray.length m)) !! j)\n\ngoal (1 subgoal):\n 1. i < length mm \\<Longrightarrow>\n    snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "finally"], ["proof (chain)\npicking this:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  (if i < IArray.length m then m !! i !! j\n   else IArray ([] ! (i - IArray.length m)) !! j)", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  (if i < IArray.length m then m !! i !! j\n   else IArray ([] ! (i - IArray.length m)) !! j)\n\ngoal (1 subgoal):\n 1. snd (snd (IArray.length m, nc,\n              mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n     (i, j) =\n    (if i < IArray.length m then m !! i !! j\n     else IArray ([] ! (i - IArray.length m)) !! j)", "."], ["proof (state)\nthis:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  (if i < IArray.length m then m !! i !! j\n   else IArray ([] ! (i - IArray.length m)) !! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (snd (IArray.length m, nc,\n            mk_mat (IArray.length m) nc (\\<lambda>(i, y). m !! i !! y)))\n   (i, j) =\n  (if i < IArray.length m then m !! i !! j\n   else IArray ([] ! (i - IArray.length m)) !! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition (code_dt) mat_of_rows_list_impl :: \"nat \\<Rightarrow> 'a list list \\<Rightarrow> 'a mat_impl option\" is\n  \"\\<lambda> n rows. if list_all (\\<lambda> r. length r = n) rows then Some (length rows, n, IArray (map IArray rows)) \n  else None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat list.\n       pred_option\n        (\\<lambda>x.\n            x \\<in> {(nr, nc, m).\n                     IArray.length m = nr \\<and>\n                     IArray.all (\\<lambda>r. IArray.length r = nc) m})\n        (if list_all (\\<lambda>r. length r = nat) list\n         then Some (length list, nat, IArray (map IArray list)) else None)", "by (auto split: if_splits simp: list_all_iff)"], ["", "lemma mat_of_rows_list_impl: \"mat_of_rows_list_impl n rs = Some A \\<Longrightarrow> mat_impl A = mat_of_rows_list n rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list_impl n rs = Some A \\<Longrightarrow>\n    mat_impl A = mat_of_rows_list n rs", "unfolding mat_of_rows_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list_impl n rs = Some A \\<Longrightarrow>\n    mat_impl A = mat (length rs) n (\\<lambda>(i, y). rs ! i ! y)", "by (transfer, auto split: if_splits simp: list_all_iff intro!: cong_mk_mat)"], ["", "lemma mat_of_rows_list_code[code]: \"mat_of_rows_list nc vs = \n  (case mat_of_rows_list_impl nc vs of Some A \\<Rightarrow> mat_impl A \n  | None \\<Rightarrow> mat_of_rows nc (map (\\<lambda> v. vec nc (nth v)) vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list nc vs =\n    (case mat_of_rows_list_impl nc vs of\n     None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n     | Some A \\<Rightarrow> mat_impl A)", "proof (cases \"mat_of_rows_list_impl nc vs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mat_of_rows_list_impl nc vs = None \\<Longrightarrow>\n    mat_of_rows_list nc vs =\n    (case mat_of_rows_list_impl nc vs of\n     None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n     | Some A \\<Rightarrow> mat_impl A)\n 2. \\<And>a.\n       mat_of_rows_list_impl nc vs = Some a \\<Longrightarrow>\n       mat_of_rows_list nc vs =\n       (case mat_of_rows_list_impl nc vs of\n        None \\<Rightarrow>\n          mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n        | Some A \\<Rightarrow> mat_impl A)", "case (Some A)"], ["proof (state)\nthis:\n  mat_of_rows_list_impl nc vs = Some A\n\ngoal (2 subgoals):\n 1. mat_of_rows_list_impl nc vs = None \\<Longrightarrow>\n    mat_of_rows_list nc vs =\n    (case mat_of_rows_list_impl nc vs of\n     None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n     | Some A \\<Rightarrow> mat_impl A)\n 2. \\<And>a.\n       mat_of_rows_list_impl nc vs = Some a \\<Longrightarrow>\n       mat_of_rows_list nc vs =\n       (case mat_of_rows_list_impl nc vs of\n        None \\<Rightarrow>\n          mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n        | Some A \\<Rightarrow> mat_impl A)", "from mat_of_rows_list_impl[OF this]"], ["proof (chain)\npicking this:\n  mat_impl A = mat_of_rows_list nc vs", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_impl A = mat_of_rows_list nc vs\n\ngoal (1 subgoal):\n 1. mat_of_rows_list nc vs =\n    (case mat_of_rows_list_impl nc vs of\n     None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n     | Some A \\<Rightarrow> mat_impl A)", "unfolding Some"], ["proof (prove)\nusing this:\n  mat_impl A = mat_of_rows_list nc vs\n\ngoal (1 subgoal):\n 1. mat_of_rows_list nc vs =\n    (case Some A of\n     None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n     | Some A \\<Rightarrow> mat_impl A)", "by simp"], ["proof (state)\nthis:\n  mat_of_rows_list nc vs =\n  (case mat_of_rows_list_impl nc vs of\n   None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n   | Some A \\<Rightarrow> mat_impl A)\n\ngoal (1 subgoal):\n 1. mat_of_rows_list_impl nc vs = None \\<Longrightarrow>\n    mat_of_rows_list nc vs =\n    (case mat_of_rows_list_impl nc vs of\n     None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n     | Some A \\<Rightarrow> mat_impl A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_rows_list_impl nc vs = None \\<Longrightarrow>\n    mat_of_rows_list nc vs =\n    (case mat_of_rows_list_impl nc vs of\n     None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n     | Some A \\<Rightarrow> mat_impl A)", "case None"], ["proof (state)\nthis:\n  mat_of_rows_list_impl nc vs = None\n\ngoal (1 subgoal):\n 1. mat_of_rows_list_impl nc vs = None \\<Longrightarrow>\n    mat_of_rows_list nc vs =\n    (case mat_of_rows_list_impl nc vs of\n     None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n     | Some A \\<Rightarrow> mat_impl A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list nc vs =\n    (case mat_of_rows_list_impl nc vs of\n     None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n     | Some A \\<Rightarrow> mat_impl A)", "unfolding None"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows_list nc vs =\n    (case None of\n     None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n     | Some A \\<Rightarrow> mat_impl A)", "unfolding mat_of_rows_list_def mat_of_rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length vs) nc (\\<lambda>(i, y). vs ! i ! y) =\n    (case None of\n     None \\<Rightarrow>\n       mat (length (map (\\<lambda>v. vec nc ((!) v)) vs)) nc\n        (\\<lambda>(i, y). map (\\<lambda>v. vec nc ((!) v)) vs ! i $ y)\n     | Some A \\<Rightarrow> mat_impl A)", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  mat_of_rows_list nc vs =\n  (case mat_of_rows_list_impl nc vs of\n   None \\<Rightarrow> mat_of_rows nc (map (\\<lambda>v. vec nc ((!) v)) vs)\n   | Some A \\<Rightarrow> mat_impl A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_vec_code[code]: \"dim_vec (vec_impl v) = dim_vec_impl v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_impl v) = dim_vec_impl v", "by (transfer, auto)"], ["", "lemma dim_row_code[code]: \"dim_row (mat_impl m) = dim_row_impl m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat_impl m) = dim_row_impl m", "by (transfer, auto)"], ["", "lemma dim_col_code[code]: \"dim_col (mat_impl m) = dim_col_impl m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (mat_impl m) = dim_col_impl m", "by (transfer, auto)"], ["", "instantiation vec :: (type)equal\nbegin"], ["", "definition \"(equal_vec :: ('a vec \\<Rightarrow> 'a vec \\<Rightarrow> bool)) = (=)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a vec, equal_class)", "by (intro_classes, auto simp: equal_vec_def)"], ["", "end"], ["", "instantiation mat :: (type)equal\nbegin"], ["", "definition \"(equal_mat :: ('a mat \\<Rightarrow> 'a mat \\<Rightarrow> bool)) = (=)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mat, equal_class)", "by (intro_classes, auto simp: equal_mat_def)"], ["", "end"], ["", "lemma veq_equal_code[code]: \"HOL.equal (vec_impl (v1 :: 'a vec_impl)) (vec_impl v2) = vec_equal_impl v1 v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (vec_impl v1) (vec_impl v2) = vec_equal_impl v1 v2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equal_class.equal (vec_impl v1) (vec_impl v2) = vec_equal_impl v1 v2", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. equal_class.equal (vec_impl v1) (vec_impl v2) = vec_equal_impl v1 v2", "fix x1 x2 :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. equal_class.equal (vec_impl v1) (vec_impl v2) = vec_equal_impl v1 v2", "assume len: \"length x1 = length x2\"\n       and index: \"(\\<lambda>i. if i < length x2 then IArray x1 !! i else undef_vec (i - length (IArray.list_of (IArray x1)))) =\n            (\\<lambda>i. if i < length x2 then IArray x2 !! i else undef_vec (i - length (IArray.list_of (IArray x2))))\""], ["proof (state)\nthis:\n  length x1 = length x2\n  (\\<lambda>i.\n      if i < length x2 then IArray x1 !! i\n      else undef_vec (i - length (IArray.list_of (IArray x1)))) =\n  (\\<lambda>i.\n      if i < length x2 then IArray x2 !! i\n      else undef_vec (i - length (IArray.list_of (IArray x2))))\n\ngoal (1 subgoal):\n 1. equal_class.equal (vec_impl v1) (vec_impl v2) = vec_equal_impl v1 v2", "have \"x1 = x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = x2", "proof (intro nth_equalityI[OF len])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "assume \"i < length x1\""], ["proof (state)\nthis:\n  i < length x1\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "with fun_cong[OF index, of i] len"], ["proof (chain)\npicking this:\n  (if i < length x2 then IArray x1 !! i\n   else undef_vec (i - length (IArray.list_of (IArray x1)))) =\n  (if i < length x2 then IArray x2 !! i\n   else undef_vec (i - length (IArray.list_of (IArray x2))))\n  length x1 = length x2\n  i < length x1", "show \"x1 ! i = x2 ! i\""], ["proof (prove)\nusing this:\n  (if i < length x2 then IArray x1 !! i\n   else undef_vec (i - length (IArray.list_of (IArray x1)))) =\n  (if i < length x2 then IArray x2 !! i\n   else undef_vec (i - length (IArray.list_of (IArray x2))))\n  length x1 = length x2\n  i < length x1\n\ngoal (1 subgoal):\n 1. x1 ! i = x2 ! i", "by simp"], ["proof (state)\nthis:\n  x1 ! i = x2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x1 = x2\n\ngoal (1 subgoal):\n 1. equal_class.equal (vec_impl v1) (vec_impl v2) = vec_equal_impl v1 v2", "}"], ["proof (state)\nthis:\n  \\<lbrakk>length ?x1.2 = length ?x2.2;\n   (\\<lambda>i.\n       if i < length ?x2.2 then IArray ?x1.2 !! i\n       else undef_vec (i - length (IArray.list_of (IArray ?x1.2)))) =\n   (\\<lambda>i.\n       if i < length ?x2.2 then IArray ?x2.2 !! i\n       else undef_vec (i - length (IArray.list_of (IArray ?x2.2))))\\<rbrakk>\n  \\<Longrightarrow> ?x1.2 = ?x2.2\n\ngoal (1 subgoal):\n 1. equal_class.equal (vec_impl v1) (vec_impl v2) = vec_equal_impl v1 v2", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>length ?x1.2 = length ?x2.2;\n   (\\<lambda>i.\n       if i < length ?x2.2 then IArray ?x1.2 !! i\n       else undef_vec (i - length (IArray.list_of (IArray ?x1.2)))) =\n   (\\<lambda>i.\n       if i < length ?x2.2 then IArray ?x2.2 !! i\n       else undef_vec (i - length (IArray.list_of (IArray ?x2.2))))\\<rbrakk>\n  \\<Longrightarrow> ?x1.2 = ?x2.2\n\ngoal (1 subgoal):\n 1. equal_class.equal (vec_impl v1) (vec_impl v2) = vec_equal_impl v1 v2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (vec_impl v1) (vec_impl v2) = vec_equal_impl v1 v2", "unfolding equal_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_impl v1 = vec_impl v2) = vec_equal_impl v1 v2", "by (transfer, insert *, auto simp: mk_vec_def, case_tac b, case_tac ba, auto)"], ["proof (state)\nthis:\n  equal_class.equal (vec_impl v1) (vec_impl v2) = vec_equal_impl v1 v2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_equal_code[code]: \"HOL.equal (mat_impl (m1 :: 'a mat_impl)) (mat_impl m2) = mat_equal_impl m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (mat_impl m1) (mat_impl m2) = mat_equal_impl m1 m2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equal_class.equal (mat_impl m1) (mat_impl m2) = mat_equal_impl m1 m2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (mat_impl m1) (mat_impl m2) = mat_equal_impl m1 m2", "unfolding equal_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_impl m1 = mat_impl m2) = mat_equal_impl m1 m2", "proof (transfer, auto, case_tac b, case_tac ba, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ac x xa.\n       \\<lbrakk>\\<forall>a\\<in>set x. length (IArray.list_of a) = ac;\n        \\<forall>a\\<in>set xa. length (IArray.list_of a) = ac;\n        length x = length xa;\n        mk_mat (length xa) ac (\\<lambda>(i, y). x ! i !! y) =\n        mk_mat (length xa) ac (\\<lambda>(i, y). xa ! i !! y)\\<rbrakk>\n       \\<Longrightarrow> x = xa", "fix x1 x2 :: \"'a iarray list\" and nc"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ac x xa.\n       \\<lbrakk>\\<forall>a\\<in>set x. length (IArray.list_of a) = ac;\n        \\<forall>a\\<in>set xa. length (IArray.list_of a) = ac;\n        length x = length xa;\n        mk_mat (length xa) ac (\\<lambda>(i, y). x ! i !! y) =\n        mk_mat (length xa) ac (\\<lambda>(i, y). xa ! i !! y)\\<rbrakk>\n       \\<Longrightarrow> x = xa", "assume len: \"\\<forall>r\\<in>set x1. length (IArray.list_of r) = nc\"\n      \"\\<forall>r\\<in>set x2. length (IArray.list_of r) = nc\"\n      \"length x1 = length x2\"\n    and index: \"mk_mat (length x2) nc (\\<lambda>(i, j). x1 ! i !! j) = mk_mat (length x2) nc (\\<lambda>(i, j). x2 ! i !! j)\""], ["proof (state)\nthis:\n  \\<forall>r\\<in>set x1. length (IArray.list_of r) = nc\n  \\<forall>r\\<in>set x2. length (IArray.list_of r) = nc\n  length x1 = length x2\n  mk_mat (length x2) nc (\\<lambda>(i, j). x1 ! i !! j) =\n  mk_mat (length x2) nc (\\<lambda>(i, j). x2 ! i !! j)\n\ngoal (1 subgoal):\n 1. \\<And>ac x xa.\n       \\<lbrakk>\\<forall>a\\<in>set x. length (IArray.list_of a) = ac;\n        \\<forall>a\\<in>set xa. length (IArray.list_of a) = ac;\n        length x = length xa;\n        mk_mat (length xa) ac (\\<lambda>(i, y). x ! i !! y) =\n        mk_mat (length xa) ac (\\<lambda>(i, y). xa ! i !! y)\\<rbrakk>\n       \\<Longrightarrow> x = xa", "show \"x1 = x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 = x2", "proof (rule nth_equalityI[OF len(3)])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "assume i: \"i < length x1\""], ["proof (state)\nthis:\n  i < length x1\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "obtain ia1 where 1: \"x1 ! i = IArray ia1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ia1.\n        x1 ! i = IArray ia1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"x1 ! i\")"], ["proof (state)\nthis:\n  x1 ! i = IArray ia1\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "obtain ia2 where 2: \"x2 ! i = IArray ia2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ia2.\n        x2 ! i = IArray ia2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"x2 ! i\")"], ["proof (state)\nthis:\n  x2 ! i = IArray ia2\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "from i 1 len(1)"], ["proof (chain)\npicking this:\n  i < length x1\n  x1 ! i = IArray ia1\n  \\<forall>r\\<in>set x1. length (IArray.list_of r) = nc", "have l1: \"length ia1 = nc\""], ["proof (prove)\nusing this:\n  i < length x1\n  x1 ! i = IArray ia1\n  \\<forall>r\\<in>set x1. length (IArray.list_of r) = nc\n\ngoal (1 subgoal):\n 1. length ia1 = nc", "using nth_mem"], ["proof (prove)\nusing this:\n  i < length x1\n  x1 ! i = IArray ia1\n  \\<forall>r\\<in>set x1. length (IArray.list_of r) = nc\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. length ia1 = nc", "by fastforce"], ["proof (state)\nthis:\n  length ia1 = nc\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "from i 2 len(2-3)"], ["proof (chain)\npicking this:\n  i < length x1\n  x2 ! i = IArray ia2\n  \\<forall>r\\<in>set x2. length (IArray.list_of r) = nc\n  length x1 = length x2", "have l2: \"length ia2 = nc\""], ["proof (prove)\nusing this:\n  i < length x1\n  x2 ! i = IArray ia2\n  \\<forall>r\\<in>set x2. length (IArray.list_of r) = nc\n  length x1 = length x2\n\ngoal (1 subgoal):\n 1. length ia2 = nc", "using nth_mem"], ["proof (prove)\nusing this:\n  i < length x1\n  x2 ! i = IArray ia2\n  \\<forall>r\\<in>set x2. length (IArray.list_of r) = nc\n  length x1 = length x2\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. length ia2 = nc", "by fastforce"], ["proof (state)\nthis:\n  length ia2 = nc\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "from l1 l2"], ["proof (chain)\npicking this:\n  length ia1 = nc\n  length ia2 = nc", "have l: \"length ia1 = length ia2\""], ["proof (prove)\nusing this:\n  length ia1 = nc\n  length ia2 = nc\n\ngoal (1 subgoal):\n 1. length ia1 = length ia2", "by simp"], ["proof (state)\nthis:\n  length ia1 = length ia2\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length x1 \\<Longrightarrow> x1 ! i = x2 ! i", "show \"x1 ! i = x2 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 ! i = x2 ! i", "unfolding 1 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray ia1 = IArray ia2", "proof (simp, rule nth_equalityI[OF l])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ia1 \\<Longrightarrow> ia1 ! i = ia2 ! i", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ia1 \\<Longrightarrow> ia1 ! i = ia2 ! i", "assume j: \"j < length ia1\""], ["proof (state)\nthis:\n  j < length ia1\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ia1 \\<Longrightarrow> ia1 ! i = ia2 ! i", "with fun_cong[OF index, of \"(i,j)\"] i len(3)"], ["proof (chain)\npicking this:\n  mk_mat (length x2) nc (\\<lambda>(i, j). x1 ! i !! j) (i, j) =\n  mk_mat (length x2) nc (\\<lambda>(i, j). x2 ! i !! j) (i, j)\n  i < length x1\n  length x1 = length x2\n  j < length ia1", "have \"x1 ! i !! j = x2 ! i !! j\""], ["proof (prove)\nusing this:\n  mk_mat (length x2) nc (\\<lambda>(i, j). x1 ! i !! j) (i, j) =\n  mk_mat (length x2) nc (\\<lambda>(i, j). x2 ! i !! j) (i, j)\n  i < length x1\n  length x1 = length x2\n  j < length ia1\n\ngoal (1 subgoal):\n 1. x1 ! i !! j = x2 ! i !! j", "by (simp add: mk_mat_def l1)"], ["proof (state)\nthis:\n  x1 ! i !! j = x2 ! i !! j\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ia1 \\<Longrightarrow> ia1 ! i = ia2 ! i", "thus \"ia1 ! j = ia2 ! j\""], ["proof (prove)\nusing this:\n  x1 ! i !! j = x2 ! i !! j\n\ngoal (1 subgoal):\n 1. ia1 ! j = ia2 ! j", "unfolding 1 2"], ["proof (prove)\nusing this:\n  IArray ia1 !! j = IArray ia2 !! j\n\ngoal (1 subgoal):\n 1. ia1 ! j = ia2 ! j", "by simp"], ["proof (state)\nthis:\n  ia1 ! j = ia2 ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x1 ! i = x2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x1 = x2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  equal_class.equal (mat_impl m1) (mat_impl m2) = mat_equal_impl m1 m2\n\ngoal:\nNo subgoals!", "qed"], ["", "declare prod.set_conv_list[code del, code_unfold]"], ["", "derive (eq) ceq mat vec"], ["", "derive (no) ccompare mat vec"], ["", "derive (dlist) set_impl mat vec"], ["", "derive (no) cenum mat vec"], ["", "lemma carrier_mat_code[code]: \"carrier_mat nr nc = Collect_set (\\<lambda> A. dim_row A = nr \\<and> dim_col A = nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier_mat nr nc =\n    Collect_set (\\<lambda>A. dim_row A = nr \\<and> dim_col A = nc)", "by auto"], ["", "lemma carrier_vec_code[code]: \"carrier_vec n = Collect_set (\\<lambda> v. dim_vec v = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier_vec n = Collect_set (\\<lambda>v. dim_vec v = n)", "unfolding carrier_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. dim_vec v = n} = Collect_set (\\<lambda>v. dim_vec v = n)", "by auto"], ["", "end"]]}