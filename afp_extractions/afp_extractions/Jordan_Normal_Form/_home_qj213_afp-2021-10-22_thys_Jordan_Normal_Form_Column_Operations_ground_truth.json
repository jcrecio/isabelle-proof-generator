{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Column_Operations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma index_mat_multcol[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> multcol k a A $$ (i,j) = (if k = j then a * A $$ (i,j) else A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> multcol j a A $$ (i,j) = a * A $$ (i,j)\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> k \\<noteq> j \\<Longrightarrow> multcol k a A $$ (i,j) = A $$ (i,j)\"\n  \"dim_row (multcol k a A) = dim_row A\" \"dim_col (multcol k a A) = dim_col A\"", "lemma index_mat_swapcols[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> swapcols k l A $$ (i,j) = (if k = j then A $$ (i,l) else \n    if l = j then A $$ (i,k) else A $$ (i,j))\"\n  \"dim_row (swapcols k l A) = dim_row A\" \"dim_col (swapcols k l A) = dim_col A\"", "lemma index_mat_addcol[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> addcol a k l A $$ (i,j) = (if k = j then \n    a * A $$ (i,l) + A $$ (i,j) else A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> addcol a j l A $$ (i,j) = a * A $$(i,l) + A$$(i,j)\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> k \\<noteq> j \\<Longrightarrow> addcol a k l A $$ (i,j) = A $$(i,j)\"\n  \"dim_row (addcol a k l A) = dim_row A\" \"dim_col (addcol a k l A) = dim_col A\"", "lemma col_addrow: \n  \"l \\<noteq> i \\<Longrightarrow> i < n \\<Longrightarrow> col (addrow_mat n a k l) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> col (addrow_mat n a k l) l = a \\<cdot>\\<^sub>v unit_vec n k + unit_vec n l\"", "lemma col_addcol[simp]:\n  \"k < dim_col A \\<Longrightarrow> l < dim_col A \\<Longrightarrow> col (addcol a k l A) k = a \\<cdot>\\<^sub>v col A l + col A k\"", "lemma addcol_mat: assumes A: \"A \\<in> carrier_mat nr n\" \n  and k: \"k < n\"\n  shows \"addcol (a :: 'a :: comm_semiring_1) l k A = A * addrow_mat n a k l\"", "lemma col_multrow:  \"k \\<noteq> i \\<Longrightarrow> i < n \\<Longrightarrow> col (multrow_mat n k a) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> col (multrow_mat n k a) k = a \\<cdot>\\<^sub>v unit_vec n k\"", "lemma multcol_mat: assumes A: \"(A :: 'a :: comm_ring_1 mat) \\<in> carrier_mat nr n\"\n  shows \"multcol k a A = A * multrow_mat n k a\"", "lemma col_swaprows: \n  \"l < n \\<Longrightarrow> col (swaprows_mat n l l) l = unit_vec n l\"\n  \"i \\<noteq> k \\<Longrightarrow> i \\<noteq> l \\<Longrightarrow> i < n \\<Longrightarrow> col (swaprows_mat n k l) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> col (swaprows_mat n k l) l = unit_vec n k\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> col (swaprows_mat n k l) k = unit_vec n l\"", "lemma swapcols_mat: assumes A: \"A \\<in> carrier_mat nr n\" and k: \"k < n\" \"l < n\"\n  shows \"swapcols k l A = A * swaprows_mat n k l\"", "lemma add_col_sub_row_carrier[simp]: \n  \"dim_row (add_col_sub_row a k l A) = dim_row A\"\n  \"dim_col (add_col_sub_row a k l A) = dim_col A\"\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> add_col_sub_row a k l A \\<in> carrier_mat n n\"", "lemma add_col_sub_index_row[simp]: \n  \"i < dim_row A \\<Longrightarrow> i < dim_col A \\<Longrightarrow> j < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> l < dim_row A \n    \\<Longrightarrow> add_col_sub_row a k l A $$ (i,j) = (if \n      i = k \\<and> j = l then A $$ (i, j) + a * A $$ (i, i) - a * a * A $$ (j, i) - a * A $$ (j, j) else if\n      i = k \\<and> j \\<noteq> l then A $$ (i, j) - a * A $$ (l, j) else if\n      i \\<noteq> k \\<and> j = l then A $$ (i, j) + a * A $$ (i, k) else A $$ (i,j))\"", "lemma mult_col_div_index_row[simp]: \n  \"i < dim_row A \\<Longrightarrow> i < dim_col A \\<Longrightarrow> j < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> a \\<noteq> 0\n    \\<Longrightarrow> mult_col_div_row a k A $$ (i,j) = (if \n      i = k \\<and> j \\<noteq> i then inverse a * A $$ (i, j) else if\n      j = k \\<and> j \\<noteq> i then a * A $$ (i, j) else A $$ (i,j))\"", "lemma mult_col_div_row_carrier[simp]: \n  \"dim_row (mult_col_div_row a k A) = dim_row A\"\n  \"dim_col (mult_col_div_row a k A) = dim_col A\"\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> mult_col_div_row a k A \\<in> carrier_mat n n\"", "lemma swap_cols_rows_carrier[simp]: \n  \"dim_row (swap_cols_rows k l A) = dim_row A\"\n  \"dim_col (swap_cols_rows k l A) = dim_col A\"\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> swap_cols_rows k l A \\<in> carrier_mat n n\"", "lemma swap_cols_rows_index[simp]: \n  \"i < dim_row A \\<Longrightarrow> i < dim_col A \\<Longrightarrow> j < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> a < dim_row A \\<Longrightarrow> b < dim_row A \n    \\<Longrightarrow> swap_cols_rows a b A $$ (i,j) = A $$ (if i = a then b else if i = b then a else i,\n     if j = a then b else if j = b then a else j)\"", "lemma add_col_sub_row_similar: assumes A: \"A \\<in> carrier_mat n n\" and kl: \"k < n\" \"l < n\" \"k \\<noteq> l\"\n  shows \"similar_mat (add_col_sub_row a k l A) (A :: 'a :: comm_ring_1 mat)\"", "lemma mult_col_div_row_similar: assumes A: \"A \\<in> carrier_mat n n\" and ak: \"k < n\" \"a \\<noteq> 0\"\n  shows \"similar_mat (mult_col_div_row a k A) A\"", "lemma swap_cols_rows_similar: assumes A: \"A \\<in> carrier_mat n n\" and kl: \"k < n\" \"l < n\"\n  shows \"similar_mat (swap_cols_rows k l A) A\"", "lemma swapcols_carrier[simp]: \"(swapcols l k A \\<in> carrier_mat n m) = (A \\<in> carrier_mat n m)\"", "lemma swap_row_to_front_result: \"A \\<in> carrier_mat n m \\<Longrightarrow> I < n \\<Longrightarrow> swap_row_to_front A I = \n  mat n m (\\<lambda> (i,j). if i = 0 then A $$ (I,j)\n  else if i \\<le> I then A $$ (i - 1, j) else A $$ (i,j))\"", "lemma swap_col_to_front_result: \"A \\<in> carrier_mat n m \\<Longrightarrow> J < m \\<Longrightarrow> swap_col_to_front A J = \n  mat n m (\\<lambda> (i,j). if j = 0 then A $$ (i,J)\n  else if j \\<le> J then A $$ (i, j-1) else A $$ (i,j))\"", "lemma swapcols_is_transp_swap_rows: assumes A: \"A \\<in> carrier_mat n m\" \"k < m\" \"l < m\"\n  shows \"swapcols k l A = transpose_mat (swaprows k l (transpose_mat A))\""], "translations": [["", "lemma index_mat_multcol[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> multcol k a A $$ (i,j) = (if k = j then a * A $$ (i,j) else A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> multcol j a A $$ (i,j) = a * A $$ (i,j)\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> k \\<noteq> j \\<Longrightarrow> multcol k a A $$ (i,j) = A $$ (i,j)\"\n  \"dim_row (multcol k a A) = dim_row A\" \"dim_col (multcol k a A) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> multcol k a A $$ (i, j) =\n                        (if k = j then a * A $$ (i, j)\n                         else A $$ (i, j))) &&&\n     (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> multcol j a A $$ (i, j) = a * A $$ (i, j))) &&&\n    (\\<lbrakk>i < dim_row A; j < dim_col A; k \\<noteq> j\\<rbrakk>\n     \\<Longrightarrow> multcol k a A $$ (i, j) = A $$ (i, j)) &&&\n    dim_row (multcol k a A) = dim_row A &&&\n    dim_col (multcol k a A) = dim_col A", "unfolding mat_multcol_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                         (\\<lambda>(i, j).\n                             if k = j then a * A $$ (i, j)\n                             else A $$ (i, j)) $$\n                        (i, j) =\n                        (if k = j then a * A $$ (i, j)\n                         else A $$ (i, j))) &&&\n     (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                         (\\<lambda>(i, ja).\n                             if j = ja then a * A $$ (i, ja)\n                             else A $$ (i, ja)) $$\n                        (i, j) =\n                        a * A $$ (i, j))) &&&\n    (\\<lbrakk>i < dim_row A; j < dim_col A; k \\<noteq> j\\<rbrakk>\n     \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                        (\\<lambda>(i, j).\n                            if k = j then a * A $$ (i, j)\n                            else A $$ (i, j)) $$\n                       (i, j) =\n                       A $$ (i, j)) &&&\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j). if k = j then a * A $$ (i, j) else A $$ (i, j))) =\n    dim_row A &&&\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j). if k = j then a * A $$ (i, j) else A $$ (i, j))) =\n    dim_col A", "by auto"], ["", "lemma index_mat_swapcols[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> swapcols k l A $$ (i,j) = (if k = j then A $$ (i,l) else \n    if l = j then A $$ (i,k) else A $$ (i,j))\"\n  \"dim_row (swapcols k l A) = dim_row A\" \"dim_col (swapcols k l A) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n     \\<Longrightarrow> swapcols k l A $$ (i, j) =\n                       (if k = j then A $$ (i, l)\n                        else if l = j then A $$ (i, k)\n                             else A $$ (i, j))) &&&\n    dim_row (swapcols k l A) = dim_row A &&&\n    dim_col (swapcols k l A) = dim_col A", "unfolding mat_swapcols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n     \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                        (\\<lambda>(i, j).\n                            if k = j then A $$ (i, l)\n                            else if l = j then A $$ (i, k)\n                                 else A $$ (i, j)) $$\n                       (i, j) =\n                       (if k = j then A $$ (i, l)\n                        else if l = j then A $$ (i, k)\n                             else A $$ (i, j))) &&&\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if k = j then A $$ (i, l)\n           else if l = j then A $$ (i, k) else A $$ (i, j))) =\n    dim_row A &&&\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if k = j then A $$ (i, l)\n           else if l = j then A $$ (i, k) else A $$ (i, j))) =\n    dim_col A", "by auto"], ["", "lemma index_mat_addcol[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> addcol a k l A $$ (i,j) = (if k = j then \n    a * A $$ (i,l) + A $$ (i,j) else A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> addcol a j l A $$ (i,j) = a * A $$(i,l) + A$$(i,j)\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> k \\<noteq> j \\<Longrightarrow> addcol a k l A $$ (i,j) = A $$(i,j)\"\n  \"dim_row (addcol a k l A) = dim_row A\" \"dim_col (addcol a k l A) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> addcol a k l A $$ (i, j) =\n                        (if k = j then a * A $$ (i, l) + A $$ (i, j)\n                         else A $$ (i, j))) &&&\n     (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> addcol a j l A $$ (i, j) =\n                        a * A $$ (i, l) + A $$ (i, j))) &&&\n    (\\<lbrakk>i < dim_row A; j < dim_col A; k \\<noteq> j\\<rbrakk>\n     \\<Longrightarrow> addcol a k l A $$ (i, j) = A $$ (i, j)) &&&\n    dim_row (addcol a k l A) = dim_row A &&&\n    dim_col (addcol a k l A) = dim_col A", "unfolding mat_addcol_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                         (\\<lambda>(i, j).\n                             if k = j then a * A $$ (i, l) + A $$ (i, j)\n                             else A $$ (i, j)) $$\n                        (i, j) =\n                        (if k = j then a * A $$ (i, l) + A $$ (i, j)\n                         else A $$ (i, j))) &&&\n     (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                         (\\<lambda>(i, ja).\n                             if j = ja then a * A $$ (i, l) + A $$ (i, ja)\n                             else A $$ (i, ja)) $$\n                        (i, j) =\n                        a * A $$ (i, l) + A $$ (i, j))) &&&\n    (\\<lbrakk>i < dim_row A; j < dim_col A; k \\<noteq> j\\<rbrakk>\n     \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                        (\\<lambda>(i, j).\n                            if k = j then a * A $$ (i, l) + A $$ (i, j)\n                            else A $$ (i, j)) $$\n                       (i, j) =\n                       A $$ (i, j)) &&&\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if k = j then a * A $$ (i, l) + A $$ (i, j) else A $$ (i, j))) =\n    dim_row A &&&\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if k = j then a * A $$ (i, l) + A $$ (i, j) else A $$ (i, j))) =\n    dim_col A", "by auto"], ["", "text \\<open>Each column-operation can be seen as a multiplication of \n  an elementary matrix from the right\\<close>"], ["", "lemma col_addrow: \n  \"l \\<noteq> i \\<Longrightarrow> i < n \\<Longrightarrow> col (addrow_mat n a k l) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> col (addrow_mat n a k l) l = a \\<cdot>\\<^sub>v unit_vec n k + unit_vec n l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>l \\<noteq> i; i < n\\<rbrakk>\n     \\<Longrightarrow> col (addrow_mat n a k l) i = unit_vec n i) &&&\n    (\\<lbrakk>k < n; l < n\\<rbrakk>\n     \\<Longrightarrow> col (addrow_mat n a k l) l =\n                       a \\<cdot>\\<^sub>v unit_vec n k + unit_vec n l)", "by (rule eq_vecI, auto)"], ["", "lemma col_addcol[simp]:\n  \"k < dim_col A \\<Longrightarrow> l < dim_col A \\<Longrightarrow> col (addcol a k l A) k = a \\<cdot>\\<^sub>v col A l + col A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < dim_col A; l < dim_col A\\<rbrakk>\n    \\<Longrightarrow> col (addcol a k l A) k =\n                      a \\<cdot>\\<^sub>v col A l + col A k", "by (rule eq_vecI;simp)"], ["", "lemma addcol_mat: assumes A: \"A \\<in> carrier_mat nr n\" \n  and k: \"k < n\"\n  shows \"addcol (a :: 'a :: comm_semiring_1) l k A = A * addrow_mat n a k l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addcol a l k A = A * addrow_mat n a k l", "by (rule eq_matI, insert A k, auto simp: col_addrow\n  scalar_prod_add_distrib[of _ n] scalar_prod_smult_distrib[of _ n])"], ["", "lemma col_multrow:  \"k \\<noteq> i \\<Longrightarrow> i < n \\<Longrightarrow> col (multrow_mat n k a) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> col (multrow_mat n k a) k = a \\<cdot>\\<^sub>v unit_vec n k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>k \\<noteq> i; i < n\\<rbrakk>\n     \\<Longrightarrow> col (multrow_mat n k a) i = unit_vec n i) &&&\n    (k < n \\<Longrightarrow>\n     col (multrow_mat n k a) k = a \\<cdot>\\<^sub>v unit_vec n k)", "by (rule eq_vecI, auto)"], ["", "lemma multcol_mat: assumes A: \"(A :: 'a :: comm_ring_1 mat) \\<in> carrier_mat nr n\"\n  shows \"multcol k a A = A * multrow_mat n k a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multcol k a A = A * multrow_mat n k a", "by (rule eq_matI, insert A, auto simp: col_multrow smult_scalar_prod_distrib[of _ n])"], ["", "lemma col_swaprows: \n  \"l < n \\<Longrightarrow> col (swaprows_mat n l l) l = unit_vec n l\"\n  \"i \\<noteq> k \\<Longrightarrow> i \\<noteq> l \\<Longrightarrow> i < n \\<Longrightarrow> col (swaprows_mat n k l) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> col (swaprows_mat n k l) l = unit_vec n k\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> col (swaprows_mat n k l) k = unit_vec n l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l < n \\<Longrightarrow> col (swaprows_mat n l l) l = unit_vec n l) &&&\n     (\\<lbrakk>i \\<noteq> k; i \\<noteq> l; i < n\\<rbrakk>\n      \\<Longrightarrow> col (swaprows_mat n k l) i = unit_vec n i)) &&&\n    (\\<lbrakk>k < n; l < n\\<rbrakk>\n     \\<Longrightarrow> col (swaprows_mat n k l) l = unit_vec n k) &&&\n    (\\<lbrakk>k < n; l < n\\<rbrakk>\n     \\<Longrightarrow> col (swaprows_mat n k l) k = unit_vec n l)", "by (rule eq_vecI, auto)"], ["", "lemma swapcols_mat: assumes A: \"A \\<in> carrier_mat nr n\" and k: \"k < n\" \"l < n\"\n  shows \"swapcols k l A = A * swaprows_mat n k l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swapcols k l A = A * swaprows_mat n k l", "by (rule eq_matI, insert A k, auto simp: col_swaprows)"], ["", "text \\<open>Combining row and column-operations yields similarity transformations.\\<close>"], ["", "definition add_col_sub_row :: \"'a :: ring_1 \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a mat \\<Rightarrow> 'a mat\"  where\n  \"add_col_sub_row a k l A = addrow (- a) k l (addcol a l k A)\""], ["", "definition mult_col_div_row :: \"'a :: field \\<Rightarrow> nat \\<Rightarrow> 'a mat \\<Rightarrow> 'a mat\" where\n  \"mult_col_div_row a k A = multrow k (inverse a) (multcol k a A)\""], ["", "definition swap_cols_rows :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a mat \\<Rightarrow> 'a mat\" where\n  \"swap_cols_rows k l A = swaprows k l (swapcols k l A)\""], ["", "lemma add_col_sub_row_carrier[simp]: \n  \"dim_row (add_col_sub_row a k l A) = dim_row A\"\n  \"dim_col (add_col_sub_row a k l A) = dim_col A\"\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> add_col_sub_row a k l A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (add_col_sub_row a k l A) = dim_row A &&&\n    dim_col (add_col_sub_row a k l A) = dim_col A &&&\n    (A \\<in> carrier_mat n n \\<Longrightarrow>\n     add_col_sub_row a k l A \\<in> carrier_mat n n)", "unfolding add_col_sub_row_def carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (addrow (- a) k l (addcol a l k A)) = dim_row A &&&\n    dim_col (addrow (- a) k l (addcol a l k A)) = dim_col A &&&\n    (A \\<in> {m. dim_row m = n \\<and> dim_col m = n} \\<Longrightarrow>\n     addrow (- a) k l (addcol a l k A)\n     \\<in> {m. dim_row m = n \\<and> dim_col m = n})", "by auto"], ["", "lemma add_col_sub_index_row[simp]: \n  \"i < dim_row A \\<Longrightarrow> i < dim_col A \\<Longrightarrow> j < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> l < dim_row A \n    \\<Longrightarrow> add_col_sub_row a k l A $$ (i,j) = (if \n      i = k \\<and> j = l then A $$ (i, j) + a * A $$ (i, i) - a * a * A $$ (j, i) - a * A $$ (j, j) else if\n      i = k \\<and> j \\<noteq> l then A $$ (i, j) - a * A $$ (l, j) else if\n      i \\<noteq> k \\<and> j = l then A $$ (i, j) + a * A $$ (i, k) else A $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A; i < dim_col A; j < dim_row A; j < dim_col A;\n     l < dim_row A\\<rbrakk>\n    \\<Longrightarrow> add_col_sub_row a k l A $$ (i, j) =\n                      (if i = k \\<and> j = l\n                       then A $$ (i, j) + a * A $$ (i, i) -\n                            a * a * A $$ (j, i) -\n                            a * A $$ (j, j)\n                       else if i = k \\<and> j \\<noteq> l\n                            then A $$ (i, j) - a * A $$ (l, j)\n                            else if i \\<noteq> k \\<and> j = l\n                                 then A $$ (i, j) + a * A $$ (i, k)\n                                 else A $$ (i, j))", "unfolding add_col_sub_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A; i < dim_col A; j < dim_row A; j < dim_col A;\n     l < dim_row A\\<rbrakk>\n    \\<Longrightarrow> addrow (- a) k l (addcol a l k A) $$ (i, j) =\n                      (if i = k \\<and> j = l\n                       then A $$ (i, j) + a * A $$ (i, i) -\n                            a * a * A $$ (j, i) -\n                            a * A $$ (j, j)\n                       else if i = k \\<and> j \\<noteq> l\n                            then A $$ (i, j) - a * A $$ (l, j)\n                            else if i \\<noteq> k \\<and> j = l\n                                 then A $$ (i, j) + a * A $$ (i, k)\n                                 else A $$ (i, j))", "by (auto simp: field_simps)"], ["", "lemma mult_col_div_index_row[simp]: \n  \"i < dim_row A \\<Longrightarrow> i < dim_col A \\<Longrightarrow> j < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> a \\<noteq> 0\n    \\<Longrightarrow> mult_col_div_row a k A $$ (i,j) = (if \n      i = k \\<and> j \\<noteq> i then inverse a * A $$ (i, j) else if\n      j = k \\<and> j \\<noteq> i then a * A $$ (i, j) else A $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A; i < dim_col A; j < dim_row A; j < dim_col A;\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> mult_col_div_row a k A $$ (i, j) =\n                      (if i = k \\<and> j \\<noteq> i\n                       then inverse a * A $$ (i, j)\n                       else if j = k \\<and> j \\<noteq> i\n                            then a * A $$ (i, j) else A $$ (i, j))", "unfolding mult_col_div_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A; i < dim_col A; j < dim_row A; j < dim_col A;\n     a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> multrow k (inverse a) (multcol k a A) $$ (i, j) =\n                      (if i = k \\<and> j \\<noteq> i\n                       then inverse a * A $$ (i, j)\n                       else if j = k \\<and> j \\<noteq> i\n                            then a * A $$ (i, j) else A $$ (i, j))", "by auto"], ["", "lemma mult_col_div_row_carrier[simp]: \n  \"dim_row (mult_col_div_row a k A) = dim_row A\"\n  \"dim_col (mult_col_div_row a k A) = dim_col A\"\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> mult_col_div_row a k A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mult_col_div_row a k A) = dim_row A &&&\n    dim_col (mult_col_div_row a k A) = dim_col A &&&\n    (A \\<in> carrier_mat n n \\<Longrightarrow>\n     mult_col_div_row a k A \\<in> carrier_mat n n)", "unfolding mult_col_div_row_def carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (multrow k (inverse a) (multcol k a A)) = dim_row A &&&\n    dim_col (multrow k (inverse a) (multcol k a A)) = dim_col A &&&\n    (A \\<in> {m. dim_row m = n \\<and> dim_col m = n} \\<Longrightarrow>\n     multrow k (inverse a) (multcol k a A)\n     \\<in> {m. dim_row m = n \\<and> dim_col m = n})", "by auto"], ["", "lemma swap_cols_rows_carrier[simp]: \n  \"dim_row (swap_cols_rows k l A) = dim_row A\"\n  \"dim_col (swap_cols_rows k l A) = dim_col A\"\n  \"A \\<in> carrier_mat n n \\<Longrightarrow> swap_cols_rows k l A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (swap_cols_rows k l A) = dim_row A &&&\n    dim_col (swap_cols_rows k l A) = dim_col A &&&\n    (A \\<in> carrier_mat n n \\<Longrightarrow>\n     swap_cols_rows k l A \\<in> carrier_mat n n)", "unfolding swap_cols_rows_def carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (swaprows k l (swapcols k l A)) = dim_row A &&&\n    dim_col (swaprows k l (swapcols k l A)) = dim_col A &&&\n    (A \\<in> {m. dim_row m = n \\<and> dim_col m = n} \\<Longrightarrow>\n     swaprows k l (swapcols k l A)\n     \\<in> {m. dim_row m = n \\<and> dim_col m = n})", "by auto"], ["", "lemma swap_cols_rows_index[simp]: \n  \"i < dim_row A \\<Longrightarrow> i < dim_col A \\<Longrightarrow> j < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> a < dim_row A \\<Longrightarrow> b < dim_row A \n    \\<Longrightarrow> swap_cols_rows a b A $$ (i,j) = A $$ (if i = a then b else if i = b then a else i,\n     if j = a then b else if j = b then a else j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A; i < dim_col A; j < dim_row A; j < dim_col A;\n     a < dim_row A; b < dim_row A\\<rbrakk>\n    \\<Longrightarrow> swap_cols_rows a b A $$ (i, j) =\n                      A $$\n                      (if i = a then b else if i = b then a else i,\n                       if j = a then b else if j = b then a else j)", "unfolding swap_cols_rows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < dim_row A; i < dim_col A; j < dim_row A; j < dim_col A;\n     a < dim_row A; b < dim_row A\\<rbrakk>\n    \\<Longrightarrow> swaprows a b (swapcols a b A) $$ (i, j) =\n                      A $$\n                      (if i = a then b else if i = b then a else i,\n                       if j = a then b else if j = b then a else j)", "by auto"], ["", "lemma add_col_sub_row_similar: assumes A: \"A \\<in> carrier_mat n n\" and kl: \"k < n\" \"l < n\" \"k \\<noteq> l\"\n  shows \"similar_mat (add_col_sub_row a k l A) (A :: 'a :: comm_ring_1 mat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat (add_col_sub_row a k l A) A", "proof (rule similar_matI)"], ["proof (state)\ngoal (4 subgoals):\n 1. {add_col_sub_row a k l A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. add_col_sub_row a k l A = ?P * A * ?Q", "let ?P = \"addrow_mat n (-a) k l\""], ["proof (state)\ngoal (4 subgoals):\n 1. {add_col_sub_row a k l A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. add_col_sub_row a k l A = ?P * A * ?Q", "let ?Q = \"addrow_mat n a k l\""], ["proof (state)\ngoal (4 subgoals):\n 1. {add_col_sub_row a k l A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. add_col_sub_row a k l A = ?P * A * ?Q", "let ?B = \"add_col_sub_row a k l A\""], ["proof (state)\ngoal (4 subgoals):\n 1. {add_col_sub_row a k l A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. add_col_sub_row a k l A = ?P * A * ?Q", "show carr: \"{?B, A, ?P, ?Q} \\<subseteq> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {add_col_sub_row a k l A, A, addrow_mat n (- a) k l, addrow_mat n a k l}\n    \\<subseteq> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. {add_col_sub_row a k l A, A, addrow_mat n (- a) k l, addrow_mat n a k l}\n    \\<subseteq> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  {add_col_sub_row a k l A, A, addrow_mat n (- a) k l, addrow_mat n a k l}\n  \\<subseteq> carrier_mat n n\n\ngoal (3 subgoals):\n 1. addrow_mat n (- a) k l * addrow_mat n a k l = 1\\<^sub>m n\n 2. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n\n 3. add_col_sub_row a k l A =\n    addrow_mat n (- a) k l * A * addrow_mat n a k l", "show \"?Q * ?P = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "by (rule addrow_mat_inv[OF kl])"], ["proof (state)\nthis:\n  addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n\n\ngoal (2 subgoals):\n 1. addrow_mat n (- a) k l * addrow_mat n a k l = 1\\<^sub>m n\n 2. add_col_sub_row a k l A =\n    addrow_mat n (- a) k l * A * addrow_mat n a k l", "show \"?P * ?Q = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n (- a) k l * addrow_mat n a k l = 1\\<^sub>m n", "using addrow_mat_inv[OF kl, of \"-a\"]"], ["proof (prove)\nusing this:\n  addrow_mat n (- a) k l * addrow_mat n (- (- a)) k l = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. addrow_mat n (- a) k l * addrow_mat n a k l = 1\\<^sub>m n", "by simp"], ["proof (state)\nthis:\n  addrow_mat n (- a) k l * addrow_mat n a k l = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. add_col_sub_row a k l A =\n    addrow_mat n (- a) k l * A * addrow_mat n a k l", "have col: \"addcol a l k A = A * ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addcol a l k A = A * addrow_mat n a k l", "by (rule addcol_mat[OF A kl(1)])"], ["proof (state)\nthis:\n  addcol a l k A = A * addrow_mat n a k l\n\ngoal (1 subgoal):\n 1. add_col_sub_row a k l A =\n    addrow_mat n (- a) k l * A * addrow_mat n a k l", "have \"?B = ?P * (A * ?Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_col_sub_row a k l A =\n    addrow_mat n (- a) k l * (A * addrow_mat n a k l)", "unfolding add_col_sub_row_def col"], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow (- a) k l (A * addrow_mat n a k l) =\n    addrow_mat n (- a) k l * (A * addrow_mat n a k l)", "by (rule addrow_mat[OF _ kl(2), of _ n], insert A, simp)"], ["proof (state)\nthis:\n  add_col_sub_row a k l A =\n  addrow_mat n (- a) k l * (A * addrow_mat n a k l)\n\ngoal (1 subgoal):\n 1. add_col_sub_row a k l A =\n    addrow_mat n (- a) k l * A * addrow_mat n a k l", "thus \"?B = ?P * A * ?Q\""], ["proof (prove)\nusing this:\n  add_col_sub_row a k l A =\n  addrow_mat n (- a) k l * (A * addrow_mat n a k l)\n\ngoal (1 subgoal):\n 1. add_col_sub_row a k l A =\n    addrow_mat n (- a) k l * A * addrow_mat n a k l", "using carr"], ["proof (prove)\nusing this:\n  add_col_sub_row a k l A =\n  addrow_mat n (- a) k l * (A * addrow_mat n a k l)\n  {add_col_sub_row a k l A, A, addrow_mat n (- a) k l, addrow_mat n a k l}\n  \\<subseteq> carrier_mat n n\n\ngoal (1 subgoal):\n 1. add_col_sub_row a k l A =\n    addrow_mat n (- a) k l * A * addrow_mat n a k l", "by (simp add: assoc_mult_mat[of _ n n _ n _ n])"], ["proof (state)\nthis:\n  add_col_sub_row a k l A = addrow_mat n (- a) k l * A * addrow_mat n a k l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_col_div_row_similar: assumes A: \"A \\<in> carrier_mat n n\" and ak: \"k < n\" \"a \\<noteq> 0\"\n  shows \"similar_mat (mult_col_div_row a k A) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat (mult_col_div_row a k A) A", "proof (rule similar_matI)"], ["proof (state)\ngoal (4 subgoals):\n 1. {mult_col_div_row a k A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. mult_col_div_row a k A = ?P * A * ?Q", "let ?P = \"multrow_mat n k (inverse a)\""], ["proof (state)\ngoal (4 subgoals):\n 1. {mult_col_div_row a k A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. mult_col_div_row a k A = ?P * A * ?Q", "let ?Q = \"multrow_mat n k a\""], ["proof (state)\ngoal (4 subgoals):\n 1. {mult_col_div_row a k A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. mult_col_div_row a k A = ?P * A * ?Q", "let ?B = \"mult_col_div_row a k A\""], ["proof (state)\ngoal (4 subgoals):\n 1. {mult_col_div_row a k A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. mult_col_div_row a k A = ?P * A * ?Q", "show carr: \"{?B, A, ?P, ?Q} \\<subseteq> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {mult_col_div_row a k A, A, multrow_mat n k (inverse a),\n     multrow_mat n k a}\n    \\<subseteq> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. {mult_col_div_row a k A, A, multrow_mat n k (inverse a),\n     multrow_mat n k a}\n    \\<subseteq> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  {mult_col_div_row a k A, A, multrow_mat n k (inverse a),\n   multrow_mat n k a}\n  \\<subseteq> carrier_mat n n\n\ngoal (3 subgoals):\n 1. multrow_mat n k (inverse a) * multrow_mat n k a = 1\\<^sub>m n\n 2. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n\n 3. mult_col_div_row a k A =\n    multrow_mat n k (inverse a) * A * multrow_mat n k a", "show \"?Q * ?P = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "by (rule multrow_mat_inv[OF ak])"], ["proof (state)\nthis:\n  multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n\n\ngoal (2 subgoals):\n 1. multrow_mat n k (inverse a) * multrow_mat n k a = 1\\<^sub>m n\n 2. mult_col_div_row a k A =\n    multrow_mat n k (inverse a) * A * multrow_mat n k a", "show \"?P * ?Q = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k (inverse a) * multrow_mat n k a = 1\\<^sub>m n", "using multrow_mat_inv[OF ak(1), of \"inverse a\"] ak(2)"], ["proof (prove)\nusing this:\n  inverse a \\<noteq> (0::'a) \\<Longrightarrow>\n  multrow_mat n k (inverse a) * multrow_mat n k (inverse (inverse a)) =\n  1\\<^sub>m n\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. multrow_mat n k (inverse a) * multrow_mat n k a = 1\\<^sub>m n", "by simp"], ["proof (state)\nthis:\n  multrow_mat n k (inverse a) * multrow_mat n k a = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. mult_col_div_row a k A =\n    multrow_mat n k (inverse a) * A * multrow_mat n k a", "have col: \"multcol k a A = A * ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multcol k a A = A * multrow_mat n k a", "by (rule multcol_mat[OF A])"], ["proof (state)\nthis:\n  multcol k a A = A * multrow_mat n k a\n\ngoal (1 subgoal):\n 1. mult_col_div_row a k A =\n    multrow_mat n k (inverse a) * A * multrow_mat n k a", "have \"?B = ?P * (A * ?Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_col_div_row a k A =\n    multrow_mat n k (inverse a) * (A * multrow_mat n k a)", "unfolding mult_col_div_row_def col"], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow k (inverse a) (A * multrow_mat n k a) =\n    multrow_mat n k (inverse a) * (A * multrow_mat n k a)", "by (rule multrow_mat[of _ n n], insert A, simp)"], ["proof (state)\nthis:\n  mult_col_div_row a k A =\n  multrow_mat n k (inverse a) * (A * multrow_mat n k a)\n\ngoal (1 subgoal):\n 1. mult_col_div_row a k A =\n    multrow_mat n k (inverse a) * A * multrow_mat n k a", "thus \"?B = ?P * A * ?Q\""], ["proof (prove)\nusing this:\n  mult_col_div_row a k A =\n  multrow_mat n k (inverse a) * (A * multrow_mat n k a)\n\ngoal (1 subgoal):\n 1. mult_col_div_row a k A =\n    multrow_mat n k (inverse a) * A * multrow_mat n k a", "using carr"], ["proof (prove)\nusing this:\n  mult_col_div_row a k A =\n  multrow_mat n k (inverse a) * (A * multrow_mat n k a)\n  {mult_col_div_row a k A, A, multrow_mat n k (inverse a),\n   multrow_mat n k a}\n  \\<subseteq> carrier_mat n n\n\ngoal (1 subgoal):\n 1. mult_col_div_row a k A =\n    multrow_mat n k (inverse a) * A * multrow_mat n k a", "by (simp add: assoc_mult_mat[of _ n n _ n _ n])"], ["proof (state)\nthis:\n  mult_col_div_row a k A =\n  multrow_mat n k (inverse a) * A * multrow_mat n k a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_cols_rows_similar: assumes A: \"A \\<in> carrier_mat n n\" and kl: \"k < n\" \"l < n\"\n  shows \"similar_mat (swap_cols_rows k l A) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat (swap_cols_rows k l A) A", "proof (rule similar_matI)"], ["proof (state)\ngoal (4 subgoals):\n 1. {swap_cols_rows k l A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. swap_cols_rows k l A = ?P * A * ?Q", "let ?P = \"swaprows_mat n k l\""], ["proof (state)\ngoal (4 subgoals):\n 1. {swap_cols_rows k l A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. swap_cols_rows k l A = ?P * A * ?Q", "let ?B = \"swap_cols_rows k l A\""], ["proof (state)\ngoal (4 subgoals):\n 1. {swap_cols_rows k l A, A, ?P, ?Q} \\<subseteq> carrier_mat ?n ?n\n 2. ?P * ?Q = 1\\<^sub>m ?n\n 3. ?Q * ?P = 1\\<^sub>m ?n\n 4. swap_cols_rows k l A = ?P * A * ?Q", "show carr: \"{?B, A, ?P, ?P} \\<subseteq> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {swap_cols_rows k l A, A, swaprows_mat n k l, swaprows_mat n k l}\n    \\<subseteq> carrier_mat n n", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. {swap_cols_rows k l A, A, swaprows_mat n k l, swaprows_mat n k l}\n    \\<subseteq> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  {swap_cols_rows k l A, A, swaprows_mat n k l, swaprows_mat n k l}\n  \\<subseteq> carrier_mat n n\n\ngoal (3 subgoals):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n\n 2. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n\n 3. swap_cols_rows k l A = swaprows_mat n k l * A * swaprows_mat n k l", "show \"?P * ?P = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "by (rule swaprows_mat_inv[OF kl])"], ["proof (state)\nthis:\n  swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n\n\ngoal (2 subgoals):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n\n 2. swap_cols_rows k l A = swaprows_mat n k l * A * swaprows_mat n k l", "show \"?P * ?P = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "by fact"], ["proof (state)\nthis:\n  swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. swap_cols_rows k l A = swaprows_mat n k l * A * swaprows_mat n k l", "have col: \"swapcols k l A = A * ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swapcols k l A = A * swaprows_mat n k l", "by (rule swapcols_mat[OF A kl])"], ["proof (state)\nthis:\n  swapcols k l A = A * swaprows_mat n k l\n\ngoal (1 subgoal):\n 1. swap_cols_rows k l A = swaprows_mat n k l * A * swaprows_mat n k l", "have \"?B = ?P * (A * ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_cols_rows k l A = swaprows_mat n k l * (A * swaprows_mat n k l)", "unfolding swap_cols_rows_def col"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows k l (A * swaprows_mat n k l) =\n    swaprows_mat n k l * (A * swaprows_mat n k l)", "by (rule swaprows_mat[of _ n n ], insert A kl, auto)"], ["proof (state)\nthis:\n  swap_cols_rows k l A = swaprows_mat n k l * (A * swaprows_mat n k l)\n\ngoal (1 subgoal):\n 1. swap_cols_rows k l A = swaprows_mat n k l * A * swaprows_mat n k l", "thus \"?B = ?P * A * ?P\""], ["proof (prove)\nusing this:\n  swap_cols_rows k l A = swaprows_mat n k l * (A * swaprows_mat n k l)\n\ngoal (1 subgoal):\n 1. swap_cols_rows k l A = swaprows_mat n k l * A * swaprows_mat n k l", "using carr"], ["proof (prove)\nusing this:\n  swap_cols_rows k l A = swaprows_mat n k l * (A * swaprows_mat n k l)\n  {swap_cols_rows k l A, A, swaprows_mat n k l, swaprows_mat n k l}\n  \\<subseteq> carrier_mat n n\n\ngoal (1 subgoal):\n 1. swap_cols_rows k l A = swaprows_mat n k l * A * swaprows_mat n k l", "by (simp add: assoc_mult_mat[of _ n n _ n _ n])"], ["proof (state)\nthis:\n  swap_cols_rows k l A = swaprows_mat n k l * A * swaprows_mat n k l\n\ngoal:\nNo subgoals!", "qed"], ["", "(* THIS LINE SEPARATES AFP-ENTRY FROM NEWER DEVELOPMENTS *)"], ["", "lemma swapcols_carrier[simp]: \"(swapcols l k A \\<in> carrier_mat n m) = (A \\<in> carrier_mat n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (swapcols l k A \\<in> carrier_mat n m) = (A \\<in> carrier_mat n m)", "unfolding mat_swapcols_def carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat (dim_row A) (dim_col A)\n      (\\<lambda>(i, j).\n          if l = j then A $$ (i, k)\n          else if k = j then A $$ (i, l) else A $$ (i, j))\n     \\<in> {ma. dim_row ma = n \\<and> dim_col ma = m}) =\n    (A \\<in> {ma. dim_row ma = n \\<and> dim_col ma = m})", "by auto"], ["", "fun swap_row_to_front :: \"'a mat \\<Rightarrow> nat \\<Rightarrow> 'a mat\" where\n  \"swap_row_to_front A 0 = A\"\n| \"swap_row_to_front A (Suc I) = swap_row_to_front (swaprows I (Suc I) A) I\""], ["", "fun swap_col_to_front :: \"'a mat \\<Rightarrow> nat \\<Rightarrow> 'a mat\" where\n  \"swap_col_to_front A 0 = A\"\n| \"swap_col_to_front A (Suc I) = swap_col_to_front (swapcols I (Suc I) A) I\""], ["", "lemma swap_row_to_front_result: \"A \\<in> carrier_mat n m \\<Longrightarrow> I < n \\<Longrightarrow> swap_row_to_front A I = \n  mat n m (\\<lambda> (i,j). if i = 0 then A $$ (I,j)\n  else if i \\<le> I then A $$ (i - 1, j) else A $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n    \\<Longrightarrow> swap_row_to_front A I =\n                      mat n m\n                       (\\<lambda>(i, j).\n                           if i = 0 then A $$ (I, j)\n                           else if i \\<le> I then A $$ (i - 1, j)\n                                else A $$ (i, j))", "proof (induct I arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A 0 =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (0, j)\n                              else if i \\<le> 0 then A $$ (i - 1, j)\n                                   else A $$ (i, j))\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "case 0"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n m\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n m; 0 < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A 0 =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (0, j)\n                              else if i \\<le> 0 then A $$ (i - 1, j)\n                                   else A $$ (i, j))\n 2. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "thus ?case"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n m\n  0 < n\n\ngoal (1 subgoal):\n 1. swap_row_to_front A 0 =\n    mat n m\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           if i = 0 then A $$ (0, j)\n           else if i \\<le> 0 then A $$ (i - 1, j) else A $$ (i, j))", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  swap_row_to_front A 0 =\n  mat n m\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         if i = 0 then A $$ (0, j)\n         else if i \\<le> 0 then A $$ (i - 1, j) else A $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "case (Suc I A)"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> carrier_mat n m; I < n\\<rbrakk>\n  \\<Longrightarrow> swap_row_to_front ?A I =\n                    mat n m\n                     (\\<lambda>a.\n                         case a of\n                         (i, j) \\<Rightarrow>\n                           if i = 0 then ?A $$ (I, j)\n                           else if i \\<le> I then ?A $$ (i - 1, j)\n                                else ?A $$ (i, j))\n  A \\<in> carrier_mat n m\n  Suc I < n\n\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "from Suc(3)"], ["proof (chain)\npicking this:\n  Suc I < n", "have I: \"I < n\""], ["proof (prove)\nusing this:\n  Suc I < n\n\ngoal (1 subgoal):\n 1. I < n", "by auto"], ["proof (state)\nthis:\n  I < n\n\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "let ?I = \"Suc I\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "let ?A = \"swaprows I ?I A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "have AA: \"?A \\<in> carrier_mat n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows I (Suc I) A \\<in> carrier_mat n m", "using Suc(2)"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. swaprows I (Suc I) A \\<in> carrier_mat n m", "by simp"], ["proof (state)\nthis:\n  swaprows I (Suc I) A \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "have \"swap_row_to_front A (Suc I) = swap_row_to_front ?A I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_row_to_front A (Suc I) = swap_row_to_front (swaprows I (Suc I) A) I", "by simp"], ["proof (state)\nthis:\n  swap_row_to_front A (Suc I) = swap_row_to_front (swaprows I (Suc I) A) I\n\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "also"], ["proof (state)\nthis:\n  swap_row_to_front A (Suc I) = swap_row_to_front (swaprows I (Suc I) A) I\n\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "have \"\\<dots> = mat n m\n   (\\<lambda>(i, j). if i = 0 then ?A $$ (I, j)\n       else if i \\<le> I then ?A $$ (i - 1, j) else ?A $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_row_to_front (swaprows I (Suc I) A) I =\n    mat n m\n     (\\<lambda>(i, j).\n         if i = 0 then swaprows I (Suc I) A $$ (I, j)\n         else if i \\<le> I then swaprows I (Suc I) A $$ (i - 1, j)\n              else swaprows I (Suc I) A $$ (i, j))", "using Suc(1)[OF AA I]"], ["proof (prove)\nusing this:\n  swap_row_to_front (swaprows I (Suc I) A) I =\n  mat n m\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         if i = 0 then swaprows I (Suc I) A $$ (I, j)\n         else if i \\<le> I then swaprows I (Suc I) A $$ (i - 1, j)\n              else swaprows I (Suc I) A $$ (i, j))\n\ngoal (1 subgoal):\n 1. swap_row_to_front (swaprows I (Suc I) A) I =\n    mat n m\n     (\\<lambda>(i, j).\n         if i = 0 then swaprows I (Suc I) A $$ (I, j)\n         else if i \\<le> I then swaprows I (Suc I) A $$ (i - 1, j)\n              else swaprows I (Suc I) A $$ (i, j))", "by simp"], ["proof (state)\nthis:\n  swap_row_to_front (swaprows I (Suc I) A) I =\n  mat n m\n   (\\<lambda>(i, j).\n       if i = 0 then swaprows I (Suc I) A $$ (I, j)\n       else if i \\<le> I then swaprows I (Suc I) A $$ (i - 1, j)\n            else swaprows I (Suc I) A $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "also"], ["proof (state)\nthis:\n  swap_row_to_front (swaprows I (Suc I) A) I =\n  mat n m\n   (\\<lambda>(i, j).\n       if i = 0 then swaprows I (Suc I) A $$ (I, j)\n       else if i \\<le> I then swaprows I (Suc I) A $$ (i - 1, j)\n            else swaprows I (Suc I) A $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "have \"\\<dots> = mat n m\n   (\\<lambda>(i, j). if i = 0 then A $$ (?I, j)\n       else if i \\<le> ?I then A $$ (i - 1, j) else A $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n m\n     (\\<lambda>(i, j).\n         if i = 0 then swaprows I (Suc I) A $$ (I, j)\n         else if i \\<le> I then swaprows I (Suc I) A $$ (i - 1, j)\n              else swaprows I (Suc I) A $$ (i, j)) =\n    mat n m\n     (\\<lambda>(i, j).\n         if i = 0 then A $$ (Suc I, j)\n         else if i \\<le> Suc I then A $$ (i - 1, j) else A $$ (i, j))", "by (rule eq_matI, insert I Suc(2), auto)"], ["proof (state)\nthis:\n  mat n m\n   (\\<lambda>(i, j).\n       if i = 0 then swaprows I (Suc I) A $$ (I, j)\n       else if i \\<le> I then swaprows I (Suc I) A $$ (i - 1, j)\n            else swaprows I (Suc I) A $$ (i, j)) =\n  mat n m\n   (\\<lambda>(i, j).\n       if i = 0 then A $$ (Suc I, j)\n       else if i \\<le> Suc I then A $$ (i - 1, j) else A $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>I A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; I < n\\<rbrakk>\n                   \\<Longrightarrow> swap_row_to_front A I =\n                                     mat n m\n(\\<lambda>(i, j).\n    if i = 0 then A $$ (I, j)\n    else if i \\<le> I then A $$ (i - 1, j) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc I < n\\<rbrakk>\n       \\<Longrightarrow> swap_row_to_front A (Suc I) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if i = 0 then A $$ (Suc I, j)\n                              else if i \\<le> Suc I then A $$ (i - 1, j)\n                                   else A $$ (i, j))", "finally"], ["proof (chain)\npicking this:\n  swap_row_to_front A (Suc I) =\n  mat n m\n   (\\<lambda>(i, j).\n       if i = 0 then A $$ (Suc I, j)\n       else if i \\<le> Suc I then A $$ (i - 1, j) else A $$ (i, j))", "show ?case"], ["proof (prove)\nusing this:\n  swap_row_to_front A (Suc I) =\n  mat n m\n   (\\<lambda>(i, j).\n       if i = 0 then A $$ (Suc I, j)\n       else if i \\<le> Suc I then A $$ (i - 1, j) else A $$ (i, j))\n\ngoal (1 subgoal):\n 1. swap_row_to_front A (Suc I) =\n    mat n m\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           if i = 0 then A $$ (Suc I, j)\n           else if i \\<le> Suc I then A $$ (i - 1, j) else A $$ (i, j))", "."], ["proof (state)\nthis:\n  swap_row_to_front A (Suc I) =\n  mat n m\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         if i = 0 then A $$ (Suc I, j)\n         else if i \\<le> Suc I then A $$ (i - 1, j) else A $$ (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_col_to_front_result: \"A \\<in> carrier_mat n m \\<Longrightarrow> J < m \\<Longrightarrow> swap_col_to_front A J = \n  mat n m (\\<lambda> (i,j). if j = 0 then A $$ (i,J)\n  else if j \\<le> J then A $$ (i, j-1) else A $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n    \\<Longrightarrow> swap_col_to_front A J =\n                      mat n m\n                       (\\<lambda>(i, j).\n                           if j = 0 then A $$ (i, J)\n                           else if j \\<le> J then A $$ (i, j - 1)\n                                else A $$ (i, j))", "proof (induct J arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n m; 0 < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A 0 =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, 0)\n                              else if j \\<le> 0 then A $$ (i, j - 1)\n                                   else A $$ (i, j))\n 2. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "case 0"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n m\n  0 < m\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> carrier_mat n m; 0 < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A 0 =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, 0)\n                              else if j \\<le> 0 then A $$ (i, j - 1)\n                                   else A $$ (i, j))\n 2. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "thus ?case"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n m\n  0 < m\n\ngoal (1 subgoal):\n 1. swap_col_to_front A 0 =\n    mat n m\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           if j = 0 then A $$ (i, 0)\n           else if j \\<le> 0 then A $$ (i, j - 1) else A $$ (i, j))", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  swap_col_to_front A 0 =\n  mat n m\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         if j = 0 then A $$ (i, 0)\n         else if j \\<le> 0 then A $$ (i, j - 1) else A $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "case (Suc J A)"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> carrier_mat n m; J < m\\<rbrakk>\n  \\<Longrightarrow> swap_col_to_front ?A J =\n                    mat n m\n                     (\\<lambda>a.\n                         case a of\n                         (i, j) \\<Rightarrow>\n                           if j = 0 then ?A $$ (i, J)\n                           else if j \\<le> J then ?A $$ (i, j - 1)\n                                else ?A $$ (i, j))\n  A \\<in> carrier_mat n m\n  Suc J < m\n\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "from Suc(3)"], ["proof (chain)\npicking this:\n  Suc J < m", "have J: \"J < m\""], ["proof (prove)\nusing this:\n  Suc J < m\n\ngoal (1 subgoal):\n 1. J < m", "by auto"], ["proof (state)\nthis:\n  J < m\n\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "let ?J = \"Suc J\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "let ?A = \"swapcols J ?J A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "have AA: \"?A \\<in> carrier_mat n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swapcols J (Suc J) A \\<in> carrier_mat n m", "using Suc(2)"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. swapcols J (Suc J) A \\<in> carrier_mat n m", "by simp"], ["proof (state)\nthis:\n  swapcols J (Suc J) A \\<in> carrier_mat n m\n\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "have \"swap_col_to_front A (Suc J) = swap_col_to_front ?A J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_col_to_front A (Suc J) = swap_col_to_front (swapcols J (Suc J) A) J", "by simp"], ["proof (state)\nthis:\n  swap_col_to_front A (Suc J) = swap_col_to_front (swapcols J (Suc J) A) J\n\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "also"], ["proof (state)\nthis:\n  swap_col_to_front A (Suc J) = swap_col_to_front (swapcols J (Suc J) A) J\n\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "have \"\\<dots> = mat n m\n   (\\<lambda>(i, j). if j = 0 then ?A $$ (i, J)\n          else if j \\<le> J then ?A $$ (i, j - 1) else ?A $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_col_to_front (swapcols J (Suc J) A) J =\n    mat n m\n     (\\<lambda>(i, j).\n         if j = 0 then swapcols J (Suc J) A $$ (i, J)\n         else if j \\<le> J then swapcols J (Suc J) A $$ (i, j - 1)\n              else swapcols J (Suc J) A $$ (i, j))", "using Suc(1)[OF AA J]"], ["proof (prove)\nusing this:\n  swap_col_to_front (swapcols J (Suc J) A) J =\n  mat n m\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         if j = 0 then swapcols J (Suc J) A $$ (i, J)\n         else if j \\<le> J then swapcols J (Suc J) A $$ (i, j - 1)\n              else swapcols J (Suc J) A $$ (i, j))\n\ngoal (1 subgoal):\n 1. swap_col_to_front (swapcols J (Suc J) A) J =\n    mat n m\n     (\\<lambda>(i, j).\n         if j = 0 then swapcols J (Suc J) A $$ (i, J)\n         else if j \\<le> J then swapcols J (Suc J) A $$ (i, j - 1)\n              else swapcols J (Suc J) A $$ (i, j))", "by simp"], ["proof (state)\nthis:\n  swap_col_to_front (swapcols J (Suc J) A) J =\n  mat n m\n   (\\<lambda>(i, j).\n       if j = 0 then swapcols J (Suc J) A $$ (i, J)\n       else if j \\<le> J then swapcols J (Suc J) A $$ (i, j - 1)\n            else swapcols J (Suc J) A $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "also"], ["proof (state)\nthis:\n  swap_col_to_front (swapcols J (Suc J) A) J =\n  mat n m\n   (\\<lambda>(i, j).\n       if j = 0 then swapcols J (Suc J) A $$ (i, J)\n       else if j \\<le> J then swapcols J (Suc J) A $$ (i, j - 1)\n            else swapcols J (Suc J) A $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "have \"\\<dots> = mat n m\n   (\\<lambda>(i, j). if j = 0 then A $$ (i, ?J)\n          else if j \\<le> ?J then A $$ (i, j - 1) else A $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n m\n     (\\<lambda>(i, j).\n         if j = 0 then swapcols J (Suc J) A $$ (i, J)\n         else if j \\<le> J then swapcols J (Suc J) A $$ (i, j - 1)\n              else swapcols J (Suc J) A $$ (i, j)) =\n    mat n m\n     (\\<lambda>(i, j).\n         if j = 0 then A $$ (i, Suc J)\n         else if j \\<le> Suc J then A $$ (i, j - 1) else A $$ (i, j))", "by (rule eq_matI, insert J Suc(2), auto)"], ["proof (state)\nthis:\n  mat n m\n   (\\<lambda>(i, j).\n       if j = 0 then swapcols J (Suc J) A $$ (i, J)\n       else if j \\<le> J then swapcols J (Suc J) A $$ (i, j - 1)\n            else swapcols J (Suc J) A $$ (i, j)) =\n  mat n m\n   (\\<lambda>(i, j).\n       if j = 0 then A $$ (i, Suc J)\n       else if j \\<le> Suc J then A $$ (i, j - 1) else A $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>J A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> carrier_mat n m; J < m\\<rbrakk>\n                   \\<Longrightarrow> swap_col_to_front A J =\n                                     mat n m\n(\\<lambda>(i, j).\n    if j = 0 then A $$ (i, J)\n    else if j \\<le> J then A $$ (i, j - 1) else A $$ (i, j));\n        A \\<in> carrier_mat n m; Suc J < m\\<rbrakk>\n       \\<Longrightarrow> swap_col_to_front A (Suc J) =\n                         mat n m\n                          (\\<lambda>(i, j).\n                              if j = 0 then A $$ (i, Suc J)\n                              else if j \\<le> Suc J then A $$ (i, j - 1)\n                                   else A $$ (i, j))", "finally"], ["proof (chain)\npicking this:\n  swap_col_to_front A (Suc J) =\n  mat n m\n   (\\<lambda>(i, j).\n       if j = 0 then A $$ (i, Suc J)\n       else if j \\<le> Suc J then A $$ (i, j - 1) else A $$ (i, j))", "show ?case"], ["proof (prove)\nusing this:\n  swap_col_to_front A (Suc J) =\n  mat n m\n   (\\<lambda>(i, j).\n       if j = 0 then A $$ (i, Suc J)\n       else if j \\<le> Suc J then A $$ (i, j - 1) else A $$ (i, j))\n\ngoal (1 subgoal):\n 1. swap_col_to_front A (Suc J) =\n    mat n m\n     (\\<lambda>a.\n         case a of\n         (i, j) \\<Rightarrow>\n           if j = 0 then A $$ (i, Suc J)\n           else if j \\<le> Suc J then A $$ (i, j - 1) else A $$ (i, j))", "."], ["proof (state)\nthis:\n  swap_col_to_front A (Suc J) =\n  mat n m\n   (\\<lambda>a.\n       case a of\n       (i, j) \\<Rightarrow>\n         if j = 0 then A $$ (i, Suc J)\n         else if j \\<le> Suc J then A $$ (i, j - 1) else A $$ (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swapcols_is_transp_swap_rows: assumes A: \"A \\<in> carrier_mat n m\" \"k < m\" \"l < m\"\n  shows \"swapcols k l A = transpose_mat (swaprows k l (transpose_mat A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swapcols k l A = (swaprows k l A\\<^sup>T)\\<^sup>T", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n m\n  k < m\n  l < m\n\ngoal (1 subgoal):\n 1. swapcols k l A = (swaprows k l A\\<^sup>T)\\<^sup>T", "by (intro eq_matI, auto)"], ["", "end"]]}