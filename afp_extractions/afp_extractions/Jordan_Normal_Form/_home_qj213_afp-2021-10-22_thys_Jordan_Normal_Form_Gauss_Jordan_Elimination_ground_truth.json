{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Gauss_Jordan_Elimination.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemmas mat_multrow_def = mat_multrow_gen_def", "lemmas mat_addrow_def = mat_addrow_gen_def", "lemma index_mat_multrow[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> mat_multrow_gen mul k a A $$ (i,j) = (if k = i then mul a (A $$ (i,j)) else A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> mat_multrow_gen mul i a A $$ (i,j) = mul a (A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> k \\<noteq> i \\<Longrightarrow> mat_multrow_gen mul k a A $$ (i,j) = A $$ (i,j)\"\n  \"dim_row (mat_multrow_gen mul k a A) = dim_row A\" \"dim_col (mat_multrow_gen mul k a A) = dim_col A\"", "lemma index_mat_multrow_mat[simp]:\n  \"i < n \\<Longrightarrow> j < n \\<Longrightarrow> multrow_mat n k a $$ (i,j) = (if k = i \\<and> k = j then a else if i = j \n     then 1 else 0)\"\n  \"dim_row (multrow_mat n k a) = n\" \"dim_col (multrow_mat n k a) = n\"", "lemma index_mat_swaprows[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> swaprows k l A $$ (i,j) = (if k = i then A $$ (l,j) else \n    if l = i then A $$ (k,j) else A $$ (i,j))\"\n  \"dim_row (swaprows k l A) = dim_row A\" \"dim_col (swaprows k l A) = dim_col A\"", "lemma index_mat_swaprows_mat[simp]:\n  \"i < n \\<Longrightarrow> j < n \\<Longrightarrow> swaprows_mat n k l $$ (i,j) = \n    (if k = i \\<and> l = j \\<or> k = j \\<and> l = i \\<or> i = j \\<and> i \\<noteq> k \\<and> i \\<noteq> l then 1 else 0)\"\n  \"dim_row (swaprows_mat n k l) = n\" \"dim_col (swaprows_mat n k l) = n\"", "lemma index_mat_addrow[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> mat_addrow_gen ad mul a k l A $$ (i,j) = (if k = i then \n    ad (mul a (A $$ (l,j))) (A $$ (i,j)) else A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> mat_addrow_gen ad mul a i l A $$ (i,j) = ad (mul a (A $$ (l,j))) (A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> k \\<noteq> i \\<Longrightarrow> mat_addrow_gen ad mul a k l A $$ (i,j) = A $$(i,j)\"\n  \"dim_row (mat_addrow_gen ad mul a k l A) = dim_row A\" \"dim_col (mat_addrow_gen ad mul a k l A) = dim_col A\"", "lemma index_mat_addrow_mat[simp]:\n  \"i < n \\<Longrightarrow> j < n \\<Longrightarrow> addrow_mat n a k l $$ (i,j) = \n    (if k = i \\<and> l = j then (+) a else id) (if i = j then 1 else 0)\"\n  \"dim_row (addrow_mat n a k l) = n\" \"dim_col (addrow_mat n a k l) = n\"", "lemma multrow_carrier[simp]: \"(mat_multrow_gen mul k a A \\<in> carrier_mat n nc) = (A \\<in> carrier_mat n nc)\"", "lemma multrow_mat_carrier[simp]: \"multrow_mat n k a \\<in> carrier_mat n n\"", "lemma addrow_mat_carrier[simp]: \"addrow_mat n a k l \\<in> carrier_mat n n\"", "lemma swaprows_mat_carrier[simp]: \"swaprows_mat n k l \\<in> carrier_mat n n\"", "lemma swaprows_carrier[simp]: \"(swaprows k l A \\<in> carrier_mat n nc) = (A \\<in> carrier_mat n nc)\"", "lemma addrow_carrier[simp]: \"(mat_addrow_gen ad mul a k l A \\<in> carrier_mat n nc) = (A \\<in> carrier_mat n nc)\"", "lemma row_multrow:  \"k \\<noteq> i \\<Longrightarrow> i < n \\<Longrightarrow> row (multrow_mat n k a) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> row (multrow_mat n k a) k = a \\<cdot>\\<^sub>v unit_vec n k\"", "lemma multrow_mat: assumes A: \"A \\<in> carrier_mat n nc\"\n  shows \"multrow k a A = multrow_mat n k a * A\"", "lemma row_addrow: \n  \"k \\<noteq> i \\<Longrightarrow> i < n \\<Longrightarrow> row (addrow_mat n a k l) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> row (addrow_mat n a k l) k = a \\<cdot>\\<^sub>v unit_vec n l + unit_vec n k\"", "lemma addrow_mat: assumes A: \"A \\<in> carrier_mat n nc\" \n  and l: \"l < n\"\n  shows \"addrow a k l A = addrow_mat n a k l * A\"", "lemma row_swaprows: \n  \"l < n \\<Longrightarrow> row (swaprows_mat n l l) l = unit_vec n l\"\n  \"i \\<noteq> k \\<Longrightarrow> i \\<noteq> l \\<Longrightarrow> i < n \\<Longrightarrow> row (swaprows_mat n k l) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> row (swaprows_mat n k l) l = unit_vec n k\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> row (swaprows_mat n k l) k = unit_vec n l\"", "lemma swaprows_mat: assumes A: \"A \\<in> carrier_mat n nc\" and k: \"k < n\" \"l < n\"\n  shows \"swaprows k l A = swaprows_mat n k l * A\"", "lemma swaprows_mat_inv: assumes k: \"k < n\" and l: \"l < n\"\n  shows \"swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n\"", "lemma swaprows_mat_Unit: assumes k: \"k < n\" and l: \"l < n\"\n  shows \"swaprows_mat n k l \\<in> Units (ring_mat TYPE('a :: semiring_1) n b)\"", "lemma addrow_mat_inv: assumes k: \"k < n\" and l: \"l < n\" and neq: \"k \\<noteq> l\"\n  shows \"addrow_mat n a k l * addrow_mat n (- (a :: 'a :: comm_ring_1)) k l = 1\\<^sub>m n\"", "lemma addrow_mat_Unit: assumes k: \"k < n\" and l: \"l < n\" and neq: \"k \\<noteq> l\"\n  shows \"addrow_mat n a k l \\<in> Units (ring_mat TYPE('a :: comm_ring_1) n b)\"", "lemma multrow_mat_inv: assumes k: \"k < n\" and a: \"(a :: 'a :: division_ring) \\<noteq> 0\"\n  shows \"multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n\"", "lemma multrow_mat_Unit: assumes k: \"k < n\" and a: \"(a :: 'a :: division_ring) \\<noteq> 0\"\n  shows \"multrow_mat n k a \\<in> Units (ring_mat TYPE('a) n b)\"", "lemma dim_eliminate_entries_gen[simp]: \"dim_row (eliminate_entries_gen v B i as) = dim_row B\"\n  \"dim_col (eliminate_entries_gen v B i as) = dim_col B\"", "lemma dimc_eliminate_entries_rec[simp]: \"dim_col (eliminate_entries_rec B i as) = dim_col B\"", "lemma dimr_eliminate_entries_rec[simp]: \"dim_row (eliminate_entries_rec B i as) = dim_row B\"", "lemma carrier_eliminate_entries: \"A \\<in> carrier_mat nr nc \\<Longrightarrow> eliminate_entries_gen v A i bs \\<in> carrier_mat nr nc\"\n  \"B \\<in> carrier_mat nr nc \\<Longrightarrow> eliminate_entries_rec B i as \\<in> carrier_mat nr nc\"", "lemma eliminate_entries_convert: \n  assumes jA: \"J < dim_col A\" and *: \"I < dim_row A\" \"dim_row B = dim_row A\" \n  shows \"eliminate_entries (\\<lambda> i. A $$ (i,J)) B I J = \n    eliminate_entries_rec B I (map (\\<lambda> i. (- A $$ (i, J), i)) (filter (\\<lambda> i. i \\<noteq> I) [0 ..< dim_row A]))\"", "lemma Unit_prod_eliminate_entries: \"i < nr \\<Longrightarrow> (\\<And> a i'. (a, i') \\<in> set is \\<Longrightarrow> i' < nr \\<and> i' \\<noteq> i)\n  \\<Longrightarrow> \\<exists> P \\<in> Units (ring_mat TYPE('a :: comm_ring_1) nr b) . \\<forall> B nc. B \\<in> carrier_mat nr nc \\<longrightarrow> eliminate_entries_rec B i is = P * B\"", "lemma gauss_jordan_transform: assumes A: \"A \\<in> carrier_mat nr nc\" and B: \"B \\<in> carrier_mat nr nc'\"\n  and res: \"gauss_jordan (A :: 'a :: field mat) B = (A',B')\"\n  shows \"\\<exists> P \\<in> Units (ring_mat TYPE('a) nr b). A' = P * A \\<and> B' = P * B\"", "lemma gauss_jordan_carrier: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nr nc'\" \n  and res: \"gauss_jordan A B = (A',B')\"\n  shows \"A' \\<in> carrier_mat nr nc\" \"B' \\<in> carrier_mat nr nc'\"", "lemma pivot_funI: assumes d: \"dim_row A = nr\"\n  and *: \"\\<And> i. i < nr \\<Longrightarrow> f i \\<le> nc\"\n      \"\\<And> i j. i < nr \\<Longrightarrow> j < f i \\<Longrightarrow> A $$ (i,j) = 0\"\n      \"\\<And> i. i < nr \\<Longrightarrow> Suc i < nr \\<Longrightarrow> f (Suc i) > f i \\<or> f (Suc i) = nc\"\n      \"\\<And> i. i < nr \\<Longrightarrow> f i < nc \\<Longrightarrow> A $$ (i, f i) = 1\"\n      \"\\<And> i i'. i < nr \\<Longrightarrow> f i < nc \\<Longrightarrow> i' < nr \\<Longrightarrow> i' \\<noteq> i \\<Longrightarrow> A $$ (i',f i) = 0\"\n  shows \"pivot_fun A f nc\"", "lemma pivot_funD: assumes d: \"dim_row A = nr\"\n  and p: \"pivot_fun A f nc\"\n  shows \"\\<And> i. i < nr \\<Longrightarrow> f i \\<le> nc\"\n      \"\\<And> i j. i < nr \\<Longrightarrow> j < f i \\<Longrightarrow> A $$ (i,j) = 0\"\n      \"\\<And> i. i < nr \\<Longrightarrow> Suc i < nr \\<Longrightarrow> f (Suc i) > f i \\<or> f (Suc i) = nc\"\n      \"\\<And> i. i < nr \\<Longrightarrow> f i < nc \\<Longrightarrow> A $$ (i, f i) = 1\"\n      \"\\<And> i i'. i < nr \\<Longrightarrow> f i < nc \\<Longrightarrow> i' < nr \\<Longrightarrow> i' \\<noteq> i \\<Longrightarrow> A $$ (i',f i) = 0\"", "lemma pivot_fun_multrow: assumes p: \"pivot_fun A f jj\"\n  and d: \"dim_row A = nr\" \"dim_col A = nc\"\n  and fi: \"f i0 = jj\"\n  and jj: \"jj \\<le> nc\"\n  shows \"pivot_fun (multrow i0 a A) f jj\"", "lemma pivot_fun_swaprows: assumes p: \"pivot_fun A f jj\"\n  and d: \"dim_row A = nr\" \"dim_col A = nc\"\n  and flk: \"f l = jj\" \"f k = jj\"\n  and nr: \"l < nr\" \"k < nr\"\n  and jj: \"jj \\<le> nc\"\n  shows \"pivot_fun (swaprows l k A) f jj\"", "lemma pivot_fun_eliminate_entries: assumes p: \"pivot_fun A f jj\"\n  and d: \"dim_row A = nr\" \"dim_col A = nc\"\n  and fl: \"f l = jj\"\n  and nr: \"l < nr\"\n  and jj: \"jj \\<le> nc\"\nshows \"pivot_fun (eliminate_entries vs A l j) f jj\"", "lemma pivot_fun_init: \"pivot_fun A (\\<lambda> _. 0) 0\"", "lemma gauss_jordan_main_row_echelon: \n  assumes \n    \"A \\<in> carrier_mat nr nc\"\n    \"gauss_jordan_main A B i j = (A',B')\"\n    \"pivot_fun A f j\" \n    \"\\<And> i'. i' < i \\<Longrightarrow> f i' < j\" \"\\<And> i'. i' \\<ge> i \\<Longrightarrow> f i' = j\"\n    \"i \\<le> nr\" \"j \\<le> nc\"\n  shows \"row_echelon_form A'\"", "lemma gauss_jordan_row_echelon: \n  assumes A: \"A \\<in> carrier_mat nr nc\" \n  and res: \"gauss_jordan A B = (A', B')\"\n  shows \"row_echelon_form A'\"", "lemma pivot_bound: assumes dim: \"dim_row A = nr\"\n  and pivot: \"pivot_fun A f n\"\n  shows \"i + j < nr \\<Longrightarrow> f (i + j) = n \\<or> f (i + j) \\<ge> j + f i\"", "lemma pivot_positions_main: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and pivot: \"pivot_fun A f nc\"\n  shows \"j \\<le> f i \\<or> i \\<ge> nr \\<Longrightarrow> \n    set (pivot_positions_main i j) = {(i', f i') | i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc}\n    \\<and> distinct (map snd (pivot_positions_main i j))\n    \\<and> distinct (map fst (pivot_positions_main i j))\"", "lemma pivot_fun_zero_row_iff: assumes pivot: \"pivot_fun (A :: 'a :: semiring_1 mat) f nc\"\n  and A: \"A \\<in> carrier_mat nr nc\"\n  and i: \"i < nr\"\n  shows \"f i = nc \\<longleftrightarrow> row A i = 0\\<^sub>v nc\"", "lemmas pivot_positions_def = pivot_positions_gen_def", "lemma pivot_positions: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and pivot: \"pivot_fun A f nc\"\n  shows \n    \"set (pivot_positions A) = {(i, f i) | i. i < nr \\<and> f i \\<noteq> nc}\"\n    \"distinct (map fst (pivot_positions A))\"\n    \"distinct (map snd (pivot_positions A))\"\n    \"length (pivot_positions A) = card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\"", "lemmas non_pivot_base_def = non_pivot_base_gen_def", "lemmas find_base_vectors_def = find_base_vectors_gen_def", "lemma non_pivot_base:\n  defines pp: \"pp \\<equiv> pivot_positions A\"\n  assumes qj: \"qj < nc\" \"qj \\<notin> snd ` set pp\" \n  shows \"non_pivot_base A pp qj \\<in> carrier_vec nc\"\n    \"non_pivot_base A pp qj $ qj = 1\"\n    \"A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\"\n    \"\\<And> qj'. qj' < nc \\<Longrightarrow> qj' \\<notin> snd ` set pp \\<Longrightarrow> qj \\<noteq> qj' \\<Longrightarrow> non_pivot_base A pp qj $ qj' = 0\"", "lemma find_base_vector: assumes \"snd ` set (pivot_positions A) \\<noteq> {0 ..< nc}\"\n  shows \n    \"find_base_vector A \\<in> carrier_vec nc\"\n    \"find_base_vector A \\<noteq> 0\\<^sub>v nc\"\n    \"A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr\"", "lemma row_echelon_form_imp_1_or_0_row: assumes A: \"A \\<in> carrier_mat n n\"\n  and row: \"row_echelon_form A\"\n  shows \"A = 1\\<^sub>m n \\<or> (n > 0 \\<and> row A (n - 1) = 0\\<^sub>v n)\"", "lemma find_base_vector_not_1_pivot_positions: \"snd ` set (pivot_positions A) \\<noteq> {0 ..< n}\"", "lemma find_base_vector_not_1: \n    \"find_base_vector A \\<in> carrier_vec n\"\n    \"find_base_vector A \\<noteq> 0\\<^sub>v n\"\n    \"A *\\<^sub>v find_base_vector A = 0\\<^sub>v n\"", "lemma gauss_jordan: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nr nc2\"\n  and gauss: \"gauss_jordan A B = (C,D)\"\n  shows \"x \\<in> carrier_vec nc \\<Longrightarrow> (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\" (is \"_ \\<Longrightarrow> ?l = ?r\")\n    \"X \\<in> carrier_mat nc nc2  \\<Longrightarrow> (A * X = B) = (C * X = D)\" (is \" _ \\<Longrightarrow> ?l2 = ?r2\")\n    \"C \\<in> carrier_mat nr nc\"\n    \"D \\<in> carrier_mat nr nc2\"", "lemma gauss_jordan_single: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and gauss: \"gauss_jordan_single A = C\"\n  shows \"x \\<in> carrier_vec nc \\<Longrightarrow> (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\" \n    \"C \\<in> carrier_mat nr nc\"\n    \"row_echelon_form C\"\n    \"\\<exists> P Q. C = P * A \\<and> P \\<in> carrier_mat nr nr \\<and> Q \\<in> carrier_mat nr nr \\<and> P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr\" (is \"?ex\")", "lemma gauss_jordan_inverse_one_direction: \n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n nc\"\n  and res: \"gauss_jordan A B = (1\\<^sub>m n, B')\"\n  shows \"A \\<in> Units (ring_mat TYPE('a :: field) n b)\"\n  \"B = 1\\<^sub>m n \\<Longrightarrow> A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n\"", "lemma gauss_jordan_inverse_other_direction: \n  assumes AU: \"A \\<in> Units (ring_mat TYPE('a :: field) n b)\" and B: \"B \\<in> carrier_mat n nc\"\n  shows \"fst (gauss_jordan A B) = 1\\<^sub>m n\"", "lemma gauss_jordan_compute_inverse:\n  assumes A: \"A \\<in> carrier_mat n n\"\n  and res: \"gauss_jordan A (1\\<^sub>m n) = (1\\<^sub>m n, B')\"\n  shows \"A * B' = 1\\<^sub>m n\" \"B' * A = 1\\<^sub>m n\" \"B' \\<in> carrier_mat n n\"", "lemma gauss_jordan_check_invertable: assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n nc\"\n  shows \"(A \\<in> Units (ring_mat TYPE('a :: field) n b)) \\<longleftrightarrow> fst (gauss_jordan A B) = 1\\<^sub>m n\"\n  (is \"?l = ?r\")", "lemma mat_inverse: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"mat_inverse A = None \\<Longrightarrow> A \\<notin> Units (ring_mat TYPE('a :: field) n b)\"\n    \"mat_inverse A = Some B \\<Longrightarrow> A * B = 1\\<^sub>m n \\<and> B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n\""], "translations": [["", "lemmas mat_multrow_def = mat_multrow_gen_def"], ["", "definition multrow_mat :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a :: semiring_1 \\<Rightarrow> 'a mat\" where\n  \"multrow_mat n k a = mat n n \n     (\\<lambda> (i,j). if k = i \\<and> k = j then a else if i = j then 1 else 0)\""], ["", "definition mat_swaprows :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a mat \\<Rightarrow> 'a mat\" (\"swaprows\")where\n  \"swaprows k l A = mat (dim_row A) (dim_col A) \n    (\\<lambda> (i,j). if k = i then A $$ (l,j) else if l = i then A $$ (k,j) else A $$ (i,j))\""], ["", "definition swaprows_mat :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a :: semiring_1 mat\" where\n  \"swaprows_mat n k l = mat n n\n    (\\<lambda> (i,j). if k = i \\<and> l = j \\<or> k = j \\<and> l = i \\<or> i = j \\<and> i \\<noteq> k \\<and> i \\<noteq> l then 1 else 0)\""], ["", "definition mat_addrow_gen :: \"('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a mat \\<Rightarrow> 'a mat\" where\n  \"mat_addrow_gen ad mul a k l A = mat (dim_row A) (dim_col A) \n    (\\<lambda> (i,j). if k = i then ad (mul a (A $$ (l,j))) (A $$ (i,j)) else A $$ (i,j))\""], ["", "abbreviation mat_addrow :: \"'a :: semiring_1 \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a mat \\<Rightarrow> 'a mat\" (\"addrow\") where\n  \"addrow \\<equiv> mat_addrow_gen (+) ((*))\""], ["", "lemmas mat_addrow_def = mat_addrow_gen_def"], ["", "definition addrow_mat :: \"nat \\<Rightarrow> 'a :: semiring_1 \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a mat\" where\n  \"addrow_mat n a k l = mat n n (\\<lambda> (i,j). \n    (if k = i \\<and> l = j then (+) a else id) (if i = j then 1 else 0))\""], ["", "lemma index_mat_multrow[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> mat_multrow_gen mul k a A $$ (i,j) = (if k = i then mul a (A $$ (i,j)) else A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> mat_multrow_gen mul i a A $$ (i,j) = mul a (A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> k \\<noteq> i \\<Longrightarrow> mat_multrow_gen mul k a A $$ (i,j) = A $$ (i,j)\"\n  \"dim_row (mat_multrow_gen mul k a A) = dim_row A\" \"dim_col (mat_multrow_gen mul k a A) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat_multrow_gen mul k a A $$ (i, j) =\n                        (if k = i then mul a (A $$ (i, j))\n                         else A $$ (i, j))) &&&\n     (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat_multrow_gen mul i a A $$ (i, j) =\n                        mul a (A $$ (i, j)))) &&&\n    (\\<lbrakk>i < dim_row A; j < dim_col A; k \\<noteq> i\\<rbrakk>\n     \\<Longrightarrow> mat_multrow_gen mul k a A $$ (i, j) =\n                       A $$ (i, j)) &&&\n    dim_row (mat_multrow_gen mul k a A) = dim_row A &&&\n    dim_col (mat_multrow_gen mul k a A) = dim_col A", "unfolding mat_multrow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                         (\\<lambda>(i, j).\n                             if k = i then mul a (A $$ (i, j))\n                             else A $$ (i, j)) $$\n                        (i, j) =\n                        (if k = i then mul a (A $$ (i, j))\n                         else A $$ (i, j))) &&&\n     (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                         (\\<lambda>(ia, j).\n                             if i = ia then mul a (A $$ (ia, j))\n                             else A $$ (ia, j)) $$\n                        (i, j) =\n                        mul a (A $$ (i, j)))) &&&\n    (\\<lbrakk>i < dim_row A; j < dim_col A; k \\<noteq> i\\<rbrakk>\n     \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                        (\\<lambda>(i, j).\n                            if k = i then mul a (A $$ (i, j))\n                            else A $$ (i, j)) $$\n                       (i, j) =\n                       A $$ (i, j)) &&&\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if k = i then mul a (A $$ (i, j)) else A $$ (i, j))) =\n    dim_row A &&&\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if k = i then mul a (A $$ (i, j)) else A $$ (i, j))) =\n    dim_col A", "by auto"], ["", "lemma index_mat_multrow_mat[simp]:\n  \"i < n \\<Longrightarrow> j < n \\<Longrightarrow> multrow_mat n k a $$ (i,j) = (if k = i \\<and> k = j then a else if i = j \n     then 1 else 0)\"\n  \"dim_row (multrow_mat n k a) = n\" \"dim_col (multrow_mat n k a) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < n; j < n\\<rbrakk>\n     \\<Longrightarrow> multrow_mat n k a $$ (i, j) =\n                       (if k = i \\<and> k = j then a\n                        else if i = j then 1::'a else (0::'a))) &&&\n    dim_row (multrow_mat n k a) = n &&& dim_col (multrow_mat n k a) = n", "unfolding multrow_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < n; j < n\\<rbrakk>\n     \\<Longrightarrow> mat n n\n                        (\\<lambda>(i, j).\n                            if k = i \\<and> k = j then a\n                            else if i = j then 1::'a else (0::'a)) $$\n                       (i, j) =\n                       (if k = i \\<and> k = j then a\n                        else if i = j then 1::'a else (0::'a))) &&&\n    dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if k = i \\<and> k = j then a\n           else if i = j then 1::'a else (0::'a))) =\n    n &&&\n    dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if k = i \\<and> k = j then a\n           else if i = j then 1::'a else (0::'a))) =\n    n", "by auto"], ["", "lemma index_mat_swaprows[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> swaprows k l A $$ (i,j) = (if k = i then A $$ (l,j) else \n    if l = i then A $$ (k,j) else A $$ (i,j))\"\n  \"dim_row (swaprows k l A) = dim_row A\" \"dim_col (swaprows k l A) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n     \\<Longrightarrow> swaprows k l A $$ (i, j) =\n                       (if k = i then A $$ (l, j)\n                        else if l = i then A $$ (k, j)\n                             else A $$ (i, j))) &&&\n    dim_row (swaprows k l A) = dim_row A &&&\n    dim_col (swaprows k l A) = dim_col A", "unfolding mat_swaprows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n     \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                        (\\<lambda>(i, j).\n                            if k = i then A $$ (l, j)\n                            else if l = i then A $$ (k, j)\n                                 else A $$ (i, j)) $$\n                       (i, j) =\n                       (if k = i then A $$ (l, j)\n                        else if l = i then A $$ (k, j)\n                             else A $$ (i, j))) &&&\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if k = i then A $$ (l, j)\n           else if l = i then A $$ (k, j) else A $$ (i, j))) =\n    dim_row A &&&\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if k = i then A $$ (l, j)\n           else if l = i then A $$ (k, j) else A $$ (i, j))) =\n    dim_col A", "by auto"], ["", "lemma index_mat_swaprows_mat[simp]:\n  \"i < n \\<Longrightarrow> j < n \\<Longrightarrow> swaprows_mat n k l $$ (i,j) = \n    (if k = i \\<and> l = j \\<or> k = j \\<and> l = i \\<or> i = j \\<and> i \\<noteq> k \\<and> i \\<noteq> l then 1 else 0)\"\n  \"dim_row (swaprows_mat n k l) = n\" \"dim_col (swaprows_mat n k l) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < n; j < n\\<rbrakk>\n     \\<Longrightarrow> swaprows_mat n k l $$ (i, j) =\n                       (if k = i \\<and> l = j \\<or>\n                           k = j \\<and> l = i \\<or>\n                           i = j \\<and> i \\<noteq> k \\<and> i \\<noteq> l\n                        then 1::'a else (0::'a))) &&&\n    dim_row (swaprows_mat n k l) = n &&& dim_col (swaprows_mat n k l) = n", "unfolding swaprows_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < n; j < n\\<rbrakk>\n     \\<Longrightarrow> mat n n\n                        (\\<lambda>(i, j).\n                            if k = i \\<and> l = j \\<or>\n                               k = j \\<and> l = i \\<or>\n                               i = j \\<and> i \\<noteq> k \\<and> i \\<noteq> l\n                            then 1::'a else (0::'a)) $$\n                       (i, j) =\n                       (if k = i \\<and> l = j \\<or>\n                           k = j \\<and> l = i \\<or>\n                           i = j \\<and> i \\<noteq> k \\<and> i \\<noteq> l\n                        then 1::'a else (0::'a))) &&&\n    dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           if k = i \\<and> l = j \\<or>\n              k = j \\<and> l = i \\<or>\n              i = j \\<and> i \\<noteq> k \\<and> i \\<noteq> l\n           then 1::'b else (0::'b))) =\n    n &&&\n    dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           if k = i \\<and> l = j \\<or>\n              k = j \\<and> l = i \\<or>\n              i = j \\<and> i \\<noteq> k \\<and> i \\<noteq> l\n           then 1::'c else (0::'c))) =\n    n", "by auto"], ["", "lemma index_mat_addrow[simp]: \n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> mat_addrow_gen ad mul a k l A $$ (i,j) = (if k = i then \n    ad (mul a (A $$ (l,j))) (A $$ (i,j)) else A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> mat_addrow_gen ad mul a i l A $$ (i,j) = ad (mul a (A $$ (l,j))) (A $$ (i,j))\"\n  \"i < dim_row A \\<Longrightarrow> j < dim_col A \\<Longrightarrow> k \\<noteq> i \\<Longrightarrow> mat_addrow_gen ad mul a k l A $$ (i,j) = A $$(i,j)\"\n  \"dim_row (mat_addrow_gen ad mul a k l A) = dim_row A\" \"dim_col (mat_addrow_gen ad mul a k l A) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat_addrow_gen ad mul a k l A $$ (i, j) =\n                        (if k = i\n                         then ad (mul a (A $$ (l, j))) (A $$ (i, j))\n                         else A $$ (i, j))) &&&\n     (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat_addrow_gen ad mul a i l A $$ (i, j) =\n                        ad (mul a (A $$ (l, j))) (A $$ (i, j)))) &&&\n    (\\<lbrakk>i < dim_row A; j < dim_col A; k \\<noteq> i\\<rbrakk>\n     \\<Longrightarrow> mat_addrow_gen ad mul a k l A $$ (i, j) =\n                       A $$ (i, j)) &&&\n    dim_row (mat_addrow_gen ad mul a k l A) = dim_row A &&&\n    dim_col (mat_addrow_gen ad mul a k l A) = dim_col A", "unfolding mat_addrow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                         (\\<lambda>(i, j).\n                             if k = i\n                             then ad (mul a (A $$ (l, j))) (A $$ (i, j))\n                             else A $$ (i, j)) $$\n                        (i, j) =\n                        (if k = i\n                         then ad (mul a (A $$ (l, j))) (A $$ (i, j))\n                         else A $$ (i, j))) &&&\n     (\\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n      \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                         (\\<lambda>(ia, j).\n                             if i = ia\n                             then ad (mul a (A $$ (l, j))) (A $$ (ia, j))\n                             else A $$ (ia, j)) $$\n                        (i, j) =\n                        ad (mul a (A $$ (l, j))) (A $$ (i, j)))) &&&\n    (\\<lbrakk>i < dim_row A; j < dim_col A; k \\<noteq> i\\<rbrakk>\n     \\<Longrightarrow> mat (dim_row A) (dim_col A)\n                        (\\<lambda>(i, j).\n                            if k = i\n                            then ad (mul a (A $$ (l, j))) (A $$ (i, j))\n                            else A $$ (i, j)) $$\n                       (i, j) =\n                       A $$ (i, j)) &&&\n    dim_row\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if k = i then ad (mul a (A $$ (l, j))) (A $$ (i, j))\n           else A $$ (i, j))) =\n    dim_row A &&&\n    dim_col\n     (mat (dim_row A) (dim_col A)\n       (\\<lambda>(i, j).\n           if k = i then ad (mul a (A $$ (l, j))) (A $$ (i, j))\n           else A $$ (i, j))) =\n    dim_col A", "by auto"], ["", "lemma index_mat_addrow_mat[simp]:\n  \"i < n \\<Longrightarrow> j < n \\<Longrightarrow> addrow_mat n a k l $$ (i,j) = \n    (if k = i \\<and> l = j then (+) a else id) (if i = j then 1 else 0)\"\n  \"dim_row (addrow_mat n a k l) = n\" \"dim_col (addrow_mat n a k l) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < n; j < n\\<rbrakk>\n     \\<Longrightarrow> addrow_mat n a k l $$ (i, j) =\n                       (if k = i \\<and> l = j then (+) a else id)\n                        (if i = j then 1::'a else (0::'a))) &&&\n    dim_row (addrow_mat n a k l) = n &&& dim_col (addrow_mat n a k l) = n", "unfolding addrow_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>i < n; j < n\\<rbrakk>\n     \\<Longrightarrow> mat n n\n                        (\\<lambda>(i, j).\n                            (if k = i \\<and> l = j then (+) a else id)\n                             (if i = j then 1::'a else (0::'a))) $$\n                       (i, j) =\n                       (if k = i \\<and> l = j then (+) a else id)\n                        (if i = j then 1::'a else (0::'a))) &&&\n    dim_row\n     (mat n n\n       (\\<lambda>(i, j).\n           (if k = i \\<and> l = j then (+) a else id)\n            (if i = j then 1::'a else (0::'a)))) =\n    n &&&\n    dim_col\n     (mat n n\n       (\\<lambda>(i, j).\n           (if k = i \\<and> l = j then (+) a else id)\n            (if i = j then 1::'a else (0::'a)))) =\n    n", "by auto"], ["", "lemma multrow_carrier[simp]: \"(mat_multrow_gen mul k a A \\<in> carrier_mat n nc) = (A \\<in> carrier_mat n nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_multrow_gen mul k a A \\<in> carrier_mat n nc) =\n    (A \\<in> carrier_mat n nc)", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_multrow_gen mul k a A\n     \\<in> {m. dim_row m = n \\<and> dim_col m = nc}) =\n    (A \\<in> {m. dim_row m = n \\<and> dim_col m = nc})", "by fastforce"], ["", "lemma multrow_mat_carrier[simp]: \"multrow_mat n k a \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k a \\<in> carrier_mat n n", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k a \\<in> {m. dim_row m = n \\<and> dim_col m = n}", "by auto"], ["", "lemma addrow_mat_carrier[simp]: \"addrow_mat n a k l \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n a k l \\<in> carrier_mat n n", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n a k l \\<in> {m. dim_row m = n \\<and> dim_col m = n}", "by auto"], ["", "lemma swaprows_mat_carrier[simp]: \"swaprows_mat n k l \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l \\<in> carrier_mat n n", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l \\<in> {m. dim_row m = n \\<and> dim_col m = n}", "by auto"], ["", "lemma swaprows_carrier[simp]: \"(swaprows k l A \\<in> carrier_mat n nc) = (A \\<in> carrier_mat n nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (swaprows k l A \\<in> carrier_mat n nc) = (A \\<in> carrier_mat n nc)", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (swaprows k l A \\<in> {m. dim_row m = n \\<and> dim_col m = nc}) =\n    (A \\<in> {m. dim_row m = n \\<and> dim_col m = nc})", "by fastforce"], ["", "lemma addrow_carrier[simp]: \"(mat_addrow_gen ad mul a k l A \\<in> carrier_mat n nc) = (A \\<in> carrier_mat n nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_addrow_gen ad mul a k l A \\<in> carrier_mat n nc) =\n    (A \\<in> carrier_mat n nc)", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_addrow_gen ad mul a k l A\n     \\<in> {m. dim_row m = n \\<and> dim_col m = nc}) =\n    (A \\<in> {m. dim_row m = n \\<and> dim_col m = nc})", "by fastforce"], ["", "lemma row_multrow:  \"k \\<noteq> i \\<Longrightarrow> i < n \\<Longrightarrow> row (multrow_mat n k a) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> row (multrow_mat n k a) k = a \\<cdot>\\<^sub>v unit_vec n k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>k \\<noteq> i; i < n\\<rbrakk>\n     \\<Longrightarrow> row (multrow_mat n k a) i = unit_vec n i) &&&\n    (k < n \\<Longrightarrow>\n     row (multrow_mat n k a) k = a \\<cdot>\\<^sub>v unit_vec n k)", "by (rule eq_vecI, auto)"], ["", "lemma multrow_mat: assumes A: \"A \\<in> carrier_mat n nc\"\n  shows \"multrow k a A = multrow_mat n k a * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow k a A = multrow_mat n k a * A", "by (rule eq_matI, insert A, auto simp: row_multrow smult_scalar_prod_distrib[of _ n])"], ["", "lemma row_addrow: \n  \"k \\<noteq> i \\<Longrightarrow> i < n \\<Longrightarrow> row (addrow_mat n a k l) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> row (addrow_mat n a k l) k = a \\<cdot>\\<^sub>v unit_vec n l + unit_vec n k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>k \\<noteq> i; i < n\\<rbrakk>\n     \\<Longrightarrow> row (addrow_mat n a k l) i = unit_vec n i) &&&\n    (\\<lbrakk>k < n; l < n\\<rbrakk>\n     \\<Longrightarrow> row (addrow_mat n a k l) k =\n                       a \\<cdot>\\<^sub>v unit_vec n l + unit_vec n k)", "by (rule eq_vecI, auto)"], ["", "lemma addrow_mat: assumes A: \"A \\<in> carrier_mat n nc\" \n  and l: \"l < n\"\n  shows \"addrow a k l A = addrow_mat n a k l * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow a k l A = addrow_mat n a k l * A", "by (rule eq_matI, insert l A, auto simp: row_addrow \n  add_scalar_prod_distrib[of _ n] smult_scalar_prod_distrib[of _ n])"], ["", "lemma row_swaprows: \n  \"l < n \\<Longrightarrow> row (swaprows_mat n l l) l = unit_vec n l\"\n  \"i \\<noteq> k \\<Longrightarrow> i \\<noteq> l \\<Longrightarrow> i < n \\<Longrightarrow> row (swaprows_mat n k l) i = unit_vec n i\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> row (swaprows_mat n k l) l = unit_vec n k\"\n  \"k < n \\<Longrightarrow> l < n \\<Longrightarrow> row (swaprows_mat n k l) k = unit_vec n l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l < n \\<Longrightarrow> row (swaprows_mat n l l) l = unit_vec n l) &&&\n     (\\<lbrakk>i \\<noteq> k; i \\<noteq> l; i < n\\<rbrakk>\n      \\<Longrightarrow> row (swaprows_mat n k l) i = unit_vec n i)) &&&\n    (\\<lbrakk>k < n; l < n\\<rbrakk>\n     \\<Longrightarrow> row (swaprows_mat n k l) l = unit_vec n k) &&&\n    (\\<lbrakk>k < n; l < n\\<rbrakk>\n     \\<Longrightarrow> row (swaprows_mat n k l) k = unit_vec n l)", "by (rule eq_vecI, auto)"], ["", "lemma swaprows_mat: assumes A: \"A \\<in> carrier_mat n nc\" and k: \"k < n\" \"l < n\"\n  shows \"swaprows k l A = swaprows_mat n k l * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows k l A = swaprows_mat n k l * A", "by (rule eq_matI, insert A k, auto simp: row_swaprows)"], ["", "lemma swaprows_mat_inv: assumes k: \"k < n\" and l: \"l < n\"\n  shows \"swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "have \"swaprows_mat n k l * swaprows_mat n k l = \n    swaprows_mat n k l * (swaprows_mat n k l * 1\\<^sub>m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l =\n    swaprows_mat n k l * (swaprows_mat n k l * 1\\<^sub>m n)", "by (simp add: right_mult_one_mat[of _ n])"], ["proof (state)\nthis:\n  swaprows_mat n k l * swaprows_mat n k l =\n  swaprows_mat n k l * (swaprows_mat n k l * 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  swaprows_mat n k l * swaprows_mat n k l =\n  swaprows_mat n k l * (swaprows_mat n k l * 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "have \"swaprows_mat n k l * 1\\<^sub>m n = swaprows k l (1\\<^sub>m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l * 1\\<^sub>m n = swaprows k l (1\\<^sub>m n)", "by (rule swaprows_mat[symmetric, OF _ k l, of _ n], simp)"], ["proof (state)\nthis:\n  swaprows_mat n k l * 1\\<^sub>m n = swaprows k l (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  swaprows_mat n k l * 1\\<^sub>m n = swaprows k l (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "have \"swaprows_mat n k l * \\<dots> = swaprows k l \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows k l (1\\<^sub>m n) =\n    swaprows k l (swaprows k l (1\\<^sub>m n))", "by (rule swaprows_mat[symmetric, of _ _ n], insert k l, auto)"], ["proof (state)\nthis:\n  swaprows_mat n k l * swaprows k l (1\\<^sub>m n) =\n  swaprows k l (swaprows k l (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  swaprows_mat n k l * swaprows k l (1\\<^sub>m n) =\n  swaprows k l (swaprows k l (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "have \"\\<dots> = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows k l (swaprows k l (1\\<^sub>m n)) = 1\\<^sub>m n", "by (rule eq_matI, insert k l, auto)"], ["proof (state)\nthis:\n  swaprows k l (swaprows k l (1\\<^sub>m n)) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "finally"], ["proof (chain)\npicking this:\n  swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "show ?thesis"], ["proof (prove)\nusing this:\n  swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n", "."], ["proof (state)\nthis:\n  swaprows_mat n k l * swaprows_mat n k l = 1\\<^sub>m n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swaprows_mat_Unit: assumes k: \"k < n\" and l: \"l < n\"\n  shows \"swaprows_mat n k l \\<in> Units (ring_mat TYPE('a :: semiring_1) n b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l \\<in> Units (ring_mat TYPE('a) n b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. swaprows_mat n k l \\<in> Units (ring_mat TYPE('a) n b)", "interpret m: semiring \"ring_mat TYPE('a) n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring (ring_mat TYPE('a) n b)", "by (rule semiring_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. swaprows_mat n k l \\<in> Units (ring_mat TYPE('a) n b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l \\<in> Units (ring_mat TYPE('a) n b)", "unfolding Units_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows_mat n k l\n    \\<in> {y \\<in> carrier (ring_mat TYPE('a) n b).\n           \\<exists>x\\<in>carrier (ring_mat TYPE('a) n b).\n              x \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> y =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> x =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub>}", "by (rule, rule conjI[OF _ bexI[of _ \"swaprows_mat n k l\"]],\n    auto simp: ring_mat_def swaprows_mat_inv[OF k l] swaprows_mat_inv[OF l k])"], ["proof (state)\nthis:\n  swaprows_mat n k l \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma addrow_mat_inv: assumes k: \"k < n\" and l: \"l < n\" and neq: \"k \\<noteq> l\"\n  shows \"addrow_mat n a k l * addrow_mat n (- (a :: 'a :: comm_ring_1)) k l = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "have \"addrow_mat n a k l * addrow_mat n (- a) k l = \n    addrow_mat n a k l * (addrow_mat n (- a) k l * 1\\<^sub>m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l =\n    addrow_mat n a k l * (addrow_mat n (- a) k l * 1\\<^sub>m n)", "by (simp add: right_mult_one_mat[of _ n])"], ["proof (state)\nthis:\n  addrow_mat n a k l * addrow_mat n (- a) k l =\n  addrow_mat n a k l * (addrow_mat n (- a) k l * 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  addrow_mat n a k l * addrow_mat n (- a) k l =\n  addrow_mat n a k l * (addrow_mat n (- a) k l * 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "have \"addrow_mat n (- a) k l * 1\\<^sub>m n = addrow (- a) k l (1\\<^sub>m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n (- a) k l * 1\\<^sub>m n = addrow (- a) k l (1\\<^sub>m n)", "by (rule addrow_mat[symmetric, of _ _ n], insert k l, auto)"], ["proof (state)\nthis:\n  addrow_mat n (- a) k l * 1\\<^sub>m n = addrow (- a) k l (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  addrow_mat n (- a) k l * 1\\<^sub>m n = addrow (- a) k l (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "have \"addrow_mat n a k l * \\<dots> = addrow a k l \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow (- a) k l (1\\<^sub>m n) =\n    addrow a k l (addrow (- a) k l (1\\<^sub>m n))", "by (rule addrow_mat[symmetric, of _ _ n], insert k l, auto)"], ["proof (state)\nthis:\n  addrow_mat n a k l * addrow (- a) k l (1\\<^sub>m n) =\n  addrow a k l (addrow (- a) k l (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  addrow_mat n a k l * addrow (- a) k l (1\\<^sub>m n) =\n  addrow a k l (addrow (- a) k l (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "have \"\\<dots> = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow a k l (addrow (- a) k l (1\\<^sub>m n)) = 1\\<^sub>m n", "by (rule eq_matI, insert k l neq, auto, algebra)"], ["proof (state)\nthis:\n  addrow a k l (addrow (- a) k l (1\\<^sub>m n)) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "finally"], ["proof (chain)\npicking this:\n  addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "show ?thesis"], ["proof (prove)\nusing this:\n  addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n", "."], ["proof (state)\nthis:\n  addrow_mat n a k l * addrow_mat n (- a) k l = 1\\<^sub>m n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma addrow_mat_Unit: assumes k: \"k < n\" and l: \"l < n\" and neq: \"k \\<noteq> l\"\n  shows \"addrow_mat n a k l \\<in> Units (ring_mat TYPE('a :: comm_ring_1) n b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n a k l \\<in> Units (ring_mat TYPE('a) n b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. addrow_mat n a k l \\<in> Units (ring_mat TYPE('a) n b)", "interpret m: semiring \"ring_mat TYPE('a) n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring (ring_mat TYPE('a) n b)", "by (rule semiring_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. addrow_mat n a k l \\<in> Units (ring_mat TYPE('a) n b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n a k l \\<in> Units (ring_mat TYPE('a) n b)", "unfolding Units_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat n a k l\n    \\<in> {y \\<in> carrier (ring_mat TYPE('a) n b).\n           \\<exists>x\\<in>carrier (ring_mat TYPE('a) n b).\n              x \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> y =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> x =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub>}", "by (rule, rule conjI[OF _ bexI[of _ \"addrow_mat n (- a) k l\"]], insert neq,\n    auto simp: ring_mat_def addrow_mat_inv[OF k l neq], \n    rule trans[OF _ addrow_mat_inv[OF k l neq, of \"- a\"]], auto)"], ["proof (state)\nthis:\n  addrow_mat n a k l \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multrow_mat_inv: assumes k: \"k < n\" and a: \"(a :: 'a :: division_ring) \\<noteq> 0\"\n  shows \"multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "have \"multrow_mat n k a * multrow_mat n k (inverse a) = \n    multrow_mat n k a * (multrow_mat n k (inverse a) * 1\\<^sub>m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) =\n    multrow_mat n k a * (multrow_mat n k (inverse a) * 1\\<^sub>m n)", "using k"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) =\n    multrow_mat n k a * (multrow_mat n k (inverse a) * 1\\<^sub>m n)", "by (simp add: right_mult_one_mat[of _ n])"], ["proof (state)\nthis:\n  multrow_mat n k a * multrow_mat n k (inverse a) =\n  multrow_mat n k a * (multrow_mat n k (inverse a) * 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  multrow_mat n k a * multrow_mat n k (inverse a) =\n  multrow_mat n k a * (multrow_mat n k (inverse a) * 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "have \"multrow_mat n k (inverse a) * 1\\<^sub>m n = multrow k (inverse a) (1\\<^sub>m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k (inverse a) * 1\\<^sub>m n =\n    multrow k (inverse a) (1\\<^sub>m n)", "by (rule multrow_mat[symmetric, of _ _ n], insert k, auto)"], ["proof (state)\nthis:\n  multrow_mat n k (inverse a) * 1\\<^sub>m n =\n  multrow k (inverse a) (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  multrow_mat n k (inverse a) * 1\\<^sub>m n =\n  multrow k (inverse a) (1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "have \"multrow_mat n k a * \\<dots> = multrow k a \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow k (inverse a) (1\\<^sub>m n) =\n    multrow k a (multrow k (inverse a) (1\\<^sub>m n))", "by (rule multrow_mat[symmetric, of _ _ n], insert k, auto)"], ["proof (state)\nthis:\n  multrow_mat n k a * multrow k (inverse a) (1\\<^sub>m n) =\n  multrow k a (multrow k (inverse a) (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  multrow_mat n k a * multrow k (inverse a) (1\\<^sub>m n) =\n  multrow k a (multrow k (inverse a) (1\\<^sub>m n))\n\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "have \"\\<dots> = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow k a (multrow k (inverse a) (1\\<^sub>m n)) = 1\\<^sub>m n", "by (rule eq_matI, insert a k a, auto)"], ["proof (state)\nthis:\n  multrow k a (multrow k (inverse a) (1\\<^sub>m n)) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "finally"], ["proof (chain)\npicking this:\n  multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "show ?thesis"], ["proof (prove)\nusing this:\n  multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n", "."], ["proof (state)\nthis:\n  multrow_mat n k a * multrow_mat n k (inverse a) = 1\\<^sub>m n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multrow_mat_Unit: assumes k: \"k < n\" and a: \"(a :: 'a :: division_ring) \\<noteq> 0\"\n  shows \"multrow_mat n k a \\<in> Units (ring_mat TYPE('a) n b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k a \\<in> Units (ring_mat TYPE('a) n b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. multrow_mat n k a \\<in> Units (ring_mat TYPE('a) n b)", "from a"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)", "have ia: \"inverse a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. inverse a \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  inverse a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. multrow_mat n k a \\<in> Units (ring_mat TYPE('a) n b)", "interpret m: semiring \"ring_mat TYPE('a) n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring (ring_mat TYPE('a) n b)", "by (rule semiring_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. multrow_mat n k a \\<in> Units (ring_mat TYPE('a) n b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k a \\<in> Units (ring_mat TYPE('a) n b)", "unfolding Units_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow_mat n k a\n    \\<in> {y \\<in> carrier (ring_mat TYPE('a) n b).\n           \\<exists>x\\<in>carrier (ring_mat TYPE('a) n b).\n              x \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> y =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> x =\n              \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub>}", "by (rule, rule conjI[OF _ bexI[of _ \"multrow_mat n k (inverse a)\"]], insert a,\n    auto simp: ring_mat_def multrow_mat_inv[OF k],\n    rule trans[OF _ multrow_mat_inv[OF k ia]], insert a, auto)"], ["proof (state)\nthis:\n  multrow_mat n k a \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Gauss-Jordan Elimination\\<close>"], ["", "fun eliminate_entries_rec where\n  \"eliminate_entries_rec B i [] = B\"\n| \"eliminate_entries_rec B i ((ai'j,i') # is) = ( \n  eliminate_entries_rec (mat_addrow_gen ((+) :: 'b :: ring_1 \\<Rightarrow> 'b \\<Rightarrow> 'b) (*) ai'j i' i B) i is)\""], ["", "context\n  fixes minus :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  and times :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\nbegin"], ["", "definition eliminate_entries_gen :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> 'a mat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a mat\" where\n  \"eliminate_entries_gen v A I J = mat (dim_row A) (dim_col A) (\\<lambda> (i, j).\n     if i \\<noteq> I then minus (A $$ (i,j)) (times (v i) (A $$ (I,j))) else A $$ (i,j))\""], ["", "lemma dim_eliminate_entries_gen[simp]: \"dim_row (eliminate_entries_gen v B i as) = dim_row B\"\n  \"dim_col (eliminate_entries_gen v B i as) = dim_col B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (local.eliminate_entries_gen v B i as) = dim_row B &&&\n    dim_col (local.eliminate_entries_gen v B i as) = dim_col B", "unfolding eliminate_entries_gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> i\n           then minus (B $$ (ia, j)) (times (v ia) (B $$ (i, j)))\n           else B $$ (ia, j))) =\n    dim_row B &&&\n    dim_col\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> i\n           then minus (B $$ (ia, j)) (times (v ia) (B $$ (i, j)))\n           else B $$ (ia, j))) =\n    dim_col B", "by auto"], ["", "lemma dimc_eliminate_entries_rec[simp]: \"dim_col (eliminate_entries_rec B i as) = dim_col B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (eliminate_entries_rec B i as) = dim_col B", "by (induct as arbitrary: B, auto simp: Let_def)"], ["", "lemma dimr_eliminate_entries_rec[simp]: \"dim_row (eliminate_entries_rec B i as) = dim_row B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (eliminate_entries_rec B i as) = dim_row B", "by (induct as arbitrary: B, auto simp: Let_def)"], ["", "lemma carrier_eliminate_entries: \"A \\<in> carrier_mat nr nc \\<Longrightarrow> eliminate_entries_gen v A i bs \\<in> carrier_mat nr nc\"\n  \"B \\<in> carrier_mat nr nc \\<Longrightarrow> eliminate_entries_rec B i as \\<in> carrier_mat nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<in> carrier_mat nr nc \\<Longrightarrow>\n     local.eliminate_entries_gen v A i bs \\<in> carrier_mat nr nc) &&&\n    (B \\<in> carrier_mat nr nc \\<Longrightarrow>\n     eliminate_entries_rec B i as \\<in> carrier_mat nr nc)", "unfolding carrier_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<in> {m. dim_row m = nr \\<and> dim_col m = nc} \\<Longrightarrow>\n     local.eliminate_entries_gen v A i bs\n     \\<in> {m. dim_row m = nr \\<and> dim_col m = nc}) &&&\n    (B \\<in> {m. dim_row m = nr \\<and> dim_col m = nc} \\<Longrightarrow>\n     eliminate_entries_rec B i as\n     \\<in> {m. dim_row m = nr \\<and> dim_col m = nc})", "by auto"], ["", "end"], ["", "abbreviation \"eliminate_entries \\<equiv> eliminate_entries_gen (-) ((*) :: 'a :: ring_1 \\<Rightarrow> 'a \\<Rightarrow> 'a)\""], ["", "lemma eliminate_entries_convert: \n  assumes jA: \"J < dim_col A\" and *: \"I < dim_row A\" \"dim_row B = dim_row A\" \n  shows \"eliminate_entries (\\<lambda> i. A $$ (i,J)) B I J = \n    eliminate_entries_rec B I (map (\\<lambda> i. (- A $$ (i, J), i)) (filter (\\<lambda> i. i \\<noteq> I) [0 ..< dim_row A]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "let ?ais = \"\\<lambda> is. map (\\<lambda> i. (- A $$ (i, J), i)) (filter (\\<lambda> i. i \\<noteq> I) is)\""], ["proof (state)\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "define one_go where \"one_go = (\\<lambda> B is. mat (dim_row B) (dim_col B) (\\<lambda> (i, j).\n    if i \\<noteq> I \\<and> i \\<in> set is then B $$ (i,j) - (A $$ (i,J))  * B $$ (I,j) else B $$ (i,j)))\""], ["proof (state)\nthis:\n  one_go =\n  (\\<lambda>B is.\n      mat (dim_row B) (dim_col B)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I \\<and> i \\<in> set is\n           then B $$ (i, j) - A $$ (i, J) * B $$ (I, j) else B $$ (i, j)))\n\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "{"], ["proof (state)\nthis:\n  one_go =\n  (\\<lambda>B is.\n      mat (dim_row B) (dim_col B)\n       (\\<lambda>(i, j).\n           if i \\<noteq> I \\<and> i \\<in> set is\n           then B $$ (i, j) - A $$ (i, J) * B $$ (I, j) else B $$ (i, j)))\n\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "fix \"is\" :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "assume \"distinct is\""], ["proof (state)\nthis:\n  distinct is\n\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "from * this"], ["proof (chain)\npicking this:\n  I < dim_row A\n  dim_row B = dim_row A\n  distinct is", "have \"eliminate_entries_rec B I (?ais is) = one_go B is\""], ["proof (prove)\nusing this:\n  I < dim_row A\n  dim_row B = dim_row A\n  distinct is\n\ngoal (1 subgoal):\n 1. eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) is)) =\n    one_go B is", "proof (induct \"is\" arbitrary: B)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>I < dim_row A; dim_row B = dim_row A; distinct []\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) [])) =\n                         one_go B []\n 2. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "case Nil"], ["proof (state)\nthis:\n  I < dim_row A\n  dim_row B = dim_row A\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>I < dim_row A; dim_row B = dim_row A; distinct []\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) [])) =\n                         one_go B []\n 2. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [])) =\n    one_go B []", "unfolding one_go_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [])) =\n    mat (dim_row B) (dim_col B)\n     (\\<lambda>(i, j).\n         if i \\<noteq> I \\<and> i \\<in> set []\n         then B $$ (i, j) - A $$ (i, J) * B $$ (I, j) else B $$ (i, j))", "by (rule eq_matI, auto)"], ["proof (state)\nthis:\n  eliminate_entries_rec B I\n   (map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) [])) =\n  one_go B []\n\ngoal (1 subgoal):\n 1. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "case (Cons i \"is\")"], ["proof (state)\nthis:\n  \\<lbrakk>I < dim_row A; dim_row ?B = dim_row A; distinct is\\<rbrakk>\n  \\<Longrightarrow> eliminate_entries_rec ?B I\n                     (map (\\<lambda>i. (- A $$ (i, J), i))\n                       (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                    one_go ?B is\n  I < dim_row A\n  dim_row B = dim_row A\n  distinct (i # is)\n\ngoal (1 subgoal):\n 1. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "note I = Cons(2)"], ["proof (state)\nthis:\n  I < dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "note dim = Cons(3)"], ["proof (state)\nthis:\n  dim_row B = dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "note II = Cons(2)[folded dim]"], ["proof (state)\nthis:\n  I < dim_row B\n\ngoal (1 subgoal):\n 1. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "let ?B = \"addrow (- A $$ (i, J)) i I B\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "from Cons(4) I dim"], ["proof (chain)\npicking this:\n  distinct (i # is)\n  I < dim_row A\n  dim_row B = dim_row A", "have \"I < dim_row A\" \"dim_row ?B = dim_row A\" and dist: \"distinct is\""], ["proof (prove)\nusing this:\n  distinct (i # is)\n  I < dim_row A\n  dim_row B = dim_row A\n\ngoal (1 subgoal):\n 1. (I < dim_row A &&&\n     dim_row (addrow (- A $$ (i, J)) i I B) = dim_row A) &&&\n    distinct is", "by auto"], ["proof (state)\nthis:\n  I < dim_row A\n  dim_row (addrow (- A $$ (i, J)) i I B) = dim_row A\n  distinct is\n\ngoal (1 subgoal):\n 1. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "note IH = Cons(1)[OF this]"], ["proof (state)\nthis:\n  eliminate_entries_rec (addrow (- A $$ (i, J)) i I B) I\n   (map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) is)) =\n  one_go (addrow (- A $$ (i, J)) i I B) is\n\ngoal (1 subgoal):\n 1. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "from Cons(4)"], ["proof (chain)\npicking this:\n  distinct (i # is)", "have i: \"i \\<notin> set is\""], ["proof (prove)\nusing this:\n  distinct (i # is)\n\ngoal (1 subgoal):\n 1. i \\<notin> set is", "by auto"], ["proof (state)\nthis:\n  i \\<notin> set is\n\ngoal (1 subgoal):\n 1. \\<And>a is B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>I < dim_row A; dim_row B = dim_row A;\n                    distinct is\\<rbrakk>\n                   \\<Longrightarrow> eliminate_entries_rec B I\n(map (\\<lambda>i. (- A $$ (i, J), i))\n  (filter (\\<lambda>i. i \\<noteq> I) is)) =\n                                     one_go B is;\n        I < dim_row A; dim_row B = dim_row A; distinct (a # is)\\<rbrakk>\n       \\<Longrightarrow> eliminate_entries_rec B I\n                          (map (\\<lambda>i. (- A $$ (i, J), i))\n                            (filter (\\<lambda>i. i \\<noteq> I) (a # is))) =\n                         one_go B (a # is)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)", "proof (cases \"i = I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = I \\<Longrightarrow>\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)\n 2. i \\<noteq> I \\<Longrightarrow>\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)", "case False"], ["proof (state)\nthis:\n  i \\<noteq> I\n\ngoal (2 subgoals):\n 1. i = I \\<Longrightarrow>\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)\n 2. i \\<noteq> I \\<Longrightarrow>\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)", "hence id: \"?ais (i # is) = (- A $$ (i, J), i) # ?ais is\""], ["proof (prove)\nusing this:\n  i \\<noteq> I\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) (i # is)) =\n    (- A $$ (i, J), i) #\n    map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) is)", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>i. (- A $$ (i, J), i))\n   (filter (\\<lambda>i. i \\<noteq> I) (i # is)) =\n  (- A $$ (i, J), i) #\n  map (\\<lambda>i. (- A $$ (i, J), i))\n   (filter (\\<lambda>i. i \\<noteq> I) is)\n\ngoal (2 subgoals):\n 1. i = I \\<Longrightarrow>\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)\n 2. i \\<noteq> I \\<Longrightarrow>\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)", "unfolding id eliminate_entries_rec.simps IH"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_go (addrow (- A $$ (i, J)) i I B) is = one_go B (i # is)", "unfolding one_go_def index_mat_addrow"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row B) (dim_col B)\n     (\\<lambda>(ia, j).\n         if ia \\<noteq> I \\<and> ia \\<in> set is\n         then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n              A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n         else addrow (- A $$ (i, J)) i I B $$ (ia, j)) =\n    mat (dim_row B) (dim_col B)\n     (\\<lambda>(ia, j).\n         if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n         then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j) else B $$ (ia, j))", "proof (rule eq_matI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < dim_row\n                      (mat (dim_row B) (dim_col B)\n                        (\\<lambda>(ia, j).\n                            if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n                            then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n                            else B $$ (ia, j)));\n        j < dim_col\n             (mat (dim_row B) (dim_col B)\n               (\\<lambda>(ia, j).\n                   if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n                   then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n                   else B $$ (ia, j)))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row B) (dim_col B)\n                          (\\<lambda>(ia, j).\n                              if ia \\<noteq> I \\<and> ia \\<in> set is\n                              then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                                   A $$ (ia, J) *\n                                   addrow (- A $$ (i, J)) i I B $$ (I, j)\n                              else addrow (- A $$ (i, J)) i I B $$\n                                   (ia, j)) $$\n                         (ia, j) =\n                         mat (dim_row B) (dim_col B)\n                          (\\<lambda>(ia, j).\n                              if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n                              then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n                              else B $$ (ia, j)) $$\n                         (ia, j)\n 2. dim_row\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set is\n           then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n           else addrow (- A $$ (i, J)) i I B $$ (ia, j))) =\n    dim_row\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n           then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n           else B $$ (ia, j)))\n 3. dim_col\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set is\n           then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n           else addrow (- A $$ (i, J)) i I B $$ (ia, j))) =\n    dim_col\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n           then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n           else B $$ (ia, j)))", "case (1 ii jj)"], ["proof (state)\nthis:\n  ii < dim_row\n        (mat (dim_row B) (dim_col B)\n          (\\<lambda>(ia, j).\n              if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n              then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n              else B $$ (ia, j)))\n  jj < dim_col\n        (mat (dim_row B) (dim_col B)\n          (\\<lambda>(ia, j).\n              if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n              then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n              else B $$ (ia, j)))\n\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < dim_row\n                      (mat (dim_row B) (dim_col B)\n                        (\\<lambda>(ia, j).\n                            if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n                            then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n                            else B $$ (ia, j)));\n        j < dim_col\n             (mat (dim_row B) (dim_col B)\n               (\\<lambda>(ia, j).\n                   if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n                   then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n                   else B $$ (ia, j)))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row B) (dim_col B)\n                          (\\<lambda>(ia, j).\n                              if ia \\<noteq> I \\<and> ia \\<in> set is\n                              then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                                   A $$ (ia, J) *\n                                   addrow (- A $$ (i, J)) i I B $$ (I, j)\n                              else addrow (- A $$ (i, J)) i I B $$\n                                   (ia, j)) $$\n                         (ia, j) =\n                         mat (dim_row B) (dim_col B)\n                          (\\<lambda>(ia, j).\n                              if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n                              then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n                              else B $$ (ia, j)) $$\n                         (ia, j)\n 2. dim_row\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set is\n           then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n           else addrow (- A $$ (i, J)) i I B $$ (ia, j))) =\n    dim_row\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n           then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n           else B $$ (ia, j)))\n 3. dim_col\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set is\n           then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n           else addrow (- A $$ (i, J)) i I B $$ (ia, j))) =\n    dim_col\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n           then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n           else B $$ (ia, j)))", "hence ii: \"ii < dim_row B\" and jj: \"jj < dim_col B\" and iiA: \"ii < dim_row A\""], ["proof (prove)\nusing this:\n  ii < dim_row\n        (mat (dim_row B) (dim_col B)\n          (\\<lambda>(ia, j).\n              if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n              then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n              else B $$ (ia, j)))\n  jj < dim_col\n        (mat (dim_row B) (dim_col B)\n          (\\<lambda>(ia, j).\n              if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n              then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n              else B $$ (ia, j)))\n\ngoal (1 subgoal):\n 1. ii < dim_row B &&& jj < dim_col B &&& ii < dim_row A", "using dim"], ["proof (prove)\nusing this:\n  ii < dim_row\n        (mat (dim_row B) (dim_col B)\n          (\\<lambda>(ia, j).\n              if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n              then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n              else B $$ (ia, j)))\n  jj < dim_col\n        (mat (dim_row B) (dim_col B)\n          (\\<lambda>(ia, j).\n              if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n              then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n              else B $$ (ia, j)))\n  dim_row B = dim_row A\n\ngoal (1 subgoal):\n 1. ii < dim_row B &&& jj < dim_col B &&& ii < dim_row A", "by auto"], ["proof (state)\nthis:\n  ii < dim_row B\n  jj < dim_col B\n  ii < dim_row A\n\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < dim_row\n                      (mat (dim_row B) (dim_col B)\n                        (\\<lambda>(ia, j).\n                            if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n                            then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n                            else B $$ (ia, j)));\n        j < dim_col\n             (mat (dim_row B) (dim_col B)\n               (\\<lambda>(ia, j).\n                   if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n                   then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n                   else B $$ (ia, j)))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row B) (dim_col B)\n                          (\\<lambda>(ia, j).\n                              if ia \\<noteq> I \\<and> ia \\<in> set is\n                              then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                                   A $$ (ia, J) *\n                                   addrow (- A $$ (i, J)) i I B $$ (I, j)\n                              else addrow (- A $$ (i, J)) i I B $$\n                                   (ia, j)) $$\n                         (ia, j) =\n                         mat (dim_row B) (dim_col B)\n                          (\\<lambda>(ia, j).\n                              if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n                              then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n                              else B $$ (ia, j)) $$\n                         (ia, j)\n 2. dim_row\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set is\n           then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n           else addrow (- A $$ (i, J)) i I B $$ (ia, j))) =\n    dim_row\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n           then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n           else B $$ (ia, j)))\n 3. dim_col\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set is\n           then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n           else addrow (- A $$ (i, J)) i I B $$ (ia, j))) =\n    dim_col\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n           then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n           else B $$ (ia, j)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row B) (dim_col B)\n     (\\<lambda>(ia, j).\n         if ia \\<noteq> I \\<and> ia \\<in> set is\n         then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n              A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n         else addrow (- A $$ (i, J)) i I B $$ (ia, j)) $$\n    (ii, jj) =\n    mat (dim_row B) (dim_col B)\n     (\\<lambda>(ia, j).\n         if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n         then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n         else B $$ (ia, j)) $$\n    (ii, jj)", "unfolding index_mat[OF ii jj] split\n            index_mat_addrow(1)[OF ii jj] index_mat_addrow(1)[OF II jj]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ii \\<noteq> I \\<and> ii \\<in> set is\n     then (if i = ii then - A $$ (i, J) * B $$ (I, jj) + B $$ (ii, jj)\n           else B $$ (ii, jj)) -\n          A $$ (ii, J) *\n          (if i = I then - A $$ (i, J) * B $$ (I, jj) + B $$ (I, jj)\n           else B $$ (I, jj))\n     else if i = ii then - A $$ (i, J) * B $$ (I, jj) + B $$ (ii, jj)\n          else B $$ (ii, jj)) =\n    (if ii \\<noteq> I \\<and> ii \\<in> set (i # is)\n     then B $$ (ii, jj) - A $$ (ii, J) * B $$ (I, jj) else B $$ (ii, jj))", "using i False"], ["proof (prove)\nusing this:\n  i \\<notin> set is\n  i \\<noteq> I\n\ngoal (1 subgoal):\n 1. (if ii \\<noteq> I \\<and> ii \\<in> set is\n     then (if i = ii then - A $$ (i, J) * B $$ (I, jj) + B $$ (ii, jj)\n           else B $$ (ii, jj)) -\n          A $$ (ii, J) *\n          (if i = I then - A $$ (i, J) * B $$ (I, jj) + B $$ (I, jj)\n           else B $$ (I, jj))\n     else if i = ii then - A $$ (i, J) * B $$ (I, jj) + B $$ (ii, jj)\n          else B $$ (ii, jj)) =\n    (if ii \\<noteq> I \\<and> ii \\<in> set (i # is)\n     then B $$ (ii, jj) - A $$ (ii, J) * B $$ (I, jj) else B $$ (ii, jj))", "by auto"], ["proof (state)\nthis:\n  mat (dim_row B) (dim_col B)\n   (\\<lambda>(ia, j).\n       if ia \\<noteq> I \\<and> ia \\<in> set is\n       then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n            A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n       else addrow (- A $$ (i, J)) i I B $$ (ia, j)) $$\n  (ii, jj) =\n  mat (dim_row B) (dim_col B)\n   (\\<lambda>(ia, j).\n       if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n       then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j) else B $$ (ia, j)) $$\n  (ii, jj)\n\ngoal (2 subgoals):\n 1. dim_row\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set is\n           then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n           else addrow (- A $$ (i, J)) i I B $$ (ia, j))) =\n    dim_row\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n           then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n           else B $$ (ia, j)))\n 2. dim_col\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set is\n           then addrow (- A $$ (i, J)) i I B $$ (ia, j) -\n                A $$ (ia, J) * addrow (- A $$ (i, J)) i I B $$ (I, j)\n           else addrow (- A $$ (i, J)) i I B $$ (ia, j))) =\n    dim_col\n     (mat (dim_row B) (dim_col B)\n       (\\<lambda>(ia, j).\n           if ia \\<noteq> I \\<and> ia \\<in> set (i # is)\n           then B $$ (ia, j) - A $$ (ia, J) * B $$ (I, j)\n           else B $$ (ia, j)))", "qed auto"], ["proof (state)\nthis:\n  eliminate_entries_rec B I\n   (map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n  one_go B (i # is)\n\ngoal (1 subgoal):\n 1. i = I \\<Longrightarrow>\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = I \\<Longrightarrow>\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)", "case True"], ["proof (state)\nthis:\n  i = I\n\ngoal (1 subgoal):\n 1. i = I \\<Longrightarrow>\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)", "hence id: \"?ais (i # is) = ?ais is\""], ["proof (prove)\nusing this:\n  i = I\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) (i # is)) =\n    map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) is)", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>i. (- A $$ (i, J), i))\n   (filter (\\<lambda>i. i \\<noteq> I) (i # is)) =\n  map (\\<lambda>i. (- A $$ (i, J), i))\n   (filter (\\<lambda>i. i \\<noteq> I) is)\n\ngoal (1 subgoal):\n 1. i = I \\<Longrightarrow>\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n    one_go B (i # is)", "unfolding id Cons(1)[OF I dim dist]"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_go B is = one_go B (i # is)", "unfolding one_go_def True"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row B) (dim_col B)\n     (\\<lambda>(i, j).\n         if i \\<noteq> I \\<and> i \\<in> set is\n         then B $$ (i, j) - A $$ (i, J) * B $$ (I, j) else B $$ (i, j)) =\n    mat (dim_row B) (dim_col B)\n     (\\<lambda>(i, j).\n         if i \\<noteq> I \\<and> i \\<in> set (I # is)\n         then B $$ (i, j) - A $$ (i, J) * B $$ (I, j) else B $$ (i, j))", "by auto"], ["proof (state)\nthis:\n  eliminate_entries_rec B I\n   (map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n  one_go B (i # is)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eliminate_entries_rec B I\n   (map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) (i # is))) =\n  one_go B (i # is)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eliminate_entries_rec B I\n   (map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) is)) =\n  one_go B is\n\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "}"], ["proof (state)\nthis:\n  distinct ?is2 \\<Longrightarrow>\n  eliminate_entries_rec B I\n   (map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) ?is2)) =\n  one_go B ?is2\n\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "note main = this"], ["proof (state)\nthis:\n  distinct ?is2 \\<Longrightarrow>\n  eliminate_entries_rec B I\n   (map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) ?is2)) =\n  one_go B ?is2\n\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n    eliminate_entries_rec B I\n     (map (\\<lambda>i. (- A $$ (i, J), i))\n       (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))", "by (subst main, force, unfold one_go_def eliminate_entries_gen_def, rule eq_matI, \n    insert *, auto)"], ["proof (state)\nthis:\n  eliminate_entries (\\<lambda>i. A $$ (i, J)) B I J =\n  eliminate_entries_rec B I\n   (map (\\<lambda>i. (- A $$ (i, J), i))\n     (filter (\\<lambda>i. i \\<noteq> I) [0..<dim_row A]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Unit_prod_eliminate_entries: \"i < nr \\<Longrightarrow> (\\<And> a i'. (a, i') \\<in> set is \\<Longrightarrow> i' < nr \\<and> i' \\<noteq> i)\n  \\<Longrightarrow> \\<exists> P \\<in> Units (ring_mat TYPE('a :: comm_ring_1) nr b) . \\<forall> B nc. B \\<in> carrier_mat nr nc \\<longrightarrow> eliminate_entries_rec B i is = P * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < nr;\n     \\<And>a i'.\n        (a, i') \\<in> set is \\<Longrightarrow>\n        i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                         \\<forall>B nc.\n                            B \\<in> carrier_mat nr nc \\<longrightarrow>\n                            eliminate_entries_rec B i is = P * B", "proof (induct \"is\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < nr;\n     \\<And>a i'.\n        (a, i') \\<in> set [] \\<Longrightarrow>\n        i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                         \\<forall>B nc.\n                            B \\<in> carrier_mat nr nc \\<longrightarrow>\n                            eliminate_entries_rec B i [] = P * B\n 2. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "case Nil"], ["proof (state)\nthis:\n  i < nr\n  (?a, ?i') \\<in> set [] \\<Longrightarrow> ?i' < nr \\<and> ?i' \\<noteq> i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < nr;\n     \\<And>a i'.\n        (a, i') \\<in> set [] \\<Longrightarrow>\n        i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                         \\<forall>B nc.\n                            B \\<in> carrier_mat nr nc \\<longrightarrow>\n                            eliminate_entries_rec B i [] = P * B\n 2. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "thus ?case"], ["proof (prove)\nusing this:\n  i < nr\n  (?a, ?i') \\<in> set [] \\<Longrightarrow> ?i' < nr \\<and> ?i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       \\<forall>B nc.\n          B \\<in> carrier_mat nr nc \\<longrightarrow>\n          eliminate_entries_rec B i [] = P * B", "by (intro bexI[of _ \"1\\<^sub>m nr\"], auto simp: Units_def ring_mat_def)"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     \\<forall>B nc.\n        B \\<in> carrier_mat nr nc \\<longrightarrow>\n        eliminate_entries_rec B i [] = P * B\n\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "case (Cons ai' \"is\")"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr;\n   \\<And>a i'.\n      (a, i') \\<in> set is \\<Longrightarrow>\n      i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       \\<forall>B nc.\n                          B \\<in> carrier_mat nr nc \\<longrightarrow>\n                          eliminate_entries_rec B i is = P * B\n  i < nr\n  (?a, ?i') \\<in> set (ai' # is) \\<Longrightarrow>\n  ?i' < nr \\<and> ?i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "obtain a i' where ai': \"ai' = (a,i')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a i'. ai' = (a, i') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  ai' = (a, i')\n\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "let ?U = \"Units (ring_mat TYPE('a) nr b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "interpret m: ring \"ring_mat TYPE('a) nr b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring (ring_mat TYPE('a) nr b)", "by (rule ring_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "from Cons(1)[OF Cons(2-3)]"], ["proof (chain)\npicking this:\n  (\\<And>a i'.\n      (a, i') \\<in> set is \\<Longrightarrow>\n      (?a a i', i') \\<in> set (ai' # is)) \\<Longrightarrow>\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     \\<forall>B nc.\n        B \\<in> carrier_mat nr nc \\<longrightarrow>\n        eliminate_entries_rec B i is = P * B", "obtain P where P: \"P \\<in> ?U\" and id: \"\\<And> B nc . B \\<in> carrier_mat nr nc \\<Longrightarrow> \n    eliminate_entries_rec B i is = P * B\""], ["proof (prove)\nusing this:\n  (\\<And>a i'.\n      (a, i') \\<in> set is \\<Longrightarrow>\n      (?a a i', i') \\<in> set (ai' # is)) \\<Longrightarrow>\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     \\<forall>B nc.\n        B \\<in> carrier_mat nr nc \\<longrightarrow>\n        eliminate_entries_rec B i is = P * B\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) nr b);\n         \\<And>B nc.\n            B \\<in> carrier_mat nr nc \\<Longrightarrow>\n            eliminate_entries_rec B i is = P * B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) nr b)\n  ?B \\<in> carrier_mat nr ?nc \\<Longrightarrow>\n  eliminate_entries_rec ?B i is = P * ?B\n\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "let ?Add = \"addrow_mat nr a i' i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "have Add: \"?Add \\<in> ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addrow_mat nr a i' i \\<in> Units (ring_mat TYPE('a) nr b)", "by (rule addrow_mat_Unit, insert Cons ai', auto)"], ["proof (state)\nthis:\n  addrow_mat nr a i' i \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "from m.Units_m_closed[OF P Add]"], ["proof (chain)\npicking this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) nr b\\<^esub> addrow_mat nr a i' i\n  \\<in> Units (ring_mat TYPE('a) nr b)", "have PI: \"P * ?Add \\<in> ?U\""], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) nr b\\<^esub> addrow_mat nr a i' i\n  \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. P * addrow_mat nr a i' i \\<in> Units (ring_mat TYPE('a) nr b)", "unfolding ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n  addrow_mat nr a i' i\n  \\<in> Units\n         \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n            one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n            \\<dots> = b\\<rparr>\n\ngoal (1 subgoal):\n 1. P * addrow_mat nr a i' i\n    \\<in> Units\n           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n              \\<dots> = b\\<rparr>", "by simp"], ["proof (state)\nthis:\n  P * addrow_mat nr a i' i \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "from m.Units_closed[OF P]"], ["proof (chain)\npicking this:\n  P \\<in> carrier (ring_mat TYPE('a) nr b)", "have P: \"P \\<in> carrier_mat nr nr\""], ["proof (prove)\nusing this:\n  P \\<in> carrier (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "unfolding ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> carrier\n           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n              \\<dots> = b\\<rparr>\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "by simp"], ["proof (state)\nthis:\n  P \\<in> carrier_mat nr nr\n\ngoal (1 subgoal):\n 1. \\<And>a is.\n       \\<lbrakk>\\<lbrakk>i < nr;\n                 \\<And>a i'.\n                    (a, i') \\<in> set is \\<Longrightarrow>\n                    i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>P\n     \\<in>Units (ring_mat TYPE('a) nr b).\n                                     \\<forall>B nc.\n  B \\<in> carrier_mat nr nc \\<longrightarrow>\n  eliminate_entries_rec B i is = P * B;\n        i < nr;\n        \\<And>aa i'.\n           (aa, i') \\<in> set (a # is) \\<Longrightarrow>\n           i' < nr \\<and> i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            \\<forall>B nc.\n                               B \\<in> carrier_mat nr nc \\<longrightarrow>\n                               eliminate_entries_rec B i (a # is) = P * B", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       \\<forall>B nc.\n          B \\<in> carrier_mat nr nc \\<longrightarrow>\n          eliminate_entries_rec B i (ai' # is) = P * B", "proof (rule bexI[OF _ PI], intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B nc.\n       B \\<in> carrier_mat nr nc \\<Longrightarrow>\n       eliminate_entries_rec B i (ai' # is) = P * addrow_mat nr a i' i * B", "fix B :: \"'a mat\" and nc"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B nc.\n       B \\<in> carrier_mat nr nc \\<Longrightarrow>\n       eliminate_entries_rec B i (ai' # is) = P * addrow_mat nr a i' i * B", "assume BB: \"B \\<in> carrier_mat nr nc\""], ["proof (state)\nthis:\n  B \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. \\<And>B nc.\n       B \\<in> carrier_mat nr nc \\<Longrightarrow>\n       eliminate_entries_rec B i (ai' # is) = P * addrow_mat nr a i' i * B", "let ?B = \"addrow a i' i B\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B nc.\n       B \\<in> carrier_mat nr nc \\<Longrightarrow>\n       eliminate_entries_rec B i (ai' # is) = P * addrow_mat nr a i' i * B", "from BB"], ["proof (chain)\npicking this:\n  B \\<in> carrier_mat nr nc", "have B: \"?B \\<in> carrier_mat nr nc\""], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. addrow a i' i B \\<in> carrier_mat nr nc", "by simp"], ["proof (state)\nthis:\n  addrow a i' i B \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. \\<And>B nc.\n       B \\<in> carrier_mat nr nc \\<Longrightarrow>\n       eliminate_entries_rec B i (ai' # is) = P * addrow_mat nr a i' i * B", "from id[OF B]"], ["proof (chain)\npicking this:\n  eliminate_entries_rec (addrow a i' i B) i is = P * addrow a i' i B", "have id: \"eliminate_entries_rec ?B i is = P * ?B\""], ["proof (prove)\nusing this:\n  eliminate_entries_rec (addrow a i' i B) i is = P * addrow a i' i B\n\ngoal (1 subgoal):\n 1. eliminate_entries_rec (addrow a i' i B) i is = P * addrow a i' i B", "."], ["proof (state)\nthis:\n  eliminate_entries_rec (addrow a i' i B) i is = P * addrow a i' i B\n\ngoal (1 subgoal):\n 1. \\<And>B nc.\n       B \\<in> carrier_mat nr nc \\<Longrightarrow>\n       eliminate_entries_rec B i (ai' # is) = P * addrow_mat nr a i' i * B", "have id2: \"eliminate_entries_rec B i (ai' # is) = eliminate_entries_rec ?B i is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_rec B i (ai' # is) =\n    eliminate_entries_rec (addrow a i' i B) i is", "unfolding ai'"], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_rec B i ((a, i') # is) =\n    eliminate_entries_rec (addrow a i' i B) i is", "by simp"], ["proof (state)\nthis:\n  eliminate_entries_rec B i (ai' # is) =\n  eliminate_entries_rec (addrow a i' i B) i is\n\ngoal (1 subgoal):\n 1. \\<And>B nc.\n       B \\<in> carrier_mat nr nc \\<Longrightarrow>\n       eliminate_entries_rec B i (ai' # is) = P * addrow_mat nr a i' i * B", "show \"eliminate_entries_rec B i (ai' # is) = P * ?Add * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_rec B i (ai' # is) = P * addrow_mat nr a i' i * B", "unfolding id2 id"], ["proof (prove)\ngoal (1 subgoal):\n 1. P * addrow a i' i B = P * addrow_mat nr a i' i * B", "unfolding addrow_mat[OF BB Cons(2)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. P * (addrow_mat nr a i' i * B) = P * addrow_mat nr a i' i * B", "by (rule assoc_mult_mat[symmetric, OF P _ BB], auto)"], ["proof (state)\nthis:\n  eliminate_entries_rec B i (ai' # is) = P * addrow_mat nr a i' i * B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     \\<forall>B nc.\n        B \\<in> carrier_mat nr nc \\<longrightarrow>\n        eliminate_entries_rec B i (ai' # is) = P * B\n\ngoal:\nNo subgoals!", "qed"], ["", "function gauss_jordan_main :: \"'a :: field mat \\<Rightarrow> 'a mat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a mat \\<times> 'a mat\" where\n  \"gauss_jordan_main A B i j = (let nr = dim_row A; nc = dim_col A in\n    if i < nr \\<and> j < nc then let aij = A $$ (i,j) in if aij = 0 then\n      (case [ i' . i' <- [Suc i ..< nr],  A $$ (i',j) \\<noteq> 0] \n        of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n         | (i' # _) \\<Rightarrow> gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j)\n      else if aij = 1 then let \n        v = (\\<lambda> i. A $$ (i,j)) in\n        gauss_jordan_main \n        (eliminate_entries v A i j) (eliminate_entries v B i j) (Suc i) (Suc j)\n      else let iaij = inverse aij in gauss_jordan_main (multrow i iaij A) (multrow i iaij B) i j\n    else (A,B))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>A B i j.\n           x = (A, B, i, j) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>A B i j Aa Ba ia ja.\n       (A, B, i, j) = (Aa, Ba, ia, ja) \\<Longrightarrow>\n       (let nr = dim_row A; nc = dim_col A\n        in if i < nr \\<and> j < nc\n           then let aij = A $$ (i, j)\n                in if aij = (0::'a)\n                   then case concat\n                              (map (\\<lambda>i'.\n if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n                                [Suc i..<nr]) of\n                        [] \\<Rightarrow>\n                          gauss_jordan_main_sumC (A, B, i, Suc j)\n                        | i' # x \\<Rightarrow>\n                            gauss_jordan_main_sumC\n                             (swaprows i i' A, swaprows i i' B, i, j)\n                   else if aij = (1::'a)\n                        then let v = \\<lambda>i. A $$ (i, j)\n                             in gauss_jordan_main_sumC\n                                 (eliminate_entries v A i j,\n                                  eliminate_entries v B i j, Suc i, Suc j)\n                        else let iaij = inverse aij\n                             in gauss_jordan_main_sumC\n                                 (multrow i iaij A, multrow i iaij B, i, j)\n           else (A, B)) =\n       (let nr = dim_row Aa; nc = dim_col Aa\n        in if ia < nr \\<and> ja < nc\n           then let aij = Aa $$ (ia, ja)\n                in if aij = (0::'a)\n                   then case concat\n                              (map (\\<lambda>i'.\n if Aa $$ (i', ja) \\<noteq> (0::'a) then [i'] else [])\n                                [Suc ia..<nr]) of\n                        [] \\<Rightarrow>\n                          gauss_jordan_main_sumC (Aa, Ba, ia, Suc ja)\n                        | i' # x \\<Rightarrow>\n                            gauss_jordan_main_sumC\n                             (swaprows ia i' Aa, swaprows ia i' Ba, ia, ja)\n                   else if aij = (1::'a)\n                        then let v = \\<lambda>i. Aa $$ (i, ja)\n                             in gauss_jordan_main_sumC\n                                 (eliminate_entries v Aa ia ja,\n                                  eliminate_entries v Ba ia ja, Suc ia,\n                                  Suc ja)\n                        else let iaij = inverse aij\n                             in gauss_jordan_main_sumC\n                                 (multrow ia iaij Aa, multrow ia iaij Ba,\n                                  ia, ja)\n           else (Aa, Ba))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All gauss_jordan_main_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All gauss_jordan_main_dom", "let ?R = \"measures [\\<lambda> (A :: 'a :: field mat,B,i,j). dim_col A - j, \n    \\<lambda> (A,B,i,j). if A $$ (i,j) = 0 then 2 else if A $$ (i,j) = 1 then 0 else 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. All gauss_jordan_main_dom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. All gauss_jordan_main_dom", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. wf ?R\n 2. \\<And>A B i j x xa xaa.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> ((A, B, i, Suc j), A, B, i, j) \\<in> ?R\n 3. \\<And>A B i j x xa xaa x21 x22.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        x21 # x22\\<rbrakk>\n       \\<Longrightarrow> ((swaprows i x21 A, swaprows i x21 B, i, j), A, B,\n                          i, j)\n                         \\<in> ?R\n 4. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n        xb = (\\<lambda>i. A $$ (i, j))\\<rbrakk>\n       \\<Longrightarrow> ((eliminate_entries xb A i j,\n                           eliminate_entries xb B i j, Suc i, Suc j),\n                          A, B, i, j)\n                         \\<in> ?R\n 5. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n        xb = inverse xaa\\<rbrakk>\n       \\<Longrightarrow> ((multrow i xb A, multrow i xb B, i, j), A, B, i,\n                          j)\n                         \\<in> ?R", "show \"wf ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measures\n         [\\<lambda>(A, B, i, j). dim_col A - j,\n          \\<lambda>(A, B, i, j).\n             if A $$ (i, j) = (0::'a) then 2\n             else if A $$ (i, j) = (1::'a) then 0 else 1])", "by auto"], ["proof (state)\nthis:\n  wf (measures\n       [\\<lambda>(A, B, i, j). dim_col A - j,\n        \\<lambda>(A, B, i, j).\n           if A $$ (i, j) = (0::'a) then 2\n           else if A $$ (i, j) = (1::'a) then 0 else 1])\n\ngoal (4 subgoals):\n 1. \\<And>A B i j x xa xaa.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> ((A, B, i, Suc j), A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 2. \\<And>A B i j x xa xaa x21 x22.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        x21 # x22\\<rbrakk>\n       \\<Longrightarrow> ((swaprows i x21 A, swaprows i x21 B, i, j), A, B,\n                          i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 3. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n        xb = (\\<lambda>i. A $$ (i, j))\\<rbrakk>\n       \\<Longrightarrow> ((eliminate_entries xb A i j,\n                           eliminate_entries xb B i j, Suc i, Suc j),\n                          A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 4. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n        xb = inverse xaa\\<rbrakk>\n       \\<Longrightarrow> ((multrow i xb A, multrow i xb B, i, j), A, B, i,\n                          j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>A B i j x xa xaa.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> ((A, B, i, Suc j), A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 2. \\<And>A B i j x xa xaa x21 x22.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        x21 # x22\\<rbrakk>\n       \\<Longrightarrow> ((swaprows i x21 A, swaprows i x21 B, i, j), A, B,\n                          i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 3. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n        xb = (\\<lambda>i. A $$ (i, j))\\<rbrakk>\n       \\<Longrightarrow> ((eliminate_entries xb A i j,\n                           eliminate_entries xb B i j, Suc i, Suc j),\n                          A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 4. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n        xb = inverse xaa\\<rbrakk>\n       \\<Longrightarrow> ((multrow i xb A, multrow i xb B, i, j), A, B, i,\n                          j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]", "fix A B :: \"'a mat\" and i j nr nc a i' \"is\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>A B i j x xa xaa.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> ((A, B, i, Suc j), A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 2. \\<And>A B i j x xa xaa x21 x22.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        x21 # x22\\<rbrakk>\n       \\<Longrightarrow> ((swaprows i x21 A, swaprows i x21 B, i, j), A, B,\n                          i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 3. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n        xb = (\\<lambda>i. A $$ (i, j))\\<rbrakk>\n       \\<Longrightarrow> ((eliminate_entries xb A i j,\n                           eliminate_entries xb B i j, Suc i, Suc j),\n                          A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 4. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n        xb = inverse xaa\\<rbrakk>\n       \\<Longrightarrow> ((multrow i xb A, multrow i xb B, i, j), A, B, i,\n                          j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]", "assume *: \"nr = dim_row A\" \"nc = dim_col A\" \"i < nr \\<and> j < nc\" \"a = A $$ (i, j)\" \"a = 0\"\n      and ne: \"[ i' . i' <- [Suc i ..< nr],  A $$ (i',j) \\<noteq> 0] = i' # is\""], ["proof (state)\nthis:\n  nr = dim_row A\n  nc = dim_col A\n  i < nr \\<and> j < nc\n  a = A $$ (i, j)\n  a = (0::'a)\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  i' # is\n\ngoal (4 subgoals):\n 1. \\<And>A B i j x xa xaa.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> ((A, B, i, Suc j), A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 2. \\<And>A B i j x xa xaa x21 x22.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        x21 # x22\\<rbrakk>\n       \\<Longrightarrow> ((swaprows i x21 A, swaprows i x21 B, i, j), A, B,\n                          i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 3. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n        xb = (\\<lambda>i. A $$ (i, j))\\<rbrakk>\n       \\<Longrightarrow> ((eliminate_entries xb A i j,\n                           eliminate_entries xb B i j, Suc i, Suc j),\n                          A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 4. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n        xb = inverse xaa\\<rbrakk>\n       \\<Longrightarrow> ((multrow i xb A, multrow i xb B, i, j), A, B, i,\n                          j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]", "from ne"], ["proof (chain)\npicking this:\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  i' # is", "have \"i' \\<in> set ([ i' . i' <- [Suc i ..< nr],  A $$ (i',j) \\<noteq> 0])\""], ["proof (prove)\nusing this:\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  i' # is\n\ngoal (1 subgoal):\n 1. i' \\<in> set (concat\n                   (map (\\<lambda>i'.\n                            if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                            else [])\n                     [Suc i..<nr]))", "by auto"], ["proof (state)\nthis:\n  i' \\<in> set (concat\n                 (map (\\<lambda>i'.\n                          if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                          else [])\n                   [Suc i..<nr]))\n\ngoal (4 subgoals):\n 1. \\<And>A B i j x xa xaa.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> ((A, B, i, Suc j), A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 2. \\<And>A B i j x xa xaa x21 x22.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        x21 # x22\\<rbrakk>\n       \\<Longrightarrow> ((swaprows i x21 A, swaprows i x21 B, i, j), A, B,\n                          i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 3. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n        xb = (\\<lambda>i. A $$ (i, j))\\<rbrakk>\n       \\<Longrightarrow> ((eliminate_entries xb A i j,\n                           eliminate_entries xb B i j, Suc i, Suc j),\n                          A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 4. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n        xb = inverse xaa\\<rbrakk>\n       \\<Longrightarrow> ((multrow i xb A, multrow i xb B, i, j), A, B, i,\n                          j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]", "with *"], ["proof (chain)\npicking this:\n  nr = dim_row A\n  nc = dim_col A\n  i < nr \\<and> j < nc\n  a = A $$ (i, j)\n  a = (0::'a)\n  i' \\<in> set (concat\n                 (map (\\<lambda>i'.\n                          if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                          else [])\n                   [Suc i..<nr]))", "show \"((swaprows i i' A, swaprows i i' B, i, j), A, B, i, j) \\<in> ?R\""], ["proof (prove)\nusing this:\n  nr = dim_row A\n  nc = dim_col A\n  i < nr \\<and> j < nc\n  a = A $$ (i, j)\n  a = (0::'a)\n  i' \\<in> set (concat\n                 (map (\\<lambda>i'.\n                          if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                          else [])\n                   [Suc i..<nr]))\n\ngoal (1 subgoal):\n 1. ((swaprows i i' A, swaprows i i' B, i, j), A, B, i, j)\n    \\<in> measures\n           [\\<lambda>(A, B, i, j). dim_col A - j,\n            \\<lambda>(A, B, i, j).\n               if A $$ (i, j) = (0::'a) then 2\n               else if A $$ (i, j) = (1::'a) then 0 else 1]", "by auto"], ["proof (state)\nthis:\n  ((swaprows i i' A, swaprows i i' B, i, j), A, B, i, j)\n  \\<in> measures\n         [\\<lambda>(A, B, i, j). dim_col A - j,\n          \\<lambda>(A, B, i, j).\n             if A $$ (i, j) = (0::'a) then 2\n             else if A $$ (i, j) = (1::'a) then 0 else 1]\n\ngoal (3 subgoals):\n 1. \\<And>A B i j x xa xaa.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa = (0::'a);\n        concat\n         (map (\\<lambda>i'.\n                  if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n           [Suc i..<x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> ((A, B, i, Suc j), A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 2. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n        xb = (\\<lambda>i. A $$ (i, j))\\<rbrakk>\n       \\<Longrightarrow> ((eliminate_entries xb A i j,\n                           eliminate_entries xb B i j, Suc i, Suc j),\n                          A, B, i, j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]\n 3. \\<And>A B i j x xa xaa xb.\n       \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n        xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n        xb = inverse xaa\\<rbrakk>\n       \\<Longrightarrow> ((multrow i xb A, multrow i xb B, i, j), A, B, i,\n                          j)\n                         \\<in> measures\n                                [\\<lambda>(A, B, i, j). dim_col A - j,\n                                 \\<lambda>(A, B, i, j).\n                                    if A $$ (i, j) = (0::'a) then 2\n                                    else if A $$ (i, j) = (1::'a) then 0\n   else 1]", "qed auto"], ["proof (state)\nthis:\n  All gauss_jordan_main_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "declare gauss_jordan_main.simps[simp del]"], ["", "definition \"gauss_jordan A B \\<equiv> gauss_jordan_main A B 0 0\""], ["", "lemma gauss_jordan_transform: assumes A: \"A \\<in> carrier_mat nr nc\" and B: \"B \\<in> carrier_mat nr nc'\"\n  and res: \"gauss_jordan (A :: 'a :: field mat) B = (A',B')\"\n  shows \"\\<exists> P \\<in> Units (ring_mat TYPE('a) nr b). A' = P * A \\<and> B' = P * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?U = \"Units (ring_mat TYPE('a) nr b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "interpret m: ring \"ring_mat TYPE('a) nr b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring (ring_mat TYPE('a) nr b)", "by (rule ring_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "fix i j :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "assume \"gauss_jordan_main A B i j = (A',B')\""], ["proof (state)\nthis:\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "with A B"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc'\n  gauss_jordan_main A B i j = (A', B')", "have \"\\<exists> P \\<in> ?U. A' = P * A \\<and> B' = P * B\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc'\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "proof (induction A B i j rule: gauss_jordan_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n                    gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P\n        \\<in>Units (ring_mat TYPE('a) nr b).\n  A' = P * A \\<and> B' = P * B;\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * swaprows i x21 A \\<and>\n                                B' = P * swaprows i x21 B;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc';\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * eliminate_entries xb A i j \\<and>\n                                B' = P * eliminate_entries xb B i j;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * multrow i xb A \\<and>\n                                B' = P * multrow i xb B;\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n        gauss_jordan_main A B i j = (A', B')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            A' = P * A \\<and> B' = P * B", "case (1 A B i j)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<?x]) =\n   [];\n   A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n   gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * A \\<and> B' = P * B\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<?x]) =\n   ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   swaprows i ?x21.0 B \\<in> carrier_mat nr nc';\n   gauss_jordan_main (swaprows i ?x21.0 A) (swaprows i ?x21.0 B) i j =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * swaprows i ?x21.0 A \\<and>\n                       B' = P * swaprows i ?x21.0 B\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a); ?xaa = (1::'a);\n   ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   eliminate_entries ?xb B i j \\<in> carrier_mat nr nc';\n   gauss_jordan_main (eliminate_entries ?xb A i j)\n    (eliminate_entries ?xb B i j) (Suc i) (Suc j) =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * eliminate_entries ?xb A i j \\<and>\n                       B' = P * eliminate_entries ?xb B i j\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a); ?xaa \\<noteq> (1::'a);\n   ?xb = inverse ?xaa; multrow i ?xb A \\<in> carrier_mat nr nc;\n   multrow i ?xb B \\<in> carrier_mat nr nc';\n   gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B) i j =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * multrow i ?xb A \\<and>\n                       B' = P * multrow i ?xb B\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc'\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n                    gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P\n        \\<in>Units (ring_mat TYPE('a) nr b).\n  A' = P * A \\<and> B' = P * B;\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * swaprows i x21 A \\<and>\n                                B' = P * swaprows i x21 B;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc';\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * eliminate_entries xb A i j \\<and>\n                                B' = P * eliminate_entries xb B i j;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * multrow i xb A \\<and>\n                                B' = P * multrow i xb B;\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n        gauss_jordan_main A B i j = (A', B')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            A' = P * A \\<and> B' = P * B", "note A = 1(5)"], ["proof (state)\nthis:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n                    gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P\n        \\<in>Units (ring_mat TYPE('a) nr b).\n  A' = P * A \\<and> B' = P * B;\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * swaprows i x21 A \\<and>\n                                B' = P * swaprows i x21 B;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc';\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * eliminate_entries xb A i j \\<and>\n                                B' = P * eliminate_entries xb B i j;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * multrow i xb A \\<and>\n                                B' = P * multrow i xb B;\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n        gauss_jordan_main A B i j = (A', B')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            A' = P * A \\<and> B' = P * B", "hence dim: \"dim_row A = nr\" \"dim_col A = nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row A = nr &&& dim_col A = nc", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n                    gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P\n        \\<in>Units (ring_mat TYPE('a) nr b).\n  A' = P * A \\<and> B' = P * B;\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * swaprows i x21 A \\<and>\n                                B' = P * swaprows i x21 B;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc';\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * eliminate_entries xb A i j \\<and>\n                                B' = P * eliminate_entries xb B i j;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * multrow i xb A \\<and>\n                                B' = P * multrow i xb B;\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n        gauss_jordan_main A B i j = (A', B')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            A' = P * A \\<and> B' = P * B", "note B = 1(6)"], ["proof (state)\nthis:\n  B \\<in> carrier_mat nr nc'\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n                    gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P\n        \\<in>Units (ring_mat TYPE('a) nr b).\n  A' = P * A \\<and> B' = P * B;\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * swaprows i x21 A \\<and>\n                                B' = P * swaprows i x21 B;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc';\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * eliminate_entries xb A i j \\<and>\n                                B' = P * eliminate_entries xb B i j;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * multrow i xb A \\<and>\n                                B' = P * multrow i xb B;\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n        gauss_jordan_main A B i j = (A', B')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            A' = P * A \\<and> B' = P * B", "hence dimB: \"dim_row B = nr\" \"dim_col B = nc'\""], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat nr nc'\n\ngoal (1 subgoal):\n 1. dim_row B = nr &&& dim_col B = nc'", "by auto"], ["proof (state)\nthis:\n  dim_row B = nr\n  dim_col B = nc'\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n                    gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P\n        \\<in>Units (ring_mat TYPE('a) nr b).\n  A' = P * A \\<and> B' = P * B;\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * swaprows i x21 A \\<and>\n                                B' = P * swaprows i x21 B;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc';\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * eliminate_entries xb A i j \\<and>\n                                B' = P * eliminate_entries xb B i j;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * multrow i xb A \\<and>\n                                B' = P * multrow i xb B;\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n        gauss_jordan_main A B i j = (A', B')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            A' = P * A \\<and> B' = P * B", "note IH = 1(1-4)[OF dim[symmetric]]"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr \\<and> j < nc; ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<nr]) =\n   [];\n   A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n   gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * A \\<and> B' = P * B\n  \\<lbrakk>i < nr \\<and> j < nc; ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<nr]) =\n   ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   swaprows i ?x21.0 B \\<in> carrier_mat nr nc';\n   gauss_jordan_main (swaprows i ?x21.0 A) (swaprows i ?x21.0 B) i j =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * swaprows i ?x21.0 A \\<and>\n                       B' = P * swaprows i ?x21.0 B\n  \\<lbrakk>i < nr \\<and> j < nc; ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a);\n   ?xaa = (1::'a); ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   eliminate_entries ?xb B i j \\<in> carrier_mat nr nc';\n   gauss_jordan_main (eliminate_entries ?xb A i j)\n    (eliminate_entries ?xb B i j) (Suc i) (Suc j) =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * eliminate_entries ?xb A i j \\<and>\n                       B' = P * eliminate_entries ?xb B i j\n  \\<lbrakk>i < nr \\<and> j < nc; ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a);\n   ?xaa \\<noteq> (1::'a); ?xb = inverse ?xaa;\n   multrow i ?xb A \\<in> carrier_mat nr nc;\n   multrow i ?xb B \\<in> carrier_mat nr nc';\n   gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B) i j =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * multrow i ?xb A \\<and>\n                       B' = P * multrow i ?xb B\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n                    gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P\n        \\<in>Units (ring_mat TYPE('a) nr b).\n  A' = P * A \\<and> B' = P * B;\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * swaprows i x21 A \\<and>\n                                B' = P * swaprows i x21 B;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc';\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * eliminate_entries xb A i j \\<and>\n                                B' = P * eliminate_entries xb B i j;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * multrow i xb A \\<and>\n                                B' = P * multrow i xb B;\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n        gauss_jordan_main A B i j = (A', B')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            A' = P * A \\<and> B' = P * B", "note res = 1(7)"], ["proof (state)\nthis:\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n                    gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P\n        \\<in>Units (ring_mat TYPE('a) nr b).\n  A' = P * A \\<and> B' = P * B;\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * swaprows i x21 A \\<and>\n                                B' = P * swaprows i x21 B;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc';\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * eliminate_entries xb A i j \\<and>\n                                B' = P * eliminate_entries xb B i j;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * multrow i xb A \\<and>\n                                B' = P * multrow i xb B;\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n        gauss_jordan_main A B i j = (A', B')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            A' = P * A \\<and> B' = P * B", "note simp = gauss_jordan_main.simps[of A B i j] Let_def"], ["proof (state)\nthis:\n  gauss_jordan_main A B i j =\n  (let nr = dim_row A; nc = dim_col A\n   in if i < nr \\<and> j < nc\n      then let aij = A $$ (i, j)\n           in if aij = (0::'a)\n              then case concat\n                         (map (\\<lambda>i'.\n                                  if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                                  else [])\n                           [Suc i..<nr]) of\n                   [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                   | i' # x \\<Rightarrow>\n                       gauss_jordan_main (swaprows i i' A) (swaprows i i' B)\n                        i j\n              else if aij = (1::'a)\n                   then let v = \\<lambda>i. A $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A i j)\n                            (eliminate_entries v B i j) (Suc i) (Suc j)\n                   else let iaij = inverse aij\n                        in gauss_jordan_main (multrow i iaij A)\n                            (multrow i iaij B) i j\n      else (A, B))\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n                    gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P\n        \\<in>Units (ring_mat TYPE('a) nr b).\n  A' = P * A \\<and> B' = P * B;\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * swaprows i x21 A \\<and>\n                                B' = P * swaprows i x21 B;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc';\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * eliminate_entries xb A i j \\<and>\n                                B' = P * eliminate_entries xb B i j;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * multrow i xb A \\<and>\n                                B' = P * multrow i xb B;\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n        gauss_jordan_main A B i j = (A', B')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            A' = P * A \\<and> B' = P * B", "let ?g = \"gauss_jordan_main A B i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B i j.\n       \\<lbrakk>\\<And>x xa xaa.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n                    gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>P\n        \\<in>Units (ring_mat TYPE('a) nr b).\n  A' = P * A \\<and> B' = P * B;\n        \\<And>x xa xaa x21 x22.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            swaprows i x21 B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * swaprows i x21 A \\<and>\n                                B' = P * swaprows i x21 B;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            eliminate_entries xb B i j \\<in> carrier_mat nr nc';\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * eliminate_entries xb A i j \\<and>\n                                B' = P * eliminate_entries xb B i j;\n        \\<And>x xa xaa xb.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            multrow i xb B \\<in> carrier_mat nr nc';\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B')\\<rbrakk>\n           \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                                A' = P * multrow i xb A \\<and>\n                                B' = P * multrow i xb B;\n        A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n        gauss_jordan_main A B i j = (A', B')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                            A' = P * A \\<and> B' = P * B", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "proof (cases \"i < nr \\<and> j < nc\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "case False"], ["proof (state)\nthis:\n  \\<not> (i < nr \\<and> j < nc)\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "with res"], ["proof (chain)\npicking this:\n  gauss_jordan_main A B i j = (A', B')\n  \\<not> (i < nr \\<and> j < nc)", "have res: \"A' = A\" \"B' = B\""], ["proof (prove)\nusing this:\n  gauss_jordan_main A B i j = (A', B')\n  \\<not> (i < nr \\<and> j < nc)\n\ngoal (1 subgoal):\n 1. A' = A &&& B' = B", "unfolding simp dim"], ["proof (prove)\nusing this:\n  (if i < nr \\<and> j < nc\n   then if A $$ (i, j) = (0::'a)\n        then case concat\n                   (map (\\<lambda>i'.\n                            if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                            else [])\n                     [Suc i..<nr]) of\n             [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n        else if A $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                   (multrow i (inverse (A $$ (i, j))) B) i j\n   else (A, B)) =\n  (A', B')\n  \\<not> (i < nr \\<and> j < nc)\n\ngoal (1 subgoal):\n 1. A' = A &&& B' = B", "by auto"], ["proof (state)\nthis:\n  A' = A\n  B' = B\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "unfolding res"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A = P * A \\<and> B = P * B", "by (rule bexI[of _ \"1\\<^sub>m nr\"], insert A B, auto simp: Units_def ring_mat_def)"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "case True"], ["proof (state)\nthis:\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note valid = this"], ["proof (state)\nthis:\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note IH = IH[OF valid refl]"], ["proof (state)\nthis:\n  \\<lbrakk>A $$ (i, j) = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<nr]) =\n   [];\n   A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n   gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * A \\<and> B' = P * B\n  \\<lbrakk>A $$ (i, j) = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<nr]) =\n   ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   swaprows i ?x21.0 B \\<in> carrier_mat nr nc';\n   gauss_jordan_main (swaprows i ?x21.0 A) (swaprows i ?x21.0 B) i j =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * swaprows i ?x21.0 A \\<and>\n                       B' = P * swaprows i ?x21.0 B\n  \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) = (1::'a);\n   ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   eliminate_entries ?xb B i j \\<in> carrier_mat nr nc';\n   gauss_jordan_main (eliminate_entries ?xb A i j)\n    (eliminate_entries ?xb B i j) (Suc i) (Suc j) =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * eliminate_entries ?xb A i j \\<and>\n                       B' = P * eliminate_entries ?xb B i j\n  \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) \\<noteq> (1::'a);\n   ?xb = inverse (A $$ (i, j)); multrow i ?xb A \\<in> carrier_mat nr nc;\n   multrow i ?xb B \\<in> carrier_mat nr nc';\n   gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B) i j =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * multrow i ?xb A \\<and>\n                       B' = P * multrow i ?xb B\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "proof (cases \"A $$ (i,j) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "case False"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note nZ = this"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note IH = IH(3-4)[OF nZ]"], ["proof (state)\nthis:\n  \\<lbrakk>A $$ (i, j) = (1::'a); ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   eliminate_entries ?xb B i j \\<in> carrier_mat nr nc';\n   gauss_jordan_main (eliminate_entries ?xb A i j)\n    (eliminate_entries ?xb B i j) (Suc i) (Suc j) =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * eliminate_entries ?xb A i j \\<and>\n                       B' = P * eliminate_entries ?xb B i j\n  \\<lbrakk>A $$ (i, j) \\<noteq> (1::'a); ?xb = inverse (A $$ (i, j));\n   multrow i ?xb A \\<in> carrier_mat nr nc;\n   multrow i ?xb B \\<in> carrier_mat nr nc';\n   gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B) i j =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * multrow i ?xb A \\<and>\n                       B' = P * multrow i ?xb B\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "proof (cases \"A $$ (i,j) = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "case False"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (1::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note nO = this"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (1::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?inv = \"inverse (A $$ (i,j))\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from nO nZ valid res"], ["proof (chain)\npicking this:\n  A $$ (i, j) \\<noteq> (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')", "have \"gauss_jordan_main (multrow i ?inv A) (multrow i ?inv B) i j = (A',B')\""], ["proof (prove)\nusing this:\n  A $$ (i, j) \\<noteq> (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n     (multrow i (inverse (A $$ (i, j))) B) i j =\n    (A', B')", "unfolding simp dim"], ["proof (prove)\nusing this:\n  A $$ (i, j) \\<noteq> (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  (if i < nr \\<and> j < nc\n   then if A $$ (i, j) = (0::'a)\n        then case concat\n                   (map (\\<lambda>i'.\n                            if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                            else [])\n                     [Suc i..<nr]) of\n             [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n        else if A $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                   (multrow i (inverse (A $$ (i, j))) B) i j\n   else (A, B)) =\n  (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n     (multrow i (inverse (A $$ (i, j))) B) i j =\n    (A', B')", "by simp"], ["proof (state)\nthis:\n  gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n   (multrow i (inverse (A $$ (i, j))) B) i j =\n  (A', B')\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note IH = IH(2)[OF nO refl, unfolded multrow_carrier, OF A B this]"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * multrow i (inverse (A $$ (i, j))) A \\<and>\n     B' = P * multrow i (inverse (A $$ (i, j))) B\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from IH"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * multrow i (inverse (A $$ (i, j))) A \\<and>\n     B' = P * multrow i (inverse (A $$ (i, j))) B", "obtain P where P: \"P \\<in> ?U\" and\n              id: \"A' = P * multrow i ?inv A\" \"B' = P * multrow i ?inv B\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * multrow i (inverse (A $$ (i, j))) A \\<and>\n     B' = P * multrow i (inverse (A $$ (i, j))) B\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) nr b);\n         A' = P * multrow i (inverse (A $$ (i, j))) A;\n         B' = P * multrow i (inverse (A $$ (i, j))) B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) nr b)\n  A' = P * multrow i (inverse (A $$ (i, j))) A\n  B' = P * multrow i (inverse (A $$ (i, j))) B\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?Inv = \"multrow_mat nr i ?inv\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from nZ valid"], ["proof (chain)\npicking this:\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc", "have \"i < nr\" \"?inv \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. i < nr &&& inverse (A $$ (i, j)) \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  i < nr\n  inverse (A $$ (i, j)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from multrow_mat_Unit[OF this]"], ["proof (chain)\npicking this:\n  multrow_mat nr i (inverse (A $$ (i, j)))\n  \\<in> Units (ring_mat TYPE('a) nr ?b)", "have Inv: \"?Inv \\<in> ?U\""], ["proof (prove)\nusing this:\n  multrow_mat nr i (inverse (A $$ (i, j)))\n  \\<in> Units (ring_mat TYPE('a) nr ?b)\n\ngoal (1 subgoal):\n 1. multrow_mat nr i (inverse (A $$ (i, j)))\n    \\<in> Units (ring_mat TYPE('a) nr b)", "."], ["proof (state)\nthis:\n  multrow_mat nr i (inverse (A $$ (i, j)))\n  \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from m.Units_m_closed[OF P Inv]"], ["proof (chain)\npicking this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) nr b\\<^esub>\n  multrow_mat nr i (inverse (A $$ (i, j)))\n  \\<in> Units (ring_mat TYPE('a) nr b)", "have PI: \"P * ?Inv \\<in> ?U\""], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) nr b\\<^esub>\n  multrow_mat nr i (inverse (A $$ (i, j)))\n  \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. P * multrow_mat nr i (inverse (A $$ (i, j)))\n    \\<in> Units (ring_mat TYPE('a) nr b)", "unfolding ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n  multrow_mat nr i (inverse (A $$ (i, j)))\n  \\<in> Units\n         \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n            one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n            \\<dots> = b\\<rparr>\n\ngoal (1 subgoal):\n 1. P * multrow_mat nr i (inverse (A $$ (i, j)))\n    \\<in> Units\n           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n              \\<dots> = b\\<rparr>", "by simp"], ["proof (state)\nthis:\n  P * multrow_mat nr i (inverse (A $$ (i, j)))\n  \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from m.Units_closed[OF P]"], ["proof (chain)\npicking this:\n  P \\<in> carrier (ring_mat TYPE('a) nr b)", "have P: \"P \\<in> carrier_mat nr nr\""], ["proof (prove)\nusing this:\n  P \\<in> carrier (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "unfolding ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> carrier\n           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n              \\<dots> = b\\<rparr>\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "by simp"], ["proof (state)\nthis:\n  P \\<in> carrier_mat nr nr\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Pa\\<in>Units (ring_mat TYPE('a) nr b).\n       P * multrow i (inverse (A $$ (i, j))) A = Pa * A \\<and>\n       P * multrow i (inverse (A $$ (i, j))) B = Pa * B", "unfolding multrow_mat[OF A] multrow_mat[OF B]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Pa\\<in>Units (ring_mat TYPE('a) nr b).\n       P * (multrow_mat nr i (inverse (A $$ (i, j))) * A) = Pa * A \\<and>\n       P * (multrow_mat nr i (inverse (A $$ (i, j))) * B) = Pa * B", "by (rule bexI[OF _ PI], intro conjI, \n                rule assoc_mult_mat[symmetric, OF P _ A], simp, \n                rule assoc_mult_mat[symmetric, OF P _ B], simp)"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "case True"], ["proof (state)\nthis:\n  A $$ (i, j) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note O = this"], ["proof (state)\nthis:\n  A $$ (i, j) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?is = \"filter (\\<lambda> i'. i' \\<noteq> i) [0 ..< nr]\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?ais = \"map (\\<lambda> i'. (-A $$ (i',j), i')) ?is\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?E = \"\\<lambda> B. eliminate_entries (\\<lambda> i. A $$ (i,j)) B i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?EE = \"\\<lambda> B. eliminate_entries_rec B i ?ais\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?A = \"?E A\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?B = \"?E B\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?AA = \"?EE A\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?BB = \"?EE B\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from O nZ valid res"], ["proof (chain)\npicking this:\n  A $$ (i, j) = (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')", "have \"gauss_jordan_main ?A ?B (Suc i) (Suc j) = (A',B')\""], ["proof (prove)\nusing this:\n  A $$ (i, j) = (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n     (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j) (Suc i) (Suc j) =\n    (A', B')", "unfolding simp dim"], ["proof (prove)\nusing this:\n  A $$ (i, j) = (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  (if i < nr \\<and> j < nc\n   then if A $$ (i, j) = (0::'a)\n        then case concat\n                   (map (\\<lambda>i'.\n                            if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                            else [])\n                     [Suc i..<nr]) of\n             [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n        else if A $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                   (multrow i (inverse (A $$ (i, j))) B) i j\n   else (A, B)) =\n  (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n     (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j) (Suc i) (Suc j) =\n    (A', B')", "by simp"], ["proof (state)\nthis:\n  gauss_jordan_main (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j) (Suc i) (Suc j) =\n  (A', B')\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note IH = IH(1)[OF O refl carrier_eliminate_entries(1)[OF A] carrier_eliminate_entries(1)[OF B] this]"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j \\<and>\n     B' = P * eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from IH"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j \\<and>\n     B' = P * eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j", "obtain P where P: \"P \\<in> ?U\" and id: \"A' = P * ?A\" \"B' = P * ?B\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j \\<and>\n     B' = P * eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) nr b);\n         A' = P * eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j;\n         B' = P * eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) nr b)\n  A' = P * eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j\n  B' = P * eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "have *: \"j < dim_col A\" \"i < dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < dim_col A &&& i < dim_row A", "by (auto simp add: dim valid)"], ["proof (state)\nthis:\n  j < dim_col A\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "have \"\\<exists>P\\<in>?U. \\<forall> B nc. B \\<in> carrier_mat nr nc \\<longrightarrow> ?EE B = P * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       \\<forall>B nc.\n          B \\<in> carrier_mat nr nc \\<longrightarrow>\n          eliminate_entries_rec B i\n           (map (\\<lambda>i'. (- A $$ (i', j), i'))\n             (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n          P * B", "by (rule Unit_prod_eliminate_entries, insert valid, auto)"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     \\<forall>B nc.\n        B \\<in> carrier_mat nr nc \\<longrightarrow>\n        eliminate_entries_rec B i\n         (map (\\<lambda>i'. (- A $$ (i', j), i'))\n           (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n        P * B\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "then"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     \\<forall>B nc.\n        B \\<in> carrier_mat nr nc \\<longrightarrow>\n        eliminate_entries_rec B i\n         (map (\\<lambda>i'. (- A $$ (i', j), i'))\n           (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n        P * B", "obtain Q where Q: \"Q \\<in> ?U\" and QQ: \"\\<And> B nc. B \\<in> carrier_mat nr nc \\<Longrightarrow> ?EE B = Q * B\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     \\<forall>B nc.\n        B \\<in> carrier_mat nr nc \\<longrightarrow>\n        eliminate_entries_rec B i\n         (map (\\<lambda>i'. (- A $$ (i', j), i'))\n           (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n        P * B\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>Q \\<in> Units (ring_mat TYPE('a) nr b);\n         \\<And>B nc.\n            B \\<in> carrier_mat nr nc \\<Longrightarrow>\n            eliminate_entries_rec B i\n             (map (\\<lambda>i'. (- A $$ (i', j), i'))\n               (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n            Q * B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Q \\<in> Units (ring_mat TYPE('a) nr b)\n  ?B \\<in> carrier_mat nr ?nc \\<Longrightarrow>\n  eliminate_entries_rec ?B i\n   (map (\\<lambda>i'. (- A $$ (i', j), i'))\n     (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n  Q * ?B\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "{"], ["proof (state)\nthis:\n  Q \\<in> Units (ring_mat TYPE('a) nr b)\n  ?B \\<in> carrier_mat nr ?nc \\<Longrightarrow>\n  eliminate_entries_rec ?B i\n   (map (\\<lambda>i'. (- A $$ (i', j), i'))\n     (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n  Q * ?B\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "fix B :: \"'a mat\" and nc"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * Ba__", "assume B: \"B \\<in> carrier_mat nr nc\""], ["proof (state)\nthis:\n  B \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * Ba__", "with dim"], ["proof (chain)\npicking this:\n  dim_row A = nr\n  dim_col A = nc\n  B \\<in> carrier_mat nr nc", "have \"dim_row B = dim_row A\""], ["proof (prove)\nusing this:\n  dim_row A = nr\n  dim_col A = nc\n  B \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row B = dim_row A", "by auto"], ["proof (state)\nthis:\n  dim_row B = dim_row A\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * Ba__", "from eliminate_entries_convert[OF * this]"], ["proof (chain)\npicking this:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j =\n  eliminate_entries_rec B i\n   (map (\\<lambda>i. (- A $$ (i, j), i))\n     (filter (\\<lambda>i. i \\<noteq> i) [0..<dim_row A]))", "have \"?E B = ?EE B\""], ["proof (prove)\nusing this:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j =\n  eliminate_entries_rec B i\n   (map (\\<lambda>i. (- A $$ (i, j), i))\n     (filter (\\<lambda>i. i \\<noteq> i) [0..<dim_row A]))\n\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j =\n    eliminate_entries_rec B i\n     (map (\\<lambda>i'. (- A $$ (i', j), i'))\n       (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr]))", "using dim"], ["proof (prove)\nusing this:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j =\n  eliminate_entries_rec B i\n   (map (\\<lambda>i. (- A $$ (i, j), i))\n     (filter (\\<lambda>i. i \\<noteq> i) [0..<dim_row A]))\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j =\n    eliminate_entries_rec B i\n     (map (\\<lambda>i'. (- A $$ (i', j), i'))\n       (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr]))", "by simp"], ["proof (state)\nthis:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j =\n  eliminate_entries_rec B i\n   (map (\\<lambda>i'. (- A $$ (i', j), i'))\n     (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr]))\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * Ba__", "also"], ["proof (state)\nthis:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j =\n  eliminate_entries_rec B i\n   (map (\\<lambda>i'. (- A $$ (i', j), i'))\n     (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr]))\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * Ba__", "have \"\\<dots> = Q * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries_rec B i\n     (map (\\<lambda>i'. (- A $$ (i', j), i'))\n       (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n    Q * B", "using QQ[OF B]"], ["proof (prove)\nusing this:\n  eliminate_entries_rec B i\n   (map (\\<lambda>i'. (- A $$ (i', j), i'))\n     (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n  Q * B\n\ngoal (1 subgoal):\n 1. eliminate_entries_rec B i\n     (map (\\<lambda>i'. (- A $$ (i', j), i'))\n       (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n    Q * B", "by simp"], ["proof (state)\nthis:\n  eliminate_entries_rec B i\n   (map (\\<lambda>i'. (- A $$ (i', j), i'))\n     (filter (\\<lambda>i'. i' \\<noteq> i) [0..<nr])) =\n  Q * B\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * Ba__", "finally"], ["proof (chain)\npicking this:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j = Q * B", "have \"?E B = Q * B\""], ["proof (prove)\nusing this:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j = Q * B\n\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j = Q * B", "."], ["proof (state)\nthis:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j = Q * B\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * Ba__", "}"], ["proof (state)\nthis:\n  ?Bb2 \\<in> carrier_mat nr ?nca2 \\<Longrightarrow>\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) ?Bb2 i j = Q * ?Bb2\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note QQ = this"], ["proof (state)\nthis:\n  ?Bb2 \\<in> carrier_mat nr ?nca2 \\<Longrightarrow>\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) ?Bb2 i j = Q * ?Bb2\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "have id3: \"?A = Q * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j = Q * A", "by (rule QQ[OF A])"], ["proof (state)\nthis:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j = Q * A\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "have id4: \"?B = Q * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j = Q * B", "by (rule QQ[OF B])"], ["proof (state)\nthis:\n  eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j = Q * B\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from m.Units_closed[OF P]"], ["proof (chain)\npicking this:\n  P \\<in> carrier (ring_mat TYPE('a) nr b)", "have Pc: \"P \\<in> carrier_mat nr nr\""], ["proof (prove)\nusing this:\n  P \\<in> carrier (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "unfolding ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> carrier\n           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n              \\<dots> = b\\<rparr>\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "by simp"], ["proof (state)\nthis:\n  P \\<in> carrier_mat nr nr\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from m.Units_closed[OF Q]"], ["proof (chain)\npicking this:\n  Q \\<in> carrier (ring_mat TYPE('a) nr b)", "have Qc: \"Q \\<in> carrier_mat nr nr\""], ["proof (prove)\nusing this:\n  Q \\<in> carrier (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. Q \\<in> carrier_mat nr nr", "unfolding ring_mat_def"], ["proof (prove)\nusing this:\n  Q \\<in> carrier\n           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n              \\<dots> = b\\<rparr>\n\ngoal (1 subgoal):\n 1. Q \\<in> carrier_mat nr nr", "by simp"], ["proof (state)\nthis:\n  Q \\<in> carrier_mat nr nr\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from m.Units_m_closed[OF P Q]"], ["proof (chain)\npicking this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) nr b\\<^esub> Q\n  \\<in> Units (ring_mat TYPE('a) nr b)", "have PQ: \"P * Q \\<in> ?U\""], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) nr b\\<^esub> Q\n  \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. P * Q \\<in> Units (ring_mat TYPE('a) nr b)", "unfolding ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n  Q\n  \\<in> Units\n         \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n            one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n            \\<dots> = b\\<rparr>\n\ngoal (1 subgoal):\n 1. P * Q\n    \\<in> Units\n           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n              \\<dots> = b\\<rparr>", "by simp"], ["proof (state)\nthis:\n  P * Q \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Pa\\<in>Units (ring_mat TYPE('a) nr b).\n       P * eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j = Pa * A \\<and>\n       P * eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j = Pa * B", "unfolding id3 id4"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Pa\\<in>Units (ring_mat TYPE('a) nr b).\n       P * (Q * A) = Pa * A \\<and> P * (Q * B) = Pa * B", "by (rule bexI[OF _ PQ], rule conjI, \n              rule assoc_mult_mat[symmetric, OF Pc Qc A],\n              rule assoc_mult_mat[symmetric, OF Pc Qc B])"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "case True"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note Z = this"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "note IH = IH(1-2)[OF Z]"], ["proof (state)\nthis:\n  \\<lbrakk>concat\n            (map (\\<lambda>i'.\n                     if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n              [Suc i..<nr]) =\n           [];\n   A \\<in> carrier_mat nr nc; B \\<in> carrier_mat nr nc';\n   gauss_jordan_main A B i (Suc j) = (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * A \\<and> B' = P * B\n  \\<lbrakk>concat\n            (map (\\<lambda>i'.\n                     if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n              [Suc i..<nr]) =\n           ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   swaprows i ?x21.0 B \\<in> carrier_mat nr nc';\n   gauss_jordan_main (swaprows i ?x21.0 A) (swaprows i ?x21.0 B) i j =\n   (A', B')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n                       A' = P * swaprows i ?x21.0 A \\<and>\n                       B' = P * swaprows i ?x21.0 B\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "let ?is = \"[ i' . i' <- [Suc i ..< nr],  A $$ (i',j) \\<noteq> 0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "proof (cases ?is)"], ["proof (state)\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "case Nil"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  []\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "from Z valid res"], ["proof (chain)\npicking this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')", "have id: \"gauss_jordan_main A B i (Suc j) = (A',B')\""], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i (Suc j) = (A', B')", "unfolding simp dim Nil"], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  (if i < nr \\<and> j < nc\n   then if A $$ (i, j) = (0::'a)\n        then case [] of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n        else if A $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                   (multrow i (inverse (A $$ (i, j))) B) i j\n   else (A, B)) =\n  (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i (Suc j) = (A', B')", "by simp"], ["proof (state)\nthis:\n  gauss_jordan_main A B i (Suc j) = (A', B')\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "from IH(1)[OF Nil A B this]"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "unfolding id"], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "."], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "case (Cons i' iis)"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  i' # iis\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "from Z valid res"], ["proof (chain)\npicking this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')", "have \"gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j = (A',B')\""], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j = (A', B')", "unfolding simp dim Cons"], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  (if i < nr \\<and> j < nc\n   then if A $$ (i, j) = (0::'a)\n        then case i' # iis of\n             [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n        else if A $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                   (multrow i (inverse (A $$ (i, j))) B) i j\n   else (A, B)) =\n  (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j = (A', B')", "by simp"], ["proof (state)\nthis:\n  gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j = (A', B')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "from IH(2)[OF Cons, unfolded swaprows_carrier, OF A B this]"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * swaprows i i' A \\<and> B' = P * swaprows i i' B", "obtain P where P: \"P \\<in> ?U\" and\n              id: \"A' = P * swaprows i i' A\" \"B' = P * swaprows i i' B\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * swaprows i i' A \\<and> B' = P * swaprows i i' B\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) nr b);\n         A' = P * swaprows i i' A; B' = P * swaprows i i' B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) nr b)\n  A' = P * swaprows i i' A\n  B' = P * swaprows i i' B\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "let ?Swap = \"swaprows_mat nr i i'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "from Cons"], ["proof (chain)\npicking this:\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  i' # iis", "have \"i' \\<in> set ?is\""], ["proof (prove)\nusing this:\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  i' # iis\n\ngoal (1 subgoal):\n 1. i' \\<in> set (concat\n                   (map (\\<lambda>i'.\n                            if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                            else [])\n                     [Suc i..<nr]))", "by auto"], ["proof (state)\nthis:\n  i' \\<in> set (concat\n                 (map (\\<lambda>i'.\n                          if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                          else [])\n                   [Suc i..<nr]))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "with valid"], ["proof (chain)\npicking this:\n  i < nr \\<and> j < nc\n  i' \\<in> set (concat\n                 (map (\\<lambda>i'.\n                          if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                          else [])\n                   [Suc i..<nr]))", "have i': \"i < nr\" \"i' < nr\""], ["proof (prove)\nusing this:\n  i < nr \\<and> j < nc\n  i' \\<in> set (concat\n                 (map (\\<lambda>i'.\n                          if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                          else [])\n                   [Suc i..<nr]))\n\ngoal (1 subgoal):\n 1. i < nr &&& i' < nr", "by auto"], ["proof (state)\nthis:\n  i < nr\n  i' < nr\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "from swaprows_mat_Unit[OF this]"], ["proof (chain)\npicking this:\n  swaprows_mat nr i i' \\<in> Units (ring_mat TYPE(?'a) nr ?b)", "have Swap: \"?Swap \\<in> ?U\""], ["proof (prove)\nusing this:\n  swaprows_mat nr i i' \\<in> Units (ring_mat TYPE(?'a) nr ?b)\n\ngoal (1 subgoal):\n 1. swaprows_mat nr i i' \\<in> Units (ring_mat TYPE('a) nr b)", "."], ["proof (state)\nthis:\n  swaprows_mat nr i i' \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "from m.Units_m_closed[OF P Swap]"], ["proof (chain)\npicking this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) nr b\\<^esub> swaprows_mat nr i i'\n  \\<in> Units (ring_mat TYPE('a) nr b)", "have PI: \"P * ?Swap \\<in> ?U\""], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) nr b\\<^esub> swaprows_mat nr i i'\n  \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. P * swaprows_mat nr i i' \\<in> Units (ring_mat TYPE('a) nr b)", "unfolding ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n  swaprows_mat nr i i'\n  \\<in> Units\n         \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n            one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n            \\<dots> = b\\<rparr>\n\ngoal (1 subgoal):\n 1. P * swaprows_mat nr i i'\n    \\<in> Units\n           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n              \\<dots> = b\\<rparr>", "by simp"], ["proof (state)\nthis:\n  P * swaprows_mat nr i i' \\<in> Units (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "from m.Units_closed[OF P]"], ["proof (chain)\npicking this:\n  P \\<in> carrier (ring_mat TYPE('a) nr b)", "have P: \"P \\<in> carrier_mat nr nr\""], ["proof (prove)\nusing this:\n  P \\<in> carrier (ring_mat TYPE('a) nr b)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "unfolding ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> carrier\n           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+),\n              \\<dots> = b\\<rparr>\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "by simp"], ["proof (state)\nthis:\n  P \\<in> carrier_mat nr nr\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n          A' = P * A \\<and> B' = P * B", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "unfolding id swaprows_mat[OF A i'] swaprows_mat[OF B i']"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Pa\\<in>Units (ring_mat TYPE('a) nr b).\n       P * (swaprows_mat nr i i' * A) = Pa * A \\<and>\n       P * (swaprows_mat nr i i' * B) = Pa * B", "by (rule bexI[OF _ PI], rule conjI, \n              rule assoc_mult_mat[symmetric, OF P _ A], simp,\n              rule assoc_mult_mat[symmetric, OF P _ B], simp)"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "}"], ["proof (state)\nthis:\n  gauss_jordan_main A B ?i2 ?j2 = (A', B') \\<Longrightarrow>\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "from this[of 0 0, folded gauss_jordan_def, OF res]"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n       A' = P * A \\<and> B' = P * B", "."], ["proof (state)\nthis:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr b).\n     A' = P * A \\<and> B' = P * B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_jordan_carrier: assumes A: \"(A :: 'a :: field mat) \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nr nc'\" \n  and res: \"gauss_jordan A B = (A',B')\"\n  shows \"A' \\<in> carrier_mat nr nc\" \"B' \\<in> carrier_mat nr nc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat nr nc &&& B' \\<in> carrier_mat nr nc'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. A' \\<in> carrier_mat nr nc\n 2. B' \\<in> carrier_mat nr nc'", "from gauss_jordan_transform[OF A B res, of undefined]"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr undefined).\n     A' = P * A \\<and> B' = P * B", "obtain P where P: \"P \\<in> Units (ring_mat TYPE('a) nr undefined)\"\n    and id: \"A' = P * A\" \"B' = P * B\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr undefined).\n     A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) nr undefined); A' = P * A;\n         B' = P * B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) nr undefined)\n  A' = P * A\n  B' = P * B\n\ngoal (2 subgoals):\n 1. A' \\<in> carrier_mat nr nc\n 2. B' \\<in> carrier_mat nr nc'", "from P"], ["proof (chain)\npicking this:\n  P \\<in> Units (ring_mat TYPE('a) nr undefined)", "have P: \"P \\<in> carrier_mat nr nr\""], ["proof (prove)\nusing this:\n  P \\<in> Units (ring_mat TYPE('a) nr undefined)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "unfolding Units_def ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> {y \\<in> carrier\n                    \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n                       one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr,\n                       add = (+), \\<dots> = undefined\\<rparr>.\n           \\<exists>x\\<in>carrier\n                           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n                              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr,\n                              add = (+), \\<dots> = undefined\\<rparr>.\n              x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+), \\<dots> = undefined\\<rparr>\\<^esub>\n              y =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+), \\<dots> = undefined\\<rparr>\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+), \\<dots> = undefined\\<rparr>\\<^esub>\n              x =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+), \\<dots> = undefined\\<rparr>\\<^esub>}\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat nr nr", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat nr nr\n\ngoal (2 subgoals):\n 1. A' \\<in> carrier_mat nr nc\n 2. B' \\<in> carrier_mat nr nc'", "show \"A' \\<in> carrier_mat nr nc\" \"B' \\<in> carrier_mat nr nc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat nr nc &&& B' \\<in> carrier_mat nr nc'", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. P * A \\<in> carrier_mat nr nc &&& P * B \\<in> carrier_mat nr nc'", "using P A B"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc\n  B \\<in> carrier_mat nr nc'\n\ngoal (1 subgoal):\n 1. P * A \\<in> carrier_mat nr nc &&& P * B \\<in> carrier_mat nr nc'", "by auto"], ["proof (state)\nthis:\n  A' \\<in> carrier_mat nr nc\n  B' \\<in> carrier_mat nr nc'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition pivot_fun :: \"'a :: {zero,one} mat \\<Rightarrow> (nat \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"pivot_fun A f nc \\<equiv> let nr = dim_row A in \n    (\\<forall> i < nr. f i \\<le> nc \\<and> \n      (f i < nc \\<longrightarrow> A $$ (i, f i) = 1 \\<and> (\\<forall> i' < nr. i' \\<noteq> i \\<longrightarrow> A $$ (i',f i) = 0)) \\<and> \n      (\\<forall> j < f i. A $$ (i, j) = 0) \\<and>\n      (Suc i < nr \\<longrightarrow> f (Suc i) > f i \\<or> f (Suc i) = nc))\""], ["", "lemma pivot_funI: assumes d: \"dim_row A = nr\"\n  and *: \"\\<And> i. i < nr \\<Longrightarrow> f i \\<le> nc\"\n      \"\\<And> i j. i < nr \\<Longrightarrow> j < f i \\<Longrightarrow> A $$ (i,j) = 0\"\n      \"\\<And> i. i < nr \\<Longrightarrow> Suc i < nr \\<Longrightarrow> f (Suc i) > f i \\<or> f (Suc i) = nc\"\n      \"\\<And> i. i < nr \\<Longrightarrow> f i < nc \\<Longrightarrow> A $$ (i, f i) = 1\"\n      \"\\<And> i i'. i < nr \\<Longrightarrow> f i < nc \\<Longrightarrow> i' < nr \\<Longrightarrow> i' \\<noteq> i \\<Longrightarrow> A $$ (i',f i) = 0\"\n  shows \"pivot_fun A f nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun A f nc", "unfolding pivot_fun_def Let_def d"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<nr.\n       f i \\<le> nc \\<and>\n       (f i < nc \\<longrightarrow>\n        A $$ (i, f i) = (1::'a) \\<and>\n        (\\<forall>i'<nr.\n            i' \\<noteq> i \\<longrightarrow>\n            A $$ (i', f i) = (0::'a))) \\<and>\n       (\\<forall>j<f i. A $$ (i, j) = (0::'a)) \\<and>\n       (Suc i < nr \\<longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc)", "using *"], ["proof (prove)\nusing this:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> nc\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = nc\n  \\<lbrakk>?i < nr; f ?i < nc\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < nc; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i<nr.\n       f i \\<le> nc \\<and>\n       (f i < nc \\<longrightarrow>\n        A $$ (i, f i) = (1::'a) \\<and>\n        (\\<forall>i'<nr.\n            i' \\<noteq> i \\<longrightarrow>\n            A $$ (i', f i) = (0::'a))) \\<and>\n       (\\<forall>j<f i. A $$ (i, j) = (0::'a)) \\<and>\n       (Suc i < nr \\<longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc)", "by blast"], ["", "lemma pivot_funD: assumes d: \"dim_row A = nr\"\n  and p: \"pivot_fun A f nc\"\n  shows \"\\<And> i. i < nr \\<Longrightarrow> f i \\<le> nc\"\n      \"\\<And> i j. i < nr \\<Longrightarrow> j < f i \\<Longrightarrow> A $$ (i,j) = 0\"\n      \"\\<And> i. i < nr \\<Longrightarrow> Suc i < nr \\<Longrightarrow> f (Suc i) > f i \\<or> f (Suc i) = nc\"\n      \"\\<And> i. i < nr \\<Longrightarrow> f i < nc \\<Longrightarrow> A $$ (i, f i) = 1\"\n      \"\\<And> i i'. i < nr \\<Longrightarrow> f i < nc \\<Longrightarrow> i' < nr \\<Longrightarrow> i' \\<noteq> i \\<Longrightarrow> A $$ (i',f i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc) &&&\n     (\\<And>i j.\n         \\<lbrakk>i < nr; j < f i\\<rbrakk>\n         \\<Longrightarrow> A $$ (i, j) = (0::'a))) &&&\n    (\\<And>i.\n        \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n        \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc) &&&\n    (\\<And>i.\n        \\<lbrakk>i < nr; f i < nc\\<rbrakk>\n        \\<Longrightarrow> A $$ (i, f i) = (1::'a)) &&&\n    (\\<And>i i'.\n        \\<lbrakk>i < nr; f i < nc; i' < nr; i' \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> A $$ (i', f i) = (0::'a))", "using p"], ["proof (prove)\nusing this:\n  pivot_fun A f nc\n\ngoal (1 subgoal):\n 1. ((\\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc) &&&\n     (\\<And>i j.\n         \\<lbrakk>i < nr; j < f i\\<rbrakk>\n         \\<Longrightarrow> A $$ (i, j) = (0::'a))) &&&\n    (\\<And>i.\n        \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n        \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc) &&&\n    (\\<And>i.\n        \\<lbrakk>i < nr; f i < nc\\<rbrakk>\n        \\<Longrightarrow> A $$ (i, f i) = (1::'a)) &&&\n    (\\<And>i i'.\n        \\<lbrakk>i < nr; f i < nc; i' < nr; i' \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> A $$ (i', f i) = (0::'a))", "unfolding pivot_fun_def Let_def d"], ["proof (prove)\nusing this:\n  \\<forall>i<nr.\n     f i \\<le> nc \\<and>\n     (f i < nc \\<longrightarrow>\n      A $$ (i, f i) = (1::'a) \\<and>\n      (\\<forall>i'<nr.\n          i' \\<noteq> i \\<longrightarrow> A $$ (i', f i) = (0::'a))) \\<and>\n     (\\<forall>j<f i. A $$ (i, j) = (0::'a)) \\<and>\n     (Suc i < nr \\<longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc)\n\ngoal (1 subgoal):\n 1. ((\\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc) &&&\n     (\\<And>i j.\n         \\<lbrakk>i < nr; j < f i\\<rbrakk>\n         \\<Longrightarrow> A $$ (i, j) = (0::'a))) &&&\n    (\\<And>i.\n        \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n        \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc) &&&\n    (\\<And>i.\n        \\<lbrakk>i < nr; f i < nc\\<rbrakk>\n        \\<Longrightarrow> A $$ (i, f i) = (1::'a)) &&&\n    (\\<And>i i'.\n        \\<lbrakk>i < nr; f i < nc; i' < nr; i' \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> A $$ (i', f i) = (0::'a))", "by blast+"], ["", "lemma pivot_fun_multrow: assumes p: \"pivot_fun A f jj\"\n  and d: \"dim_row A = nr\" \"dim_col A = nc\"\n  and fi: \"f i0 = jj\"\n  and jj: \"jj \\<le> nc\"\n  shows \"pivot_fun (multrow i0 a A) f jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun (multrow i0 a A) f jj", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pivot_fun (multrow i0 a A) f jj", "note p = pivot_funD[OF d(1) p]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> jj\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = jj\n  \\<lbrakk>?i < nr; f ?i < jj\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < jj; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. pivot_fun (multrow i0 a A) f jj", "let ?A = \"multrow i0 a A\""], ["proof (state)\ngoal (1 subgoal):\n 1. pivot_fun (multrow i0 a A) f jj", "have \"dim_row ?A = nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (multrow i0 a A) = nr", "using d"], ["proof (prove)\nusing this:\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. dim_row (multrow i0 a A) = nr", "by simp"], ["proof (state)\nthis:\n  dim_row (multrow i0 a A) = nr\n\ngoal (1 subgoal):\n 1. pivot_fun (multrow i0 a A) f jj", "thus ?thesis"], ["proof (prove)\nusing this:\n  dim_row (multrow i0 a A) = nr\n\ngoal (1 subgoal):\n 1. pivot_fun (multrow i0 a A) f jj", "proof (rule pivot_funI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> jj\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i', f i) = (0::'a)", "fix i"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> jj\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i', f i) = (0::'a)", "assume i: \"i < nr\""], ["proof (state)\nthis:\n  i < nr\n\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> jj\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i', f i) = (0::'a)", "note p = p[OF i]"], ["proof (state)\nthis:\n  f i \\<le> jj\n  ?j < f i \\<Longrightarrow> A $$ (i, ?j) = (0::'a)\n  Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n  f i < jj \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n  \\<lbrakk>f i < jj; ?i' < nr; ?i' \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f i) = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> jj\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i', f i) = (0::'a)", "show \"f i \\<le> jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<le> jj", "by fact"], ["proof (state)\nthis:\n  f i \\<le> jj\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n 3. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i', f i) = (0::'a)", "show \"Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj", "by fact"], ["proof (state)\nthis:\n  Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i', f i) = (0::'a)", "{"], ["proof (state)\nthis:\n  Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i', f i) = (0::'a)", "fix i'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i', f i) = (0::'a)", "assume *: \"f i < jj\" \"i' < nr\" \"i' \\<noteq> i\""], ["proof (state)\nthis:\n  f i < jj\n  i' < nr\n  i' \\<noteq> i\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i', f i) = (0::'a)", "from p(5)[OF this]"], ["proof (chain)\npicking this:\n  A $$ (i', f i) = (0::'a)", "show \"?A $$ (i', f i) = 0\""], ["proof (prove)\nusing this:\n  A $$ (i', f i) = (0::'a)\n\ngoal (1 subgoal):\n 1. multrow i0 a A $$ (i', f i) = (0::'a)", "by (subst index_mat_multrow(1), insert * d jj, auto)"], ["proof (state)\nthis:\n  multrow i0 a A $$ (i', f i) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>f i < jj; ?i'2 < nr; ?i'2 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> multrow i0 a A $$ (?i'2, f i) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>f i < jj; ?i'2 < nr; ?i'2 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> multrow i0 a A $$ (?i'2, f i) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)", "assume *: \"f i < jj\""], ["proof (state)\nthis:\n  f i < jj\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)", "from p(4)[OF this]"], ["proof (chain)\npicking this:\n  A $$ (i, f i) = (1::'a)", "have A: \"A $$ (i, f i) = 1\""], ["proof (prove)\nusing this:\n  A $$ (i, f i) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, f i) = (1::'a)", "by auto"], ["proof (state)\nthis:\n  A $$ (i, f i) = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)", "show \"?A $$ (i, f i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multrow i0 a A $$ (i, f i) = (1::'a)", "by (subst index_mat_multrow(1), insert * d i A jj fi, auto)"], ["proof (state)\nthis:\n  multrow i0 a A $$ (i, f i) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)", "}"], ["proof (state)\nthis:\n  f i < jj \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)", "{"], ["proof (state)\nthis:\n  f i < jj \\<Longrightarrow> multrow i0 a A $$ (i, f i) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)", "assume j: \"j < f i\""], ["proof (state)\nthis:\n  j < f i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> multrow i0 a A $$ (i, j) = (0::'a)", "from p(2)[OF j]"], ["proof (chain)\npicking this:\n  A $$ (i, j) = (0::'a)", "show \"?A $$ (i, j) = 0\""], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. multrow i0 a A $$ (i, j) = (0::'a)", "by (subst index_mat_multrow(1), insert j d i p jj fi, auto)"], ["proof (state)\nthis:\n  multrow i0 a A $$ (i, j) = (0::'a)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?j2 < f i \\<Longrightarrow> multrow i0 a A $$ (i, ?j2) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_fun (multrow i0 a A) f jj\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pivot_fun_swaprows: assumes p: \"pivot_fun A f jj\"\n  and d: \"dim_row A = nr\" \"dim_col A = nc\"\n  and flk: \"f l = jj\" \"f k = jj\"\n  and nr: \"l < nr\" \"k < nr\"\n  and jj: \"jj \\<le> nc\"\n  shows \"pivot_fun (swaprows l k A) f jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun (swaprows l k A) f jj", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pivot_fun (swaprows l k A) f jj", "note pivot = pivot_funD[OF d(1) p]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> jj\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = jj\n  \\<lbrakk>?i < nr; f ?i < jj\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < jj; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. pivot_fun (swaprows l k A) f jj", "let ?A = \"swaprows l k A\""], ["proof (state)\ngoal (1 subgoal):\n 1. pivot_fun (swaprows l k A) f jj", "have \"dim_row ?A = nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (swaprows l k A) = nr", "using d"], ["proof (prove)\nusing this:\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. dim_row (swaprows l k A) = nr", "by simp"], ["proof (state)\nthis:\n  dim_row (swaprows l k A) = nr\n\ngoal (1 subgoal):\n 1. pivot_fun (swaprows l k A) f jj", "thus ?thesis"], ["proof (prove)\nusing this:\n  dim_row (swaprows l k A) = nr\n\ngoal (1 subgoal):\n 1. pivot_fun (swaprows l k A) f jj", "proof (rule pivot_funI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> jj\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i', f i) = (0::'a)", "fix i"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> jj\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i', f i) = (0::'a)", "assume i: \"i < nr\""], ["proof (state)\nthis:\n  i < nr\n\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> jj\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i', f i) = (0::'a)", "note p = pivot[OF i]"], ["proof (state)\nthis:\n  f i \\<le> jj\n  ?j < f i \\<Longrightarrow> A $$ (i, ?j) = (0::'a)\n  Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n  f i < jj \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n  \\<lbrakk>f i < jj; ?i' < nr; ?i' \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f i) = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> jj\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i', f i) = (0::'a)", "show \"f i \\<le> jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<le> jj", "by fact"], ["proof (state)\nthis:\n  f i \\<le> jj\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n 3. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i', f i) = (0::'a)", "show \"Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj", "by fact"], ["proof (state)\nthis:\n  Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i', f i) = (0::'a)", "{"], ["proof (state)\nthis:\n  Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = jj\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i', f i) = (0::'a)", "fix i'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i', f i) = (0::'a)", "assume *: \"f i < jj\" \"i' < nr\" \"i' \\<noteq> i\""], ["proof (state)\nthis:\n  f i < jj\n  i' < nr\n  i' \\<noteq> i\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i', f i) = (0::'a)", "from *(1) flk"], ["proof (chain)\npicking this:\n  f i < jj\n  f l = jj\n  f k = jj", "have diff: \"l \\<noteq> i\" \"k \\<noteq> i\""], ["proof (prove)\nusing this:\n  f i < jj\n  f l = jj\n  f k = jj\n\ngoal (1 subgoal):\n 1. l \\<noteq> i &&& k \\<noteq> i", "by auto"], ["proof (state)\nthis:\n  l \\<noteq> i\n  k \\<noteq> i\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < jj; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i', f i) = (0::'a)", "from p(5)[OF *] p(5)[OF *(1) nr(1) diff(1)] p(5)[OF *(1) nr(2) diff(2)]"], ["proof (chain)\npicking this:\n  A $$ (i', f i) = (0::'a)\n  A $$ (l, f i) = (0::'a)\n  A $$ (k, f i) = (0::'a)", "show \"?A $$ (i', f i) = 0\""], ["proof (prove)\nusing this:\n  A $$ (i', f i) = (0::'a)\n  A $$ (l, f i) = (0::'a)\n  A $$ (k, f i) = (0::'a)\n\ngoal (1 subgoal):\n 1. swaprows l k A $$ (i', f i) = (0::'a)", "by (subst index_mat_swaprows(1), insert * d jj, auto)"], ["proof (state)\nthis:\n  swaprows l k A $$ (i', f i) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>f i < jj; ?i'2 < nr; ?i'2 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> swaprows l k A $$ (?i'2, f i) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>f i < jj; ?i'2 < nr; ?i'2 \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> swaprows l k A $$ (?i'2, f i) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)", "assume *: \"f i < jj\""], ["proof (state)\nthis:\n  f i < jj\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)", "from p(4)[OF this]"], ["proof (chain)\npicking this:\n  A $$ (i, f i) = (1::'a)", "have A: \"A $$ (i, f i) = 1\""], ["proof (prove)\nusing this:\n  A $$ (i, f i) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, f i) = (1::'a)", "by auto"], ["proof (state)\nthis:\n  A $$ (i, f i) = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; f i < jj\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)", "show \"?A $$ (i, f i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swaprows l k A $$ (i, f i) = (1::'a)", "by (subst index_mat_swaprows(1), insert * d i A jj flk, auto)"], ["proof (state)\nthis:\n  swaprows l k A $$ (i, f i) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)", "}"], ["proof (state)\nthis:\n  f i < jj \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)", "{"], ["proof (state)\nthis:\n  f i < jj \\<Longrightarrow> swaprows l k A $$ (i, f i) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)", "assume j: \"j < f i\""], ["proof (state)\nthis:\n  j < f i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)", "with p(1) flk"], ["proof (chain)\npicking this:\n  f i \\<le> jj\n  f l = jj\n  f k = jj\n  j < f i", "have le: \"j < f l\" \"j < f k\""], ["proof (prove)\nusing this:\n  f i \\<le> jj\n  f l = jj\n  f k = jj\n  j < f i\n\ngoal (1 subgoal):\n 1. j < f l &&& j < f k", "by auto"], ["proof (state)\nthis:\n  j < f l\n  j < f k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> swaprows l k A $$ (i, j) = (0::'a)", "from p(2)[OF j] pivot(2)[OF nr(1) le(1)] pivot(2)[OF nr(2) le(2)]"], ["proof (chain)\npicking this:\n  A $$ (i, j) = (0::'a)\n  A $$ (l, j) = (0::'a)\n  A $$ (k, j) = (0::'a)", "show \"?A $$ (i, j) = 0\""], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n  A $$ (l, j) = (0::'a)\n  A $$ (k, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. swaprows l k A $$ (i, j) = (0::'a)", "by (subst index_mat_swaprows(1), insert j d i p jj, auto)"], ["proof (state)\nthis:\n  swaprows l k A $$ (i, j) = (0::'a)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?j2 < f i \\<Longrightarrow> swaprows l k A $$ (i, ?j2) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_fun (swaprows l k A) f jj\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pivot_fun_eliminate_entries: assumes p: \"pivot_fun A f jj\"\n  and d: \"dim_row A = nr\" \"dim_col A = nc\"\n  and fl: \"f l = jj\"\n  and nr: \"l < nr\"\n  and jj: \"jj \\<le> nc\"\nshows \"pivot_fun (eliminate_entries vs A l j) f jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "note pD = pivot_funD[OF d(1) p]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> jj\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = jj\n  \\<lbrakk>?i < nr; f ?i < jj\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < jj; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "{"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> jj\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = jj\n  \\<lbrakk>?i < nr; f ?i < jj\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < jj; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "assume *: \"i < nr\" \"j < f i\""], ["proof (state)\nthis:\n  i < nr\n  j < f i\n\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "from pD(1)[OF this(1)] this(2) jj"], ["proof (chain)\npicking this:\n  f i \\<le> jj\n  j < f i\n  jj \\<le> nc", "have j: \"j < nc\""], ["proof (prove)\nusing this:\n  f i \\<le> jj\n  j < f i\n  jj \\<le> nc\n\ngoal (1 subgoal):\n 1. j < nc", "by auto"], ["proof (state)\nthis:\n  j < nc\n\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "from pD nr fl * j"], ["proof (chain)\npicking this:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> jj\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = jj\n  \\<lbrakk>?i < nr; f ?i < jj\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < jj; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n  l < nr\n  f l = jj\n  i < nr\n  j < f i\n  j < nc", "have \"A $$ (l, j) = 0\""], ["proof (prove)\nusing this:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> jj\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = jj\n  \\<lbrakk>?i < nr; f ?i < jj\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < jj; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n  l < nr\n  f l = jj\n  i < nr\n  j < f i\n  j < nc\n\ngoal (1 subgoal):\n 1. A $$ (l, j) = (0::'a)", "by (meson less_le_trans)"], ["proof (state)\nthis:\n  A $$ (l, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "note j this"], ["proof (state)\nthis:\n  j < nc\n  A $$ (l, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?ja2 < f ?i2\\<rbrakk> \\<Longrightarrow> ?ja2 < nc\n  \\<lbrakk>?i2 < nr; ?ja2 < f ?i2\\<rbrakk>\n  \\<Longrightarrow> A $$ (l, ?ja2) = (0::'a)\n\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "note hint = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < nr; ?ja2 < f ?i2\\<rbrakk> \\<Longrightarrow> ?ja2 < nc\n  \\<lbrakk>?i2 < nr; ?ja2 < f ?i2\\<rbrakk>\n  \\<Longrightarrow> A $$ (l, ?ja2) = (0::'a)\n\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries vs A l j) f jj", "by (rule pivot_funI, insert fl nr jj pD, auto simp: eliminate_entries_gen_def d hint)"], ["proof (state)\nthis:\n  pivot_fun (eliminate_entries vs A l j) f jj\n\ngoal:\nNo subgoals!", "qed"], ["", "definition row_echelon_form :: \"'a :: {zero,one} mat \\<Rightarrow> bool\" where\n  \"row_echelon_form A \\<equiv> \\<exists> f. pivot_fun A f (dim_col A)\""], ["", "lemma pivot_fun_init: \"pivot_fun A (\\<lambda> _. 0) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun A (\\<lambda>_. 0) 0", "by (rule pivot_funI, auto)"], ["", "lemma gauss_jordan_main_row_echelon: \n  assumes \n    \"A \\<in> carrier_mat nr nc\"\n    \"gauss_jordan_main A B i j = (A',B')\"\n    \"pivot_fun A f j\" \n    \"\\<And> i'. i' < i \\<Longrightarrow> f i' < j\" \"\\<And> i'. i' \\<ge> i \\<Longrightarrow> f i' = j\"\n    \"i \\<le> nr\" \"j \\<le> nc\"\n  shows \"row_echelon_form A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "interpret m: ring \"ring_mat TYPE('a) nr b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring (ring_mat TYPE('a) nr b)", "by (rule ring_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  gauss_jordan_main A B i j = (A', B')\n  pivot_fun A f j\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. row_echelon_form A'", "proof (induct A B i j arbitrary: f rule: gauss_jordan_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "case (1 A B i j f)"], ["proof (state)\nthis:\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<?x]) =\n   [];\n   A \\<in> carrier_mat nr nc; gauss_jordan_main A B i (Suc j) = (A', B');\n   pivot_fun A ?f (Suc j); \\<And>i'. i' < i \\<Longrightarrow> ?f i' < Suc j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = Suc j; i \\<le> nr;\n   Suc j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<?x]) =\n   ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   gauss_jordan_main (swaprows i ?x21.0 A) (swaprows i ?x21.0 B) i j =\n   (A', B');\n   pivot_fun (swaprows i ?x21.0 A) ?f j;\n   \\<And>i'. i' < i \\<Longrightarrow> ?f i' < j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = j; i \\<le> nr;\n   j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a); ?xaa = (1::'a);\n   ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   gauss_jordan_main (eliminate_entries ?xb A i j)\n    (eliminate_entries ?xb B i j) (Suc i) (Suc j) =\n   (A', B');\n   pivot_fun (eliminate_entries ?xb A i j) ?f (Suc j);\n   \\<And>i'. i' < Suc i \\<Longrightarrow> ?f i' < Suc j;\n   \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> ?f i' = Suc j; Suc i \\<le> nr;\n   Suc j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>?x = dim_row A; ?xa = dim_col A; i < ?x \\<and> j < ?xa;\n   ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a); ?xaa \\<noteq> (1::'a);\n   ?xb = inverse ?xaa; multrow i ?xb A \\<in> carrier_mat nr nc;\n   gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B) i j = (A', B');\n   pivot_fun (multrow i ?xb A) ?f j;\n   \\<And>i'. i' < i \\<Longrightarrow> ?f i' < j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = j; i \\<le> nr;\n   j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  A \\<in> carrier_mat nr nc\n  gauss_jordan_main A B i j = (A', B')\n  pivot_fun A f j\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "note A = 1(5)"], ["proof (state)\nthis:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "hence dim: \"dim_row A = nr\" \"dim_col A = nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row A = nr &&& dim_col A = nc", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "note res = 1(6)"], ["proof (state)\nthis:\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "note pivot = 1(7)"], ["proof (state)\nthis:\n  pivot_fun A f j\n\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "note f = 1(8-9)"], ["proof (state)\nthis:\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j\n\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "note ij = 1(10-11)"], ["proof (state)\nthis:\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "note IH = 1(1-4)[OF dim[symmetric]]"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr \\<and> j < nc; ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<nr]) =\n   [];\n   A \\<in> carrier_mat nr nc; gauss_jordan_main A B i (Suc j) = (A', B');\n   pivot_fun A ?f (Suc j); \\<And>i'. i' < i \\<Longrightarrow> ?f i' < Suc j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = Suc j; i \\<le> nr;\n   Suc j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>i < nr \\<and> j < nc; ?xaa = A $$ (i, j); ?xaa = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<nr]) =\n   ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   gauss_jordan_main (swaprows i ?x21.0 A) (swaprows i ?x21.0 B) i j =\n   (A', B');\n   pivot_fun (swaprows i ?x21.0 A) ?f j;\n   \\<And>i'. i' < i \\<Longrightarrow> ?f i' < j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = j; i \\<le> nr;\n   j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>i < nr \\<and> j < nc; ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a);\n   ?xaa = (1::'a); ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   gauss_jordan_main (eliminate_entries ?xb A i j)\n    (eliminate_entries ?xb B i j) (Suc i) (Suc j) =\n   (A', B');\n   pivot_fun (eliminate_entries ?xb A i j) ?f (Suc j);\n   \\<And>i'. i' < Suc i \\<Longrightarrow> ?f i' < Suc j;\n   \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> ?f i' = Suc j; Suc i \\<le> nr;\n   Suc j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>i < nr \\<and> j < nc; ?xaa = A $$ (i, j); ?xaa \\<noteq> (0::'a);\n   ?xaa \\<noteq> (1::'a); ?xb = inverse ?xaa;\n   multrow i ?xb A \\<in> carrier_mat nr nc;\n   gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B) i j = (A', B');\n   pivot_fun (multrow i ?xb A) ?f j;\n   \\<And>i'. i' < i \\<Longrightarrow> ?f i' < j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = j; i \\<le> nr;\n   j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "note simp = gauss_jordan_main.simps[of A B i j] Let_def"], ["proof (state)\nthis:\n  gauss_jordan_main A B i j =\n  (let nr = dim_row A; nc = dim_col A\n   in if i < nr \\<and> j < nc\n      then let aij = A $$ (i, j)\n           in if aij = (0::'a)\n              then case concat\n                         (map (\\<lambda>i'.\n                                  if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                                  else [])\n                           [Suc i..<nr]) of\n                   [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n                   | i' # x \\<Rightarrow>\n                       gauss_jordan_main (swaprows i i' A) (swaprows i i' B)\n                        i j\n              else if aij = (1::'a)\n                   then let v = \\<lambda>i. A $$ (i, j)\n                        in gauss_jordan_main (eliminate_entries v A i j)\n                            (eliminate_entries v B i j) (Suc i) (Suc j)\n                   else let iaij = inverse aij\n                        in gauss_jordan_main (multrow i iaij A)\n                            (multrow i iaij B) i j\n      else (A, B))\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "let ?g = \"gauss_jordan_main A B i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B i j f.\n       \\<lbrakk>\\<And>x xa xaa f.\n                   \\<lbrakk>x = dim_row A; xa = dim_col A;\n                    i < x \\<and> j < xa; xaa = A $$ (i, j); xaa = (0::'a);\n                    concat\n                     (map (\\<lambda>i'.\n                              if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                              else [])\n                       [Suc i..<x]) =\n                    [];\n                    A \\<in> carrier_mat nr nc;\n                    gauss_jordan_main A B i (Suc j) = (A', B');\n                    pivot_fun A f (Suc j);\n                    \\<And>i'. i' < i \\<Longrightarrow> f i' < Suc j;\n                    \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n                    i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n                   \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa x21 x22 f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa = (0::'a);\n            concat\n             (map (\\<lambda>i'.\n                      if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n               [Suc i..<x]) =\n            x21 # x22;\n            swaprows i x21 A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (swaprows i x21 A) (swaprows i x21 B) i j =\n            (A', B');\n            pivot_fun (swaprows i x21 A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa = (1::'a);\n            xb = (\\<lambda>i. A $$ (i, j));\n            eliminate_entries xb A i j \\<in> carrier_mat nr nc;\n            gauss_jordan_main (eliminate_entries xb A i j)\n             (eliminate_entries xb B i j) (Suc i) (Suc j) =\n            (A', B');\n            pivot_fun (eliminate_entries xb A i j) f (Suc j);\n            \\<And>i'. i' < Suc i \\<Longrightarrow> f i' < Suc j;\n            \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> f i' = Suc j;\n            Suc i \\<le> nr; Suc j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        \\<And>x xa xaa xb f.\n           \\<lbrakk>x = dim_row A; xa = dim_col A; i < x \\<and> j < xa;\n            xaa = A $$ (i, j); xaa \\<noteq> (0::'a); xaa \\<noteq> (1::'a);\n            xb = inverse xaa; multrow i xb A \\<in> carrier_mat nr nc;\n            gauss_jordan_main (multrow i xb A) (multrow i xb B) i j =\n            (A', B');\n            pivot_fun (multrow i xb A) f j;\n            \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n            \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n            j \\<le> nc\\<rbrakk>\n           \\<Longrightarrow> row_echelon_form A';\n        A \\<in> carrier_mat nr nc; gauss_jordan_main A B i j = (A', B');\n        pivot_fun A f j; \\<And>i'. i' < i \\<Longrightarrow> f i' < j;\n        \\<And>i'. i \\<le> i' \\<Longrightarrow> f i' = j; i \\<le> nr;\n        j \\<le> nc\\<rbrakk>\n       \\<Longrightarrow> row_echelon_form A'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "proof (cases \"i < nr \\<and> j < nc\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow> row_echelon_form A'", "case False"], ["proof (state)\nthis:\n  \\<not> (i < nr \\<and> j < nc)\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow> row_echelon_form A'", "note nij = this"], ["proof (state)\nthis:\n  \\<not> (i < nr \\<and> j < nc)\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow> row_echelon_form A'", "with res"], ["proof (chain)\npicking this:\n  gauss_jordan_main A B i j = (A', B')\n  \\<not> (i < nr \\<and> j < nc)", "have id: \"A' = A\""], ["proof (prove)\nusing this:\n  gauss_jordan_main A B i j = (A', B')\n  \\<not> (i < nr \\<and> j < nc)\n\ngoal (1 subgoal):\n 1. A' = A", "unfolding simp dim"], ["proof (prove)\nusing this:\n  (if i < nr \\<and> j < nc\n   then if A $$ (i, j) = (0::'a)\n        then case concat\n                   (map (\\<lambda>i'.\n                            if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                            else [])\n                     [Suc i..<nr]) of\n             [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n        else if A $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                   (multrow i (inverse (A $$ (i, j))) B) i j\n   else (A, B)) =\n  (A', B')\n  \\<not> (i < nr \\<and> j < nc)\n\ngoal (1 subgoal):\n 1. A' = A", "by auto"], ["proof (state)\nthis:\n  A' = A\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow> row_echelon_form A'", "have \"pivot_fun A f nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun A f nc", "proof (cases \"j \\<ge> nc\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nc \\<le> j \\<Longrightarrow> pivot_fun A f nc\n 2. \\<not> nc \\<le> j \\<Longrightarrow> pivot_fun A f nc", "case True"], ["proof (state)\nthis:\n  nc \\<le> j\n\ngoal (2 subgoals):\n 1. nc \\<le> j \\<Longrightarrow> pivot_fun A f nc\n 2. \\<not> nc \\<le> j \\<Longrightarrow> pivot_fun A f nc", "with ij"], ["proof (chain)\npicking this:\n  i \\<le> nr\n  j \\<le> nc\n  nc \\<le> j", "have j: \"j = nc\""], ["proof (prove)\nusing this:\n  i \\<le> nr\n  j \\<le> nc\n  nc \\<le> j\n\ngoal (1 subgoal):\n 1. j = nc", "by auto"], ["proof (state)\nthis:\n  j = nc\n\ngoal (2 subgoals):\n 1. nc \\<le> j \\<Longrightarrow> pivot_fun A f nc\n 2. \\<not> nc \\<le> j \\<Longrightarrow> pivot_fun A f nc", "with pivot"], ["proof (chain)\npicking this:\n  pivot_fun A f j\n  j = nc", "show \"pivot_fun A f nc\""], ["proof (prove)\nusing this:\n  pivot_fun A f j\n  j = nc\n\ngoal (1 subgoal):\n 1. pivot_fun A f nc", "by simp"], ["proof (state)\nthis:\n  pivot_fun A f nc\n\ngoal (1 subgoal):\n 1. \\<not> nc \\<le> j \\<Longrightarrow> pivot_fun A f nc", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> nc \\<le> j \\<Longrightarrow> pivot_fun A f nc", "case False"], ["proof (state)\nthis:\n  \\<not> nc \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> nc \\<le> j \\<Longrightarrow> pivot_fun A f nc", "hence j: \"j < nc\""], ["proof (prove)\nusing this:\n  \\<not> nc \\<le> j\n\ngoal (1 subgoal):\n 1. j < nc", "by simp"], ["proof (state)\nthis:\n  j < nc\n\ngoal (1 subgoal):\n 1. \\<not> nc \\<le> j \\<Longrightarrow> pivot_fun A f nc", "from False nij ij"], ["proof (chain)\npicking this:\n  \\<not> nc \\<le> j\n  \\<not> (i < nr \\<and> j < nc)\n  i \\<le> nr\n  j \\<le> nc", "have i: \"i = nr\""], ["proof (prove)\nusing this:\n  \\<not> nc \\<le> j\n  \\<not> (i < nr \\<and> j < nc)\n  i \\<le> nr\n  j \\<le> nc\n\ngoal (1 subgoal):\n 1. i = nr", "by auto"], ["proof (state)\nthis:\n  i = nr\n\ngoal (1 subgoal):\n 1. \\<not> nc \\<le> j \\<Longrightarrow> pivot_fun A f nc", "note f = f[unfolded i]"], ["proof (state)\nthis:\n  ?i' < nr \\<Longrightarrow> f ?i' < j\n  nr \\<le> ?i' \\<Longrightarrow> f ?i' = j\n\ngoal (1 subgoal):\n 1. \\<not> nc \\<le> j \\<Longrightarrow> pivot_fun A f nc", "note p = pivot_funD[OF dim(1) pivot]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> j\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = j\n  \\<lbrakk>?i < nr; f ?i < j\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < j; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> nc \\<le> j \\<Longrightarrow> pivot_fun A f nc", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun A f nc", "proof (rule pivot_funI[OF dim(1)])"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < nc\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < nc; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', f i) = (0::'a)", "fix i"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < nc\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < nc; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', f i) = (0::'a)", "assume i: \"i < nr\""], ["proof (state)\nthis:\n  i < nr\n\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < nc\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < nc; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', f i) = (0::'a)", "note p = p[OF i]"], ["proof (state)\nthis:\n  f i \\<le> j\n  ?j < f i \\<Longrightarrow> A $$ (i, ?j) = (0::'a)\n  Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = j\n  f i < j \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n  \\<lbrakk>f i < j; ?i' < nr; ?i' \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f i) = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<And>i. i < nr \\<Longrightarrow> f i \\<le> nc\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc\n 4. \\<And>i.\n       \\<lbrakk>i < nr; f i < nc\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < nc; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', f i) = (0::'a)", "from p(1) j"], ["proof (chain)\npicking this:\n  f i \\<le> j\n  j < nc", "show \"f i \\<le> nc\""], ["proof (prove)\nusing this:\n  f i \\<le> j\n  j < nc\n\ngoal (1 subgoal):\n 1. f i \\<le> nc", "by simp"], ["proof (state)\nthis:\n  f i \\<le> nc\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc\n 3. \\<And>i.\n       \\<lbrakk>i < nr; f i < nc\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < nc; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', f i) = (0::'a)", "from f(1)[OF i]"], ["proof (chain)\npicking this:\n  f i < j", "have fij: \"f i < j\""], ["proof (prove)\nusing this:\n  f i < j\n\ngoal (1 subgoal):\n 1. f i < j", "."], ["proof (state)\nthis:\n  f i < j\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc\n 3. \\<And>i.\n       \\<lbrakk>i < nr; f i < nc\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < nc; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', f i) = (0::'a)", "from p(4)[OF fij]"], ["proof (chain)\npicking this:\n  A $$ (i, f i) = (1::'a)", "show \"A $$ (i, f i) = 1\""], ["proof (prove)\nusing this:\n  A $$ (i, f i) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, f i) = (1::'a)", "."], ["proof (state)\nthis:\n  A $$ (i, f i) = (1::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; f i < nc; i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', f i) = (0::'a)", "from p(5)[OF fij]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i' < nr; ?i' \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f i) = (0::'a)", "show \"\\<And> i'. i' < nr \\<Longrightarrow> i' \\<noteq> i \\<Longrightarrow> A $$ (i', f i) = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i' < nr; ?i' \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f i) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       \\<lbrakk>i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', f i) = (0::'a)", "."], ["proof (state)\nthis:\n  \\<lbrakk>?i' < nr; ?i' \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f i) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < f i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc", "show \"\\<And> j. j < f i \\<Longrightarrow> A $$ (i, j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. j < f i \\<Longrightarrow> A $$ (i, j) = (0::'a)", "by (rule p(2))"], ["proof (state)\nthis:\n  ?j < f i \\<Longrightarrow> A $$ (i, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc", "assume \"Suc i < nr\""], ["proof (state)\nthis:\n  Suc i < nr\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc", "with p(3)[OF this] f"], ["proof (chain)\npicking this:\n  f i < f (Suc i) \\<or> f (Suc i) = j\n  ?i' < nr \\<Longrightarrow> f ?i' < j\n  nr \\<le> ?i' \\<Longrightarrow> f ?i' = j\n  Suc i < nr", "show \"f i < f (Suc i) \\<or> f (Suc i) = nc\""], ["proof (prove)\nusing this:\n  f i < f (Suc i) \\<or> f (Suc i) = j\n  ?i' < nr \\<Longrightarrow> f ?i' < j\n  nr \\<le> ?i' \\<Longrightarrow> f ?i' = j\n  Suc i < nr\n\ngoal (1 subgoal):\n 1. f i < f (Suc i) \\<or> f (Suc i) = nc", "by auto"], ["proof (state)\nthis:\n  f i < f (Suc i) \\<or> f (Suc i) = nc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_fun A f nc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_fun A f nc\n\ngoal (2 subgoals):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'\n 2. \\<not> (i < nr \\<and> j < nc) \\<Longrightarrow> row_echelon_form A'", "thus ?thesis"], ["proof (prove)\nusing this:\n  pivot_fun A f nc\n\ngoal (1 subgoal):\n 1. row_echelon_form A'", "using pivot"], ["proof (prove)\nusing this:\n  pivot_fun A f nc\n  pivot_fun A f j\n\ngoal (1 subgoal):\n 1. row_echelon_form A'", "unfolding id row_echelon_form_def dim"], ["proof (prove)\nusing this:\n  pivot_fun A f nc\n  pivot_fun A f j\n\ngoal (1 subgoal):\n 1. \\<exists>f. pivot_fun A f nc", "by blast"], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'", "case True"], ["proof (state)\nthis:\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'", "note valid = this"], ["proof (state)\nthis:\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'", "hence sij: \"Suc i \\<le> nr\" \"Suc j \\<le> nc\""], ["proof (prove)\nusing this:\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. Suc i \\<le> nr &&& Suc j \\<le> nc", "by auto"], ["proof (state)\nthis:\n  Suc i \\<le> nr\n  Suc j \\<le> nc\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'", "note IH = IH[OF valid refl]"], ["proof (state)\nthis:\n  \\<lbrakk>A $$ (i, j) = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<nr]) =\n   [];\n   A \\<in> carrier_mat nr nc; gauss_jordan_main A B i (Suc j) = (A', B');\n   pivot_fun A ?f (Suc j); \\<And>i'. i' < i \\<Longrightarrow> ?f i' < Suc j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = Suc j; i \\<le> nr;\n   Suc j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>A $$ (i, j) = (0::'a);\n   concat\n    (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n      [Suc i..<nr]) =\n   ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   gauss_jordan_main (swaprows i ?x21.0 A) (swaprows i ?x21.0 B) i j =\n   (A', B');\n   pivot_fun (swaprows i ?x21.0 A) ?f j;\n   \\<And>i'. i' < i \\<Longrightarrow> ?f i' < j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = j; i \\<le> nr;\n   j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) = (1::'a);\n   ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   gauss_jordan_main (eliminate_entries ?xb A i j)\n    (eliminate_entries ?xb B i j) (Suc i) (Suc j) =\n   (A', B');\n   pivot_fun (eliminate_entries ?xb A i j) ?f (Suc j);\n   \\<And>i'. i' < Suc i \\<Longrightarrow> ?f i' < Suc j;\n   \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> ?f i' = Suc j; Suc i \\<le> nr;\n   Suc j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a); A $$ (i, j) \\<noteq> (1::'a);\n   ?xb = inverse (A $$ (i, j)); multrow i ?xb A \\<in> carrier_mat nr nc;\n   gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B) i j = (A', B');\n   pivot_fun (multrow i ?xb A) ?f j;\n   \\<And>i'. i' < i \\<Longrightarrow> ?f i' < j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = j; i \\<le> nr;\n   j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (1 subgoal):\n 1. i < nr \\<and> j < nc \\<Longrightarrow> row_echelon_form A'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "proof (cases \"A $$ (i,j) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow> row_echelon_form A'", "case False"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow> row_echelon_form A'", "note nZ = this"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow> row_echelon_form A'", "note IH = IH(3-4)[OF nZ]"], ["proof (state)\nthis:\n  \\<lbrakk>A $$ (i, j) = (1::'a); ?xb = (\\<lambda>i. A $$ (i, j));\n   eliminate_entries ?xb A i j \\<in> carrier_mat nr nc;\n   gauss_jordan_main (eliminate_entries ?xb A i j)\n    (eliminate_entries ?xb B i j) (Suc i) (Suc j) =\n   (A', B');\n   pivot_fun (eliminate_entries ?xb A i j) ?f (Suc j);\n   \\<And>i'. i' < Suc i \\<Longrightarrow> ?f i' < Suc j;\n   \\<And>i'. Suc i \\<le> i' \\<Longrightarrow> ?f i' = Suc j; Suc i \\<le> nr;\n   Suc j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>A $$ (i, j) \\<noteq> (1::'a); ?xb = inverse (A $$ (i, j));\n   multrow i ?xb A \\<in> carrier_mat nr nc;\n   gauss_jordan_main (multrow i ?xb A) (multrow i ?xb B) i j = (A', B');\n   pivot_fun (multrow i ?xb A) ?f j;\n   \\<And>i'. i' < i \\<Longrightarrow> ?f i' < j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = j; i \\<le> nr;\n   j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow> row_echelon_form A'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "proof (cases \"A $$ (i,j) = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow> row_echelon_form A'", "case False"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (1::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow> row_echelon_form A'", "note nO = this"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (1::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow> row_echelon_form A'", "let ?inv = \"inverse (A $$ (i,j))\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow> row_echelon_form A'", "let ?A = \"multrow i ?inv A\""], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow> row_echelon_form A'", "from nO nZ valid res"], ["proof (chain)\npicking this:\n  A $$ (i, j) \\<noteq> (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')", "have id: \"gauss_jordan_main (multrow i ?inv A) (multrow i ?inv B) i j = (A', B')\""], ["proof (prove)\nusing this:\n  A $$ (i, j) \\<noteq> (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n     (multrow i (inverse (A $$ (i, j))) B) i j =\n    (A', B')", "unfolding simp dim"], ["proof (prove)\nusing this:\n  A $$ (i, j) \\<noteq> (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  (if i < nr \\<and> j < nc\n   then if A $$ (i, j) = (0::'a)\n        then case concat\n                   (map (\\<lambda>i'.\n                            if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                            else [])\n                     [Suc i..<nr]) of\n             [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n        else if A $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                   (multrow i (inverse (A $$ (i, j))) B) i j\n   else (A, B)) =\n  (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n     (multrow i (inverse (A $$ (i, j))) B) i j =\n    (A', B')", "by simp"], ["proof (state)\nthis:\n  gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n   (multrow i (inverse (A $$ (i, j))) B) i j =\n  (A', B')\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow> row_echelon_form A'", "have \"pivot_fun ?A f j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun (multrow i (inverse (A $$ (i, j))) A) f j", "by (rule pivot_fun_multrow[OF pivot dim f(2) ij(2)], auto)"], ["proof (state)\nthis:\n  pivot_fun (multrow i (inverse (A $$ (i, j))) A) f j\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow> row_echelon_form A'", "note IH = IH(2)[OF nO refl, unfolded multrow_carrier, OF A id this f ij]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i'. i' < i \\<Longrightarrow> i' < i;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> i \\<le> i'\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'\n 2. A $$ (i, j) \\<noteq> (1::'a) \\<Longrightarrow> row_echelon_form A'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "using IH"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i'. i' < i \\<Longrightarrow> i' < i;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> i \\<le> i'\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (1 subgoal):\n 1. row_echelon_form A'", "."], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "case True"], ["proof (state)\nthis:\n  A $$ (i, j) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "note O = this"], ["proof (state)\nthis:\n  A $$ (i, j) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "let ?E = \"\\<lambda> B. eliminate_entries (\\<lambda> i. A $$ (i,j)) B i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "let ?A = \"?E A\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "let ?B = \"?E B\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "define E where \"E = ?A\""], ["proof (state)\nthis:\n  E = eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "let ?f = \"\\<lambda> i'. if i' = i then j else if i' > i then Suc j else f i'\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "have pivot: \"pivot_fun E f j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun E f j", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j) f j", "by (rule pivot_fun_eliminate_entries[OF pivot dim f(2)], insert valid, auto)"], ["proof (state)\nthis:\n  pivot_fun E f j\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "{"], ["proof (state)\nthis:\n  pivot_fun E f j\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "assume i': \"i' < nr\""], ["proof (state)\nthis:\n  i' < nr\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "have \"E $$ (i', j) = (if i' = i then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E $$ (i', j) = (if i' = i then 1::'a else (0::'a))", "unfolding E_def eliminate_entries_gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         if i \\<noteq> i then A $$ (i, j) - A $$ (i, j) * A $$ (i, j)\n         else A $$ (i, j)) $$\n    (i', j) =\n    (if i' = i then 1::'a else (0::'a))", "using dim O i' valid"], ["proof (prove)\nusing this:\n  dim_row A = nr\n  dim_col A = nc\n  A $$ (i, j) = (1::'a)\n  i' < nr\n  i < nr \\<and> j < nc\n\ngoal (1 subgoal):\n 1. mat (dim_row A) (dim_col A)\n     (\\<lambda>(i, j).\n         if i \\<noteq> i then A $$ (i, j) - A $$ (i, j) * A $$ (i, j)\n         else A $$ (i, j)) $$\n    (i', j) =\n    (if i' = i then 1::'a else (0::'a))", "by auto"], ["proof (state)\nthis:\n  E $$ (i', j) = (if i' = i then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "}"], ["proof (state)\nthis:\n  ?i'2 < nr \\<Longrightarrow>\n  E $$ (?i'2, j) = (if ?i'2 = i then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "note Ej = this"], ["proof (state)\nthis:\n  ?i'2 < nr \\<Longrightarrow>\n  E $$ (?i'2, j) = (if ?i'2 = i then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "have E: \"E \\<in> carrier_mat nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<in> carrier_mat nr nc", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j\n    \\<in> carrier_mat nr nc", "by (rule carrier_eliminate_entries[OF A])"], ["proof (state)\nthis:\n  E \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "hence dimE: \"dim_row E = nr\" \"dim_col E = nc\""], ["proof (prove)\nusing this:\n  E \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row E = nr &&& dim_col E = nc", "by auto"], ["proof (state)\nthis:\n  dim_row E = nr\n  dim_col E = nc\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "note pivot = pivot_funD[OF dimE(1) pivot]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> j\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> E $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = j\n  \\<lbrakk>?i < nr; f ?i < j\\<rbrakk>\n  \\<Longrightarrow> E $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < j; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> E $$ (?i', f ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "have \"pivot_fun E ?f (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun E\n     (\\<lambda>i'. if i' = i then j else if i < i' then Suc j else f i')\n     (Suc j)", "proof (rule pivot_funI[OF dimE(1)])"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (if i = i then j else if i < i then Suc j else f i) \\<le> Suc j\n 2. \\<And>i j.\n       \\<lbrakk>i < nr;\n        j < (if i = i then j else if i < i then Suc j else f i)\\<rbrakk>\n       \\<Longrightarrow> E $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 4. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "fix ii"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (if i = i then j else if i < i then Suc j else f i) \\<le> Suc j\n 2. \\<And>i j.\n       \\<lbrakk>i < nr;\n        j < (if i = i then j else if i < i then Suc j else f i)\\<rbrakk>\n       \\<Longrightarrow> E $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 4. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "assume ii: \"ii < nr\""], ["proof (state)\nthis:\n  ii < nr\n\ngoal (5 subgoals):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (if i = i then j else if i < i then Suc j else f i) \\<le> Suc j\n 2. \\<And>i j.\n       \\<lbrakk>i < nr;\n        j < (if i = i then j else if i < i then Suc j else f i)\\<rbrakk>\n       \\<Longrightarrow> E $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 4. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "note p = pivot[OF ii]"], ["proof (state)\nthis:\n  f ii \\<le> j\n  ?j < f ii \\<Longrightarrow> E $$ (ii, ?j) = (0::'a)\n  Suc ii < nr \\<Longrightarrow> f ii < f (Suc ii) \\<or> f (Suc ii) = j\n  f ii < j \\<Longrightarrow> E $$ (ii, f ii) = (1::'a)\n  \\<lbrakk>f ii < j; ?i' < nr; ?i' \\<noteq> ii\\<rbrakk>\n  \\<Longrightarrow> E $$ (?i', f ii) = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow>\n       (if i = i then j else if i < i then Suc j else f i) \\<le> Suc j\n 2. \\<And>i j.\n       \\<lbrakk>i < nr;\n        j < (if i = i then j else if i < i then Suc j else f i)\\<rbrakk>\n       \\<Longrightarrow> E $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 4. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "show \"?f ii \\<le> Suc j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ii = i then j else if i < ii then Suc j else f ii) \\<le> Suc j", "using p(1)"], ["proof (prove)\nusing this:\n  f ii \\<le> j\n\ngoal (1 subgoal):\n 1. (if ii = i then j else if i < ii then Suc j else f ii) \\<le> Suc j", "by simp"], ["proof (state)\nthis:\n  (if ii = i then j else if i < ii then Suc j else f ii) \\<le> Suc j\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr;\n        j < (if i = i then j else if i < i then Suc j else f i)\\<rbrakk>\n       \\<Longrightarrow> E $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 3. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "{"], ["proof (state)\nthis:\n  (if ii = i then j else if i < ii then Suc j else f ii) \\<le> Suc j\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr;\n        j < (if i = i then j else if i < i then Suc j else f i)\\<rbrakk>\n       \\<Longrightarrow> E $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 3. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "fix jj"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr;\n        j < (if i = i then j else if i < i then Suc j else f i)\\<rbrakk>\n       \\<Longrightarrow> E $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 3. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "assume jj: \"jj < ?f ii\""], ["proof (state)\nthis:\n  jj < (if ii = i then j else if i < ii then Suc j else f ii)\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr;\n        j < (if i = i then j else if i < i then Suc j else f i)\\<rbrakk>\n       \\<Longrightarrow> E $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 3. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "show \"E $$ (ii,jj) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E $$ (ii, jj) = (0::'a)", "proof (cases \"ii < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n 2. \\<not> ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "case True"], ["proof (state)\nthis:\n  ii < i\n\ngoal (2 subgoals):\n 1. ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n 2. \\<not> ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "with jj"], ["proof (chain)\npicking this:\n  jj < (if ii = i then j else if i < ii then Suc j else f ii)\n  ii < i", "have \"jj < f ii\""], ["proof (prove)\nusing this:\n  jj < (if ii = i then j else if i < ii then Suc j else f ii)\n  ii < i\n\ngoal (1 subgoal):\n 1. jj < f ii", "by auto"], ["proof (state)\nthis:\n  jj < f ii\n\ngoal (2 subgoals):\n 1. ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n 2. \\<not> ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "from p(2)[OF this]"], ["proof (chain)\npicking this:\n  E $$ (ii, jj) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  E $$ (ii, jj) = (0::'a)\n\ngoal (1 subgoal):\n 1. E $$ (ii, jj) = (0::'a)", "."], ["proof (state)\nthis:\n  E $$ (ii, jj) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> ii < i\n\ngoal (1 subgoal):\n 1. \\<not> ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "note ge = this"], ["proof (state)\nthis:\n  \\<not> ii < i\n\ngoal (1 subgoal):\n 1. \\<not> ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "with f"], ["proof (chain)\npicking this:\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j\n  \\<not> ii < i", "have fiij: \"f ii = j\""], ["proof (prove)\nusing this:\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j\n  \\<not> ii < i\n\ngoal (1 subgoal):\n 1. f ii = j", "by simp"], ["proof (state)\nthis:\n  f ii = j\n\ngoal (1 subgoal):\n 1. \\<not> ii < i \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. E $$ (ii, jj) = (0::'a)", "proof (cases \"i < ii\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n 2. \\<not> i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "case True"], ["proof (state)\nthis:\n  i < ii\n\ngoal (2 subgoals):\n 1. i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n 2. \\<not> i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "with jj"], ["proof (chain)\npicking this:\n  jj < (if ii = i then j else if i < ii then Suc j else f ii)\n  i < ii", "have jj: \"jj \\<le> j\""], ["proof (prove)\nusing this:\n  jj < (if ii = i then j else if i < ii then Suc j else f ii)\n  i < ii\n\ngoal (1 subgoal):\n 1. jj \\<le> j", "by auto"], ["proof (state)\nthis:\n  jj \\<le> j\n\ngoal (2 subgoals):\n 1. i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n 2. \\<not> i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. E $$ (ii, jj) = (0::'a)", "proof (cases \"jj < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jj < j \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n 2. \\<not> jj < j \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "case True"], ["proof (state)\nthis:\n  jj < j\n\ngoal (2 subgoals):\n 1. jj < j \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n 2. \\<not> jj < j \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "with p(2)[of jj] fiij"], ["proof (chain)\npicking this:\n  jj < f ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n  f ii = j\n  jj < j", "show ?thesis"], ["proof (prove)\nusing this:\n  jj < f ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n  f ii = j\n  jj < j\n\ngoal (1 subgoal):\n 1. E $$ (ii, jj) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  E $$ (ii, jj) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> jj < j \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> jj < j \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> jj < j\n\ngoal (1 subgoal):\n 1. \\<not> jj < j \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "with jj"], ["proof (chain)\npicking this:\n  jj \\<le> j\n  \\<not> jj < j", "have jj: \"jj = j\""], ["proof (prove)\nusing this:\n  jj \\<le> j\n  \\<not> jj < j\n\ngoal (1 subgoal):\n 1. jj = j", "by auto"], ["proof (state)\nthis:\n  jj = j\n\ngoal (1 subgoal):\n 1. \\<not> jj < j \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "with Ej[OF ii] True"], ["proof (chain)\npicking this:\n  E $$ (ii, j) = (if ii = i then 1::'a else (0::'a))\n  i < ii\n  jj = j", "show ?thesis"], ["proof (prove)\nusing this:\n  E $$ (ii, j) = (if ii = i then 1::'a else (0::'a))\n  i < ii\n  jj = j\n\ngoal (1 subgoal):\n 1. E $$ (ii, jj) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  E $$ (ii, jj) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E $$ (ii, jj) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> i < ii\n\ngoal (1 subgoal):\n 1. \\<not> i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "with ge"], ["proof (chain)\npicking this:\n  \\<not> ii < i\n  \\<not> i < ii", "have ii: \"ii = i\""], ["proof (prove)\nusing this:\n  \\<not> ii < i\n  \\<not> i < ii\n\ngoal (1 subgoal):\n 1. ii = i", "by simp"], ["proof (state)\nthis:\n  ii = i\n\ngoal (1 subgoal):\n 1. \\<not> i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "with jj"], ["proof (chain)\npicking this:\n  jj < (if ii = i then j else if i < ii then Suc j else f ii)\n  ii = i", "have jj: \"jj < j\""], ["proof (prove)\nusing this:\n  jj < (if ii = i then j else if i < ii then Suc j else f ii)\n  ii = i\n\ngoal (1 subgoal):\n 1. jj < j", "by simp"], ["proof (state)\nthis:\n  jj < j\n\ngoal (1 subgoal):\n 1. \\<not> i < ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)", "from p(2)[of jj] ii jj fiij"], ["proof (chain)\npicking this:\n  jj < f ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n  ii = i\n  jj < j\n  f ii = j", "show ?thesis"], ["proof (prove)\nusing this:\n  jj < f ii \\<Longrightarrow> E $$ (ii, jj) = (0::'a)\n  ii = i\n  jj < j\n  f ii = j\n\ngoal (1 subgoal):\n 1. E $$ (ii, jj) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  E $$ (ii, jj) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E $$ (ii, jj) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E $$ (ii, jj) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 2. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "}"], ["proof (state)\nthis:\n  ?jj2\n  < (if ii = i then j else if i < ii then Suc j else f ii) \\<Longrightarrow>\n  E $$ (ii, ?jj2) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 2. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "{"], ["proof (state)\nthis:\n  ?jj2\n  < (if ii = i then j else if i < ii then Suc j else f ii) \\<Longrightarrow>\n  E $$ (ii, ?jj2) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 2. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "assume \"Suc ii < nr\""], ["proof (state)\nthis:\n  Suc ii < nr\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i = i then j else if i < i then Suc j else f i)\n                         < (if Suc i = i then j\n                            else if i < Suc i then Suc j\n                                 else f (Suc i)) \\<or>\n                         (if Suc i = i then j\n                          else if i < Suc i then Suc j else f (Suc i)) =\n                         Suc j\n 2. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "from p(3)[OF this] f"], ["proof (chain)\npicking this:\n  f ii < f (Suc ii) \\<or> f (Suc ii) = j\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j", "show \"?f (Suc ii) > ?f ii \\<or> ?f (Suc ii) = Suc j\""], ["proof (prove)\nusing this:\n  f ii < f (Suc ii) \\<or> f (Suc ii) = j\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j\n\ngoal (1 subgoal):\n 1. (if ii = i then j else if i < ii then Suc j else f ii)\n    < (if Suc ii = i then j\n       else if i < Suc ii then Suc j else f (Suc ii)) \\<or>\n    (if Suc ii = i then j else if i < Suc ii then Suc j else f (Suc ii)) =\n    Suc j", "by auto"], ["proof (state)\nthis:\n  (if ii = i then j else if i < ii then Suc j else f ii)\n  < (if Suc ii = i then j\n     else if i < Suc ii then Suc j else f (Suc ii)) \\<or>\n  (if Suc ii = i then j else if i < Suc ii then Suc j else f (Suc ii)) =\n  Suc j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 2. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "}"], ["proof (state)\nthis:\n  Suc ii < nr \\<Longrightarrow>\n  (if ii = i then j else if i < ii then Suc j else f ii)\n  < (if Suc ii = i then j\n     else if i < Suc ii then Suc j else f (Suc ii)) \\<or>\n  (if Suc ii = i then j else if i < Suc ii then Suc j else f (Suc ii)) =\n  Suc j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 2. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "{"], ["proof (state)\nthis:\n  Suc ii < nr \\<Longrightarrow>\n  (if ii = i then j else if i < ii then Suc j else f ii)\n  < (if Suc ii = i then j\n     else if i < Suc ii then Suc j else f (Suc ii)) \\<or>\n  (if Suc ii = i then j else if i < Suc ii then Suc j else f (Suc ii)) =\n  Suc j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 2. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "assume fii: \"?f ii < Suc j\""], ["proof (state)\nthis:\n  (if ii = i then j else if i < ii then Suc j else f ii) < Suc j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i, if i = i then j\n                             else if i < i then Suc j else f i) =\n                         (1::'a)\n 2. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "show \"E $$ (ii, ?f ii) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)", "proof (cases \"ii = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow>\n    E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)\n 2. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)", "case True"], ["proof (state)\nthis:\n  ii = i\n\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow>\n    E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)\n 2. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)", "with Ej[of i] valid"], ["proof (chain)\npicking this:\n  i < nr \\<Longrightarrow> E $$ (i, j) = (if i = i then 1::'a else (0::'a))\n  i < nr \\<and> j < nc\n  ii = i", "show ?thesis"], ["proof (prove)\nusing this:\n  i < nr \\<Longrightarrow> E $$ (i, j) = (if i = i then 1::'a else (0::'a))\n  i < nr \\<and> j < nc\n  ii = i\n\ngoal (1 subgoal):\n 1. E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)", "by auto"], ["proof (state)\nthis:\n  E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) = (1::'a)\n\ngoal (1 subgoal):\n 1. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)", "case False"], ["proof (state)\nthis:\n  ii \\<noteq> i\n\ngoal (1 subgoal):\n 1. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)", "with fii"], ["proof (chain)\npicking this:\n  (if ii = i then j else if i < ii then Suc j else f ii) < Suc j\n  ii \\<noteq> i", "have ii: \"ii < i\""], ["proof (prove)\nusing this:\n  (if ii = i then j else if i < ii then Suc j else f ii) < Suc j\n  ii \\<noteq> i\n\ngoal (1 subgoal):\n 1. ii < i", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  ii < i\n\ngoal (1 subgoal):\n 1. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)", "from f(1)[OF this]"], ["proof (chain)\npicking this:\n  f ii < j", "have \"f ii < j\""], ["proof (prove)\nusing this:\n  f ii < j\n\ngoal (1 subgoal):\n 1. f ii < j", "by auto"], ["proof (state)\nthis:\n  f ii < j\n\ngoal (1 subgoal):\n 1. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)", "from p(4)[OF this] ii"], ["proof (chain)\npicking this:\n  E $$ (ii, f ii) = (1::'a)\n  ii < i", "show ?thesis"], ["proof (prove)\nusing this:\n  E $$ (ii, f ii) = (1::'a)\n  ii < i\n\ngoal (1 subgoal):\n 1. E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) =\n    (1::'a)", "by simp"], ["proof (state)\nthis:\n  E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "}"], ["proof (state)\nthis:\n  (if ii = i then j else if i < ii then Suc j else f ii)\n  < Suc j \\<Longrightarrow>\n  E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "{"], ["proof (state)\nthis:\n  (if ii = i then j else if i < ii then Suc j else f ii)\n  < Suc j \\<Longrightarrow>\n  E $$ (ii, if ii = i then j else if i < ii then Suc j else f ii) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "assume *: \"?f ii < Suc j\" \"i' < nr\" \"i' \\<noteq> ii\""], ["proof (state)\nthis:\n  (if ii = i then j else if i < ii then Suc j else f ii) < Suc j\n  i' < nr\n  i' \\<noteq> ii\n\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       \\<lbrakk>i < nr;\n        (if i = i then j else if i < i then Suc j else f i) < Suc j;\n        i' < nr; i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> E $$\n                         (i',\n                          if i = i then j\n                          else if i < i then Suc j else f i) =\n                         (0::'a)", "show \"E $$ (i', ?f ii) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "proof (cases \"ii = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)\n 2. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  ii \\<noteq> i\n\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)\n 2. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "with *(1)"], ["proof (chain)\npicking this:\n  (if ii = i then j else if i < ii then Suc j else f ii) < Suc j\n  ii \\<noteq> i", "have iii: \"ii < i\""], ["proof (prove)\nusing this:\n  (if ii = i then j else if i < ii then Suc j else f ii) < Suc j\n  ii \\<noteq> i\n\ngoal (1 subgoal):\n 1. ii < i", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  ii < i\n\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)\n 2. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "from f(1)[OF this]"], ["proof (chain)\npicking this:\n  f ii < j", "have \"f ii < j\""], ["proof (prove)\nusing this:\n  f ii < j\n\ngoal (1 subgoal):\n 1. f ii < j", "by auto"], ["proof (state)\nthis:\n  f ii < j\n\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)\n 2. ii \\<noteq> i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "from p(5)[OF this *(2-3)]"], ["proof (chain)\npicking this:\n  E $$ (i', f ii) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  E $$ (i', f ii) = (0::'a)\n\ngoal (1 subgoal):\n 1. E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "using iii"], ["proof (prove)\nusing this:\n  E $$ (i', f ii) = (0::'a)\n  ii < i\n\ngoal (1 subgoal):\n 1. E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) = (0::'a)\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  ii = i\n\ngoal (1 subgoal):\n 1. ii = i \\<Longrightarrow>\n    E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "with *(2-3) Ej[of i']"], ["proof (chain)\npicking this:\n  i' < nr\n  i' \\<noteq> ii\n  i' < nr \\<Longrightarrow>\n  E $$ (i', j) = (if i' = i then 1::'a else (0::'a))\n  ii = i", "show ?thesis"], ["proof (prove)\nusing this:\n  i' < nr\n  i' \\<noteq> ii\n  i' < nr \\<Longrightarrow>\n  E $$ (i', j) = (if i' = i then 1::'a else (0::'a))\n  ii = i\n\ngoal (1 subgoal):\n 1. E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E $$ (i', if ii = i then j else if i < ii then Suc j else f ii) = (0::'a)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(if ii = i then j else if i < ii then Suc j else f ii) < Suc j;\n   ?i'2 < nr; ?i'2 \\<noteq> ii\\<rbrakk>\n  \\<Longrightarrow> E $$\n                    (?i'2,\n                     if ii = i then j else if i < ii then Suc j else f ii) =\n                    (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_fun E\n   (\\<lambda>i'. if i' = i then j else if i < i' then Suc j else f i')\n   (Suc j)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "note IH = IH(1)[OF O refl, folded E_def, OF E _ this _ _ sij]"], ["proof (state)\nthis:\n  \\<lbrakk>gauss_jordan_main E\n            (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j) (Suc i)\n            (Suc j) =\n           (A', B');\n   \\<And>i'.\n      i' < Suc i \\<Longrightarrow>\n      (if i' = i then j else if i < i' then Suc j else f i') < Suc j;\n   \\<And>i'.\n      Suc i \\<le> i' \\<Longrightarrow>\n      (if i' = i then j else if i < i' then Suc j else f i') =\n      Suc j\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "from O nZ valid res"], ["proof (chain)\npicking this:\n  A $$ (i, j) = (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')", "have \"gauss_jordan_main E ?B (Suc i) (Suc j) = (A', B')\""], ["proof (prove)\nusing this:\n  A $$ (i, j) = (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main E (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n     (Suc i) (Suc j) =\n    (A', B')", "unfolding E_def simp dim"], ["proof (prove)\nusing this:\n  A $$ (i, j) = (1::'a)\n  A $$ (i, j) \\<noteq> (0::'a)\n  i < nr \\<and> j < nc\n  (if i < nr \\<and> j < nc\n   then if A $$ (i, j) = (0::'a)\n        then case concat\n                   (map (\\<lambda>i'.\n                            if A $$ (i', j) \\<noteq> (0::'a) then [i']\n                            else [])\n                     [Suc i..<nr]) of\n             [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n        else if A $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                   (multrow i (inverse (A $$ (i, j))) B) i j\n   else (A, B)) =\n  (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n     (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j) (Suc i) (Suc j) =\n    (A', B')", "by simp"], ["proof (state)\nthis:\n  gauss_jordan_main E (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n   (Suc i) (Suc j) =\n  (A', B')\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "note IH = IH[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i'.\n              i' < Suc i \\<Longrightarrow>\n              (if i' = i then j else if i < i' then Suc j else f i')\n              < Suc j;\n   \\<And>i'.\n      Suc i \\<le> i' \\<Longrightarrow>\n      (if i' = i then j else if i < i' then Suc j else f i') =\n      Suc j\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a) \\<Longrightarrow> row_echelon_form A'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "proof (rule IH)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i'.\n       i' < Suc i \\<Longrightarrow>\n       (if i' = i then j else if i < i' then Suc j else f i') < Suc j\n 2. \\<And>i'.\n       Suc i \\<le> i' \\<Longrightarrow>\n       (if i' = i then j else if i < i' then Suc j else f i') = Suc j", "fix i'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i'.\n       i' < Suc i \\<Longrightarrow>\n       (if i' = i then j else if i < i' then Suc j else f i') < Suc j\n 2. \\<And>i'.\n       Suc i \\<le> i' \\<Longrightarrow>\n       (if i' = i then j else if i < i' then Suc j else f i') = Suc j", "assume \"i' < Suc i\""], ["proof (state)\nthis:\n  i' < Suc i\n\ngoal (2 subgoals):\n 1. \\<And>i'.\n       i' < Suc i \\<Longrightarrow>\n       (if i' = i then j else if i < i' then Suc j else f i') < Suc j\n 2. \\<And>i'.\n       Suc i \\<le> i' \\<Longrightarrow>\n       (if i' = i then j else if i < i' then Suc j else f i') = Suc j", "thus \"?f i' < Suc j\""], ["proof (prove)\nusing this:\n  i' < Suc i\n\ngoal (1 subgoal):\n 1. (if i' = i then j else if i < i' then Suc j else f i') < Suc j", "using f[of i']"], ["proof (prove)\nusing this:\n  i' < Suc i\n  i' < i \\<Longrightarrow> f i' < j\n  i \\<le> i' \\<Longrightarrow> f i' = j\n\ngoal (1 subgoal):\n 1. (if i' = i then j else if i < i' then Suc j else f i') < Suc j", "by (cases \"i' < i\", auto)"], ["proof (state)\nthis:\n  (if i' = i then j else if i < i' then Suc j else f i') < Suc j\n\ngoal (1 subgoal):\n 1. \\<And>i'.\n       Suc i \\<le> i' \\<Longrightarrow>\n       (if i' = i then j else if i < i' then Suc j else f i') = Suc j", "qed auto"], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow> row_echelon_form A'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow> row_echelon_form A'", "case True"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow> row_echelon_form A'", "note Z = this"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow> row_echelon_form A'", "note IH = IH(1-2)[OF Z]"], ["proof (state)\nthis:\n  \\<lbrakk>concat\n            (map (\\<lambda>i'.\n                     if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n              [Suc i..<nr]) =\n           [];\n   A \\<in> carrier_mat nr nc; gauss_jordan_main A B i (Suc j) = (A', B');\n   pivot_fun A ?f (Suc j); \\<And>i'. i' < i \\<Longrightarrow> ?f i' < Suc j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = Suc j; i \\<le> nr;\n   Suc j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n  \\<lbrakk>concat\n            (map (\\<lambda>i'.\n                     if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n              [Suc i..<nr]) =\n           ?x21.0 # ?x22.0;\n   swaprows i ?x21.0 A \\<in> carrier_mat nr nc;\n   gauss_jordan_main (swaprows i ?x21.0 A) (swaprows i ?x21.0 B) i j =\n   (A', B');\n   pivot_fun (swaprows i ?x21.0 A) ?f j;\n   \\<And>i'. i' < i \\<Longrightarrow> ?f i' < j;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> ?f i' = j; i \\<le> nr;\n   j \\<le> nc\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow> row_echelon_form A'", "let ?is = \"[ i' . i' <- [Suc i ..< nr],  A $$ (i',j) \\<noteq> 0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow> row_echelon_form A'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "proof (cases ?is)"], ["proof (state)\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "case Nil"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  []\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "{"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  []\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "fix i'"], ["proof (state)\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "assume \"i \\<le> i'\" and \"i' < nr\""], ["proof (state)\nthis:\n  i \\<le> i'\n  i' < nr\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "hence \"i' = i \\<or> i' \\<in> {Suc i ..< nr}\""], ["proof (prove)\nusing this:\n  i \\<le> i'\n  i' < nr\n\ngoal (1 subgoal):\n 1. i' = i \\<or> i' \\<in> {Suc i..<nr}", "by auto"], ["proof (state)\nthis:\n  i' = i \\<or> i' \\<in> {Suc i..<nr}\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "from this arg_cong[OF Nil, of set] Z"], ["proof (chain)\npicking this:\n  i' = i \\<or> i' \\<in> {Suc i..<nr}\n  set (concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr])) =\n  set []\n  A $$ (i, j) = (0::'a)", "have \"A $$ (i',j) = 0\""], ["proof (prove)\nusing this:\n  i' = i \\<or> i' \\<in> {Suc i..<nr}\n  set (concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr])) =\n  set []\n  A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i', j) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $$ (i', j) = (0::'a)\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> ?i'2; ?i'2 < nr\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i'2, j) = (0::'a)\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "note zero = this"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> ?i'2; ?i'2 < nr\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i'2, j) = (0::'a)\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "let ?f = \"\\<lambda> i'. if i' < i then f i' else Suc j\""], ["proof (state)\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "note p = pivot_funD[OF dim(1) pivot]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> j\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = j\n  \\<lbrakk>?i < nr; f ?i < j\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < j; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "have \"pivot_fun A ?f (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun A (\\<lambda>i'. if i' < i then f i' else Suc j) (Suc j)", "proof (rule pivot_funI[OF dim(1)])"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow> (if i < i then f i else Suc j) \\<le> Suc j\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < (if i < i then f i else Suc j)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 4. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "fix ii"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow> (if i < i then f i else Suc j) \\<le> Suc j\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < (if i < i then f i else Suc j)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 4. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "assume ii: \"ii < nr\""], ["proof (state)\nthis:\n  ii < nr\n\ngoal (5 subgoals):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow> (if i < i then f i else Suc j) \\<le> Suc j\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < (if i < i then f i else Suc j)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 4. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "note p = p[OF this]"], ["proof (state)\nthis:\n  f ii \\<le> j\n  ?j < f ii \\<Longrightarrow> A $$ (ii, ?j) = (0::'a)\n  Suc ii < nr \\<Longrightarrow> f ii < f (Suc ii) \\<or> f (Suc ii) = j\n  f ii < j \\<Longrightarrow> A $$ (ii, f ii) = (1::'a)\n  \\<lbrakk>f ii < j; ?i' < nr; ?i' \\<noteq> ii\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ii) = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<And>i.\n       i < nr \\<Longrightarrow> (if i < i then f i else Suc j) \\<le> Suc j\n 2. \\<And>i j.\n       \\<lbrakk>i < nr; j < (if i < i then f i else Suc j)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 4. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 5. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "show \"?f ii \\<le> Suc j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ii < i then f ii else Suc j) \\<le> Suc j", "using p(1)"], ["proof (prove)\nusing this:\n  f ii \\<le> j\n\ngoal (1 subgoal):\n 1. (if ii < i then f ii else Suc j) \\<le> Suc j", "by simp"], ["proof (state)\nthis:\n  (if ii < i then f ii else Suc j) \\<le> Suc j\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < (if i < i then f i else Suc j)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 3. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "{"], ["proof (state)\nthis:\n  (if ii < i then f ii else Suc j) \\<le> Suc j\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < (if i < i then f i else Suc j)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 3. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "fix jj"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < (if i < i then f i else Suc j)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 3. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "assume jj: \"jj < ?f ii\""], ["proof (state)\nthis:\n  jj < (if ii < i then f ii else Suc j)\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < nr; j < (if i < i then f i else Suc j)\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, j) = (0::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 3. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 4. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "show \"A $$ (ii,jj) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (ii, jj) = (0::'a)", "proof (cases \"ii < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)\n 2. \\<not> ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "case True"], ["proof (state)\nthis:\n  ii < i\n\ngoal (2 subgoals):\n 1. ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)\n 2. \\<not> ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "with jj"], ["proof (chain)\npicking this:\n  jj < (if ii < i then f ii else Suc j)\n  ii < i", "have \"jj < f ii\""], ["proof (prove)\nusing this:\n  jj < (if ii < i then f ii else Suc j)\n  ii < i\n\ngoal (1 subgoal):\n 1. jj < f ii", "by auto"], ["proof (state)\nthis:\n  jj < f ii\n\ngoal (2 subgoals):\n 1. ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)\n 2. \\<not> ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "from p(2)[OF this]"], ["proof (chain)\npicking this:\n  A $$ (ii, jj) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  A $$ (ii, jj) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (ii, jj) = (0::'a)", "."], ["proof (state)\nthis:\n  A $$ (ii, jj) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> ii < i\n\ngoal (1 subgoal):\n 1. \\<not> ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "with jj"], ["proof (chain)\npicking this:\n  jj < (if ii < i then f ii else Suc j)\n  \\<not> ii < i", "have ii': \"ii \\<ge> i\" and jjj: \"jj \\<le> j\""], ["proof (prove)\nusing this:\n  jj < (if ii < i then f ii else Suc j)\n  \\<not> ii < i\n\ngoal (1 subgoal):\n 1. i \\<le> ii &&& jj \\<le> j", "by auto"], ["proof (state)\nthis:\n  i \\<le> ii\n  jj \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "from zero[OF ii' ii]"], ["proof (chain)\npicking this:\n  A $$ (ii, j) = (0::'a)", "have Az: \"A $$ (ii,j) = 0\""], ["proof (prove)\nusing this:\n  A $$ (ii, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (ii, j) = (0::'a)", "."], ["proof (state)\nthis:\n  A $$ (ii, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> ii < i \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (ii, jj) = (0::'a)", "proof (cases \"jj < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. jj < j \\<Longrightarrow> A $$ (ii, jj) = (0::'a)\n 2. \\<not> jj < j \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> jj < j\n\ngoal (2 subgoals):\n 1. jj < j \\<Longrightarrow> A $$ (ii, jj) = (0::'a)\n 2. \\<not> jj < j \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "with jjj"], ["proof (chain)\npicking this:\n  jj \\<le> j\n  \\<not> jj < j", "have \"jj = j\""], ["proof (prove)\nusing this:\n  jj \\<le> j\n  \\<not> jj < j\n\ngoal (1 subgoal):\n 1. jj = j", "by auto"], ["proof (state)\nthis:\n  jj = j\n\ngoal (2 subgoals):\n 1. jj < j \\<Longrightarrow> A $$ (ii, jj) = (0::'a)\n 2. \\<not> jj < j \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "with Az"], ["proof (chain)\npicking this:\n  A $$ (ii, j) = (0::'a)\n  jj = j", "show ?thesis"], ["proof (prove)\nusing this:\n  A $$ (ii, j) = (0::'a)\n  jj = j\n\ngoal (1 subgoal):\n 1. A $$ (ii, jj) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $$ (ii, jj) = (0::'a)\n\ngoal (1 subgoal):\n 1. jj < j \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. jj < j \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "case True"], ["proof (state)\nthis:\n  jj < j\n\ngoal (1 subgoal):\n 1. jj < j \\<Longrightarrow> A $$ (ii, jj) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (ii, jj) = (0::'a)", "by (rule p(2), insert True False f, auto)"], ["proof (state)\nthis:\n  A $$ (ii, jj) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $$ (ii, jj) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $$ (ii, jj) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 2. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "}"], ["proof (state)\nthis:\n  ?jj2 < (if ii < i then f ii else Suc j) \\<Longrightarrow>\n  A $$ (ii, ?jj2) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 2. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "{"], ["proof (state)\nthis:\n  ?jj2 < (if ii < i then f ii else Suc j) \\<Longrightarrow>\n  A $$ (ii, ?jj2) = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 2. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "assume sii: \"Suc ii < nr\""], ["proof (state)\nthis:\n  Suc ii < nr\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; Suc i < nr\\<rbrakk>\n       \\<Longrightarrow> (if i < i then f i else Suc j)\n                         < (if Suc i < i then f (Suc i) else Suc j) \\<or>\n                         (if Suc i < i then f (Suc i) else Suc j) = Suc j\n 2. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 3. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "show \"?f ii < ?f (Suc ii) \\<or> ?f (Suc ii) = Suc j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ii < i then f ii else Suc j)\n    < (if Suc ii < i then f (Suc ii) else Suc j) \\<or>\n    (if Suc ii < i then f (Suc ii) else Suc j) = Suc j", "using p(3)[OF sii] f"], ["proof (prove)\nusing this:\n  f ii < f (Suc ii) \\<or> f (Suc ii) = j\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j\n\ngoal (1 subgoal):\n 1. (if ii < i then f ii else Suc j)\n    < (if Suc ii < i then f (Suc ii) else Suc j) \\<or>\n    (if Suc ii < i then f (Suc ii) else Suc j) = Suc j", "by auto"], ["proof (state)\nthis:\n  (if ii < i then f ii else Suc j)\n  < (if Suc ii < i then f (Suc ii) else Suc j) \\<or>\n  (if Suc ii < i then f (Suc ii) else Suc j) = Suc j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 2. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "}"], ["proof (state)\nthis:\n  Suc ii < nr \\<Longrightarrow>\n  (if ii < i then f ii else Suc j)\n  < (if Suc ii < i then f (Suc ii) else Suc j) \\<or>\n  (if Suc ii < i then f (Suc ii) else Suc j) = Suc j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 2. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "{"], ["proof (state)\nthis:\n  Suc ii < nr \\<Longrightarrow>\n  (if ii < i then f ii else Suc j)\n  < (if Suc ii < i then f (Suc ii) else Suc j) \\<or>\n  (if Suc ii < i then f (Suc ii) else Suc j) = Suc j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 2. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "assume fii: \"?f ii < Suc j\""], ["proof (state)\nthis:\n  (if ii < i then f ii else Suc j) < Suc j\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j\\<rbrakk>\n       \\<Longrightarrow> A $$ (i, if i < i then f i else Suc j) = (1::'a)\n 2. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "thus \"A $$ (ii, ?f ii) = 1\""], ["proof (prove)\nusing this:\n  (if ii < i then f ii else Suc j) < Suc j\n\ngoal (1 subgoal):\n 1. A $$ (ii, if ii < i then f ii else Suc j) = (1::'a)", "using p(4) f"], ["proof (prove)\nusing this:\n  (if ii < i then f ii else Suc j) < Suc j\n  f ii < j \\<Longrightarrow> A $$ (ii, f ii) = (1::'a)\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j\n\ngoal (1 subgoal):\n 1. A $$ (ii, if ii < i then f ii else Suc j) = (1::'a)", "by (cases \"ii < i\", auto)"], ["proof (state)\nthis:\n  A $$ (ii, if ii < i then f ii else Suc j) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "assume \"i' < nr\" \"i' \\<noteq> ii\""], ["proof (state)\nthis:\n  i' < nr\n  i' \\<noteq> ii\n\ngoal (1 subgoal):\n 1. \\<And>i i'.\n       \\<lbrakk>i < nr; (if i < i then f i else Suc j) < Suc j; i' < nr;\n        i' \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> A $$ (i', if i < i then f i else Suc j) = (0::'a)", "from p(5)[OF _ this] f fii"], ["proof (chain)\npicking this:\n  f ii < j \\<Longrightarrow> A $$ (i', f ii) = (0::'a)\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j\n  (if ii < i then f ii else Suc j) < Suc j", "show \"A $$ (i', ?f ii) = 0\""], ["proof (prove)\nusing this:\n  f ii < j \\<Longrightarrow> A $$ (i', f ii) = (0::'a)\n  ?i' < i \\<Longrightarrow> f ?i' < j\n  i \\<le> ?i' \\<Longrightarrow> f ?i' = j\n  (if ii < i then f ii else Suc j) < Suc j\n\ngoal (1 subgoal):\n 1. A $$ (i', if ii < i then f ii else Suc j) = (0::'a)", "by (cases \"ii < i\", auto)"], ["proof (state)\nthis:\n  A $$ (i', if ii < i then f ii else Suc j) = (0::'a)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(if ii < i then f ii else Suc j) < Suc j; ?i'2 < nr;\n   ?i'2 \\<noteq> ii\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i'2, if ii < i then f ii else Suc j) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pivot_fun A (\\<lambda>i'. if i' < i then f i' else Suc j) (Suc j)\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "note IH = IH(1)[OF Nil A _ this _ _ ij(1) sij(2)]"], ["proof (state)\nthis:\n  \\<lbrakk>gauss_jordan_main A B i (Suc j) = (A', B');\n   \\<And>i'.\n      i' < i \\<Longrightarrow> (if i' < i then f i' else Suc j) < Suc j;\n   \\<And>i'.\n      i \\<le> i' \\<Longrightarrow>\n      (if i' < i then f i' else Suc j) = Suc j\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "from Z valid res"], ["proof (chain)\npicking this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')", "have \"gauss_jordan_main A B i (Suc j) = (A',B')\""], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i (Suc j) = (A', B')", "unfolding simp dim Nil"], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  (if i < nr \\<and> j < nc\n   then if A $$ (i, j) = (0::'a)\n        then case [] of [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n        else if A $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                   (multrow i (inverse (A $$ (i, j))) B) i j\n   else (A, B)) =\n  (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main A B i (Suc j) = (A', B')", "by simp"], ["proof (state)\nthis:\n  gauss_jordan_main A B i (Suc j) = (A', B')\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "note IH = IH[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i'.\n              i' < i \\<Longrightarrow>\n              (if i' < i then f i' else Suc j) < Suc j;\n   \\<And>i'.\n      i \\<le> i' \\<Longrightarrow>\n      (if i' < i then f i' else Suc j) = Suc j\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (2 subgoals):\n 1. concat\n     (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n       [Suc i..<nr]) =\n    [] \\<Longrightarrow>\n    row_echelon_form A'\n 2. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "by (rule IH, insert f, force+)"], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "case (Cons i' iis)"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>i'. if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n     [Suc i..<nr]) =\n  i' # iis\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "from arg_cong[OF this, of set]"], ["proof (chain)\npicking this:\n  set (concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr])) =\n  set (i' # iis)", "have i': \"i' \\<ge> Suc i\" \"i' < nr\""], ["proof (prove)\nusing this:\n  set (concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr])) =\n  set (i' # iis)\n\ngoal (1 subgoal):\n 1. Suc i \\<le> i' &&& i' < nr", "by auto"], ["proof (state)\nthis:\n  Suc i \\<le> i'\n  i' < nr\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "from f[of i] f[of \"i'\"] i'"], ["proof (chain)\npicking this:\n  i < i \\<Longrightarrow> f i < j\n  i \\<le> i \\<Longrightarrow> f i = j\n  i' < i \\<Longrightarrow> f i' < j\n  i \\<le> i' \\<Longrightarrow> f i' = j\n  Suc i \\<le> i'\n  i' < nr", "have fij: \"f i = j\" \"f i' = j\""], ["proof (prove)\nusing this:\n  i < i \\<Longrightarrow> f i < j\n  i \\<le> i \\<Longrightarrow> f i = j\n  i' < i \\<Longrightarrow> f i' < j\n  i \\<le> i' \\<Longrightarrow> f i' = j\n  Suc i \\<le> i'\n  i' < nr\n\ngoal (1 subgoal):\n 1. f i = j &&& f i' = j", "by auto"], ["proof (state)\nthis:\n  f i = j\n  f i' = j\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "let ?A = \"swaprows i i' A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "let ?B = \"swaprows i i' B\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "have \"pivot_fun ?A f j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun (swaprows i i' A) f j", "by (rule pivot_fun_swaprows[OF pivot dim fij], insert i' ij, auto)"], ["proof (state)\nthis:\n  pivot_fun (swaprows i i' A) f j\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "note IH = IH(2)[OF Cons, unfolded swaprows_carrier, OF A _ this f ij]"], ["proof (state)\nthis:\n  \\<lbrakk>gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j =\n           (A', B');\n   \\<And>i'. i' < i \\<Longrightarrow> i' < i;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> i \\<le> i'\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "from Z valid res"], ["proof (chain)\npicking this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')", "have id: \"gauss_jordan_main ?A ?B i j = (A', B')\""], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  gauss_jordan_main A B i j = (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j = (A', B')", "unfolding simp dim Cons"], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n  i < nr \\<and> j < nc\n  (if i < nr \\<and> j < nc\n   then if A $$ (i, j) = (0::'a)\n        then case i' # iis of\n             [] \\<Rightarrow> gauss_jordan_main A B i (Suc j)\n             | i' # x \\<Rightarrow>\n                 gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j\n        else if A $$ (i, j) = (1::'a)\n             then gauss_jordan_main\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) A i j)\n                   (eliminate_entries (\\<lambda>i. A $$ (i, j)) B i j)\n                   (Suc i) (Suc j)\n             else gauss_jordan_main (multrow i (inverse (A $$ (i, j))) A)\n                   (multrow i (inverse (A $$ (i, j))) B) i j\n   else (A, B)) =\n  (A', B')\n\ngoal (1 subgoal):\n 1. gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j = (A', B')", "by simp"], ["proof (state)\nthis:\n  gauss_jordan_main (swaprows i i' A) (swaprows i i' B) i j = (A', B')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "note IH = IH[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i'. i' < i \\<Longrightarrow> i' < i;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> i \\<le> i'\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       concat\n        (map (\\<lambda>i'.\n                 if A $$ (i', j) \\<noteq> (0::'a) then [i'] else [])\n          [Suc i..<nr]) =\n       a # list \\<Longrightarrow>\n       row_echelon_form A'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "using IH"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i'. i' < i \\<Longrightarrow> i' < i;\n   \\<And>i'. i \\<le> i' \\<Longrightarrow> i \\<le> i'\\<rbrakk>\n  \\<Longrightarrow> row_echelon_form A'\n\ngoal (1 subgoal):\n 1. row_echelon_form A'", "."], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_echelon_form A'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_jordan_row_echelon: \n  assumes A: \"A \\<in> carrier_mat nr nc\" \n  and res: \"gauss_jordan A B = (A', B')\"\n  shows \"row_echelon_form A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form A'", "by (rule gauss_jordan_main_row_echelon[OF A res[unfolded gauss_jordan_def] pivot_fun_init], auto)"], ["", "lemma pivot_bound: assumes dim: \"dim_row A = nr\"\n  and pivot: \"pivot_fun A f n\"\n  shows \"i + j < nr \\<Longrightarrow> f (i + j) = n \\<or> f (i + j) \\<ge> j + f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + j < nr \\<Longrightarrow> f (i + j) = n \\<or> j + f i \\<le> f (i + j)", "proof (induct j)"], ["proof (state)\ngoal (2 subgoals):\n 1. i + 0 < nr \\<Longrightarrow> f (i + 0) = n \\<or> 0 + f i \\<le> f (i + 0)\n 2. \\<And>j.\n       \\<lbrakk>i + j < nr \\<Longrightarrow>\n                f (i + j) = n \\<or> j + f i \\<le> f (i + j);\n        i + Suc j < nr\\<rbrakk>\n       \\<Longrightarrow> f (i + Suc j) = n \\<or>\n                         Suc j + f i \\<le> f (i + Suc j)", "case (Suc j)"], ["proof (state)\nthis:\n  i + j < nr \\<Longrightarrow> f (i + j) = n \\<or> j + f i \\<le> f (i + j)\n  i + Suc j < nr\n\ngoal (2 subgoals):\n 1. i + 0 < nr \\<Longrightarrow> f (i + 0) = n \\<or> 0 + f i \\<le> f (i + 0)\n 2. \\<And>j.\n       \\<lbrakk>i + j < nr \\<Longrightarrow>\n                f (i + j) = n \\<or> j + f i \\<le> f (i + j);\n        i + Suc j < nr\\<rbrakk>\n       \\<Longrightarrow> f (i + Suc j) = n \\<or>\n                         Suc j + f i \\<le> f (i + Suc j)", "hence IH: \"f (i + j) = n \\<or> j + f i \\<le> f (i + j)\" \n    and lt: \"i + j < nr\" \"Suc (i + j) < nr\""], ["proof (prove)\nusing this:\n  i + j < nr \\<Longrightarrow> f (i + j) = n \\<or> j + f i \\<le> f (i + j)\n  i + Suc j < nr\n\ngoal (1 subgoal):\n 1. f (i + j) = n \\<or> j + f i \\<le> f (i + j) &&&\n    i + j < nr &&& Suc (i + j) < nr", "by auto"], ["proof (state)\nthis:\n  f (i + j) = n \\<or> j + f i \\<le> f (i + j)\n  i + j < nr\n  Suc (i + j) < nr\n\ngoal (2 subgoals):\n 1. i + 0 < nr \\<Longrightarrow> f (i + 0) = n \\<or> 0 + f i \\<le> f (i + 0)\n 2. \\<And>j.\n       \\<lbrakk>i + j < nr \\<Longrightarrow>\n                f (i + j) = n \\<or> j + f i \\<le> f (i + j);\n        i + Suc j < nr\\<rbrakk>\n       \\<Longrightarrow> f (i + Suc j) = n \\<or>\n                         Suc j + f i \\<le> f (i + Suc j)", "note p = pivot_funD[OF dim pivot]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> n\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = n\n  \\<lbrakk>?i < nr; f ?i < n\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < n; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n\ngoal (2 subgoals):\n 1. i + 0 < nr \\<Longrightarrow> f (i + 0) = n \\<or> 0 + f i \\<le> f (i + 0)\n 2. \\<And>j.\n       \\<lbrakk>i + j < nr \\<Longrightarrow>\n                f (i + j) = n \\<or> j + f i \\<le> f (i + j);\n        i + Suc j < nr\\<rbrakk>\n       \\<Longrightarrow> f (i + Suc j) = n \\<or>\n                         Suc j + f i \\<le> f (i + Suc j)", "from p(3)[OF lt] IH p(1)[OF lt(2)]"], ["proof (chain)\npicking this:\n  f (i + j) < f (Suc (i + j)) \\<or> f (Suc (i + j)) = n\n  f (i + j) = n \\<or> j + f i \\<le> f (i + j)\n  f (Suc (i + j)) \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  f (i + j) < f (Suc (i + j)) \\<or> f (Suc (i + j)) = n\n  f (i + j) = n \\<or> j + f i \\<le> f (i + j)\n  f (Suc (i + j)) \\<le> n\n\ngoal (1 subgoal):\n 1. f (i + Suc j) = n \\<or> Suc j + f i \\<le> f (i + Suc j)", "by auto"], ["proof (state)\nthis:\n  f (i + Suc j) = n \\<or> Suc j + f i \\<le> f (i + Suc j)\n\ngoal (1 subgoal):\n 1. i + 0 < nr \\<Longrightarrow> f (i + 0) = n \\<or> 0 + f i \\<le> f (i + 0)", "qed simp"], ["", "context\n  fixes zero :: 'a\n  and A :: \"'a mat\"\n  and nr nc :: nat\nbegin"], ["", "function pivot_positions_main_gen :: \"nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> nat) list\" where\n  \"pivot_positions_main_gen i j = (\n     if i < nr then\n       if j < nc then \n         if A $$ (i,j) = zero then \n           pivot_positions_main_gen i (Suc j)\n         else (i,j) # pivot_positions_main_gen (Suc i) (Suc j)\n       else []\n     else [])\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i j. x = (i, j) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>i j ia ja.\n       (i, j) = (ia, ja) \\<Longrightarrow>\n       (if i < nr\n        then if j < nc\n             then if A $$ (i, j) = zero\n                  then pivot_positions_main_gen_sumC (i, Suc j)\n                  else (i, j) # pivot_positions_main_gen_sumC (Suc i, Suc j)\n             else []\n        else []) =\n       (if ia < nr\n        then if ja < nc\n             then if A $$ (ia, ja) = zero\n                  then pivot_positions_main_gen_sumC (ia, Suc ja)\n                  else (ia, ja) #\n                       pivot_positions_main_gen_sumC (Suc ia, Suc ja)\n             else []\n        else [])", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.pivot_positions_main_gen_dom", "by (relation \"measures [(\\<lambda> (i,j). Suc nr - i), (\\<lambda> (i,j). Suc nc - j)]\", auto)"], ["", "declare pivot_positions_main_gen.simps[simp del]"], ["", "end"], ["", "context\n  fixes A :: \"'a :: semiring_1 mat\"\n  and nr nc :: nat\nbegin"], ["", "abbreviation \"pivot_positions_main \\<equiv> pivot_positions_main_gen (0 :: 'a) A nr nc\""], ["", "lemma pivot_positions_main: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and pivot: \"pivot_fun A f nc\"\n  shows \"j \\<le> f i \\<or> i \\<ge> nr \\<Longrightarrow> \n    set (pivot_positions_main i j) = {(i', f i') | i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc}\n    \\<and> distinct (map snd (pivot_positions_main i j))\n    \\<and> distinct (map fst (pivot_positions_main i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> f i \\<or> nr \\<le> i \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "proof (induct i j rule: pivot_positions_main_gen.induct[of nr nc A 0])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "case (1 i j)"], ["proof (state)\nthis:\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n   Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n  \\<Longrightarrow> set (local.pivot_positions_main i (Suc j)) =\n                    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                    UNIV \\<times> {nc} \\<and>\n                    distinct\n                     (map snd (local.pivot_positions_main i (Suc j))) \\<and>\n                    distinct\n                     (map fst (local.pivot_positions_main i (Suc j)))\n  \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n   Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n  \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                    {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                    UNIV \\<times> {nc} \\<and>\n                    distinct\n                     (map snd\n                       (local.pivot_positions_main (Suc i) (Suc j))) \\<and>\n                    distinct\n                     (map fst (local.pivot_positions_main (Suc i) (Suc j)))\n  j \\<le> f i \\<or> nr \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "let ?a = \"A $$ (i,j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "let ?pivot = \"\\<lambda> i j. pivot_positions_main i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "let ?set = \"\\<lambda> i. {(i',f i') | i'. i \\<le> i' \\<and> i' < nr}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "let ?s = \"?set i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "let ?set = \"\\<lambda> i. {(i',f i') | i'. i \\<le> i' \\<and> i' < nr}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "let ?s = \"?set i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "let ?p = \"?pivot i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc", "have dA: \"dim_row A = nr\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row A = nr", "by simp"], ["proof (state)\nthis:\n  dim_row A = nr\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "note [simp] = pivot_positions_main_gen.simps[of 0 A nr nc i j]"], ["proof (state)\nthis:\n  local.pivot_positions_main i j =\n  (if i < nr\n   then if j < nc\n        then if A $$ (i, j) = (0::'a)\n             then local.pivot_positions_main i (Suc j)\n             else (i, j) # local.pivot_positions_main (Suc i) (Suc j)\n        else []\n   else [])\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<lbrakk>i < nr; j < nc; A $$ (i, j) = (0::'a);\n                 Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n                \\<Longrightarrow> set (local.pivot_positions_main i\n  (Suc j)) =\n                                  {(i', f i') |i'.\n                                   i \\<le> i' \\<and> i' < nr} -\n                                  UNIV \\<times> {nc} \\<and>\n                                  distinct\n                                   (map snd\n                                     (local.pivot_positions_main i\n (Suc j))) \\<and>\n                                  distinct\n                                   (map fst\n                                     (local.pivot_positions_main i\n (Suc j)));\n        \\<lbrakk>i < nr; j < nc; A $$ (i, j) \\<noteq> (0::'a);\n         Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n        \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                          {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                          UNIV \\<times> {nc} \\<and>\n                          distinct\n                           (map snd\n                             (local.pivot_positions_main (Suc i)\n                               (Suc j))) \\<and>\n                          distinct\n                           (map fst\n                             (local.pivot_positions_main (Suc i) (Suc j)));\n        j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n       \\<Longrightarrow> set (local.pivot_positions_main i j) =\n                         {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                         UNIV \\<times> {nc} \\<and>\n                         distinct\n                          (map snd (local.pivot_positions_main i j)) \\<and>\n                         distinct (map fst (local.pivot_positions_main i j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "proof (cases \"i < nr\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "case True"], ["proof (state)\nthis:\n  i < nr\n\ngoal (2 subgoals):\n 1. i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note i = this"], ["proof (state)\nthis:\n  i < nr\n\ngoal (2 subgoals):\n 1. i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note IH = 1(1-2)[OF True]"], ["proof (state)\nthis:\n  \\<lbrakk>j < nc; A $$ (i, j) = (0::'a);\n   Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n  \\<Longrightarrow> set (local.pivot_positions_main i (Suc j)) =\n                    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                    UNIV \\<times> {nc} \\<and>\n                    distinct\n                     (map snd (local.pivot_positions_main i (Suc j))) \\<and>\n                    distinct\n                     (map fst (local.pivot_positions_main i (Suc j)))\n  \\<lbrakk>j < nc; A $$ (i, j) \\<noteq> (0::'a);\n   Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n  \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                    {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                    UNIV \\<times> {nc} \\<and>\n                    distinct\n                     (map snd\n                       (local.pivot_positions_main (Suc i) (Suc j))) \\<and>\n                    distinct\n                     (map fst (local.pivot_positions_main (Suc i) (Suc j)))\n\ngoal (2 subgoals):\n 1. i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "have jfi: \"j \\<le> f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> f i", "using 1(3) i"], ["proof (prove)\nusing this:\n  j \\<le> f i \\<or> nr \\<le> i\n  i < nr\n\ngoal (1 subgoal):\n 1. j \\<le> f i", "by auto"], ["proof (state)\nthis:\n  j \\<le> f i\n\ngoal (2 subgoals):\n 1. i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note pivotB = pivot_bound[OF dA pivot]"], ["proof (state)\nthis:\n  ?i + ?j < nr \\<Longrightarrow>\n  f (?i + ?j) = nc \\<or> ?j + f ?i \\<le> f (?i + ?j)\n\ngoal (2 subgoals):\n 1. i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note pivot' = pivot_funD[OF dA pivot]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> f ?i \\<le> nc\n  \\<lbrakk>?i < nr; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = nc\n  \\<lbrakk>?i < nr; f ?i < nc\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < nr; f ?i < nc; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note pivot = pivot'[OF True]"], ["proof (state)\nthis:\n  f i \\<le> nc\n  ?j < f i \\<Longrightarrow> A $$ (i, ?j) = (0::'a)\n  Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc\n  f i < nc \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n  \\<lbrakk>f i < nc; ?i' < nr; ?i' \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f i) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "have id1: \"[i ..< nr] = i # [Suc i ..< nr]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i..<nr] = i # [Suc i..<nr]", "using i"], ["proof (prove)\nusing this:\n  i < nr\n\ngoal (1 subgoal):\n 1. [i..<nr] = i # [Suc i..<nr]", "by (rule upt_conv_Cons)"], ["proof (state)\nthis:\n  [i..<nr] = i # [Suc i..<nr]\n\ngoal (2 subgoals):\n 1. i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "proof (cases \"j < nc\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "case True"], ["proof (state)\nthis:\n  j < nc\n\ngoal (2 subgoals):\n 1. j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note j = this"], ["proof (state)\nthis:\n  j < nc\n\ngoal (2 subgoals):\n 1. j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note IH = IH(1-2)[OF True]"], ["proof (state)\nthis:\n  \\<lbrakk>A $$ (i, j) = (0::'a); Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n  \\<Longrightarrow> set (local.pivot_positions_main i (Suc j)) =\n                    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                    UNIV \\<times> {nc} \\<and>\n                    distinct\n                     (map snd (local.pivot_positions_main i (Suc j))) \\<and>\n                    distinct\n                     (map fst (local.pivot_positions_main i (Suc j)))\n  \\<lbrakk>A $$ (i, j) \\<noteq> (0::'a);\n   Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n  \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                    {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                    UNIV \\<times> {nc} \\<and>\n                    distinct\n                     (map snd\n                       (local.pivot_positions_main (Suc i) (Suc j))) \\<and>\n                    distinct\n                     (map fst (local.pivot_positions_main (Suc i) (Suc j)))\n\ngoal (2 subgoals):\n 1. j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "proof (cases \"?a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "case True"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note a = this"], ["proof (state)\nthis:\n  A $$ (i, j) = (0::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "from i j a"], ["proof (chain)\npicking this:\n  i < nr\n  j < nc\n  A $$ (i, j) = (0::'a)", "have p: \"?p = ?pivot i (Suc j)\""], ["proof (prove)\nusing this:\n  i < nr\n  j < nc\n  A $$ (i, j) = (0::'a)\n\ngoal (1 subgoal):\n 1. local.pivot_positions_main i j = local.pivot_positions_main i (Suc j)", "by simp"], ["proof (state)\nthis:\n  local.pivot_positions_main i j = local.pivot_positions_main i (Suc j)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "{"], ["proof (state)\nthis:\n  local.pivot_positions_main i j = local.pivot_positions_main i (Suc j)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "assume \"f i = j\""], ["proof (state)\nthis:\n  f i = j\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "with pivot(4) j"], ["proof (chain)\npicking this:\n  f i < nc \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n  j < nc\n  f i = j", "have \"?a = 1\""], ["proof (prove)\nusing this:\n  f i < nc \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n  j < nc\n  f i = j\n\ngoal (1 subgoal):\n 1. A $$ (i, j) = (1::'a)", "by simp"], ["proof (state)\nthis:\n  A $$ (i, j) = (1::'a)\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "with a"], ["proof (chain)\npicking this:\n  A $$ (i, j) = (0::'a)\n  A $$ (i, j) = (1::'a)", "have False"], ["proof (prove)\nusing this:\n  A $$ (i, j) = (0::'a)\n  A $$ (i, j) = (1::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "}"], ["proof (state)\nthis:\n  f i = j \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "with jfi"], ["proof (chain)\npicking this:\n  j \\<le> f i\n  f i = j \\<Longrightarrow> False", "have \"Suc j \\<le> f i \\<or> i \\<ge> nr\""], ["proof (prove)\nusing this:\n  j \\<le> f i\n  f i = j \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Suc j \\<le> f i \\<or> nr \\<le> i", "by fastforce"], ["proof (state)\nthis:\n  Suc j \\<le> f i \\<or> nr \\<le> i\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note IH = IH(1)[OF True this]"], ["proof (state)\nthis:\n  set (local.pivot_positions_main i (Suc j)) =\n  {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main i (Suc j))) \\<and>\n  distinct (map fst (local.pivot_positions_main i (Suc j)))\n\ngoal (2 subgoals):\n 1. A $$ (i, j) = (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))\n 2. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (local.pivot_positions_main i (Suc j)) =\n  {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main i (Suc j))) \\<and>\n  distinct (map fst (local.pivot_positions_main i (Suc j)))\n\ngoal (1 subgoal):\n 1. set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "unfolding p"], ["proof (prove)\nusing this:\n  set (local.pivot_positions_main i (Suc j)) =\n  {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main i (Suc j))) \\<and>\n  distinct (map fst (local.pivot_positions_main i (Suc j)))\n\ngoal (1 subgoal):\n 1. set (local.pivot_positions_main i (Suc j)) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i (Suc j))) \\<and>\n    distinct (map fst (local.pivot_positions_main i (Suc j)))", "."], ["proof (state)\nthis:\n  set (local.pivot_positions_main i j) =\n  {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main i j)) \\<and>\n  distinct (map fst (local.pivot_positions_main i j))\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "case False"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note a = this"], ["proof (state)\nthis:\n  A $$ (i, j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "from i j a"], ["proof (chain)\npicking this:\n  i < nr\n  j < nc\n  A $$ (i, j) \\<noteq> (0::'a)", "have p: \"?p = (i,j) # ?pivot (Suc i) (Suc j)\""], ["proof (prove)\nusing this:\n  i < nr\n  j < nc\n  A $$ (i, j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. local.pivot_positions_main i j =\n    (i, j) # local.pivot_positions_main (Suc i) (Suc j)", "by simp"], ["proof (state)\nthis:\n  local.pivot_positions_main i j =\n  (i, j) # local.pivot_positions_main (Suc i) (Suc j)\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "from pivot(2)[of j] jfi a"], ["proof (chain)\npicking this:\n  j < f i \\<Longrightarrow> A $$ (i, j) = (0::'a)\n  j \\<le> f i\n  A $$ (i, j) \\<noteq> (0::'a)", "have jfi: \"j = f i\""], ["proof (prove)\nusing this:\n  j < f i \\<Longrightarrow> A $$ (i, j) = (0::'a)\n  j \\<le> f i\n  A $$ (i, j) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. j = f i", "by force"], ["proof (state)\nthis:\n  j = f i\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "from pivotB[of i \"Suc 0\"] jfi"], ["proof (chain)\npicking this:\n  i + Suc 0 < nr \\<Longrightarrow>\n  f (i + Suc 0) = nc \\<or> Suc 0 + f i \\<le> f (i + Suc 0)\n  j = f i", "have \"Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\""], ["proof (prove)\nusing this:\n  i + Suc 0 < nr \\<Longrightarrow>\n  f (i + Suc 0) = nc \\<or> Suc 0 + f i \\<le> f (i + Suc 0)\n  j = f i\n\ngoal (1 subgoal):\n 1. Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i", "using Suc_le_eq j leI"], ["proof (prove)\nusing this:\n  i + Suc 0 < nr \\<Longrightarrow>\n  f (i + Suc 0) = nc \\<or> Suc 0 + f i \\<le> f (i + Suc 0)\n  j = f i\n  (Suc ?m \\<le> ?n) = (?m < ?n)\n  j < nc\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i", "by auto"], ["proof (state)\nthis:\n  Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note IH = IH(2)[OF False this]"], ["proof (state)\nthis:\n  set (local.pivot_positions_main (Suc i) (Suc j)) =\n  {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n  UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main (Suc i) (Suc j))) \\<and>\n  distinct (map fst (local.pivot_positions_main (Suc i) (Suc j)))\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "{"], ["proof (state)\nthis:\n  set (local.pivot_positions_main (Suc i) (Suc j)) =\n  {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n  UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main (Suc i) (Suc j))) \\<and>\n  distinct (map fst (local.pivot_positions_main (Suc i) (Suc j)))\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "assume *: \"f i = f i'\" \"Suc i \\<le> i'\" \"i' < nr\""], ["proof (state)\nthis:\n  f i = f i'\n  Suc i \\<le> i'\n  i' < nr\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "hence \"i + (i' - i) = i'\""], ["proof (prove)\nusing this:\n  f i = f i'\n  Suc i \\<le> i'\n  i' < nr\n\ngoal (1 subgoal):\n 1. i + (i' - i) = i'", "by auto"], ["proof (state)\nthis:\n  i + (i' - i) = i'\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "from pivotB[of i \"i' - i\", unfolded this] * jfi j"], ["proof (chain)\npicking this:\n  i' < nr \\<Longrightarrow> f i' = nc \\<or> i' - i + f i \\<le> f i'\n  f i = f i'\n  Suc i \\<le> i'\n  i' < nr\n  j = f i\n  j < nc", "have False"], ["proof (prove)\nusing this:\n  i' < nr \\<Longrightarrow> f i' = nc \\<or> i' - i + f i \\<le> f i'\n  f i = f i'\n  Suc i \\<le> i'\n  i' < nr\n  j = f i\n  j < nc\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>f i = f ?i'2; Suc i \\<le> ?i'2; ?i'2 < nr\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note distinct = this"], ["proof (state)\nthis:\n  \\<lbrakk>f i = f ?i'2; Suc i \\<le> ?i'2; ?i'2 < nr\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "have id2: \"?s = insert (i,j) (?set (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} =\n    insert (i, j) {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr}", "using i jfi not_less_eq_eq"], ["proof (prove)\nusing this:\n  i < nr\n  j = f i\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} =\n    insert (i, j) {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr}", "by fastforce"], ["proof (state)\nthis:\n  {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} =\n  insert (i, j) {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr}\n\ngoal (1 subgoal):\n 1. A $$ (i, j) \\<noteq> (0::'a) \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "using IH j jfi i"], ["proof (prove)\nusing this:\n  set (local.pivot_positions_main (Suc i) (Suc j)) =\n  {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n  UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main (Suc i) (Suc j))) \\<and>\n  distinct (map fst (local.pivot_positions_main (Suc i) (Suc j)))\n  j < nc\n  j = f i\n  i < nr\n\ngoal (1 subgoal):\n 1. set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "unfolding p id1 id2"], ["proof (prove)\nusing this:\n  set (local.pivot_positions_main (Suc i) (Suc j)) =\n  {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n  UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main (Suc i) (Suc j))) \\<and>\n  distinct (map fst (local.pivot_positions_main (Suc i) (Suc j)))\n  j < nc\n  j = f i\n  i < nr\n\ngoal (1 subgoal):\n 1. set ((i, j) # local.pivot_positions_main (Suc i) (Suc j)) =\n    insert (i, j) {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n    UNIV \\<times> {nc} \\<and>\n    distinct\n     (map snd ((i, j) # local.pivot_positions_main (Suc i) (Suc j))) \\<and>\n    distinct (map fst ((i, j) # local.pivot_positions_main (Suc i) (Suc j)))", "by (auto intro: distinct)"], ["proof (state)\nthis:\n  set (local.pivot_positions_main i j) =\n  {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main i j)) \\<and>\n  distinct (map fst (local.pivot_positions_main i j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (local.pivot_positions_main i j) =\n  {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main i j)) \\<and>\n  distinct (map fst (local.pivot_positions_main i j))\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "case False"], ["proof (state)\nthis:\n  \\<not> j < nc\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "note j = this"], ["proof (state)\nthis:\n  \\<not> j < nc\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "from pivot(1) j jfi"], ["proof (chain)\npicking this:\n  f i \\<le> nc\n  \\<not> j < nc\n  j \\<le> f i", "have *: \"f i = nc\" \"nc = j\""], ["proof (prove)\nusing this:\n  f i \\<le> nc\n  \\<not> j < nc\n  j \\<le> f i\n\ngoal (1 subgoal):\n 1. f i = nc &&& nc = j", "by auto"], ["proof (state)\nthis:\n  f i = nc\n  nc = j\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "from i j"], ["proof (chain)\npicking this:\n  i < nr\n  \\<not> j < nc", "have p: \"?p = []\""], ["proof (prove)\nusing this:\n  i < nr\n  \\<not> j < nc\n\ngoal (1 subgoal):\n 1. local.pivot_positions_main i j = []", "by simp"], ["proof (state)\nthis:\n  local.pivot_positions_main i j = []\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "from pivotB[of i \"Suc 0\"] *"], ["proof (chain)\npicking this:\n  i + Suc 0 < nr \\<Longrightarrow>\n  f (i + Suc 0) = nc \\<or> Suc 0 + f i \\<le> f (i + Suc 0)\n  f i = nc\n  nc = j", "have \"j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\""], ["proof (prove)\nusing this:\n  i + Suc 0 < nr \\<Longrightarrow>\n  f (i + Suc 0) = nc \\<or> Suc 0 + f i \\<le> f (i + Suc 0)\n  f i = nc\n  nc = j\n\ngoal (1 subgoal):\n 1. j \\<le> f (Suc i) \\<or> nr \\<le> Suc i", "by auto"], ["proof (state)\nthis:\n  j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "{"], ["proof (state)\nthis:\n  j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "assume **: \"i \\<le> i'\" \"i' < nr\""], ["proof (state)\nthis:\n  i \\<le> i'\n  i' < nr\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "hence \"i + (i' - i) = i'\""], ["proof (prove)\nusing this:\n  i \\<le> i'\n  i' < nr\n\ngoal (1 subgoal):\n 1. i + (i' - i) = i'", "by auto"], ["proof (state)\nthis:\n  i + (i' - i) = i'\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "from pivotB[of i \"i' - i\", unfolded this] ** *"], ["proof (chain)\npicking this:\n  i' < nr \\<Longrightarrow> f i' = nc \\<or> i' - i + f i \\<le> f i'\n  i \\<le> i'\n  i' < nr\n  f i = nc\n  nc = j", "have \"nc \\<le> f i'\""], ["proof (prove)\nusing this:\n  i' < nr \\<Longrightarrow> f i' = nc \\<or> i' - i + f i \\<le> f i'\n  i \\<le> i'\n  i' < nr\n  f i = nc\n  nc = j\n\ngoal (1 subgoal):\n 1. nc \\<le> f i'", "by auto"], ["proof (state)\nthis:\n  nc \\<le> f i'\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "with pivot'(1)[OF \\<open>i' < nr\\<close>]"], ["proof (chain)\npicking this:\n  f i' \\<le> nc\n  nc \\<le> f i'", "have \"f i' = nc\""], ["proof (prove)\nusing this:\n  f i' \\<le> nc\n  nc \\<le> f i'\n\ngoal (1 subgoal):\n 1. f i' = nc", "by auto"], ["proof (state)\nthis:\n  f i' = nc\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> ?i'2; ?i'2 < nr\\<rbrakk> \\<Longrightarrow> f ?i'2 = nc\n\ngoal (1 subgoal):\n 1. \\<not> j < nc \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> ?i'2; ?i'2 < nr\\<rbrakk> \\<Longrightarrow> f ?i'2 = nc\n\ngoal (1 subgoal):\n 1. set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "using IH"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> ?i'2; ?i'2 < nr\\<rbrakk> \\<Longrightarrow> f ?i'2 = nc\n  \\<lbrakk>j < nc; A $$ (i, j) = (0::'a);\n   Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n  \\<Longrightarrow> set (local.pivot_positions_main i (Suc j)) =\n                    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                    UNIV \\<times> {nc} \\<and>\n                    distinct\n                     (map snd (local.pivot_positions_main i (Suc j))) \\<and>\n                    distinct\n                     (map fst (local.pivot_positions_main i (Suc j)))\n  \\<lbrakk>j < nc; A $$ (i, j) \\<noteq> (0::'a);\n   Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n  \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                    {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                    UNIV \\<times> {nc} \\<and>\n                    distinct\n                     (map snd\n                       (local.pivot_positions_main (Suc i) (Suc j))) \\<and>\n                    distinct\n                     (map fst (local.pivot_positions_main (Suc i) (Suc j)))\n\ngoal (1 subgoal):\n 1. set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "unfolding p id1"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> ?i'2; ?i'2 < nr\\<rbrakk> \\<Longrightarrow> f ?i'2 = nc\n  \\<lbrakk>j < nc; A $$ (i, j) = (0::'a);\n   Suc j \\<le> f i \\<or> nr \\<le> i\\<rbrakk>\n  \\<Longrightarrow> set (local.pivot_positions_main i (Suc j)) =\n                    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} -\n                    UNIV \\<times> {nc} \\<and>\n                    distinct\n                     (map snd (local.pivot_positions_main i (Suc j))) \\<and>\n                    distinct\n                     (map fst (local.pivot_positions_main i (Suc j)))\n  \\<lbrakk>j < nc; A $$ (i, j) \\<noteq> (0::'a);\n   Suc j \\<le> f (Suc i) \\<or> nr \\<le> Suc i\\<rbrakk>\n  \\<Longrightarrow> set (local.pivot_positions_main (Suc i) (Suc j)) =\n                    {(i', f i') |i'. Suc i \\<le> i' \\<and> i' < nr} -\n                    UNIV \\<times> {nc} \\<and>\n                    distinct\n                     (map snd\n                       (local.pivot_positions_main (Suc i) (Suc j))) \\<and>\n                    distinct\n                     (map fst (local.pivot_positions_main (Suc i) (Suc j)))\n\ngoal (1 subgoal):\n 1. set [] =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd []) \\<and> distinct (map fst [])", "by auto"], ["proof (state)\nthis:\n  set (local.pivot_positions_main i j) =\n  {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main i j)) \\<and>\n  distinct (map fst (local.pivot_positions_main i j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (local.pivot_positions_main i j) =\n  {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main i j)) \\<and>\n  distinct (map fst (local.pivot_positions_main i j))\n\ngoal (1 subgoal):\n 1. \\<not> i < nr \\<Longrightarrow>\n    set (local.pivot_positions_main i j) =\n    {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n    distinct (map snd (local.pivot_positions_main i j)) \\<and>\n    distinct (map fst (local.pivot_positions_main i j))", "qed auto"], ["proof (state)\nthis:\n  set (local.pivot_positions_main i j) =\n  {(i', f i') |i'. i \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (local.pivot_positions_main i j)) \\<and>\n  distinct (map fst (local.pivot_positions_main i j))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma pivot_fun_zero_row_iff: assumes pivot: \"pivot_fun (A :: 'a :: semiring_1 mat) f nc\"\n  and A: \"A \\<in> carrier_mat nr nc\"\n  and i: \"i < nr\"\n  shows \"f i = nc \\<longleftrightarrow> row A i = 0\\<^sub>v nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc", "have dim: \"dim_row A = nr\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row A = nr", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "note pivot = pivot_funD[OF dim pivot i]"], ["proof (state)\nthis:\n  f i \\<le> nc\n  ?j < f i \\<Longrightarrow> A $$ (i, ?j) = (0::'a)\n  Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc\n  f i < nc \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n  \\<lbrakk>f i < nc; ?i' < nr; ?i' \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f i) = (0::'a)\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "{"], ["proof (state)\nthis:\n  f i \\<le> nc\n  ?j < f i \\<Longrightarrow> A $$ (i, ?j) = (0::'a)\n  Suc i < nr \\<Longrightarrow> f i < f (Suc i) \\<or> f (Suc i) = nc\n  f i < nc \\<Longrightarrow> A $$ (i, f i) = (1::'a)\n  \\<lbrakk>f i < nc; ?i' < nr; ?i' \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f i) = (0::'a)\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "assume \"f i = nc\""], ["proof (state)\nthis:\n  f i = nc\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "from pivot(2)[unfolded this]"], ["proof (chain)\npicking this:\n  ?j < nc \\<Longrightarrow> A $$ (i, ?j) = (0::'a)", "have \"row A i = 0\\<^sub>v nc\""], ["proof (prove)\nusing this:\n  ?j < nc \\<Longrightarrow> A $$ (i, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. row A i = 0\\<^sub>v nc", "by (intro eq_vecI, insert A, auto simp: row_def)"], ["proof (state)\nthis:\n  row A i = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "}"], ["proof (state)\nthis:\n  f i = nc \\<Longrightarrow> row A i = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "moreover"], ["proof (state)\nthis:\n  f i = nc \\<Longrightarrow> row A i = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "{"], ["proof (state)\nthis:\n  f i = nc \\<Longrightarrow> row A i = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "assume row: \"row A i = 0\\<^sub>v nc\""], ["proof (state)\nthis:\n  row A i = 0\\<^sub>v nc\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "assume \"f i \\<noteq> nc\""], ["proof (state)\nthis:\n  f i \\<noteq> nc\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "with pivot(1)"], ["proof (chain)\npicking this:\n  f i \\<le> nc\n  f i \\<noteq> nc", "have \"f i < nc\""], ["proof (prove)\nusing this:\n  f i \\<le> nc\n  f i \\<noteq> nc\n\ngoal (1 subgoal):\n 1. f i < nc", "by auto"], ["proof (state)\nthis:\n  f i < nc\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "with pivot(4)[OF this] i A arg_cong[OF row, of \"\\<lambda> v. v $ f i\"]"], ["proof (chain)\npicking this:\n  A $$ (i, f i) = (1::'a)\n  i < nr\n  A \\<in> carrier_mat nr nc\n  row A i $ f i = 0\\<^sub>v nc $ f i\n  f i < nc", "have False"], ["proof (prove)\nusing this:\n  A $$ (i, f i) = (1::'a)\n  i < nr\n  A \\<in> carrier_mat nr nc\n  row A i $ f i = 0\\<^sub>v nc $ f i\n  f i < nc\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>row A i = 0\\<^sub>v nc; f i \\<noteq> nc\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "ultimately"], ["proof (chain)\npicking this:\n  f i = nc \\<Longrightarrow> row A i = 0\\<^sub>v nc\n  \\<lbrakk>row A i = 0\\<^sub>v nc; f i \\<noteq> nc\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  f i = nc \\<Longrightarrow> row A i = 0\\<^sub>v nc\n  \\<lbrakk>row A i = 0\\<^sub>v nc; f i \\<noteq> nc\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (f i = nc) = (row A i = 0\\<^sub>v nc)", "by auto"], ["proof (state)\nthis:\n  (f i = nc) = (row A i = 0\\<^sub>v nc)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition pivot_positions_gen :: \"'a \\<Rightarrow> 'a mat \\<Rightarrow> (nat \\<times> nat) list\" where\n  \"pivot_positions_gen zer A \\<equiv> pivot_positions_main_gen zer A (dim_row A) (dim_col A) 0 0\""], ["", "abbreviation pivot_positions :: \"'a :: semiring_1 mat \\<Rightarrow> (nat \\<times> nat) list\" where\n  \"pivot_positions \\<equiv> pivot_positions_gen 0\""], ["", "lemmas pivot_positions_def = pivot_positions_gen_def"], ["", "lemma pivot_positions: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and pivot: \"pivot_fun A f nc\"\n  shows \n    \"set (pivot_positions A) = {(i, f i) | i. i < nr \\<and> f i \\<noteq> nc}\"\n    \"distinct (map fst (pivot_positions A))\"\n    \"distinct (map snd (pivot_positions A))\"\n    \"length (pivot_positions A) = card { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (pivot_positions A) =\n     {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc} &&&\n     distinct (map fst (pivot_positions A))) &&&\n    distinct (map snd (pivot_positions A)) &&&\n    length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. set (pivot_positions A) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}\n 2. distinct (map fst (pivot_positions A))\n 3. distinct (map snd (pivot_positions A))\n 4. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc", "have dim: \"dim_row A = nr\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row A = nr", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr\n\ngoal (4 subgoals):\n 1. set (pivot_positions A) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}\n 2. distinct (map fst (pivot_positions A))\n 3. distinct (map snd (pivot_positions A))\n 4. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "let ?pp = \"pivot_positions A\""], ["proof (state)\ngoal (4 subgoals):\n 1. set (pivot_positions A) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}\n 2. distinct (map fst (pivot_positions A))\n 3. distinct (map snd (pivot_positions A))\n 4. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "show id: \"set ?pp = {(i, f i) | i. i < nr \\<and> f i \\<noteq> nc}\"\n    and dist: \"distinct (map fst ?pp)\"\n    and \"distinct (map snd ?pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (pivot_positions A) =\n    {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc} &&&\n    distinct (map fst (pivot_positions A)) &&&\n    distinct (map snd (pivot_positions A))", "using pivot_positions_main[OF A pivot, of 0 0] A"], ["proof (prove)\nusing this:\n  0 \\<le> f 0 \\<or> nr \\<le> 0 \\<Longrightarrow>\n  set (pivot_positions_main A nr nc 0 0) =\n  {(i', f i') |i'. 0 \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (pivot_positions_main A nr nc 0 0)) \\<and>\n  distinct (map fst (pivot_positions_main A nr nc 0 0))\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. set (pivot_positions A) =\n    {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc} &&&\n    distinct (map fst (pivot_positions A)) &&&\n    distinct (map snd (pivot_positions A))", "unfolding pivot_positions_def"], ["proof (prove)\nusing this:\n  0 \\<le> f 0 \\<or> nr \\<le> 0 \\<Longrightarrow>\n  set (pivot_positions_main A nr nc 0 0) =\n  {(i', f i') |i'. 0 \\<le> i' \\<and> i' < nr} - UNIV \\<times> {nc} \\<and>\n  distinct (map snd (pivot_positions_main A nr nc 0 0)) \\<and>\n  distinct (map fst (pivot_positions_main A nr nc 0 0))\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. set (pivot_positions_main A (dim_row A) (dim_col A) 0 0) =\n    {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc} &&&\n    distinct\n     (map fst (pivot_positions_main A (dim_row A) (dim_col A) 0 0)) &&&\n    distinct (map snd (pivot_positions_main A (dim_row A) (dim_col A) 0 0))", "by auto"], ["proof (state)\nthis:\n  set (pivot_positions A) = {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc}\n  distinct (map fst (pivot_positions A))\n  distinct (map snd (pivot_positions A))\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "have \"length ?pp = length (map fst ?pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pivot_positions A) = length (map fst (pivot_positions A))", "by simp"], ["proof (state)\nthis:\n  length (pivot_positions A) = length (map fst (pivot_positions A))\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "also"], ["proof (state)\nthis:\n  length (pivot_positions A) = length (map fst (pivot_positions A))\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "have \"\\<dots> = card (fst ` set ?pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst (pivot_positions A)) =\n    card (fst ` set (pivot_positions A))", "using distinct_card[OF dist]"], ["proof (prove)\nusing this:\n  card (set (map fst (pivot_positions A))) =\n  length (map fst (pivot_positions A))\n\ngoal (1 subgoal):\n 1. length (map fst (pivot_positions A)) =\n    card (fst ` set (pivot_positions A))", "by simp"], ["proof (state)\nthis:\n  length (map fst (pivot_positions A)) =\n  card (fst ` set (pivot_positions A))\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "also"], ["proof (state)\nthis:\n  length (map fst (pivot_positions A)) =\n  card (fst ` set (pivot_positions A))\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "have \"fst ` set ?pp = { i. i < nr \\<and> f i \\<noteq> nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (pivot_positions A) = {i. i < nr \\<and> f i \\<noteq> nc}", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` {(i, f i) |i. i < nr \\<and> f i \\<noteq> nc} =\n    {i. i < nr \\<and> f i \\<noteq> nc}", "by force"], ["proof (state)\nthis:\n  fst ` set (pivot_positions A) = {i. i < nr \\<and> f i \\<noteq> nc}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "also"], ["proof (state)\nthis:\n  fst ` set (pivot_positions A) = {i. i < nr \\<and> f i \\<noteq> nc}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "have \"\\<dots> = { i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < nr \\<and> f i \\<noteq> nc} =\n    {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "using pivot_fun_zero_row_iff[OF pivot A]"], ["proof (prove)\nusing this:\n  ?i < nr \\<Longrightarrow> (f ?i = nc) = (row A ?i = 0\\<^sub>v nc)\n\ngoal (1 subgoal):\n 1. {i. i < nr \\<and> f i \\<noteq> nc} =\n    {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "by auto"], ["proof (state)\nthis:\n  {i. i < nr \\<and> f i \\<noteq> nc} =\n  {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "finally"], ["proof (chain)\npicking this:\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "show \"length ?pp = card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\""], ["proof (prove)\nusing this:\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. length (pivot_positions A) =\n    card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "."], ["proof (state)\nthis:\n  length (pivot_positions A) =\n  card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n  fixes uminus :: \"'a \\<Rightarrow> 'a\"\n  and zero :: 'a\n  and one :: 'a\nbegin"], ["", "definition non_pivot_base_gen :: \"'a mat \\<Rightarrow> (nat \\<times> nat)list \\<Rightarrow> nat \\<Rightarrow> 'a vec\" where\n  \"non_pivot_base_gen A pivots \\<equiv> let nr = dim_row A; nc = dim_col A; \n     invers = map_of (map prod.swap pivots)\n     in (\\<lambda> qj. vec nc (\\<lambda> i. \n     if i = qj then one else (case invers i of Some j => uminus (A $$ (j,qj)) | None \\<Rightarrow> zero)))\""], ["", "definition find_base_vectors_gen :: \"'a mat \\<Rightarrow> 'a vec list\" where\n  \"find_base_vectors_gen A \\<equiv> \n    let \n      pp = pivot_positions_gen zero A;     \n      cands = filter (\\<lambda> j. j \\<notin> set (map snd pp)) [0 ..< dim_col A]\n    in map (non_pivot_base_gen A pp) cands\""], ["", "end"], ["", "abbreviation \"non_pivot_base \\<equiv> non_pivot_base_gen uminus 0 (1 :: 'a :: comm_ring_1)\""], ["", "abbreviation \"find_base_vectors \\<equiv> find_base_vectors_gen uminus 0 (1 :: 'a :: comm_ring_1)\""], ["", "lemmas non_pivot_base_def = non_pivot_base_gen_def"], ["", "lemmas find_base_vectors_def = find_base_vectors_gen_def"], ["", "text \\<open>The soundness of @{const find_base_vectors} is proven in theory Matrix-Kern,\n  where it is shown that @{const find_base_vectors} is a basis of the kern of $A$.\\<close>"], ["", "definition find_base_vector :: \"'a :: comm_ring_1 mat \\<Rightarrow> 'a vec\" where\n  \"find_base_vector A \\<equiv> \n    let \n      pp = pivot_positions A;     \n      cands = filter (\\<lambda> j. j \\<notin> set (map snd pp)) [0 ..< dim_col A]\n    in non_pivot_base A pp (hd cands)\""], ["", "context\n  fixes A :: \"'a :: field mat\" and nr nc :: nat and p :: \"nat \\<Rightarrow> nat\"\n  assumes ref: \"row_echelon_form A\"\n  and A: \"A \\<in> carrier_mat nr nc\"\nbegin"], ["", "lemma non_pivot_base:\n  defines pp: \"pp \\<equiv> pivot_positions A\"\n  assumes qj: \"qj < nc\" \"qj \\<notin> snd ` set pp\" \n  shows \"non_pivot_base A pp qj \\<in> carrier_vec nc\"\n    \"non_pivot_base A pp qj $ qj = 1\"\n    \"A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\"\n    \"\\<And> qj'. qj' < nc \\<Longrightarrow> qj' \\<notin> snd ` set pp \\<Longrightarrow> qj \\<noteq> qj' \\<Longrightarrow> non_pivot_base A pp qj $ qj' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (non_pivot_base A pp qj \\<in> carrier_vec nc &&&\n     non_pivot_base A pp qj $ qj = (1::'a)) &&&\n    A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr &&&\n    (\\<And>qj'.\n        \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n         qj \\<noteq> qj'\\<rbrakk>\n        \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a))", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc", "have dim: \"dim_row A = nr\" \"dim_col A = nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row A = nr &&& dim_col A = nc", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "from ref[unfolded row_echelon_form_def]"], ["proof (chain)\npicking this:\n  \\<exists>f. pivot_fun A f (dim_col A)", "obtain p \n  where pivot: \"pivot_fun A p nc\""], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. (\\<And>p. pivot_fun A p nc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using dim"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. (\\<And>p. pivot_fun A p nc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pivot_fun A p nc\n\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "note pivot' = pivot_funD[OF dim(1) pivot]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> p ?i \\<le> nc\n  \\<lbrakk>?i < nr; ?j < p ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> p ?i < p (Suc ?i) \\<or> p (Suc ?i) = nc\n  \\<lbrakk>?i < nr; p ?i < nc\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, p ?i) = (1::'a)\n  \\<lbrakk>?i < nr; p ?i < nc; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', p ?i) = (0::'a)\n\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "note pp = pivot_positions[OF A pivot, folded pp]"], ["proof (state)\nthis:\n  set pp = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst pp)\n  distinct (map snd pp)\n  length pp = card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "let ?p = \"\\<lambda> i. i < nr \\<and> p i = nc \\<or> i = nr\""], ["proof (state)\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "let ?spp = \"map prod.swap pp\""], ["proof (state)\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "let ?map = \"map_of ?spp\""], ["proof (state)\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "define I where \"I = (\\<lambda> i. case map_of (map prod.swap pp) i of Some j \\<Rightarrow> - A $$ (j,qj) | None \\<Rightarrow> 0)\""], ["proof (state)\nthis:\n  I =\n  (\\<lambda>i.\n      case map_of (map prod.swap pp) i of None \\<Rightarrow> 0::'a\n      | Some j \\<Rightarrow> - A $$ (j, qj))\n\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "have d: \"non_pivot_base A pp qj = vec nc (\\<lambda> i. if i = qj then 1 else I i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_pivot_base A pp qj =\n    vec nc (\\<lambda>i. if i = qj then 1::'a else I i)", "unfolding non_pivot_base_def Let_def dim I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nc\n     (\\<lambda>i.\n         if i = qj then 1::'a\n         else case map_of (map prod.swap pp) i of None \\<Rightarrow> 0::'a\n              | Some j \\<Rightarrow> - A $$ (j, qj)) =\n    vec nc\n     (\\<lambda>i.\n         if i = qj then 1::'a\n         else case map_of (map prod.swap pp) i of None \\<Rightarrow> 0::'a\n              | Some j \\<Rightarrow> - A $$ (j, qj))", ".."], ["proof (state)\nthis:\n  non_pivot_base A pp qj =\n  vec nc (\\<lambda>i. if i = qj then 1::'a else I i)\n\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "from pp"], ["proof (chain)\npicking this:\n  set pp = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst pp)\n  distinct (map snd pp)\n  length pp = card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}", "have dist: \"distinct (map fst ?spp)\""], ["proof (prove)\nusing this:\n  set pp = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst pp)\n  distinct (map snd pp)\n  length pp = card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. distinct (map fst (map prod.swap pp))", "unfolding map_map o_def prod.swap_def"], ["proof (prove)\nusing this:\n  set pp = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  distinct (map fst pp)\n  distinct (map snd pp)\n  length pp = card {i. i < nr \\<and> row A i \\<noteq> 0\\<^sub>v nc}\n\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>x. fst (snd x, fst x)) pp)", "by auto"], ["proof (state)\nthis:\n  distinct (map fst (map prod.swap pp))\n\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "let ?r = \"set (map snd pp)\""], ["proof (state)\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "have r: \"?r = p ` {0 ..< nr} - {nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map snd pp) = p ` {0..<nr} - {nc}", "unfolding set_map pp"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc} = p ` {0..<nr} - {nc}", "by force"], ["proof (state)\nthis:\n  set (map snd pp) = p ` {0..<nr} - {nc}\n\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "let ?l = \"set (map fst pp)\""], ["proof (state)\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "from qj"], ["proof (chain)\npicking this:\n  qj < nc\n  qj \\<notin> snd ` set pp", "have qj': \"qj \\<notin> p ` {0 ..< nr}\""], ["proof (prove)\nusing this:\n  qj < nc\n  qj \\<notin> snd ` set pp\n\ngoal (1 subgoal):\n 1. qj \\<notin> p ` {0..<nr}", "using r"], ["proof (prove)\nusing this:\n  qj < nc\n  qj \\<notin> snd ` set pp\n  set (map snd pp) = p ` {0..<nr} - {nc}\n\ngoal (1 subgoal):\n 1. qj \\<notin> p ` {0..<nr}", "by auto"], ["proof (state)\nthis:\n  qj \\<notin> p ` {0..<nr}\n\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "let ?v = \"non_pivot_base A pp qj\""], ["proof (state)\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "let ?P = \"p ` {0 ..< nr}\""], ["proof (state)\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "have dimv: \"dim_vec ?v = nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (non_pivot_base A pp qj) = nc", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec nc (\\<lambda>i. if i = qj then 1::'a else I i)) = nc", "by simp"], ["proof (state)\nthis:\n  dim_vec (non_pivot_base A pp qj) = nc\n\ngoal (4 subgoals):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc\n 2. non_pivot_base A pp qj $ qj = (1::'a)\n 3. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 4. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "thus \"?v \\<in> carrier_vec nc\""], ["proof (prove)\nusing this:\n  dim_vec (non_pivot_base A pp qj) = nc\n\ngoal (1 subgoal):\n 1. non_pivot_base A pp qj \\<in> carrier_vec nc", "unfolding carrier_vec_def"], ["proof (prove)\nusing this:\n  dim_vec (non_pivot_base A pp qj) = nc\n\ngoal (1 subgoal):\n 1. non_pivot_base A pp qj \\<in> {v. dim_vec v = nc}", "by auto"], ["proof (state)\nthis:\n  non_pivot_base A pp qj \\<in> carrier_vec nc\n\ngoal (3 subgoals):\n 1. non_pivot_base A pp qj $ qj = (1::'a)\n 2. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 3. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "show vqj: \"?v $ qj = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_pivot_base A pp qj $ qj = (1::'a)", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nc (\\<lambda>i. if i = qj then 1::'a else I i) $ qj = (1::'a)", "using qj"], ["proof (prove)\nusing this:\n  qj < nc\n  qj \\<notin> snd ` set pp\n\ngoal (1 subgoal):\n 1. vec nc (\\<lambda>i. if i = qj then 1::'a else I i) $ qj = (1::'a)", "by auto"], ["proof (state)\nthis:\n  non_pivot_base A pp qj $ qj = (1::'a)\n\ngoal (2 subgoals):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 2. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "{"], ["proof (state)\nthis:\n  non_pivot_base A pp qj $ qj = (1::'a)\n\ngoal (2 subgoals):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 2. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "fix qj'"], ["proof (state)\ngoal (2 subgoals):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 2. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "assume *: \"qj' < nc\" \"qj \\<noteq> qj'\" \"qj' \\<notin> snd ` set pp\""], ["proof (state)\nthis:\n  qj' < nc\n  qj \\<noteq> qj'\n  qj' \\<notin> snd ` set pp\n\ngoal (2 subgoals):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 2. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "hence \"?map qj' = None\""], ["proof (prove)\nusing this:\n  qj' < nc\n  qj \\<noteq> qj'\n  qj' \\<notin> snd ` set pp\n\ngoal (1 subgoal):\n 1. map_of (map prod.swap pp) qj' = None", "unfolding map_of_eq_None_iff"], ["proof (prove)\nusing this:\n  qj' < nc\n  qj \\<noteq> qj'\n  qj' \\<notin> snd ` set pp\n\ngoal (1 subgoal):\n 1. qj' \\<notin> fst ` set (map prod.swap pp)", "by force"], ["proof (state)\nthis:\n  map_of (map prod.swap pp) qj' = None\n\ngoal (2 subgoals):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 2. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "hence \"I qj' = 0\""], ["proof (prove)\nusing this:\n  map_of (map prod.swap pp) qj' = None\n\ngoal (1 subgoal):\n 1. I qj' = (0::'a)", "unfolding I_def"], ["proof (prove)\nusing this:\n  map_of (map prod.swap pp) qj' = None\n\ngoal (1 subgoal):\n 1. (case map_of (map prod.swap pp) qj' of None \\<Rightarrow> 0::'a\n     | Some j \\<Rightarrow> - A $$ (j, qj)) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  I qj' = (0::'a)\n\ngoal (2 subgoals):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n 2. \\<And>qj'.\n       \\<lbrakk>qj' < nc; qj' \\<notin> snd ` set pp;\n        qj \\<noteq> qj'\\<rbrakk>\n       \\<Longrightarrow> non_pivot_base A pp qj $ qj' = (0::'a)", "with *"], ["proof (chain)\npicking this:\n  qj' < nc\n  qj \\<noteq> qj'\n  qj' \\<notin> snd ` set pp\n  I qj' = (0::'a)", "show \"non_pivot_base A pp qj $ qj' = 0\""], ["proof (prove)\nusing this:\n  qj' < nc\n  qj \\<noteq> qj'\n  qj' \\<notin> snd ` set pp\n  I qj' = (0::'a)\n\ngoal (1 subgoal):\n 1. non_pivot_base A pp qj $ qj' = (0::'a)", "unfolding d"], ["proof (prove)\nusing this:\n  qj' < nc\n  qj \\<noteq> qj'\n  qj' \\<notin> snd ` set pp\n  I qj' = (0::'a)\n\ngoal (1 subgoal):\n 1. vec nc (\\<lambda>i. if i = qj then 1::'a else I i) $ qj' = (0::'a)", "by simp"], ["proof (state)\nthis:\n  non_pivot_base A pp qj $ qj' = (0::'a)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?qj'2 < nc; qj \\<noteq> ?qj'2;\n   ?qj'2 \\<notin> snd ` set pp\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A pp qj $ ?qj'2 = (0::'a)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?qj'2 < nc; qj \\<noteq> ?qj'2;\n   ?qj'2 \\<notin> snd ` set pp\\<rbrakk>\n  \\<Longrightarrow> non_pivot_base A pp qj $ ?qj'2 = (0::'a)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr", "assume i: \"i < nr\""], ["proof (state)\nthis:\n  i < nr\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr", "let ?I = \"{j. ?map j = Some i}\""], ["proof (state)\ngoal (1 subgoal):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr", "have \"row A i \\<bullet> ?v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have id: \"({0..<nc} \\<inter> ?P) \\<union> ({0..<nc} - ?P) = {0..<nc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<nc} \\<inter> p ` {0..<nr} \\<union> ({0..<nc} - p ` {0..<nr}) =\n    {0..<nc}", "by auto"], ["proof (state)\nthis:\n  {0..<nc} \\<inter> p ` {0..<nr} \\<union> ({0..<nc} - p ` {0..<nr}) =\n  {0..<nc}\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "let ?e = \"\\<lambda> j. row A i $ j * ?v $ j\""], ["proof (state)\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "let ?e' = \"\\<lambda> j. (if ?map j = Some i then - A $$ (i, qj) else 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "assume j: \"j < nc\" \"j \\<in> ?P\""], ["proof (state)\nthis:\n  j < nc\n  j \\<in> p ` {0..<nr}\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "then"], ["proof (chain)\npicking this:\n  j < nc\n  j \\<in> p ` {0..<nr}", "obtain ii where ii: \"ii < nr\" and jpi: \"j = p ii\" and pii: \"p ii < nc\""], ["proof (prove)\nusing this:\n  j < nc\n  j \\<in> p ` {0..<nr}\n\ngoal (1 subgoal):\n 1. (\\<And>ii.\n        \\<lbrakk>ii < nr; j = p ii; p ii < nc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ii < nr\n  j = p ii\n  p ii < nc\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "hence mem: \"(ii,j) \\<in> set pp\" and \"(j,ii) \\<in> set ?spp\""], ["proof (prove)\nusing this:\n  ii < nr\n  j = p ii\n  p ii < nc\n\ngoal (1 subgoal):\n 1. (ii, j) \\<in> set pp &&& (j, ii) \\<in> set (map prod.swap pp)", "by (auto simp: pp)"], ["proof (state)\nthis:\n  (ii, j) \\<in> set pp\n  (j, ii) \\<in> set (map prod.swap pp)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "from map_of_is_SomeI[OF dist this(2)]"], ["proof (chain)\npicking this:\n  map_of (map prod.swap pp) j = Some ii", "have map: \"?map j = Some ii\""], ["proof (prove)\nusing this:\n  map_of (map prod.swap pp) j = Some ii\n\ngoal (1 subgoal):\n 1. map_of (map prod.swap pp) j = Some ii", "by auto"], ["proof (state)\nthis:\n  map_of (map prod.swap pp) j = Some ii\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "from mem j qj"], ["proof (chain)\npicking this:\n  (ii, j) \\<in> set pp\n  j < nc\n  j \\<in> p ` {0..<nr}\n  qj < nc\n  qj \\<notin> snd ` set pp", "have jqj: \"j \\<noteq> qj\""], ["proof (prove)\nusing this:\n  (ii, j) \\<in> set pp\n  j < nc\n  j \\<in> p ` {0..<nr}\n  qj < nc\n  qj \\<notin> snd ` set pp\n\ngoal (1 subgoal):\n 1. j \\<noteq> qj", "by force"], ["proof (state)\nthis:\n  j \\<noteq> qj\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "note p = pivot'(4-5)[OF ii pii]"], ["proof (state)\nthis:\n  A $$ (ii, p ii) = (1::'a)\n  \\<lbrakk>?i' < nr; ?i' \\<noteq> ii\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', p ii) = (0::'a)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "define start where \"start = ?e j\""], ["proof (state)\nthis:\n  start = row A i $ j * non_pivot_base A pp qj $ j\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"start = A $$ (i,j) * ?v $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start = A $$ (i, j) * non_pivot_base A pp qj $ j", "using j i A"], ["proof (prove)\nusing this:\n  j < nc\n  j \\<in> p ` {0..<nr}\n  i < nr\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. start = A $$ (i, j) * non_pivot_base A pp qj $ j", "by (auto simp: start_def)"], ["proof (state)\nthis:\n  start = A $$ (i, j) * non_pivot_base A pp qj $ j\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  start = A $$ (i, j) * non_pivot_base A pp qj $ j\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"A $$ (i,j) = A $$ (i, p ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, j) = A $$ (i, p ii)", "unfolding jpi"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, p ii) = A $$ (i, p ii)", ".."], ["proof (state)\nthis:\n  A $$ (i, j) = A $$ (i, p ii)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  A $$ (i, j) = A $$ (i, p ii)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"\\<dots> = (if i = ii then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, p ii) = (if i = ii then 1::'a else (0::'a))", "using p(1) p(2)[OF i]"], ["proof (prove)\nusing this:\n  A $$ (ii, p ii) = (1::'a)\n  i \\<noteq> ii \\<Longrightarrow> A $$ (i, p ii) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, p ii) = (if i = ii then 1::'a else (0::'a))", "by auto"], ["proof (state)\nthis:\n  A $$ (i, p ii) = (if i = ii then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  A $$ (i, p ii) = (if i = ii then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"\\<dots> * ?v $ j = (if i = ii then ?v $ j else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = ii then 1::'a else (0::'a)) * non_pivot_base A pp qj $ j =\n    (if i = ii then non_pivot_base A pp qj $ j else (0::'a))", "by simp"], ["proof (state)\nthis:\n  (if i = ii then 1::'a else (0::'a)) * non_pivot_base A pp qj $ j =\n  (if i = ii then non_pivot_base A pp qj $ j else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  (if i = ii then 1::'a else (0::'a)) * non_pivot_base A pp qj $ j =\n  (if i = ii then non_pivot_base A pp qj $ j else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"?v $ j = I j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_pivot_base A pp qj $ j = I j", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nc (\\<lambda>i. if i = qj then 1::'a else I i) $ j = I j", "using j jqj A"], ["proof (prove)\nusing this:\n  j < nc\n  j \\<in> p ` {0..<nr}\n  j \\<noteq> qj\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. vec nc (\\<lambda>i. if i = qj then 1::'a else I i) $ j = I j", "by auto"], ["proof (state)\nthis:\n  non_pivot_base A pp qj $ j = I j\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  non_pivot_base A pp qj $ j = I j\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"I j = - A $$ (ii, qj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I j = - A $$ (ii, qj)", "unfolding I_def map"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case Some ii of None \\<Rightarrow> 0::'a\n     | Some j \\<Rightarrow> - A $$ (j, qj)) =\n    - A $$ (ii, qj)", "by simp"], ["proof (state)\nthis:\n  I j = - A $$ (ii, qj)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  start = (if i = ii then - A $$ (ii, qj) else (0::'a))", "have \"?e j = ?e' j\""], ["proof (prove)\nusing this:\n  start = (if i = ii then - A $$ (ii, qj) else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i $ j * non_pivot_base A pp qj $ j =\n    (if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a))", "unfolding start_def map"], ["proof (prove)\nusing this:\n  row A i $ j * non_pivot_base A pp qj $ j =\n  (if i = ii then - A $$ (ii, qj) else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i $ j * non_pivot_base A pp qj $ j =\n    (if Some ii = Some i then - A $$ (i, qj) else (0::'a))", "by auto"], ["proof (state)\nthis:\n  row A i $ j * non_pivot_base A pp qj $ j =\n  (if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj) else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < nc; ?j2 \\<in> p ` {0..<nr}\\<rbrakk>\n  \\<Longrightarrow> row A i $ ?j2 * non_pivot_base A pp qj $ ?j2 =\n                    (if map_of (map prod.swap pp) ?j2 = Some i\n                     then - A $$ (i, qj) else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "note piv = this"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < nc; ?j2 \\<in> p ` {0..<nr}\\<rbrakk>\n  \\<Longrightarrow> row A i $ ?j2 * non_pivot_base A pp qj $ ?j2 =\n                    (if map_of (map prod.swap pp) ?j2 = Some i\n                     then - A $$ (i, qj) else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"row A i \\<bullet> ?v = (\\<Sum> j = 0..<nc. ?e j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj =\n    (\\<Sum>j = 0..<nc. row A i $ j * non_pivot_base A pp qj $ j)", "unfolding row_def scalar_prod_def dimv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<nc.\n        vec (dim_col A) (\\<lambda>j. A $$ (i, j)) $ ia *\n        non_pivot_base A pp qj $ ia) =\n    (\\<Sum>j = 0..<nc.\n        vec (dim_col A) (\\<lambda>j. A $$ (i, j)) $ j *\n        non_pivot_base A pp qj $ j)", ".."], ["proof (state)\nthis:\n  row A i \\<bullet> non_pivot_base A pp qj =\n  (\\<Sum>j = 0..<nc. row A i $ j * non_pivot_base A pp qj $ j)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  row A i \\<bullet> non_pivot_base A pp qj =\n  (\\<Sum>j = 0..<nc. row A i $ j * non_pivot_base A pp qj $ j)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"\\<dots> = sum ?e ({0..<nc} \\<inter> ?P) + sum ?e ({0..<nc} - ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<nc. row A i $ j * non_pivot_base A pp qj $ j) =\n    (\\<Sum>j\\<in>{0..<nc} \\<inter> p ` {0..<nr}.\n       row A i $ j * non_pivot_base A pp qj $ j) +\n    (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr}.\n       row A i $ j * non_pivot_base A pp qj $ j)", "by (subst sum.union_disjoint[symmetric], auto simp: id)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nc. row A i $ j * non_pivot_base A pp qj $ j) =\n  (\\<Sum>j\\<in>{0..<nc} \\<inter> p ` {0..<nr}.\n     row A i $ j * non_pivot_base A pp qj $ j) +\n  (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr}.\n     row A i $ j * non_pivot_base A pp qj $ j)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nc. row A i $ j * non_pivot_base A pp qj $ j) =\n  (\\<Sum>j\\<in>{0..<nc} \\<inter> p ` {0..<nr}.\n     row A i $ j * non_pivot_base A pp qj $ j) +\n  (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr}.\n     row A i $ j * non_pivot_base A pp qj $ j)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"sum ?e ({0..<nc} - ?P) = ?e qj + sum ?e ({0 ..<nc} - ?P - {qj})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr}.\n       row A i $ j * non_pivot_base A pp qj $ j) =\n    row A i $ qj * non_pivot_base A pp qj $ qj +\n    (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr} - {qj}.\n       row A i $ j * non_pivot_base A pp qj $ j)", "by (rule sum.remove, insert qj qj', auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr}.\n     row A i $ j * non_pivot_base A pp qj $ j) =\n  row A i $ qj * non_pivot_base A pp qj $ qj +\n  (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr} - {qj}.\n     row A i $ j * non_pivot_base A pp qj $ j)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr}.\n     row A i $ j * non_pivot_base A pp qj $ j) =\n  row A i $ qj * non_pivot_base A pp qj $ qj +\n  (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr} - {qj}.\n     row A i $ j * non_pivot_base A pp qj $ j)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"?e qj = row A i $ qj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i $ qj * non_pivot_base A pp qj $ qj = row A i $ qj", "unfolding vqj"], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i $ qj * (1::'a) = row A i $ qj", "by simp"], ["proof (state)\nthis:\n  row A i $ qj * non_pivot_base A pp qj $ qj = row A i $ qj\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  row A i $ qj * non_pivot_base A pp qj $ qj = row A i $ qj\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"row A i $ qj = A $$ (i, qj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i $ qj = A $$ (i, qj)", "using i A qj"], ["proof (prove)\nusing this:\n  i < nr\n  A \\<in> carrier_mat nr nc\n  qj < nc\n  qj \\<notin> snd ` set pp\n\ngoal (1 subgoal):\n 1. row A i $ qj = A $$ (i, qj)", "by auto"], ["proof (state)\nthis:\n  row A i $ qj = A $$ (i, qj)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  row A i $ qj = A $$ (i, qj)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"sum ?e ({0 ..<nc} - ?P - {qj}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr} - {qj}.\n       row A i $ j * non_pivot_base A pp qj $ j) =\n    (0::'a)", "proof (rule sum.neutral, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<nc} - p ` {0..<nr} - {qj} \\<Longrightarrow>\n       row A i $ x * non_pivot_base A pp qj $ x = (0::'a)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<nc} - p ` {0..<nr} - {qj} \\<Longrightarrow>\n       row A i $ x * non_pivot_base A pp qj $ x = (0::'a)", "assume \"j \\<in> {0 ..<nc} - ?P - {qj}\""], ["proof (state)\nthis:\n  j \\<in> {0..<nc} - p ` {0..<nr} - {qj}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<nc} - p ` {0..<nr} - {qj} \\<Longrightarrow>\n       row A i $ x * non_pivot_base A pp qj $ x = (0::'a)", "hence j: \"j < nc\" \"j \\<notin> ?P\" \"j \\<noteq> qj\" \"j \\<notin> ?r\""], ["proof (prove)\nusing this:\n  j \\<in> {0..<nc} - p ` {0..<nr} - {qj}\n\ngoal (1 subgoal):\n 1. (j < nc &&& j \\<notin> p ` {0..<nr}) &&&\n    j \\<noteq> qj &&& j \\<notin> set (map snd pp)", "unfolding r"], ["proof (prove)\nusing this:\n  j \\<in> {0..<nc} - p ` {0..<nr} - {qj}\n\ngoal (1 subgoal):\n 1. (j < nc &&& j \\<notin> p ` {0..<nr}) &&&\n    j \\<noteq> qj &&& j \\<notin> p ` {0..<nr} - {nc}", "by auto"], ["proof (state)\nthis:\n  j < nc\n  j \\<notin> p ` {0..<nr}\n  j \\<noteq> qj\n  j \\<notin> set (map snd pp)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<nc} - p ` {0..<nr} - {qj} \\<Longrightarrow>\n       row A i $ x * non_pivot_base A pp qj $ x = (0::'a)", "hence id: \"map_of ?spp j = None\""], ["proof (prove)\nusing this:\n  j < nc\n  j \\<notin> p ` {0..<nr}\n  j \\<noteq> qj\n  j \\<notin> set (map snd pp)\n\ngoal (1 subgoal):\n 1. map_of (map prod.swap pp) j = None", "unfolding map_of_eq_None_iff"], ["proof (prove)\nusing this:\n  j < nc\n  j \\<notin> p ` {0..<nr}\n  j \\<noteq> qj\n  j \\<notin> set (map snd pp)\n\ngoal (1 subgoal):\n 1. j \\<notin> fst ` set (map prod.swap pp)", "by force"], ["proof (state)\nthis:\n  map_of (map prod.swap pp) j = None\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<nc} - p ` {0..<nr} - {qj} \\<Longrightarrow>\n       row A i $ x * non_pivot_base A pp qj $ x = (0::'a)", "have \"?v $ j = I j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_pivot_base A pp qj $ j = I j", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nc (\\<lambda>i. if i = qj then 1::'a else I i) $ j = I j", "using j"], ["proof (prove)\nusing this:\n  j < nc\n  j \\<notin> p ` {0..<nr}\n  j \\<noteq> qj\n  j \\<notin> set (map snd pp)\n\ngoal (1 subgoal):\n 1. vec nc (\\<lambda>i. if i = qj then 1::'a else I i) $ j = I j", "by simp"], ["proof (state)\nthis:\n  non_pivot_base A pp qj $ j = I j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<nc} - p ` {0..<nr} - {qj} \\<Longrightarrow>\n       row A i $ x * non_pivot_base A pp qj $ x = (0::'a)", "also"], ["proof (state)\nthis:\n  non_pivot_base A pp qj $ j = I j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<nc} - p ` {0..<nr} - {qj} \\<Longrightarrow>\n       row A i $ x * non_pivot_base A pp qj $ x = (0::'a)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I j = (0::'a)", "unfolding I_def id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case None of None \\<Rightarrow> 0::'a\n     | Some j \\<Rightarrow> - A $$ (j, qj)) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  I j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<nc} - p ` {0..<nr} - {qj} \\<Longrightarrow>\n       row A i $ x * non_pivot_base A pp qj $ x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  non_pivot_base A pp qj $ j = (0::'a)", "show \"row A i $ j * ?v $ j = 0\""], ["proof (prove)\nusing this:\n  non_pivot_base A pp qj $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. row A i $ j * non_pivot_base A pp qj $ j = (0::'a)", "by simp"], ["proof (state)\nthis:\n  row A i $ j * non_pivot_base A pp qj $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr} - {qj}.\n     row A i $ j * non_pivot_base A pp qj $ j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..<nc} - p ` {0..<nr} - {qj}.\n     row A i $ j * non_pivot_base A pp qj $ j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"A $$ (i, qj) + 0 = A $$ (i, qj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$ (i, qj) + (0::'a) = A $$ (i, qj)", "by simp"], ["proof (state)\nthis:\n  A $$ (i, qj) + (0::'a) = A $$ (i, qj)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  A $$ (i, qj) + (0::'a) = A $$ (i, qj)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"sum ?e ({0..<nc} \\<inter> ?P) = sum ?e' ({0..<nc} \\<inter> ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{0..<nc} \\<inter> p ` {0..<nr}.\n       row A i $ j * non_pivot_base A pp qj $ j) =\n    (\\<Sum>j\\<in>{0..<nc} \\<inter> p ` {0..<nr}.\n       if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n       else (0::'a))", "by (rule sum.cong, insert piv, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..<nc} \\<inter> p ` {0..<nr}.\n     row A i $ j * non_pivot_base A pp qj $ j) =\n  (\\<Sum>j\\<in>{0..<nc} \\<inter> p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..<nc} \\<inter> p ` {0..<nr}.\n     row A i $ j * non_pivot_base A pp qj $ j) =\n  (\\<Sum>j\\<in>{0..<nc} \\<inter> p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"{0..<nc} \\<inter> ?P = {0..<nc} \\<inter> ?I \\<inter> ?P \\<union> ({0..<nc} - ?I) \\<inter> ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<nc} \\<inter> p ` {0..<nr} =\n    {0..<nc} \\<inter> {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n    p ` {0..<nr} \\<union>\n    ({0..<nc} - {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n    p ` {0..<nr}", "by auto"], ["proof (state)\nthis:\n  {0..<nc} \\<inter> p ` {0..<nr} =\n  {0..<nc} \\<inter> {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n  p ` {0..<nr} \\<union>\n  ({0..<nc} - {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n  p ` {0..<nr}\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  {0..<nc} \\<inter> p ` {0..<nr} =\n  {0..<nc} \\<inter> {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n  p ` {0..<nr} \\<union>\n  ({0..<nc} - {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n  p ` {0..<nr}\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"sum ?e' ({0..<nc} \\<inter> ?I \\<inter> ?P \\<union> ({0..<nc} - ?I) \\<inter> ?P)\n        = sum ?e' ({0..<nc} \\<inter> ?I \\<inter> ?P) + sum ?e' (({0..<nc} - ?I) \\<inter> ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr} \\<union>\n                 ({0..<nc} -\n                  {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n                 p ` {0..<nr}.\n       if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n       else (0::'a)) =\n    (\\<Sum>j\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n       else (0::'a)) +\n    (\\<Sum>j\\<in>({0..<nc} -\n                  {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n                 p ` {0..<nr}.\n       if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n       else (0::'a))", "by (rule sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr} \\<union>\n               ({0..<nc} -\n                {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n               p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a)) =\n  (\\<Sum>j\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a)) +\n  (\\<Sum>j\\<in>({0..<nc} -\n                {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n               p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr} \\<union>\n               ({0..<nc} -\n                {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n               p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a)) =\n  (\\<Sum>j\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a)) +\n  (\\<Sum>j\\<in>({0..<nc} -\n                {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n               p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"sum ?e' (({0..<nc} - ?I) \\<inter> ?P) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>({0..<nc} -\n                  {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n                 p ` {0..<nr}.\n       if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n       else (0::'a)) =\n    (0::'a)", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>({0..<nc} -\n                {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n               p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>({0..<nc} -\n                {j. map_of (map prod.swap pp) j = Some i}) \\<inter>\n               p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"sum ?e' ({0..<nc} \\<inter> ?I \\<inter> ?P) = \n        sum (\\<lambda> _. - A $$ (i, qj)) ({0..<nc} \\<inter> ?I \\<inter> ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n       else (0::'a)) =\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a)) =\n  (\\<Sum>_\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     - A $$ (i, qj))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     if map_of (map prod.swap pp) j = Some i then - A $$ (i, qj)\n     else (0::'a)) =\n  (\\<Sum>_\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     - A $$ (i, qj))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"\\<dots> + 0 = \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    (0::'a) =\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>_\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     - A $$ (i, qj)) +\n  (0::'a) =\n  (\\<Sum>_\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     - A $$ (i, qj))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>_\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     - A $$ (i, qj)) +\n  (0::'a) =\n  (\\<Sum>_\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     - A $$ (i, qj))\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "have \"sum (\\<lambda> _. - A $$ (i, qj)) ({0..<nc} \\<inter> ?I \\<inter> ?P) + A $$ (i, qj) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "proof (cases \"i \\<in> ?l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)\n 2. i \\<notin> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  i \\<notin> set (map fst pp)\n\ngoal (2 subgoals):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)\n 2. i \\<notin> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "with pp(1) i"], ["proof (chain)\npicking this:\n  set pp = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  i < nr\n  i \\<notin> set (map fst pp)", "have \"p i = nc\""], ["proof (prove)\nusing this:\n  set pp = {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  i < nr\n  i \\<notin> set (map fst pp)\n\ngoal (1 subgoal):\n 1. p i = nc", "by force"], ["proof (state)\nthis:\n  p i = nc\n\ngoal (2 subgoals):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)\n 2. i \\<notin> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "from pivot'(2)[OF i, unfolded this, OF qj(1)]"], ["proof (chain)\npicking this:\n  A $$ (i, qj) = (0::'a)", "have z: \"A $$ (i, qj) = 0\""], ["proof (prove)\nusing this:\n  A $$ (i, qj) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $$ (i, qj) = (0::'a)", "."], ["proof (state)\nthis:\n  A $$ (i, qj) = (0::'a)\n\ngoal (2 subgoals):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)\n 2. i \\<notin> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "by (subst sum.neutral, auto simp: z)"], ["proof (state)\nthis:\n  (\\<Sum>_\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     - A $$ (i, qj)) +\n  A $$ (i, qj) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  i \\<in> set (map fst pp)\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "then"], ["proof (chain)\npicking this:\n  i \\<in> set (map fst pp)", "obtain j where mem: \"(i,j) \\<in> set pp\" and id: \"(j,i) \\<in> set ?spp\""], ["proof (prove)\nusing this:\n  i \\<in> set (map fst pp)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>(i, j) \\<in> set pp;\n         (j, i) \\<in> set (map prod.swap pp)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (i, j) \\<in> set pp\n  (j, i) \\<in> set (map prod.swap pp)\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "from map_of_is_SomeI[OF dist this(2)]"], ["proof (chain)\npicking this:\n  map_of (map prod.swap pp) j = Some i", "have map: \"?map j = Some i\""], ["proof (prove)\nusing this:\n  map_of (map prod.swap pp) j = Some i\n\ngoal (1 subgoal):\n 1. map_of (map prod.swap pp) j = Some i", "."], ["proof (state)\nthis:\n  map_of (map prod.swap pp) j = Some i\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "from pivot'(1)[OF i]"], ["proof (chain)\npicking this:\n  p i \\<le> nc", "have pi: \"p i \\<le> nc\""], ["proof (prove)\nusing this:\n  p i \\<le> nc\n\ngoal (1 subgoal):\n 1. p i \\<le> nc", "."], ["proof (state)\nthis:\n  p i \\<le> nc\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "with mem[unfolded pp]"], ["proof (chain)\npicking this:\n  (i, j) \\<in> {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  p i \\<le> nc", "have j: \"j = p i\" \"j < nc\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  p i \\<le> nc\n\ngoal (1 subgoal):\n 1. j = p i &&& j < nc", "by auto"], ["proof (state)\nthis:\n  j = p i\n  j < nc\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "{"], ["proof (state)\nthis:\n  j = p i\n  j < nc\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "fix j'"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "assume \"j' \\<in> ?I\""], ["proof (state)\nthis:\n  j' \\<in> {j. map_of (map prod.swap pp) j = Some i}\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "hence \"?map j' = Some i\""], ["proof (prove)\nusing this:\n  j' \\<in> {j. map_of (map prod.swap pp) j = Some i}\n\ngoal (1 subgoal):\n 1. map_of (map prod.swap pp) j' = Some i", "by auto"], ["proof (state)\nthis:\n  map_of (map prod.swap pp) j' = Some i\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "from map_of_SomeD[OF this]"], ["proof (chain)\npicking this:\n  (j', i) \\<in> set (map prod.swap pp)", "have \"(i, j') \\<in> set pp\""], ["proof (prove)\nusing this:\n  (j', i) \\<in> set (map prod.swap pp)\n\ngoal (1 subgoal):\n 1. (i, j') \\<in> set pp", "by auto"], ["proof (state)\nthis:\n  (i, j') \\<in> set pp\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "with mem pp(2)"], ["proof (chain)\npicking this:\n  (i, j) \\<in> set pp\n  distinct (map fst pp)\n  (i, j') \\<in> set pp", "have \"j' = j\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> set pp\n  distinct (map fst pp)\n  (i, j') \\<in> set pp\n\ngoal (1 subgoal):\n 1. j' = j", "using map_of_is_SomeI"], ["proof (prove)\nusing this:\n  (i, j) \\<in> set pp\n  distinct (map fst pp)\n  (i, j') \\<in> set pp\n  \\<lbrakk>distinct (map fst ?xys); (?x, ?y) \\<in> set ?xys\\<rbrakk>\n  \\<Longrightarrow> map_of ?xys ?x = Some ?y\n\ngoal (1 subgoal):\n 1. j' = j", "by fastforce"], ["proof (state)\nthis:\n  j' = j\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "}"], ["proof (state)\nthis:\n  ?j'2 \\<in> {j. map_of (map prod.swap pp) j = Some i} \\<Longrightarrow>\n  ?j'2 = j\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "with map"], ["proof (chain)\npicking this:\n  map_of (map prod.swap pp) j = Some i\n  ?j'2 \\<in> {j. map_of (map prod.swap pp) j = Some i} \\<Longrightarrow>\n  ?j'2 = j", "have II: \"?I = {j}\""], ["proof (prove)\nusing this:\n  map_of (map prod.swap pp) j = Some i\n  ?j'2 \\<in> {j. map_of (map prod.swap pp) j = Some i} \\<Longrightarrow>\n  ?j'2 = j\n\ngoal (1 subgoal):\n 1. {j. map_of (map prod.swap pp) j = Some i} = {j}", "by blast"], ["proof (state)\nthis:\n  {j. map_of (map prod.swap pp) j = Some i} = {j}\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "have II: \"{0..<nc} \\<inter> ?I \\<inter> ?P = {j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<nc} \\<inter> {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n    p ` {0..<nr} =\n    {j}", "unfolding II"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<nc} \\<inter> {j} \\<inter> p ` {0..<nr} = {j}", "using mem[unfolded pp] i j"], ["proof (prove)\nusing this:\n  (i, j) \\<in> {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc}\n  i < nr\n  j = p i\n  j < nc\n\ngoal (1 subgoal):\n 1. {0..<nc} \\<inter> {j} \\<inter> p ` {0..<nr} = {j}", "by auto"], ["proof (state)\nthis:\n  {0..<nc} \\<inter> {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n  p ` {0..<nr} =\n  {j}\n\ngoal (1 subgoal):\n 1. i \\<in> set (map fst pp) \\<Longrightarrow>\n    (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<in>{0..<nc} \\<inter>\n                 {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n                 p ` {0..<nr}.\n       - A $$ (i, qj)) +\n    A $$ (i, qj) =\n    (0::'a)", "unfolding II"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<in>{j}. - A $$ (i, qj)) + A $$ (i, qj) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>_\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     - A $$ (i, qj)) +\n  A $$ (i, qj) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>_\\<in>{0..<nc} \\<inter>\n               {j. map_of (map prod.swap pp) j = Some i} \\<inter>\n               p ` {0..<nr}.\n     - A $$ (i, qj)) +\n  A $$ (i, qj) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "show \"row A i \\<bullet> ?v = 0\""], ["proof (prove)\nusing this:\n  row A i \\<bullet> non_pivot_base A pp qj = (0::'a)\n\ngoal (1 subgoal):\n 1. row A i \\<bullet> non_pivot_base A pp qj = (0::'a)", "."], ["proof (state)\nthis:\n  row A i \\<bullet> non_pivot_base A pp qj = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row A i \\<bullet> non_pivot_base A pp qj = (0::'a)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr", "}"], ["proof (state)\nthis:\n  ?i2 < nr \\<Longrightarrow>\n  row A ?i2 \\<bullet> non_pivot_base A pp qj = (0::'a)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr", "note main = this"], ["proof (state)\nthis:\n  ?i2 < nr \\<Longrightarrow>\n  row A ?i2 \\<bullet> non_pivot_base A pp qj = (0::'a)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr", "show \"A *\\<^sub>v ?v = 0\\<^sub>v nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr", "by (rule eq_vecI, auto simp: dim main)"], ["proof (state)\nthis:\n  A *\\<^sub>v non_pivot_base A pp qj = 0\\<^sub>v nr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_base_vector: assumes \"snd ` set (pivot_positions A) \\<noteq> {0 ..< nc}\"\n  shows \n    \"find_base_vector A \\<in> carrier_vec nc\"\n    \"find_base_vector A \\<noteq> 0\\<^sub>v nc\"\n    \"A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_base_vector A \\<in> carrier_vec nc &&&\n    find_base_vector A \\<noteq> 0\\<^sub>v nc &&&\n    A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. find_base_vector A \\<in> carrier_vec nc\n 2. find_base_vector A \\<noteq> 0\\<^sub>v nc\n 3. A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "define cands where \"cands = filter (\\<lambda> j. j \\<notin> snd ` set (pivot_positions A)) [0 ..< nc]\""], ["proof (state)\nthis:\n  cands =\n  filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A)) [0..<nc]\n\ngoal (3 subgoals):\n 1. find_base_vector A \\<in> carrier_vec nc\n 2. find_base_vector A \\<noteq> 0\\<^sub>v nc\n 3. A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc", "have dim: \"dim_row A = nr\" \"dim_col A = nc\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. dim_row A = nr &&& dim_col A = nc", "by auto"], ["proof (state)\nthis:\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (3 subgoals):\n 1. find_base_vector A \\<in> carrier_vec nc\n 2. find_base_vector A \\<noteq> 0\\<^sub>v nc\n 3. A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "from ref[unfolded row_echelon_form_def]"], ["proof (chain)\npicking this:\n  \\<exists>f. pivot_fun A f (dim_col A)", "obtain p \n  where pivot: \"pivot_fun A p nc\""], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. (\\<And>p. pivot_fun A p nc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using dim"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n  dim_row A = nr\n  dim_col A = nc\n\ngoal (1 subgoal):\n 1. (\\<And>p. pivot_fun A p nc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pivot_fun A p nc\n\ngoal (3 subgoals):\n 1. find_base_vector A \\<in> carrier_vec nc\n 2. find_base_vector A \\<noteq> 0\\<^sub>v nc\n 3. A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "note piv = pivot_funD[OF dim(1) pivot]"], ["proof (state)\nthis:\n  ?i < nr \\<Longrightarrow> p ?i \\<le> nc\n  \\<lbrakk>?i < nr; ?j < p ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> p ?i < p (Suc ?i) \\<or> p (Suc ?i) = nc\n  \\<lbrakk>?i < nr; p ?i < nc\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, p ?i) = (1::'a)\n  \\<lbrakk>?i < nr; p ?i < nc; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', p ?i) = (0::'a)\n\ngoal (3 subgoals):\n 1. find_base_vector A \\<in> carrier_vec nc\n 2. find_base_vector A \\<noteq> 0\\<^sub>v nc\n 3. A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "have \"set cands \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set cands \\<noteq> {}", "using assms piv"], ["proof (prove)\nusing this:\n  snd ` set (pivot_positions A) \\<noteq> {0..<nc}\n  ?i < nr \\<Longrightarrow> p ?i \\<le> nc\n  \\<lbrakk>?i < nr; ?j < p ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> p ?i < p (Suc ?i) \\<or> p (Suc ?i) = nc\n  \\<lbrakk>?i < nr; p ?i < nc\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, p ?i) = (1::'a)\n  \\<lbrakk>?i < nr; p ?i < nc; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', p ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. set cands \\<noteq> {}", "unfolding cands_def  pivot_positions[OF A pivot]"], ["proof (prove)\nusing this:\n  snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc} \\<noteq> {0..<nc}\n  ?i < nr \\<Longrightarrow> p ?i \\<le> nc\n  \\<lbrakk>?i < nr; ?j < p ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < nr; Suc ?i < nr\\<rbrakk>\n  \\<Longrightarrow> p ?i < p (Suc ?i) \\<or> p (Suc ?i) = nc\n  \\<lbrakk>?i < nr; p ?i < nc\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, p ?i) = (1::'a)\n  \\<lbrakk>?i < nr; p ?i < nc; ?i' < nr; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', p ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. set (filter\n          (\\<lambda>j.\n              j \\<notin> snd ` {(i, p i) |i. i < nr \\<and> p i \\<noteq> nc})\n          [0..<nc]) \\<noteq>\n    {}", "by (auto simp: le_neq_implies_less)"], ["proof (state)\nthis:\n  set cands \\<noteq> {}\n\ngoal (3 subgoals):\n 1. find_base_vector A \\<in> carrier_vec nc\n 2. find_base_vector A \\<noteq> 0\\<^sub>v nc\n 3. A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "then"], ["proof (chain)\npicking this:\n  set cands \\<noteq> {}", "obtain c cs where cands: \"cands = c # cs\""], ["proof (prove)\nusing this:\n  set cands \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>c cs. cands = c # cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases cands, auto)"], ["proof (state)\nthis:\n  cands = c # cs\n\ngoal (3 subgoals):\n 1. find_base_vector A \\<in> carrier_vec nc\n 2. find_base_vector A \\<noteq> 0\\<^sub>v nc\n 3. A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "hence res: \"find_base_vector A = non_pivot_base A (pivot_positions A) c\""], ["proof (prove)\nusing this:\n  cands = c # cs\n\ngoal (1 subgoal):\n 1. find_base_vector A = non_pivot_base A (pivot_positions A) c", "unfolding find_base_vector_def Let_def cands_def dim"], ["proof (prove)\nusing this:\n  filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A)) [0..<nc] =\n  c # cs\n\ngoal (1 subgoal):\n 1. non_pivot_base A (pivot_positions A)\n     (hd (filter (\\<lambda>j. j \\<notin> set (map snd (pivot_positions A)))\n           [0..<nc])) =\n    non_pivot_base A (pivot_positions A) c", "by auto"], ["proof (state)\nthis:\n  find_base_vector A = non_pivot_base A (pivot_positions A) c\n\ngoal (3 subgoals):\n 1. find_base_vector A \\<in> carrier_vec nc\n 2. find_base_vector A \\<noteq> 0\\<^sub>v nc\n 3. A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "from cands"], ["proof (chain)\npicking this:\n  cands = c # cs", "have \"c \\<in> set cands\""], ["proof (prove)\nusing this:\n  cands = c # cs\n\ngoal (1 subgoal):\n 1. c \\<in> set cands", "by auto"], ["proof (state)\nthis:\n  c \\<in> set cands\n\ngoal (3 subgoals):\n 1. find_base_vector A \\<in> carrier_vec nc\n 2. find_base_vector A \\<noteq> 0\\<^sub>v nc\n 3. A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "hence c: \"c < nc\" \"c \\<notin> snd ` set (pivot_positions A)\""], ["proof (prove)\nusing this:\n  c \\<in> set cands\n\ngoal (1 subgoal):\n 1. c < nc &&& c \\<notin> snd ` set (pivot_positions A)", "unfolding cands_def"], ["proof (prove)\nusing this:\n  c \\<in> set (filter (\\<lambda>j. j \\<notin> snd ` set (pivot_positions A))\n                [0..<nc])\n\ngoal (1 subgoal):\n 1. c < nc &&& c \\<notin> snd ` set (pivot_positions A)", "by auto"], ["proof (state)\nthis:\n  c < nc\n  c \\<notin> snd ` set (pivot_positions A)\n\ngoal (3 subgoals):\n 1. find_base_vector A \\<in> carrier_vec nc\n 2. find_base_vector A \\<noteq> 0\\<^sub>v nc\n 3. A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "from non_pivot_base[OF this, folded res] c"], ["proof (chain)\npicking this:\n  find_base_vector A \\<in> carrier_vec nc\n  find_base_vector A $ c = (1::'a)\n  A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr\n  \\<lbrakk>?qj' < nc; ?qj' \\<notin> snd ` set (pivot_positions A);\n   c \\<noteq> ?qj'\\<rbrakk>\n  \\<Longrightarrow> find_base_vector A $ ?qj' = (0::'a)\n  c < nc\n  c \\<notin> snd ` set (pivot_positions A)", "show\n    \"find_base_vector A \\<in> carrier_vec nc\"\n    \"find_base_vector A \\<noteq> 0\\<^sub>v nc\"\n    \"A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr\""], ["proof (prove)\nusing this:\n  find_base_vector A \\<in> carrier_vec nc\n  find_base_vector A $ c = (1::'a)\n  A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr\n  \\<lbrakk>?qj' < nc; ?qj' \\<notin> snd ` set (pivot_positions A);\n   c \\<noteq> ?qj'\\<rbrakk>\n  \\<Longrightarrow> find_base_vector A $ ?qj' = (0::'a)\n  c < nc\n  c \\<notin> snd ` set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. find_base_vector A \\<in> carrier_vec nc &&&\n    find_base_vector A \\<noteq> 0\\<^sub>v nc &&&\n    A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  find_base_vector A \\<in> carrier_vec nc\n  find_base_vector A \\<noteq> 0\\<^sub>v nc\n  A *\\<^sub>v find_base_vector A = 0\\<^sub>v nr\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma row_echelon_form_imp_1_or_0_row: assumes A: \"A \\<in> carrier_mat n n\"\n  and row: \"row_echelon_form A\"\n  shows \"A = 1\\<^sub>m n \\<or> (n > 0 \\<and> row A (n - 1) = 0\\<^sub>v n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have dim: \"dim_row A = n\" \"dim_col A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n &&& dim_col A = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "from row[unfolded row_echelon_form_def] A"], ["proof (chain)\npicking this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n  A \\<in> carrier_mat n n", "obtain f where pivot: \"pivot_fun A f n\""], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (\\<And>f. pivot_fun A f n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pivot_fun A f n\n\ngoal (1 subgoal):\n 1. A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "note p = pivot_funD[OF dim(1) this]"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> f ?i \\<le> n\n  \\<lbrakk>?i < n; ?j < f ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < n; Suc ?i < n\\<rbrakk>\n  \\<Longrightarrow> f ?i < f (Suc ?i) \\<or> f (Suc ?i) = n\n  \\<lbrakk>?i < n; f ?i < n\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, f ?i) = (1::'a)\n  \\<lbrakk>?i < n; f ?i < n; ?i' < n; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', f ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "proof (cases \"\\<exists> i < n. f i \\<noteq> i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i<n. f i \\<noteq> i \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n 2. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "case True"], ["proof (state)\nthis:\n  \\<exists>i<n. f i \\<noteq> i\n\ngoal (2 subgoals):\n 1. \\<exists>i<n. f i \\<noteq> i \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n 2. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<n. f i \\<noteq> i", "obtain i where i: \"i < n\" and fi: \"f i \\<noteq> i\""], ["proof (prove)\nusing this:\n  \\<exists>i<n. f i \\<noteq> i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; f i \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < n\n  f i \\<noteq> i\n\ngoal (2 subgoals):\n 1. \\<exists>i<n. f i \\<noteq> i \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n 2. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "note pb = pivot_bound[OF dim(1) pivot]"], ["proof (state)\nthis:\n  ?i + ?j < n \\<Longrightarrow>\n  f (?i + ?j) = n \\<or> ?j + f ?i \\<le> f (?i + ?j)\n\ngoal (2 subgoals):\n 1. \\<exists>i<n. f i \\<noteq> i \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n 2. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "from pb[of 0 i] i"], ["proof (chain)\npicking this:\n  0 + i < n \\<Longrightarrow> f (0 + i) = n \\<or> i + f 0 \\<le> f (0 + i)\n  i < n", "have \"f i = n \\<or> i \\<le> f i\""], ["proof (prove)\nusing this:\n  0 + i < n \\<Longrightarrow> f (0 + i) = n \\<or> i + f 0 \\<le> f (0 + i)\n  i < n\n\ngoal (1 subgoal):\n 1. f i = n \\<or> i \\<le> f i", "by auto"], ["proof (state)\nthis:\n  f i = n \\<or> i \\<le> f i\n\ngoal (2 subgoals):\n 1. \\<exists>i<n. f i \\<noteq> i \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n 2. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "with fi"], ["proof (chain)\npicking this:\n  f i \\<noteq> i\n  f i = n \\<or> i \\<le> f i", "have fi: \"f i = n \\<or> i < f i\""], ["proof (prove)\nusing this:\n  f i \\<noteq> i\n  f i = n \\<or> i \\<le> f i\n\ngoal (1 subgoal):\n 1. f i = n \\<or> i < f i", "by auto"], ["proof (state)\nthis:\n  f i = n \\<or> i < f i\n\ngoal (2 subgoals):\n 1. \\<exists>i<n. f i \\<noteq> i \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n 2. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "from i"], ["proof (chain)\npicking this:\n  i < n", "have n: \"n - 1 = i + (n - i - 1)\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. n - 1 = i + (n - i - 1)", "by auto"], ["proof (state)\nthis:\n  n - 1 = i + (n - i - 1)\n\ngoal (2 subgoals):\n 1. \\<exists>i<n. f i \\<noteq> i \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n 2. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "from pb[of i \"n - i - 1\", folded n] fi i p(1)[of \"n - 1\"]"], ["proof (chain)\npicking this:\n  n - 1 < n \\<Longrightarrow>\n  f (n - 1) = n \\<or> n - i - 1 + f i \\<le> f (n - 1)\n  f i = n \\<or> i < f i\n  i < n\n  n - 1 < n \\<Longrightarrow> f (n - 1) \\<le> n", "have fn: \"f (n - 1) = n\""], ["proof (prove)\nusing this:\n  n - 1 < n \\<Longrightarrow>\n  f (n - 1) = n \\<or> n - i - 1 + f i \\<le> f (n - 1)\n  f i = n \\<or> i < f i\n  i < n\n  n - 1 < n \\<Longrightarrow> f (n - 1) \\<le> n\n\ngoal (1 subgoal):\n 1. f (n - 1) = n", "by auto"], ["proof (state)\nthis:\n  f (n - 1) = n\n\ngoal (2 subgoals):\n 1. \\<exists>i<n. f i \\<noteq> i \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n 2. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "from i"], ["proof (chain)\npicking this:\n  i < n", "have n0: \"n > 0\" and n1: \"n - 1 < n\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. 0 < n &&& n - 1 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n  n - 1 < n\n\ngoal (2 subgoals):\n 1. \\<exists>i<n. f i \\<noteq> i \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n 2. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "from p(2)[OF n1, unfolded fn]"], ["proof (chain)\npicking this:\n  ?j < n \\<Longrightarrow> A $$ (n - 1, ?j) = (0::'a)", "have zero: \"\\<And> j. j < n \\<Longrightarrow> A $$ (n - 1, j) = 0\""], ["proof (prove)\nusing this:\n  ?j < n \\<Longrightarrow> A $$ (n - 1, ?j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j. j < n \\<Longrightarrow> A $$ (n - 1, j) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  ?j < n \\<Longrightarrow> A $$ (n - 1, ?j) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>i<n. f i \\<noteq> i \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n 2. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "by (rule disjI2[OF conjI[OF n0]], rule eq_vecI, insert zero A, auto)"], ["proof (state)\nthis:\n  A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i<n. f i \\<noteq> i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "{"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i<n. f i \\<noteq> i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "assume j: \"j < n\""], ["proof (state)\nthis:\n  j < n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "with False"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i<n. f i \\<noteq> i)\n  j < n", "have id: \"f j = j\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i<n. f i \\<noteq> i)\n  j < n\n\ngoal (1 subgoal):\n 1. f j = j", "by auto"], ["proof (state)\nthis:\n  f j = j\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "note pj = p[OF j, unfolded id]"], ["proof (state)\nthis:\n  j \\<le> n\n  ?j < j \\<Longrightarrow> A $$ (j, ?j) = (0::'a)\n  Suc j < n \\<Longrightarrow> j < f (Suc j) \\<or> f (Suc j) = n\n  j < n \\<Longrightarrow> A $$ (j, j) = (1::'a)\n  \\<lbrakk>j < n; ?i' < n; ?i' \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', j) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "from pj(5)[OF j] pj(4)[OF j]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i' < n; ?i' \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', j) = (0::'a)\n  A $$ (j, j) = (1::'a)", "have \"\\<And> i. i < n \\<Longrightarrow> A $$ (i,j) = (if i = j then 1 else 0)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i' < n; ?i' \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', j) = (0::'a)\n  A $$ (j, j) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       A $$ (i, j) = (if i = j then 1::'a else (0::'a))", "by auto"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow>\n  A $$ (?i, j) = (if ?i = j then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j3 < n; ?i < n\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j3) = (if ?i = ?j3 then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "note id = this"], ["proof (state)\nthis:\n  \\<lbrakk>?j3 < n; ?i < n\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j3) = (if ?i = ?j3 then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. f i \\<noteq> i) \\<Longrightarrow>\n    A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n", "by (rule disjI1, rule eq_matI, subst id, insert A, auto)"], ["proof (state)\nthis:\n  A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes A :: \"'a :: field mat\" and n :: nat and p :: \"nat \\<Rightarrow> nat\"\n  assumes ref: \"row_echelon_form A\"\n  and A: \"A \\<in> carrier_mat n n\"\n  and 1: \"A \\<noteq> 1\\<^sub>m n\"\nbegin"], ["", "lemma find_base_vector_not_1_pivot_positions: \"snd ` set (pivot_positions A) \\<noteq> {0 ..< n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) \\<noteq> {0..<n}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "let ?pp = \"pivot_positions A\""], ["proof (state)\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "assume id: \"snd ` set ?pp = {0 ..< n}\""], ["proof (state)\nthis:\n  snd ` set (pivot_positions A) = {0..<n}\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "from A"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n", "have dim: \"dim_row A = n\" \"dim_col A = n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row A = n &&& dim_col A = n", "by auto"], ["proof (state)\nthis:\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "let ?n = \"n - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "from row_echelon_form_imp_1_or_0_row[OF A ref] 1"], ["proof (chain)\npicking this:\n  A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n  A \\<noteq> 1\\<^sub>m n", "have *: \"0 < n\" and row: \"row A ?n = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  A = 1\\<^sub>m n \\<or> 0 < n \\<and> row A (n - 1) = 0\\<^sub>v n\n  A \\<noteq> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. 0 < n &&& row A (n - 1) = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  0 < n\n  row A (n - 1) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "from ref[unfolded row_echelon_form_def]"], ["proof (chain)\npicking this:\n  \\<exists>f. pivot_fun A f (dim_col A)", "obtain p \n    where pivot: \"pivot_fun A p n\""], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n\ngoal (1 subgoal):\n 1. (\\<And>p. pivot_fun A p n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using dim"], ["proof (prove)\nusing this:\n  \\<exists>f. pivot_fun A f (dim_col A)\n  dim_row A = n\n  dim_col A = n\n\ngoal (1 subgoal):\n 1. (\\<And>p. pivot_fun A p n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pivot_fun A p n\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "note pp = pivot_positions[OF A pivot]"], ["proof (state)\nthis:\n  set (pivot_positions A) = {(i, p i) |i. i < n \\<and> p i \\<noteq> n}\n  distinct (map fst (pivot_positions A))\n  distinct (map snd (pivot_positions A))\n  length (pivot_positions A) =\n  card {i. i < n \\<and> row A i \\<noteq> 0\\<^sub>v n}\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "note piv = pivot_funD[OF dim(1) pivot]"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> p ?i \\<le> n\n  \\<lbrakk>?i < n; ?j < p ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, ?j) = (0::'a)\n  \\<lbrakk>?i < n; Suc ?i < n\\<rbrakk>\n  \\<Longrightarrow> p ?i < p (Suc ?i) \\<or> p (Suc ?i) = n\n  \\<lbrakk>?i < n; p ?i < n\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i, p ?i) = (1::'a)\n  \\<lbrakk>?i < n; p ?i < n; ?i' < n; ?i' \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> A $$ (?i', p ?i) = (0::'a)\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "from *"], ["proof (chain)\npicking this:\n  0 < n", "have n: \"?n < n\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. n - 1 < n", "by auto"], ["proof (state)\nthis:\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "assume \"p ?n < n\""], ["proof (state)\nthis:\n  p (n - 1) < n\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "with piv(4)[OF n this] row n A"], ["proof (chain)\npicking this:\n  A $$ (n - 1, p (n - 1)) = (1::'a)\n  row A (n - 1) = 0\\<^sub>v n\n  n - 1 < n\n  A \\<in> carrier_mat n n\n  p (n - 1) < n", "have False"], ["proof (prove)\nusing this:\n  A $$ (n - 1, p (n - 1)) = (1::'a)\n  row A (n - 1) = 0\\<^sub>v n\n  n - 1 < n\n  A \\<in> carrier_mat n n\n  p (n - 1) < n\n\ngoal (1 subgoal):\n 1. False", "by (metis dim index_row(1) index_zero_vec(1) zero_neq_one)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  p (n - 1) < n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "with piv(1)[OF n]"], ["proof (chain)\npicking this:\n  p (n - 1) \\<le> n\n  p (n - 1) < n \\<Longrightarrow> False", "have pn: \"p ?n = n\""], ["proof (prove)\nusing this:\n  p (n - 1) \\<le> n\n  p (n - 1) < n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. p (n - 1) = n", "by fastforce"], ["proof (state)\nthis:\n  p (n - 1) = n\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "hence \"?n \\<notin> fst ` set ?pp\""], ["proof (prove)\nusing this:\n  p (n - 1) = n\n\ngoal (1 subgoal):\n 1. n - 1 \\<notin> fst ` set (pivot_positions A)", "unfolding pp"], ["proof (prove)\nusing this:\n  p (n - 1) = n\n\ngoal (1 subgoal):\n 1. n - 1 \\<notin> fst ` {(i, p i) |i. i < n \\<and> p i \\<noteq> n}", "by auto"], ["proof (state)\nthis:\n  n - 1 \\<notin> fst ` set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "hence \"fst ` set ?pp \\<subseteq> {0 ..< n} - {?n}\""], ["proof (prove)\nusing this:\n  n - 1 \\<notin> fst ` set (pivot_positions A)\n\ngoal (1 subgoal):\n 1. fst ` set (pivot_positions A) \\<subseteq> {0..<n} - {n - 1}", "unfolding pp"], ["proof (prove)\nusing this:\n  n - 1 \\<notin> fst ` {(i, p i) |i. i < n \\<and> p i \\<noteq> n}\n\ngoal (1 subgoal):\n 1. fst ` {(i, p i) |i. i < n \\<and> p i \\<noteq> n}\n    \\<subseteq> {0..<n} - {n - 1}", "by force"], ["proof (state)\nthis:\n  fst ` set (pivot_positions A) \\<subseteq> {0..<n} - {n - 1}\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  fst ` set (pivot_positions A) \\<subseteq> {0..<n} - {n - 1}\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "have \"\\<dots> \\<subseteq> {0 ..< n - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<n} - {n - 1} \\<subseteq> {0..<n - 1}", "by auto"], ["proof (state)\nthis:\n  {0..<n} - {n - 1} \\<subseteq> {0..<n - 1}\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  fst ` set (pivot_positions A) \\<subseteq> {0..<n - 1}", "have \"card (fst ` set ?pp) \\<le> card {0 ..< n - 1}\""], ["proof (prove)\nusing this:\n  fst ` set (pivot_positions A) \\<subseteq> {0..<n - 1}\n\ngoal (1 subgoal):\n 1. card (fst ` set (pivot_positions A)) \\<le> card {0..<n - 1}", "using card_mono"], ["proof (prove)\nusing this:\n  fst ` set (pivot_positions A) \\<subseteq> {0..<n - 1}\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> card ?B\n\ngoal (1 subgoal):\n 1. card (fst ` set (pivot_positions A)) \\<le> card {0..<n - 1}", "by blast"], ["proof (state)\nthis:\n  card (fst ` set (pivot_positions A)) \\<le> card {0..<n - 1}\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card (fst ` set (pivot_positions A)) \\<le> card {0..<n - 1}\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "have \"\\<dots> = n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<n - 1} = n - 1", "by auto"], ["proof (state)\nthis:\n  card {0..<n - 1} = n - 1\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card {0..<n - 1} = n - 1\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "have \"card (fst ` set ?pp) = card (snd ` set ?pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (fst ` set (pivot_positions A)) =\n    card (snd ` set (pivot_positions A))", "unfolding set_map[symmetric] distinct_card[OF pp(2)] distinct_card[OF pp(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst (pivot_positions A)) =\n    length (map snd (pivot_positions A))", "by simp"], ["proof (state)\nthis:\n  card (fst ` set (pivot_positions A)) =\n  card (snd ` set (pivot_positions A))\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card (fst ` set (pivot_positions A)) =\n  card (snd ` set (pivot_positions A))\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "have \"\\<dots> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (snd ` set (pivot_positions A)) = n", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<n} = n", "by simp"], ["proof (state)\nthis:\n  card (snd ` set (pivot_positions A)) = n\n\ngoal (1 subgoal):\n 1. snd ` set (pivot_positions A) = {0..<n} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  n \\<le> n - 1", "show False"], ["proof (prove)\nusing this:\n  n \\<le> n - 1\n\ngoal (1 subgoal):\n 1. False", "using n"], ["proof (prove)\nusing this:\n  n \\<le> n - 1\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_base_vector_not_1: \n    \"find_base_vector A \\<in> carrier_vec n\"\n    \"find_base_vector A \\<noteq> 0\\<^sub>v n\"\n    \"A *\\<^sub>v find_base_vector A = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_base_vector A \\<in> carrier_vec n &&&\n    find_base_vector A \\<noteq> 0\\<^sub>v n &&&\n    A *\\<^sub>v find_base_vector A = 0\\<^sub>v n", "using find_base_vector[OF ref A find_base_vector_not_1_pivot_positions]"], ["proof (prove)\nusing this:\n  find_base_vector A \\<in> carrier_vec n\n  find_base_vector A \\<noteq> 0\\<^sub>v n\n  A *\\<^sub>v find_base_vector A = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. find_base_vector A \\<in> carrier_vec n &&&\n    find_base_vector A \\<noteq> 0\\<^sub>v n &&&\n    A *\\<^sub>v find_base_vector A = 0\\<^sub>v n", "."], ["", "end"], ["", "lemma gauss_jordan: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and B: \"B \\<in> carrier_mat nr nc2\"\n  and gauss: \"gauss_jordan A B = (C,D)\"\n  shows \"x \\<in> carrier_vec nc \\<Longrightarrow> (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\" (is \"_ \\<Longrightarrow> ?l = ?r\")\n    \"X \\<in> carrier_mat nc nc2  \\<Longrightarrow> (A * X = B) = (C * X = D)\" (is \" _ \\<Longrightarrow> ?l2 = ?r2\")\n    \"C \\<in> carrier_mat nr nc\"\n    \"D \\<in> carrier_mat nr nc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x \\<in> carrier_vec nc \\<Longrightarrow>\n      (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)) &&&\n     (X \\<in> carrier_mat nc nc2 \\<Longrightarrow>\n      (A * X = B) = (C * X = D))) &&&\n    C \\<in> carrier_mat nr nc &&& D \\<in> carrier_mat nr nc2", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)\n 3. C \\<in> carrier_mat nr nc\n 4. D \\<in> carrier_mat nr nc2", "from gauss_jordan_transform[OF A B gauss, unfolded ring_mat_def Units_def, simplified]"], ["proof (chain)\npicking this:\n  \\<exists>P.\n     P \\<in> carrier_mat nr nr \\<and>\n     (\\<exists>x\\<in>carrier_mat nr nr.\n         x * P = 1\\<^sub>m nr \\<and> P * x = 1\\<^sub>m nr) \\<and>\n     C = P * A \\<and> D = P * B", "obtain P Q where P: \"P \\<in> carrier_mat nr nr\" and Q: \"Q \\<in> carrier_mat nr nr\"\n    and inv: \"Q * P = 1\\<^sub>m nr\" \n    and CPA: \"C = P * A\" \n    and DPB: \"D = P * B\""], ["proof (prove)\nusing this:\n  \\<exists>P.\n     P \\<in> carrier_mat nr nr \\<and>\n     (\\<exists>x\\<in>carrier_mat nr nr.\n         x * P = 1\\<^sub>m nr \\<and> P * x = 1\\<^sub>m nr) \\<and>\n     C = P * A \\<and> D = P * B\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>P \\<in> carrier_mat nr nr; Q \\<in> carrier_mat nr nr;\n         Q * P = 1\\<^sub>m nr; C = P * A; D = P * B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat nr nr\n  Q \\<in> carrier_mat nr nr\n  Q * P = 1\\<^sub>m nr\n  C = P * A\n  D = P * B\n\ngoal (4 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)\n 3. C \\<in> carrier_mat nr nc\n 4. D \\<in> carrier_mat nr nc2", "from CPA P A"], ["proof (chain)\npicking this:\n  C = P * A\n  P \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc", "show C: \"C \\<in> carrier_mat nr nc\""], ["proof (prove)\nusing this:\n  C = P * A\n  P \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. C \\<in> carrier_mat nr nc", "by auto"], ["proof (state)\nthis:\n  C \\<in> carrier_mat nr nc\n\ngoal (3 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)\n 3. D \\<in> carrier_mat nr nc2", "from DPB P B"], ["proof (chain)\npicking this:\n  D = P * B\n  P \\<in> carrier_mat nr nr\n  B \\<in> carrier_mat nr nc2", "show D: \"D \\<in> carrier_mat nr nc2\""], ["proof (prove)\nusing this:\n  D = P * B\n  P \\<in> carrier_mat nr nr\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. D \\<in> carrier_mat nr nc2", "by auto"], ["proof (state)\nthis:\n  D \\<in> carrier_mat nr nc2\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "have \"A = 1\\<^sub>m nr * A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 1\\<^sub>m nr * A", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. A = 1\\<^sub>m nr * A", "by simp"], ["proof (state)\nthis:\n  A = 1\\<^sub>m nr * A\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "also"], ["proof (state)\nthis:\n  A = 1\\<^sub>m nr * A\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "have \"\\<dots> = Q * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m nr * A = Q * C", "unfolding inv[symmetric] CPA"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q * P * A = Q * (P * A)", "using Q P A"], ["proof (prove)\nusing this:\n  Q \\<in> carrier_mat nr nr\n  P \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc\n\ngoal (1 subgoal):\n 1. Q * P * A = Q * (P * A)", "by simp"], ["proof (state)\nthis:\n  1\\<^sub>m nr * A = Q * C\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "finally"], ["proof (chain)\npicking this:\n  A = Q * C", "have AQC: \"A = Q * C\""], ["proof (prove)\nusing this:\n  A = Q * C\n\ngoal (1 subgoal):\n 1. A = Q * C", "."], ["proof (state)\nthis:\n  A = Q * C\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "have \"B = 1\\<^sub>m nr * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m nr * B", "using B"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m nr * B", "by simp"], ["proof (state)\nthis:\n  B = 1\\<^sub>m nr * B\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "also"], ["proof (state)\nthis:\n  B = 1\\<^sub>m nr * B\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "have \"\\<dots> = Q * D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m nr * B = Q * D", "unfolding inv[symmetric] DPB"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q * P * B = Q * (P * B)", "using Q P B"], ["proof (prove)\nusing this:\n  Q \\<in> carrier_mat nr nr\n  P \\<in> carrier_mat nr nr\n  B \\<in> carrier_mat nr nc2\n\ngoal (1 subgoal):\n 1. Q * P * B = Q * (P * B)", "by simp"], ["proof (state)\nthis:\n  1\\<^sub>m nr * B = Q * D\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "finally"], ["proof (chain)\npicking this:\n  B = Q * D", "have BQD: \"B = Q * D\""], ["proof (prove)\nusing this:\n  B = Q * D\n\ngoal (1 subgoal):\n 1. B = Q * D", "."], ["proof (state)\nthis:\n  B = Q * D\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "{"], ["proof (state)\nthis:\n  B = Q * D\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "assume x: \"x \\<in> carrier_vec nc\""], ["proof (state)\nthis:\n  x \\<in> carrier_vec nc\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "{"], ["proof (state)\nthis:\n  x \\<in> carrier_vec nc\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "assume ?l"], ["proof (state)\nthis:\n  A *\\<^sub>v x = 0\\<^sub>v nr\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "from arg_cong[OF this, of \"\\<lambda> v. P *\\<^sub>v v\"] P A x"], ["proof (chain)\npicking this:\n  P *\\<^sub>v (A *\\<^sub>v x) = P *\\<^sub>v 0\\<^sub>v nr\n  P \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc\n  x \\<in> carrier_vec nc", "have ?r"], ["proof (prove)\nusing this:\n  P *\\<^sub>v (A *\\<^sub>v x) = P *\\<^sub>v 0\\<^sub>v nr\n  P \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc\n  x \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. C *\\<^sub>v x = 0\\<^sub>v nr", "unfolding CPA"], ["proof (prove)\nusing this:\n  P *\\<^sub>v (A *\\<^sub>v x) = P *\\<^sub>v 0\\<^sub>v nr\n  P \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc\n  x \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. P * A *\\<^sub>v x = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  C *\\<^sub>v x = 0\\<^sub>v nr\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "}"], ["proof (state)\nthis:\n  A *\\<^sub>v x = 0\\<^sub>v nr \\<Longrightarrow>\n  C *\\<^sub>v x = 0\\<^sub>v nr\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "moreover"], ["proof (state)\nthis:\n  A *\\<^sub>v x = 0\\<^sub>v nr \\<Longrightarrow>\n  C *\\<^sub>v x = 0\\<^sub>v nr\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "{"], ["proof (state)\nthis:\n  A *\\<^sub>v x = 0\\<^sub>v nr \\<Longrightarrow>\n  C *\\<^sub>v x = 0\\<^sub>v nr\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "assume ?r"], ["proof (state)\nthis:\n  C *\\<^sub>v x = 0\\<^sub>v nr\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "from arg_cong[OF this, of \"\\<lambda> v. Q *\\<^sub>v v\"] Q C x"], ["proof (chain)\npicking this:\n  Q *\\<^sub>v (C *\\<^sub>v x) = Q *\\<^sub>v 0\\<^sub>v nr\n  Q \\<in> carrier_mat nr nr\n  C \\<in> carrier_mat nr nc\n  x \\<in> carrier_vec nc", "have ?l"], ["proof (prove)\nusing this:\n  Q *\\<^sub>v (C *\\<^sub>v x) = Q *\\<^sub>v 0\\<^sub>v nr\n  Q \\<in> carrier_mat nr nr\n  C \\<in> carrier_mat nr nc\n  x \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. A *\\<^sub>v x = 0\\<^sub>v nr", "unfolding AQC"], ["proof (prove)\nusing this:\n  Q *\\<^sub>v (C *\\<^sub>v x) = Q *\\<^sub>v 0\\<^sub>v nr\n  Q \\<in> carrier_mat nr nr\n  C \\<in> carrier_mat nr nc\n  x \\<in> carrier_vec nc\n\ngoal (1 subgoal):\n 1. Q * C *\\<^sub>v x = 0\\<^sub>v nr", "by auto"], ["proof (state)\nthis:\n  A *\\<^sub>v x = 0\\<^sub>v nr\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "}"], ["proof (state)\nthis:\n  C *\\<^sub>v x = 0\\<^sub>v nr \\<Longrightarrow>\n  A *\\<^sub>v x = 0\\<^sub>v nr\n\ngoal (2 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "ultimately"], ["proof (chain)\npicking this:\n  A *\\<^sub>v x = 0\\<^sub>v nr \\<Longrightarrow>\n  C *\\<^sub>v x = 0\\<^sub>v nr\n  C *\\<^sub>v x = 0\\<^sub>v nr \\<Longrightarrow>\n  A *\\<^sub>v x = 0\\<^sub>v nr", "show \"?l = ?r\""], ["proof (prove)\nusing this:\n  A *\\<^sub>v x = 0\\<^sub>v nr \\<Longrightarrow>\n  C *\\<^sub>v x = 0\\<^sub>v nr\n  C *\\<^sub>v x = 0\\<^sub>v nr \\<Longrightarrow>\n  A *\\<^sub>v x = 0\\<^sub>v nr\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)", "by auto"], ["proof (state)\nthis:\n  (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "}"], ["proof (state)\nthis:\n  x \\<in> carrier_vec nc \\<Longrightarrow>\n  (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "{"], ["proof (state)\nthis:\n  x \\<in> carrier_vec nc \\<Longrightarrow>\n  (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "assume X: \"X \\<in> carrier_mat nc nc2\""], ["proof (state)\nthis:\n  X \\<in> carrier_mat nc nc2\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "{"], ["proof (state)\nthis:\n  X \\<in> carrier_mat nc nc2\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "assume ?l2"], ["proof (state)\nthis:\n  A * X = B\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "from arg_cong[OF this, of \"\\<lambda> X. P * X\"] P A X"], ["proof (chain)\npicking this:\n  P * (A * X) = P * B\n  P \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc\n  X \\<in> carrier_mat nc nc2", "have ?r2"], ["proof (prove)\nusing this:\n  P * (A * X) = P * B\n  P \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc\n  X \\<in> carrier_mat nc nc2\n\ngoal (1 subgoal):\n 1. C * X = D", "unfolding CPA DPB"], ["proof (prove)\nusing this:\n  P * (A * X) = P * B\n  P \\<in> carrier_mat nr nr\n  A \\<in> carrier_mat nr nc\n  X \\<in> carrier_mat nc nc2\n\ngoal (1 subgoal):\n 1. P * A * X = P * B", "by simp"], ["proof (state)\nthis:\n  C * X = D\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "}"], ["proof (state)\nthis:\n  A * X = B \\<Longrightarrow> C * X = D\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "moreover"], ["proof (state)\nthis:\n  A * X = B \\<Longrightarrow> C * X = D\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "{"], ["proof (state)\nthis:\n  A * X = B \\<Longrightarrow> C * X = D\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "assume ?r2"], ["proof (state)\nthis:\n  C * X = D\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "from arg_cong[OF this, of \"\\<lambda> X. Q * X\"] Q C X"], ["proof (chain)\npicking this:\n  Q * (C * X) = Q * D\n  Q \\<in> carrier_mat nr nr\n  C \\<in> carrier_mat nr nc\n  X \\<in> carrier_mat nc nc2", "have ?l2"], ["proof (prove)\nusing this:\n  Q * (C * X) = Q * D\n  Q \\<in> carrier_mat nr nr\n  C \\<in> carrier_mat nr nc\n  X \\<in> carrier_mat nc nc2\n\ngoal (1 subgoal):\n 1. A * X = B", "unfolding AQC BQD"], ["proof (prove)\nusing this:\n  Q * (C * X) = Q * D\n  Q \\<in> carrier_mat nr nr\n  C \\<in> carrier_mat nr nc\n  X \\<in> carrier_mat nc nc2\n\ngoal (1 subgoal):\n 1. Q * C * X = Q * D", "by simp"], ["proof (state)\nthis:\n  A * X = B\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "}"], ["proof (state)\nthis:\n  C * X = D \\<Longrightarrow> A * X = B\n\ngoal (1 subgoal):\n 1. X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)", "ultimately"], ["proof (chain)\npicking this:\n  A * X = B \\<Longrightarrow> C * X = D\n  C * X = D \\<Longrightarrow> A * X = B", "show \"?l2 = ?r2\""], ["proof (prove)\nusing this:\n  A * X = B \\<Longrightarrow> C * X = D\n  C * X = D \\<Longrightarrow> A * X = B\n\ngoal (1 subgoal):\n 1. (A * X = B) = (C * X = D)", "by auto"], ["proof (state)\nthis:\n  (A * X = B) = (C * X = D)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  X \\<in> carrier_mat nc nc2 \\<Longrightarrow> (A * X = B) = (C * X = D)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gauss_jordan_single :: \"'a :: field mat \\<Rightarrow> 'a mat\" where\n  \"gauss_jordan_single A = fst (gauss_jordan A (0\\<^sub>m (dim_row A) 0))\""], ["", "lemma gauss_jordan_single: assumes A: \"A \\<in> carrier_mat nr nc\"\n  and gauss: \"gauss_jordan_single A = C\"\n  shows \"x \\<in> carrier_vec nc \\<Longrightarrow> (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\" \n    \"C \\<in> carrier_mat nr nc\"\n    \"row_echelon_form C\"\n    \"\\<exists> P Q. C = P * A \\<and> P \\<in> carrier_mat nr nr \\<and> Q \\<in> carrier_mat nr nr \\<and> P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr\" (is \"?ex\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x \\<in> carrier_vec nc \\<Longrightarrow>\n      (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)) &&&\n     C \\<in> carrier_mat nr nc) &&&\n    row_echelon_form C &&&\n    \\<exists>P Q.\n       C = P * A \\<and>\n       P \\<in> carrier_mat nr nr \\<and>\n       Q \\<in> carrier_mat nr nr \\<and>\n       P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. C \\<in> carrier_mat nr nc\n 3. row_echelon_form C\n 4. \\<exists>P Q.\n       C = P * A \\<and>\n       P \\<in> carrier_mat nr nr \\<and>\n       Q \\<in> carrier_mat nr nr \\<and>\n       P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr", "from A gauss[unfolded gauss_jordan_single_def]"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat nr nc\n  fst (gauss_jordan A (0\\<^sub>m (dim_row A) 0)) = C", "obtain D where gauss: \"gauss_jordan A (0\\<^sub>m nr 0) = (C,D)\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n  fst (gauss_jordan A (0\\<^sub>m (dim_row A) 0)) = C\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        gauss_jordan A (0\\<^sub>m nr 0) = (C, D) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"gauss_jordan A (0\\<^sub>m nr 0)\", auto)"], ["proof (state)\nthis:\n  gauss_jordan A (0\\<^sub>m nr 0) = (C, D)\n\ngoal (4 subgoals):\n 1. x \\<in> carrier_vec nc \\<Longrightarrow>\n    (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n 2. C \\<in> carrier_mat nr nc\n 3. row_echelon_form C\n 4. \\<exists>P Q.\n       C = P * A \\<and>\n       P \\<in> carrier_mat nr nr \\<and>\n       Q \\<in> carrier_mat nr nr \\<and>\n       P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr", "from gauss_jordan[OF A zero_carrier_mat gauss] gauss_jordan_row_echelon[OF A gauss]\n    gauss_jordan_transform[OF A zero_carrier_mat gauss, of \"()\"]"], ["proof (chain)\npicking this:\n  ?x \\<in> carrier_vec nc \\<Longrightarrow>\n  (A *\\<^sub>v ?x = 0\\<^sub>v nr) = (C *\\<^sub>v ?x = 0\\<^sub>v nr)\n  ?X \\<in> carrier_mat nc 0 \\<Longrightarrow>\n  (A * ?X = 0\\<^sub>m nr 0) = (C * ?X = D)\n  C \\<in> carrier_mat nr nc\n  D \\<in> carrier_mat nr 0\n  row_echelon_form C\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr ()).\n     C = P * A \\<and> D = P * 0\\<^sub>m nr 0", "show \"x \\<in> carrier_vec nc \\<Longrightarrow> (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\" \n    \"C \\<in> carrier_mat nr nc\" \"row_echelon_form C\" ?ex"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier_vec nc \\<Longrightarrow>\n  (A *\\<^sub>v ?x = 0\\<^sub>v nr) = (C *\\<^sub>v ?x = 0\\<^sub>v nr)\n  ?X \\<in> carrier_mat nc 0 \\<Longrightarrow>\n  (A * ?X = 0\\<^sub>m nr 0) = (C * ?X = D)\n  C \\<in> carrier_mat nr nc\n  D \\<in> carrier_mat nr 0\n  row_echelon_form C\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) nr ()).\n     C = P * A \\<and> D = P * 0\\<^sub>m nr 0\n\ngoal (1 subgoal):\n 1. ((x \\<in> carrier_vec nc \\<Longrightarrow>\n      (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)) &&&\n     C \\<in> carrier_mat nr nc) &&&\n    row_echelon_form C &&&\n    \\<exists>P Q.\n       C = P * A \\<and>\n       P \\<in> carrier_mat nr nr \\<and>\n       Q \\<in> carrier_mat nr nr \\<and>\n       P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr", "unfolding Units_def ring_mat_def"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier_vec nc \\<Longrightarrow>\n  (A *\\<^sub>v ?x = 0\\<^sub>v nr) = (C *\\<^sub>v ?x = 0\\<^sub>v nr)\n  ?X \\<in> carrier_mat nc 0 \\<Longrightarrow>\n  (A * ?X = 0\\<^sub>m nr 0) = (C * ?X = D)\n  C \\<in> carrier_mat nr nc\n  D \\<in> carrier_mat nr 0\n  row_echelon_form C\n  \\<exists>P\\<in>{y \\<in> carrier\n                           \\<lparr>carrier = carrier_mat nr nr, mult = (*),\n                              one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr,\n                              add = (+)\\<rparr>.\n                  \\<exists>x\\<in>carrier\n                                  \\<lparr>carrier = carrier_mat nr nr,\n                                     mult = (*), one = 1\\<^sub>m nr,\n                                     zero = 0\\<^sub>m nr nr,\n                                     add = (+)\\<rparr>.\n                     x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+)\\<rparr>\\<^esub>\n                     y =\n                     \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+)\\<rparr>\\<^esub> \\<and>\n                     y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+)\\<rparr>\\<^esub>\n                     x =\n                     \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat nr nr, mult = (*), one = 1\\<^sub>m nr, zero = 0\\<^sub>m nr nr, add = (+)\\<rparr>\\<^esub>}.\n     C = P * A \\<and> D = P * 0\\<^sub>m nr 0\n\ngoal (1 subgoal):\n 1. ((x \\<in> carrier_vec nc \\<Longrightarrow>\n      (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)) &&&\n     C \\<in> carrier_mat nr nc) &&&\n    row_echelon_form C &&&\n    \\<exists>P Q.\n       C = P * A \\<and>\n       P \\<in> carrier_mat nr nr \\<and>\n       Q \\<in> carrier_mat nr nr \\<and>\n       P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr", "by auto"], ["proof (state)\nthis:\n  x \\<in> carrier_vec nc \\<Longrightarrow>\n  (A *\\<^sub>v x = 0\\<^sub>v nr) = (C *\\<^sub>v x = 0\\<^sub>v nr)\n  C \\<in> carrier_mat nr nc\n  row_echelon_form C\n  \\<exists>P Q.\n     C = P * A \\<and>\n     P \\<in> carrier_mat nr nr \\<and>\n     Q \\<in> carrier_mat nr nr \\<and>\n     P * Q = 1\\<^sub>m nr \\<and> Q * P = 1\\<^sub>m nr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_jordan_inverse_one_direction: \n  assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n nc\"\n  and res: \"gauss_jordan A B = (1\\<^sub>m n, B')\"\n  shows \"A \\<in> Units (ring_mat TYPE('a :: field) n b)\"\n  \"B = 1\\<^sub>m n \\<Longrightarrow> A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> Units (ring_mat TYPE('a) n b) &&&\n    (B = 1\\<^sub>m n \\<Longrightarrow>\n     A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<in> Units (ring_mat TYPE('a) n b)\n 2. B = 1\\<^sub>m n \\<Longrightarrow>\n    A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "let ?R = \"ring_mat TYPE('a) n b\""], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<in> Units (ring_mat TYPE('a) n b)\n 2. B = 1\\<^sub>m n \\<Longrightarrow>\n    A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "let ?U = \"Units ?R\""], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<in> Units (ring_mat TYPE('a) n b)\n 2. B = 1\\<^sub>m n \\<Longrightarrow>\n    A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "interpret m: ring ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring (ring_mat TYPE('a) n b)", "by (rule ring_mat)"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<in> Units (ring_mat TYPE('a) n b)\n 2. B = 1\\<^sub>m n \\<Longrightarrow>\n    A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "from gauss_jordan_transform[OF A B res, of b]"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) n b).\n     1\\<^sub>m n = P * A \\<and> B' = P * B", "obtain P where P: \"P \\<in> ?U\" and id: \"P * A = 1\\<^sub>m n\" and B': \"B' = P * B\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) n b).\n     1\\<^sub>m n = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) n b); P * A = 1\\<^sub>m n;\n         B' = P * B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) n b)\n  P * A = 1\\<^sub>m n\n  B' = P * B\n\ngoal (2 subgoals):\n 1. A \\<in> Units (ring_mat TYPE('a) n b)\n 2. B = 1\\<^sub>m n \\<Longrightarrow>\n    A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "from P"], ["proof (chain)\npicking this:\n  P \\<in> Units (ring_mat TYPE('a) n b)", "have Pc: \"P \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  P \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "unfolding Units_def ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<in> {y \\<in> carrier\n                    \\<lparr>carrier = carrier_mat n n, mult = (*),\n                       one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n                       \\<dots> = b\\<rparr>.\n           \\<exists>x\\<in>carrier\n                           \\<lparr>carrier = carrier_mat n n, mult = (*),\n                              one = 1\\<^sub>m n, zero = 0\\<^sub>m n n,\n                              add = (+), \\<dots> = b\\<rparr>.\n              x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n              y =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n              x =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>}\n\ngoal (1 subgoal):\n 1. P \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  P \\<in> carrier_mat n n\n\ngoal (2 subgoals):\n 1. A \\<in> Units (ring_mat TYPE('a) n b)\n 2. B = 1\\<^sub>m n \\<Longrightarrow>\n    A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "from m.Units_one_side_I(1)[of A P] A P id"], ["proof (chain)\npicking this:\n  \\<lbrakk>A \\<in> carrier (ring_mat TYPE('a) n b);\n   P \\<in> Units (ring_mat TYPE('a) n b);\n   P \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> A =\n   \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> A \\<in> Units (ring_mat TYPE('a) n b)\n  A \\<in> carrier_mat n n\n  P \\<in> Units (ring_mat TYPE('a) n b)\n  P * A = 1\\<^sub>m n", "show Au: \"A \\<in> ?U\""], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<in> carrier (ring_mat TYPE('a) n b);\n   P \\<in> Units (ring_mat TYPE('a) n b);\n   P \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> A =\n   \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> A \\<in> Units (ring_mat TYPE('a) n b)\n  A \\<in> carrier_mat n n\n  P \\<in> Units (ring_mat TYPE('a) n b)\n  P * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A \\<in> Units (ring_mat TYPE('a) n b)", "unfolding ring_mat_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<in> carrier\n                    \\<lparr>carrier = carrier_mat n n, mult = (*),\n                       one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n                       \\<dots> = b\\<rparr>;\n   P \\<in> Units\n            \\<lparr>carrier = carrier_mat n n, mult = (*),\n               one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n               \\<dots> = b\\<rparr>;\n   P \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n   A =\n   \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> A \\<in> Units\n                             \\<lparr>carrier = carrier_mat n n, mult = (*),\n                                one = 1\\<^sub>m n, zero = 0\\<^sub>m n n,\n                                add = (+), \\<dots> = b\\<rparr>\n  A \\<in> carrier_mat n n\n  P \\<in> Units\n           \\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n,\n              zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\n  P * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A \\<in> Units\n             \\<lparr>carrier = carrier_mat n n, mult = (*),\n                one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n                \\<dots> = b\\<rparr>", "by auto"], ["proof (state)\nthis:\n  A \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow>\n    A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "assume B: \"B = 1\\<^sub>m n\""], ["proof (state)\nthis:\n  B = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow>\n    A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "from B'[unfolded this] Pc"], ["proof (chain)\npicking this:\n  B' = P * 1\\<^sub>m n\n  P \\<in> carrier_mat n n", "have B': \"B' = P\""], ["proof (prove)\nusing this:\n  B' = P * 1\\<^sub>m n\n  P \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B' = P", "by auto"], ["proof (state)\nthis:\n  B' = P\n\ngoal (1 subgoal):\n 1. B = 1\\<^sub>m n \\<Longrightarrow>\n    A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "show \"A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "unfolding B'"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * P = 1\\<^sub>m n \\<and> P * A = 1\\<^sub>m n", "using m.Units_inv_comm[OF _ P Au] id"], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> A =\n  \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> \\<Longrightarrow>\n  A \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> P =\n  \\<one>\\<^bsub>ring_mat TYPE('a) n b\\<^esub>\n  P * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A * P = 1\\<^sub>m n \\<and> P * A = 1\\<^sub>m n", "by (auto simp: ring_mat_def)"], ["proof (state)\nthis:\n  A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_jordan_inverse_other_direction: \n  assumes AU: \"A \\<in> Units (ring_mat TYPE('a :: field) n b)\" and B: \"B \\<in> carrier_mat n nc\"\n  shows \"fst (gauss_jordan A B) = 1\\<^sub>m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "let ?R = \"ring_mat TYPE('a) n b\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "let ?U = \"Units ?R\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "interpret m: ring ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring (ring_mat TYPE('a) n b)", "by (rule ring_mat)"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "from AU"], ["proof (chain)\npicking this:\n  A \\<in> Units (ring_mat TYPE('a) n b)", "have A: \"A \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n", "unfolding Units_def ring_mat_def"], ["proof (prove)\nusing this:\n  A \\<in> {y \\<in> carrier\n                    \\<lparr>carrier = carrier_mat n n, mult = (*),\n                       one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n                       \\<dots> = b\\<rparr>.\n           \\<exists>x\\<in>carrier\n                           \\<lparr>carrier = carrier_mat n n, mult = (*),\n                              one = 1\\<^sub>m n, zero = 0\\<^sub>m n n,\n                              add = (+), \\<dots> = b\\<rparr>.\n              x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n              y =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub> \\<and>\n              y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n              x =\n              \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>}\n\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "obtain A' B' where res: \"gauss_jordan A B = (A',B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A' B'.\n        gauss_jordan A B = (A', B') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  gauss_jordan A B = (A', B')\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "from gauss_jordan_transform[OF A B res, of b]"], ["proof (chain)\npicking this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) n b). A' = P * A \\<and> B' = P * B", "obtain P where P: \"P \\<in> ?U\" and id: \"A' = P * A\""], ["proof (prove)\nusing this:\n  \\<exists>P\\<in>Units (ring_mat TYPE('a) n b). A' = P * A \\<and> B' = P * B\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>P \\<in> Units (ring_mat TYPE('a) n b); A' = P * A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<in> Units (ring_mat TYPE('a) n b)\n  A' = P * A\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "from m.Units_m_closed[OF P AU]"], ["proof (chain)\npicking this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> A\n  \\<in> Units (ring_mat TYPE('a) n b)", "have A': \"A' \\<in> ?U\""], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>ring_mat TYPE('a) n b\\<^esub> A\n  \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. A' \\<in> Units (ring_mat TYPE('a) n b)", "unfolding id ring_mat_def"], ["proof (prove)\nusing this:\n  P \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n  A\n  \\<in> Units\n         \\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n,\n            zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\n\ngoal (1 subgoal):\n 1. P * A\n    \\<in> Units\n           \\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n,\n              zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>", "by auto"], ["proof (state)\nthis:\n  A' \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "hence A'c: \"A' \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A' \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat n n", "unfolding Units_def ring_mat_def"], ["proof (prove)\nusing this:\n  A' \\<in> {y \\<in> carrier\n                     \\<lparr>carrier = carrier_mat n n, mult = (*),\n                        one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n                        \\<dots> = b\\<rparr>.\n            \\<exists>x\\<in>carrier\n                            \\<lparr>carrier = carrier_mat n n, mult = (*),\n                               one = 1\\<^sub>m n, zero = 0\\<^sub>m n n,\n                               add = (+), \\<dots> = b\\<rparr>.\n               x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n               y =\n               \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub> \\<and>\n               y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n               x =\n               \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>}\n\ngoal (1 subgoal):\n 1. A' \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "from A'[unfolded Units_def ring_mat_def]"], ["proof (chain)\npicking this:\n  A' \\<in> {y \\<in> carrier\n                     \\<lparr>carrier = carrier_mat n n, mult = (*),\n                        one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n                        \\<dots> = b\\<rparr>.\n            \\<exists>x\\<in>carrier\n                            \\<lparr>carrier = carrier_mat n n, mult = (*),\n                               one = 1\\<^sub>m n, zero = 0\\<^sub>m n n,\n                               add = (+), \\<dots> = b\\<rparr>.\n               x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n               y =\n               \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub> \\<and>\n               y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n               x =\n               \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>}", "obtain IA' where IA': \"IA' \\<in> carrier_mat n n\"\n    and IA: \"A' * IA' = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  A' \\<in> {y \\<in> carrier\n                     \\<lparr>carrier = carrier_mat n n, mult = (*),\n                        one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+),\n                        \\<dots> = b\\<rparr>.\n            \\<exists>x\\<in>carrier\n                            \\<lparr>carrier = carrier_mat n n, mult = (*),\n                               one = 1\\<^sub>m n, zero = 0\\<^sub>m n n,\n                               add = (+), \\<dots> = b\\<rparr>.\n               x \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n               y =\n               \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub> \\<and>\n               y \\<otimes>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>\n               x =\n               \\<one>\\<^bsub>\\<lparr>carrier = carrier_mat n n, mult = (*), one = 1\\<^sub>m n, zero = 0\\<^sub>m n n, add = (+), \\<dots> = b\\<rparr>\\<^esub>}\n\ngoal (1 subgoal):\n 1. (\\<And>IA'.\n        \\<lbrakk>IA' \\<in> carrier_mat n n; A' * IA' = 1\\<^sub>m n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  IA' \\<in> carrier_mat n n\n  A' * IA' = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "from row_echelon_form_imp_1_or_0_row[OF gauss_jordan_carrier(1)[OF A B res] gauss_jordan_row_echelon[OF A res]]"], ["proof (chain)\npicking this:\n  A' = 1\\<^sub>m n \\<or> 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n", "have choice: \"A' = 1\\<^sub>m n \\<or> 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  A' = 1\\<^sub>m n \\<or> 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. A' = 1\\<^sub>m n \\<or> 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n", "."], ["proof (state)\nthis:\n  A' = 1\\<^sub>m n \\<or> 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "hence \"A' = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  A' = 1\\<^sub>m n \\<or> 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. A' = 1\\<^sub>m n", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "let ?n = \"n - 1\""], ["proof (state)\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "assume \"0 < n \\<and> row A' ?n = 0\\<^sub>v n\""], ["proof (state)\nthis:\n  0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "hence n: \"?n < n\" and row: \"row A' ?n =  0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. n - 1 < n &&& row A' (n - 1) = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  n - 1 < n\n  row A' (n - 1) = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "have \"1 = 1\\<^sub>m n $$ (?n,?n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'c) = 1\\<^sub>m n $$ (n - 1, n - 1)", "using n"], ["proof (prove)\nusing this:\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. (1::'c) = 1\\<^sub>m n $$ (n - 1, n - 1)", "by simp"], ["proof (state)\nthis:\n  (1::?'c1) = 1\\<^sub>m n $$ (n - 1, n - 1)\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (1::?'c1) = 1\\<^sub>m n $$ (n - 1, n - 1)\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "have \"1\\<^sub>m n = A' * IA'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n = A' * IA'", "unfolding IA"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m n = 1\\<^sub>m n", ".."], ["proof (state)\nthis:\n  1\\<^sub>m n = A' * IA'\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  1\\<^sub>m n = A' * IA'\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "have \"(A' * IA') $$ (?n, ?n) = row A' ?n \\<bullet> col IA' ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A' * IA') $$ (n - 1, n - 1) = row A' (n - 1) \\<bullet> col IA' (n - 1)", "using n IA' A'c"], ["proof (prove)\nusing this:\n  n - 1 < n\n  IA' \\<in> carrier_mat n n\n  A' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (A' * IA') $$ (n - 1, n - 1) = row A' (n - 1) \\<bullet> col IA' (n - 1)", "by simp"], ["proof (state)\nthis:\n  (A' * IA') $$ (n - 1, n - 1) = row A' (n - 1) \\<bullet> col IA' (n - 1)\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  (A' * IA') $$ (n - 1, n - 1) = row A' (n - 1) \\<bullet> col IA' (n - 1)\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "have \"row A' ?n = 0\\<^sub>v n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A' (n - 1) = 0\\<^sub>v n", "unfolding row"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n = 0\\<^sub>v n", ".."], ["proof (state)\nthis:\n  row A' (n - 1) = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "also"], ["proof (state)\nthis:\n  row A' (n - 1) = 0\\<^sub>v n\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "have \"0\\<^sub>v n \\<bullet> col IA' ?n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<bullet> col IA' (n - 1) = (0::'a)", "using IA' n"], ["proof (prove)\nusing this:\n  IA' \\<in> carrier_mat n n\n  n - 1 < n\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n \\<bullet> col IA' (n - 1) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  0\\<^sub>v n \\<bullet> col IA' (n - 1) = (0::'a)\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "finally"], ["proof (chain)\npicking this:\n  (1::'a) = (0::'a)", "have \"1 = (0 :: 'a)\""], ["proof (prove)\nusing this:\n  (1::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. (1::'a) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  (1::'a) = (0::'a)\n\ngoal (2 subgoals):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n\n 2. 0 < n \\<and> row A' (n - 1) = 0\\<^sub>v n \\<Longrightarrow>\n    A' = 1\\<^sub>m n", "thus ?thesis"], ["proof (prove)\nusing this:\n  (1::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. A' = 1\\<^sub>m n", "by simp"], ["proof (state)\nthis:\n  A' = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A' = 1\\<^sub>m n \\<Longrightarrow> A' = 1\\<^sub>m n", "qed"], ["proof (state)\nthis:\n  A' = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "with res"], ["proof (chain)\npicking this:\n  gauss_jordan A B = (A', B')\n  A' = 1\\<^sub>m n", "show ?thesis"], ["proof (prove)\nusing this:\n  gauss_jordan A B = (A', B')\n  A' = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "by simp"], ["proof (state)\nthis:\n  fst (gauss_jordan A B) = 1\\<^sub>m n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_jordan_compute_inverse:\n  assumes A: \"A \\<in> carrier_mat n n\"\n  and res: \"gauss_jordan A (1\\<^sub>m n) = (1\\<^sub>m n, B')\"\n  shows \"A * B' = 1\\<^sub>m n\" \"B' * A = 1\\<^sub>m n\" \"B' \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B' = 1\\<^sub>m n &&&\n    B' * A = 1\\<^sub>m n &&& B' \\<in> carrier_mat n n", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. A * B' = 1\\<^sub>m n\n 2. B' * A = 1\\<^sub>m n\n 3. B' \\<in> carrier_mat n n", "from gauss_jordan_inverse_one_direction(2)[OF A _ res refl, of n]"], ["proof (chain)\npicking this:\n  1\\<^sub>m n \\<in> carrier_mat n n \\<Longrightarrow>\n  A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n", "show \"A * B' = 1\\<^sub>m n\" \"B' * A = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  1\\<^sub>m n \\<in> carrier_mat n n \\<Longrightarrow>\n  A * B' = 1\\<^sub>m n \\<and> B' * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A * B' = 1\\<^sub>m n &&& B' * A = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  A * B' = 1\\<^sub>m n\n  B' * A = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. B' \\<in> carrier_mat n n", "from gauss_jordan_carrier(2)[OF A _ res, of n]"], ["proof (chain)\npicking this:\n  1\\<^sub>m n \\<in> carrier_mat n n \\<Longrightarrow>\n  B' \\<in> carrier_mat n n", "show \"B' \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  1\\<^sub>m n \\<in> carrier_mat n n \\<Longrightarrow>\n  B' \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. B' \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  B' \\<in> carrier_mat n n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_jordan_check_invertable: assumes A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n nc\"\n  shows \"(A \\<in> Units (ring_mat TYPE('a :: field) n b)) \\<longleftrightarrow> fst (gauss_jordan A B) = 1\\<^sub>m n\"\n  (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<in> Units (ring_mat TYPE('a) n b)) =\n    (fst (gauss_jordan A B) = 1\\<^sub>m n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<in> Units (ring_mat TYPE('a) n b) \\<Longrightarrow>\n    fst (gauss_jordan A B) = 1\\<^sub>m n\n 2. fst (gauss_jordan A B) = 1\\<^sub>m n \\<Longrightarrow>\n    A \\<in> Units (ring_mat TYPE('a) n b)", "assume ?l"], ["proof (state)\nthis:\n  A \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal (2 subgoals):\n 1. A \\<in> Units (ring_mat TYPE('a) n b) \\<Longrightarrow>\n    fst (gauss_jordan A B) = 1\\<^sub>m n\n 2. fst (gauss_jordan A B) = 1\\<^sub>m n \\<Longrightarrow>\n    A \\<in> Units (ring_mat TYPE('a) n b)", "show ?r"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n", "by (rule gauss_jordan_inverse_other_direction[OF \\<open>?l\\<close> B])"], ["proof (state)\nthis:\n  fst (gauss_jordan A B) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n \\<Longrightarrow>\n    A \\<in> Units (ring_mat TYPE('a) n b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n \\<Longrightarrow>\n    A \\<in> Units (ring_mat TYPE('a) n b)", "let ?g = \"gauss_jordan A B\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n \\<Longrightarrow>\n    A \\<in> Units (ring_mat TYPE('a) n b)", "assume ?r"], ["proof (state)\nthis:\n  fst (gauss_jordan A B) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n \\<Longrightarrow>\n    A \\<in> Units (ring_mat TYPE('a) n b)", "then"], ["proof (chain)\npicking this:\n  fst (gauss_jordan A B) = 1\\<^sub>m n", "obtain B' where \"?g = (1\\<^sub>m n, B')\""], ["proof (prove)\nusing this:\n  fst (gauss_jordan A B) = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. (\\<And>B'.\n        gauss_jordan A B = (1\\<^sub>m n, B') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?g, auto)"], ["proof (state)\nthis:\n  gauss_jordan A B = (1\\<^sub>m n, B')\n\ngoal (1 subgoal):\n 1. fst (gauss_jordan A B) = 1\\<^sub>m n \\<Longrightarrow>\n    A \\<in> Units (ring_mat TYPE('a) n b)", "from gauss_jordan_inverse_one_direction(1)[OF A B this]"], ["proof (chain)\npicking this:\n  A \\<in> Units (ring_mat TYPE('a) n ?b)", "show ?l"], ["proof (prove)\nusing this:\n  A \\<in> Units (ring_mat TYPE('a) n ?b)\n\ngoal (1 subgoal):\n 1. A \\<in> Units (ring_mat TYPE('a) n b)", "."], ["proof (state)\nthis:\n  A \\<in> Units (ring_mat TYPE('a) n b)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mat_inverse :: \"'a :: field mat \\<Rightarrow> 'a mat option\" where \n  \"mat_inverse A = (if dim_row A = dim_col A then\n    let one = 1\\<^sub>m (dim_row A) in\n    (case gauss_jordan A one of\n      (B, C) \\<Rightarrow> if B = one then Some C else None) else None)\""], ["", "lemma mat_inverse: assumes A: \"A \\<in> carrier_mat n n\"\n  shows \"mat_inverse A = None \\<Longrightarrow> A \\<notin> Units (ring_mat TYPE('a :: field) n b)\"\n    \"mat_inverse A = Some B \\<Longrightarrow> A * B = 1\\<^sub>m n \\<and> B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_inverse A = None \\<Longrightarrow>\n     A \\<notin> Units (ring_mat TYPE('a) n b)) &&&\n    (mat_inverse A = Some B \\<Longrightarrow>\n     A * B = 1\\<^sub>m n \\<and>\n     B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. mat_inverse A = None \\<Longrightarrow>\n    A \\<notin> Units (ring_mat TYPE('a) n b)\n 2. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "let ?one = \"1\\<^sub>m n\""], ["proof (state)\ngoal (2 subgoals):\n 1. mat_inverse A = None \\<Longrightarrow>\n    A \\<notin> Units (ring_mat TYPE('a) n b)\n 2. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "obtain BB C where res: \"gauss_jordan A ?one = (BB,C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>BB C.\n        gauss_jordan A (1\\<^sub>m n) = (BB, C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  gauss_jordan A (1\\<^sub>m n) = (BB, C)\n\ngoal (2 subgoals):\n 1. mat_inverse A = None \\<Longrightarrow>\n    A \\<notin> Units (ring_mat TYPE('a) n b)\n 2. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "{"], ["proof (state)\nthis:\n  gauss_jordan A (1\\<^sub>m n) = (BB, C)\n\ngoal (2 subgoals):\n 1. mat_inverse A = None \\<Longrightarrow>\n    A \\<notin> Units (ring_mat TYPE('a) n b)\n 2. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "assume \"mat_inverse A = None\""], ["proof (state)\nthis:\n  mat_inverse A = None\n\ngoal (2 subgoals):\n 1. mat_inverse A = None \\<Longrightarrow>\n    A \\<notin> Units (ring_mat TYPE('a) n b)\n 2. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "with res"], ["proof (chain)\npicking this:\n  gauss_jordan A (1\\<^sub>m n) = (BB, C)\n  mat_inverse A = None", "have \"BB \\<noteq> ?one\""], ["proof (prove)\nusing this:\n  gauss_jordan A (1\\<^sub>m n) = (BB, C)\n  mat_inverse A = None\n\ngoal (1 subgoal):\n 1. BB \\<noteq> 1\\<^sub>m n", "unfolding mat_inverse_def"], ["proof (prove)\nusing this:\n  gauss_jordan A (1\\<^sub>m n) = (BB, C)\n  (if dim_row A = dim_col A\n   then let one = 1\\<^sub>m (dim_row A)\n        in case gauss_jordan A one of\n           (B, C) \\<Rightarrow> if B = one then Some C else None\n   else None) =\n  None\n\ngoal (1 subgoal):\n 1. BB \\<noteq> 1\\<^sub>m n", "using A"], ["proof (prove)\nusing this:\n  gauss_jordan A (1\\<^sub>m n) = (BB, C)\n  (if dim_row A = dim_col A\n   then let one = 1\\<^sub>m (dim_row A)\n        in case gauss_jordan A one of\n           (B, C) \\<Rightarrow> if B = one then Some C else None\n   else None) =\n  None\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. BB \\<noteq> 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  BB \\<noteq> 1\\<^sub>m n\n\ngoal (2 subgoals):\n 1. mat_inverse A = None \\<Longrightarrow>\n    A \\<notin> Units (ring_mat TYPE('a) n b)\n 2. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "thus \"A \\<notin> Units (ring_mat TYPE('a :: field) n b)\""], ["proof (prove)\nusing this:\n  BB \\<noteq> 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b)", "using gauss_jordan_check_invertable[OF A, of ?one n] res"], ["proof (prove)\nusing this:\n  BB \\<noteq> 1\\<^sub>m n\n  1\\<^sub>m n \\<in> carrier_mat n n \\<Longrightarrow>\n  (A \\<in> Units (ring_mat TYPE('a) n ?b)) =\n  (fst (gauss_jordan A (1\\<^sub>m n)) = 1\\<^sub>m n)\n  gauss_jordan A (1\\<^sub>m n) = (BB, C)\n\ngoal (1 subgoal):\n 1. A \\<notin> Units (ring_mat TYPE('a) n b)", "by force"], ["proof (state)\nthis:\n  A \\<notin> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "}"], ["proof (state)\nthis:\n  mat_inverse A = None \\<Longrightarrow>\n  A \\<notin> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "{"], ["proof (state)\nthis:\n  mat_inverse A = None \\<Longrightarrow>\n  A \\<notin> Units (ring_mat TYPE('a) n b)\n\ngoal (1 subgoal):\n 1. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "assume \"mat_inverse A = Some B\""], ["proof (state)\nthis:\n  mat_inverse A = Some B\n\ngoal (1 subgoal):\n 1. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "with res A"], ["proof (chain)\npicking this:\n  gauss_jordan A (1\\<^sub>m n) = (BB, C)\n  A \\<in> carrier_mat n n\n  mat_inverse A = Some B", "have \"BB = ?one\" \"C = B\""], ["proof (prove)\nusing this:\n  gauss_jordan A (1\\<^sub>m n) = (BB, C)\n  A \\<in> carrier_mat n n\n  mat_inverse A = Some B\n\ngoal (1 subgoal):\n 1. BB = 1\\<^sub>m n &&& C = B", "unfolding mat_inverse_def"], ["proof (prove)\nusing this:\n  gauss_jordan A (1\\<^sub>m n) = (BB, C)\n  A \\<in> carrier_mat n n\n  (if dim_row A = dim_col A\n   then let one = 1\\<^sub>m (dim_row A)\n        in case gauss_jordan A one of\n           (B, C) \\<Rightarrow> if B = one then Some C else None\n   else None) =\n  Some B\n\ngoal (1 subgoal):\n 1. BB = 1\\<^sub>m n &&& C = B", "by (auto split: if_splits option.splits)"], ["proof (state)\nthis:\n  BB = 1\\<^sub>m n\n  C = B\n\ngoal (1 subgoal):\n 1. mat_inverse A = Some B \\<Longrightarrow>\n    A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "from gauss_jordan_compute_inverse[OF A res[unfolded this]]"], ["proof (chain)\npicking this:\n  A * B = 1\\<^sub>m n\n  B * A = 1\\<^sub>m n\n  B \\<in> carrier_mat n n", "show \"A * B = 1\\<^sub>m n \\<and> B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A * B = 1\\<^sub>m n\n  B * A = 1\\<^sub>m n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. A * B = 1\\<^sub>m n \\<and>\n    B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  A * B = 1\\<^sub>m n \\<and>\n  B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  mat_inverse A = Some B \\<Longrightarrow>\n  A * B = 1\\<^sub>m n \\<and>\n  B * A = 1\\<^sub>m n \\<and> B \\<in> carrier_mat n n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}