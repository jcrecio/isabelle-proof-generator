{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Jordan_Normal_Form_Uniqueness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma similar_mat_wit_char_matrix: assumes wit: \"similar_mat_wit A B P Q\"\n  shows \"similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q\"", "lemma dim_kernel_non_zero_jordan_block_pow: assumes a: \"a \\<noteq> 0\"\n  shows \"kernel.dim n (jordan_block n (a :: 'a) ^\\<^sub>m k) = 0\"", "lemma dim_kernel_zero_jordan_block_pow: \n  \"kernel.dim n ((jordan_block n (0 :: 'a)) ^\\<^sub>m k) = min k n\" (is \"kernel.dim _ ?A = ?c\")", "lemma dim_gen_eigenspace_jordan_matrix: \n  \"dim_gen_eigenspace (jordan_matrix n_as) ev k\n    = (\\<Sum> n \\<leftarrow> map fst [(n, e)\\<leftarrow>n_as . e = ev]. min k n)\"", "lemma dim_gen_eigenspace_similar: assumes sim: \"similar_mat A B\"\n  shows \"dim_gen_eigenspace A = dim_gen_eigenspace B\"", "lemma dim_gen_eigenspace: assumes \"jordan_nf A n_as\"\n  shows \"dim_gen_eigenspace A ev k\n    = (\\<Sum> n \\<leftarrow> map fst [(n, e)\\<leftarrow>n_as . e = ev]. min k n)\"", "lemma compute_nr_of_jordan_blocks: assumes jnf: \"jordan_nf A n_as\"\n  and no_0: \"k \\<noteq> 0\"\n  shows \"compute_nr_of_jordan_blocks A ev k = length (filter ((=) (k,ev)) n_as)\"", "lemma compute_set_of_jordan_blocks: assumes jnf: \"jordan_nf A n_as\"\n  shows \"set (compute_set_of_jordan_blocks A ev) = set n_as \\<inter> UNIV \\<times> {ev}\" (is \"?C = ?N'\")", "lemma jordan_nf_unique: assumes \"jordan_nf (A :: 'a mat) n_as\" and \"jordan_nf A m_bs\" \nshows \"set n_as = set m_bs\""], "translations": [["", "lemma similar_mat_wit_char_matrix: assumes wit: \"similar_mat_wit A B P Q\"\n  shows \"similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "define n where \"n = dim_row A\""], ["proof (state)\nthis:\n  n = dim_row A\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "let ?C = \"carrier_mat n n\""], ["proof (state)\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "from similar_mat_witD[OF refl wit, folded n_def]"], ["proof (chain)\npicking this:\n  P * Q = 1\\<^sub>m n\n  Q * P = 1\\<^sub>m n\n  A = P * B * Q\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n", "have\n    A: \"A \\<in> ?C\" and B: \"B \\<in> ?C\" and P: \"P \\<in> ?C\" and Q: \"Q \\<in> ?C\"\n    and PQ: \"P * Q = 1\\<^sub>m n\" and QP: \"Q * P = 1\\<^sub>m n\"\n    and AB: \"A = P * B * Q\""], ["proof (prove)\nusing this:\n  P * Q = 1\\<^sub>m n\n  Q * P = 1\\<^sub>m n\n  A = P * B * Q\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (A \\<in> carrier_mat n n &&&\n     B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n) &&&\n    (Q \\<in> carrier_mat n n &&& P * Q = 1\\<^sub>m n) &&&\n    Q * P = 1\\<^sub>m n &&& A = P * B * Q", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  P * Q = 1\\<^sub>m n\n  Q * P = 1\\<^sub>m n\n  A = P * B * Q\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "have \"char_matrix A ev = (P * B * Q + (-ev) \\<cdot>\\<^sub>m (P * Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_matrix A ev = P * B * Q + - ev \\<cdot>\\<^sub>m (P * Q)", "unfolding char_matrix_def n_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A + - ev \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    P * B * Q + - ev \\<cdot>\\<^sub>m (P * Q)", "unfolding AB PQ"], ["proof (prove)\ngoal (1 subgoal):\n 1. P * B * Q + - ev \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    P * B * Q + - ev \\<cdot>\\<^sub>m 1\\<^sub>m n", "by (intro eq_matI, insert P B Q, auto)"], ["proof (state)\nthis:\n  char_matrix A ev = P * B * Q + - ev \\<cdot>\\<^sub>m (P * Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "also"], ["proof (state)\nthis:\n  char_matrix A ev = P * B * Q + - ev \\<cdot>\\<^sub>m (P * Q)\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "have \"(-ev) \\<cdot>\\<^sub>m (P * Q) = P * ((-ev) \\<cdot>\\<^sub>m 1\\<^sub>m n) * Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - ev \\<cdot>\\<^sub>m (P * Q) =\n    P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) * Q", "using P Q"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. - ev \\<cdot>\\<^sub>m (P * Q) =\n    P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) * Q", "by (metis mult_smult_assoc_mat mult_smult_distrib one_carrier_mat right_mult_one_mat)"], ["proof (state)\nthis:\n  - ev \\<cdot>\\<^sub>m (P * Q) = P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) * Q\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "also"], ["proof (state)\nthis:\n  - ev \\<cdot>\\<^sub>m (P * Q) = P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) * Q\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "have \"P * B * Q + \\<dots> = (P * B + P * ((-ev) \\<cdot>\\<^sub>m 1\\<^sub>m n)) * Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * B * Q + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) * Q =\n    (P * B + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n)) * Q", "using P B"], ["proof (prove)\nusing this:\n  P \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. P * B * Q + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) * Q =\n    (P * B + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n)) * Q", "by (intro add_mult_distrib_mat[symmetric, OF _ _ Q, of _ n], auto)"], ["proof (state)\nthis:\n  P * B * Q + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) * Q =\n  (P * B + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n)) * Q\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "also"], ["proof (state)\nthis:\n  P * B * Q + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) * Q =\n  (P * B + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n)) * Q\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "have \"P * B + P * ((-ev) \\<cdot>\\<^sub>m 1\\<^sub>m n) = P * (B  + (-ev) \\<cdot>\\<^sub>m 1\\<^sub>m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * B + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) =\n    P * (B + - ev \\<cdot>\\<^sub>m 1\\<^sub>m n)", "by (intro mult_add_distrib_mat[symmetric, OF P B], auto)"], ["proof (state)\nthis:\n  P * B + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) =\n  P * (B + - ev \\<cdot>\\<^sub>m 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "also"], ["proof (state)\nthis:\n  P * B + P * (- ev \\<cdot>\\<^sub>m 1\\<^sub>m n) =\n  P * (B + - ev \\<cdot>\\<^sub>m 1\\<^sub>m n)\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "have \"(B  + (-ev) \\<cdot>\\<^sub>m 1\\<^sub>m n) = char_matrix B ev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B + - ev \\<cdot>\\<^sub>m 1\\<^sub>m n = char_matrix B ev", "unfolding char_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. B + - ev \\<cdot>\\<^sub>m 1\\<^sub>m n =\n    B + - ev \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row B)", "by (intro eq_matI, insert B, auto)"], ["proof (state)\nthis:\n  B + - ev \\<cdot>\\<^sub>m 1\\<^sub>m n = char_matrix B ev\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "finally"], ["proof (chain)\npicking this:\n  char_matrix A ev = P * char_matrix B ev * Q", "have AB: \"char_matrix A ev = P * char_matrix B ev * Q\""], ["proof (prove)\nusing this:\n  char_matrix A ev = P * char_matrix B ev * Q\n\ngoal (1 subgoal):\n 1. char_matrix A ev = P * char_matrix B ev * Q", "."], ["proof (state)\nthis:\n  char_matrix A ev = P * char_matrix B ev * Q\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "show \"similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q", "by (intro similar_mat_witI[OF PQ QP AB _ _ P Q], insert A B, auto)"], ["proof (state)\nthis:\n  similar_mat_wit (char_matrix A ev) (char_matrix B ev) P Q\n\ngoal:\nNo subgoals!", "qed"], ["", "context fixes ty :: \"'a :: field itself\"\nbegin"], ["", "lemma dim_kernel_non_zero_jordan_block_pow: assumes a: \"a \\<noteq> 0\"\n  shows \"kernel.dim n (jordan_block n (a :: 'a) ^\\<^sub>m k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n a ^\\<^sub>m k)\\<rparr>) =\n    0", "by (rule kernel_upper_triangular[OF pow_carrier_mat[OF jordan_block_carrier]],\n  unfold jordan_block_pow, insert a, auto simp: diag_mat_def)"], ["", "lemma dim_kernel_zero_jordan_block_pow: \n  \"kernel.dim n ((jordan_block n (0 :: 'a)) ^\\<^sub>m k) = min k n\" (is \"kernel.dim _ ?A = ?c\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "have A: \"?A \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_block n (0::'a) ^\\<^sub>m k \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  jordan_block n (0::'a) ^\\<^sub>m k \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "hence dim: \"dim_row ?A = n\""], ["proof (prove)\nusing this:\n  jordan_block n (0::'a) ^\\<^sub>m k \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_row (jordan_block n (0::'a) ^\\<^sub>m k) = n", "by simp"], ["proof (state)\nthis:\n  dim_row (jordan_block n (0::'a) ^\\<^sub>m k) = n\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "let ?f = \"\\<lambda> i. min (k + i) n\""], ["proof (state)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "have piv: \"pivot_fun ?A ?f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun (jordan_block n (0::'a) ^\\<^sub>m k)\n     (\\<lambda>i. min (k + i) n) n", "unfolding jordan_block_zero_pow"], ["proof (prove)\ngoal (1 subgoal):\n 1. pivot_fun\n     (mat n n\n       (\\<lambda>(i, j).\n           if i \\<le> j \\<and> j - i = k then 1::'a else (0::'a)))\n     (\\<lambda>i. min (k + i) n) n", "by (intro pivot_funI, auto)"], ["proof (state)\nthis:\n  pivot_fun (jordan_block n (0::'a) ^\\<^sub>m k) (\\<lambda>i. min (k + i) n)\n   n\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "hence row: \"row_echelon_form ?A\""], ["proof (prove)\nusing this:\n  pivot_fun (jordan_block n (0::'a) ^\\<^sub>m k) (\\<lambda>i. min (k + i) n)\n   n\n\ngoal (1 subgoal):\n 1. row_echelon_form (jordan_block n (0::'a) ^\\<^sub>m k)", "unfolding row_echelon_form_def"], ["proof (prove)\nusing this:\n  pivot_fun (jordan_block n (0::'a) ^\\<^sub>m k) (\\<lambda>i. min (k + i) n)\n   n\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       pivot_fun (jordan_block n (0::'a) ^\\<^sub>m k) f\n        (dim_col (jordan_block n (0::'a) ^\\<^sub>m k))", "by auto"], ["proof (state)\nthis:\n  row_echelon_form (jordan_block n (0::'a) ^\\<^sub>m k)\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "from find_base_vectors(5-6)[OF row A]"], ["proof (chain)\npicking this:\n  length (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)) =\n  card\n   {i. i < n \\<and>\n       row (jordan_block n (0::'a) ^\\<^sub>m k) i \\<noteq> 0\\<^sub>v n}\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n  n -\n  card\n   {i. i < n \\<and>\n       row (jordan_block n (0::'a) ^\\<^sub>m k) i \\<noteq> 0\\<^sub>v n}", "have \"kernel.dim n ?A = n - length (map fst (pivot_positions ?A))\""], ["proof (prove)\nusing this:\n  length (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)) =\n  card\n   {i. i < n \\<and>\n       row (jordan_block n (0::'a) ^\\<^sub>m k) i \\<noteq> 0\\<^sub>v n}\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n  n -\n  card\n   {i. i < n \\<and>\n       row (jordan_block n (0::'a) ^\\<^sub>m k) i \\<noteq> 0\\<^sub>v n}\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    n -\n    length (map fst (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)))", "by auto"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n  n -\n  length (map fst (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)))\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "also"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n  n -\n  length (map fst (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)))\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "have \"length (map fst (pivot_positions ?A)) = card (fst ` set (pivot_positions ?A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map fst (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k))) =\n    card (fst ` set (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)))", "by (subst distinct_card[OF pivot_positions(2)[OF A piv], symmetric], simp)"], ["proof (state)\nthis:\n  length (map fst (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k))) =\n  card (fst ` set (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)))\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "also"], ["proof (state)\nthis:\n  length (map fst (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k))) =\n  card (fst ` set (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)))\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "have \"fst ` set (pivot_positions ?A) = { 0 ..< (n - ?c)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)) =\n    {0..<n - min k n}", "unfolding pivot_positions(1)[OF A piv]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` {(i, min (k + i) n) |i. i < n \\<and> min (k + i) n \\<noteq> n} =\n    {0..<n - min k n}", "by force"], ["proof (state)\nthis:\n  fst ` set (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)) =\n  {0..<n - min k n}\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "also"], ["proof (state)\nthis:\n  fst ` set (pivot_positions (jordan_block n (0::'a) ^\\<^sub>m k)) =\n  {0..<n - min k n}\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "have \"card \\<dots> = n - ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<n - min k n} = n - min k n", "by simp"], ["proof (state)\nthis:\n  card {0..<n - min k n} = n - min k n\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "finally"], ["proof (chain)\npicking this:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n  n - (n - min k n)", "show ?thesis"], ["proof (prove)\nusing this:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n  n - (n - min k n)\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n    min k n", "by simp"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n  min k n\n\ngoal:\nNo subgoals!", "qed"], ["", "definition dim_gen_eigenspace :: \"'a mat \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"dim_gen_eigenspace A ev k = kernel_dim ((char_matrix A ev) ^\\<^sub>m k)\""], ["", "lemma dim_gen_eigenspace_jordan_matrix: \n  \"dim_gen_eigenspace (jordan_matrix n_as) ev k\n    = (\\<Sum> n \\<leftarrow> map fst [(n, e)\\<leftarrow>n_as . e = ev]. min k n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "let ?JM = \"\\<lambda> n_as. jordan_matrix n_as\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "let ?CM = \"\\<lambda> n_as. char_matrix (?JM n_as) ev\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "let ?A = \"\\<lambda> n_as. (?CM n_as) ^\\<^sub>m k\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "let ?n = \"\\<lambda> n_as. sum_list (map fst n_as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "let ?C = \"\\<lambda> n_as. carrier_mat (?n n_as) (?n n_as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "let ?sum = \"\\<lambda> n_as. \\<Sum> n \\<leftarrow> map fst [(n, e)\\<leftarrow>n_as . e = ev]. min k n\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "let ?dim = \"\\<lambda> n_as. sum_list (map fst n_as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "let ?kdim = \"\\<lambda> n_as. kernel.dim (?dim n_as) (?A n_as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "have JM: \"\\<And> n_as. ?JM n_as \\<in> ?C n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n_as.\n       jordan_matrix n_as\n       \\<in> carrier_mat (sum_list (map fst n_as)) (sum_list (map fst n_as))", "by auto"], ["proof (state)\nthis:\n  jordan_matrix ?n_as4\n  \\<in> carrier_mat (sum_list (map fst ?n_as4)) (sum_list (map fst ?n_as4))\n\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "have CM: \"\\<And> n_as. ?CM n_as \\<in> ?C n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n_as.\n       char_matrix (jordan_matrix n_as) ev\n       \\<in> carrier_mat (sum_list (map fst n_as)) (sum_list (map fst n_as))", "by auto"], ["proof (state)\nthis:\n  char_matrix (jordan_matrix ?n_as5) ev\n  \\<in> carrier_mat (sum_list (map fst ?n_as5)) (sum_list (map fst ?n_as5))\n\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "have A: \"\\<And> n_as. ?A n_as \\<in> ?C n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n_as.\n       char_matrix (jordan_matrix n_as) ev ^\\<^sub>m k\n       \\<in> carrier_mat (sum_list (map fst n_as)) (sum_list (map fst n_as))", "by auto"], ["proof (state)\nthis:\n  char_matrix (jordan_matrix ?n_as5) ev ^\\<^sub>m k\n  \\<in> carrier_mat (sum_list (map fst ?n_as5)) (sum_list (map fst ?n_as5))\n\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "have dimc: \"dim_col (?JM n_as) = ?dim n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (jordan_matrix n_as) = sum_list (map fst n_as)", "by simp"], ["proof (state)\nthis:\n  dim_col (jordan_matrix n_as) = sum_list (map fst n_as)\n\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "interpret K: kernel \"?dim n_as\" \"?dim n_as\" \"?A n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel (sum_list (map fst n_as)) (sum_list (map fst n_as))\n     (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m k)", "by (unfold_locales, rule A)"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "unfolding dim_gen_eigenspace_def K.kernel_dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. K.dim =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "proof (induct n_as)"], ["proof (state)\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst []))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_matrix []) ev ^\\<^sub>m k)\\<rparr>) =\n    sum_list\n     (map (min k)\n       (map fst\n         (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev) [])))\n 2. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst []))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_matrix []) ev ^\\<^sub>m k)\\<rparr>) =\n    sum_list\n     (map (min k)\n       (map fst\n         (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev) [])))\n 2. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "have \"?JM Nil = 1\\<^sub>m 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jordan_matrix [] = 1\\<^sub>m 0", "unfolding jordan_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) []) =\n    1\\<^sub>m 0", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  jordan_matrix [] = 1\\<^sub>m 0\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst []))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_matrix []) ev ^\\<^sub>m k)\\<rparr>) =\n    sum_list\n     (map (min k)\n       (map fst\n         (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev) [])))\n 2. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "hence id: \"?A Nil = 1\\<^sub>m 0\""], ["proof (prove)\nusing this:\n  jordan_matrix [] = 1\\<^sub>m 0\n\ngoal (1 subgoal):\n 1. char_matrix (jordan_matrix []) ev ^\\<^sub>m k = 1\\<^sub>m 0", "unfolding char_matrix_def"], ["proof (prove)\nusing this:\n  jordan_matrix [] = 1\\<^sub>m 0\n\ngoal (1 subgoal):\n 1. (jordan_matrix [] +\n     - ev \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row (jordan_matrix []))) ^\\<^sub>m\n    k =\n    1\\<^sub>m 0", "by auto"], ["proof (state)\nthis:\n  char_matrix (jordan_matrix []) ev ^\\<^sub>m k = 1\\<^sub>m 0\n\ngoal (2 subgoals):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst []))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_matrix []) ev ^\\<^sub>m k)\\<rparr>) =\n    sum_list\n     (map (min k)\n       (map fst\n         (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev) [])))\n 2. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst []))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_matrix []) ev ^\\<^sub>m k)\\<rparr>) =\n    sum_list\n     (map (min k)\n       (map fst\n         (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev) [])))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst []))\n      \\<lparr>carrier := mat_kernel (1\\<^sub>m 0)\\<rparr>) =\n    sum_list\n     (map (min k)\n       (map fst\n         (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev) [])))", "using kernel_one_mat[of 0]"], ["proof (prove)\nusing this:\n  vectorspace.dim class_ring\n   (module_vec TYPE(?'a) 0\n    \\<lparr>carrier := mat_kernel (1\\<^sub>m 0)\\<rparr>) =\n  0\n  vectorspace.basis class_ring\n   (module_vec TYPE(?'a) 0\n    \\<lparr>carrier := mat_kernel (1\\<^sub>m 0)\\<rparr>)\n   {}\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst []))\n      \\<lparr>carrier := mat_kernel (1\\<^sub>m 0)\\<rparr>) =\n    sum_list\n     (map (min k)\n       (map fst\n         (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev) [])))", "by auto"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst []))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix []) ev ^\\<^sub>m k)\\<rparr>) =\n  sum_list\n   (map (min k)\n     (map fst\n       (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev) [])))\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "case (Cons ne n_as')"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst n_as'))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m k)\\<rparr>) =\n  sum_list\n   (map (min k)\n     (map fst\n       (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev) n_as')))\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "let ?n_as = \"Cons ne n_as'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "let ?d = \"?dim ?n_as\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "let ?d' = \"?dim n_as'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "obtain n e where ne: \"ne = (n,e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n e. ne = (n, e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  ne = (n, e)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "have dim: \"?d = n + ?d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map fst (ne # n_as')) = n + sum_list (map fst n_as')", "unfolding ne"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map fst ((n, e) # n_as')) = n + sum_list (map fst n_as')", "by simp"], ["proof (state)\nthis:\n  sum_list (map fst (ne # n_as')) = n + sum_list (map fst n_as')\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "let ?jb = \"jordan_block n e\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "let ?cm = \"char_matrix ?jb ev\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "let ?a = \"?cm ^\\<^sub>m k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "have a: \"?a \\<in> carrier_mat n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_matrix (jordan_block n e) ev ^\\<^sub>m k \\<in> carrier_mat n n", "by simp"], ["proof (state)\nthis:\n  char_matrix (jordan_block n e) ev ^\\<^sub>m k \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "from JM[of n_as']"], ["proof (chain)\npicking this:\n  jordan_matrix n_as'\n  \\<in> carrier_mat (sum_list (map fst n_as')) (sum_list (map fst n_as'))", "have dim_rec: \"dim_row (?JM n_as') = ?d'\" \"dim_col (?JM n_as') = ?d'\""], ["proof (prove)\nusing this:\n  jordan_matrix n_as'\n  \\<in> carrier_mat (sum_list (map fst n_as')) (sum_list (map fst n_as'))\n\ngoal (1 subgoal):\n 1. dim_row (jordan_matrix n_as') = sum_list (map fst n_as') &&&\n    dim_col (jordan_matrix n_as') = sum_list (map fst n_as')", "by auto"], ["proof (state)\nthis:\n  dim_row (jordan_matrix n_as') = sum_list (map fst n_as')\n  dim_col (jordan_matrix n_as') = sum_list (map fst n_as')\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "hence JM_id: \"?JM ?n_as = four_block_mat ?jb (0\\<^sub>m n ?d') (0\\<^sub>m ?d' n) (?JM n_as')\""], ["proof (prove)\nusing this:\n  dim_row (jordan_matrix n_as') = sum_list (map fst n_as')\n  dim_col (jordan_matrix n_as') = sum_list (map fst n_as')\n\ngoal (1 subgoal):\n 1. jordan_matrix (ne # n_as') =\n    four_block_mat (jordan_block n e)\n     (0\\<^sub>m n (sum_list (map fst n_as')))\n     (0\\<^sub>m (sum_list (map fst n_as')) n) (jordan_matrix n_as')", "unfolding ne jordan_matrix_def"], ["proof (prove)\nusing this:\n  dim_row (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as')) =\n  sum_list (map fst n_as')\n  dim_col (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as')) =\n  sum_list (map fst n_as')\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>(x, y). jordan_block x y) ((n, e) # n_as')) =\n    four_block_mat (jordan_block n e)\n     (0\\<^sub>m n (sum_list (map fst n_as')))\n     (0\\<^sub>m (sum_list (map fst n_as')) n)\n     (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as'))", "using JM[of n_as']"], ["proof (prove)\nusing this:\n  dim_row (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as')) =\n  sum_list (map fst n_as')\n  dim_col (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as')) =\n  sum_list (map fst n_as')\n  jordan_matrix n_as'\n  \\<in> carrier_mat (sum_list (map fst n_as')) (sum_list (map fst n_as'))\n\ngoal (1 subgoal):\n 1. diag_block_mat\n     (map (\\<lambda>(x, y). jordan_block x y) ((n, e) # n_as')) =\n    four_block_mat (jordan_block n e)\n     (0\\<^sub>m n (sum_list (map fst n_as')))\n     (0\\<^sub>m (sum_list (map fst n_as')) n)\n     (diag_block_mat (map (\\<lambda>(x, y). jordan_block x y) n_as'))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  jordan_matrix (ne # n_as') =\n  four_block_mat (jordan_block n e) (0\\<^sub>m n (sum_list (map fst n_as')))\n   (0\\<^sub>m (sum_list (map fst n_as')) n) (jordan_matrix n_as')\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "have CM_id: \"?CM ?n_as = four_block_mat ?cm (0\\<^sub>m n ?d') (0\\<^sub>m ?d' n) (?CM n_as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_matrix (jordan_matrix (ne # n_as')) ev =\n    four_block_mat (char_matrix (jordan_block n e) ev)\n     (0\\<^sub>m n (sum_list (map fst n_as')))\n     (0\\<^sub>m (sum_list (map fst n_as')) n)\n     (char_matrix (jordan_matrix n_as') ev)", "unfolding JM_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. char_matrix\n     (four_block_mat (jordan_block n e)\n       (0\\<^sub>m n (sum_list (map fst n_as')))\n       (0\\<^sub>m (sum_list (map fst n_as')) n) (jordan_matrix n_as'))\n     ev =\n    four_block_mat (char_matrix (jordan_block n e) ev)\n     (0\\<^sub>m n (sum_list (map fst n_as')))\n     (0\\<^sub>m (sum_list (map fst n_as')) n)\n     (char_matrix (jordan_matrix n_as') ev)", "unfolding char_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat (jordan_block n e)\n     (0\\<^sub>m n (sum_list (map fst n_as')))\n     (0\\<^sub>m (sum_list (map fst n_as')) n) (jordan_matrix n_as') +\n    - ev \\<cdot>\\<^sub>m\n    1\\<^sub>m\n     (dim_row\n       (four_block_mat (jordan_block n e)\n         (0\\<^sub>m n (sum_list (map fst n_as')))\n         (0\\<^sub>m (sum_list (map fst n_as')) n) (jordan_matrix n_as'))) =\n    four_block_mat\n     (jordan_block n e +\n      - ev \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row (jordan_block n e)))\n     (0\\<^sub>m n (sum_list (map fst n_as')))\n     (0\\<^sub>m (sum_list (map fst n_as')) n)\n     (jordan_matrix n_as' +\n      - ev \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row (jordan_matrix n_as')))", "by (intro eq_matI, auto)"], ["proof (state)\nthis:\n  char_matrix (jordan_matrix (ne # n_as')) ev =\n  four_block_mat (char_matrix (jordan_block n e) ev)\n   (0\\<^sub>m n (sum_list (map fst n_as')))\n   (0\\<^sub>m (sum_list (map fst n_as')) n)\n   (char_matrix (jordan_matrix n_as') ev)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "have A_id: \"?A ?n_as = four_block_mat ?a (0\\<^sub>m n ?d') (0\\<^sub>m ?d' n) (?A n_as')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_matrix (jordan_matrix (ne # n_as')) ev ^\\<^sub>m k =\n    four_block_mat (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\n     (0\\<^sub>m n (sum_list (map fst n_as')))\n     (0\\<^sub>m (sum_list (map fst n_as')) n)\n     (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m k)", "unfolding CM_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. four_block_mat (char_matrix (jordan_block n e) ev)\n     (0\\<^sub>m n (sum_list (map fst n_as')))\n     (0\\<^sub>m (sum_list (map fst n_as')) n)\n     (char_matrix (jordan_matrix n_as') ev) ^\\<^sub>m\n    k =\n    four_block_mat (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\n     (0\\<^sub>m n (sum_list (map fst n_as')))\n     (0\\<^sub>m (sum_list (map fst n_as')) n)\n     (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m k)", "by (rule pow_four_block_mat[OF _ CM], auto)"], ["proof (state)\nthis:\n  char_matrix (jordan_matrix (ne # n_as')) ev ^\\<^sub>m k =\n  four_block_mat (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\n   (0\\<^sub>m n (sum_list (map fst n_as')))\n   (0\\<^sub>m (sum_list (map fst n_as')) n)\n   (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m k)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "have kdim: \"?kdim ?n_as = kernel.dim n ?a + ?kdim n_as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst (ne # n_as')))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_matrix (ne # n_as')) ev ^\\<^sub>m\n                  k)\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\\<rparr>) +\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst n_as'))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m k)\\<rparr>)", "unfolding dim A_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (n + sum_list (map fst n_as'))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (four_block_mat\n                   (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\n                   (0\\<^sub>m n (sum_list (map fst n_as')))\n                   (0\\<^sub>m (sum_list (map fst n_as')) n)\n                   (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m\n                    k))\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\\<rparr>) +\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst n_as'))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m k)\\<rparr>)", "by (rule kernel_four_block_0_mat[OF refl a A])"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst (ne # n_as')))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix (ne # n_as')) ev ^\\<^sub>m\n                k)\\<rparr>) =\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\\<rparr>) +\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst n_as'))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m k)\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "also"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst (ne # n_as')))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix (ne # n_as')) ev ^\\<^sub>m\n                k)\\<rparr>) =\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\\<rparr>) +\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst n_as'))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m k)\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "have \"?kdim n_as' = ?sum n_as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst n_as'))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m\n                  k)\\<rparr>) =\n    sum_list\n     (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as')))", "by (rule Cons)"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst n_as'))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m k)\\<rparr>) =\n  sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as')))\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "also"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst n_as'))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix n_as') ev ^\\<^sub>m k)\\<rparr>) =\n  sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as')))\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "have \"kernel.dim n ?a = (if e = ev then min k n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\\<rparr>) =\n    (if e = ev then min k n else 0)", "using dim_kernel_zero_jordan_block_pow[of n k]\n        dim_kernel_non_zero_jordan_block_pow[of \"e - ev\" n k]"], ["proof (prove)\nusing this:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n  min k n\n  e - ev \\<noteq> (0::'a) \\<Longrightarrow>\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (e - ev) ^\\<^sub>m k)\\<rparr>) =\n  0\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\\<rparr>) =\n    (if e = ev then min k n else 0)", "unfolding char_matrix_jordan_block"], ["proof (prove)\nusing this:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (0::'a) ^\\<^sub>m k)\\<rparr>) =\n  min k n\n  e - ev \\<noteq> (0::'a) \\<Longrightarrow>\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel (jordan_block n (e - ev) ^\\<^sub>m k)\\<rparr>) =\n  0\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (jordan_block n (e - ev) ^\\<^sub>m k)\\<rparr>) =\n    (if e = ev then min k n else 0)", "by (cases \"e = ev\", auto)"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\\<rparr>) =\n  (if e = ev then min k n else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "also"], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) n\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_block n e) ev ^\\<^sub>m k)\\<rparr>) =\n  (if e = ev then min k n else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "have \"\\<dots> + ?sum n_as' = ?sum ?n_as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if e = ev then min k n else 0) +\n    sum_list\n     (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as'))) =\n    sum_list\n     (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) (ne # n_as'))))", "unfolding ne"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if e = ev then min k n else 0) +\n    sum_list\n     (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as'))) =\n    sum_list\n     (map (min k)\n       (map fst (filter (\\<lambda>(n, e). e = ev) ((n, e) # n_as'))))", "by auto"], ["proof (state)\nthis:\n  (if e = ev then min k n else 0) +\n  sum_list\n   (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as'))) =\n  sum_list\n   (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) (ne # n_as'))))\n\ngoal (1 subgoal):\n 1. \\<And>a n_as.\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst n_as))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix n_as) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              n_as))) \\<Longrightarrow>\n       vectorspace.dim class_ring\n        (module_vec TYPE('a) (sum_list (map fst (a # n_as)))\n         \\<lparr>carrier :=\n                   mat_kernel\n                    (char_matrix (jordan_matrix (a # n_as)) ev ^\\<^sub>m\n                     k)\\<rparr>) =\n       sum_list\n        (map (min k)\n          (map fst\n            (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n              (a # n_as))))", "finally"], ["proof (chain)\npicking this:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst (ne # n_as')))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix (ne # n_as')) ev ^\\<^sub>m\n                k)\\<rparr>) =\n  sum_list\n   (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) (ne # n_as'))))", "show ?case"], ["proof (prove)\nusing this:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst (ne # n_as')))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix (ne # n_as')) ev ^\\<^sub>m\n                k)\\<rparr>) =\n  sum_list\n   (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) (ne # n_as'))))\n\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) (sum_list (map fst (ne # n_as')))\n      \\<lparr>carrier :=\n                mat_kernel\n                 (char_matrix (jordan_matrix (ne # n_as')) ev ^\\<^sub>m\n                  k)\\<rparr>) =\n    sum_list\n     (map (min k)\n       (map fst\n         (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n           (ne # n_as'))))", "."], ["proof (state)\nthis:\n  vectorspace.dim class_ring\n   (module_vec TYPE('a) (sum_list (map fst (ne # n_as')))\n    \\<lparr>carrier :=\n              mat_kernel\n               (char_matrix (jordan_matrix (ne # n_as')) ev ^\\<^sub>m\n                k)\\<rparr>) =\n  sum_list\n   (map (min k)\n     (map fst\n       (filter (\\<lambda>a. case a of (n, e) \\<Rightarrow> e = ev)\n         (ne # n_as'))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.dim_gen_eigenspace (jordan_matrix n_as) ev k =\n  sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_gen_eigenspace_similar: assumes sim: \"similar_mat A B\"\n  shows \"dim_gen_eigenspace A = dim_gen_eigenspace B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace A = local.dim_gen_eigenspace B", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "fix ev k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "define n where \"n = dim_row A\""], ["proof (state)\nthis:\n  n = dim_row A\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "from sim[unfolded similar_mat_def]"], ["proof (chain)\npicking this:\n  \\<exists>P. Ex (similar_mat_wit A B P)", "obtain P Q where\n    wit: \"similar_mat_wit A B P Q\""], ["proof (prove)\nusing this:\n  \\<exists>P. Ex (similar_mat_wit A B P)\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        similar_mat_wit A B P Q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  similar_mat_wit A B P Q\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "let ?C = \"carrier_mat n n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "from similar_mat_witD[OF refl wit, folded n_def]"], ["proof (chain)\npicking this:\n  P * Q = 1\\<^sub>m n\n  Q * P = 1\\<^sub>m n\n  A = P * B * Q\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n", "have A: \"A \\<in> ?C\" and B: \"B \\<in> ?C\" and P: \"P \\<in> ?C\" and Q: \"Q \\<in> ?C\" \n    and PQ: \"P * Q = 1\\<^sub>m n\" and QP: \"Q * P = 1\\<^sub>m n\""], ["proof (prove)\nusing this:\n  P * Q = 1\\<^sub>m n\n  Q * P = 1\\<^sub>m n\n  A = P * B * Q\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. (A \\<in> carrier_mat n n &&&\n     B \\<in> carrier_mat n n &&& P \\<in> carrier_mat n n) &&&\n    Q \\<in> carrier_mat n n &&& P * Q = 1\\<^sub>m n &&& Q * P = 1\\<^sub>m n", "by auto"], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  P \\<in> carrier_mat n n\n  Q \\<in> carrier_mat n n\n  P * Q = 1\\<^sub>m n\n  Q * P = 1\\<^sub>m n\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "from similar_mat_wit_pow[OF similar_mat_wit_char_matrix[OF wit, of ev], of k]"], ["proof (chain)\npicking this:\n  similar_mat_wit (char_matrix A ev ^\\<^sub>m k)\n   (char_matrix B ev ^\\<^sub>m k) P Q", "have wit: \"similar_mat_wit (char_matrix A ev ^\\<^sub>m k) (char_matrix B ev ^\\<^sub>m k) P Q\""], ["proof (prove)\nusing this:\n  similar_mat_wit (char_matrix A ev ^\\<^sub>m k)\n   (char_matrix B ev ^\\<^sub>m k) P Q\n\ngoal (1 subgoal):\n 1. similar_mat_wit (char_matrix A ev ^\\<^sub>m k)\n     (char_matrix B ev ^\\<^sub>m k) P Q", "."], ["proof (state)\nthis:\n  similar_mat_wit (char_matrix A ev ^\\<^sub>m k)\n   (char_matrix B ev ^\\<^sub>m k) P Q\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "from A B"], ["proof (chain)\npicking this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n", "have cA: \"char_matrix A ev ^\\<^sub>m k \\<in> carrier_mat n n\" \n    and cB: \"char_matrix B ev ^\\<^sub>m k \\<in> carrier_mat n n\""], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. char_matrix A ev ^\\<^sub>m k \\<in> carrier_mat n n &&&\n    char_matrix B ev ^\\<^sub>m k \\<in> carrier_mat n n", "by auto"], ["proof (state)\nthis:\n  char_matrix A ev ^\\<^sub>m k \\<in> carrier_mat n n\n  char_matrix B ev ^\\<^sub>m k \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "hence dim: \"dim_col (char_matrix A ev ^\\<^sub>m k) = n\" \"dim_col (char_matrix B ev ^\\<^sub>m k) = n\""], ["proof (prove)\nusing this:\n  char_matrix A ev ^\\<^sub>m k \\<in> carrier_mat n n\n  char_matrix B ev ^\\<^sub>m k \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. dim_col (char_matrix A ev ^\\<^sub>m k) = n &&&\n    dim_col (char_matrix B ev ^\\<^sub>m k) = n", "by auto"], ["proof (state)\nthis:\n  dim_col (char_matrix A ev ^\\<^sub>m k) = n\n  dim_col (char_matrix B ev ^\\<^sub>m k) = n\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "have \"dim_gen_eigenspace A ev k = kernel_dim (char_matrix A ev ^\\<^sub>m k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace A ev k =\n    kernel_dim (char_matrix A ev ^\\<^sub>m k)", "unfolding dim_gen_eigenspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel_dim (char_matrix A ev ^\\<^sub>m k) =\n    kernel_dim (char_matrix A ev ^\\<^sub>m k)", "using A"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. kernel_dim (char_matrix A ev ^\\<^sub>m k) =\n    kernel_dim (char_matrix A ev ^\\<^sub>m k)", "by simp"], ["proof (state)\nthis:\n  local.dim_gen_eigenspace A ev k =\n  kernel_dim (char_matrix A ev ^\\<^sub>m k)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "also"], ["proof (state)\nthis:\n  local.dim_gen_eigenspace A ev k =\n  kernel_dim (char_matrix A ev ^\\<^sub>m k)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "have \"\\<dots> = kernel_dim (char_matrix B ev ^\\<^sub>m k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel_dim (char_matrix A ev ^\\<^sub>m k) =\n    kernel_dim (char_matrix B ev ^\\<^sub>m k)", "unfolding kernel_dim_def dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier :=\n                mat_kernel (char_matrix A ev ^\\<^sub>m k)\\<rparr>) =\n    vectorspace.dim class_ring\n     (module_vec TYPE('a) n\n      \\<lparr>carrier := mat_kernel (char_matrix B ev ^\\<^sub>m k)\\<rparr>)", "by (rule similar_mat_wit_kernel_dim[OF cA wit])"], ["proof (state)\nthis:\n  kernel_dim (char_matrix A ev ^\\<^sub>m k) =\n  kernel_dim (char_matrix B ev ^\\<^sub>m k)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "also"], ["proof (state)\nthis:\n  kernel_dim (char_matrix A ev ^\\<^sub>m k) =\n  kernel_dim (char_matrix B ev ^\\<^sub>m k)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "have \"\\<dots> = dim_gen_eigenspace B ev k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel_dim (char_matrix B ev ^\\<^sub>m k) =\n    local.dim_gen_eigenspace B ev k", "unfolding dim_gen_eigenspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel_dim (char_matrix B ev ^\\<^sub>m k) =\n    kernel_dim (char_matrix B ev ^\\<^sub>m k)", "using B"], ["proof (prove)\nusing this:\n  B \\<in> carrier_mat n n\n\ngoal (1 subgoal):\n 1. kernel_dim (char_matrix B ev ^\\<^sub>m k) =\n    kernel_dim (char_matrix B ev ^\\<^sub>m k)", "by simp"], ["proof (state)\nthis:\n  kernel_dim (char_matrix B ev ^\\<^sub>m k) =\n  local.dim_gen_eigenspace B ev k\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.dim_gen_eigenspace A x xa = local.dim_gen_eigenspace B x xa", "finally"], ["proof (chain)\npicking this:\n  local.dim_gen_eigenspace A ev k = local.dim_gen_eigenspace B ev k", "show \"dim_gen_eigenspace A ev k = dim_gen_eigenspace B ev k\""], ["proof (prove)\nusing this:\n  local.dim_gen_eigenspace A ev k = local.dim_gen_eigenspace B ev k\n\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace A ev k = local.dim_gen_eigenspace B ev k", "."], ["proof (state)\nthis:\n  local.dim_gen_eigenspace A ev k = local.dim_gen_eigenspace B ev k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_gen_eigenspace: assumes \"jordan_nf A n_as\"\n  shows \"dim_gen_eigenspace A ev k\n    = (\\<Sum> n \\<leftarrow> map fst [(n, e)\\<leftarrow>n_as . e = ev]. min k n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace A ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace A ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "from assms[unfolded jordan_nf_def]"], ["proof (chain)\npicking this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)", "have sim: \"similar_mat A (jordan_matrix n_as)\""], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. similar_mat A (jordan_matrix n_as)", "by auto"], ["proof (state)\nthis:\n  similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace A ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "from dim_gen_eigenspace_jordan_matrix[of n_as, folded dim_gen_eigenspace_similar[OF this]]"], ["proof (chain)\npicking this:\n  local.dim_gen_eigenspace A ?ev ?k =\n  sum_list (map (min ?k) (map fst (filter (\\<lambda>(n, e). e = ?ev) n_as)))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.dim_gen_eigenspace A ?ev ?k =\n  sum_list (map (min ?k) (map fst (filter (\\<lambda>(n, e). e = ?ev) n_as)))\n\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace A ev k =\n    sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "."], ["proof (state)\nthis:\n  local.dim_gen_eigenspace A ev k =\n  sum_list (map (min k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition compute_nr_of_jordan_blocks :: \"'a mat \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"compute_nr_of_jordan_blocks A ev k = 2 * dim_gen_eigenspace A ev k -\n     dim_gen_eigenspace A ev (k - 1) - dim_gen_eigenspace A ev (Suc k)\""], ["", "text \\<open>This lemma finally shows uniqueness of JNFs. Take an arbitrary\n  JNF of a matrix $A$, (encoded by the list of Jordan-blocks @{term n_as}),\n  then then number of occurrences of each Jordan-Block in @{term n_as} \n  is uniquely determined, namely by @{const compute_nr_of_jordan_blocks}. \n  The condition @{term \"k \\<noteq> (0 :: nat)\"}\n  is to ensure that we do not count blocks of dimension 0.\\<close>"], ["", "lemma compute_nr_of_jordan_blocks: assumes jnf: \"jordan_nf A n_as\"\n  and no_0: \"k \\<noteq> 0\"\n  shows \"compute_nr_of_jordan_blocks A ev k = length (filter ((=) (k,ev)) n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "from no_0"], ["proof (chain)\npicking this:\n  k \\<noteq> 0", "obtain k1 where k: \"k = Suc k1\""], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k1. k = Suc k1 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases k, auto)"], ["proof (state)\nthis:\n  k = Suc k1\n\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "let ?k = \"Suc k1\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "let ?k2 = \"Suc ?k\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "let ?dim = \"dim_gen_eigenspace A ev\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "let ?sizes = \"map fst [(n, e)\\<leftarrow>n_as . e = ev]\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "define sizes where \"sizes = ?sizes\""], ["proof (state)\nthis:\n  sizes = map fst (filter (\\<lambda>(n, e). e = ev) n_as)\n\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "let ?two = \"length (filter ((=) (k, ev)) n_as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "have \"compute_nr_of_jordan_blocks A ev k = \n    ?dim ?k + ?dim ?k - ?dim k1 - ?dim ?k2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    local.dim_gen_eigenspace A ev (Suc k1) +\n    local.dim_gen_eigenspace A ev (Suc k1) -\n    local.dim_gen_eigenspace A ev k1 -\n    local.dim_gen_eigenspace A ev (Suc (Suc k1))", "unfolding compute_nr_of_jordan_blocks_def k"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * local.dim_gen_eigenspace A ev (Suc k1) -\n    local.dim_gen_eigenspace A ev (Suc k1 - 1) -\n    local.dim_gen_eigenspace A ev (Suc (Suc k1)) =\n    local.dim_gen_eigenspace A ev (Suc k1) +\n    local.dim_gen_eigenspace A ev (Suc k1) -\n    local.dim_gen_eigenspace A ev k1 -\n    local.dim_gen_eigenspace A ev (Suc (Suc k1))", "by simp"], ["proof (state)\nthis:\n  local.compute_nr_of_jordan_blocks A ev k =\n  local.dim_gen_eigenspace A ev (Suc k1) +\n  local.dim_gen_eigenspace A ev (Suc k1) -\n  local.dim_gen_eigenspace A ev k1 -\n  local.dim_gen_eigenspace A ev (Suc (Suc k1))\n\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "also"], ["proof (state)\nthis:\n  local.compute_nr_of_jordan_blocks A ev k =\n  local.dim_gen_eigenspace A ev (Suc k1) +\n  local.dim_gen_eigenspace A ev (Suc k1) -\n  local.dim_gen_eigenspace A ev k1 -\n  local.dim_gen_eigenspace A ev (Suc (Suc k1))\n\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "have \"\\<dots> = length (filter ((=) k) ?sizes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim_gen_eigenspace A ev (Suc k1) +\n    local.dim_gen_eigenspace A ev (Suc k1) -\n    local.dim_gen_eigenspace A ev k1 -\n    local.dim_gen_eigenspace A ev (Suc (Suc k1)) =\n    length\n     (filter ((=) k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))", "unfolding dim_gen_eigenspace[OF jnf] k sizes_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (min (Suc k1)) sizes) +\n    sum_list (map (min (Suc k1)) sizes) -\n    sum_list (map (min k1) sizes) -\n    sum_list (map (min (Suc (Suc k1))) sizes) =\n    length (filter ((=) (Suc k1)) sizes)", "proof (rule sym, induct sizes)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (filter ((=) (Suc k1)) []) =\n    sum_list (map (min (Suc k1)) []) + sum_list (map (min (Suc k1)) []) -\n    sum_list (map (min k1) []) -\n    sum_list (map (min (Suc (Suc k1))) [])\n 2. \\<And>a sizes.\n       length (filter ((=) (Suc k1)) sizes) =\n       sum_list (map (min (Suc k1)) sizes) +\n       sum_list (map (min (Suc k1)) sizes) -\n       sum_list (map (min k1) sizes) -\n       sum_list (map (min (Suc (Suc k1))) sizes) \\<Longrightarrow>\n       length (filter ((=) (Suc k1)) (a # sizes)) =\n       sum_list (map (min (Suc k1)) (a # sizes)) +\n       sum_list (map (min (Suc k1)) (a # sizes)) -\n       sum_list (map (min k1) (a # sizes)) -\n       sum_list (map (min (Suc (Suc k1))) (a # sizes))", "case (Cons s sizes)"], ["proof (state)\nthis:\n  length (filter ((=) (Suc k1)) sizes) =\n  sum_list (map (min (Suc k1)) sizes) +\n  sum_list (map (min (Suc k1)) sizes) -\n  sum_list (map (min k1) sizes) -\n  sum_list (map (min (Suc (Suc k1))) sizes)\n\ngoal (2 subgoals):\n 1. length (filter ((=) (Suc k1)) []) =\n    sum_list (map (min (Suc k1)) []) + sum_list (map (min (Suc k1)) []) -\n    sum_list (map (min k1) []) -\n    sum_list (map (min (Suc (Suc k1))) [])\n 2. \\<And>a sizes.\n       length (filter ((=) (Suc k1)) sizes) =\n       sum_list (map (min (Suc k1)) sizes) +\n       sum_list (map (min (Suc k1)) sizes) -\n       sum_list (map (min k1) sizes) -\n       sum_list (map (min (Suc (Suc k1))) sizes) \\<Longrightarrow>\n       length (filter ((=) (Suc k1)) (a # sizes)) =\n       sum_list (map (min (Suc k1)) (a # sizes)) +\n       sum_list (map (min (Suc k1)) (a # sizes)) -\n       sum_list (map (min k1) (a # sizes)) -\n       sum_list (map (min (Suc (Suc k1))) (a # sizes))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "proof (cases \"s = ?k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "case True"], ["proof (state)\nthis:\n  s = Suc k1\n\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "let ?sum = \"\\<lambda> k sizes. sum_list (map (min k) sizes)\""], ["proof (state)\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "let ?len = \"\\<lambda> sizes. length (filter ((=) ?k) sizes)\""], ["proof (state)\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "have len: \"?len (s # sizes) = Suc (?len sizes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) (Suc k1)) (s # sizes)) =\n    Suc (length (filter ((=) (Suc k1)) sizes))", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) (Suc k1)) (Suc k1 # sizes)) =\n    Suc (length (filter ((=) (Suc k1)) sizes))", "by simp"], ["proof (state)\nthis:\n  length (filter ((=) (Suc k1)) (s # sizes)) =\n  Suc (length (filter ((=) (Suc k1)) sizes))\n\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "have IH: \"?len sizes = ?sum ?k sizes + ?sum ?k sizes -\n        ?sum k1 sizes - ?sum ?k2 sizes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) (Suc k1)) sizes) =\n    sum_list (map (min (Suc k1)) sizes) +\n    sum_list (map (min (Suc k1)) sizes) -\n    sum_list (map (min k1) sizes) -\n    sum_list (map (min (Suc (Suc k1))) sizes)", "by (rule Cons)"], ["proof (state)\nthis:\n  length (filter ((=) (Suc k1)) sizes) =\n  sum_list (map (min (Suc k1)) sizes) +\n  sum_list (map (min (Suc k1)) sizes) -\n  sum_list (map (min k1) sizes) -\n  sum_list (map (min (Suc (Suc k1))) sizes)\n\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "have \"?sum ?k (s # sizes) + ?sum ?k (s # sizes) -\n        ?sum k1 (s # sizes) - ?sum ?k2 (s # sizes)\n        = Suc (?sum ?k sizes + ?sum ?k sizes) - \n         (?sum k1 sizes + ?sum ?k2 sizes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes)) =\n    Suc (sum_list (map (min (Suc k1)) sizes) +\n         sum_list (map (min (Suc k1)) sizes)) -\n    (sum_list (map (min k1) sizes) +\n     sum_list (map (min (Suc (Suc k1))) sizes))", "using True"], ["proof (prove)\nusing this:\n  s = Suc k1\n\ngoal (1 subgoal):\n 1. sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes)) =\n    Suc (sum_list (map (min (Suc k1)) sizes) +\n         sum_list (map (min (Suc k1)) sizes)) -\n    (sum_list (map (min k1) sizes) +\n     sum_list (map (min (Suc (Suc k1))) sizes))", "by simp"], ["proof (state)\nthis:\n  sum_list (map (min (Suc k1)) (s # sizes)) +\n  sum_list (map (min (Suc k1)) (s # sizes)) -\n  sum_list (map (min k1) (s # sizes)) -\n  sum_list (map (min (Suc (Suc k1))) (s # sizes)) =\n  Suc (sum_list (map (min (Suc k1)) sizes) +\n       sum_list (map (min (Suc k1)) sizes)) -\n  (sum_list (map (min k1) sizes) +\n   sum_list (map (min (Suc (Suc k1))) sizes))\n\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "also"], ["proof (state)\nthis:\n  sum_list (map (min (Suc k1)) (s # sizes)) +\n  sum_list (map (min (Suc k1)) (s # sizes)) -\n  sum_list (map (min k1) (s # sizes)) -\n  sum_list (map (min (Suc (Suc k1))) (s # sizes)) =\n  Suc (sum_list (map (min (Suc k1)) sizes) +\n       sum_list (map (min (Suc k1)) sizes)) -\n  (sum_list (map (min k1) sizes) +\n   sum_list (map (min (Suc (Suc k1))) sizes))\n\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "have \"\\<dots> = Suc (?sum ?k sizes + ?sum ?k sizes - (?sum k1 sizes + ?sum ?k2 sizes))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (sum_list (map (min (Suc k1)) sizes) +\n         sum_list (map (min (Suc k1)) sizes)) -\n    (sum_list (map (min k1) sizes) +\n     sum_list (map (min (Suc (Suc k1))) sizes)) =\n    Suc (sum_list (map (min (Suc k1)) sizes) +\n         sum_list (map (min (Suc k1)) sizes) -\n         (sum_list (map (min k1) sizes) +\n          sum_list (map (min (Suc (Suc k1))) sizes)))", "by (rule Suc_diff_le, induct sizes, auto)"], ["proof (state)\nthis:\n  Suc (sum_list (map (min (Suc k1)) sizes) +\n       sum_list (map (min (Suc k1)) sizes)) -\n  (sum_list (map (min k1) sizes) +\n   sum_list (map (min (Suc (Suc k1))) sizes)) =\n  Suc (sum_list (map (min (Suc k1)) sizes) +\n       sum_list (map (min (Suc k1)) sizes) -\n       (sum_list (map (min k1) sizes) +\n        sum_list (map (min (Suc (Suc k1))) sizes)))\n\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "also"], ["proof (state)\nthis:\n  Suc (sum_list (map (min (Suc k1)) sizes) +\n       sum_list (map (min (Suc k1)) sizes)) -\n  (sum_list (map (min k1) sizes) +\n   sum_list (map (min (Suc (Suc k1))) sizes)) =\n  Suc (sum_list (map (min (Suc k1)) sizes) +\n       sum_list (map (min (Suc k1)) sizes) -\n       (sum_list (map (min k1) sizes) +\n        sum_list (map (min (Suc (Suc k1))) sizes)))\n\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "have \"\\<dots> = ?len (s # sizes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (sum_list (map (min (Suc k1)) sizes) +\n         sum_list (map (min (Suc k1)) sizes) -\n         (sum_list (map (min k1) sizes) +\n          sum_list (map (min (Suc (Suc k1))) sizes))) =\n    length (filter ((=) (Suc k1)) (s # sizes))", "unfolding len IH"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (sum_list (map (min (Suc k1)) sizes) +\n         sum_list (map (min (Suc k1)) sizes) -\n         (sum_list (map (min k1) sizes) +\n          sum_list (map (min (Suc (Suc k1))) sizes))) =\n    Suc (sum_list (map (min (Suc k1)) sizes) +\n         sum_list (map (min (Suc k1)) sizes) -\n         sum_list (map (min k1) sizes) -\n         sum_list (map (min (Suc (Suc k1))) sizes))", "by simp"], ["proof (state)\nthis:\n  Suc (sum_list (map (min (Suc k1)) sizes) +\n       sum_list (map (min (Suc k1)) sizes) -\n       (sum_list (map (min k1) sizes) +\n        sum_list (map (min (Suc (Suc k1))) sizes))) =\n  length (filter ((=) (Suc k1)) (s # sizes))\n\ngoal (2 subgoals):\n 1. s = Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))\n 2. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "finally"], ["proof (chain)\npicking this:\n  sum_list (map (min (Suc k1)) (s # sizes)) +\n  sum_list (map (min (Suc k1)) (s # sizes)) -\n  sum_list (map (min k1) (s # sizes)) -\n  sum_list (map (min (Suc (Suc k1))) (s # sizes)) =\n  length (filter ((=) (Suc k1)) (s # sizes))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map (min (Suc k1)) (s # sizes)) +\n  sum_list (map (min (Suc k1)) (s # sizes)) -\n  sum_list (map (min k1) (s # sizes)) -\n  sum_list (map (min (Suc (Suc k1))) (s # sizes)) =\n  length (filter ((=) (Suc k1)) (s # sizes))\n\ngoal (1 subgoal):\n 1. length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "by simp"], ["proof (state)\nthis:\n  length (filter ((=) (Suc k1)) (s # sizes)) =\n  sum_list (map (min (Suc k1)) (s # sizes)) +\n  sum_list (map (min (Suc k1)) (s # sizes)) -\n  sum_list (map (min k1) (s # sizes)) -\n  sum_list (map (min (Suc (Suc k1))) (s # sizes))\n\ngoal (1 subgoal):\n 1. s \\<noteq> Suc k1 \\<Longrightarrow>\n    length (filter ((=) (Suc k1)) (s # sizes)) =\n    sum_list (map (min (Suc k1)) (s # sizes)) +\n    sum_list (map (min (Suc k1)) (s # sizes)) -\n    sum_list (map (min k1) (s # sizes)) -\n    sum_list (map (min (Suc (Suc k1))) (s # sizes))", "qed (insert Cons, auto)"], ["proof (state)\nthis:\n  length (filter ((=) (Suc k1)) (s # sizes)) =\n  sum_list (map (min (Suc k1)) (s # sizes)) +\n  sum_list (map (min (Suc k1)) (s # sizes)) -\n  sum_list (map (min k1) (s # sizes)) -\n  sum_list (map (min (Suc (Suc k1))) (s # sizes))\n\ngoal (1 subgoal):\n 1. length (filter ((=) (Suc k1)) []) =\n    sum_list (map (min (Suc k1)) []) + sum_list (map (min (Suc k1)) []) -\n    sum_list (map (min k1) []) -\n    sum_list (map (min (Suc (Suc k1))) [])", "qed simp"], ["proof (state)\nthis:\n  local.dim_gen_eigenspace A ev (Suc k1) +\n  local.dim_gen_eigenspace A ev (Suc k1) -\n  local.dim_gen_eigenspace A ev k1 -\n  local.dim_gen_eigenspace A ev (Suc (Suc k1)) =\n  length (filter ((=) k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))\n\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "also"], ["proof (state)\nthis:\n  local.dim_gen_eigenspace A ev (Suc k1) +\n  local.dim_gen_eigenspace A ev (Suc k1) -\n  local.dim_gen_eigenspace A ev k1 -\n  local.dim_gen_eigenspace A ev (Suc (Suc k1)) =\n  length (filter ((=) k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as)))\n\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "have \"\\<dots> = length (filter ((=) (k, ev)) n_as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter ((=) k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as))) =\n    length (filter ((=) (k, ev)) n_as)", "by (induct n_as, force+)"], ["proof (state)\nthis:\n  length\n   (filter ((=) k) (map fst (filter (\\<lambda>(n, e). e = ev) n_as))) =\n  length (filter ((=) (k, ev)) n_as)\n\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "finally"], ["proof (chain)\npicking this:\n  local.compute_nr_of_jordan_blocks A ev k =\n  length (filter ((=) (k, ev)) n_as)", "show ?thesis"], ["proof (prove)\nusing this:\n  local.compute_nr_of_jordan_blocks A ev k =\n  length (filter ((=) (k, ev)) n_as)\n\ngoal (1 subgoal):\n 1. local.compute_nr_of_jordan_blocks A ev k =\n    length (filter ((=) (k, ev)) n_as)", "."], ["proof (state)\nthis:\n  local.compute_nr_of_jordan_blocks A ev k =\n  length (filter ((=) (k, ev)) n_as)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition compute_set_of_jordan_blocks :: \"'a mat \\<Rightarrow> 'a \\<Rightarrow> (nat \\<times> 'a)list\" where\n  \"compute_set_of_jordan_blocks A ev \\<equiv> let \n     k = Polynomial.order ev (char_poly A);\n     as = map (dim_gen_eigenspace A ev) [0 ..< Suc (Suc k)];\n     cards = map (\\<lambda> k. (k, 2 * as ! k - as ! (k - 1) - as ! Suc k)) [1 ..< Suc k]\n     in map (\\<lambda> (k,c). (k,ev)) (filter (\\<lambda> (k,c). c \\<noteq> 0) cards)\""], ["", "lemma compute_set_of_jordan_blocks: assumes jnf: \"jordan_nf A n_as\"\n  shows \"set (compute_set_of_jordan_blocks A ev) = set n_as \\<inter> UNIV \\<times> {ev}\" (is \"?C = ?N'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "let ?N = \"set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV\""], ["proof (state)\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "have N: \"?N' = ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set n_as \\<inter> UNIV \\<times> {ev} =\n    set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV", "using jnf[unfolded jordan_nf_def]"], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` set n_as \\<and> similar_mat A (jordan_matrix n_as)\n\ngoal (1 subgoal):\n 1. set n_as \\<inter> UNIV \\<times> {ev} =\n    set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV", "by force"], ["proof (state)\nthis:\n  set n_as \\<inter> UNIV \\<times> {ev} =\n  set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "note cjb = compute_nr_of_jordan_blocks[OF jnf]"], ["proof (state)\nthis:\n  ?k \\<noteq> 0 \\<Longrightarrow>\n  local.compute_nr_of_jordan_blocks A ?ev ?k =\n  length (filter ((=) (?k, ?ev)) n_as)\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "note d = compute_set_of_jordan_blocks_def Let_def"], ["proof (state)\nthis:\n  local.compute_set_of_jordan_blocks ?A ?ev \\<equiv>\n  let k = Polynomial.order ?ev (char_poly ?A);\n      as = map (local.dim_gen_eigenspace ?A ?ev) [0..<Suc (Suc k)];\n      cards =\n        map (\\<lambda>k. (k, 2 * as ! k - as ! (k - 1) - as ! Suc k))\n         [1..<Suc k]\n  in map (\\<lambda>(k, c). (k, ?ev))\n      (filter (\\<lambda>(k, c). c \\<noteq> 0) cards)\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "define kk where \"kk = Polynomial.order ev (char_poly A)\""], ["proof (state)\nthis:\n  kk = Polynomial.order ev (char_poly A)\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "define as where \"as = map (dim_gen_eigenspace A ev) [0 ..< Suc (Suc kk)]\""], ["proof (state)\nthis:\n  as = map (local.dim_gen_eigenspace A ev) [0..<Suc (Suc kk)]\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "define cards where \"cards = map (\\<lambda> k. (k, 2 * as ! k - as ! (k - 1) - as ! Suc k)) [1 ..< Suc kk]\""], ["proof (state)\nthis:\n  cards =\n  map (\\<lambda>k. (k, 2 * as ! k - as ! (k - 1) - as ! Suc k)) [1..<Suc kk]\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "have C: \"?C = set (map (\\<lambda> (k,c). (k,ev)) (filter (\\<lambda> (k,c). c \\<noteq> 0) cards))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set (map (\\<lambda>(k, c). (k, ev))\n          (filter (\\<lambda>(k, c). c \\<noteq> 0) cards))", "unfolding d as_def kk_def cards_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, c). (k, ev))\n          (filter (\\<lambda>(k, c). c \\<noteq> 0)\n            (map (\\<lambda>k.\n                     (k, 2 *\n                         map (local.dim_gen_eigenspace A ev)\n                          [0..<\n                           Suc (Suc (Polynomial.order ev (char_poly A)))] !\n                         k -\n                         map (local.dim_gen_eigenspace A ev)\n                          [0..<\n                           Suc (Suc (Polynomial.order ev (char_poly A)))] !\n                         (k - 1) -\n                         map (local.dim_gen_eigenspace A ev)\n                          [0..<\n                           Suc (Suc (Polynomial.order ev (char_poly A)))] !\n                         Suc k))\n              [1..<Suc (Polynomial.order ev (char_poly A))]))) =\n    set (map (\\<lambda>(k, c). (k, ev))\n          (filter (\\<lambda>(k, c). c \\<noteq> 0)\n            (map (\\<lambda>k.\n                     (k, 2 *\n                         map (local.dim_gen_eigenspace A ev)\n                          [0..<\n                           Suc (Suc (Polynomial.order ev (char_poly A)))] !\n                         k -\n                         map (local.dim_gen_eigenspace A ev)\n                          [0..<\n                           Suc (Suc (Polynomial.order ev (char_poly A)))] !\n                         (k - 1) -\n                         map (local.dim_gen_eigenspace A ev)\n                          [0..<\n                           Suc (Suc (Polynomial.order ev (char_poly A)))] !\n                         Suc k))\n              [1..<Suc (Polynomial.order ev (char_poly A))])))", "by (rule refl)"], ["proof (state)\nthis:\n  set (local.compute_set_of_jordan_blocks A ev) =\n  set (map (\\<lambda>(k, c). (k, ev))\n        (filter (\\<lambda>(k, c). c \\<noteq> 0) cards))\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "{"], ["proof (state)\nthis:\n  set (local.compute_set_of_jordan_blocks A ev) =\n  set (map (\\<lambda>(k, c). (k, ev))\n        (filter (\\<lambda>(k, c). c \\<noteq> 0) cards))\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "assume \"i < Suc (Suc kk)\""], ["proof (state)\nthis:\n  i < Suc (Suc kk)\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "hence \"as ! i = dim_gen_eigenspace A ev i\""], ["proof (prove)\nusing this:\n  i < Suc (Suc kk)\n\ngoal (1 subgoal):\n 1. as ! i = local.dim_gen_eigenspace A ev i", "unfolding as_def"], ["proof (prove)\nusing this:\n  i < Suc (Suc kk)\n\ngoal (1 subgoal):\n 1. map (local.dim_gen_eigenspace A ev) [0..<Suc (Suc kk)] ! i =\n    local.dim_gen_eigenspace A ev i", "by (auto simp del: upt_Suc)"], ["proof (state)\nthis:\n  as ! i = local.dim_gen_eigenspace A ev i\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "}"], ["proof (state)\nthis:\n  ?i2 < Suc (Suc kk) \\<Longrightarrow>\n  as ! ?i2 = local.dim_gen_eigenspace A ev ?i2\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "note as = this"], ["proof (state)\nthis:\n  ?i2 < Suc (Suc kk) \\<Longrightarrow>\n  as ! ?i2 = local.dim_gen_eigenspace A ev ?i2\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "(* TODO: perhaps use special code equation, and use inefficient thing in definition *)"], ["proof (state)\nthis:\n  ?i2 < Suc (Suc kk) \\<Longrightarrow>\n  as ! ?i2 = local.dim_gen_eigenspace A ev ?i2\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "have cards: \"cards = map (\\<lambda> k. (k, compute_nr_of_jordan_blocks A ev k)) [1 ..< Suc kk]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cards =\n    map (\\<lambda>k. (k, local.compute_nr_of_jordan_blocks A ev k))\n     [1..<Suc kk]", "unfolding cards_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. (k, 2 * as ! k - as ! (k - 1) - as ! Suc k))\n     [1..<Suc kk] =\n    map (\\<lambda>k. (k, local.compute_nr_of_jordan_blocks A ev k))\n     [1..<Suc kk]", "by (rule map_cong[OF refl], insert as, unfold compute_nr_of_jordan_blocks_def, auto)"], ["proof (state)\nthis:\n  cards =\n  map (\\<lambda>k. (k, local.compute_nr_of_jordan_blocks A ev k))\n   [1..<Suc kk]\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "have C: \"?C = { (k,ev) | k. compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and> k \\<noteq> 0 \\<and> k < Suc kk }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    {(k, ev) |k.\n     local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and>\n     k \\<noteq> 0 \\<and> k < Suc kk}", "unfolding C cards"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>(k, c). (k, ev))\n          (filter (\\<lambda>(k, c). c \\<noteq> 0)\n            (map (\\<lambda>k. (k, local.compute_nr_of_jordan_blocks A ev k))\n              [1..<Suc kk]))) =\n    {(k, ev) |k.\n     local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and>\n     k \\<noteq> 0 \\<and> k < Suc kk}", "by force"], ["proof (state)\nthis:\n  set (local.compute_set_of_jordan_blocks A ev) =\n  {(k, ev) |k.\n   local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and>\n   k \\<noteq> 0 \\<and> k < Suc kk}\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "{"], ["proof (state)\nthis:\n  set (local.compute_set_of_jordan_blocks A ev) =\n  {(k, ev) |k.\n   local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and>\n   k \\<noteq> 0 \\<and> k < Suc kk}\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "have \"(k,ev) \\<in> ?C \\<longleftrightarrow> (k,ev) \\<in> ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "unfolding C"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. ((k, ev)\n     \\<in> {(k, ev) |k.\n            local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and>\n            k \\<noteq> 0 \\<and> k < Suc kk}) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "by auto"], ["proof (state)\nthis:\n  ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n  ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "proof (cases \"k < Suc kk\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "case True"], ["proof (state)\nthis:\n  k < Suc kk\n\ngoal (2 subgoals):\n 1. k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "have \"length (filter ((=) (k, ev)) n_as) \\<noteq> 0 \\<longleftrightarrow>\n          set (filter ((=) (k, ev)) n_as) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length (filter ((=) (k, ev)) n_as) \\<noteq> 0) =\n    (set (filter ((=) (k, ev)) n_as) \\<noteq> {})", "by blast"], ["proof (state)\nthis:\n  (length (filter ((=) (k, ev)) n_as) \\<noteq> 0) =\n  (set (filter ((=) (k, ev)) n_as) \\<noteq> {})\n\ngoal (2 subgoals):\n 1. k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "have \"(k,ev) \\<in> ?N \\<longleftrightarrow>  set (filter ((=) (k, ev)) n_as) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((k, ev)\n     \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV) =\n    (set (filter ((=) (k, ev)) n_as) \\<noteq> {})", "using False"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((k, ev)\n     \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV) =\n    (set (filter ((=) (k, ev)) n_as) \\<noteq> {})", "by auto"], ["proof (state)\nthis:\n  ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV) =\n  (set (filter ((=) (k, ev)) n_as) \\<noteq> {})\n\ngoal (2 subgoals):\n 1. k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "also"], ["proof (state)\nthis:\n  ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV) =\n  (set (filter ((=) (k, ev)) n_as) \\<noteq> {})\n\ngoal (2 subgoals):\n 1. k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "have \"\\<dots> \\<longleftrightarrow> length (filter ((=) (k, ev)) n_as) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (filter ((=) (k, ev)) n_as) \\<noteq> {}) =\n    (length (filter ((=) (k, ev)) n_as) \\<noteq> 0)", "by blast"], ["proof (state)\nthis:\n  (set (filter ((=) (k, ev)) n_as) \\<noteq> {}) =\n  (length (filter ((=) (k, ev)) n_as) \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "also"], ["proof (state)\nthis:\n  (set (filter ((=) (k, ev)) n_as) \\<noteq> {}) =\n  (length (filter ((=) (k, ev)) n_as) \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "have \"\\<dots> \\<longleftrightarrow> compute_nr_of_jordan_blocks A ev k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length (filter ((=) (k, ev)) n_as) \\<noteq> 0) =\n    (local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0)", "unfolding compute_nr_of_jordan_blocks[OF jnf False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length (filter ((=) (k, ev)) n_as) \\<noteq> 0) =\n    (length (filter ((=) (k, ev)) n_as) \\<noteq> 0)", "by simp"], ["proof (state)\nthis:\n  (length (filter ((=) (k, ev)) n_as) \\<noteq> 0) =\n  (local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "also"], ["proof (state)\nthis:\n  (length (filter ((=) (k, ev)) n_as) \\<noteq> 0) =\n  (local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "have \"\\<dots> \\<longleftrightarrow> (k,ev) \\<in> ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0) =\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev))", "unfolding C"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0) =\n    ((k, ev)\n     \\<in> {(k, ev) |k.\n            local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and>\n            k \\<noteq> 0 \\<and> k < Suc kk})", "using False True"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  k < Suc kk\n\ngoal (1 subgoal):\n 1. (local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0) =\n    ((k, ev)\n     \\<in> {(k, ev) |k.\n            local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and>\n            k \\<noteq> 0 \\<and> k < Suc kk})", "by auto"], ["proof (state)\nthis:\n  (local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0) =\n  ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev))\n\ngoal (2 subgoals):\n 1. k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n 2. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "finally"], ["proof (chain)\npicking this:\n  ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV) =\n  ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev))", "show ?thesis"], ["proof (prove)\nusing this:\n  ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV) =\n  ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev))\n\ngoal (1 subgoal):\n 1. ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "by auto"], ["proof (state)\nthis:\n  ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n  ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "case False"], ["proof (state)\nthis:\n  \\<not> k < Suc kk\n\ngoal (1 subgoal):\n 1. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "hence \"(k,ev) \\<notin> ?C\""], ["proof (prove)\nusing this:\n  \\<not> k < Suc kk\n\ngoal (1 subgoal):\n 1. (k, ev) \\<notin> set (local.compute_set_of_jordan_blocks A ev)", "unfolding C"], ["proof (prove)\nusing this:\n  \\<not> k < Suc kk\n\ngoal (1 subgoal):\n 1. (k, ev)\n    \\<notin> {(k, ev) |k.\n              local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and>\n              k \\<noteq> 0 \\<and> k < Suc kk}", "by auto"], ["proof (state)\nthis:\n  (k, ev) \\<notin> set (local.compute_set_of_jordan_blocks A ev)\n\ngoal (1 subgoal):\n 1. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "moreover"], ["proof (state)\nthis:\n  (k, ev) \\<notin> set (local.compute_set_of_jordan_blocks A ev)\n\ngoal (1 subgoal):\n 1. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "from False kk_def"], ["proof (chain)\npicking this:\n  \\<not> k < Suc kk\n  kk = Polynomial.order ev (char_poly A)", "have k: \"k > Polynomial.order ev (char_poly A)\""], ["proof (prove)\nusing this:\n  \\<not> k < Suc kk\n  kk = Polynomial.order ev (char_poly A)\n\ngoal (1 subgoal):\n 1. Polynomial.order ev (char_poly A) < k", "by auto"], ["proof (state)\nthis:\n  Polynomial.order ev (char_poly A) < k\n\ngoal (1 subgoal):\n 1. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "with jordan_nf_block_size_order_bound[OF jnf, of k ev]"], ["proof (chain)\npicking this:\n  (k, ev) \\<in> set n_as \\<Longrightarrow>\n  k \\<le> Polynomial.order ev (char_poly A)\n  Polynomial.order ev (char_poly A) < k", "have \"(k,ev) \\<notin> ?N\""], ["proof (prove)\nusing this:\n  (k, ev) \\<in> set n_as \\<Longrightarrow>\n  k \\<le> Polynomial.order ev (char_poly A)\n  Polynomial.order ev (char_poly A) < k\n\ngoal (1 subgoal):\n 1. (k, ev)\n    \\<notin> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  (k, ev) \\<notin> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<not> k < Suc kk \\<Longrightarrow>\n    ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "ultimately"], ["proof (chain)\npicking this:\n  (k, ev) \\<notin> set (local.compute_set_of_jordan_blocks A ev)\n  (k, ev) \\<notin> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  (k, ev) \\<notin> set (local.compute_set_of_jordan_blocks A ev)\n  (k, ev) \\<notin> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n    ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)", "by simp"], ["proof (state)\nthis:\n  ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n  ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n  ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((k, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n  ((k, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "}"], ["proof (state)\nthis:\n  ((?k2, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n  ((?k2, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((?k2, ev) \\<in> set (local.compute_set_of_jordan_blocks A ev)) =\n  ((?k2, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev} - {0} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. set (local.compute_set_of_jordan_blocks A ev) =\n    set n_as \\<inter> UNIV \\<times> {ev}", "unfolding C N[symmetric]"], ["proof (prove)\nusing this:\n  ((?k2, ev)\n   \\<in> {(k, ev) |k.\n          local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and>\n          k \\<noteq> 0 \\<and> k < Suc kk}) =\n  ((?k2, ev) \\<in> set n_as \\<inter> UNIV \\<times> {ev})\n\ngoal (1 subgoal):\n 1. {(k, ev) |k.\n     local.compute_nr_of_jordan_blocks A ev k \\<noteq> 0 \\<and>\n     k \\<noteq> 0 \\<and> k < Suc kk} =\n    set n_as \\<inter> UNIV \\<times> {ev}", "by auto"], ["proof (state)\nthis:\n  set (local.compute_set_of_jordan_blocks A ev) =\n  set n_as \\<inter> UNIV \\<times> {ev}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jordan_nf_unique: assumes \"jordan_nf (A :: 'a mat) n_as\" and \"jordan_nf A m_bs\" \nshows \"set n_as = set m_bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set n_as = set m_bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set n_as = set m_bs", "from compute_set_of_jordan_blocks[OF assms(1), unfolded compute_set_of_jordan_blocks[OF assms(2)]]"], ["proof (chain)\npicking this:\n  set m_bs \\<inter> UNIV \\<times> {?ev} =\n  set n_as \\<inter> UNIV \\<times> {?ev}", "show ?thesis"], ["proof (prove)\nusing this:\n  set m_bs \\<inter> UNIV \\<times> {?ev} =\n  set n_as \\<inter> UNIV \\<times> {?ev}\n\ngoal (1 subgoal):\n 1. set n_as = set m_bs", "by auto"], ["proof (state)\nthis:\n  set n_as = set m_bs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>One might get more fine-grained and prove the uniqueness lemma for multisets, \n   so one takes multiplicities into account. For the moment we don't require this for\n  complexity analysis, so it remains as future work.\\<close>"], ["", "end"], ["", "end"]]}