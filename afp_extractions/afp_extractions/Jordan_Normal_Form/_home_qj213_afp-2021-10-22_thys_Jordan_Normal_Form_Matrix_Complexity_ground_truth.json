{"file_name": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form/Matrix_Complexity.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Jordan_Normal_Form", "problem_names": ["lemma weak_mat_gt_mono: assumes sd_n: \"sd \\<le> n\" and\n    orient: \"\\<And> A B. A \\<in> carrier_mat n n \\<Longrightarrow> B \\<in> carrier_mat n n \\<Longrightarrow> (A,B) \\<in> set ABs \\<Longrightarrow> weak_mat_gt sd A B\"\n   shows \"\\<exists> gt bound. mono_matrix_carrier gt default bound mono \n   \\<and> (\\<forall> A B. A \\<in> carrier_mat n n \\<longrightarrow> B \\<in> carrier_mat n n \\<longrightarrow> (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)\"", "lemma int_complexity:\n  \"mono_matrix_carrier ((>) :: int \\<Rightarrow> int \\<Rightarrow> bool) 1 nat int_mono\"", "lemma int_weak_complexity:\n  \"weak_complexity_linear_poly_order_carrier (>) 1 int_mono\"", "lemma delta_complexity:\n  assumes d0: \"d > 0\" and d1: \"d \\<le> def\" \n  shows \"mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono\"", "lemma delta_weak_complexity_carrier:\n  assumes d0: \"def > 0\" \n  shows \"weak_complexity_linear_poly_order_carrier (>) def delta_mono\"", "lemma arctic_delta_weak_carrier:\n  \"weak_SN_both_mono_ordered_semiring_1 weak_gt_arctic_delta 1 pos_arctic_delta\"", "lemma arctic_weak_carrier:\n  \"weak_SN_both_mono_ordered_semiring_1 (>) 1 pos_arctic\""], "translations": [["", "lemma weak_mat_gt_mono: assumes sd_n: \"sd \\<le> n\" and\n    orient: \"\\<And> A B. A \\<in> carrier_mat n n \\<Longrightarrow> B \\<in> carrier_mat n n \\<Longrightarrow> (A,B) \\<in> set ABs \\<Longrightarrow> weak_mat_gt sd A B\"\n   shows \"\\<exists> gt bound. mono_matrix_carrier gt default bound mono \n   \\<and> (\\<forall> A B. A \\<in> carrier_mat n n \\<longrightarrow> B \\<in> carrier_mat n n \\<longrightarrow> (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt default bound mono \\<and>\n       (\\<forall>A B.\n           A \\<in> carrier_mat n n \\<longrightarrow>\n           B \\<in> carrier_mat n n \\<longrightarrow>\n           (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt default bound mono \\<and>\n       (\\<forall>A B.\n           A \\<in> carrier_mat n n \\<longrightarrow>\n           B \\<in> carrier_mat n n \\<longrightarrow>\n           (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)", "let ?n = \"[0 ..< n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt default bound mono \\<and>\n       (\\<forall>A B.\n           A \\<in> carrier_mat n n \\<longrightarrow>\n           B \\<in> carrier_mat n n \\<longrightarrow>\n           (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)", "let ?m1x = \"[ A $$ (i,j) . A <- map fst ABs, i <- ?n, j <- ?n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt default bound mono \\<and>\n       (\\<forall>A B.\n           A \\<in> carrier_mat n n \\<longrightarrow>\n           B \\<in> carrier_mat n n \\<longrightarrow>\n           (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)", "let ?m2y = \"[ B $$ (i,j) . B <- map snd ABs, i <- ?n, j <- ?n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt default bound mono \\<and>\n       (\\<forall>A B.\n           A \\<in> carrier_mat n n \\<longrightarrow>\n           B \\<in> carrier_mat n n \\<longrightarrow>\n           (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)", "let ?pairs = \"concat (map (\\<lambda> x. map (\\<lambda> y. (x,y)) ?m2y) ?m1x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt default bound mono \\<and>\n       (\\<forall>A B.\n           A \\<in> carrier_mat n n \\<longrightarrow>\n           B \\<in> carrier_mat n n \\<longrightarrow>\n           (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)", "let ?strict = \"filter (\\<lambda> (x,y). weak_gt x y) ?pairs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt default bound mono \\<and>\n       (\\<forall>A B.\n           A \\<in> carrier_mat n n \\<longrightarrow>\n           B \\<in> carrier_mat n n \\<longrightarrow>\n           (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)", "have \"\\<forall> x y. (x,y) \\<in> set ?strict \\<longrightarrow> weak_gt x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y)\n       \\<in> set (filter (\\<lambda>(x, y). weak_gt x y)\n                   (concat\n                     (map (\\<lambda>x.\n                              map (Pair x)\n                               (concat\n                                 (map (\\<lambda>B.\n    concat\n     (map (\\<lambda>i. map (\\<lambda>j. B $$ (i, j)) [0..<n]) [0..<n]))\n                                   (map snd ABs))))\n                       (concat\n                         (map (\\<lambda>A.\n                                  concat\n                                   (map (\\<lambda>i.\n      map (\\<lambda>j. A $$ (i, j)) [0..<n])\n                                     [0..<n]))\n                           (map fst ABs)))))) \\<longrightarrow>\n       weak_gt x y", "by auto"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (x, y)\n     \\<in> set (filter (\\<lambda>(x, y). weak_gt x y)\n                 (concat\n                   (map (\\<lambda>x.\n                            map (Pair x)\n                             (concat\n                               (map (\\<lambda>B.\n  concat (map (\\<lambda>i. map (\\<lambda>j. B $$ (i, j)) [0..<n]) [0..<n]))\n                                 (map snd ABs))))\n                     (concat\n                       (map (\\<lambda>A.\n                                concat\n                                 (map (\\<lambda>i.\n    map (\\<lambda>j. A $$ (i, j)) [0..<n])\n                                   [0..<n]))\n                         (map fst ABs)))))) \\<longrightarrow>\n     weak_gt x y\n\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt default bound mono \\<and>\n       (\\<forall>A B.\n           A \\<in> carrier_mat n n \\<longrightarrow>\n           B \\<in> carrier_mat n n \\<longrightarrow>\n           (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)", "from weak_gt_mono[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>gt bound.\n     mono_matrix_carrier gt default bound mono \\<and>\n     (\\<forall>x y.\n         (x, y)\n         \\<in> set (filter (\\<lambda>(x, y). weak_gt x y)\n                     (concat\n                       (map (\\<lambda>x.\n                                map (Pair x)\n                                 (concat\n                                   (map (\\<lambda>B.\n      concat\n       (map (\\<lambda>i. map (\\<lambda>j. B $$ (i, j)) [0..<n]) [0..<n]))\n                                     (map snd ABs))))\n                         (concat\n                           (map (\\<lambda>A.\n                                    concat\n                                     (map\n (\\<lambda>i. map (\\<lambda>j. A $$ (i, j)) [0..<n]) [0..<n]))\n                             (map fst ABs)))))) \\<longrightarrow>\n         gt x y)", "obtain gt bound where order: \"mono_matrix_carrier gt default bound mono\" \n    and orient2: \"\\<And> x y. (x, y) \\<in> set ?strict \\<Longrightarrow> gt x y\""], ["proof (prove)\nusing this:\n  \\<exists>gt bound.\n     mono_matrix_carrier gt default bound mono \\<and>\n     (\\<forall>x y.\n         (x, y)\n         \\<in> set (filter (\\<lambda>(x, y). weak_gt x y)\n                     (concat\n                       (map (\\<lambda>x.\n                                map (Pair x)\n                                 (concat\n                                   (map (\\<lambda>B.\n      concat\n       (map (\\<lambda>i. map (\\<lambda>j. B $$ (i, j)) [0..<n]) [0..<n]))\n                                     (map snd ABs))))\n                         (concat\n                           (map (\\<lambda>A.\n                                    concat\n                                     (map\n (\\<lambda>i. map (\\<lambda>j. A $$ (i, j)) [0..<n]) [0..<n]))\n                             (map fst ABs)))))) \\<longrightarrow>\n         gt x y)\n\ngoal (1 subgoal):\n 1. (\\<And>gt bound.\n        \\<lbrakk>mono_matrix_carrier gt default bound mono;\n         \\<And>x y.\n            (x, y)\n            \\<in> set (filter (\\<lambda>(x, y). weak_gt x y)\n                        (concat\n                          (map (\\<lambda>x.\n                                   map (Pair x)\n                                    (concat\n(map (\\<lambda>B.\n         concat\n          (map (\\<lambda>i. map (\\<lambda>j. B $$ (i, j)) [0..<n]) [0..<n]))\n  (map snd ABs))))\n                            (concat\n                              (map (\\<lambda>A.\n concat (map (\\<lambda>i. map (\\<lambda>j. A $$ (i, j)) [0..<n]) [0..<n]))\n                                (map fst ABs)))))) \\<Longrightarrow>\n            gt x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mono_matrix_carrier gt default bound mono\n  (?x, ?y)\n  \\<in> set (filter (\\<lambda>(x, y). weak_gt x y)\n              (concat\n                (map (\\<lambda>x.\n                         map (Pair x)\n                          (concat\n                            (map (\\<lambda>B.\n                                     concat\n(map (\\<lambda>i. map (\\<lambda>j. B $$ (i, j)) [0..<n]) [0..<n]))\n                              (map snd ABs))))\n                  (concat\n                    (map (\\<lambda>A.\n                             concat\n                              (map (\\<lambda>i.\n map (\\<lambda>j. A $$ (i, j)) [0..<n])\n                                [0..<n]))\n                      (map fst ABs)))))) \\<Longrightarrow>\n  gt ?x ?y\n\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt default bound mono \\<and>\n       (\\<forall>A B.\n           A \\<in> carrier_mat n n \\<longrightarrow>\n           B \\<in> carrier_mat n n \\<longrightarrow>\n           (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt default bound mono \\<and>\n       (\\<forall>A B.\n           A \\<in> carrier_mat n n \\<longrightarrow>\n           B \\<in> carrier_mat n n \\<longrightarrow>\n           (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)", "proof (intro exI allI conjI impI, rule order)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n        (A, B) \\<in> set ABs\\<rbrakk>\n       \\<Longrightarrow> mat_gt gt sd A B", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n        (A, B) \\<in> set ABs\\<rbrakk>\n       \\<Longrightarrow> mat_gt gt sd A B", "assume A: \"A \\<in> carrier_mat n n\" and B: \"B \\<in> carrier_mat n n\"\n      and AB: \"(A, B) \\<in> set ABs\""], ["proof (state)\nthis:\n  A \\<in> carrier_mat n n\n  B \\<in> carrier_mat n n\n  (A, B) \\<in> set ABs\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n        (A, B) \\<in> set ABs\\<rbrakk>\n       \\<Longrightarrow> mat_gt gt sd A B", "from orient[OF this]"], ["proof (chain)\npicking this:\n  weak_mat_gt sd A B", "have \"mat_gt weak_gt sd A B\""], ["proof (prove)\nusing this:\n  weak_mat_gt sd A B\n\ngoal (1 subgoal):\n 1. weak_mat_gt sd A B", "by auto"], ["proof (state)\nthis:\n  weak_mat_gt sd A B\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n        (A, B) \\<in> set ABs\\<rbrakk>\n       \\<Longrightarrow> mat_gt gt sd A B", "from mat_gtD[OF this]"], ["proof (chain)\npicking this:\n  A \\<ge>\\<^sub>m B\n  \\<exists>i<sd. \\<exists>j<sd. weak_gt (A $$ (i, j)) (B $$ (i, j))", "obtain i j where\n      ge: \"A \\<ge>\\<^sub>m B\" and ij: \"i < sd\" \"j < sd\" and wgt: \"weak_gt (A $$ (i,j)) (B $$ (i,j))\""], ["proof (prove)\nusing this:\n  A \\<ge>\\<^sub>m B\n  \\<exists>i<sd. \\<exists>j<sd. weak_gt (A $$ (i, j)) (B $$ (i, j))\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>A \\<ge>\\<^sub>m B; i < sd; j < sd;\n         weak_gt (A $$ (i, j)) (B $$ (i, j))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<ge>\\<^sub>m B\n  i < sd\n  j < sd\n  weak_gt (A $$ (i, j)) (B $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n        (A, B) \\<in> set ABs\\<rbrakk>\n       \\<Longrightarrow> mat_gt gt sd A B", "from ij \\<open>sd \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  i < sd\n  j < sd\n  sd \\<le> n", "have ij': \"i < n\" \"j < n\""], ["proof (prove)\nusing this:\n  i < sd\n  j < sd\n  sd \\<le> n\n\ngoal (1 subgoal):\n 1. i < n &&& j < n", "by auto"], ["proof (state)\nthis:\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n        (A, B) \\<in> set ABs\\<rbrakk>\n       \\<Longrightarrow> mat_gt gt sd A B", "have gt: \"gt (A $$ (i,j)) (B $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gt (A $$ (i, j)) (B $$ (i, j))", "by (rule orient2, insert ij' AB wgt, force)"], ["proof (state)\nthis:\n  gt (A $$ (i, j)) (B $$ (i, j))\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>A \\<in> carrier_mat n n; B \\<in> carrier_mat n n;\n        (A, B) \\<in> set ABs\\<rbrakk>\n       \\<Longrightarrow> mat_gt gt sd A B", "show \"mat_gt gt sd A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_gt gt sd A B", "using ij gt ge"], ["proof (prove)\nusing this:\n  i < sd\n  j < sd\n  gt (A $$ (i, j)) (B $$ (i, j))\n  A \\<ge>\\<^sub>m B\n\ngoal (1 subgoal):\n 1. mat_gt gt sd A B", "by auto"], ["proof (state)\nthis:\n  mat_gt gt sd A B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>gt bound.\n     mono_matrix_carrier gt default bound mono \\<and>\n     (\\<forall>A B.\n         A \\<in> carrier_mat n n \\<longrightarrow>\n         B \\<in> carrier_mat n n \\<longrightarrow>\n         (A, B) \\<in> set ABs \\<longrightarrow> mat_gt gt sd A B)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale mono_matrix_carrier \\<subseteq> SN_strict_mono_ordered_semiring_1 d gt mono"], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_strict_mono_ordered_semiring_1 d (\\<succ>) mono", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. SN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n 2. \\<And>x y z.\n       \\<lbrakk>mono x; y \\<succ> z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x * y \\<succ> x * z", "show \"SN {(x,y). y \\<ge> 0 \\<and> x \\<succ> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}", "unfolding SN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. SN_on {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y} {x}", "by (intro allI deriv_bound_SN_on[OF bound])"], ["proof (state)\nthis:\n  SN {(x, y). (0::'a) \\<le> y \\<and> x \\<succ> y}\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>mono x; y \\<succ> z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x * y \\<succ> x * z", "qed (rule mono)"], ["", "sublocale mono_matrix_carrier \\<subseteq> matrix_carrier"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_carrier (\\<succ>) d", ".."], ["", "subsection \\<open>The Integers as Carrier\\<close>"], ["", "lemma int_complexity:\n  \"mono_matrix_carrier ((>) :: int \\<Rightarrow> int \\<Rightarrow> bool) 1 nat int_mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_matrix_carrier (\\<lambda>x y. y < x) 1 nat int_mono", "proof (unfold_locales)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a b. b \\<le> a \\<Longrightarrow> nat b \\<le> nat a\n 2. \\<And>a b. nat (a + b) \\<le> nat a + nat b\n 3. \\<And>a n.\n       0 \\<le> a \\<Longrightarrow> nat (a + int n) = nat a + nat (int n)\n 4. nat 0 = 0\n 5. 1 \\<le> nat 1\n 6. \\<And>a. deriv_bound {(a, b). 0 \\<le> b \\<and> b < a} a (nat a)\n 7. \\<And>x y z.\n       \\<lbrakk>int_mono x; z < y; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x * z < x * y", "fix x"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a b. b \\<le> a \\<Longrightarrow> nat b \\<le> nat a\n 2. \\<And>a b. nat (a + b) \\<le> nat a + nat b\n 3. \\<And>a n.\n       0 \\<le> a \\<Longrightarrow> nat (a + int n) = nat a + nat (int n)\n 4. nat 0 = 0\n 5. 1 \\<le> nat 1\n 6. \\<And>a. deriv_bound {(a, b). 0 \\<le> b \\<and> b < a} a (nat a)\n 7. \\<And>x y z.\n       \\<lbrakk>int_mono x; z < y; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x * z < x * y", "let ?R = \"{(x, y). 0 \\<le> (y :: int) \\<and> y < x}\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a b. b \\<le> a \\<Longrightarrow> nat b \\<le> nat a\n 2. \\<And>a b. nat (a + b) \\<le> nat a + nat b\n 3. \\<And>a n.\n       0 \\<le> a \\<Longrightarrow> nat (a + int n) = nat a + nat (int n)\n 4. nat 0 = 0\n 5. 1 \\<le> nat 1\n 6. \\<And>a. deriv_bound {(a, b). 0 \\<le> b \\<and> b < a} a (nat a)\n 7. \\<And>x y z.\n       \\<lbrakk>int_mono x; z < y; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x * z < x * y", "show \"deriv_bound ?R x (nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_bound {(x, y). 0 \\<le> y \\<and> y < x} x (nat x)", "unfolding deriv_bound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>b.\n       (x, b) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc (nat x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n             Suc (nat x) \\<Longrightarrow>\n    False", "assume \"(\\<exists> y. (x,y) \\<in> ?R ^^ Suc (nat x))\""], ["proof (state)\nthis:\n  \\<exists>y. (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc (nat x)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n             Suc (nat x) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc (nat x)", "obtain y where xy: \"(x,y) \\<in> ?R ^^ Suc (nat x)\""], ["proof (prove)\nusing this:\n  \\<exists>y. (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc (nat x)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        (x, y)\n        \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n              Suc (nat x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc (nat x)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n             Suc (nat x) \\<Longrightarrow>\n    False", "from xy"], ["proof (chain)\npicking this:\n  (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc (nat x)", "have y: \"0 \\<le> y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc (nat x)\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "by auto"], ["proof (state)\nthis:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n             Suc (nat x) \\<Longrightarrow>\n    False", "obtain n where n: \"n = Suc (nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = Suc (nat x) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = Suc (nat x)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n             Suc (nat x) \\<Longrightarrow>\n    False", "from xy[unfolded n[symmetric]]"], ["proof (chain)\npicking this:\n  (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ n", "have \"x \\<ge> y + int n\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ n\n\ngoal (1 subgoal):\n 1. y + int n \\<le> x", "proof (induct n arbitrary: x y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ 0 \\<Longrightarrow>\n       y + int 0 \\<le> x\n 2. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n                         n \\<Longrightarrow>\n                   y + int n \\<le> x;\n        (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> y + int (Suc n) \\<le> x", "case 0"], ["proof (state)\nthis:\n  (x, y)\n  \\<in> {a. case a of (x, y) \\<Rightarrow> 0 \\<le> y \\<and> y < x} ^^ 0\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ 0 \\<Longrightarrow>\n       y + int 0 \\<le> x\n 2. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n                         n \\<Longrightarrow>\n                   y + int n \\<le> x;\n        (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> y + int (Suc n) \\<le> x", "thus ?case"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {a. case a of (x, y) \\<Rightarrow> 0 \\<le> y \\<and> y < x} ^^ 0\n\ngoal (1 subgoal):\n 1. y + int 0 \\<le> x", "by auto"], ["proof (state)\nthis:\n  y + int 0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n                         n \\<Longrightarrow>\n                   y + int n \\<le> x;\n        (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> y + int (Suc n) \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n                         n \\<Longrightarrow>\n                   y + int n \\<le> x;\n        (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> y + int (Suc n) \\<le> x", "case (Suc n)"], ["proof (state)\nthis:\n  (?x, ?y)\n  \\<in> {a. case a of (x, y) \\<Rightarrow> 0 \\<le> y \\<and> y < x} ^^\n        n \\<Longrightarrow>\n  ?y + int n \\<le> ?x\n  (x, y)\n  \\<in> {a. case a of (x, y) \\<Rightarrow> 0 \\<le> y \\<and> y < x} ^^ Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n                         n \\<Longrightarrow>\n                   y + int n \\<le> x;\n        (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> y + int (Suc n) \\<le> x", "from Suc(2)"], ["proof (chain)\npicking this:\n  (x, y)\n  \\<in> {a. case a of (x, y) \\<Rightarrow> 0 \\<le> y \\<and> y < x} ^^ Suc n", "obtain z where xz: \"(x,z) \\<in> ?R ^^ n\" and zy: \"(z,y) \\<in> ?R\""], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {a. case a of (x, y) \\<Rightarrow> 0 \\<le> y \\<and> y < x} ^^ Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>(x, z) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ n;\n         (z, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, z) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ n\n  (z, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x}\n\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n                         n \\<Longrightarrow>\n                   y + int n \\<le> x;\n        (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> y + int (Suc n) \\<le> x", "from Suc(1)[OF xz]"], ["proof (chain)\npicking this:\n  z + int n \\<le> x", "have le: \"z + int n \\<le> x\""], ["proof (prove)\nusing this:\n  z + int n \\<le> x\n\ngoal (1 subgoal):\n 1. z + int n \\<le> x", "."], ["proof (state)\nthis:\n  z + int n \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n                         n \\<Longrightarrow>\n                   y + int n \\<le> x;\n        (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> y + int (Suc n) \\<le> x", "from zy"], ["proof (chain)\npicking this:\n  (z, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x}", "have le2: \"y + 1 \\<le> z\""], ["proof (prove)\nusing this:\n  (z, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x}\n\ngoal (1 subgoal):\n 1. y + 1 \\<le> z", "by simp"], ["proof (state)\nthis:\n  y + 1 \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n                         n \\<Longrightarrow>\n                   y + int n \\<le> x;\n        (x, y) \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^ Suc n\\<rbrakk>\n       \\<Longrightarrow> y + int (Suc n) \\<le> x", "with le"], ["proof (chain)\npicking this:\n  z + int n \\<le> x\n  y + 1 \\<le> z", "show ?case"], ["proof (prove)\nusing this:\n  z + int n \\<le> x\n  y + 1 \\<le> z\n\ngoal (1 subgoal):\n 1. y + int (Suc n) \\<le> x", "by auto"], ["proof (state)\nthis:\n  y + int (Suc n) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y + int n \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n             Suc (nat x) \\<Longrightarrow>\n    False", "with y"], ["proof (chain)\npicking this:\n  0 \\<le> y\n  y + int n \\<le> x", "have nx: \"int n \\<le> x\""], ["proof (prove)\nusing this:\n  0 \\<le> y\n  y + int n \\<le> x\n\ngoal (1 subgoal):\n 1. int n \\<le> x", "by simp"], ["proof (state)\nthis:\n  int n \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n             Suc (nat x) \\<Longrightarrow>\n    False", "from nx"], ["proof (chain)\npicking this:\n  int n \\<le> x", "have x0: \"x \\<ge> 0\""], ["proof (prove)\nusing this:\n  int n \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "by simp"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). 0 \\<le> y \\<and> y < x} ^^\n             Suc (nat x) \\<Longrightarrow>\n    False", "with nx n"], ["proof (chain)\npicking this:\n  int n \\<le> x\n  n = Suc (nat x)\n  0 \\<le> x", "show False"], ["proof (prove)\nusing this:\n  int n \\<le> x\n  n = Suc (nat x)\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deriv_bound {(x, y). 0 \\<le> y \\<and> y < x} x (nat x)\n\ngoal (6 subgoals):\n 1. \\<And>a b. b \\<le> a \\<Longrightarrow> nat b \\<le> nat a\n 2. \\<And>a b. nat (a + b) \\<le> nat a + nat b\n 3. \\<And>a n.\n       0 \\<le> a \\<Longrightarrow> nat (a + int n) = nat a + nat (int n)\n 4. nat 0 = 0\n 5. 1 \\<le> nat 1\n 6. \\<And>x y z.\n       \\<lbrakk>int_mono x; z < y; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x * z < x * y", "qed (insert int_SN.mono, auto)"], ["", "lemma int_weak_complexity:\n  \"weak_complexity_linear_poly_order_carrier (>) 1 int_mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_complexity_linear_poly_order_carrier (\\<lambda>x y. y < x) 1\n     int_mono", "by (unfold_locales, intro exI[of _ \"(>)\"] exI[of _ nat] conjI, rule int_complexity, auto)"], ["", "subsection \\<open>The Rational and Real Numbers as Carrier\\<close>"], ["", "definition delta_bound :: \"'a :: floor_ceiling \\<Rightarrow> 'a \\<Rightarrow> nat\"\nwhere\n  \"delta_bound d x = nat (ceiling (x * of_int (ceiling (1 / d))))\""], ["", "lemma delta_complexity:\n  assumes d0: \"d > 0\" and d1: \"d \\<le> def\" \n  shows \"mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "from d0"], ["proof (chain)\npicking this:\n  (0::'a) < d", "have d00: \"0 \\<le> d\""], ["proof (prove)\nusing this:\n  (0::'a) < d\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> d", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<le> d\n\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "define N where \"N = ceiling (1 / d)\""], ["proof (state)\nthis:\n  N = \\<lceil>(1::'a) / d\\<rceil>\n\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "let ?N = \"of_int N :: 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "from d0"], ["proof (chain)\npicking this:\n  (0::'a) < d", "have \"1 / d > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < d\n\ngoal (1 subgoal):\n 1. (0::'a) < (1::'a) / d", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (0::'a) < (1::'a) / d\n\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "with ceiling_correct[of \"1 / d\"]"], ["proof (chain)\npicking this:\n  of_int \\<lceil>(1::'a) / d\\<rceil> - (1::'a) < (1::'a) / d \\<and>\n  (1::'a) / d \\<le> of_int \\<lceil>(1::'a) / d\\<rceil>\n  (0::'a) < (1::'a) / d", "have Nd: \"1 / d \\<le> ?N\" and N: \"N > 0\""], ["proof (prove)\nusing this:\n  of_int \\<lceil>(1::'a) / d\\<rceil> - (1::'a) < (1::'a) / d \\<and>\n  (1::'a) / d \\<le> of_int \\<lceil>(1::'a) / d\\<rceil>\n  (0::'a) < (1::'a) / d\n\ngoal (1 subgoal):\n 1. (1::'a) / d \\<le> of_int N &&& 0 < N", "unfolding N_def"], ["proof (prove)\nusing this:\n  of_int \\<lceil>(1::'a) / d\\<rceil> - (1::'a) < (1::'a) / d \\<and>\n  (1::'a) / d \\<le> of_int \\<lceil>(1::'a) / d\\<rceil>\n  (0::'a) < (1::'a) / d\n\ngoal (1 subgoal):\n 1. (1::'a) / d \\<le> of_int \\<lceil>(1::'a) / d\\<rceil> &&&\n    0 < \\<lceil>(1::'a) / d\\<rceil>", "by auto"], ["proof (state)\nthis:\n  (1::'a) / d \\<le> of_int N\n  0 < N\n\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "let ?nat = \"\\<lambda> x. nat (ceiling (x * ?N))\""], ["proof (state)\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "let ?gt = \"delta_gt d\""], ["proof (state)\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "have nn: \"delta_bound d = ?nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_bound d = (\\<lambda>x. nat \\<lceil>x * of_int N\\<rceil>)", "unfolding fun_eq_iff N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       delta_bound d x =\n       nat \\<lceil>x * of_int \\<lceil>(1::'a) / d\\<rceil>\\<rceil>", "by (simp add: delta_bound_def)"], ["proof (state)\nthis:\n  delta_bound d = (\\<lambda>x. nat \\<lceil>x * of_int N\\<rceil>)\n\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "from delta_interpretation[OF d0 d1]"], ["proof (chain)\npicking this:\n  SN_strict_mono_ordered_semiring_1 def (delta_gt d) delta_mono", "interpret SN_strict_mono_ordered_semiring_1 \"def\" ?gt delta_mono"], ["proof (prove)\nusing this:\n  SN_strict_mono_ordered_semiring_1 def (delta_gt d) delta_mono\n\ngoal (1 subgoal):\n 1. SN_strict_mono_ordered_semiring_1 def (delta_gt d) delta_mono", "."], ["proof (state)\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono", "unfolding nn"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_matrix_carrier (delta_gt d) def\n     (\\<lambda>x. nat \\<lceil>x * of_int N\\<rceil>) delta_mono", "proof(unfold_locales)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a b.\n       b \\<le> a \\<Longrightarrow>\n       nat \\<lceil>b * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil>\n 2. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 3. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 4. nat \\<lceil>(0::'a) * of_int N\\<rceil> = 0\n 5. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n 6. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 7. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "show \"?nat 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>(0::'a) * of_int N\\<rceil> = 0", "by auto"], ["proof (state)\nthis:\n  nat \\<lceil>(0::'a) * of_int N\\<rceil> = 0\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       b \\<le> a \\<Longrightarrow>\n       nat \\<lceil>b * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil>\n 2. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 3. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 4. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n 5. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 6. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b.\n       b \\<le> a \\<Longrightarrow>\n       nat \\<lceil>b * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil>\n 2. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 3. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 4. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n 5. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 6. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "fix x y :: 'a"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b.\n       b \\<le> a \\<Longrightarrow>\n       nat \\<lceil>b * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil>\n 2. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 3. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 4. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n 5. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 6. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "assume xy: \"x \\<ge> y\""], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       b \\<le> a \\<Longrightarrow>\n       nat \\<lceil>b * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil>\n 2. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 3. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 4. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n 5. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 6. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "show \"?nat x \\<ge> ?nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>y * of_int N\\<rceil> \\<le> nat \\<lceil>x * of_int N\\<rceil>", "by (rule nat_mono, rule ceiling_mono, insert xy N, auto simp: field_simps)"], ["proof (state)\nthis:\n  nat \\<lceil>y * of_int N\\<rceil> \\<le> nat \\<lceil>x * of_int N\\<rceil>\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n 4. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 5. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n 4. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 5. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "have \"1 \\<le> nat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> nat 1", "by simp"], ["proof (state)\nthis:\n  1 \\<le> nat 1\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n 4. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 5. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "also"], ["proof (state)\nthis:\n  1 \\<le> nat 1\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n 4. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 5. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "have \"... \\<le> ?nat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>", "proof (rule nat_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>", "have \"1 = ceiling (1 :: rat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = \\<lceil>1\\<rceil>", "by simp"], ["proof (state)\nthis:\n  1 = \\<lceil>1\\<rceil>\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>", "also"], ["proof (state)\nthis:\n  1 = \\<lceil>1\\<rceil>\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>", "have \"... \\<le> ceiling (1 * ?N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>1\\<rceil> \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>", "using N"], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. \\<lceil>1\\<rceil> \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>", "by simp"], ["proof (state)\nthis:\n  \\<lceil>1\\<rceil> \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>", "show \"1 \\<le> ceiling (1 * ?N)\""], ["proof (prove)\nusing this:\n  1 \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>", "."], ["proof (state)\nthis:\n  1 \\<le> \\<lceil>(1::'a) * of_int N\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n 4. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 5. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>", "show \"1 \\<le> ?nat 1\""], ["proof (prove)\nusing this:\n  1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n\ngoal (1 subgoal):\n 1. 1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>", "."], ["proof (state)\nthis:\n  1 \\<le> nat \\<lceil>(1::'a) * of_int N\\<rceil>\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 4. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 4. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "fix x y :: 'a"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 4. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "have \"ceiling ((x + y) * ?N) = ceiling (x * ?N + y * ?N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>(x + y) * of_int N\\<rceil> =\n    \\<lceil>x * of_int N + y * of_int N\\<rceil>", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  \\<lceil>(x + y) * of_int N\\<rceil> =\n  \\<lceil>x * of_int N + y * of_int N\\<rceil>\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 4. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "also"], ["proof (state)\nthis:\n  \\<lceil>(x + y) * of_int N\\<rceil> =\n  \\<lceil>x * of_int N + y * of_int N\\<rceil>\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 4. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "have \"... \\<le> ceiling (x * ?N) + ceiling (y * ?N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>x * of_int N + y * of_int N\\<rceil>\n    \\<le> \\<lceil>x * of_int N\\<rceil> + \\<lceil>y * of_int N\\<rceil>", "by (rule ceiling_add_le)"], ["proof (state)\nthis:\n  \\<lceil>x * of_int N + y * of_int N\\<rceil>\n  \\<le> \\<lceil>x * of_int N\\<rceil> + \\<lceil>y * of_int N\\<rceil>\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       nat \\<lceil>(a + b) * of_int N\\<rceil>\n       \\<le> nat \\<lceil>a * of_int N\\<rceil> +\n             nat \\<lceil>b * of_int N\\<rceil>\n 2. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 3. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 4. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "finally"], ["proof (chain)\npicking this:\n  \\<lceil>(x + y) * of_int N\\<rceil>\n  \\<le> \\<lceil>x * of_int N\\<rceil> + \\<lceil>y * of_int N\\<rceil>", "show \"?nat (x + y) \\<le> ?nat x + ?nat y\""], ["proof (prove)\nusing this:\n  \\<lceil>(x + y) * of_int N\\<rceil>\n  \\<le> \\<lceil>x * of_int N\\<rceil> + \\<lceil>y * of_int N\\<rceil>\n\ngoal (1 subgoal):\n 1. nat \\<lceil>(x + y) * of_int N\\<rceil>\n    \\<le> nat \\<lceil>x * of_int N\\<rceil> +\n          nat \\<lceil>y * of_int N\\<rceil>", "by auto"], ["proof (state)\nthis:\n  nat \\<lceil>(x + y) * of_int N\\<rceil>\n  \\<le> nat \\<lceil>x * of_int N\\<rceil> + nat \\<lceil>y * of_int N\\<rceil>\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "fix x :: 'a and n :: nat"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "assume x: \"0 \\<le> x\""], ["proof (state)\nthis:\n  (0::'a) \\<le> x\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "interpret mono_matrix_carrier \"(>)\" 1 nat int_mono"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_matrix_carrier (\\<lambda>x y. y < x) 1 nat int_mono", "by (rule int_complexity)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "have \"?nat (x + of_nat n) = nat (ceiling (x * ?N + of_nat n * ?N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>(x + of_nat n) * of_int N\\<rceil> =\n    nat \\<lceil>x * of_int N + of_nat n * of_int N\\<rceil>", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  nat \\<lceil>(x + of_nat n) * of_int N\\<rceil> =\n  nat \\<lceil>x * of_int N + of_nat n * of_int N\\<rceil>\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "also"], ["proof (state)\nthis:\n  nat \\<lceil>(x + of_nat n) * of_int N\\<rceil> =\n  nat \\<lceil>x * of_int N + of_nat n * of_int N\\<rceil>\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "have id: \"of_nat n * ?N = of_int (of_nat (n * nat N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n * of_int N = of_int (int (n * nat N))", "using N"], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. of_nat n * of_int N = of_int (int (n * nat N))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  of_nat n * of_int N = of_int (int (n * nat N))\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "also"], ["proof (state)\nthis:\n  of_nat n * of_int N = of_int (int (n * nat N))\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "have \"ceiling (x * ?N + of_int (of_nat (n * nat N))) = ceiling (x * ?N) + of_nat (n * nat N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>x * of_int N + of_int (int (n * nat N))\\<rceil> =\n    \\<lceil>x * of_int N\\<rceil> + int (n * nat N)", "unfolding ceiling_add_of_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>x * of_int N\\<rceil> + int (n * nat N) =\n    \\<lceil>x * of_int N\\<rceil> + int (n * nat N)", ".."], ["proof (state)\nthis:\n  \\<lceil>x * of_int N + of_int (int (n * nat N))\\<rceil> =\n  \\<lceil>x * of_int N\\<rceil> + int (n * nat N)\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "also"], ["proof (state)\nthis:\n  \\<lceil>x * of_int N + of_int (int (n * nat N))\\<rceil> =\n  \\<lceil>x * of_int N\\<rceil> + int (n * nat N)\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "have \"nat (ceiling (x * ?N) + of_nat (n * nat N)) = ?nat x + nat (int (n * nat N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (\\<lceil>x * of_int N\\<rceil> + int (n * nat N)) =\n    nat \\<lceil>x * of_int N\\<rceil> + nat (int (n * nat N))", "proof (rule bound_plus_of_nat)"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lceil>x * of_int N\\<rceil>", "have \"x * ?N \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x * of_int N", "by (rule mult_nonneg_nonneg, insert x N, auto)"], ["proof (state)\nthis:\n  (0::'a) \\<le> x * of_int N\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lceil>x * of_int N\\<rceil>", "thus \"ceiling (x * ?N) \\<ge> 0\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x * of_int N\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lceil>x * of_int N\\<rceil>", "by auto"], ["proof (state)\nthis:\n  0 \\<le> \\<lceil>x * of_int N\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat (\\<lceil>x * of_int N\\<rceil> + int (n * nat N)) =\n  nat \\<lceil>x * of_int N\\<rceil> + nat (int (n * nat N))\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "also"], ["proof (state)\nthis:\n  nat (\\<lceil>x * of_int N\\<rceil> + int (n * nat N)) =\n  nat \\<lceil>x * of_int N\\<rceil> + nat (int (n * nat N))\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "have \"(nat (int (n * nat N))) = n * nat N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (int (n * nat N)) = n * nat N", "by presburger"], ["proof (state)\nthis:\n  nat (int (n * nat N)) = n * nat N\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "also"], ["proof (state)\nthis:\n  nat (int (n * nat N)) = n * nat N\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "have \"n * nat N = ?nat (of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * nat N = nat \\<lceil>of_nat n * of_int N\\<rceil>", "using N"], ["proof (prove)\nusing this:\n  0 < N\n\ngoal (1 subgoal):\n 1. n * nat N = nat \\<lceil>of_nat n * of_int N\\<rceil>", "by (metis id ceiling_of_int nat_int)"], ["proof (state)\nthis:\n  n * nat N = nat \\<lceil>of_nat n * of_int N\\<rceil>\n\ngoal (3 subgoals):\n 1. \\<And>a n.\n       (0::'a) \\<le> a \\<Longrightarrow>\n       nat \\<lceil>(a + of_nat n) * of_int N\\<rceil> =\n       nat \\<lceil>a * of_int N\\<rceil> +\n       nat \\<lceil>of_nat n * of_int N\\<rceil>\n 2. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 3. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "finally"], ["proof (chain)\npicking this:\n  nat \\<lceil>(x + of_nat n) * of_int N\\<rceil> =\n  nat \\<lceil>x * of_int N\\<rceil> + nat \\<lceil>of_nat n * of_int N\\<rceil>", "show \"?nat (x + of_nat n) = ?nat x + ?nat (of_nat n)\""], ["proof (prove)\nusing this:\n  nat \\<lceil>(x + of_nat n) * of_int N\\<rceil> =\n  nat \\<lceil>x * of_int N\\<rceil> + nat \\<lceil>of_nat n * of_int N\\<rceil>\n\ngoal (1 subgoal):\n 1. nat \\<lceil>(x + of_nat n) * of_int N\\<rceil> =\n    nat \\<lceil>x * of_int N\\<rceil> +\n    nat \\<lceil>of_nat n * of_int N\\<rceil>", "."], ["proof (state)\nthis:\n  nat \\<lceil>(x + of_nat n) * of_int N\\<rceil> =\n  nat \\<lceil>x * of_int N\\<rceil> + nat \\<lceil>of_nat n * of_int N\\<rceil>\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 2. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 2. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "fix x y z :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 2. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "assume *: \"delta_mono x\" \"delta_gt d y z\" and x: \"0 \\<le> x\""], ["proof (state)\nthis:\n  delta_mono x\n  delta_gt d y z\n  (0::'a) \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)\n 2. \\<And>x y z.\n       \\<lbrakk>delta_mono x; delta_gt d y z; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> delta_gt d (x * y) (x * z)", "from mono[OF * x]"], ["proof (chain)\npicking this:\n  delta_gt d (x * y) (x * z)", "show \"delta_gt d (x * y) (x * z)\""], ["proof (prove)\nusing this:\n  delta_gt d (x * y) (x * z)\n\ngoal (1 subgoal):\n 1. delta_gt d (x * y) (x * z)", "."], ["proof (state)\nthis:\n  delta_gt d (x * y) (x * z)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)", "fix x :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)", "let ?R = \"{(x,y). 0 \\<le> y \\<and> ?gt x y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       deriv_bound {(a, b). (0::'a) \\<le> b \\<and> delta_gt d a b} a\n        (nat \\<lceil>a * of_int N\\<rceil>)", "show \"deriv_bound ?R x (?nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv_bound {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} x\n     (nat \\<lceil>x * of_int N\\<rceil>)", "unfolding deriv_bound_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "assume \"(\\<exists> y. (x,y) \\<in> ?R ^^ Suc (?nat x))\""], ["proof (state)\nthis:\n  \\<exists>y.\n     (x, y)\n     \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n           Suc (nat \\<lceil>x * of_int N\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>y.\n     (x, y)\n     \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n           Suc (nat \\<lceil>x * of_int N\\<rceil>)", "obtain y where xy: \"(x,y) \\<in> ?R ^^ Suc (?nat x)\""], ["proof (prove)\nusing this:\n  \\<exists>y.\n     (x, y)\n     \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n           Suc (nat \\<lceil>x * of_int N\\<rceil>)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        (x, y)\n        \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n              Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (x, y)\n  \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n        Suc (nat \\<lceil>x * of_int N\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "from xy"], ["proof (chain)\npicking this:\n  (x, y)\n  \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n        Suc (nat \\<lceil>x * of_int N\\<rceil>)", "have y: \"0 \\<le> y\""], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n        Suc (nat \\<lceil>x * of_int N\\<rceil>)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> y", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "obtain n where n: \"n = Suc (?nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n = Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = Suc (nat \\<lceil>x * of_int N\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "from xy[unfolded n[symmetric]]"], ["proof (chain)\npicking this:\n  (x, y) \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^ n", "have \"x \\<ge> y + d * of_nat n\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^ n\n\ngoal (1 subgoal):\n 1. y + d * of_nat n \\<le> x", "proof (induct n arbitrary: x y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             0 \\<Longrightarrow>\n       y + d * of_nat 0 \\<le> x\n 2. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n                         n \\<Longrightarrow>\n                   y + d * of_nat n \\<le> x;\n        (x, y)\n        \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n              Suc n\\<rbrakk>\n       \\<Longrightarrow> y + d * of_nat (Suc n) \\<le> x", "case 0"], ["proof (state)\nthis:\n  (x, y)\n  \\<in> {a. case a of\n            (x, y) \\<Rightarrow> (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n        0\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             0 \\<Longrightarrow>\n       y + d * of_nat 0 \\<le> x\n 2. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n                         n \\<Longrightarrow>\n                   y + d * of_nat n \\<le> x;\n        (x, y)\n        \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n              Suc n\\<rbrakk>\n       \\<Longrightarrow> y + d * of_nat (Suc n) \\<le> x", "thus ?case"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {a. case a of\n            (x, y) \\<Rightarrow> (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n        0\n\ngoal (1 subgoal):\n 1. y + d * of_nat 0 \\<le> x", "by auto"], ["proof (state)\nthis:\n  y + d * of_nat 0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n                         n \\<Longrightarrow>\n                   y + d * of_nat n \\<le> x;\n        (x, y)\n        \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n              Suc n\\<rbrakk>\n       \\<Longrightarrow> y + d * of_nat (Suc n) \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n                         n \\<Longrightarrow>\n                   y + d * of_nat n \\<le> x;\n        (x, y)\n        \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n              Suc n\\<rbrakk>\n       \\<Longrightarrow> y + d * of_nat (Suc n) \\<le> x", "case (Suc n)"], ["proof (state)\nthis:\n  (?x, ?y)\n  \\<in> {a. case a of\n            (x, y) \\<Rightarrow> (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n        n \\<Longrightarrow>\n  ?y + d * of_nat n \\<le> ?x\n  (x, y)\n  \\<in> {a. case a of\n            (x, y) \\<Rightarrow> (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n        Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n                         n \\<Longrightarrow>\n                   y + d * of_nat n \\<le> x;\n        (x, y)\n        \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n              Suc n\\<rbrakk>\n       \\<Longrightarrow> y + d * of_nat (Suc n) \\<le> x", "from Suc(2)"], ["proof (chain)\npicking this:\n  (x, y)\n  \\<in> {a. case a of\n            (x, y) \\<Rightarrow> (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n        Suc n", "obtain z where xz: \"(x,z) \\<in> ?R ^^ n\" and zy: \"(z,y) \\<in> ?R\""], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {a. case a of\n            (x, y) \\<Rightarrow> (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n        Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>(x, z)\n                 \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^ n;\n         (z, y)\n         \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, z) \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^ n\n  (z, y) \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y}\n\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n                         n \\<Longrightarrow>\n                   y + d * of_nat n \\<le> x;\n        (x, y)\n        \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n              Suc n\\<rbrakk>\n       \\<Longrightarrow> y + d * of_nat (Suc n) \\<le> x", "from Suc(1)[OF xz]"], ["proof (chain)\npicking this:\n  z + d * of_nat n \\<le> x", "have le: \"z + d * of_nat n \\<le> x\""], ["proof (prove)\nusing this:\n  z + d * of_nat n \\<le> x\n\ngoal (1 subgoal):\n 1. z + d * of_nat n \\<le> x", "."], ["proof (state)\nthis:\n  z + d * of_nat n \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n                         n \\<Longrightarrow>\n                   y + d * of_nat n \\<le> x;\n        (x, y)\n        \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n              Suc n\\<rbrakk>\n       \\<Longrightarrow> y + d * of_nat (Suc n) \\<le> x", "from zy[unfolded delta_gt_def]"], ["proof (chain)\npicking this:\n  (z, y) \\<in> {(x, y). (0::'a) \\<le> y \\<and> d \\<le> x - y}", "have le2: \"y + d \\<le> z\""], ["proof (prove)\nusing this:\n  (z, y) \\<in> {(x, y). (0::'a) \\<le> y \\<and> d \\<le> x - y}\n\ngoal (1 subgoal):\n 1. y + d \\<le> z", "by simp"], ["proof (state)\nthis:\n  y + d \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>n x y.\n       \\<lbrakk>\\<And>x y.\n                   (x, y)\n                   \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n                         n \\<Longrightarrow>\n                   y + d * of_nat n \\<le> x;\n        (x, y)\n        \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n              Suc n\\<rbrakk>\n       \\<Longrightarrow> y + d * of_nat (Suc n) \\<le> x", "with le"], ["proof (chain)\npicking this:\n  z + d * of_nat n \\<le> x\n  y + d \\<le> z", "show ?case"], ["proof (prove)\nusing this:\n  z + d * of_nat n \\<le> x\n  y + d \\<le> z\n\ngoal (1 subgoal):\n 1. y + d * of_nat (Suc n) \\<le> x", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  y + d * of_nat (Suc n) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y + d * of_nat n \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "with y"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> y\n  y + d * of_nat n \\<le> x", "have nx: \"d * of_nat n \\<le> x\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> y\n  y + d * of_nat n \\<le> x\n\ngoal (1 subgoal):\n 1. d * of_nat n \\<le> x", "by simp"], ["proof (state)\nthis:\n  d * of_nat n \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "have \"0 \\<le> d * of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> d * of_nat n", "by (rule mult_nonneg_nonneg, insert d00, auto)"], ["proof (state)\nthis:\n  (0::'a) \\<le> d * of_nat n\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "with nx"], ["proof (chain)\npicking this:\n  d * of_nat n \\<le> x\n  (0::'a) \\<le> d * of_nat n", "have x0: \"x \\<ge> 0\""], ["proof (prove)\nusing this:\n  d * of_nat n \\<le> x\n  (0::'a) \\<le> d * of_nat n\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "have xd0: \"0 \\<le> x / d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x / d", "by (rule divide_nonneg_pos[OF x0 d0])"], ["proof (state)\nthis:\n  (0::'a) \\<le> x / d\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "from nx[unfolded n]"], ["proof (chain)\npicking this:\n  d * of_nat (Suc (nat \\<lceil>x * of_int N\\<rceil>)) \\<le> x", "have \"d + d * of_nat (?nat x) \\<le> x\""], ["proof (prove)\nusing this:\n  d * of_nat (Suc (nat \\<lceil>x * of_int N\\<rceil>)) \\<le> x\n\ngoal (1 subgoal):\n 1. d + d * of_nat (nat \\<lceil>x * of_int N\\<rceil>) \\<le> x", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  d + d * of_nat (nat \\<lceil>x * of_int N\\<rceil>) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "with d0"], ["proof (chain)\npicking this:\n  (0::'a) < d\n  d + d * of_nat (nat \\<lceil>x * of_int N\\<rceil>) \\<le> x", "have less: \"d * of_nat (?nat x) < x\""], ["proof (prove)\nusing this:\n  (0::'a) < d\n  d + d * of_nat (nat \\<lceil>x * of_int N\\<rceil>) \\<le> x\n\ngoal (1 subgoal):\n 1. d * of_nat (nat \\<lceil>x * of_int N\\<rceil>) < x", "by simp"], ["proof (state)\nthis:\n  d * of_nat (nat \\<lceil>x * of_int N\\<rceil>) < x\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "from Nd d0"], ["proof (chain)\npicking this:\n  (1::'a) / d \\<le> of_int N\n  (0::'a) < d", "have \"1 \\<le> d * ?N\""], ["proof (prove)\nusing this:\n  (1::'a) / d \\<le> of_int N\n  (0::'a) < d\n\ngoal (1 subgoal):\n 1. (1::'a) \\<le> d * of_int N", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (1::'a) \\<le> d * of_int N\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "from mult_left_mono[OF this x0]"], ["proof (chain)\npicking this:\n  x * (1::'a) \\<le> x * (d * of_int N)", "have \"x \\<le> d * (x * ?N)\""], ["proof (prove)\nusing this:\n  x * (1::'a) \\<le> x * (d * of_int N)\n\ngoal (1 subgoal):\n 1. x \\<le> d * (x * of_int N)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  x \\<le> d * (x * of_int N)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  x \\<le> d * (x * of_int N)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "have \"\\<dots> \\<le> d * of_nat (?nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * (x * of_int N) \\<le> d * of_nat (nat \\<lceil>x * of_int N\\<rceil>)", "proof (rule mult_left_mono[OF _ d00])"], ["proof (state)\ngoal (1 subgoal):\n 1. x * of_int N \\<le> of_nat (nat \\<lceil>x * of_int N\\<rceil>)", "show \"x * ?N \\<le> of_nat (nat \\<lceil>x * ?N\\<rceil>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * of_int N \\<le> of_nat (nat \\<lceil>x * of_int N\\<rceil>)", "using x0 ceiling_correct[of \"x * ?N\"]"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n  of_int \\<lceil>x * of_int N\\<rceil> - (1::'a) < x * of_int N \\<and>\n  x * of_int N \\<le> of_int \\<lceil>x * of_int N\\<rceil>\n\ngoal (1 subgoal):\n 1. x * of_int N \\<le> of_nat (nat \\<lceil>x * of_int N\\<rceil>)", "by (metis int_nat_eq le_cases of_int_0_le_iff of_int_of_nat_eq order_trans)"], ["proof (state)\nthis:\n  x * of_int N \\<le> of_nat (nat \\<lceil>x * of_int N\\<rceil>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d * (x * of_int N) \\<le> d * of_nat (nat \\<lceil>x * of_int N\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  d * (x * of_int N) \\<le> d * of_nat (nat \\<lceil>x * of_int N\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "have \"\\<dots> < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * of_nat (nat \\<lceil>x * of_int N\\<rceil>) < x", "using less"], ["proof (prove)\nusing this:\n  d * of_nat (nat \\<lceil>x * of_int N\\<rceil>) < x\n\ngoal (1 subgoal):\n 1. d * of_nat (nat \\<lceil>x * of_int N\\<rceil>) < x", "."], ["proof (state)\nthis:\n  d * of_nat (nat \\<lceil>x * of_int N\\<rceil>) < x\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       (x, b)\n       \\<in> {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} ^^\n             Suc (nat \\<lceil>x * of_int N\\<rceil>) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  x < x", "show False"], ["proof (prove)\nusing this:\n  x < x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deriv_bound {(x, y). (0::'a) \\<le> y \\<and> delta_gt d x y} x\n   (nat \\<lceil>x * of_int N\\<rceil>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mono_matrix_carrier (delta_gt d) def (delta_bound d) delta_mono\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delta_weak_complexity_carrier:\n  assumes d0: \"def > 0\" \n  shows \"weak_complexity_linear_poly_order_carrier (>) def delta_mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_complexity_linear_poly_order_carrier (\\<lambda>x y. y < x) def\n     delta_mono", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xys.\n       \\<forall>x y.\n          (x, y) \\<in> set xys \\<longrightarrow> y < x \\<Longrightarrow>\n       \\<exists>gt bound.\n          mono_matrix_carrier gt def bound delta_mono \\<and>\n          (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "fix xys :: \"('a \\<times> 'a) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xys.\n       \\<forall>x y.\n          (x, y) \\<in> set xys \\<longrightarrow> y < x \\<Longrightarrow>\n       \\<exists>gt bound.\n          mono_matrix_carrier gt def bound delta_mono \\<and>\n          (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "assume ass: \"\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> y < x\""], ["proof (state)\nthis:\n  \\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> y < x\n\ngoal (1 subgoal):\n 1. \\<And>xys.\n       \\<forall>x y.\n          (x, y) \\<in> set xys \\<longrightarrow> y < x \\<Longrightarrow>\n       \\<exists>gt bound.\n          mono_matrix_carrier gt def bound delta_mono \\<and>\n          (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "let ?cs = \"map (\\<lambda> (x,y). x - y) xys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xys.\n       \\<forall>x y.\n          (x, y) \\<in> set xys \\<longrightarrow> y < x \\<Longrightarrow>\n       \\<exists>gt bound.\n          mono_matrix_carrier gt def bound delta_mono \\<and>\n          (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "let ?ds = \"def # ?cs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xys.\n       \\<forall>x y.\n          (x, y) \\<in> set xys \\<longrightarrow> y < x \\<Longrightarrow>\n       \\<exists>gt bound.\n          mono_matrix_carrier gt def bound delta_mono \\<and>\n          (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "define d where \"d = Min (set ?ds)\""], ["proof (state)\nthis:\n  d = Min (set (def # map (\\<lambda>(x, y). x - y) xys))\n\ngoal (1 subgoal):\n 1. \\<And>xys.\n       \\<forall>x y.\n          (x, y) \\<in> set xys \\<longrightarrow> y < x \\<Longrightarrow>\n       \\<exists>gt bound.\n          mono_matrix_carrier gt def bound delta_mono \\<and>\n          (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "have d: \"d \\<le> def\" and dcs: \"\\<And> x. x \\<in> set ?cs \\<Longrightarrow> d \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> def &&&\n    (\\<And>x.\n        x \\<in> set (map (\\<lambda>(x, y). x - y) xys) \\<Longrightarrow>\n        d \\<le> x)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (set (def # map (\\<lambda>(x, y). x - y) xys)) \\<le> def &&&\n    (\\<And>x.\n        x \\<in> set (map (\\<lambda>(x, y). x - y) xys) \\<Longrightarrow>\n        Min (set (def # map (\\<lambda>(x, y). x - y) xys)) \\<le> x)", "by auto"], ["proof (state)\nthis:\n  d \\<le> def\n  ?x \\<in> set (map (\\<lambda>(x, y). x - y) xys) \\<Longrightarrow>\n  d \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>xys.\n       \\<forall>x y.\n          (x, y) \\<in> set xys \\<longrightarrow> y < x \\<Longrightarrow>\n       \\<exists>gt bound.\n          mono_matrix_carrier gt def bound delta_mono \\<and>\n          (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "have \"d \\<in> set ?ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<in> set (def # map (\\<lambda>(x, y). x - y) xys)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (set (def # map (\\<lambda>(x, y). x - y) xys))\n    \\<in> set (def # map (\\<lambda>(x, y). x - y) xys)", "by (rule Min_in, auto)"], ["proof (state)\nthis:\n  d \\<in> set (def # map (\\<lambda>(x, y). x - y) xys)\n\ngoal (1 subgoal):\n 1. \\<And>xys.\n       \\<forall>x y.\n          (x, y) \\<in> set xys \\<longrightarrow> y < x \\<Longrightarrow>\n       \\<exists>gt bound.\n          mono_matrix_carrier gt def bound delta_mono \\<and>\n          (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "hence \"d = def \\<or> d \\<in> set ?cs\""], ["proof (prove)\nusing this:\n  d \\<in> set (def # map (\\<lambda>(x, y). x - y) xys)\n\ngoal (1 subgoal):\n 1. d = def \\<or> d \\<in> set (map (\\<lambda>(x, y). x - y) xys)", "by auto"], ["proof (state)\nthis:\n  d = def \\<or> d \\<in> set (map (\\<lambda>(x, y). x - y) xys)\n\ngoal (1 subgoal):\n 1. \\<And>xys.\n       \\<forall>x y.\n          (x, y) \\<in> set xys \\<longrightarrow> y < x \\<Longrightarrow>\n       \\<exists>gt bound.\n          mono_matrix_carrier gt def bound delta_mono \\<and>\n          (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "hence d0: \"d > 0\""], ["proof (prove)\nusing this:\n  d = def \\<or> d \\<in> set (map (\\<lambda>(x, y). x - y) xys)\n\ngoal (1 subgoal):\n 1. (0::'a) < d", "by (cases, insert d0 ass, auto simp: field_simps)"], ["proof (state)\nthis:\n  (0::'a) < d\n\ngoal (1 subgoal):\n 1. \\<And>xys.\n       \\<forall>x y.\n          (x, y) \\<in> set xys \\<longrightarrow> y < x \\<Longrightarrow>\n       \\<exists>gt bound.\n          mono_matrix_carrier gt def bound delta_mono \\<and>\n          (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "show \"\\<exists>gt bound. mono_matrix_carrier gt def bound delta_mono \\<and> (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gt bound.\n       mono_matrix_carrier gt def bound delta_mono \\<and>\n       (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)", "by (intro exI conjI, rule delta_complexity[OF d0 d], insert dcs, force simp: delta_gt_def)"], ["proof (state)\nthis:\n  \\<exists>gt bound.\n     mono_matrix_carrier gt def bound delta_mono \\<and>\n     (\\<forall>x y. (x, y) \\<in> set xys \\<longrightarrow> gt x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Arctic Numbers as Carrier\\<close>"], ["", "lemma arctic_delta_weak_carrier:\n  \"weak_SN_both_mono_ordered_semiring_1 weak_gt_arctic_delta 1 pos_arctic_delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_SN_both_mono_ordered_semiring_1 weak_gt_arctic_delta 1\n     pos_arctic_delta", ".."], ["", "lemma arctic_weak_carrier:\n  \"weak_SN_both_mono_ordered_semiring_1 (>) 1 pos_arctic\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_SN_both_mono_ordered_semiring_1 (\\<lambda>x y. y < x) 1 pos_arctic", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. weak_SN_both_mono_ordered_semiring_1 (\\<lambda>x y. y < x) 1 pos_arctic", "have SN: \"SN_both_mono_ordered_semiring_1 1 (>) pos_arctic\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN_both_mono_ordered_semiring_1 1 (\\<lambda>x y. y < x) pos_arctic", ".."], ["proof (state)\nthis:\n  SN_both_mono_ordered_semiring_1 1 (\\<lambda>x y. y < x) pos_arctic\n\ngoal (1 subgoal):\n 1. weak_SN_both_mono_ordered_semiring_1 (\\<lambda>x y. y < x) 1 pos_arctic", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_SN_both_mono_ordered_semiring_1 (\\<lambda>x y. y < x) 1 pos_arctic", "by (unfold_locales, intro conjI exI, rule SN, auto)"], ["proof (state)\nthis:\n  weak_SN_both_mono_ordered_semiring_1 (\\<lambda>x y. y < x) 1 pos_arctic\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}